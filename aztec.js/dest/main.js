/*! For license information please see main.js.LICENSE.txt */
var e,t,n={1451:(e,t)=>{t.byteLength=function(e){var t=o(e),n=t[0],s=t[1];return 3*(n+s)/4-s},t.toByteArray=function(e){var t,n,a=o(e),i=a[0],l=a[1],c=new r(function(e,t,n){return 3*(t+n)/4-n}(0,i,l)),d=0,u=l>0?i-4:i;for(n=0;n<u;n+=4)t=s[e.charCodeAt(n)]<<18|s[e.charCodeAt(n+1)]<<12|s[e.charCodeAt(n+2)]<<6|s[e.charCodeAt(n+3)],c[d++]=t>>16&255,c[d++]=t>>8&255,c[d++]=255&t;return 2===l&&(t=s[e.charCodeAt(n)]<<2|s[e.charCodeAt(n+1)]>>4,c[d++]=255&t),1===l&&(t=s[e.charCodeAt(n)]<<10|s[e.charCodeAt(n+1)]<<4|s[e.charCodeAt(n+2)]>>2,c[d++]=t>>8&255,c[d++]=255&t),c},t.fromByteArray=function(e){for(var t,s=e.length,r=s%3,a=[],i=16383,o=0,c=s-r;o<c;o+=i)a.push(l(e,o,o+i>c?c:o+i));return 1===r?(t=e[s-1],a.push(n[t>>2]+n[t<<4&63]+"==")):2===r&&(t=(e[s-2]<<8)+e[s-1],a.push(n[t>>10]+n[t>>4&63]+n[t<<2&63]+"=")),a.join("")};for(var n=[],s=[],r="undefined"!=typeof Uint8Array?Uint8Array:Array,a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",i=0;i<64;++i)n[i]=a[i],s[a.charCodeAt(i)]=i;function o(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var n=e.indexOf("=");return-1===n&&(n=t),[n,n===t?0:4-n%4]}function l(e,t,s){for(var r,a,i=[],o=t;o<s;o+=3)r=(e[o]<<16&16711680)+(e[o+1]<<8&65280)+(255&e[o+2]),i.push(n[(a=r)>>18&63]+n[a>>12&63]+n[a>>6&63]+n[63&a]);return i.join("")}s["-".charCodeAt(0)]=62,s["_".charCodeAt(0)]=63},8356:(e,t,n)=>{const s=n(1451),r=n(7930),a="function"==typeof Symbol&&"function"==typeof Symbol.for?Symbol.for("nodejs.util.inspect.custom"):null;t.hp=l,t.IS=50;const i=2147483647;function o(e){if(e>i)throw new RangeError('The value "'+e+'" is invalid for option "size"');const t=new Uint8Array(e);return Object.setPrototypeOf(t,l.prototype),t}function l(e,t,n){if("number"==typeof e){if("string"==typeof t)throw new TypeError('The "string" argument must be of type string. Received type number');return u(e)}return c(e,t,n)}function c(e,t,n){if("string"==typeof e)return function(e,t){if("string"==typeof t&&""!==t||(t="utf8"),!l.isEncoding(t))throw new TypeError("Unknown encoding: "+t);const n=0|_(e,t);let s=o(n);const r=s.write(e,t);return r!==n&&(s=s.slice(0,r)),s}(e,t);if(ArrayBuffer.isView(e))return function(e){if(W(e,Uint8Array)){const t=new Uint8Array(e);return h(t.buffer,t.byteOffset,t.byteLength)}return f(e)}(e);if(null==e)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e);if(W(e,ArrayBuffer)||e&&W(e.buffer,ArrayBuffer))return h(e,t,n);if("undefined"!=typeof SharedArrayBuffer&&(W(e,SharedArrayBuffer)||e&&W(e.buffer,SharedArrayBuffer)))return h(e,t,n);if("number"==typeof e)throw new TypeError('The "value" argument must not be of type number. Received type number');const s=e.valueOf&&e.valueOf();if(null!=s&&s!==e)return l.from(s,t,n);const r=function(e){if(l.isBuffer(e)){const t=0|p(e.length),n=o(t);return 0===n.length||e.copy(n,0,0,t),n}return void 0!==e.length?"number"!=typeof e.length||Z(e.length)?o(0):f(e):"Buffer"===e.type&&Array.isArray(e.data)?f(e.data):void 0}(e);if(r)return r;if("undefined"!=typeof Symbol&&null!=Symbol.toPrimitive&&"function"==typeof e[Symbol.toPrimitive])return l.from(e[Symbol.toPrimitive]("string"),t,n);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e)}function d(e){if("number"!=typeof e)throw new TypeError('"size" argument must be of type number');if(e<0)throw new RangeError('The value "'+e+'" is invalid for option "size"')}function u(e){return d(e),o(e<0?0:0|p(e))}function f(e){const t=e.length<0?0:0|p(e.length),n=o(t);for(let s=0;s<t;s+=1)n[s]=255&e[s];return n}function h(e,t,n){if(t<0||e.byteLength<t)throw new RangeError('"offset" is outside of buffer bounds');if(e.byteLength<t+(n||0))throw new RangeError('"length" is outside of buffer bounds');let s;return s=void 0===t&&void 0===n?new Uint8Array(e):void 0===n?new Uint8Array(e,t):new Uint8Array(e,t,n),Object.setPrototypeOf(s,l.prototype),s}function p(e){if(e>=i)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+i.toString(16)+" bytes");return 0|e}function _(e,t){if(l.isBuffer(e))return e.length;if(ArrayBuffer.isView(e)||W(e,ArrayBuffer))return e.byteLength;if("string"!=typeof e)throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof e);const n=e.length,s=arguments.length>2&&!0===arguments[2];if(!s&&0===n)return 0;let r=!1;for(;;)switch(t){case"ascii":case"latin1":case"binary":return n;case"utf8":case"utf-8":return D(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*n;case"hex":return n>>>1;case"base64":return q(e).length;default:if(r)return s?-1:D(e).length;t=(""+t).toLowerCase(),r=!0}}function m(e,t,n){let s=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return"";if((n>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return P(this,t,n);case"utf8":case"utf-8":return T(this,t,n);case"ascii":return C(this,t,n);case"latin1":case"binary":return z(this,t,n);case"base64":return S(this,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return F(this,t,n);default:if(s)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),s=!0}}function g(e,t,n){const s=e[t];e[t]=e[n],e[n]=s}function b(e,t,n,s,r){if(0===e.length)return-1;if("string"==typeof n?(s=n,n=0):n>2147483647?n=2147483647:n<-2147483648&&(n=-2147483648),Z(n=+n)&&(n=r?0:e.length-1),n<0&&(n=e.length+n),n>=e.length){if(r)return-1;n=e.length-1}else if(n<0){if(!r)return-1;n=0}if("string"==typeof t&&(t=l.from(t,s)),l.isBuffer(t))return 0===t.length?-1:y(e,t,n,s,r);if("number"==typeof t)return t&=255,"function"==typeof Uint8Array.prototype.indexOf?r?Uint8Array.prototype.indexOf.call(e,t,n):Uint8Array.prototype.lastIndexOf.call(e,t,n):y(e,[t],n,s,r);throw new TypeError("val must be string, number or Buffer")}function y(e,t,n,s,r){let a,i=1,o=e.length,l=t.length;if(void 0!==s&&("ucs2"===(s=String(s).toLowerCase())||"ucs-2"===s||"utf16le"===s||"utf-16le"===s)){if(e.length<2||t.length<2)return-1;i=2,o/=2,l/=2,n/=2}function c(e,t){return 1===i?e[t]:e.readUInt16BE(t*i)}if(r){let s=-1;for(a=n;a<o;a++)if(c(e,a)===c(t,-1===s?0:a-s)){if(-1===s&&(s=a),a-s+1===l)return s*i}else-1!==s&&(a-=a-s),s=-1}else for(n+l>o&&(n=o-l),a=n;a>=0;a--){let n=!0;for(let s=0;s<l;s++)if(c(e,a+s)!==c(t,s)){n=!1;break}if(n)return a}return-1}function v(e,t,n,s){n=Number(n)||0;const r=e.length-n;s?(s=Number(s))>r&&(s=r):s=r;const a=t.length;let i;for(s>a/2&&(s=a/2),i=0;i<s;++i){const s=parseInt(t.substr(2*i,2),16);if(Z(s))return i;e[n+i]=s}return i}function w(e,t,n,s){return K(D(t,e.length-n),e,n,s)}function A(e,t,n,s){return K(function(e){const t=[];for(let n=0;n<e.length;++n)t.push(255&e.charCodeAt(n));return t}(t),e,n,s)}function E(e,t,n,s){return K(q(t),e,n,s)}function x(e,t,n,s){return K(function(e,t){let n,s,r;const a=[];for(let i=0;i<e.length&&!((t-=2)<0);++i)n=e.charCodeAt(i),s=n>>8,r=n%256,a.push(r),a.push(s);return a}(t,e.length-n),e,n,s)}function S(e,t,n){return 0===t&&n===e.length?s.fromByteArray(e):s.fromByteArray(e.slice(t,n))}function T(e,t,n){n=Math.min(e.length,n);const s=[];let r=t;for(;r<n;){const t=e[r];let a=null,i=t>239?4:t>223?3:t>191?2:1;if(r+i<=n){let n,s,o,l;switch(i){case 1:t<128&&(a=t);break;case 2:n=e[r+1],128==(192&n)&&(l=(31&t)<<6|63&n,l>127&&(a=l));break;case 3:n=e[r+1],s=e[r+2],128==(192&n)&&128==(192&s)&&(l=(15&t)<<12|(63&n)<<6|63&s,l>2047&&(l<55296||l>57343)&&(a=l));break;case 4:n=e[r+1],s=e[r+2],o=e[r+3],128==(192&n)&&128==(192&s)&&128==(192&o)&&(l=(15&t)<<18|(63&n)<<12|(63&s)<<6|63&o,l>65535&&l<1114112&&(a=l))}}null===a?(a=65533,i=1):a>65535&&(a-=65536,s.push(a>>>10&1023|55296),a=56320|1023&a),s.push(a),r+=i}return function(e){const t=e.length;if(t<=k)return String.fromCharCode.apply(String,e);let n="",s=0;for(;s<t;)n+=String.fromCharCode.apply(String,e.slice(s,s+=k));return n}(s)}l.TYPED_ARRAY_SUPPORT=function(){try{const e=new Uint8Array(1),t={foo:function(){return 42}};return Object.setPrototypeOf(t,Uint8Array.prototype),Object.setPrototypeOf(e,t),42===e.foo()}catch(e){return!1}}(),l.TYPED_ARRAY_SUPPORT||"undefined"==typeof console||"function"!=typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(l.prototype,"parent",{enumerable:!0,get:function(){if(l.isBuffer(this))return this.buffer}}),Object.defineProperty(l.prototype,"offset",{enumerable:!0,get:function(){if(l.isBuffer(this))return this.byteOffset}}),l.poolSize=8192,l.from=function(e,t,n){return c(e,t,n)},Object.setPrototypeOf(l.prototype,Uint8Array.prototype),Object.setPrototypeOf(l,Uint8Array),l.alloc=function(e,t,n){return function(e,t,n){return d(e),e<=0?o(e):void 0!==t?"string"==typeof n?o(e).fill(t,n):o(e).fill(t):o(e)}(e,t,n)},l.allocUnsafe=function(e){return u(e)},l.allocUnsafeSlow=function(e){return u(e)},l.isBuffer=function(e){return null!=e&&!0===e._isBuffer&&e!==l.prototype},l.compare=function(e,t){if(W(e,Uint8Array)&&(e=l.from(e,e.offset,e.byteLength)),W(t,Uint8Array)&&(t=l.from(t,t.offset,t.byteLength)),!l.isBuffer(e)||!l.isBuffer(t))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(e===t)return 0;let n=e.length,s=t.length;for(let r=0,a=Math.min(n,s);r<a;++r)if(e[r]!==t[r]){n=e[r],s=t[r];break}return n<s?-1:s<n?1:0},l.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},l.concat=function(e,t){if(!Array.isArray(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return l.alloc(0);let n;if(void 0===t)for(t=0,n=0;n<e.length;++n)t+=e[n].length;const s=l.allocUnsafe(t);let r=0;for(n=0;n<e.length;++n){let t=e[n];if(W(t,Uint8Array))r+t.length>s.length?(l.isBuffer(t)||(t=l.from(t)),t.copy(s,r)):Uint8Array.prototype.set.call(s,t,r);else{if(!l.isBuffer(t))throw new TypeError('"list" argument must be an Array of Buffers');t.copy(s,r)}r+=t.length}return s},l.byteLength=_,l.prototype._isBuffer=!0,l.prototype.swap16=function(){const e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let t=0;t<e;t+=2)g(this,t,t+1);return this},l.prototype.swap32=function(){const e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let t=0;t<e;t+=4)g(this,t,t+3),g(this,t+1,t+2);return this},l.prototype.swap64=function(){const e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let t=0;t<e;t+=8)g(this,t,t+7),g(this,t+1,t+6),g(this,t+2,t+5),g(this,t+3,t+4);return this},l.prototype.toString=function(){const e=this.length;return 0===e?"":0===arguments.length?T(this,0,e):m.apply(this,arguments)},l.prototype.toLocaleString=l.prototype.toString,l.prototype.equals=function(e){if(!l.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===l.compare(this,e)},l.prototype.inspect=function(){let e="";const n=t.IS;return e=this.toString("hex",0,n).replace(/(.{2})/g,"$1 ").trim(),this.length>n&&(e+=" ... "),"<Buffer "+e+">"},a&&(l.prototype[a]=l.prototype.inspect),l.prototype.compare=function(e,t,n,s,r){if(W(e,Uint8Array)&&(e=l.from(e,e.offset,e.byteLength)),!l.isBuffer(e))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(void 0===t&&(t=0),void 0===n&&(n=e?e.length:0),void 0===s&&(s=0),void 0===r&&(r=this.length),t<0||n>e.length||s<0||r>this.length)throw new RangeError("out of range index");if(s>=r&&t>=n)return 0;if(s>=r)return-1;if(t>=n)return 1;if(this===e)return 0;let a=(r>>>=0)-(s>>>=0),i=(n>>>=0)-(t>>>=0);const o=Math.min(a,i),c=this.slice(s,r),d=e.slice(t,n);for(let e=0;e<o;++e)if(c[e]!==d[e]){a=c[e],i=d[e];break}return a<i?-1:i<a?1:0},l.prototype.includes=function(e,t,n){return-1!==this.indexOf(e,t,n)},l.prototype.indexOf=function(e,t,n){return b(this,e,t,n,!0)},l.prototype.lastIndexOf=function(e,t,n){return b(this,e,t,n,!1)},l.prototype.write=function(e,t,n,s){if(void 0===t)s="utf8",n=this.length,t=0;else if(void 0===n&&"string"==typeof t)s=t,n=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t>>>=0,isFinite(n)?(n>>>=0,void 0===s&&(s="utf8")):(s=n,n=void 0)}const r=this.length-t;if((void 0===n||n>r)&&(n=r),e.length>0&&(n<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");s||(s="utf8");let a=!1;for(;;)switch(s){case"hex":return v(this,e,t,n);case"utf8":case"utf-8":return w(this,e,t,n);case"ascii":case"latin1":case"binary":return A(this,e,t,n);case"base64":return E(this,e,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return x(this,e,t,n);default:if(a)throw new TypeError("Unknown encoding: "+s);s=(""+s).toLowerCase(),a=!0}},l.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};const k=4096;function C(e,t,n){let s="";n=Math.min(e.length,n);for(let r=t;r<n;++r)s+=String.fromCharCode(127&e[r]);return s}function z(e,t,n){let s="";n=Math.min(e.length,n);for(let r=t;r<n;++r)s+=String.fromCharCode(e[r]);return s}function P(e,t,n){const s=e.length;(!t||t<0)&&(t=0),(!n||n<0||n>s)&&(n=s);let r="";for(let s=t;s<n;++s)r+=V[e[s]];return r}function F(e,t,n){const s=e.slice(t,n);let r="";for(let e=0;e<s.length-1;e+=2)r+=String.fromCharCode(s[e]+256*s[e+1]);return r}function N(e,t,n){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>n)throw new RangeError("Trying to access beyond buffer length")}function G(e,t,n,s,r,a){if(!l.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>r||t<a)throw new RangeError('"value" argument is out of bounds');if(n+s>e.length)throw new RangeError("Index out of range")}function L(e,t,n,s,r){I(t,s,r,e,n,7);let a=Number(t&BigInt(4294967295));e[n++]=a,a>>=8,e[n++]=a,a>>=8,e[n++]=a,a>>=8,e[n++]=a;let i=Number(t>>BigInt(32)&BigInt(4294967295));return e[n++]=i,i>>=8,e[n++]=i,i>>=8,e[n++]=i,i>>=8,e[n++]=i,n}function O(e,t,n,s,r){I(t,s,r,e,n,7);let a=Number(t&BigInt(4294967295));e[n+7]=a,a>>=8,e[n+6]=a,a>>=8,e[n+5]=a,a>>=8,e[n+4]=a;let i=Number(t>>BigInt(32)&BigInt(4294967295));return e[n+3]=i,i>>=8,e[n+2]=i,i>>=8,e[n+1]=i,i>>=8,e[n]=i,n+8}function R(e,t,n,s,r,a){if(n+s>e.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("Index out of range")}function M(e,t,n,s,a){return t=+t,n>>>=0,a||R(e,0,n,4),r.write(e,t,n,s,23,4),n+4}function B(e,t,n,s,a){return t=+t,n>>>=0,a||R(e,0,n,8),r.write(e,t,n,s,52,8),n+8}l.prototype.slice=function(e,t){const n=this.length;(e=~~e)<0?(e+=n)<0&&(e=0):e>n&&(e=n),(t=void 0===t?n:~~t)<0?(t+=n)<0&&(t=0):t>n&&(t=n),t<e&&(t=e);const s=this.subarray(e,t);return Object.setPrototypeOf(s,l.prototype),s},l.prototype.readUintLE=l.prototype.readUIntLE=function(e,t,n){e>>>=0,t>>>=0,n||N(e,t,this.length);let s=this[e],r=1,a=0;for(;++a<t&&(r*=256);)s+=this[e+a]*r;return s},l.prototype.readUintBE=l.prototype.readUIntBE=function(e,t,n){e>>>=0,t>>>=0,n||N(e,t,this.length);let s=this[e+--t],r=1;for(;t>0&&(r*=256);)s+=this[e+--t]*r;return s},l.prototype.readUint8=l.prototype.readUInt8=function(e,t){return e>>>=0,t||N(e,1,this.length),this[e]},l.prototype.readUint16LE=l.prototype.readUInt16LE=function(e,t){return e>>>=0,t||N(e,2,this.length),this[e]|this[e+1]<<8},l.prototype.readUint16BE=l.prototype.readUInt16BE=function(e,t){return e>>>=0,t||N(e,2,this.length),this[e]<<8|this[e+1]},l.prototype.readUint32LE=l.prototype.readUInt32LE=function(e,t){return e>>>=0,t||N(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},l.prototype.readUint32BE=l.prototype.readUInt32BE=function(e,t){return e>>>=0,t||N(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},l.prototype.readBigUInt64LE=Q((function(e){X(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||U(e,this.length-8);const s=t+256*this[++e]+65536*this[++e]+this[++e]*2**24,r=this[++e]+256*this[++e]+65536*this[++e]+n*2**24;return BigInt(s)+(BigInt(r)<<BigInt(32))})),l.prototype.readBigUInt64BE=Q((function(e){X(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||U(e,this.length-8);const s=t*2**24+65536*this[++e]+256*this[++e]+this[++e],r=this[++e]*2**24+65536*this[++e]+256*this[++e]+n;return(BigInt(s)<<BigInt(32))+BigInt(r)})),l.prototype.readIntLE=function(e,t,n){e>>>=0,t>>>=0,n||N(e,t,this.length);let s=this[e],r=1,a=0;for(;++a<t&&(r*=256);)s+=this[e+a]*r;return r*=128,s>=r&&(s-=Math.pow(2,8*t)),s},l.prototype.readIntBE=function(e,t,n){e>>>=0,t>>>=0,n||N(e,t,this.length);let s=t,r=1,a=this[e+--s];for(;s>0&&(r*=256);)a+=this[e+--s]*r;return r*=128,a>=r&&(a-=Math.pow(2,8*t)),a},l.prototype.readInt8=function(e,t){return e>>>=0,t||N(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},l.prototype.readInt16LE=function(e,t){e>>>=0,t||N(e,2,this.length);const n=this[e]|this[e+1]<<8;return 32768&n?4294901760|n:n},l.prototype.readInt16BE=function(e,t){e>>>=0,t||N(e,2,this.length);const n=this[e+1]|this[e]<<8;return 32768&n?4294901760|n:n},l.prototype.readInt32LE=function(e,t){return e>>>=0,t||N(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},l.prototype.readInt32BE=function(e,t){return e>>>=0,t||N(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},l.prototype.readBigInt64LE=Q((function(e){X(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||U(e,this.length-8);const s=this[e+4]+256*this[e+5]+65536*this[e+6]+(n<<24);return(BigInt(s)<<BigInt(32))+BigInt(t+256*this[++e]+65536*this[++e]+this[++e]*2**24)})),l.prototype.readBigInt64BE=Q((function(e){X(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||U(e,this.length-8);const s=(t<<24)+65536*this[++e]+256*this[++e]+this[++e];return(BigInt(s)<<BigInt(32))+BigInt(this[++e]*2**24+65536*this[++e]+256*this[++e]+n)})),l.prototype.readFloatLE=function(e,t){return e>>>=0,t||N(e,4,this.length),r.read(this,e,!0,23,4)},l.prototype.readFloatBE=function(e,t){return e>>>=0,t||N(e,4,this.length),r.read(this,e,!1,23,4)},l.prototype.readDoubleLE=function(e,t){return e>>>=0,t||N(e,8,this.length),r.read(this,e,!0,52,8)},l.prototype.readDoubleBE=function(e,t){return e>>>=0,t||N(e,8,this.length),r.read(this,e,!1,52,8)},l.prototype.writeUintLE=l.prototype.writeUIntLE=function(e,t,n,s){e=+e,t>>>=0,n>>>=0,s||G(this,e,t,n,Math.pow(2,8*n)-1,0);let r=1,a=0;for(this[t]=255&e;++a<n&&(r*=256);)this[t+a]=e/r&255;return t+n},l.prototype.writeUintBE=l.prototype.writeUIntBE=function(e,t,n,s){e=+e,t>>>=0,n>>>=0,s||G(this,e,t,n,Math.pow(2,8*n)-1,0);let r=n-1,a=1;for(this[t+r]=255&e;--r>=0&&(a*=256);)this[t+r]=e/a&255;return t+n},l.prototype.writeUint8=l.prototype.writeUInt8=function(e,t,n){return e=+e,t>>>=0,n||G(this,e,t,1,255,0),this[t]=255&e,t+1},l.prototype.writeUint16LE=l.prototype.writeUInt16LE=function(e,t,n){return e=+e,t>>>=0,n||G(this,e,t,2,65535,0),this[t]=255&e,this[t+1]=e>>>8,t+2},l.prototype.writeUint16BE=l.prototype.writeUInt16BE=function(e,t,n){return e=+e,t>>>=0,n||G(this,e,t,2,65535,0),this[t]=e>>>8,this[t+1]=255&e,t+2},l.prototype.writeUint32LE=l.prototype.writeUInt32LE=function(e,t,n){return e=+e,t>>>=0,n||G(this,e,t,4,4294967295,0),this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e,t+4},l.prototype.writeUint32BE=l.prototype.writeUInt32BE=function(e,t,n){return e=+e,t>>>=0,n||G(this,e,t,4,4294967295,0),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},l.prototype.writeBigUInt64LE=Q((function(e,t=0){return L(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))})),l.prototype.writeBigUInt64BE=Q((function(e,t=0){return O(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))})),l.prototype.writeIntLE=function(e,t,n,s){if(e=+e,t>>>=0,!s){const s=Math.pow(2,8*n-1);G(this,e,t,n,s-1,-s)}let r=0,a=1,i=0;for(this[t]=255&e;++r<n&&(a*=256);)e<0&&0===i&&0!==this[t+r-1]&&(i=1),this[t+r]=(e/a|0)-i&255;return t+n},l.prototype.writeIntBE=function(e,t,n,s){if(e=+e,t>>>=0,!s){const s=Math.pow(2,8*n-1);G(this,e,t,n,s-1,-s)}let r=n-1,a=1,i=0;for(this[t+r]=255&e;--r>=0&&(a*=256);)e<0&&0===i&&0!==this[t+r+1]&&(i=1),this[t+r]=(e/a|0)-i&255;return t+n},l.prototype.writeInt8=function(e,t,n){return e=+e,t>>>=0,n||G(this,e,t,1,127,-128),e<0&&(e=255+e+1),this[t]=255&e,t+1},l.prototype.writeInt16LE=function(e,t,n){return e=+e,t>>>=0,n||G(this,e,t,2,32767,-32768),this[t]=255&e,this[t+1]=e>>>8,t+2},l.prototype.writeInt16BE=function(e,t,n){return e=+e,t>>>=0,n||G(this,e,t,2,32767,-32768),this[t]=e>>>8,this[t+1]=255&e,t+2},l.prototype.writeInt32LE=function(e,t,n){return e=+e,t>>>=0,n||G(this,e,t,4,2147483647,-2147483648),this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24,t+4},l.prototype.writeInt32BE=function(e,t,n){return e=+e,t>>>=0,n||G(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},l.prototype.writeBigInt64LE=Q((function(e,t=0){return L(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),l.prototype.writeBigInt64BE=Q((function(e,t=0){return O(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),l.prototype.writeFloatLE=function(e,t,n){return M(this,e,t,!0,n)},l.prototype.writeFloatBE=function(e,t,n){return M(this,e,t,!1,n)},l.prototype.writeDoubleLE=function(e,t,n){return B(this,e,t,!0,n)},l.prototype.writeDoubleBE=function(e,t,n){return B(this,e,t,!1,n)},l.prototype.copy=function(e,t,n,s){if(!l.isBuffer(e))throw new TypeError("argument should be a Buffer");if(n||(n=0),s||0===s||(s=this.length),t>=e.length&&(t=e.length),t||(t=0),s>0&&s<n&&(s=n),s===n)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(n<0||n>=this.length)throw new RangeError("Index out of range");if(s<0)throw new RangeError("sourceEnd out of bounds");s>this.length&&(s=this.length),e.length-t<s-n&&(s=e.length-t+n);const r=s-n;return this===e&&"function"==typeof Uint8Array.prototype.copyWithin?this.copyWithin(t,n,s):Uint8Array.prototype.set.call(e,this.subarray(n,s),t),r},l.prototype.fill=function(e,t,n,s){if("string"==typeof e){if("string"==typeof t?(s=t,t=0,n=this.length):"string"==typeof n&&(s=n,n=this.length),void 0!==s&&"string"!=typeof s)throw new TypeError("encoding must be a string");if("string"==typeof s&&!l.isEncoding(s))throw new TypeError("Unknown encoding: "+s);if(1===e.length){const t=e.charCodeAt(0);("utf8"===s&&t<128||"latin1"===s)&&(e=t)}}else"number"==typeof e?e&=255:"boolean"==typeof e&&(e=Number(e));if(t<0||this.length<t||this.length<n)throw new RangeError("Out of range index");if(n<=t)return this;let r;if(t>>>=0,n=void 0===n?this.length:n>>>0,e||(e=0),"number"==typeof e)for(r=t;r<n;++r)this[r]=e;else{const a=l.isBuffer(e)?e:l.from(e,s),i=a.length;if(0===i)throw new TypeError('The value "'+e+'" is invalid for argument "value"');for(r=0;r<n-t;++r)this[r+t]=a[r%i]}return this};const Y={};function j(e,t,n){Y[e]=class extends n{constructor(){super(),Object.defineProperty(this,"message",{value:t.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${e}]`,this.stack,delete this.name}get code(){return e}set code(e){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:e,writable:!0})}toString(){return`${this.name} [${e}]: ${this.message}`}}}function H(e){let t="",n=e.length;const s="-"===e[0]?1:0;for(;n>=s+4;n-=3)t=`_${e.slice(n-3,n)}${t}`;return`${e.slice(0,n)}${t}`}function I(e,t,n,s,r,a){if(e>n||e<t){const s="bigint"==typeof t?"n":"";let r;throw r=a>3?0===t||t===BigInt(0)?`>= 0${s} and < 2${s} ** ${8*(a+1)}${s}`:`>= -(2${s} ** ${8*(a+1)-1}${s}) and < 2 ** ${8*(a+1)-1}${s}`:`>= ${t}${s} and <= ${n}${s}`,new Y.ERR_OUT_OF_RANGE("value",r,e)}!function(e,t,n){X(t,"offset"),void 0!==e[t]&&void 0!==e[t+n]||U(t,e.length-(n+1))}(s,r,a)}function X(e,t){if("number"!=typeof e)throw new Y.ERR_INVALID_ARG_TYPE(t,"number",e)}function U(e,t,n){if(Math.floor(e)!==e)throw X(e,n),new Y.ERR_OUT_OF_RANGE(n||"offset","an integer",e);if(t<0)throw new Y.ERR_BUFFER_OUT_OF_BOUNDS;throw new Y.ERR_OUT_OF_RANGE(n||"offset",`>= ${n?1:0} and <= ${t}`,e)}j("ERR_BUFFER_OUT_OF_BOUNDS",(function(e){return e?`${e} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"}),RangeError),j("ERR_INVALID_ARG_TYPE",(function(e,t){return`The "${e}" argument must be of type number. Received type ${typeof t}`}),TypeError),j("ERR_OUT_OF_RANGE",(function(e,t,n){let s=`The value of "${e}" is out of range.`,r=n;return Number.isInteger(n)&&Math.abs(n)>2**32?r=H(String(n)):"bigint"==typeof n&&(r=String(n),(n>BigInt(2)**BigInt(32)||n<-(BigInt(2)**BigInt(32)))&&(r=H(r)),r+="n"),s+=` It must be ${t}. Received ${r}`,s}),RangeError);const J=/[^+/0-9A-Za-z-_]/g;function D(e,t){let n;t=t||1/0;const s=e.length;let r=null;const a=[];for(let i=0;i<s;++i){if(n=e.charCodeAt(i),n>55295&&n<57344){if(!r){if(n>56319){(t-=3)>-1&&a.push(239,191,189);continue}if(i+1===s){(t-=3)>-1&&a.push(239,191,189);continue}r=n;continue}if(n<56320){(t-=3)>-1&&a.push(239,191,189),r=n;continue}n=65536+(r-55296<<10|n-56320)}else r&&(t-=3)>-1&&a.push(239,191,189);if(r=null,n<128){if((t-=1)<0)break;a.push(n)}else if(n<2048){if((t-=2)<0)break;a.push(n>>6|192,63&n|128)}else if(n<65536){if((t-=3)<0)break;a.push(n>>12|224,n>>6&63|128,63&n|128)}else{if(!(n<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;a.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128)}}return a}function q(e){return s.toByteArray(function(e){if((e=(e=e.split("=")[0]).trim().replace(J,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function K(e,t,n,s){let r;for(r=0;r<s&&!(r+n>=t.length||r>=e.length);++r)t[r+n]=e[r];return r}function W(e,t){return e instanceof t||null!=e&&null!=e.constructor&&null!=e.constructor.name&&e.constructor.name===t.name}function Z(e){return e!=e}const V=function(){const e="0123456789abcdef",t=new Array(256);for(let n=0;n<16;++n){const s=16*n;for(let r=0;r<16;++r)t[s+r]=e[n]+e[r]}return t}();function Q(e){return"undefined"==typeof BigInt?$:e}function $(){throw new Error("BigInt not supported")}},7930:(e,t)=>{t.read=function(e,t,n,s,r){var a,i,o=8*r-s-1,l=(1<<o)-1,c=l>>1,d=-7,u=n?r-1:0,f=n?-1:1,h=e[t+u];for(u+=f,a=h&(1<<-d)-1,h>>=-d,d+=o;d>0;a=256*a+e[t+u],u+=f,d-=8);for(i=a&(1<<-d)-1,a>>=-d,d+=s;d>0;i=256*i+e[t+u],u+=f,d-=8);if(0===a)a=1-c;else{if(a===l)return i?NaN:1/0*(h?-1:1);i+=Math.pow(2,s),a-=c}return(h?-1:1)*i*Math.pow(2,a-s)},t.write=function(e,t,n,s,r,a){var i,o,l,c=8*a-r-1,d=(1<<c)-1,u=d>>1,f=23===r?Math.pow(2,-24)-Math.pow(2,-77):0,h=s?0:a-1,p=s?1:-1,_=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(o=isNaN(t)?1:0,i=d):(i=Math.floor(Math.log(t)/Math.LN2),t*(l=Math.pow(2,-i))<1&&(i--,l*=2),(t+=i+u>=1?f/l:f*Math.pow(2,1-u))*l>=2&&(i++,l/=2),i+u>=d?(o=0,i=d):i+u>=1?(o=(t*l-1)*Math.pow(2,r),i+=u):(o=t*Math.pow(2,u-1)*Math.pow(2,r),i=0));r>=8;e[n+h]=255&o,h+=p,o/=256,r-=8);for(i=i<<r|o,c+=r;c>0;e[n+h]=255&i,h+=p,i/=256,c-=8);e[n+h-p]|=128*_}},7322:(e,t)=>{t.byteLength=function(e){var t=o(e),n=t[0],s=t[1];return 3*(n+s)/4-s},t.toByteArray=function(e){var t,n,a=o(e),i=a[0],l=a[1],c=new r(function(e,t,n){return 3*(t+n)/4-n}(0,i,l)),d=0,u=l>0?i-4:i;for(n=0;n<u;n+=4)t=s[e.charCodeAt(n)]<<18|s[e.charCodeAt(n+1)]<<12|s[e.charCodeAt(n+2)]<<6|s[e.charCodeAt(n+3)],c[d++]=t>>16&255,c[d++]=t>>8&255,c[d++]=255&t;return 2===l&&(t=s[e.charCodeAt(n)]<<2|s[e.charCodeAt(n+1)]>>4,c[d++]=255&t),1===l&&(t=s[e.charCodeAt(n)]<<10|s[e.charCodeAt(n+1)]<<4|s[e.charCodeAt(n+2)]>>2,c[d++]=t>>8&255,c[d++]=255&t),c},t.fromByteArray=function(e){for(var t,s=e.length,r=s%3,a=[],i=16383,o=0,c=s-r;o<c;o+=i)a.push(l(e,o,o+i>c?c:o+i));return 1===r?(t=e[s-1],a.push(n[t>>2]+n[t<<4&63]+"==")):2===r&&(t=(e[s-2]<<8)+e[s-1],a.push(n[t>>10]+n[t>>4&63]+n[t<<2&63]+"=")),a.join("")};for(var n=[],s=[],r="undefined"!=typeof Uint8Array?Uint8Array:Array,a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",i=0;i<64;++i)n[i]=a[i],s[a.charCodeAt(i)]=i;function o(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var n=e.indexOf("=");return-1===n&&(n=t),[n,n===t?0:4-n%4]}function l(e,t,s){for(var r,a,i=[],o=t;o<s;o+=3)r=(e[o]<<16&16711680)+(e[o+1]<<8&65280)+(255&e[o+2]),i.push(n[(a=r)>>18&63]+n[a>>12&63]+n[a>>6&63]+n[63&a]);return i.join("")}s["-".charCodeAt(0)]=62,s["_".charCodeAt(0)]=63},5706:(e,t,n)=>{var s=n(1817).Buffer;function r(e){s.isBuffer(e)||(e=s.from(e));for(var t=e.length/4|0,n=new Array(t),r=0;r<t;r++)n[r]=e.readUInt32BE(4*r);return n}function a(e){for(;0<e.length;e++)e[0]=0}function i(e,t,n,s,r){for(var a,i,o,l,c=n[0],d=n[1],u=n[2],f=n[3],h=e[0]^t[0],p=e[1]^t[1],_=e[2]^t[2],m=e[3]^t[3],g=4,b=1;b<r;b++)a=c[h>>>24]^d[p>>>16&255]^u[_>>>8&255]^f[255&m]^t[g++],i=c[p>>>24]^d[_>>>16&255]^u[m>>>8&255]^f[255&h]^t[g++],o=c[_>>>24]^d[m>>>16&255]^u[h>>>8&255]^f[255&p]^t[g++],l=c[m>>>24]^d[h>>>16&255]^u[p>>>8&255]^f[255&_]^t[g++],h=a,p=i,_=o,m=l;return a=(s[h>>>24]<<24|s[p>>>16&255]<<16|s[_>>>8&255]<<8|s[255&m])^t[g++],i=(s[p>>>24]<<24|s[_>>>16&255]<<16|s[m>>>8&255]<<8|s[255&h])^t[g++],o=(s[_>>>24]<<24|s[m>>>16&255]<<16|s[h>>>8&255]<<8|s[255&p])^t[g++],l=(s[m>>>24]<<24|s[h>>>16&255]<<16|s[p>>>8&255]<<8|s[255&_])^t[g++],[a>>>=0,i>>>=0,o>>>=0,l>>>=0]}var o=[0,1,2,4,8,16,32,64,128,27,54],l=function(){for(var e=new Array(256),t=0;t<256;t++)e[t]=t<128?t<<1:t<<1^283;for(var n=[],s=[],r=[[],[],[],[]],a=[[],[],[],[]],i=0,o=0,l=0;l<256;++l){var c=o^o<<1^o<<2^o<<3^o<<4;c=c>>>8^255&c^99,n[i]=c,s[c]=i;var d=e[i],u=e[d],f=e[u],h=257*e[c]^16843008*c;r[0][i]=h<<24|h>>>8,r[1][i]=h<<16|h>>>16,r[2][i]=h<<8|h>>>24,r[3][i]=h,h=16843009*f^65537*u^257*d^16843008*i,a[0][c]=h<<24|h>>>8,a[1][c]=h<<16|h>>>16,a[2][c]=h<<8|h>>>24,a[3][c]=h,0===i?i=o=1:(i=d^e[e[e[f^d]]],o^=e[e[o]])}return{SBOX:n,INV_SBOX:s,SUB_MIX:r,INV_SUB_MIX:a}}();function c(e){this._key=r(e),this._reset()}c.blockSize=16,c.keySize=32,c.prototype.blockSize=c.blockSize,c.prototype.keySize=c.keySize,c.prototype._reset=function(){for(var e=this._key,t=e.length,n=t+6,s=4*(n+1),r=[],a=0;a<t;a++)r[a]=e[a];for(a=t;a<s;a++){var i=r[a-1];a%t==0?(i=i<<8|i>>>24,i=l.SBOX[i>>>24]<<24|l.SBOX[i>>>16&255]<<16|l.SBOX[i>>>8&255]<<8|l.SBOX[255&i],i^=o[a/t|0]<<24):t>6&&a%t==4&&(i=l.SBOX[i>>>24]<<24|l.SBOX[i>>>16&255]<<16|l.SBOX[i>>>8&255]<<8|l.SBOX[255&i]),r[a]=r[a-t]^i}for(var c=[],d=0;d<s;d++){var u=s-d,f=r[u-(d%4?0:4)];c[d]=d<4||u<=4?f:l.INV_SUB_MIX[0][l.SBOX[f>>>24]]^l.INV_SUB_MIX[1][l.SBOX[f>>>16&255]]^l.INV_SUB_MIX[2][l.SBOX[f>>>8&255]]^l.INV_SUB_MIX[3][l.SBOX[255&f]]}this._nRounds=n,this._keySchedule=r,this._invKeySchedule=c},c.prototype.encryptBlockRaw=function(e){return i(e=r(e),this._keySchedule,l.SUB_MIX,l.SBOX,this._nRounds)},c.prototype.encryptBlock=function(e){var t=this.encryptBlockRaw(e),n=s.allocUnsafe(16);return n.writeUInt32BE(t[0],0),n.writeUInt32BE(t[1],4),n.writeUInt32BE(t[2],8),n.writeUInt32BE(t[3],12),n},c.prototype.decryptBlock=function(e){var t=(e=r(e))[1];e[1]=e[3],e[3]=t;var n=i(e,this._invKeySchedule,l.INV_SUB_MIX,l.INV_SBOX,this._nRounds),a=s.allocUnsafe(16);return a.writeUInt32BE(n[0],0),a.writeUInt32BE(n[3],4),a.writeUInt32BE(n[2],8),a.writeUInt32BE(n[1],12),a},c.prototype.scrub=function(){a(this._keySchedule),a(this._invKeySchedule),a(this._key)},e.exports.AES=c},8856:(e,t,n)=>{var s=n(5706),r=n(1817).Buffer,a=n(7444),i=n(198),o=n(9120),l=n(755),c=n(5366);function d(e,t,n,i){a.call(this);var l=r.alloc(4,0);this._cipher=new s.AES(t);var d=this._cipher.encryptBlock(l);this._ghash=new o(d),n=function(e,t,n){if(12===t.length)return e._finID=r.concat([t,r.from([0,0,0,1])]),r.concat([t,r.from([0,0,0,2])]);var s=new o(n),a=t.length,i=a%16;s.update(t),i&&(i=16-i,s.update(r.alloc(i,0))),s.update(r.alloc(8,0));var l=8*a,d=r.alloc(8);d.writeUIntBE(l,0,8),s.update(d),e._finID=s.state;var u=r.from(e._finID);return c(u),u}(this,n,d),this._prev=r.from(n),this._cache=r.allocUnsafe(0),this._secCache=r.allocUnsafe(0),this._decrypt=i,this._alen=0,this._len=0,this._mode=e,this._authTag=null,this._called=!1}i(d,a),d.prototype._update=function(e){if(!this._called&&this._alen){var t=16-this._alen%16;t<16&&(t=r.alloc(t,0),this._ghash.update(t))}this._called=!0;var n=this._mode.encrypt(this,e);return this._decrypt?this._ghash.update(e):this._ghash.update(n),this._len+=e.length,n},d.prototype._final=function(){if(this._decrypt&&!this._authTag)throw new Error("Unsupported state or unable to authenticate data");var e=l(this._ghash.final(8*this._alen,8*this._len),this._cipher.encryptBlock(this._finID));if(this._decrypt&&function(e,t){var n=0;e.length!==t.length&&n++;for(var s=Math.min(e.length,t.length),r=0;r<s;++r)n+=e[r]^t[r];return n}(e,this._authTag))throw new Error("Unsupported state or unable to authenticate data");this._authTag=e,this._cipher.scrub()},d.prototype.getAuthTag=function(){if(this._decrypt||!r.isBuffer(this._authTag))throw new Error("Attempting to get auth tag in unsupported state");return this._authTag},d.prototype.setAuthTag=function(e){if(!this._decrypt)throw new Error("Attempting to set auth tag in unsupported state");this._authTag=e},d.prototype.setAAD=function(e){if(this._called)throw new Error("Attempting to set AAD in unsupported state");this._ghash.update(e),this._alen+=e.length},e.exports=d},2005:(e,t,n)=>{var s=n(2939),r=n(5039),a=n(9543);t.createCipher=t.Cipher=s.createCipher,t.createCipheriv=t.Cipheriv=s.createCipheriv,t.createDecipher=t.Decipher=r.createDecipher,t.createDecipheriv=t.Decipheriv=r.createDecipheriv,t.listCiphers=t.getCiphers=function(){return Object.keys(a)}},5039:(e,t,n)=>{var s=n(8856),r=n(1817).Buffer,a=n(4646),i=n(8502),o=n(7444),l=n(5706),c=n(586);function d(e,t,n){o.call(this),this._cache=new u,this._last=void 0,this._cipher=new l.AES(t),this._prev=r.from(n),this._mode=e,this._autopadding=!0}function u(){this.cache=r.allocUnsafe(0)}function f(e,t,n){var o=a[e.toLowerCase()];if(!o)throw new TypeError("invalid suite type");if("string"==typeof n&&(n=r.from(n)),"GCM"!==o.mode&&n.length!==o.iv)throw new TypeError("invalid iv length "+n.length);if("string"==typeof t&&(t=r.from(t)),t.length!==o.key/8)throw new TypeError("invalid key length "+t.length);return"stream"===o.type?new i(o.module,t,n,!0):"auth"===o.type?new s(o.module,t,n,!0):new d(o.module,t,n)}n(198)(d,o),d.prototype._update=function(e){var t,n;this._cache.add(e);for(var s=[];t=this._cache.get(this._autopadding);)n=this._mode.decrypt(this,t),s.push(n);return r.concat(s)},d.prototype._final=function(){var e=this._cache.flush();if(this._autopadding)return function(e){var t=e[15];if(t<1||t>16)throw new Error("unable to decrypt data");for(var n=-1;++n<t;)if(e[n+(16-t)]!==t)throw new Error("unable to decrypt data");if(16!==t)return e.slice(0,16-t)}(this._mode.decrypt(this,e));if(e)throw new Error("data not multiple of block length")},d.prototype.setAutoPadding=function(e){return this._autopadding=!!e,this},u.prototype.add=function(e){this.cache=r.concat([this.cache,e])},u.prototype.get=function(e){var t;if(e){if(this.cache.length>16)return t=this.cache.slice(0,16),this.cache=this.cache.slice(16),t}else if(this.cache.length>=16)return t=this.cache.slice(0,16),this.cache=this.cache.slice(16),t;return null},u.prototype.flush=function(){if(this.cache.length)return this.cache},t.createDecipher=function(e,t){var n=a[e.toLowerCase()];if(!n)throw new TypeError("invalid suite type");var s=c(t,!1,n.key,n.iv);return f(e,s.key,s.iv)},t.createDecipheriv=f},2939:(e,t,n)=>{var s=n(4646),r=n(8856),a=n(1817).Buffer,i=n(8502),o=n(7444),l=n(5706),c=n(586);function d(e,t,n){o.call(this),this._cache=new f,this._cipher=new l.AES(t),this._prev=a.from(n),this._mode=e,this._autopadding=!0}n(198)(d,o),d.prototype._update=function(e){var t,n;this._cache.add(e);for(var s=[];t=this._cache.get();)n=this._mode.encrypt(this,t),s.push(n);return a.concat(s)};var u=a.alloc(16,16);function f(){this.cache=a.allocUnsafe(0)}function h(e,t,n){var o=s[e.toLowerCase()];if(!o)throw new TypeError("invalid suite type");if("string"==typeof t&&(t=a.from(t)),t.length!==o.key/8)throw new TypeError("invalid key length "+t.length);if("string"==typeof n&&(n=a.from(n)),"GCM"!==o.mode&&n.length!==o.iv)throw new TypeError("invalid iv length "+n.length);return"stream"===o.type?new i(o.module,t,n):"auth"===o.type?new r(o.module,t,n):new d(o.module,t,n)}d.prototype._final=function(){var e=this._cache.flush();if(this._autopadding)return e=this._mode.encrypt(this,e),this._cipher.scrub(),e;if(!e.equals(u))throw this._cipher.scrub(),new Error("data not multiple of block length")},d.prototype.setAutoPadding=function(e){return this._autopadding=!!e,this},f.prototype.add=function(e){this.cache=a.concat([this.cache,e])},f.prototype.get=function(){if(this.cache.length>15){var e=this.cache.slice(0,16);return this.cache=this.cache.slice(16),e}return null},f.prototype.flush=function(){for(var e=16-this.cache.length,t=a.allocUnsafe(e),n=-1;++n<e;)t.writeUInt8(e,n);return a.concat([this.cache,t])},t.createCipheriv=h,t.createCipher=function(e,t){var n=s[e.toLowerCase()];if(!n)throw new TypeError("invalid suite type");var r=c(t,!1,n.key,n.iv);return h(e,r.key,r.iv)}},9120:(e,t,n)=>{var s=n(1817).Buffer,r=s.alloc(16,0);function a(e){var t=s.allocUnsafe(16);return t.writeUInt32BE(e[0]>>>0,0),t.writeUInt32BE(e[1]>>>0,4),t.writeUInt32BE(e[2]>>>0,8),t.writeUInt32BE(e[3]>>>0,12),t}function i(e){this.h=e,this.state=s.alloc(16,0),this.cache=s.allocUnsafe(0)}i.prototype.ghash=function(e){for(var t=-1;++t<e.length;)this.state[t]^=e[t];this._multiply()},i.prototype._multiply=function(){for(var e,t,n,s=[(e=this.h).readUInt32BE(0),e.readUInt32BE(4),e.readUInt32BE(8),e.readUInt32BE(12)],r=[0,0,0,0],i=-1;++i<128;){for(!!(this.state[~~(i/8)]&1<<7-i%8)&&(r[0]^=s[0],r[1]^=s[1],r[2]^=s[2],r[3]^=s[3]),n=!!(1&s[3]),t=3;t>0;t--)s[t]=s[t]>>>1|(1&s[t-1])<<31;s[0]=s[0]>>>1,n&&(s[0]=s[0]^225<<24)}this.state=a(r)},i.prototype.update=function(e){var t;for(this.cache=s.concat([this.cache,e]);this.cache.length>=16;)t=this.cache.slice(0,16),this.cache=this.cache.slice(16),this.ghash(t)},i.prototype.final=function(e,t){return this.cache.length&&this.ghash(s.concat([this.cache,r],16)),this.ghash(a([0,e,0,t])),this.state},e.exports=i},5366:e=>{e.exports=function(e){for(var t,n=e.length;n--;){if(255!==(t=e.readUInt8(n))){t++,e.writeUInt8(t,n);break}e.writeUInt8(0,n)}}},6976:(e,t,n)=>{var s=n(755);t.encrypt=function(e,t){var n=s(t,e._prev);return e._prev=e._cipher.encryptBlock(n),e._prev},t.decrypt=function(e,t){var n=e._prev;e._prev=t;var r=e._cipher.decryptBlock(t);return s(r,n)}},515:(e,t,n)=>{var s=n(1817).Buffer,r=n(755);function a(e,t,n){var a=t.length,i=r(t,e._cache);return e._cache=e._cache.slice(a),e._prev=s.concat([e._prev,n?t:i]),i}t.encrypt=function(e,t,n){for(var r,i=s.allocUnsafe(0);t.length;){if(0===e._cache.length&&(e._cache=e._cipher.encryptBlock(e._prev),e._prev=s.allocUnsafe(0)),!(e._cache.length<=t.length)){i=s.concat([i,a(e,t,n)]);break}r=e._cache.length,i=s.concat([i,a(e,t.slice(0,r),n)]),t=t.slice(r)}return i}},924:(e,t,n)=>{var s=n(1817).Buffer;function r(e,t,n){for(var s,r,i=-1,o=0;++i<8;)s=t&1<<7-i?128:0,o+=(128&(r=e._cipher.encryptBlock(e._prev)[0]^s))>>i%8,e._prev=a(e._prev,n?s:r);return o}function a(e,t){var n=e.length,r=-1,a=s.allocUnsafe(e.length);for(e=s.concat([e,s.from([t])]);++r<n;)a[r]=e[r]<<1|e[r+1]>>7;return a}t.encrypt=function(e,t,n){for(var a=t.length,i=s.allocUnsafe(a),o=-1;++o<a;)i[o]=r(e,t[o],n);return i}},5467:(e,t,n)=>{var s=n(1817).Buffer;function r(e,t,n){var r=e._cipher.encryptBlock(e._prev)[0]^t;return e._prev=s.concat([e._prev.slice(1),s.from([n?t:r])]),r}t.encrypt=function(e,t,n){for(var a=t.length,i=s.allocUnsafe(a),o=-1;++o<a;)i[o]=r(e,t[o],n);return i}},1297:(e,t,n)=>{var s=n(755),r=n(1817).Buffer,a=n(5366);function i(e){var t=e._cipher.encryptBlockRaw(e._prev);return a(e._prev),t}t.encrypt=function(e,t){var n=Math.ceil(t.length/16),a=e._cache.length;e._cache=r.concat([e._cache,r.allocUnsafe(16*n)]);for(var o=0;o<n;o++){var l=i(e),c=a+16*o;e._cache.writeUInt32BE(l[0],c+0),e._cache.writeUInt32BE(l[1],c+4),e._cache.writeUInt32BE(l[2],c+8),e._cache.writeUInt32BE(l[3],c+12)}var d=e._cache.slice(0,t.length);return e._cache=e._cache.slice(t.length),s(t,d)}},6236:(e,t)=>{t.encrypt=function(e,t){return e._cipher.encryptBlock(t)},t.decrypt=function(e,t){return e._cipher.decryptBlock(t)}},4646:(e,t,n)=>{var s={ECB:n(6236),CBC:n(6976),CFB:n(515),CFB8:n(5467),CFB1:n(924),OFB:n(1543),CTR:n(1297),GCM:n(1297)},r=n(9543);for(var a in r)r[a].module=s[r[a].mode];e.exports=r},1543:(e,t,n)=>{var s=n(8891).Buffer,r=n(755);function a(e){return e._prev=e._cipher.encryptBlock(e._prev),e._prev}t.encrypt=function(e,t){for(;e._cache.length<t.length;)e._cache=s.concat([e._cache,a(e)]);var n=e._cache.slice(0,t.length);return e._cache=e._cache.slice(t.length),r(t,n)}},8502:(e,t,n)=>{var s=n(5706),r=n(1817).Buffer,a=n(7444);function i(e,t,n,i){a.call(this),this._cipher=new s.AES(t),this._prev=r.from(n),this._cache=r.allocUnsafe(0),this._secCache=r.allocUnsafe(0),this._decrypt=i,this._mode=e}n(198)(i,a),i.prototype._update=function(e){return this._mode.encrypt(this,e,this._decrypt)},i.prototype._final=function(){this._cipher.scrub()},e.exports=i},721:(e,t,n)=>{n(1974),n(2005),n(4646),n(2866),n(586)},1974:(e,t,n)=>{var s=n(7444),r=n(1076),a=n(198),i=n(1817).Buffer,o={"des-ede3-cbc":r.CBC.instantiate(r.EDE),"des-ede3":r.EDE,"des-ede-cbc":r.CBC.instantiate(r.EDE),"des-ede":r.EDE,"des-cbc":r.CBC.instantiate(r.DES),"des-ecb":r.DES};function l(e){s.call(this);var t,n=e.mode.toLowerCase(),r=o[n];t=e.decrypt?"decrypt":"encrypt";var a=e.key;i.isBuffer(a)||(a=i.from(a)),"des-ede"!==n&&"des-ede-cbc"!==n||(a=i.concat([a,a.slice(0,8)]));var l=e.iv;i.isBuffer(l)||(l=i.from(l)),this._des=r.create({key:a,iv:l,type:t})}o.des=o["des-cbc"],o.des3=o["des-ede3-cbc"],e.exports=l,a(l,s),l.prototype._update=function(e){return i.from(this._des.update(e))},l.prototype._final=function(){return i.from(this._des.final())}},2866:(e,t)=>{t["des-ecb"]={key:8,iv:0},t["des-cbc"]=t.des={key:8,iv:8},t["des-ede3-cbc"]=t.des3={key:24,iv:8},t["des-ede3"]={key:24,iv:0},t["des-ede-cbc"]={key:16,iv:8},t["des-ede"]={key:16,iv:0}},755:(e,t,n)=>{var s=n(8891).Buffer;e.exports=function(e,t){for(var n=Math.min(e.length,t.length),r=new s(n),a=0;a<n;++a)r[a]=e[a]^t[a];return r}},8891:(e,t,n)=>{const s=n(7322),r=n(8239),a="function"==typeof Symbol&&"function"==typeof Symbol.for?Symbol.for("nodejs.util.inspect.custom"):null;t.Buffer=l,t.SlowBuffer=function(e){return+e!=e&&(e=0),l.alloc(+e)},t.INSPECT_MAX_BYTES=50;const i=2147483647;function o(e){if(e>i)throw new RangeError('The value "'+e+'" is invalid for option "size"');const t=new Uint8Array(e);return Object.setPrototypeOf(t,l.prototype),t}function l(e,t,n){if("number"==typeof e){if("string"==typeof t)throw new TypeError('The "string" argument must be of type string. Received type number');return u(e)}return c(e,t,n)}function c(e,t,n){if("string"==typeof e)return function(e,t){if("string"==typeof t&&""!==t||(t="utf8"),!l.isEncoding(t))throw new TypeError("Unknown encoding: "+t);const n=0|_(e,t);let s=o(n);const r=s.write(e,t);return r!==n&&(s=s.slice(0,r)),s}(e,t);if(ArrayBuffer.isView(e))return function(e){if(W(e,Uint8Array)){const t=new Uint8Array(e);return h(t.buffer,t.byteOffset,t.byteLength)}return f(e)}(e);if(null==e)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e);if(W(e,ArrayBuffer)||e&&W(e.buffer,ArrayBuffer))return h(e,t,n);if("undefined"!=typeof SharedArrayBuffer&&(W(e,SharedArrayBuffer)||e&&W(e.buffer,SharedArrayBuffer)))return h(e,t,n);if("number"==typeof e)throw new TypeError('The "value" argument must not be of type number. Received type number');const s=e.valueOf&&e.valueOf();if(null!=s&&s!==e)return l.from(s,t,n);const r=function(e){if(l.isBuffer(e)){const t=0|p(e.length),n=o(t);return 0===n.length||e.copy(n,0,0,t),n}return void 0!==e.length?"number"!=typeof e.length||Z(e.length)?o(0):f(e):"Buffer"===e.type&&Array.isArray(e.data)?f(e.data):void 0}(e);if(r)return r;if("undefined"!=typeof Symbol&&null!=Symbol.toPrimitive&&"function"==typeof e[Symbol.toPrimitive])return l.from(e[Symbol.toPrimitive]("string"),t,n);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e)}function d(e){if("number"!=typeof e)throw new TypeError('"size" argument must be of type number');if(e<0)throw new RangeError('The value "'+e+'" is invalid for option "size"')}function u(e){return d(e),o(e<0?0:0|p(e))}function f(e){const t=e.length<0?0:0|p(e.length),n=o(t);for(let s=0;s<t;s+=1)n[s]=255&e[s];return n}function h(e,t,n){if(t<0||e.byteLength<t)throw new RangeError('"offset" is outside of buffer bounds');if(e.byteLength<t+(n||0))throw new RangeError('"length" is outside of buffer bounds');let s;return s=void 0===t&&void 0===n?new Uint8Array(e):void 0===n?new Uint8Array(e,t):new Uint8Array(e,t,n),Object.setPrototypeOf(s,l.prototype),s}function p(e){if(e>=i)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+i.toString(16)+" bytes");return 0|e}function _(e,t){if(l.isBuffer(e))return e.length;if(ArrayBuffer.isView(e)||W(e,ArrayBuffer))return e.byteLength;if("string"!=typeof e)throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof e);const n=e.length,s=arguments.length>2&&!0===arguments[2];if(!s&&0===n)return 0;let r=!1;for(;;)switch(t){case"ascii":case"latin1":case"binary":return n;case"utf8":case"utf-8":return D(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*n;case"hex":return n>>>1;case"base64":return q(e).length;default:if(r)return s?-1:D(e).length;t=(""+t).toLowerCase(),r=!0}}function m(e,t,n){let s=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return"";if((n>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return P(this,t,n);case"utf8":case"utf-8":return T(this,t,n);case"ascii":return C(this,t,n);case"latin1":case"binary":return z(this,t,n);case"base64":return S(this,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return F(this,t,n);default:if(s)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),s=!0}}function g(e,t,n){const s=e[t];e[t]=e[n],e[n]=s}function b(e,t,n,s,r){if(0===e.length)return-1;if("string"==typeof n?(s=n,n=0):n>2147483647?n=2147483647:n<-2147483648&&(n=-2147483648),Z(n=+n)&&(n=r?0:e.length-1),n<0&&(n=e.length+n),n>=e.length){if(r)return-1;n=e.length-1}else if(n<0){if(!r)return-1;n=0}if("string"==typeof t&&(t=l.from(t,s)),l.isBuffer(t))return 0===t.length?-1:y(e,t,n,s,r);if("number"==typeof t)return t&=255,"function"==typeof Uint8Array.prototype.indexOf?r?Uint8Array.prototype.indexOf.call(e,t,n):Uint8Array.prototype.lastIndexOf.call(e,t,n):y(e,[t],n,s,r);throw new TypeError("val must be string, number or Buffer")}function y(e,t,n,s,r){let a,i=1,o=e.length,l=t.length;if(void 0!==s&&("ucs2"===(s=String(s).toLowerCase())||"ucs-2"===s||"utf16le"===s||"utf-16le"===s)){if(e.length<2||t.length<2)return-1;i=2,o/=2,l/=2,n/=2}function c(e,t){return 1===i?e[t]:e.readUInt16BE(t*i)}if(r){let s=-1;for(a=n;a<o;a++)if(c(e,a)===c(t,-1===s?0:a-s)){if(-1===s&&(s=a),a-s+1===l)return s*i}else-1!==s&&(a-=a-s),s=-1}else for(n+l>o&&(n=o-l),a=n;a>=0;a--){let n=!0;for(let s=0;s<l;s++)if(c(e,a+s)!==c(t,s)){n=!1;break}if(n)return a}return-1}function v(e,t,n,s){n=Number(n)||0;const r=e.length-n;s?(s=Number(s))>r&&(s=r):s=r;const a=t.length;let i;for(s>a/2&&(s=a/2),i=0;i<s;++i){const s=parseInt(t.substr(2*i,2),16);if(Z(s))return i;e[n+i]=s}return i}function w(e,t,n,s){return K(D(t,e.length-n),e,n,s)}function A(e,t,n,s){return K(function(e){const t=[];for(let n=0;n<e.length;++n)t.push(255&e.charCodeAt(n));return t}(t),e,n,s)}function E(e,t,n,s){return K(q(t),e,n,s)}function x(e,t,n,s){return K(function(e,t){let n,s,r;const a=[];for(let i=0;i<e.length&&!((t-=2)<0);++i)n=e.charCodeAt(i),s=n>>8,r=n%256,a.push(r),a.push(s);return a}(t,e.length-n),e,n,s)}function S(e,t,n){return 0===t&&n===e.length?s.fromByteArray(e):s.fromByteArray(e.slice(t,n))}function T(e,t,n){n=Math.min(e.length,n);const s=[];let r=t;for(;r<n;){const t=e[r];let a=null,i=t>239?4:t>223?3:t>191?2:1;if(r+i<=n){let n,s,o,l;switch(i){case 1:t<128&&(a=t);break;case 2:n=e[r+1],128==(192&n)&&(l=(31&t)<<6|63&n,l>127&&(a=l));break;case 3:n=e[r+1],s=e[r+2],128==(192&n)&&128==(192&s)&&(l=(15&t)<<12|(63&n)<<6|63&s,l>2047&&(l<55296||l>57343)&&(a=l));break;case 4:n=e[r+1],s=e[r+2],o=e[r+3],128==(192&n)&&128==(192&s)&&128==(192&o)&&(l=(15&t)<<18|(63&n)<<12|(63&s)<<6|63&o,l>65535&&l<1114112&&(a=l))}}null===a?(a=65533,i=1):a>65535&&(a-=65536,s.push(a>>>10&1023|55296),a=56320|1023&a),s.push(a),r+=i}return function(e){const t=e.length;if(t<=k)return String.fromCharCode.apply(String,e);let n="",s=0;for(;s<t;)n+=String.fromCharCode.apply(String,e.slice(s,s+=k));return n}(s)}t.kMaxLength=i,l.TYPED_ARRAY_SUPPORT=function(){try{const e=new Uint8Array(1),t={foo:function(){return 42}};return Object.setPrototypeOf(t,Uint8Array.prototype),Object.setPrototypeOf(e,t),42===e.foo()}catch(e){return!1}}(),l.TYPED_ARRAY_SUPPORT||"undefined"==typeof console||"function"!=typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(l.prototype,"parent",{enumerable:!0,get:function(){if(l.isBuffer(this))return this.buffer}}),Object.defineProperty(l.prototype,"offset",{enumerable:!0,get:function(){if(l.isBuffer(this))return this.byteOffset}}),l.poolSize=8192,l.from=function(e,t,n){return c(e,t,n)},Object.setPrototypeOf(l.prototype,Uint8Array.prototype),Object.setPrototypeOf(l,Uint8Array),l.alloc=function(e,t,n){return function(e,t,n){return d(e),e<=0?o(e):void 0!==t?"string"==typeof n?o(e).fill(t,n):o(e).fill(t):o(e)}(e,t,n)},l.allocUnsafe=function(e){return u(e)},l.allocUnsafeSlow=function(e){return u(e)},l.isBuffer=function(e){return null!=e&&!0===e._isBuffer&&e!==l.prototype},l.compare=function(e,t){if(W(e,Uint8Array)&&(e=l.from(e,e.offset,e.byteLength)),W(t,Uint8Array)&&(t=l.from(t,t.offset,t.byteLength)),!l.isBuffer(e)||!l.isBuffer(t))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(e===t)return 0;let n=e.length,s=t.length;for(let r=0,a=Math.min(n,s);r<a;++r)if(e[r]!==t[r]){n=e[r],s=t[r];break}return n<s?-1:s<n?1:0},l.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},l.concat=function(e,t){if(!Array.isArray(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return l.alloc(0);let n;if(void 0===t)for(t=0,n=0;n<e.length;++n)t+=e[n].length;const s=l.allocUnsafe(t);let r=0;for(n=0;n<e.length;++n){let t=e[n];if(W(t,Uint8Array))r+t.length>s.length?(l.isBuffer(t)||(t=l.from(t)),t.copy(s,r)):Uint8Array.prototype.set.call(s,t,r);else{if(!l.isBuffer(t))throw new TypeError('"list" argument must be an Array of Buffers');t.copy(s,r)}r+=t.length}return s},l.byteLength=_,l.prototype._isBuffer=!0,l.prototype.swap16=function(){const e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let t=0;t<e;t+=2)g(this,t,t+1);return this},l.prototype.swap32=function(){const e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let t=0;t<e;t+=4)g(this,t,t+3),g(this,t+1,t+2);return this},l.prototype.swap64=function(){const e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let t=0;t<e;t+=8)g(this,t,t+7),g(this,t+1,t+6),g(this,t+2,t+5),g(this,t+3,t+4);return this},l.prototype.toString=function(){const e=this.length;return 0===e?"":0===arguments.length?T(this,0,e):m.apply(this,arguments)},l.prototype.toLocaleString=l.prototype.toString,l.prototype.equals=function(e){if(!l.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===l.compare(this,e)},l.prototype.inspect=function(){let e="";const n=t.INSPECT_MAX_BYTES;return e=this.toString("hex",0,n).replace(/(.{2})/g,"$1 ").trim(),this.length>n&&(e+=" ... "),"<Buffer "+e+">"},a&&(l.prototype[a]=l.prototype.inspect),l.prototype.compare=function(e,t,n,s,r){if(W(e,Uint8Array)&&(e=l.from(e,e.offset,e.byteLength)),!l.isBuffer(e))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(void 0===t&&(t=0),void 0===n&&(n=e?e.length:0),void 0===s&&(s=0),void 0===r&&(r=this.length),t<0||n>e.length||s<0||r>this.length)throw new RangeError("out of range index");if(s>=r&&t>=n)return 0;if(s>=r)return-1;if(t>=n)return 1;if(this===e)return 0;let a=(r>>>=0)-(s>>>=0),i=(n>>>=0)-(t>>>=0);const o=Math.min(a,i),c=this.slice(s,r),d=e.slice(t,n);for(let e=0;e<o;++e)if(c[e]!==d[e]){a=c[e],i=d[e];break}return a<i?-1:i<a?1:0},l.prototype.includes=function(e,t,n){return-1!==this.indexOf(e,t,n)},l.prototype.indexOf=function(e,t,n){return b(this,e,t,n,!0)},l.prototype.lastIndexOf=function(e,t,n){return b(this,e,t,n,!1)},l.prototype.write=function(e,t,n,s){if(void 0===t)s="utf8",n=this.length,t=0;else if(void 0===n&&"string"==typeof t)s=t,n=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t>>>=0,isFinite(n)?(n>>>=0,void 0===s&&(s="utf8")):(s=n,n=void 0)}const r=this.length-t;if((void 0===n||n>r)&&(n=r),e.length>0&&(n<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");s||(s="utf8");let a=!1;for(;;)switch(s){case"hex":return v(this,e,t,n);case"utf8":case"utf-8":return w(this,e,t,n);case"ascii":case"latin1":case"binary":return A(this,e,t,n);case"base64":return E(this,e,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return x(this,e,t,n);default:if(a)throw new TypeError("Unknown encoding: "+s);s=(""+s).toLowerCase(),a=!0}},l.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};const k=4096;function C(e,t,n){let s="";n=Math.min(e.length,n);for(let r=t;r<n;++r)s+=String.fromCharCode(127&e[r]);return s}function z(e,t,n){let s="";n=Math.min(e.length,n);for(let r=t;r<n;++r)s+=String.fromCharCode(e[r]);return s}function P(e,t,n){const s=e.length;(!t||t<0)&&(t=0),(!n||n<0||n>s)&&(n=s);let r="";for(let s=t;s<n;++s)r+=V[e[s]];return r}function F(e,t,n){const s=e.slice(t,n);let r="";for(let e=0;e<s.length-1;e+=2)r+=String.fromCharCode(s[e]+256*s[e+1]);return r}function N(e,t,n){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>n)throw new RangeError("Trying to access beyond buffer length")}function G(e,t,n,s,r,a){if(!l.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>r||t<a)throw new RangeError('"value" argument is out of bounds');if(n+s>e.length)throw new RangeError("Index out of range")}function L(e,t,n,s,r){I(t,s,r,e,n,7);let a=Number(t&BigInt(4294967295));e[n++]=a,a>>=8,e[n++]=a,a>>=8,e[n++]=a,a>>=8,e[n++]=a;let i=Number(t>>BigInt(32)&BigInt(4294967295));return e[n++]=i,i>>=8,e[n++]=i,i>>=8,e[n++]=i,i>>=8,e[n++]=i,n}function O(e,t,n,s,r){I(t,s,r,e,n,7);let a=Number(t&BigInt(4294967295));e[n+7]=a,a>>=8,e[n+6]=a,a>>=8,e[n+5]=a,a>>=8,e[n+4]=a;let i=Number(t>>BigInt(32)&BigInt(4294967295));return e[n+3]=i,i>>=8,e[n+2]=i,i>>=8,e[n+1]=i,i>>=8,e[n]=i,n+8}function R(e,t,n,s,r,a){if(n+s>e.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("Index out of range")}function M(e,t,n,s,a){return t=+t,n>>>=0,a||R(e,0,n,4),r.write(e,t,n,s,23,4),n+4}function B(e,t,n,s,a){return t=+t,n>>>=0,a||R(e,0,n,8),r.write(e,t,n,s,52,8),n+8}l.prototype.slice=function(e,t){const n=this.length;(e=~~e)<0?(e+=n)<0&&(e=0):e>n&&(e=n),(t=void 0===t?n:~~t)<0?(t+=n)<0&&(t=0):t>n&&(t=n),t<e&&(t=e);const s=this.subarray(e,t);return Object.setPrototypeOf(s,l.prototype),s},l.prototype.readUintLE=l.prototype.readUIntLE=function(e,t,n){e>>>=0,t>>>=0,n||N(e,t,this.length);let s=this[e],r=1,a=0;for(;++a<t&&(r*=256);)s+=this[e+a]*r;return s},l.prototype.readUintBE=l.prototype.readUIntBE=function(e,t,n){e>>>=0,t>>>=0,n||N(e,t,this.length);let s=this[e+--t],r=1;for(;t>0&&(r*=256);)s+=this[e+--t]*r;return s},l.prototype.readUint8=l.prototype.readUInt8=function(e,t){return e>>>=0,t||N(e,1,this.length),this[e]},l.prototype.readUint16LE=l.prototype.readUInt16LE=function(e,t){return e>>>=0,t||N(e,2,this.length),this[e]|this[e+1]<<8},l.prototype.readUint16BE=l.prototype.readUInt16BE=function(e,t){return e>>>=0,t||N(e,2,this.length),this[e]<<8|this[e+1]},l.prototype.readUint32LE=l.prototype.readUInt32LE=function(e,t){return e>>>=0,t||N(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},l.prototype.readUint32BE=l.prototype.readUInt32BE=function(e,t){return e>>>=0,t||N(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},l.prototype.readBigUInt64LE=Q((function(e){X(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||U(e,this.length-8);const s=t+256*this[++e]+65536*this[++e]+this[++e]*2**24,r=this[++e]+256*this[++e]+65536*this[++e]+n*2**24;return BigInt(s)+(BigInt(r)<<BigInt(32))})),l.prototype.readBigUInt64BE=Q((function(e){X(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||U(e,this.length-8);const s=t*2**24+65536*this[++e]+256*this[++e]+this[++e],r=this[++e]*2**24+65536*this[++e]+256*this[++e]+n;return(BigInt(s)<<BigInt(32))+BigInt(r)})),l.prototype.readIntLE=function(e,t,n){e>>>=0,t>>>=0,n||N(e,t,this.length);let s=this[e],r=1,a=0;for(;++a<t&&(r*=256);)s+=this[e+a]*r;return r*=128,s>=r&&(s-=Math.pow(2,8*t)),s},l.prototype.readIntBE=function(e,t,n){e>>>=0,t>>>=0,n||N(e,t,this.length);let s=t,r=1,a=this[e+--s];for(;s>0&&(r*=256);)a+=this[e+--s]*r;return r*=128,a>=r&&(a-=Math.pow(2,8*t)),a},l.prototype.readInt8=function(e,t){return e>>>=0,t||N(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},l.prototype.readInt16LE=function(e,t){e>>>=0,t||N(e,2,this.length);const n=this[e]|this[e+1]<<8;return 32768&n?4294901760|n:n},l.prototype.readInt16BE=function(e,t){e>>>=0,t||N(e,2,this.length);const n=this[e+1]|this[e]<<8;return 32768&n?4294901760|n:n},l.prototype.readInt32LE=function(e,t){return e>>>=0,t||N(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},l.prototype.readInt32BE=function(e,t){return e>>>=0,t||N(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},l.prototype.readBigInt64LE=Q((function(e){X(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||U(e,this.length-8);const s=this[e+4]+256*this[e+5]+65536*this[e+6]+(n<<24);return(BigInt(s)<<BigInt(32))+BigInt(t+256*this[++e]+65536*this[++e]+this[++e]*2**24)})),l.prototype.readBigInt64BE=Q((function(e){X(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||U(e,this.length-8);const s=(t<<24)+65536*this[++e]+256*this[++e]+this[++e];return(BigInt(s)<<BigInt(32))+BigInt(this[++e]*2**24+65536*this[++e]+256*this[++e]+n)})),l.prototype.readFloatLE=function(e,t){return e>>>=0,t||N(e,4,this.length),r.read(this,e,!0,23,4)},l.prototype.readFloatBE=function(e,t){return e>>>=0,t||N(e,4,this.length),r.read(this,e,!1,23,4)},l.prototype.readDoubleLE=function(e,t){return e>>>=0,t||N(e,8,this.length),r.read(this,e,!0,52,8)},l.prototype.readDoubleBE=function(e,t){return e>>>=0,t||N(e,8,this.length),r.read(this,e,!1,52,8)},l.prototype.writeUintLE=l.prototype.writeUIntLE=function(e,t,n,s){e=+e,t>>>=0,n>>>=0,s||G(this,e,t,n,Math.pow(2,8*n)-1,0);let r=1,a=0;for(this[t]=255&e;++a<n&&(r*=256);)this[t+a]=e/r&255;return t+n},l.prototype.writeUintBE=l.prototype.writeUIntBE=function(e,t,n,s){e=+e,t>>>=0,n>>>=0,s||G(this,e,t,n,Math.pow(2,8*n)-1,0);let r=n-1,a=1;for(this[t+r]=255&e;--r>=0&&(a*=256);)this[t+r]=e/a&255;return t+n},l.prototype.writeUint8=l.prototype.writeUInt8=function(e,t,n){return e=+e,t>>>=0,n||G(this,e,t,1,255,0),this[t]=255&e,t+1},l.prototype.writeUint16LE=l.prototype.writeUInt16LE=function(e,t,n){return e=+e,t>>>=0,n||G(this,e,t,2,65535,0),this[t]=255&e,this[t+1]=e>>>8,t+2},l.prototype.writeUint16BE=l.prototype.writeUInt16BE=function(e,t,n){return e=+e,t>>>=0,n||G(this,e,t,2,65535,0),this[t]=e>>>8,this[t+1]=255&e,t+2},l.prototype.writeUint32LE=l.prototype.writeUInt32LE=function(e,t,n){return e=+e,t>>>=0,n||G(this,e,t,4,4294967295,0),this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e,t+4},l.prototype.writeUint32BE=l.prototype.writeUInt32BE=function(e,t,n){return e=+e,t>>>=0,n||G(this,e,t,4,4294967295,0),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},l.prototype.writeBigUInt64LE=Q((function(e,t=0){return L(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))})),l.prototype.writeBigUInt64BE=Q((function(e,t=0){return O(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))})),l.prototype.writeIntLE=function(e,t,n,s){if(e=+e,t>>>=0,!s){const s=Math.pow(2,8*n-1);G(this,e,t,n,s-1,-s)}let r=0,a=1,i=0;for(this[t]=255&e;++r<n&&(a*=256);)e<0&&0===i&&0!==this[t+r-1]&&(i=1),this[t+r]=(e/a|0)-i&255;return t+n},l.prototype.writeIntBE=function(e,t,n,s){if(e=+e,t>>>=0,!s){const s=Math.pow(2,8*n-1);G(this,e,t,n,s-1,-s)}let r=n-1,a=1,i=0;for(this[t+r]=255&e;--r>=0&&(a*=256);)e<0&&0===i&&0!==this[t+r+1]&&(i=1),this[t+r]=(e/a|0)-i&255;return t+n},l.prototype.writeInt8=function(e,t,n){return e=+e,t>>>=0,n||G(this,e,t,1,127,-128),e<0&&(e=255+e+1),this[t]=255&e,t+1},l.prototype.writeInt16LE=function(e,t,n){return e=+e,t>>>=0,n||G(this,e,t,2,32767,-32768),this[t]=255&e,this[t+1]=e>>>8,t+2},l.prototype.writeInt16BE=function(e,t,n){return e=+e,t>>>=0,n||G(this,e,t,2,32767,-32768),this[t]=e>>>8,this[t+1]=255&e,t+2},l.prototype.writeInt32LE=function(e,t,n){return e=+e,t>>>=0,n||G(this,e,t,4,2147483647,-2147483648),this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24,t+4},l.prototype.writeInt32BE=function(e,t,n){return e=+e,t>>>=0,n||G(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},l.prototype.writeBigInt64LE=Q((function(e,t=0){return L(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),l.prototype.writeBigInt64BE=Q((function(e,t=0){return O(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),l.prototype.writeFloatLE=function(e,t,n){return M(this,e,t,!0,n)},l.prototype.writeFloatBE=function(e,t,n){return M(this,e,t,!1,n)},l.prototype.writeDoubleLE=function(e,t,n){return B(this,e,t,!0,n)},l.prototype.writeDoubleBE=function(e,t,n){return B(this,e,t,!1,n)},l.prototype.copy=function(e,t,n,s){if(!l.isBuffer(e))throw new TypeError("argument should be a Buffer");if(n||(n=0),s||0===s||(s=this.length),t>=e.length&&(t=e.length),t||(t=0),s>0&&s<n&&(s=n),s===n)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(n<0||n>=this.length)throw new RangeError("Index out of range");if(s<0)throw new RangeError("sourceEnd out of bounds");s>this.length&&(s=this.length),e.length-t<s-n&&(s=e.length-t+n);const r=s-n;return this===e&&"function"==typeof Uint8Array.prototype.copyWithin?this.copyWithin(t,n,s):Uint8Array.prototype.set.call(e,this.subarray(n,s),t),r},l.prototype.fill=function(e,t,n,s){if("string"==typeof e){if("string"==typeof t?(s=t,t=0,n=this.length):"string"==typeof n&&(s=n,n=this.length),void 0!==s&&"string"!=typeof s)throw new TypeError("encoding must be a string");if("string"==typeof s&&!l.isEncoding(s))throw new TypeError("Unknown encoding: "+s);if(1===e.length){const t=e.charCodeAt(0);("utf8"===s&&t<128||"latin1"===s)&&(e=t)}}else"number"==typeof e?e&=255:"boolean"==typeof e&&(e=Number(e));if(t<0||this.length<t||this.length<n)throw new RangeError("Out of range index");if(n<=t)return this;let r;if(t>>>=0,n=void 0===n?this.length:n>>>0,e||(e=0),"number"==typeof e)for(r=t;r<n;++r)this[r]=e;else{const a=l.isBuffer(e)?e:l.from(e,s),i=a.length;if(0===i)throw new TypeError('The value "'+e+'" is invalid for argument "value"');for(r=0;r<n-t;++r)this[r+t]=a[r%i]}return this};const Y={};function j(e,t,n){Y[e]=class extends n{constructor(){super(),Object.defineProperty(this,"message",{value:t.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${e}]`,this.stack,delete this.name}get code(){return e}set code(e){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:e,writable:!0})}toString(){return`${this.name} [${e}]: ${this.message}`}}}function H(e){let t="",n=e.length;const s="-"===e[0]?1:0;for(;n>=s+4;n-=3)t=`_${e.slice(n-3,n)}${t}`;return`${e.slice(0,n)}${t}`}function I(e,t,n,s,r,a){if(e>n||e<t){const s="bigint"==typeof t?"n":"";let r;throw r=a>3?0===t||t===BigInt(0)?`>= 0${s} and < 2${s} ** ${8*(a+1)}${s}`:`>= -(2${s} ** ${8*(a+1)-1}${s}) and < 2 ** ${8*(a+1)-1}${s}`:`>= ${t}${s} and <= ${n}${s}`,new Y.ERR_OUT_OF_RANGE("value",r,e)}!function(e,t,n){X(t,"offset"),void 0!==e[t]&&void 0!==e[t+n]||U(t,e.length-(n+1))}(s,r,a)}function X(e,t){if("number"!=typeof e)throw new Y.ERR_INVALID_ARG_TYPE(t,"number",e)}function U(e,t,n){if(Math.floor(e)!==e)throw X(e,n),new Y.ERR_OUT_OF_RANGE(n||"offset","an integer",e);if(t<0)throw new Y.ERR_BUFFER_OUT_OF_BOUNDS;throw new Y.ERR_OUT_OF_RANGE(n||"offset",`>= ${n?1:0} and <= ${t}`,e)}j("ERR_BUFFER_OUT_OF_BOUNDS",(function(e){return e?`${e} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"}),RangeError),j("ERR_INVALID_ARG_TYPE",(function(e,t){return`The "${e}" argument must be of type number. Received type ${typeof t}`}),TypeError),j("ERR_OUT_OF_RANGE",(function(e,t,n){let s=`The value of "${e}" is out of range.`,r=n;return Number.isInteger(n)&&Math.abs(n)>2**32?r=H(String(n)):"bigint"==typeof n&&(r=String(n),(n>BigInt(2)**BigInt(32)||n<-(BigInt(2)**BigInt(32)))&&(r=H(r)),r+="n"),s+=` It must be ${t}. Received ${r}`,s}),RangeError);const J=/[^+/0-9A-Za-z-_]/g;function D(e,t){let n;t=t||1/0;const s=e.length;let r=null;const a=[];for(let i=0;i<s;++i){if(n=e.charCodeAt(i),n>55295&&n<57344){if(!r){if(n>56319){(t-=3)>-1&&a.push(239,191,189);continue}if(i+1===s){(t-=3)>-1&&a.push(239,191,189);continue}r=n;continue}if(n<56320){(t-=3)>-1&&a.push(239,191,189),r=n;continue}n=65536+(r-55296<<10|n-56320)}else r&&(t-=3)>-1&&a.push(239,191,189);if(r=null,n<128){if((t-=1)<0)break;a.push(n)}else if(n<2048){if((t-=2)<0)break;a.push(n>>6|192,63&n|128)}else if(n<65536){if((t-=3)<0)break;a.push(n>>12|224,n>>6&63|128,63&n|128)}else{if(!(n<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;a.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128)}}return a}function q(e){return s.toByteArray(function(e){if((e=(e=e.split("=")[0]).trim().replace(J,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function K(e,t,n,s){let r;for(r=0;r<s&&!(r+n>=t.length||r>=e.length);++r)t[r+n]=e[r];return r}function W(e,t){return e instanceof t||null!=e&&null!=e.constructor&&null!=e.constructor.name&&e.constructor.name===t.name}function Z(e){return e!=e}const V=function(){const e="0123456789abcdef",t=new Array(256);for(let n=0;n<16;++n){const s=16*n;for(let r=0;r<16;++r)t[s+r]=e[n]+e[r]}return t}();function Q(e){return"undefined"==typeof BigInt?$:e}function $(){throw new Error("BigInt not supported")}},9343:(e,t,n)=>{var s=n(8897),r=n(8179),a=r(s("String.prototype.indexOf"));e.exports=function(e,t){var n=s(e,!!t);return"function"==typeof n&&a(e,".prototype.")>-1?r(n):n}},8179:(e,t,n)=>{var s=n(4499),r=n(8897),a=n(8973),i=n(1711),o=r("%Function.prototype.apply%"),l=r("%Function.prototype.call%"),c=r("%Reflect.apply%",!0)||s.call(l,o),d=n(7539),u=r("%Math.max%");e.exports=function(e){if("function"!=typeof e)throw new i("a function is required");var t=c(s,l,arguments);return a(t,1+u(0,e.length-(arguments.length-1)),!0)};var f=function(){return c(s,o,arguments)};d?d(e.exports,"apply",{value:f}):e.exports.apply=f},7444:(e,t,n)=>{var s=n(1817).Buffer,r=n(5994).Transform,a=n(3102).I;function i(e){r.call(this),this.hashMode="string"==typeof e,this.hashMode?this[e]=this._finalOrDigest:this.final=this._finalOrDigest,this._final&&(this.__final=this._final,this._final=null),this._decoder=null,this._encoding=null}n(198)(i,r),i.prototype.update=function(e,t,n){"string"==typeof e&&(e=s.from(e,t));var r=this._update(e);return this.hashMode?this:(n&&(r=this._toString(r,n)),r)},i.prototype.setAutoPadding=function(){},i.prototype.getAuthTag=function(){throw new Error("trying to get auth tag in unsupported state")},i.prototype.setAuthTag=function(){throw new Error("trying to set auth tag in unsupported state")},i.prototype.setAAD=function(){throw new Error("trying to set aad in unsupported state")},i.prototype._transform=function(e,t,n){var s;try{this.hashMode?this._update(e):this.push(this._update(e))}catch(e){s=e}finally{n(s)}},i.prototype._flush=function(e){var t;try{this.push(this.__final())}catch(e){t=e}e(t)},i.prototype._finalOrDigest=function(e){var t=this.__final()||s.alloc(0);return e&&(t=this._toString(t,e,!0)),t},i.prototype._toString=function(e,t,n){if(this._decoder||(this._decoder=new a(t),this._encoding=t),this._encoding!==t)throw new Error("can't switch encodings");var s=this._decoder.write(e);return n&&(s+=this._decoder.end()),s},e.exports=i},7989:(e,t,n)=>{t.formatArgs=function(t){if(t[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+t[0]+(this.useColors?"%c ":" ")+"+"+e.exports.humanize(this.diff),!this.useColors)return;const n="color: "+this.color;t.splice(1,0,n,"color: inherit");let s=0,r=0;t[0].replace(/%[a-zA-Z%]/g,(e=>{"%%"!==e&&(s++,"%c"===e&&(r=s))})),t.splice(r,0,n)},t.save=function(e){try{e?t.storage.setItem("debug",e):t.storage.removeItem("debug")}catch(e){}},t.load=function(){let e;try{e=t.storage.getItem("debug")}catch(e){}return!e&&"undefined"!=typeof process&&"env"in process&&(e={NODE_ENV:"production"}.DEBUG),e},t.useColors=function(){if("undefined"!=typeof window&&window.process&&("renderer"===window.process.type||window.process.__nwjs))return!0;if("undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;let e;return"undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&(e=navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/))&&parseInt(e[1],10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},t.storage=function(){try{return localStorage}catch(e){}}(),t.destroy=(()=>{let e=!1;return()=>{e||(e=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),t.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],t.log=console.debug||console.log||(()=>{}),e.exports=n(1236)(t);const{formatters:s}=e.exports;s.j=function(e){try{return JSON.stringify(e)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}},1236:(e,t,n)=>{e.exports=function(e){function t(e){let n,r,a,i=null;function o(...e){if(!o.enabled)return;const s=o,r=Number(new Date),a=r-(n||r);s.diff=a,s.prev=n,s.curr=r,n=r,e[0]=t.coerce(e[0]),"string"!=typeof e[0]&&e.unshift("%O");let i=0;e[0]=e[0].replace(/%([a-zA-Z%])/g,((n,r)=>{if("%%"===n)return"%";i++;const a=t.formatters[r];if("function"==typeof a){const t=e[i];n=a.call(s,t),e.splice(i,1),i--}return n})),t.formatArgs.call(s,e),(s.log||t.log).apply(s,e)}return o.namespace=e,o.useColors=t.useColors(),o.color=t.selectColor(e),o.extend=s,o.destroy=t.destroy,Object.defineProperty(o,"enabled",{enumerable:!0,configurable:!1,get:()=>null!==i?i:(r!==t.namespaces&&(r=t.namespaces,a=t.enabled(e)),a),set:e=>{i=e}}),"function"==typeof t.init&&t.init(o),o}function s(e,n){const s=t(this.namespace+(void 0===n?":":n)+e);return s.log=this.log,s}function r(e){return e.toString().substring(2,e.toString().length-2).replace(/\.\*\?$/,"*")}return t.debug=t,t.default=t,t.coerce=function(e){return e instanceof Error?e.stack||e.message:e},t.disable=function(){const e=[...t.names.map(r),...t.skips.map(r).map((e=>"-"+e))].join(",");return t.enable(""),e},t.enable=function(e){let n;t.save(e),t.namespaces=e,t.names=[],t.skips=[];const s=("string"==typeof e?e:"").split(/[\s,]+/),r=s.length;for(n=0;n<r;n++)s[n]&&("-"===(e=s[n].replace(/\*/g,".*?"))[0]?t.skips.push(new RegExp("^"+e.slice(1)+"$")):t.names.push(new RegExp("^"+e+"$")))},t.enabled=function(e){if("*"===e[e.length-1])return!0;let n,s;for(n=0,s=t.skips.length;n<s;n++)if(t.skips[n].test(e))return!1;for(n=0,s=t.names.length;n<s;n++)if(t.names[n].test(e))return!0;return!1},t.humanize=n(6301),t.destroy=function(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")},Object.keys(e).forEach((n=>{t[n]=e[n]})),t.names=[],t.skips=[],t.formatters={},t.selectColor=function(e){let n=0;for(let t=0;t<e.length;t++)n=(n<<5)-n+e.charCodeAt(t),n|=0;return t.colors[Math.abs(n)%t.colors.length]},t.enable(t.load()),t}},9381:(e,t,n)=>{var s=n(7539),r=n(6296),a=n(1711),i=n(1399);e.exports=function(e,t,n){if(!e||"object"!=typeof e&&"function"!=typeof e)throw new a("`obj` must be an object or a function`");if("string"!=typeof t&&"symbol"!=typeof t)throw new a("`property` must be a string or a symbol`");if(arguments.length>3&&"boolean"!=typeof arguments[3]&&null!==arguments[3])throw new a("`nonEnumerable`, if provided, must be a boolean or null");if(arguments.length>4&&"boolean"!=typeof arguments[4]&&null!==arguments[4])throw new a("`nonWritable`, if provided, must be a boolean or null");if(arguments.length>5&&"boolean"!=typeof arguments[5]&&null!==arguments[5])throw new a("`nonConfigurable`, if provided, must be a boolean or null");if(arguments.length>6&&"boolean"!=typeof arguments[6])throw new a("`loose`, if provided, must be a boolean");var o=arguments.length>3?arguments[3]:null,l=arguments.length>4?arguments[4]:null,c=arguments.length>5?arguments[5]:null,d=arguments.length>6&&arguments[6],u=!!i&&i(e,t);if(s)s(e,t,{configurable:null===c&&u?u.configurable:!c,enumerable:null===o&&u?u.enumerable:!o,value:n,writable:null===l&&u?u.writable:!l});else{if(!d&&(o||l||c))throw new r("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");e[t]=n}}},1076:(e,t,n)=>{t.utils=n(7702),t.Cipher=n(4079),t.DES=n(5079),t.CBC=n(3713),t.EDE=n(4075)},3713:(e,t,n)=>{var s=n(73),r=n(198),a={};function i(e){s.equal(e.length,8,"Invalid IV length"),this.iv=new Array(8);for(var t=0;t<this.iv.length;t++)this.iv[t]=e[t]}t.instantiate=function(e){function t(t){e.call(this,t),this._cbcInit()}r(t,e);for(var n=Object.keys(a),s=0;s<n.length;s++){var i=n[s];t.prototype[i]=a[i]}return t.create=function(e){return new t(e)},t},a._cbcInit=function(){var e=new i(this.options.iv);this._cbcState=e},a._update=function(e,t,n,s){var r=this._cbcState,a=this.constructor.super_.prototype,i=r.iv;if("encrypt"===this.type){for(var o=0;o<this.blockSize;o++)i[o]^=e[t+o];for(a._update.call(this,i,0,n,s),o=0;o<this.blockSize;o++)i[o]=n[s+o]}else{for(a._update.call(this,e,t,n,s),o=0;o<this.blockSize;o++)n[s+o]^=i[o];for(o=0;o<this.blockSize;o++)i[o]=e[t+o]}}},4079:(e,t,n)=>{var s=n(73);function r(e){this.options=e,this.type=this.options.type,this.blockSize=8,this._init(),this.buffer=new Array(this.blockSize),this.bufferOff=0,this.padding=!1!==e.padding}e.exports=r,r.prototype._init=function(){},r.prototype.update=function(e){return 0===e.length?[]:"decrypt"===this.type?this._updateDecrypt(e):this._updateEncrypt(e)},r.prototype._buffer=function(e,t){for(var n=Math.min(this.buffer.length-this.bufferOff,e.length-t),s=0;s<n;s++)this.buffer[this.bufferOff+s]=e[t+s];return this.bufferOff+=n,n},r.prototype._flushBuffer=function(e,t){return this._update(this.buffer,0,e,t),this.bufferOff=0,this.blockSize},r.prototype._updateEncrypt=function(e){var t=0,n=0,s=(this.bufferOff+e.length)/this.blockSize|0,r=new Array(s*this.blockSize);0!==this.bufferOff&&(t+=this._buffer(e,t),this.bufferOff===this.buffer.length&&(n+=this._flushBuffer(r,n)));for(var a=e.length-(e.length-t)%this.blockSize;t<a;t+=this.blockSize)this._update(e,t,r,n),n+=this.blockSize;for(;t<e.length;t++,this.bufferOff++)this.buffer[this.bufferOff]=e[t];return r},r.prototype._updateDecrypt=function(e){for(var t=0,n=0,s=Math.ceil((this.bufferOff+e.length)/this.blockSize)-1,r=new Array(s*this.blockSize);s>0;s--)t+=this._buffer(e,t),n+=this._flushBuffer(r,n);return t+=this._buffer(e,t),r},r.prototype.final=function(e){var t,n;return e&&(t=this.update(e)),n="encrypt"===this.type?this._finalEncrypt():this._finalDecrypt(),t?t.concat(n):n},r.prototype._pad=function(e,t){if(0===t)return!1;for(;t<e.length;)e[t++]=0;return!0},r.prototype._finalEncrypt=function(){if(!this._pad(this.buffer,this.bufferOff))return[];var e=new Array(this.blockSize);return this._update(this.buffer,0,e,0),e},r.prototype._unpad=function(e){return e},r.prototype._finalDecrypt=function(){s.equal(this.bufferOff,this.blockSize,"Not enough data to decrypt");var e=new Array(this.blockSize);return this._flushBuffer(e,0),this._unpad(e)}},5079:(e,t,n)=>{var s=n(73),r=n(198),a=n(7702),i=n(4079);function o(){this.tmp=new Array(2),this.keys=null}function l(e){i.call(this,e);var t=new o;this._desState=t,this.deriveKeys(t,e.key)}r(l,i),e.exports=l,l.create=function(e){return new l(e)};var c=[1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1];l.prototype.deriveKeys=function(e,t){e.keys=new Array(32),s.equal(t.length,this.blockSize,"Invalid key length");var n=a.readUInt32BE(t,0),r=a.readUInt32BE(t,4);a.pc1(n,r,e.tmp,0),n=e.tmp[0],r=e.tmp[1];for(var i=0;i<e.keys.length;i+=2){var o=c[i>>>1];n=a.r28shl(n,o),r=a.r28shl(r,o),a.pc2(n,r,e.keys,i)}},l.prototype._update=function(e,t,n,s){var r=this._desState,i=a.readUInt32BE(e,t),o=a.readUInt32BE(e,t+4);a.ip(i,o,r.tmp,0),i=r.tmp[0],o=r.tmp[1],"encrypt"===this.type?this._encrypt(r,i,o,r.tmp,0):this._decrypt(r,i,o,r.tmp,0),i=r.tmp[0],o=r.tmp[1],a.writeUInt32BE(n,i,s),a.writeUInt32BE(n,o,s+4)},l.prototype._pad=function(e,t){if(!1===this.padding)return!1;for(var n=e.length-t,s=t;s<e.length;s++)e[s]=n;return!0},l.prototype._unpad=function(e){if(!1===this.padding)return e;for(var t=e[e.length-1],n=e.length-t;n<e.length;n++)s.equal(e[n],t);return e.slice(0,e.length-t)},l.prototype._encrypt=function(e,t,n,s,r){for(var i=t,o=n,l=0;l<e.keys.length;l+=2){var c=e.keys[l],d=e.keys[l+1];a.expand(o,e.tmp,0),c^=e.tmp[0],d^=e.tmp[1];var u=a.substitute(c,d),f=o;o=(i^a.permute(u))>>>0,i=f}a.rip(o,i,s,r)},l.prototype._decrypt=function(e,t,n,s,r){for(var i=n,o=t,l=e.keys.length-2;l>=0;l-=2){var c=e.keys[l],d=e.keys[l+1];a.expand(i,e.tmp,0),c^=e.tmp[0],d^=e.tmp[1];var u=a.substitute(c,d),f=i;i=(o^a.permute(u))>>>0,o=f}a.rip(i,o,s,r)}},4075:(e,t,n)=>{var s=n(73),r=n(198),a=n(4079),i=n(5079);function o(e,t){s.equal(t.length,24,"Invalid key length");var n=t.slice(0,8),r=t.slice(8,16),a=t.slice(16,24);this.ciphers="encrypt"===e?[i.create({type:"encrypt",key:n}),i.create({type:"decrypt",key:r}),i.create({type:"encrypt",key:a})]:[i.create({type:"decrypt",key:a}),i.create({type:"encrypt",key:r}),i.create({type:"decrypt",key:n})]}function l(e){a.call(this,e);var t=new o(this.type,this.options.key);this._edeState=t}r(l,a),e.exports=l,l.create=function(e){return new l(e)},l.prototype._update=function(e,t,n,s){var r=this._edeState;r.ciphers[0]._update(e,t,n,s),r.ciphers[1]._update(n,s,n,s),r.ciphers[2]._update(n,s,n,s)},l.prototype._pad=i.prototype._pad,l.prototype._unpad=i.prototype._unpad},7702:(e,t)=>{t.readUInt32BE=function(e,t){return(e[0+t]<<24|e[1+t]<<16|e[2+t]<<8|e[3+t])>>>0},t.writeUInt32BE=function(e,t,n){e[0+n]=t>>>24,e[1+n]=t>>>16&255,e[2+n]=t>>>8&255,e[3+n]=255&t},t.ip=function(e,t,n,s){for(var r=0,a=0,i=6;i>=0;i-=2){for(var o=0;o<=24;o+=8)r<<=1,r|=t>>>o+i&1;for(o=0;o<=24;o+=8)r<<=1,r|=e>>>o+i&1}for(i=6;i>=0;i-=2){for(o=1;o<=25;o+=8)a<<=1,a|=t>>>o+i&1;for(o=1;o<=25;o+=8)a<<=1,a|=e>>>o+i&1}n[s+0]=r>>>0,n[s+1]=a>>>0},t.rip=function(e,t,n,s){for(var r=0,a=0,i=0;i<4;i++)for(var o=24;o>=0;o-=8)r<<=1,r|=t>>>o+i&1,r<<=1,r|=e>>>o+i&1;for(i=4;i<8;i++)for(o=24;o>=0;o-=8)a<<=1,a|=t>>>o+i&1,a<<=1,a|=e>>>o+i&1;n[s+0]=r>>>0,n[s+1]=a>>>0},t.pc1=function(e,t,n,s){for(var r=0,a=0,i=7;i>=5;i--){for(var o=0;o<=24;o+=8)r<<=1,r|=t>>o+i&1;for(o=0;o<=24;o+=8)r<<=1,r|=e>>o+i&1}for(o=0;o<=24;o+=8)r<<=1,r|=t>>o+i&1;for(i=1;i<=3;i++){for(o=0;o<=24;o+=8)a<<=1,a|=t>>o+i&1;for(o=0;o<=24;o+=8)a<<=1,a|=e>>o+i&1}for(o=0;o<=24;o+=8)a<<=1,a|=e>>o+i&1;n[s+0]=r>>>0,n[s+1]=a>>>0},t.r28shl=function(e,t){return e<<t&268435455|e>>>28-t};var n=[14,11,17,4,27,23,25,0,13,22,7,18,5,9,16,24,2,20,12,21,1,8,15,26,15,4,25,19,9,1,26,16,5,11,23,8,12,7,17,0,22,3,10,14,6,20,27,24];t.pc2=function(e,t,s,r){for(var a=0,i=0,o=n.length>>>1,l=0;l<o;l++)a<<=1,a|=e>>>n[l]&1;for(l=o;l<n.length;l++)i<<=1,i|=t>>>n[l]&1;s[r+0]=a>>>0,s[r+1]=i>>>0},t.expand=function(e,t,n){var s=0,r=0;s=(1&e)<<5|e>>>27;for(var a=23;a>=15;a-=4)s<<=6,s|=e>>>a&63;for(a=11;a>=3;a-=4)r|=e>>>a&63,r<<=6;r|=(31&e)<<1|e>>>31,t[n+0]=s>>>0,t[n+1]=r>>>0};var s=[14,0,4,15,13,7,1,4,2,14,15,2,11,13,8,1,3,10,10,6,6,12,12,11,5,9,9,5,0,3,7,8,4,15,1,12,14,8,8,2,13,4,6,9,2,1,11,7,15,5,12,11,9,3,7,14,3,10,10,0,5,6,0,13,15,3,1,13,8,4,14,7,6,15,11,2,3,8,4,14,9,12,7,0,2,1,13,10,12,6,0,9,5,11,10,5,0,13,14,8,7,10,11,1,10,3,4,15,13,4,1,2,5,11,8,6,12,7,6,12,9,0,3,5,2,14,15,9,10,13,0,7,9,0,14,9,6,3,3,4,15,6,5,10,1,2,13,8,12,5,7,14,11,12,4,11,2,15,8,1,13,1,6,10,4,13,9,0,8,6,15,9,3,8,0,7,11,4,1,15,2,14,12,3,5,11,10,5,14,2,7,12,7,13,13,8,14,11,3,5,0,6,6,15,9,0,10,3,1,4,2,7,8,2,5,12,11,1,12,10,4,14,15,9,10,3,6,15,9,0,0,6,12,10,11,1,7,13,13,8,15,9,1,4,3,5,14,11,5,12,2,7,8,2,4,14,2,14,12,11,4,2,1,12,7,4,10,7,11,13,6,1,8,5,5,0,3,15,15,10,13,3,0,9,14,8,9,6,4,11,2,8,1,12,11,7,10,1,13,14,7,2,8,13,15,6,9,15,12,0,5,9,6,10,3,4,0,5,14,3,12,10,1,15,10,4,15,2,9,7,2,12,6,9,8,5,0,6,13,1,3,13,4,14,14,0,7,11,5,3,11,8,9,4,14,3,15,2,5,12,2,9,8,5,12,15,3,10,7,11,0,14,4,1,10,7,1,6,13,0,11,8,6,13,4,13,11,0,2,11,14,7,15,4,0,9,8,1,13,10,3,14,12,3,9,5,7,12,5,2,10,15,6,8,1,6,1,6,4,11,11,13,13,8,12,1,3,4,7,10,14,7,10,9,15,5,6,0,8,15,0,14,5,2,9,3,2,12,13,1,2,15,8,13,4,8,6,10,15,3,11,7,1,4,10,12,9,5,3,6,14,11,5,0,0,14,12,9,7,2,7,2,11,1,4,14,1,7,9,4,12,10,14,8,2,13,0,15,6,12,10,9,13,0,15,3,3,5,5,6,8,11];t.substitute=function(e,t){for(var n=0,r=0;r<4;r++)n<<=4,n|=s[64*r+(e>>>18-6*r&63)];for(r=0;r<4;r++)n<<=4,n|=s[256+64*r+(t>>>18-6*r&63)];return n>>>0};var r=[16,25,12,11,3,20,4,15,31,17,9,6,27,14,1,22,30,24,8,18,0,5,29,23,13,19,2,26,10,21,28,7];t.permute=function(e){for(var t=0,n=0;n<r.length;n++)t<<=1,t|=e>>>r[n]&1;return t>>>0},t.padSplit=function(e,t,n){for(var s=e.toString(2);s.length<t;)s="0"+s;for(var r=[],a=0;a<t;a+=n)r.push(s.slice(a,a+n));return r.join(" ")}},6041:e=>{e.exports=!1},7539:(e,t,n)=>{var s=n(8897)("%Object.defineProperty%",!0)||!1;if(s)try{s({},"a",{value:1})}catch(e){s=!1}e.exports=s},3841:e=>{e.exports=EvalError},219:e=>{e.exports=Error},6190:e=>{e.exports=RangeError},3950:e=>{e.exports=ReferenceError},6296:e=>{e.exports=SyntaxError},1711:e=>{e.exports=TypeError},3221:e=>{e.exports=URIError},6827:e=>{var t,n="object"==typeof Reflect?Reflect:null,s=n&&"function"==typeof n.apply?n.apply:function(e,t,n){return Function.prototype.apply.call(e,t,n)};t=n&&"function"==typeof n.ownKeys?n.ownKeys:Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:function(e){return Object.getOwnPropertyNames(e)};var r=Number.isNaN||function(e){return e!=e};function a(){a.init.call(this)}e.exports=a,e.exports.once=function(e,t){return new Promise((function(n,s){function r(n){e.removeListener(t,a),s(n)}function a(){"function"==typeof e.removeListener&&e.removeListener("error",r),n([].slice.call(arguments))}_(e,t,a,{once:!0}),"error"!==t&&function(e,t){"function"==typeof e.on&&_(e,"error",t,{once:!0})}(e,r)}))},a.EventEmitter=a,a.prototype._events=void 0,a.prototype._eventsCount=0,a.prototype._maxListeners=void 0;var i=10;function o(e){if("function"!=typeof e)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e)}function l(e){return void 0===e._maxListeners?a.defaultMaxListeners:e._maxListeners}function c(e,t,n,s){var r,a,i,c;if(o(n),void 0===(a=e._events)?(a=e._events=Object.create(null),e._eventsCount=0):(void 0!==a.newListener&&(e.emit("newListener",t,n.listener?n.listener:n),a=e._events),i=a[t]),void 0===i)i=a[t]=n,++e._eventsCount;else if("function"==typeof i?i=a[t]=s?[n,i]:[i,n]:s?i.unshift(n):i.push(n),(r=l(e))>0&&i.length>r&&!i.warned){i.warned=!0;var d=new Error("Possible EventEmitter memory leak detected. "+i.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");d.name="MaxListenersExceededWarning",d.emitter=e,d.type=t,d.count=i.length,c=d,console&&console.warn&&console.warn(c)}return e}function d(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function u(e,t,n){var s={fired:!1,wrapFn:void 0,target:e,type:t,listener:n},r=d.bind(s);return r.listener=n,s.wrapFn=r,r}function f(e,t,n){var s=e._events;if(void 0===s)return[];var r=s[t];return void 0===r?[]:"function"==typeof r?n?[r.listener||r]:[r]:n?function(e){for(var t=new Array(e.length),n=0;n<t.length;++n)t[n]=e[n].listener||e[n];return t}(r):p(r,r.length)}function h(e){var t=this._events;if(void 0!==t){var n=t[e];if("function"==typeof n)return 1;if(void 0!==n)return n.length}return 0}function p(e,t){for(var n=new Array(t),s=0;s<t;++s)n[s]=e[s];return n}function _(e,t,n,s){if("function"==typeof e.on)s.once?e.once(t,n):e.on(t,n);else{if("function"!=typeof e.addEventListener)throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof e);e.addEventListener(t,(function r(a){s.once&&e.removeEventListener(t,r),n(a)}))}}Object.defineProperty(a,"defaultMaxListeners",{enumerable:!0,get:function(){return i},set:function(e){if("number"!=typeof e||e<0||r(e))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+e+".");i=e}}),a.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},a.prototype.setMaxListeners=function(e){if("number"!=typeof e||e<0||r(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this},a.prototype.getMaxListeners=function(){return l(this)},a.prototype.emit=function(e){for(var t=[],n=1;n<arguments.length;n++)t.push(arguments[n]);var r="error"===e,a=this._events;if(void 0!==a)r=r&&void 0===a.error;else if(!r)return!1;if(r){var i;if(t.length>0&&(i=t[0]),i instanceof Error)throw i;var o=new Error("Unhandled error."+(i?" ("+i.message+")":""));throw o.context=i,o}var l=a[e];if(void 0===l)return!1;if("function"==typeof l)s(l,this,t);else{var c=l.length,d=p(l,c);for(n=0;n<c;++n)s(d[n],this,t)}return!0},a.prototype.addListener=function(e,t){return c(this,e,t,!1)},a.prototype.on=a.prototype.addListener,a.prototype.prependListener=function(e,t){return c(this,e,t,!0)},a.prototype.once=function(e,t){return o(t),this.on(e,u(this,e,t)),this},a.prototype.prependOnceListener=function(e,t){return o(t),this.prependListener(e,u(this,e,t)),this},a.prototype.removeListener=function(e,t){var n,s,r,a,i;if(o(t),void 0===(s=this._events))return this;if(void 0===(n=s[e]))return this;if(n===t||n.listener===t)0==--this._eventsCount?this._events=Object.create(null):(delete s[e],s.removeListener&&this.emit("removeListener",e,n.listener||t));else if("function"!=typeof n){for(r=-1,a=n.length-1;a>=0;a--)if(n[a]===t||n[a].listener===t){i=n[a].listener,r=a;break}if(r<0)return this;0===r?n.shift():function(e,t){for(;t+1<e.length;t++)e[t]=e[t+1];e.pop()}(n,r),1===n.length&&(s[e]=n[0]),void 0!==s.removeListener&&this.emit("removeListener",e,i||t)}return this},a.prototype.off=a.prototype.removeListener,a.prototype.removeAllListeners=function(e){var t,n,s;if(void 0===(n=this._events))return this;if(void 0===n.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==n[e]&&(0==--this._eventsCount?this._events=Object.create(null):delete n[e]),this;if(0===arguments.length){var r,a=Object.keys(n);for(s=0;s<a.length;++s)"removeListener"!==(r=a[s])&&this.removeAllListeners(r);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(t=n[e]))this.removeListener(e,t);else if(void 0!==t)for(s=t.length-1;s>=0;s--)this.removeListener(e,t[s]);return this},a.prototype.listeners=function(e){return f(this,e,!0)},a.prototype.rawListeners=function(e){return f(this,e,!1)},a.listenerCount=function(e,t){return"function"==typeof e.listenerCount?e.listenerCount(t):h.call(e,t)},a.prototype.listenerCount=h,a.prototype.eventNames=function(){return this._eventsCount>0?t(this._events):[]}},586:(e,t,n)=>{var s=n(1817).Buffer,r=n(2848);e.exports=function(e,t,n,a){if(s.isBuffer(e)||(e=s.from(e,"binary")),t&&(s.isBuffer(t)||(t=s.from(t,"binary")),8!==t.length))throw new RangeError("salt should be Buffer with 8 byte length");for(var i=n/8,o=s.alloc(i),l=s.alloc(a||0),c=s.alloc(0);i>0||a>0;){var d=new r;d.update(c),d.update(e),t&&d.update(t),c=d.digest();var u=0;if(i>0){var f=o.length-i;u=Math.min(i,c.length),c.copy(o,f,0,u),i-=u}if(u<c.length&&a>0){var h=l.length-a,p=Math.min(a,c.length-u);c.copy(l,h,u,u+p),a-=p}}return c.fill(0),{key:o,iv:l}}},7270:(e,t,n)=>{var s=n(9916),r=Object.prototype.toString,a=Object.prototype.hasOwnProperty;e.exports=function(e,t,n){if(!s(t))throw new TypeError("iterator must be a function");var i;arguments.length>=3&&(i=n),"[object Array]"===r.call(e)?function(e,t,n){for(var s=0,r=e.length;s<r;s++)a.call(e,s)&&(null==n?t(e[s],s,e):t.call(n,e[s],s,e))}(e,t,i):"string"==typeof e?function(e,t,n){for(var s=0,r=e.length;s<r;s++)null==n?t(e.charAt(s),s,e):t.call(n,e.charAt(s),s,e)}(e,t,i):function(e,t,n){for(var s in e)a.call(e,s)&&(null==n?t(e[s],s,e):t.call(n,e[s],s,e))}(e,t,i)}},5845:e=>{var t=Object.prototype.toString,n=Math.max,s=function(e,t){for(var n=[],s=0;s<e.length;s+=1)n[s]=e[s];for(var r=0;r<t.length;r+=1)n[r+e.length]=t[r];return n};e.exports=function(e){var r=this;if("function"!=typeof r||"[object Function]"!==t.apply(r))throw new TypeError("Function.prototype.bind called on incompatible "+r);for(var a,i=function(e){for(var t=[],n=1,s=0;n<e.length;n+=1,s+=1)t[s]=e[n];return t}(arguments),o=n(0,r.length-i.length),l=[],c=0;c<o;c++)l[c]="$"+c;if(a=Function("binder","return function ("+function(e){for(var t="",n=0;n<e.length;n+=1)t+=e[n],n+1<e.length&&(t+=",");return t}(l)+"){ return binder.apply(this,arguments); }")((function(){if(this instanceof a){var t=r.apply(this,s(i,arguments));return Object(t)===t?t:this}return r.apply(e,s(i,arguments))})),r.prototype){var d=function(){};d.prototype=r.prototype,a.prototype=new d,d.prototype=null}return a}},4499:(e,t,n)=>{var s=n(5845);e.exports=Function.prototype.bind||s},8897:(e,t,n)=>{var s,r=n(219),a=n(3841),i=n(6190),o=n(3950),l=n(6296),c=n(1711),d=n(3221),u=Function,f=function(e){try{return u('"use strict"; return ('+e+").constructor;")()}catch(e){}},h=Object.getOwnPropertyDescriptor;if(h)try{h({},"")}catch(e){h=null}var p=function(){throw new c},_=h?function(){try{return p}catch(e){try{return h(arguments,"callee").get}catch(e){return p}}}():p,m=n(4923)(),g=n(9372)(),b=Object.getPrototypeOf||(g?function(e){return e.__proto__}:null),y={},v="undefined"!=typeof Uint8Array&&b?b(Uint8Array):s,w={__proto__:null,"%AggregateError%":"undefined"==typeof AggregateError?s:AggregateError,"%Array%":Array,"%ArrayBuffer%":"undefined"==typeof ArrayBuffer?s:ArrayBuffer,"%ArrayIteratorPrototype%":m&&b?b([][Symbol.iterator]()):s,"%AsyncFromSyncIteratorPrototype%":s,"%AsyncFunction%":y,"%AsyncGenerator%":y,"%AsyncGeneratorFunction%":y,"%AsyncIteratorPrototype%":y,"%Atomics%":"undefined"==typeof Atomics?s:Atomics,"%BigInt%":"undefined"==typeof BigInt?s:BigInt,"%BigInt64Array%":"undefined"==typeof BigInt64Array?s:BigInt64Array,"%BigUint64Array%":"undefined"==typeof BigUint64Array?s:BigUint64Array,"%Boolean%":Boolean,"%DataView%":"undefined"==typeof DataView?s:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":r,"%eval%":eval,"%EvalError%":a,"%Float32Array%":"undefined"==typeof Float32Array?s:Float32Array,"%Float64Array%":"undefined"==typeof Float64Array?s:Float64Array,"%FinalizationRegistry%":"undefined"==typeof FinalizationRegistry?s:FinalizationRegistry,"%Function%":u,"%GeneratorFunction%":y,"%Int8Array%":"undefined"==typeof Int8Array?s:Int8Array,"%Int16Array%":"undefined"==typeof Int16Array?s:Int16Array,"%Int32Array%":"undefined"==typeof Int32Array?s:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":m&&b?b(b([][Symbol.iterator]())):s,"%JSON%":"object"==typeof JSON?JSON:s,"%Map%":"undefined"==typeof Map?s:Map,"%MapIteratorPrototype%":"undefined"!=typeof Map&&m&&b?b((new Map)[Symbol.iterator]()):s,"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":"undefined"==typeof Promise?s:Promise,"%Proxy%":"undefined"==typeof Proxy?s:Proxy,"%RangeError%":i,"%ReferenceError%":o,"%Reflect%":"undefined"==typeof Reflect?s:Reflect,"%RegExp%":RegExp,"%Set%":"undefined"==typeof Set?s:Set,"%SetIteratorPrototype%":"undefined"!=typeof Set&&m&&b?b((new Set)[Symbol.iterator]()):s,"%SharedArrayBuffer%":"undefined"==typeof SharedArrayBuffer?s:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":m&&b?b(""[Symbol.iterator]()):s,"%Symbol%":m?Symbol:s,"%SyntaxError%":l,"%ThrowTypeError%":_,"%TypedArray%":v,"%TypeError%":c,"%Uint8Array%":"undefined"==typeof Uint8Array?s:Uint8Array,"%Uint8ClampedArray%":"undefined"==typeof Uint8ClampedArray?s:Uint8ClampedArray,"%Uint16Array%":"undefined"==typeof Uint16Array?s:Uint16Array,"%Uint32Array%":"undefined"==typeof Uint32Array?s:Uint32Array,"%URIError%":d,"%WeakMap%":"undefined"==typeof WeakMap?s:WeakMap,"%WeakRef%":"undefined"==typeof WeakRef?s:WeakRef,"%WeakSet%":"undefined"==typeof WeakSet?s:WeakSet};if(b)try{null.error}catch(e){var A=b(b(e));w["%Error.prototype%"]=A}var E=function e(t){var n;if("%AsyncFunction%"===t)n=f("async function () {}");else if("%GeneratorFunction%"===t)n=f("function* () {}");else if("%AsyncGeneratorFunction%"===t)n=f("async function* () {}");else if("%AsyncGenerator%"===t){var s=e("%AsyncGeneratorFunction%");s&&(n=s.prototype)}else if("%AsyncIteratorPrototype%"===t){var r=e("%AsyncGenerator%");r&&b&&(n=b(r.prototype))}return w[t]=n,n},x={__proto__:null,"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},S=n(4499),T=n(4313),k=S.call(Function.call,Array.prototype.concat),C=S.call(Function.apply,Array.prototype.splice),z=S.call(Function.call,String.prototype.replace),P=S.call(Function.call,String.prototype.slice),F=S.call(Function.call,RegExp.prototype.exec),N=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,G=/\\(\\)?/g,L=function(e,t){var n,s=e;if(T(x,s)&&(s="%"+(n=x[s])[0]+"%"),T(w,s)){var r=w[s];if(r===y&&(r=E(s)),void 0===r&&!t)throw new c("intrinsic "+e+" exists, but is not available. Please file an issue!");return{alias:n,name:s,value:r}}throw new l("intrinsic "+e+" does not exist!")};e.exports=function(e,t){if("string"!=typeof e||0===e.length)throw new c("intrinsic name must be a non-empty string");if(arguments.length>1&&"boolean"!=typeof t)throw new c('"allowMissing" argument must be a boolean');if(null===F(/^%?[^%]*%?$/,e))throw new l("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var n=function(e){var t=P(e,0,1),n=P(e,-1);if("%"===t&&"%"!==n)throw new l("invalid intrinsic syntax, expected closing `%`");if("%"===n&&"%"!==t)throw new l("invalid intrinsic syntax, expected opening `%`");var s=[];return z(e,N,(function(e,t,n,r){s[s.length]=n?z(r,G,"$1"):t||e})),s}(e),s=n.length>0?n[0]:"",r=L("%"+s+"%",t),a=r.name,i=r.value,o=!1,d=r.alias;d&&(s=d[0],C(n,k([0,1],d)));for(var u=1,f=!0;u<n.length;u+=1){var p=n[u],_=P(p,0,1),m=P(p,-1);if(('"'===_||"'"===_||"`"===_||'"'===m||"'"===m||"`"===m)&&_!==m)throw new l("property names with quotes must have matching quotes");if("constructor"!==p&&f||(o=!0),T(w,a="%"+(s+="."+p)+"%"))i=w[a];else if(null!=i){if(!(p in i)){if(!t)throw new c("base intrinsic for "+e+" exists, but the property is not available.");return}if(h&&u+1>=n.length){var g=h(i,p);i=(f=!!g)&&"get"in g&&!("originalValue"in g.get)?g.get:i[p]}else f=T(i,p),i=i[p];f&&!o&&(w[a]=i)}}return i}},1399:(e,t,n)=>{var s=n(8897)("%Object.getOwnPropertyDescriptor%",!0);if(s)try{s([],"length")}catch(e){s=null}e.exports=s},6900:(e,t,n)=>{var s=n(7539),r=function(){return!!s};r.hasArrayLengthDefineBug=function(){if(!s)return null;try{return 1!==s([],"length",{value:1}).length}catch(e){return!0}},e.exports=r},9372:e=>{var t={__proto__:null,foo:{}},n=Object;e.exports=function(){return{__proto__:t}.foo===t.foo&&!(t instanceof n)}},4923:(e,t,n)=>{var s="undefined"!=typeof Symbol&&Symbol,r=n(4361);e.exports=function(){return"function"==typeof s&&"function"==typeof Symbol&&"symbol"==typeof s("foo")&&"symbol"==typeof Symbol("bar")&&r()}},4361:e=>{e.exports=function(){if("function"!=typeof Symbol||"function"!=typeof Object.getOwnPropertySymbols)return!1;if("symbol"==typeof Symbol.iterator)return!0;var e={},t=Symbol("test"),n=Object(t);if("string"==typeof t)return!1;if("[object Symbol]"!==Object.prototype.toString.call(t))return!1;if("[object Symbol]"!==Object.prototype.toString.call(n))return!1;for(t in e[t]=42,e)return!1;if("function"==typeof Object.keys&&0!==Object.keys(e).length)return!1;if("function"==typeof Object.getOwnPropertyNames&&0!==Object.getOwnPropertyNames(e).length)return!1;var s=Object.getOwnPropertySymbols(e);if(1!==s.length||s[0]!==t)return!1;if(!Object.prototype.propertyIsEnumerable.call(e,t))return!1;if("function"==typeof Object.getOwnPropertyDescriptor){var r=Object.getOwnPropertyDescriptor(e,t);if(42!==r.value||!0!==r.enumerable)return!1}return!0}},1432:(e,t,n)=>{var s=n(4361);e.exports=function(){return s()&&!!Symbol.toStringTag}},7293:(e,t,n)=>{var s=n(1817).Buffer,r=n(6451).Transform;function a(e){r.call(this),this._block=s.allocUnsafe(e),this._blockSize=e,this._blockOffset=0,this._length=[0,0,0,0],this._finalized=!1}n(198)(a,r),a.prototype._transform=function(e,t,n){var s=null;try{this.update(e,t)}catch(e){s=e}n(s)},a.prototype._flush=function(e){var t=null;try{this.push(this.digest())}catch(e){t=e}e(t)},a.prototype.update=function(e,t){if(function(e){if(!s.isBuffer(e)&&"string"!=typeof e)throw new TypeError("Data must be a string or a buffer")}(e),this._finalized)throw new Error("Digest already called");s.isBuffer(e)||(e=s.from(e,t));for(var n=this._block,r=0;this._blockOffset+e.length-r>=this._blockSize;){for(var a=this._blockOffset;a<this._blockSize;)n[a++]=e[r++];this._update(),this._blockOffset=0}for(;r<e.length;)n[this._blockOffset++]=e[r++];for(var i=0,o=8*e.length;o>0;++i)this._length[i]+=o,(o=this._length[i]/4294967296|0)>0&&(this._length[i]-=4294967296*o);return this},a.prototype._update=function(){throw new Error("_update is not implemented")},a.prototype.digest=function(e){if(this._finalized)throw new Error("Digest already called");this._finalized=!0;var t=this._digest();void 0!==e&&(t=t.toString(e)),this._block.fill(0),this._blockOffset=0;for(var n=0;n<4;++n)this._length[n]=0;return t},a.prototype._digest=function(){throw new Error("_digest is not implemented")},e.exports=a},6460:(e,t,n)=>{var s=t;s.utils=n(9566),s.common=n(2090),s.sha=n(1017),s.ripemd=n(7572),s.hmac=n(1912),s.sha1=s.sha.sha1,s.sha256=s.sha.sha256,s.sha224=s.sha.sha224,s.sha384=s.sha.sha384,s.sha512=s.sha.sha512,s.ripemd160=s.ripemd.ripemd160},2090:(e,t,n)=>{var s=n(9566),r=n(73);function a(){this.pending=null,this.pendingTotal=0,this.blockSize=this.constructor.blockSize,this.outSize=this.constructor.outSize,this.hmacStrength=this.constructor.hmacStrength,this.padLength=this.constructor.padLength/8,this.endian="big",this._delta8=this.blockSize/8,this._delta32=this.blockSize/32}t.BlockHash=a,a.prototype.update=function(e,t){if(e=s.toArray(e,t),this.pending?this.pending=this.pending.concat(e):this.pending=e,this.pendingTotal+=e.length,this.pending.length>=this._delta8){var n=(e=this.pending).length%this._delta8;this.pending=e.slice(e.length-n,e.length),0===this.pending.length&&(this.pending=null),e=s.join32(e,0,e.length-n,this.endian);for(var r=0;r<e.length;r+=this._delta32)this._update(e,r,r+this._delta32)}return this},a.prototype.digest=function(e){return this.update(this._pad()),r(null===this.pending),this._digest(e)},a.prototype._pad=function(){var e=this.pendingTotal,t=this._delta8,n=t-(e+this.padLength)%t,s=new Array(n+this.padLength);s[0]=128;for(var r=1;r<n;r++)s[r]=0;if(e<<=3,"big"===this.endian){for(var a=8;a<this.padLength;a++)s[r++]=0;s[r++]=0,s[r++]=0,s[r++]=0,s[r++]=0,s[r++]=e>>>24&255,s[r++]=e>>>16&255,s[r++]=e>>>8&255,s[r++]=255&e}else for(s[r++]=255&e,s[r++]=e>>>8&255,s[r++]=e>>>16&255,s[r++]=e>>>24&255,s[r++]=0,s[r++]=0,s[r++]=0,s[r++]=0,a=8;a<this.padLength;a++)s[r++]=0;return s}},1912:(e,t,n)=>{var s=n(9566),r=n(73);function a(e,t,n){if(!(this instanceof a))return new a(e,t,n);this.Hash=e,this.blockSize=e.blockSize/8,this.outSize=e.outSize/8,this.inner=null,this.outer=null,this._init(s.toArray(t,n))}e.exports=a,a.prototype._init=function(e){e.length>this.blockSize&&(e=(new this.Hash).update(e).digest()),r(e.length<=this.blockSize);for(var t=e.length;t<this.blockSize;t++)e.push(0);for(t=0;t<e.length;t++)e[t]^=54;for(this.inner=(new this.Hash).update(e),t=0;t<e.length;t++)e[t]^=106;this.outer=(new this.Hash).update(e)},a.prototype.update=function(e,t){return this.inner.update(e,t),this},a.prototype.digest=function(e){return this.outer.update(this.inner.digest()),this.outer.digest(e)}},7572:(e,t,n)=>{var s=n(9566),r=n(2090),a=s.rotl32,i=s.sum32,o=s.sum32_3,l=s.sum32_4,c=r.BlockHash;function d(){if(!(this instanceof d))return new d;c.call(this),this.h=[1732584193,4023233417,2562383102,271733878,3285377520],this.endian="little"}function u(e,t,n,s){return e<=15?t^n^s:e<=31?t&n|~t&s:e<=47?(t|~n)^s:e<=63?t&s|n&~s:t^(n|~s)}function f(e){return e<=15?0:e<=31?1518500249:e<=47?1859775393:e<=63?2400959708:2840853838}function h(e){return e<=15?1352829926:e<=31?1548603684:e<=47?1836072691:e<=63?2053994217:0}s.inherits(d,c),t.ripemd160=d,d.blockSize=512,d.outSize=160,d.hmacStrength=192,d.padLength=64,d.prototype._update=function(e,t){for(var n=this.h[0],s=this.h[1],r=this.h[2],c=this.h[3],d=this.h[4],b=n,y=s,v=r,w=c,A=d,E=0;E<80;E++){var x=i(a(l(n,u(E,s,r,c),e[p[E]+t],f(E)),m[E]),d);n=d,d=c,c=a(r,10),r=s,s=x,x=i(a(l(b,u(79-E,y,v,w),e[_[E]+t],h(E)),g[E]),A),b=A,A=w,w=a(v,10),v=y,y=x}x=o(this.h[1],r,w),this.h[1]=o(this.h[2],c,A),this.h[2]=o(this.h[3],d,b),this.h[3]=o(this.h[4],n,y),this.h[4]=o(this.h[0],s,v),this.h[0]=x},d.prototype._digest=function(e){return"hex"===e?s.toHex32(this.h,"little"):s.split32(this.h,"little")};var p=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13],_=[5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11],m=[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6],g=[8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]},1017:(e,t,n)=>{t.sha1=n(3897),t.sha224=n(422),t.sha256=n(6475),t.sha384=n(6251),t.sha512=n(714)},3897:(e,t,n)=>{var s=n(9566),r=n(2090),a=n(3085),i=s.rotl32,o=s.sum32,l=s.sum32_5,c=a.ft_1,d=r.BlockHash,u=[1518500249,1859775393,2400959708,3395469782];function f(){if(!(this instanceof f))return new f;d.call(this),this.h=[1732584193,4023233417,2562383102,271733878,3285377520],this.W=new Array(80)}s.inherits(f,d),e.exports=f,f.blockSize=512,f.outSize=160,f.hmacStrength=80,f.padLength=64,f.prototype._update=function(e,t){for(var n=this.W,s=0;s<16;s++)n[s]=e[t+s];for(;s<n.length;s++)n[s]=i(n[s-3]^n[s-8]^n[s-14]^n[s-16],1);var r=this.h[0],a=this.h[1],d=this.h[2],f=this.h[3],h=this.h[4];for(s=0;s<n.length;s++){var p=~~(s/20),_=l(i(r,5),c(p,a,d,f),h,n[s],u[p]);h=f,f=d,d=i(a,30),a=r,r=_}this.h[0]=o(this.h[0],r),this.h[1]=o(this.h[1],a),this.h[2]=o(this.h[2],d),this.h[3]=o(this.h[3],f),this.h[4]=o(this.h[4],h)},f.prototype._digest=function(e){return"hex"===e?s.toHex32(this.h,"big"):s.split32(this.h,"big")}},422:(e,t,n)=>{var s=n(9566),r=n(6475);function a(){if(!(this instanceof a))return new a;r.call(this),this.h=[3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428]}s.inherits(a,r),e.exports=a,a.blockSize=512,a.outSize=224,a.hmacStrength=192,a.padLength=64,a.prototype._digest=function(e){return"hex"===e?s.toHex32(this.h.slice(0,7),"big"):s.split32(this.h.slice(0,7),"big")}},6475:(e,t,n)=>{var s=n(9566),r=n(2090),a=n(3085),i=n(73),o=s.sum32,l=s.sum32_4,c=s.sum32_5,d=a.ch32,u=a.maj32,f=a.s0_256,h=a.s1_256,p=a.g0_256,_=a.g1_256,m=r.BlockHash,g=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];function b(){if(!(this instanceof b))return new b;m.call(this),this.h=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],this.k=g,this.W=new Array(64)}s.inherits(b,m),e.exports=b,b.blockSize=512,b.outSize=256,b.hmacStrength=192,b.padLength=64,b.prototype._update=function(e,t){for(var n=this.W,s=0;s<16;s++)n[s]=e[t+s];for(;s<n.length;s++)n[s]=l(_(n[s-2]),n[s-7],p(n[s-15]),n[s-16]);var r=this.h[0],a=this.h[1],m=this.h[2],g=this.h[3],b=this.h[4],y=this.h[5],v=this.h[6],w=this.h[7];for(i(this.k.length===n.length),s=0;s<n.length;s++){var A=c(w,h(b),d(b,y,v),this.k[s],n[s]),E=o(f(r),u(r,a,m));w=v,v=y,y=b,b=o(g,A),g=m,m=a,a=r,r=o(A,E)}this.h[0]=o(this.h[0],r),this.h[1]=o(this.h[1],a),this.h[2]=o(this.h[2],m),this.h[3]=o(this.h[3],g),this.h[4]=o(this.h[4],b),this.h[5]=o(this.h[5],y),this.h[6]=o(this.h[6],v),this.h[7]=o(this.h[7],w)},b.prototype._digest=function(e){return"hex"===e?s.toHex32(this.h,"big"):s.split32(this.h,"big")}},6251:(e,t,n)=>{var s=n(9566),r=n(714);function a(){if(!(this instanceof a))return new a;r.call(this),this.h=[3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]}s.inherits(a,r),e.exports=a,a.blockSize=1024,a.outSize=384,a.hmacStrength=192,a.padLength=128,a.prototype._digest=function(e){return"hex"===e?s.toHex32(this.h.slice(0,12),"big"):s.split32(this.h.slice(0,12),"big")}},714:(e,t,n)=>{var s=n(9566),r=n(2090),a=n(73),i=s.rotr64_hi,o=s.rotr64_lo,l=s.shr64_hi,c=s.shr64_lo,d=s.sum64,u=s.sum64_hi,f=s.sum64_lo,h=s.sum64_4_hi,p=s.sum64_4_lo,_=s.sum64_5_hi,m=s.sum64_5_lo,g=r.BlockHash,b=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591];function y(){if(!(this instanceof y))return new y;g.call(this),this.h=[1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209],this.k=b,this.W=new Array(160)}function v(e,t,n,s,r){var a=e&n^~e&r;return a<0&&(a+=4294967296),a}function w(e,t,n,s,r,a){var i=t&s^~t&a;return i<0&&(i+=4294967296),i}function A(e,t,n,s,r){var a=e&n^e&r^n&r;return a<0&&(a+=4294967296),a}function E(e,t,n,s,r,a){var i=t&s^t&a^s&a;return i<0&&(i+=4294967296),i}function x(e,t){var n=i(e,t,28)^i(t,e,2)^i(t,e,7);return n<0&&(n+=4294967296),n}function S(e,t){var n=o(e,t,28)^o(t,e,2)^o(t,e,7);return n<0&&(n+=4294967296),n}function T(e,t){var n=o(e,t,14)^o(e,t,18)^o(t,e,9);return n<0&&(n+=4294967296),n}function k(e,t){var n=i(e,t,1)^i(e,t,8)^l(e,t,7);return n<0&&(n+=4294967296),n}function C(e,t){var n=o(e,t,1)^o(e,t,8)^c(e,t,7);return n<0&&(n+=4294967296),n}function z(e,t){var n=o(e,t,19)^o(t,e,29)^c(e,t,6);return n<0&&(n+=4294967296),n}s.inherits(y,g),e.exports=y,y.blockSize=1024,y.outSize=512,y.hmacStrength=192,y.padLength=128,y.prototype._prepareBlock=function(e,t){for(var n=this.W,s=0;s<32;s++)n[s]=e[t+s];for(;s<n.length;s+=2){var r=(m=n[s-4],g=n[s-3],b=void 0,(b=i(m,g,19)^i(g,m,29)^l(m,g,6))<0&&(b+=4294967296),b),a=z(n[s-4],n[s-3]),o=n[s-14],c=n[s-13],d=k(n[s-30],n[s-29]),u=C(n[s-30],n[s-29]),f=n[s-32],_=n[s-31];n[s]=h(r,a,o,c,d,u,f,_),n[s+1]=p(r,a,o,c,d,u,f,_)}var m,g,b},y.prototype._update=function(e,t){this._prepareBlock(e,t);var n,s,r,o=this.W,l=this.h[0],c=this.h[1],h=this.h[2],p=this.h[3],g=this.h[4],b=this.h[5],y=this.h[6],k=this.h[7],C=this.h[8],z=this.h[9],P=this.h[10],F=this.h[11],N=this.h[12],G=this.h[13],L=this.h[14],O=this.h[15];a(this.k.length===o.length);for(var R=0;R<o.length;R+=2){var M=L,B=O,Y=(r=void 0,(r=i(n=C,s=z,14)^i(n,s,18)^i(s,n,9))<0&&(r+=4294967296),r),j=T(C,z),H=v(C,0,P,0,N),I=w(0,z,0,F,0,G),X=this.k[R],U=this.k[R+1],J=o[R],D=o[R+1],q=_(M,B,Y,j,H,I,X,U,J,D),K=m(M,B,Y,j,H,I,X,U,J,D);M=x(l,c),B=S(l,c),Y=A(l,0,h,0,g),j=E(0,c,0,p,0,b);var W=u(M,B,Y,j),Z=f(M,B,Y,j);L=N,O=G,N=P,G=F,P=C,F=z,C=u(y,k,q,K),z=f(k,k,q,K),y=g,k=b,g=h,b=p,h=l,p=c,l=u(q,K,W,Z),c=f(q,K,W,Z)}d(this.h,0,l,c),d(this.h,2,h,p),d(this.h,4,g,b),d(this.h,6,y,k),d(this.h,8,C,z),d(this.h,10,P,F),d(this.h,12,N,G),d(this.h,14,L,O)},y.prototype._digest=function(e){return"hex"===e?s.toHex32(this.h,"big"):s.split32(this.h,"big")}},3085:(e,t,n)=>{var s=n(9566).rotr32;function r(e,t,n){return e&t^~e&n}function a(e,t,n){return e&t^e&n^t&n}function i(e,t,n){return e^t^n}t.ft_1=function(e,t,n,s){return 0===e?r(t,n,s):1===e||3===e?i(t,n,s):2===e?a(t,n,s):void 0},t.ch32=r,t.maj32=a,t.p32=i,t.s0_256=function(e){return s(e,2)^s(e,13)^s(e,22)},t.s1_256=function(e){return s(e,6)^s(e,11)^s(e,25)},t.g0_256=function(e){return s(e,7)^s(e,18)^e>>>3},t.g1_256=function(e){return s(e,17)^s(e,19)^e>>>10}},9566:(e,t,n)=>{var s=n(73),r=n(198);function a(e,t){return 55296==(64512&e.charCodeAt(t))&&!(t<0||t+1>=e.length)&&56320==(64512&e.charCodeAt(t+1))}function i(e){return(e>>>24|e>>>8&65280|e<<8&16711680|(255&e)<<24)>>>0}function o(e){return 1===e.length?"0"+e:e}function l(e){return 7===e.length?"0"+e:6===e.length?"00"+e:5===e.length?"000"+e:4===e.length?"0000"+e:3===e.length?"00000"+e:2===e.length?"000000"+e:1===e.length?"0000000"+e:e}t.inherits=r,t.toArray=function(e,t){if(Array.isArray(e))return e.slice();if(!e)return[];var n=[];if("string"==typeof e)if(t){if("hex"===t)for((e=e.replace(/[^a-z0-9]+/gi,"")).length%2!=0&&(e="0"+e),r=0;r<e.length;r+=2)n.push(parseInt(e[r]+e[r+1],16))}else for(var s=0,r=0;r<e.length;r++){var i=e.charCodeAt(r);i<128?n[s++]=i:i<2048?(n[s++]=i>>6|192,n[s++]=63&i|128):a(e,r)?(i=65536+((1023&i)<<10)+(1023&e.charCodeAt(++r)),n[s++]=i>>18|240,n[s++]=i>>12&63|128,n[s++]=i>>6&63|128,n[s++]=63&i|128):(n[s++]=i>>12|224,n[s++]=i>>6&63|128,n[s++]=63&i|128)}else for(r=0;r<e.length;r++)n[r]=0|e[r];return n},t.toHex=function(e){for(var t="",n=0;n<e.length;n++)t+=o(e[n].toString(16));return t},t.htonl=i,t.toHex32=function(e,t){for(var n="",s=0;s<e.length;s++){var r=e[s];"little"===t&&(r=i(r)),n+=l(r.toString(16))}return n},t.zero2=o,t.zero8=l,t.join32=function(e,t,n,r){var a=n-t;s(a%4==0);for(var i=new Array(a/4),o=0,l=t;o<i.length;o++,l+=4){var c;c="big"===r?e[l]<<24|e[l+1]<<16|e[l+2]<<8|e[l+3]:e[l+3]<<24|e[l+2]<<16|e[l+1]<<8|e[l],i[o]=c>>>0}return i},t.split32=function(e,t){for(var n=new Array(4*e.length),s=0,r=0;s<e.length;s++,r+=4){var a=e[s];"big"===t?(n[r]=a>>>24,n[r+1]=a>>>16&255,n[r+2]=a>>>8&255,n[r+3]=255&a):(n[r+3]=a>>>24,n[r+2]=a>>>16&255,n[r+1]=a>>>8&255,n[r]=255&a)}return n},t.rotr32=function(e,t){return e>>>t|e<<32-t},t.rotl32=function(e,t){return e<<t|e>>>32-t},t.sum32=function(e,t){return e+t>>>0},t.sum32_3=function(e,t,n){return e+t+n>>>0},t.sum32_4=function(e,t,n,s){return e+t+n+s>>>0},t.sum32_5=function(e,t,n,s,r){return e+t+n+s+r>>>0},t.sum64=function(e,t,n,s){var r=e[t],a=s+e[t+1]>>>0,i=(a<s?1:0)+n+r;e[t]=i>>>0,e[t+1]=a},t.sum64_hi=function(e,t,n,s){return(t+s>>>0<t?1:0)+e+n>>>0},t.sum64_lo=function(e,t,n,s){return t+s>>>0},t.sum64_4_hi=function(e,t,n,s,r,a,i,o){var l=0,c=t;return l+=(c=c+s>>>0)<t?1:0,l+=(c=c+a>>>0)<a?1:0,e+n+r+i+(l+=(c=c+o>>>0)<o?1:0)>>>0},t.sum64_4_lo=function(e,t,n,s,r,a,i,o){return t+s+a+o>>>0},t.sum64_5_hi=function(e,t,n,s,r,a,i,o,l,c){var d=0,u=t;return d+=(u=u+s>>>0)<t?1:0,d+=(u=u+a>>>0)<a?1:0,d+=(u=u+o>>>0)<o?1:0,e+n+r+i+l+(d+=(u=u+c>>>0)<c?1:0)>>>0},t.sum64_5_lo=function(e,t,n,s,r,a,i,o,l,c){return t+s+a+o+c>>>0},t.rotr64_hi=function(e,t,n){return(t<<32-n|e>>>n)>>>0},t.rotr64_lo=function(e,t,n){return(e<<32-n|t>>>n)>>>0},t.shr64_hi=function(e,t,n){return e>>>n},t.shr64_lo=function(e,t,n){return(e<<32-n|t>>>n)>>>0}},4313:(e,t,n)=>{var s=Function.prototype.call,r=Object.prototype.hasOwnProperty,a=n(4499);e.exports=a.call(s,r)},8239:(e,t)=>{t.read=function(e,t,n,s,r){var a,i,o=8*r-s-1,l=(1<<o)-1,c=l>>1,d=-7,u=n?r-1:0,f=n?-1:1,h=e[t+u];for(u+=f,a=h&(1<<-d)-1,h>>=-d,d+=o;d>0;a=256*a+e[t+u],u+=f,d-=8);for(i=a&(1<<-d)-1,a>>=-d,d+=s;d>0;i=256*i+e[t+u],u+=f,d-=8);if(0===a)a=1-c;else{if(a===l)return i?NaN:1/0*(h?-1:1);i+=Math.pow(2,s),a-=c}return(h?-1:1)*i*Math.pow(2,a-s)},t.write=function(e,t,n,s,r,a){var i,o,l,c=8*a-r-1,d=(1<<c)-1,u=d>>1,f=23===r?Math.pow(2,-24)-Math.pow(2,-77):0,h=s?0:a-1,p=s?1:-1,_=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(o=isNaN(t)?1:0,i=d):(i=Math.floor(Math.log(t)/Math.LN2),t*(l=Math.pow(2,-i))<1&&(i--,l*=2),(t+=i+u>=1?f/l:f*Math.pow(2,1-u))*l>=2&&(i++,l/=2),i+u>=d?(o=0,i=d):i+u>=1?(o=(t*l-1)*Math.pow(2,r),i+=u):(o=t*Math.pow(2,u-1)*Math.pow(2,r),i=0));r>=8;e[n+h]=255&o,h+=p,o/=256,r-=8);for(i=i<<r|o,c+=r;c>0;e[n+h]=255&i,h+=p,i/=256,c-=8);e[n+h-p]|=128*_}},198:e=>{"function"==typeof Object.create?e.exports=function(e,t){t&&(e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}))}:e.exports=function(e,t){if(t){e.super_=t;var n=function(){};n.prototype=t.prototype,e.prototype=new n,e.prototype.constructor=e}}},5456:(e,t,n)=>{var s=n(1432)(),r=n(9343)("Object.prototype.toString"),a=function(e){return!(s&&e&&"object"==typeof e&&Symbol.toStringTag in e)&&"[object Arguments]"===r(e)},i=function(e){return!!a(e)||null!==e&&"object"==typeof e&&"number"==typeof e.length&&e.length>=0&&"[object Array]"!==r(e)&&"[object Function]"===r(e.callee)},o=function(){return a(arguments)}();a.isLegacyArguments=i,e.exports=o?a:i},9916:e=>{var t,n,s=Function.prototype.toString,r="object"==typeof Reflect&&null!==Reflect&&Reflect.apply;if("function"==typeof r&&"function"==typeof Object.defineProperty)try{t=Object.defineProperty({},"length",{get:function(){throw n}}),n={},r((function(){throw 42}),null,t)}catch(e){e!==n&&(r=null)}else r=null;var a=/^\s*class\b/,i=function(e){try{var t=s.call(e);return a.test(t)}catch(e){return!1}},o=function(e){try{return!i(e)&&(s.call(e),!0)}catch(e){return!1}},l=Object.prototype.toString,c="function"==typeof Symbol&&!!Symbol.toStringTag,d=!(0 in[,]),u=function(){return!1};if("object"==typeof document){var f=document.all;l.call(f)===l.call(document.all)&&(u=function(e){if((d||!e)&&(void 0===e||"object"==typeof e))try{var t=l.call(e);return("[object HTMLAllCollection]"===t||"[object HTML document.all class]"===t||"[object HTMLCollection]"===t||"[object Object]"===t)&&null==e("")}catch(e){}return!1})}e.exports=r?function(e){if(u(e))return!0;if(!e)return!1;if("function"!=typeof e&&"object"!=typeof e)return!1;try{r(e,null,t)}catch(e){if(e!==n)return!1}return!i(e)&&o(e)}:function(e){if(u(e))return!0;if(!e)return!1;if("function"!=typeof e&&"object"!=typeof e)return!1;if(c)return o(e);if(i(e))return!1;var t=l.call(e);return!("[object Function]"!==t&&"[object GeneratorFunction]"!==t&&!/^\[object HTML/.test(t))&&o(e)}},6940:(e,t,n)=>{var s,r=Object.prototype.toString,a=Function.prototype.toString,i=/^\s*(?:function)?\*/,o=n(1432)(),l=Object.getPrototypeOf;e.exports=function(e){if("function"!=typeof e)return!1;if(i.test(a.call(e)))return!0;if(!o)return"[object GeneratorFunction]"===r.call(e);if(!l)return!1;if(void 0===s){var t=function(){if(!o)return!1;try{return Function("return function*() {}")()}catch(e){}}();s=!!t&&l(t)}return l(e)===s}},2116:(e,t,n)=>{var s=n(6059);e.exports=function(e){return!!s(e)}},4247:e=>{var t=1/0,n=9007199254740991,s=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,a=/^0b[01]+$/i,i=/^0o[0-7]+$/i,o=/^(?:0|[1-9]\d*)$/,l=parseInt,c=Object.prototype.toString,d=Math.ceil,u=Math.max;function f(e,t,n){var s=-1,r=e.length;t<0&&(t=-t>r?0:r+t),(n=n>r?r:n)<0&&(n+=r),r=t>n?0:n-t>>>0,t>>>=0;for(var a=Array(r);++s<r;)a[s]=e[s+t];return a}function h(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}e.exports=function(e,p,_){p=(_?function(e,t,s){if(!h(s))return!1;var r=typeof t;return!!("number"==r?function(e){return null!=e&&function(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=n}(e.length)&&!function(e){var t=h(e)?c.call(e):"";return"[object Function]"==t||"[object GeneratorFunction]"==t}(e)}(s)&&function(e,t){return!!(t=null==t?n:t)&&("number"==typeof e||o.test(e))&&e>-1&&e%1==0&&e<t}(t,s.length):"string"==r&&t in s)&&function(e,t){return e===t||e!=e&&t!=t}(s[t],e)}(e,p,_):void 0===p)?1:u(function(e){var n=function(e){return e?(e=function(e){if("number"==typeof e)return e;if(function(e){return"symbol"==typeof e||function(e){return!!e&&"object"==typeof e}(e)&&"[object Symbol]"==c.call(e)}(e))return NaN;if(h(e)){var t="function"==typeof e.valueOf?e.valueOf():e;e=h(t)?t+"":t}if("string"!=typeof e)return 0===e?e:+e;e=e.replace(s,"");var n=a.test(e);return n||i.test(e)?l(e.slice(2),n?2:8):r.test(e)?NaN:+e}(e))===t||e===-1/0?17976931348623157e292*(e<0?-1:1):e==e?e:0:0===e?e:0}(e),o=n%1;return n==n?o?n-o:n:0}(p),0);var m=e?e.length:0;if(!m||p<1)return[];for(var g=0,b=0,y=Array(d(m/p));g<m;)y[b++]=f(e,g,g+=p);return y}},2617:(e,t,n)=>{e=n.nmd(e);var s="__lodash_hash_undefined__",r=9007199254740991,a="[object Arguments]",i="[object Boolean]",o="[object Date]",l="[object Function]",c="[object GeneratorFunction]",d="[object Map]",u="[object Number]",f="[object Object]",h="[object Promise]",p="[object RegExp]",_="[object Set]",m="[object String]",g="[object Symbol]",b="[object WeakMap]",y="[object ArrayBuffer]",v="[object DataView]",w="[object Float32Array]",A="[object Float64Array]",E="[object Int8Array]",x="[object Int16Array]",S="[object Int32Array]",T="[object Uint8Array]",k="[object Uint8ClampedArray]",C="[object Uint16Array]",z="[object Uint32Array]",P=/\w*$/,F=/^\[object .+?Constructor\]$/,N=/^(?:0|[1-9]\d*)$/,G={};G[a]=G["[object Array]"]=G[y]=G[v]=G[i]=G[o]=G[w]=G[A]=G[E]=G[x]=G[S]=G[d]=G[u]=G[f]=G[p]=G[_]=G[m]=G[g]=G[T]=G[k]=G[C]=G[z]=!0,G["[object Error]"]=G[l]=G[b]=!1;var L="object"==typeof n.g&&n.g&&n.g.Object===Object&&n.g,O="object"==typeof self&&self&&self.Object===Object&&self,R=L||O||Function("return this")(),M=t&&!t.nodeType&&t,B=M&&e&&!e.nodeType&&e,Y=B&&B.exports===M;function j(e,t){return e.set(t[0],t[1]),e}function H(e,t){return e.add(t),e}function I(e,t,n,s){var r=-1,a=e?e.length:0;for(s&&a&&(n=e[++r]);++r<a;)n=t(n,e[r],r,e);return n}function X(e){var t=!1;if(null!=e&&"function"!=typeof e.toString)try{t=!!(e+"")}catch(e){}return t}function U(e){var t=-1,n=Array(e.size);return e.forEach((function(e,s){n[++t]=[s,e]})),n}function J(e,t){return function(n){return e(t(n))}}function D(e){var t=-1,n=Array(e.size);return e.forEach((function(e){n[++t]=e})),n}var q,K=Array.prototype,W=Function.prototype,Z=Object.prototype,V=R["__core-js_shared__"],Q=(q=/[^.]+$/.exec(V&&V.keys&&V.keys.IE_PROTO||""))?"Symbol(src)_1."+q:"",$=W.toString,ee=Z.hasOwnProperty,te=Z.toString,ne=RegExp("^"+$.call(ee).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),se=Y?R.Buffer:void 0,re=R.Symbol,ae=R.Uint8Array,ie=J(Object.getPrototypeOf,Object),oe=Object.create,le=Z.propertyIsEnumerable,ce=K.splice,de=Object.getOwnPropertySymbols,ue=se?se.isBuffer:void 0,fe=J(Object.keys,Object),he=Re(R,"DataView"),pe=Re(R,"Map"),_e=Re(R,"Promise"),me=Re(R,"Set"),ge=Re(R,"WeakMap"),be=Re(Object,"create"),ye=He(he),ve=He(pe),we=He(_e),Ae=He(me),Ee=He(ge),xe=re?re.prototype:void 0,Se=xe?xe.valueOf:void 0;function Te(e){var t=-1,n=e?e.length:0;for(this.clear();++t<n;){var s=e[t];this.set(s[0],s[1])}}function ke(e){var t=-1,n=e?e.length:0;for(this.clear();++t<n;){var s=e[t];this.set(s[0],s[1])}}function Ce(e){var t=-1,n=e?e.length:0;for(this.clear();++t<n;){var s=e[t];this.set(s[0],s[1])}}function ze(e){this.__data__=new ke(e)}function Pe(e,t,n){var s=e[t];ee.call(e,t)&&Ie(s,n)&&(void 0!==n||t in e)||(e[t]=n)}function Fe(e,t){for(var n=e.length;n--;)if(Ie(e[n][0],t))return n;return-1}function Ne(e,t,n,s,r,h,b){var F;if(s&&(F=h?s(e,r,h,b):s(e)),void 0!==F)return F;if(!qe(e))return e;var N=Xe(e);if(N){if(F=function(e){var t=e.length,n=e.constructor(t);return t&&"string"==typeof e[0]&&ee.call(e,"index")&&(n.index=e.index,n.input=e.input),n}(e),!t)return function(e,t){var n=-1,s=e.length;for(t||(t=Array(s));++n<s;)t[n]=e[n];return t}(e,F)}else{var L=Be(e),O=L==l||L==c;if(Je(e))return function(e,t){if(t)return e.slice();var n=new e.constructor(e.length);return e.copy(n),n}(e,t);if(L==f||L==a||O&&!h){if(X(e))return h?e:{};if(F=function(e){return"function"!=typeof e.constructor||je(e)?{}:qe(t=ie(e))?oe(t):{};var t}(O?{}:e),!t)return function(e,t){return Le(e,Me(e),t)}(e,function(e,t){return e&&Le(t,Ke(t),e)}(F,e))}else{if(!G[L])return h?e:{};F=function(e,t,n,s){var r,a=e.constructor;switch(t){case y:return Ge(e);case i:case o:return new a(+e);case v:return function(e,t){var n=t?Ge(e.buffer):e.buffer;return new e.constructor(n,e.byteOffset,e.byteLength)}(e,s);case w:case A:case E:case x:case S:case T:case k:case C:case z:return function(e,t){var n=t?Ge(e.buffer):e.buffer;return new e.constructor(n,e.byteOffset,e.length)}(e,s);case d:return function(e,t,n){return I(t?n(U(e),!0):U(e),j,new e.constructor)}(e,s,n);case u:case m:return new a(e);case p:return function(e){var t=new e.constructor(e.source,P.exec(e));return t.lastIndex=e.lastIndex,t}(e);case _:return function(e,t,n){return I(t?n(D(e),!0):D(e),H,new e.constructor)}(e,s,n);case g:return r=e,Se?Object(Se.call(r)):{}}}(e,L,Ne,t)}}b||(b=new ze);var R=b.get(e);if(R)return R;if(b.set(e,F),!N)var M=n?function(e){return function(e,t,n){var s=t(e);return Xe(e)?s:function(e,t){for(var n=-1,s=t.length,r=e.length;++n<s;)e[r+n]=t[n];return e}(s,n(e))}(e,Ke,Me)}(e):Ke(e);return function(e,t){for(var n=-1,s=e?e.length:0;++n<s&&!1!==t(e[n],n););}(M||e,(function(r,a){M&&(r=e[a=r]),Pe(F,a,Ne(r,t,n,s,a,e,b))})),F}function Ge(e){var t=new e.constructor(e.byteLength);return new ae(t).set(new ae(e)),t}function Le(e,t,n,s){n||(n={});for(var r=-1,a=t.length;++r<a;){var i=t[r],o=s?s(n[i],e[i],i,n,e):void 0;Pe(n,i,void 0===o?e[i]:o)}return n}function Oe(e,t){var n,s,r=e.__data__;return("string"==(s=typeof(n=t))||"number"==s||"symbol"==s||"boolean"==s?"__proto__"!==n:null===n)?r["string"==typeof t?"string":"hash"]:r.map}function Re(e,t){var n=function(e,t){return null==e?void 0:e[t]}(e,t);return function(e){return!(!qe(e)||(t=e,Q&&Q in t))&&(De(e)||X(e)?ne:F).test(He(e));var t}(n)?n:void 0}Te.prototype.clear=function(){this.__data__=be?be(null):{}},Te.prototype.delete=function(e){return this.has(e)&&delete this.__data__[e]},Te.prototype.get=function(e){var t=this.__data__;if(be){var n=t[e];return n===s?void 0:n}return ee.call(t,e)?t[e]:void 0},Te.prototype.has=function(e){var t=this.__data__;return be?void 0!==t[e]:ee.call(t,e)},Te.prototype.set=function(e,t){return this.__data__[e]=be&&void 0===t?s:t,this},ke.prototype.clear=function(){this.__data__=[]},ke.prototype.delete=function(e){var t=this.__data__,n=Fe(t,e);return!(n<0||(n==t.length-1?t.pop():ce.call(t,n,1),0))},ke.prototype.get=function(e){var t=this.__data__,n=Fe(t,e);return n<0?void 0:t[n][1]},ke.prototype.has=function(e){return Fe(this.__data__,e)>-1},ke.prototype.set=function(e,t){var n=this.__data__,s=Fe(n,e);return s<0?n.push([e,t]):n[s][1]=t,this},Ce.prototype.clear=function(){this.__data__={hash:new Te,map:new(pe||ke),string:new Te}},Ce.prototype.delete=function(e){return Oe(this,e).delete(e)},Ce.prototype.get=function(e){return Oe(this,e).get(e)},Ce.prototype.has=function(e){return Oe(this,e).has(e)},Ce.prototype.set=function(e,t){return Oe(this,e).set(e,t),this},ze.prototype.clear=function(){this.__data__=new ke},ze.prototype.delete=function(e){return this.__data__.delete(e)},ze.prototype.get=function(e){return this.__data__.get(e)},ze.prototype.has=function(e){return this.__data__.has(e)},ze.prototype.set=function(e,t){var n=this.__data__;if(n instanceof ke){var s=n.__data__;if(!pe||s.length<199)return s.push([e,t]),this;n=this.__data__=new Ce(s)}return n.set(e,t),this};var Me=de?J(de,Object):function(){return[]},Be=function(e){return te.call(e)};function Ye(e,t){return!!(t=null==t?r:t)&&("number"==typeof e||N.test(e))&&e>-1&&e%1==0&&e<t}function je(e){var t=e&&e.constructor;return e===("function"==typeof t&&t.prototype||Z)}function He(e){if(null!=e){try{return $.call(e)}catch(e){}try{return e+""}catch(e){}}return""}function Ie(e,t){return e===t||e!=e&&t!=t}(he&&Be(new he(new ArrayBuffer(1)))!=v||pe&&Be(new pe)!=d||_e&&Be(_e.resolve())!=h||me&&Be(new me)!=_||ge&&Be(new ge)!=b)&&(Be=function(e){var t=te.call(e),n=t==f?e.constructor:void 0,s=n?He(n):void 0;if(s)switch(s){case ye:return v;case ve:return d;case we:return h;case Ae:return _;case Ee:return b}return t});var Xe=Array.isArray;function Ue(e){return null!=e&&function(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=r}(e.length)&&!De(e)}var Je=ue||function(){return!1};function De(e){var t=qe(e)?te.call(e):"";return t==l||t==c}function qe(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}function Ke(e){return Ue(e)?function(e,t){var n=Xe(e)||function(e){return function(e){return function(e){return!!e&&"object"==typeof e}(e)&&Ue(e)}(e)&&ee.call(e,"callee")&&(!le.call(e,"callee")||te.call(e)==a)}(e)?function(e,t){for(var n=-1,s=Array(e);++n<e;)s[n]=t(n);return s}(e.length,String):[],s=n.length,r=!!s;for(var i in e)!t&&!ee.call(e,i)||r&&("length"==i||Ye(i,s))||n.push(i);return n}(e):function(e){if(!je(e))return fe(e);var t=[];for(var n in Object(e))ee.call(e,n)&&"constructor"!=n&&t.push(n);return t}(e)}e.exports=function(e,t){return Ne(e,!0,!0,t)}},7842:(e,t,n)=>{e=n.nmd(e);var s="__lodash_hash_undefined__",r=9007199254740991,a="[object Arguments]",i="[object Array]",o="[object Boolean]",l="[object Date]",c="[object Error]",d="[object Function]",u="[object Map]",f="[object Number]",h="[object Object]",p="[object Promise]",_="[object RegExp]",m="[object Set]",g="[object String]",b="[object WeakMap]",y="[object ArrayBuffer]",v="[object DataView]",w=/^\[object .+?Constructor\]$/,A=/^(?:0|[1-9]\d*)$/,E={};E["[object Float32Array]"]=E["[object Float64Array]"]=E["[object Int8Array]"]=E["[object Int16Array]"]=E["[object Int32Array]"]=E["[object Uint8Array]"]=E["[object Uint8ClampedArray]"]=E["[object Uint16Array]"]=E["[object Uint32Array]"]=!0,E[a]=E[i]=E[y]=E[o]=E[v]=E[l]=E[c]=E[d]=E[u]=E[f]=E[h]=E[_]=E[m]=E[g]=E[b]=!1;var x="object"==typeof n.g&&n.g&&n.g.Object===Object&&n.g,S="object"==typeof self&&self&&self.Object===Object&&self,T=x||S||Function("return this")(),k=t&&!t.nodeType&&t,C=k&&e&&!e.nodeType&&e,z=C&&C.exports===k,P=z&&x.process,F=function(){try{return P&&P.binding&&P.binding("util")}catch(e){}}(),N=F&&F.isTypedArray;function G(e,t){for(var n=-1,s=null==e?0:e.length;++n<s;)if(t(e[n],n,e))return!0;return!1}function L(e){var t=-1,n=Array(e.size);return e.forEach((function(e,s){n[++t]=[s,e]})),n}function O(e){var t=-1,n=Array(e.size);return e.forEach((function(e){n[++t]=e})),n}var R,M,B,Y=Array.prototype,j=Function.prototype,H=Object.prototype,I=T["__core-js_shared__"],X=j.toString,U=H.hasOwnProperty,J=(R=/[^.]+$/.exec(I&&I.keys&&I.keys.IE_PROTO||""))?"Symbol(src)_1."+R:"",D=H.toString,q=RegExp("^"+X.call(U).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),K=z?T.Buffer:void 0,W=T.Symbol,Z=T.Uint8Array,V=H.propertyIsEnumerable,Q=Y.splice,$=W?W.toStringTag:void 0,ee=Object.getOwnPropertySymbols,te=K?K.isBuffer:void 0,ne=(M=Object.keys,B=Object,function(e){return M(B(e))}),se=Ce(T,"DataView"),re=Ce(T,"Map"),ae=Ce(T,"Promise"),ie=Ce(T,"Set"),oe=Ce(T,"WeakMap"),le=Ce(Object,"create"),ce=Ne(se),de=Ne(re),ue=Ne(ae),fe=Ne(ie),he=Ne(oe),pe=W?W.prototype:void 0,_e=pe?pe.valueOf:void 0;function me(e){var t=-1,n=null==e?0:e.length;for(this.clear();++t<n;){var s=e[t];this.set(s[0],s[1])}}function ge(e){var t=-1,n=null==e?0:e.length;for(this.clear();++t<n;){var s=e[t];this.set(s[0],s[1])}}function be(e){var t=-1,n=null==e?0:e.length;for(this.clear();++t<n;){var s=e[t];this.set(s[0],s[1])}}function ye(e){var t=-1,n=null==e?0:e.length;for(this.__data__=new be;++t<n;)this.add(e[t])}function ve(e){var t=this.__data__=new ge(e);this.size=t.size}function we(e,t){for(var n=e.length;n--;)if(Ge(e[n][0],t))return n;return-1}function Ae(e){return null==e?void 0===e?"[object Undefined]":"[object Null]":$&&$ in Object(e)?function(e){var t=U.call(e,$),n=e[$];try{e[$]=void 0;var s=!0}catch(e){}var r=D.call(e);return s&&(t?e[$]=n:delete e[$]),r}(e):function(e){return D.call(e)}(e)}function Ee(e){return je(e)&&Ae(e)==a}function xe(e,t,n,s,r){return e===t||(null==e||null==t||!je(e)&&!je(t)?e!=e&&t!=t:function(e,t,n,s,r,d){var p=Oe(e),b=Oe(t),w=p?i:Pe(e),A=b?i:Pe(t),E=(w=w==a?h:w)==h,x=(A=A==a?h:A)==h,S=w==A;if(S&&Re(e)){if(!Re(t))return!1;p=!0,E=!1}if(S&&!E)return d||(d=new ve),p||He(e)?Se(e,t,n,s,r,d):function(e,t,n,s,r,a,i){switch(n){case v:if(e.byteLength!=t.byteLength||e.byteOffset!=t.byteOffset)return!1;e=e.buffer,t=t.buffer;case y:return!(e.byteLength!=t.byteLength||!a(new Z(e),new Z(t)));case o:case l:case f:return Ge(+e,+t);case c:return e.name==t.name&&e.message==t.message;case _:case g:return e==t+"";case u:var d=L;case m:var h=1&s;if(d||(d=O),e.size!=t.size&&!h)return!1;var p=i.get(e);if(p)return p==t;s|=2,i.set(e,t);var b=Se(d(e),d(t),s,r,a,i);return i.delete(e),b;case"[object Symbol]":if(_e)return _e.call(e)==_e.call(t)}return!1}(e,t,w,n,s,r,d);if(!(1&n)){var T=E&&U.call(e,"__wrapped__"),k=x&&U.call(t,"__wrapped__");if(T||k){var C=T?e.value():e,z=k?t.value():t;return d||(d=new ve),r(C,z,n,s,d)}}return!!S&&(d||(d=new ve),function(e,t,n,s,r,a){var i=1&n,o=Te(e),l=o.length;if(l!=Te(t).length&&!i)return!1;for(var c=l;c--;){var d=o[c];if(!(i?d in t:U.call(t,d)))return!1}var u=a.get(e);if(u&&a.get(t))return u==t;var f=!0;a.set(e,t),a.set(t,e);for(var h=i;++c<l;){var p=e[d=o[c]],_=t[d];if(s)var m=i?s(_,p,d,t,e,a):s(p,_,d,e,t,a);if(!(void 0===m?p===_||r(p,_,n,s,a):m)){f=!1;break}h||(h="constructor"==d)}if(f&&!h){var g=e.constructor,b=t.constructor;g==b||!("constructor"in e)||!("constructor"in t)||"function"==typeof g&&g instanceof g&&"function"==typeof b&&b instanceof b||(f=!1)}return a.delete(e),a.delete(t),f}(e,t,n,s,r,d))}(e,t,n,s,xe,r))}function Se(e,t,n,s,r,a){var i=1&n,o=e.length,l=t.length;if(o!=l&&!(i&&l>o))return!1;var c=a.get(e);if(c&&a.get(t))return c==t;var d=-1,u=!0,f=2&n?new ye:void 0;for(a.set(e,t),a.set(t,e);++d<o;){var h=e[d],p=t[d];if(s)var _=i?s(p,h,d,t,e,a):s(h,p,d,e,t,a);if(void 0!==_){if(_)continue;u=!1;break}if(f){if(!G(t,(function(e,t){if(i=t,!f.has(i)&&(h===e||r(h,e,n,s,a)))return f.push(t);var i}))){u=!1;break}}else if(h!==p&&!r(h,p,n,s,a)){u=!1;break}}return a.delete(e),a.delete(t),u}function Te(e){return function(e,t,n){var s=t(e);return Oe(e)?s:function(e,t){for(var n=-1,s=t.length,r=e.length;++n<s;)e[r+n]=t[n];return e}(s,n(e))}(e,Ie,ze)}function ke(e,t){var n,s,r=e.__data__;return("string"==(s=typeof(n=t))||"number"==s||"symbol"==s||"boolean"==s?"__proto__"!==n:null===n)?r["string"==typeof t?"string":"hash"]:r.map}function Ce(e,t){var n=function(e,t){return null==e?void 0:e[t]}(e,t);return function(e){return!(!Ye(e)||function(e){return!!J&&J in e}(e))&&(Me(e)?q:w).test(Ne(e))}(n)?n:void 0}me.prototype.clear=function(){this.__data__=le?le(null):{},this.size=0},me.prototype.delete=function(e){var t=this.has(e)&&delete this.__data__[e];return this.size-=t?1:0,t},me.prototype.get=function(e){var t=this.__data__;if(le){var n=t[e];return n===s?void 0:n}return U.call(t,e)?t[e]:void 0},me.prototype.has=function(e){var t=this.__data__;return le?void 0!==t[e]:U.call(t,e)},me.prototype.set=function(e,t){var n=this.__data__;return this.size+=this.has(e)?0:1,n[e]=le&&void 0===t?s:t,this},ge.prototype.clear=function(){this.__data__=[],this.size=0},ge.prototype.delete=function(e){var t=this.__data__,n=we(t,e);return!(n<0||(n==t.length-1?t.pop():Q.call(t,n,1),--this.size,0))},ge.prototype.get=function(e){var t=this.__data__,n=we(t,e);return n<0?void 0:t[n][1]},ge.prototype.has=function(e){return we(this.__data__,e)>-1},ge.prototype.set=function(e,t){var n=this.__data__,s=we(n,e);return s<0?(++this.size,n.push([e,t])):n[s][1]=t,this},be.prototype.clear=function(){this.size=0,this.__data__={hash:new me,map:new(re||ge),string:new me}},be.prototype.delete=function(e){var t=ke(this,e).delete(e);return this.size-=t?1:0,t},be.prototype.get=function(e){return ke(this,e).get(e)},be.prototype.has=function(e){return ke(this,e).has(e)},be.prototype.set=function(e,t){var n=ke(this,e),s=n.size;return n.set(e,t),this.size+=n.size==s?0:1,this},ye.prototype.add=ye.prototype.push=function(e){return this.__data__.set(e,s),this},ye.prototype.has=function(e){return this.__data__.has(e)},ve.prototype.clear=function(){this.__data__=new ge,this.size=0},ve.prototype.delete=function(e){var t=this.__data__,n=t.delete(e);return this.size=t.size,n},ve.prototype.get=function(e){return this.__data__.get(e)},ve.prototype.has=function(e){return this.__data__.has(e)},ve.prototype.set=function(e,t){var n=this.__data__;if(n instanceof ge){var s=n.__data__;if(!re||s.length<199)return s.push([e,t]),this.size=++n.size,this;n=this.__data__=new be(s)}return n.set(e,t),this.size=n.size,this};var ze=ee?function(e){return null==e?[]:(e=Object(e),function(t){for(var n=-1,s=null==t?0:t.length,r=0,a=[];++n<s;){var i=t[n];o=i,V.call(e,o)&&(a[r++]=i)}var o;return a}(ee(e)))}:function(){return[]},Pe=Ae;function Fe(e,t){return!!(t=null==t?r:t)&&("number"==typeof e||A.test(e))&&e>-1&&e%1==0&&e<t}function Ne(e){if(null!=e){try{return X.call(e)}catch(e){}try{return e+""}catch(e){}}return""}function Ge(e,t){return e===t||e!=e&&t!=t}(se&&Pe(new se(new ArrayBuffer(1)))!=v||re&&Pe(new re)!=u||ae&&Pe(ae.resolve())!=p||ie&&Pe(new ie)!=m||oe&&Pe(new oe)!=b)&&(Pe=function(e){var t=Ae(e),n=t==h?e.constructor:void 0,s=n?Ne(n):"";if(s)switch(s){case ce:return v;case de:return u;case ue:return p;case fe:return m;case he:return b}return t});var Le=Ee(function(){return arguments}())?Ee:function(e){return je(e)&&U.call(e,"callee")&&!V.call(e,"callee")},Oe=Array.isArray,Re=te||function(){return!1};function Me(e){if(!Ye(e))return!1;var t=Ae(e);return t==d||"[object GeneratorFunction]"==t||"[object AsyncFunction]"==t||"[object Proxy]"==t}function Be(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=r}function Ye(e){var t=typeof e;return null!=e&&("object"==t||"function"==t)}function je(e){return null!=e&&"object"==typeof e}var He=N?function(e){return function(t){return e(t)}}(N):function(e){return je(e)&&Be(e.length)&&!!E[Ae(e)]};function Ie(e){return null!=(t=e)&&Be(t.length)&&!Me(t)?function(e,t){var n=Oe(e),s=!n&&Le(e),r=!n&&!s&&Re(e),a=!n&&!s&&!r&&He(e),i=n||s||r||a,o=i?function(e,t){for(var n=-1,s=Array(e);++n<e;)s[n]=t(n);return s}(e.length,String):[],l=o.length;for(var c in e)!t&&!U.call(e,c)||i&&("length"==c||r&&("offset"==c||"parent"==c)||a&&("buffer"==c||"byteLength"==c||"byteOffset"==c)||Fe(c,l))||o.push(c);return o}(e):function(e){if(n=(t=e)&&t.constructor,t!==("function"==typeof n&&n.prototype||H))return ne(e);var t,n,s=[];for(var r in Object(e))U.call(e,r)&&"constructor"!=r&&s.push(r);return s}(e);var t}e.exports=function(e,t){return xe(e,t)}},2848:(e,t,n)=>{var s=n(198),r=n(7293),a=n(1817).Buffer,i=new Array(16);function o(){r.call(this,64),this._a=1732584193,this._b=4023233417,this._c=2562383102,this._d=271733878}function l(e,t){return e<<t|e>>>32-t}function c(e,t,n,s,r,a,i){return l(e+(t&n|~t&s)+r+a|0,i)+t|0}function d(e,t,n,s,r,a,i){return l(e+(t&s|n&~s)+r+a|0,i)+t|0}function u(e,t,n,s,r,a,i){return l(e+(t^n^s)+r+a|0,i)+t|0}function f(e,t,n,s,r,a,i){return l(e+(n^(t|~s))+r+a|0,i)+t|0}s(o,r),o.prototype._update=function(){for(var e=i,t=0;t<16;++t)e[t]=this._block.readInt32LE(4*t);var n=this._a,s=this._b,r=this._c,a=this._d;n=c(n,s,r,a,e[0],3614090360,7),a=c(a,n,s,r,e[1],3905402710,12),r=c(r,a,n,s,e[2],606105819,17),s=c(s,r,a,n,e[3],3250441966,22),n=c(n,s,r,a,e[4],4118548399,7),a=c(a,n,s,r,e[5],1200080426,12),r=c(r,a,n,s,e[6],2821735955,17),s=c(s,r,a,n,e[7],4249261313,22),n=c(n,s,r,a,e[8],1770035416,7),a=c(a,n,s,r,e[9],2336552879,12),r=c(r,a,n,s,e[10],4294925233,17),s=c(s,r,a,n,e[11],2304563134,22),n=c(n,s,r,a,e[12],1804603682,7),a=c(a,n,s,r,e[13],4254626195,12),r=c(r,a,n,s,e[14],2792965006,17),n=d(n,s=c(s,r,a,n,e[15],1236535329,22),r,a,e[1],4129170786,5),a=d(a,n,s,r,e[6],3225465664,9),r=d(r,a,n,s,e[11],643717713,14),s=d(s,r,a,n,e[0],3921069994,20),n=d(n,s,r,a,e[5],3593408605,5),a=d(a,n,s,r,e[10],38016083,9),r=d(r,a,n,s,e[15],3634488961,14),s=d(s,r,a,n,e[4],3889429448,20),n=d(n,s,r,a,e[9],568446438,5),a=d(a,n,s,r,e[14],3275163606,9),r=d(r,a,n,s,e[3],4107603335,14),s=d(s,r,a,n,e[8],1163531501,20),n=d(n,s,r,a,e[13],2850285829,5),a=d(a,n,s,r,e[2],4243563512,9),r=d(r,a,n,s,e[7],1735328473,14),n=u(n,s=d(s,r,a,n,e[12],2368359562,20),r,a,e[5],4294588738,4),a=u(a,n,s,r,e[8],2272392833,11),r=u(r,a,n,s,e[11],1839030562,16),s=u(s,r,a,n,e[14],4259657740,23),n=u(n,s,r,a,e[1],2763975236,4),a=u(a,n,s,r,e[4],1272893353,11),r=u(r,a,n,s,e[7],4139469664,16),s=u(s,r,a,n,e[10],3200236656,23),n=u(n,s,r,a,e[13],681279174,4),a=u(a,n,s,r,e[0],3936430074,11),r=u(r,a,n,s,e[3],3572445317,16),s=u(s,r,a,n,e[6],76029189,23),n=u(n,s,r,a,e[9],3654602809,4),a=u(a,n,s,r,e[12],3873151461,11),r=u(r,a,n,s,e[15],530742520,16),n=f(n,s=u(s,r,a,n,e[2],3299628645,23),r,a,e[0],4096336452,6),a=f(a,n,s,r,e[7],1126891415,10),r=f(r,a,n,s,e[14],2878612391,15),s=f(s,r,a,n,e[5],4237533241,21),n=f(n,s,r,a,e[12],1700485571,6),a=f(a,n,s,r,e[3],2399980690,10),r=f(r,a,n,s,e[10],4293915773,15),s=f(s,r,a,n,e[1],2240044497,21),n=f(n,s,r,a,e[8],1873313359,6),a=f(a,n,s,r,e[15],4264355552,10),r=f(r,a,n,s,e[6],2734768916,15),s=f(s,r,a,n,e[13],1309151649,21),n=f(n,s,r,a,e[4],4149444226,6),a=f(a,n,s,r,e[11],3174756917,10),r=f(r,a,n,s,e[2],718787259,15),s=f(s,r,a,n,e[9],3951481745,21),this._a=this._a+n|0,this._b=this._b+s|0,this._c=this._c+r|0,this._d=this._d+a|0},o.prototype._digest=function(){this._block[this._blockOffset++]=128,this._blockOffset>56&&(this._block.fill(0,this._blockOffset,64),this._update(),this._blockOffset=0),this._block.fill(0,this._blockOffset,56),this._block.writeUInt32LE(this._length[0],56),this._block.writeUInt32LE(this._length[1],60),this._update();var e=a.allocUnsafe(16);return e.writeInt32LE(this._a,0),e.writeInt32LE(this._b,4),e.writeInt32LE(this._c,8),e.writeInt32LE(this._d,12),e},e.exports=o},73:e=>{function t(e,t){if(!e)throw new Error(t||"Assertion failed")}e.exports=t,t.equal=function(e,t,n){if(e!=t)throw new Error(n||"Assertion failed: "+e+" != "+t)}},6301:e=>{var t=1e3,n=60*t,s=60*n,r=24*s,a=7*r;function i(e,t,n,s){var r=t>=1.5*n;return Math.round(e/n)+" "+s+(r?"s":"")}e.exports=function(e,o){o=o||{};var l,c,d=typeof e;if("string"===d&&e.length>0)return function(e){if(!((e=String(e)).length>100)){var i=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);if(i){var o=parseFloat(i[1]);switch((i[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return 315576e5*o;case"weeks":case"week":case"w":return o*a;case"days":case"day":case"d":return o*r;case"hours":case"hour":case"hrs":case"hr":case"h":return o*s;case"minutes":case"minute":case"mins":case"min":case"m":return o*n;case"seconds":case"second":case"secs":case"sec":case"s":return o*t;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return o;default:return}}}}(e);if("number"===d&&isFinite(e))return o.long?(l=e,(c=Math.abs(l))>=r?i(l,c,r,"day"):c>=s?i(l,c,s,"hour"):c>=n?i(l,c,n,"minute"):c>=t?i(l,c,t,"second"):l+" ms"):function(e){var a=Math.abs(e);return a>=r?Math.round(e/r)+"d":a>=s?Math.round(e/s)+"h":a>=n?Math.round(e/n)+"m":a>=t?Math.round(e/t)+"s":e+"ms"}(e);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(e))}},6350:e=>{e.exports=["Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","BigInt64Array","BigUint64Array"]},9476:e=>{var t={};function n(e,n,s){s||(s=Error);var r=function(e){var t,s;function r(t,s,r){return e.call(this,function(e,t,s){return"string"==typeof n?n:n(e,t,s)}(t,s,r))||this}return s=e,(t=r).prototype=Object.create(s.prototype),t.prototype.constructor=t,t.__proto__=s,r}(s);r.prototype.name=s.name,r.prototype.code=e,t[e]=r}function s(e,t){if(Array.isArray(e)){var n=e.length;return e=e.map((function(e){return String(e)})),n>2?"one of ".concat(t," ").concat(e.slice(0,n-1).join(", "),", or ")+e[n-1]:2===n?"one of ".concat(t," ").concat(e[0]," or ").concat(e[1]):"of ".concat(t," ").concat(e[0])}return"of ".concat(t," ").concat(String(e))}n("ERR_INVALID_OPT_VALUE",(function(e,t){return'The value "'+t+'" is invalid for option "'+e+'"'}),TypeError),n("ERR_INVALID_ARG_TYPE",(function(e,t,n){var r,a,i,o,l;if("string"==typeof t&&(a="not ",t.substr(0,4)===a)?(r="must not be",t=t.replace(/^not /,"")):r="must be",function(e,t,n){return(void 0===n||n>e.length)&&(n=e.length),e.substring(n-9,n)===t}(e," argument"))i="The ".concat(e," ").concat(r," ").concat(s(t,"type"));else{var c=("number"!=typeof l&&(l=0),l+1>(o=e).length||-1===o.indexOf(".",l)?"argument":"property");i='The "'.concat(e,'" ').concat(c," ").concat(r," ").concat(s(t,"type"))}return i+". Received type ".concat(typeof n)}),TypeError),n("ERR_STREAM_PUSH_AFTER_EOF","stream.push() after EOF"),n("ERR_METHOD_NOT_IMPLEMENTED",(function(e){return"The "+e+" method is not implemented"})),n("ERR_STREAM_PREMATURE_CLOSE","Premature close"),n("ERR_STREAM_DESTROYED",(function(e){return"Cannot call "+e+" after a stream was destroyed"})),n("ERR_MULTIPLE_CALLBACK","Callback called multiple times"),n("ERR_STREAM_CANNOT_PIPE","Cannot pipe, not readable"),n("ERR_STREAM_WRITE_AFTER_END","write after end"),n("ERR_STREAM_NULL_VALUES","May not write null values to stream",TypeError),n("ERR_UNKNOWN_ENCODING",(function(e){return"Unknown encoding: "+e}),TypeError),n("ERR_STREAM_UNSHIFT_AFTER_END_EVENT","stream.unshift() after end event"),e.exports.F=t},7890:(e,t,n)=>{var s=Object.keys||function(e){var t=[];for(var n in e)t.push(n);return t};e.exports=c;var r=n(9616),a=n(3920);n(198)(c,r);for(var i=s(a.prototype),o=0;o<i.length;o++){var l=i[o];c.prototype[l]||(c.prototype[l]=a.prototype[l])}function c(e){if(!(this instanceof c))return new c(e);r.call(this,e),a.call(this,e),this.allowHalfOpen=!0,e&&(!1===e.readable&&(this.readable=!1),!1===e.writable&&(this.writable=!1),!1===e.allowHalfOpen&&(this.allowHalfOpen=!1,this.once("end",d)))}function d(){this._writableState.ended||process.nextTick(u,this)}function u(e){e.end()}Object.defineProperty(c.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),Object.defineProperty(c.prototype,"writableBuffer",{enumerable:!1,get:function(){return this._writableState&&this._writableState.getBuffer()}}),Object.defineProperty(c.prototype,"writableLength",{enumerable:!1,get:function(){return this._writableState.length}}),Object.defineProperty(c.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._readableState&&void 0!==this._writableState&&this._readableState.destroyed&&this._writableState.destroyed},set:function(e){void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed=e,this._writableState.destroyed=e)}})},8180:(e,t,n)=>{e.exports=r;var s=n(5118);function r(e){if(!(this instanceof r))return new r(e);s.call(this,e)}n(198)(r,s),r.prototype._transform=function(e,t,n){n(null,e)}},9616:(e,t,n)=>{var s;e.exports=x,x.ReadableState=E,n(6827).EventEmitter;var r,a=function(e,t){return e.listeners(t).length},i=n(1341),o=n(8891).Buffer,l=(void 0!==n.g?n.g:"undefined"!=typeof window?window:"undefined"!=typeof self?self:{}).Uint8Array||function(){},c=n(4098);r=c&&c.debuglog?c.debuglog("stream"):function(){};var d,u,f,h=n(8373),p=n(7804),_=n(2103).getHighWaterMark,m=n(9476).F,g=m.ERR_INVALID_ARG_TYPE,b=m.ERR_STREAM_PUSH_AFTER_EOF,y=m.ERR_METHOD_NOT_IMPLEMENTED,v=m.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;n(198)(x,i);var w=p.errorOrDestroy,A=["error","close","destroy","pause","resume"];function E(e,t,r){s=s||n(7890),e=e||{},"boolean"!=typeof r&&(r=t instanceof s),this.objectMode=!!e.objectMode,r&&(this.objectMode=this.objectMode||!!e.readableObjectMode),this.highWaterMark=_(this,e,"readableHighWaterMark",r),this.buffer=new h,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.paused=!0,this.emitClose=!1!==e.emitClose,this.autoDestroy=!!e.autoDestroy,this.destroyed=!1,this.defaultEncoding=e.defaultEncoding||"utf8",this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,e.encoding&&(d||(d=n(3102).I),this.decoder=new d(e.encoding),this.encoding=e.encoding)}function x(e){if(s=s||n(7890),!(this instanceof x))return new x(e);var t=this instanceof s;this._readableState=new E(e,this,t),this.readable=!0,e&&("function"==typeof e.read&&(this._read=e.read),"function"==typeof e.destroy&&(this._destroy=e.destroy)),i.call(this)}function S(e,t,n,s,a){r("readableAddChunk",t);var i,c=e._readableState;if(null===t)c.reading=!1,function(e,t){if(r("onEofChunk"),!t.ended){if(t.decoder){var n=t.decoder.end();n&&n.length&&(t.buffer.push(n),t.length+=t.objectMode?1:n.length)}t.ended=!0,t.sync?z(e):(t.needReadable=!1,t.emittedReadable||(t.emittedReadable=!0,P(e)))}}(e,c);else if(a||(i=function(e,t){var n,s;return s=t,o.isBuffer(s)||s instanceof l||"string"==typeof t||void 0===t||e.objectMode||(n=new g("chunk",["string","Buffer","Uint8Array"],t)),n}(c,t)),i)w(e,i);else if(c.objectMode||t&&t.length>0)if("string"==typeof t||c.objectMode||Object.getPrototypeOf(t)===o.prototype||(t=function(e){return o.from(e)}(t)),s)c.endEmitted?w(e,new v):T(e,c,t,!0);else if(c.ended)w(e,new b);else{if(c.destroyed)return!1;c.reading=!1,c.decoder&&!n?(t=c.decoder.write(t),c.objectMode||0!==t.length?T(e,c,t,!1):F(e,c)):T(e,c,t,!1)}else s||(c.reading=!1,F(e,c));return!c.ended&&(c.length<c.highWaterMark||0===c.length)}function T(e,t,n,s){t.flowing&&0===t.length&&!t.sync?(t.awaitDrain=0,e.emit("data",n)):(t.length+=t.objectMode?1:n.length,s?t.buffer.unshift(n):t.buffer.push(n),t.needReadable&&z(e)),F(e,t)}Object.defineProperty(x.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._readableState&&this._readableState.destroyed},set:function(e){this._readableState&&(this._readableState.destroyed=e)}}),x.prototype.destroy=p.destroy,x.prototype._undestroy=p.undestroy,x.prototype._destroy=function(e,t){t(e)},x.prototype.push=function(e,t){var n,s=this._readableState;return s.objectMode?n=!0:"string"==typeof e&&((t=t||s.defaultEncoding)!==s.encoding&&(e=o.from(e,t),t=""),n=!0),S(this,e,t,!1,n)},x.prototype.unshift=function(e){return S(this,e,null,!0,!1)},x.prototype.isPaused=function(){return!1===this._readableState.flowing},x.prototype.setEncoding=function(e){d||(d=n(3102).I);var t=new d(e);this._readableState.decoder=t,this._readableState.encoding=this._readableState.decoder.encoding;for(var s=this._readableState.buffer.head,r="";null!==s;)r+=t.write(s.data),s=s.next;return this._readableState.buffer.clear(),""!==r&&this._readableState.buffer.push(r),this._readableState.length=r.length,this};var k=1073741824;function C(e,t){return e<=0||0===t.length&&t.ended?0:t.objectMode?1:e!=e?t.flowing&&t.length?t.buffer.head.data.length:t.length:(e>t.highWaterMark&&(t.highWaterMark=function(e){return e>=k?e=k:(e--,e|=e>>>1,e|=e>>>2,e|=e>>>4,e|=e>>>8,e|=e>>>16,e++),e}(e)),e<=t.length?e:t.ended?t.length:(t.needReadable=!0,0))}function z(e){var t=e._readableState;r("emitReadable",t.needReadable,t.emittedReadable),t.needReadable=!1,t.emittedReadable||(r("emitReadable",t.flowing),t.emittedReadable=!0,process.nextTick(P,e))}function P(e){var t=e._readableState;r("emitReadable_",t.destroyed,t.length,t.ended),t.destroyed||!t.length&&!t.ended||(e.emit("readable"),t.emittedReadable=!1),t.needReadable=!t.flowing&&!t.ended&&t.length<=t.highWaterMark,R(e)}function F(e,t){t.readingMore||(t.readingMore=!0,process.nextTick(N,e,t))}function N(e,t){for(;!t.reading&&!t.ended&&(t.length<t.highWaterMark||t.flowing&&0===t.length);){var n=t.length;if(r("maybeReadMore read 0"),e.read(0),n===t.length)break}t.readingMore=!1}function G(e){var t=e._readableState;t.readableListening=e.listenerCount("readable")>0,t.resumeScheduled&&!t.paused?t.flowing=!0:e.listenerCount("data")>0&&e.resume()}function L(e){r("readable nexttick read 0"),e.read(0)}function O(e,t){r("resume",t.reading),t.reading||e.read(0),t.resumeScheduled=!1,e.emit("resume"),R(e),t.flowing&&!t.reading&&e.read(0)}function R(e){var t=e._readableState;for(r("flow",t.flowing);t.flowing&&null!==e.read(););}function M(e,t){return 0===t.length?null:(t.objectMode?n=t.buffer.shift():!e||e>=t.length?(n=t.decoder?t.buffer.join(""):1===t.buffer.length?t.buffer.first():t.buffer.concat(t.length),t.buffer.clear()):n=t.buffer.consume(e,t.decoder),n);var n}function B(e){var t=e._readableState;r("endReadable",t.endEmitted),t.endEmitted||(t.ended=!0,process.nextTick(Y,t,e))}function Y(e,t){if(r("endReadableNT",e.endEmitted,e.length),!e.endEmitted&&0===e.length&&(e.endEmitted=!0,t.readable=!1,t.emit("end"),e.autoDestroy)){var n=t._writableState;(!n||n.autoDestroy&&n.finished)&&t.destroy()}}function j(e,t){for(var n=0,s=e.length;n<s;n++)if(e[n]===t)return n;return-1}x.prototype.read=function(e){r("read",e),e=parseInt(e,10);var t=this._readableState,n=e;if(0!==e&&(t.emittedReadable=!1),0===e&&t.needReadable&&((0!==t.highWaterMark?t.length>=t.highWaterMark:t.length>0)||t.ended))return r("read: emitReadable",t.length,t.ended),0===t.length&&t.ended?B(this):z(this),null;if(0===(e=C(e,t))&&t.ended)return 0===t.length&&B(this),null;var s,a=t.needReadable;return r("need readable",a),(0===t.length||t.length-e<t.highWaterMark)&&r("length less than watermark",a=!0),t.ended||t.reading?r("reading or ended",a=!1):a&&(r("do read"),t.reading=!0,t.sync=!0,0===t.length&&(t.needReadable=!0),this._read(t.highWaterMark),t.sync=!1,t.reading||(e=C(n,t))),null===(s=e>0?M(e,t):null)?(t.needReadable=t.length<=t.highWaterMark,e=0):(t.length-=e,t.awaitDrain=0),0===t.length&&(t.ended||(t.needReadable=!0),n!==e&&t.ended&&B(this)),null!==s&&this.emit("data",s),s},x.prototype._read=function(e){w(this,new y("_read()"))},x.prototype.pipe=function(e,t){var n=this,s=this._readableState;switch(s.pipesCount){case 0:s.pipes=e;break;case 1:s.pipes=[s.pipes,e];break;default:s.pipes.push(e)}s.pipesCount+=1,r("pipe count=%d opts=%j",s.pipesCount,t);var i=t&&!1===t.end||e===process.stdout||e===process.stderr?p:o;function o(){r("onend"),e.end()}s.endEmitted?process.nextTick(i):n.once("end",i),e.on("unpipe",(function t(a,i){r("onunpipe"),a===n&&i&&!1===i.hasUnpiped&&(i.hasUnpiped=!0,r("cleanup"),e.removeListener("close",f),e.removeListener("finish",h),e.removeListener("drain",l),e.removeListener("error",u),e.removeListener("unpipe",t),n.removeListener("end",o),n.removeListener("end",p),n.removeListener("data",d),c=!0,!s.awaitDrain||e._writableState&&!e._writableState.needDrain||l())}));var l=function(e){return function(){var t=e._readableState;r("pipeOnDrain",t.awaitDrain),t.awaitDrain&&t.awaitDrain--,0===t.awaitDrain&&a(e,"data")&&(t.flowing=!0,R(e))}}(n);e.on("drain",l);var c=!1;function d(t){r("ondata");var a=e.write(t);r("dest.write",a),!1===a&&((1===s.pipesCount&&s.pipes===e||s.pipesCount>1&&-1!==j(s.pipes,e))&&!c&&(r("false write response, pause",s.awaitDrain),s.awaitDrain++),n.pause())}function u(t){r("onerror",t),p(),e.removeListener("error",u),0===a(e,"error")&&w(e,t)}function f(){e.removeListener("finish",h),p()}function h(){r("onfinish"),e.removeListener("close",f),p()}function p(){r("unpipe"),n.unpipe(e)}return n.on("data",d),function(e,t,n){if("function"==typeof e.prependListener)return e.prependListener(t,n);e._events&&e._events[t]?Array.isArray(e._events[t])?e._events[t].unshift(n):e._events[t]=[n,e._events[t]]:e.on(t,n)}(e,"error",u),e.once("close",f),e.once("finish",h),e.emit("pipe",n),s.flowing||(r("pipe resume"),n.resume()),e},x.prototype.unpipe=function(e){var t=this._readableState,n={hasUnpiped:!1};if(0===t.pipesCount)return this;if(1===t.pipesCount)return e&&e!==t.pipes||(e||(e=t.pipes),t.pipes=null,t.pipesCount=0,t.flowing=!1,e&&e.emit("unpipe",this,n)),this;if(!e){var s=t.pipes,r=t.pipesCount;t.pipes=null,t.pipesCount=0,t.flowing=!1;for(var a=0;a<r;a++)s[a].emit("unpipe",this,{hasUnpiped:!1});return this}var i=j(t.pipes,e);return-1===i||(t.pipes.splice(i,1),t.pipesCount-=1,1===t.pipesCount&&(t.pipes=t.pipes[0]),e.emit("unpipe",this,n)),this},x.prototype.on=function(e,t){var n=i.prototype.on.call(this,e,t),s=this._readableState;return"data"===e?(s.readableListening=this.listenerCount("readable")>0,!1!==s.flowing&&this.resume()):"readable"===e&&(s.endEmitted||s.readableListening||(s.readableListening=s.needReadable=!0,s.flowing=!1,s.emittedReadable=!1,r("on readable",s.length,s.reading),s.length?z(this):s.reading||process.nextTick(L,this))),n},x.prototype.addListener=x.prototype.on,x.prototype.removeListener=function(e,t){var n=i.prototype.removeListener.call(this,e,t);return"readable"===e&&process.nextTick(G,this),n},x.prototype.removeAllListeners=function(e){var t=i.prototype.removeAllListeners.apply(this,arguments);return"readable"!==e&&void 0!==e||process.nextTick(G,this),t},x.prototype.resume=function(){var e=this._readableState;return e.flowing||(r("resume"),e.flowing=!e.readableListening,function(e,t){t.resumeScheduled||(t.resumeScheduled=!0,process.nextTick(O,e,t))}(this,e)),e.paused=!1,this},x.prototype.pause=function(){return r("call pause flowing=%j",this._readableState.flowing),!1!==this._readableState.flowing&&(r("pause"),this._readableState.flowing=!1,this.emit("pause")),this._readableState.paused=!0,this},x.prototype.wrap=function(e){var t=this,n=this._readableState,s=!1;for(var a in e.on("end",(function(){if(r("wrapped end"),n.decoder&&!n.ended){var e=n.decoder.end();e&&e.length&&t.push(e)}t.push(null)})),e.on("data",(function(a){r("wrapped data"),n.decoder&&(a=n.decoder.write(a)),n.objectMode&&null==a||(n.objectMode||a&&a.length)&&(t.push(a)||(s=!0,e.pause()))})),e)void 0===this[a]&&"function"==typeof e[a]&&(this[a]=function(t){return function(){return e[t].apply(e,arguments)}}(a));for(var i=0;i<A.length;i++)e.on(A[i],this.emit.bind(this,A[i]));return this._read=function(t){r("wrapped _read",t),s&&(s=!1,e.resume())},this},"function"==typeof Symbol&&(x.prototype[Symbol.asyncIterator]=function(){return void 0===u&&(u=n(9479)),u(this)}),Object.defineProperty(x.prototype,"readableHighWaterMark",{enumerable:!1,get:function(){return this._readableState.highWaterMark}}),Object.defineProperty(x.prototype,"readableBuffer",{enumerable:!1,get:function(){return this._readableState&&this._readableState.buffer}}),Object.defineProperty(x.prototype,"readableFlowing",{enumerable:!1,get:function(){return this._readableState.flowing},set:function(e){this._readableState&&(this._readableState.flowing=e)}}),x._fromList=M,Object.defineProperty(x.prototype,"readableLength",{enumerable:!1,get:function(){return this._readableState.length}}),"function"==typeof Symbol&&(x.from=function(e,t){return void 0===f&&(f=n(7929)),f(x,e,t)})},5118:(e,t,n)=>{e.exports=d;var s=n(9476).F,r=s.ERR_METHOD_NOT_IMPLEMENTED,a=s.ERR_MULTIPLE_CALLBACK,i=s.ERR_TRANSFORM_ALREADY_TRANSFORMING,o=s.ERR_TRANSFORM_WITH_LENGTH_0,l=n(7890);function c(e,t){var n=this._transformState;n.transforming=!1;var s=n.writecb;if(null===s)return this.emit("error",new a);n.writechunk=null,n.writecb=null,null!=t&&this.push(t),s(e);var r=this._readableState;r.reading=!1,(r.needReadable||r.length<r.highWaterMark)&&this._read(r.highWaterMark)}function d(e){if(!(this instanceof d))return new d(e);l.call(this,e),this._transformState={afterTransform:c.bind(this),needTransform:!1,transforming:!1,writecb:null,writechunk:null,writeencoding:null},this._readableState.needReadable=!0,this._readableState.sync=!1,e&&("function"==typeof e.transform&&(this._transform=e.transform),"function"==typeof e.flush&&(this._flush=e.flush)),this.on("prefinish",u)}function u(){var e=this;"function"!=typeof this._flush||this._readableState.destroyed?f(this,null,null):this._flush((function(t,n){f(e,t,n)}))}function f(e,t,n){if(t)return e.emit("error",t);if(null!=n&&e.push(n),e._writableState.length)throw new o;if(e._transformState.transforming)throw new i;return e.push(null)}n(198)(d,l),d.prototype.push=function(e,t){return this._transformState.needTransform=!1,l.prototype.push.call(this,e,t)},d.prototype._transform=function(e,t,n){n(new r("_transform()"))},d.prototype._write=function(e,t,n){var s=this._transformState;if(s.writecb=n,s.writechunk=e,s.writeencoding=t,!s.transforming){var r=this._readableState;(s.needTransform||r.needReadable||r.length<r.highWaterMark)&&this._read(r.highWaterMark)}},d.prototype._read=function(e){var t=this._transformState;null===t.writechunk||t.transforming?t.needTransform=!0:(t.transforming=!0,this._transform(t.writechunk,t.writeencoding,t.afterTransform))},d.prototype._destroy=function(e,t){l.prototype._destroy.call(this,e,(function(e){t(e)}))}},3920:(e,t,n)=>{function s(e){var t=this;this.next=null,this.entry=null,this.finish=function(){!function(e,t){var n=e.entry;for(e.entry=null;n;){var s=n.callback;t.pendingcb--,s(undefined),n=n.next}t.corkedRequestsFree.next=e}(t,e)}}var r;e.exports=x,x.WritableState=E;var a,i={deprecate:n(1527)},o=n(1341),l=n(8891).Buffer,c=(void 0!==n.g?n.g:"undefined"!=typeof window?window:"undefined"!=typeof self?self:{}).Uint8Array||function(){},d=n(7804),u=n(2103).getHighWaterMark,f=n(9476).F,h=f.ERR_INVALID_ARG_TYPE,p=f.ERR_METHOD_NOT_IMPLEMENTED,_=f.ERR_MULTIPLE_CALLBACK,m=f.ERR_STREAM_CANNOT_PIPE,g=f.ERR_STREAM_DESTROYED,b=f.ERR_STREAM_NULL_VALUES,y=f.ERR_STREAM_WRITE_AFTER_END,v=f.ERR_UNKNOWN_ENCODING,w=d.errorOrDestroy;function A(){}function E(e,t,a){r=r||n(7890),e=e||{},"boolean"!=typeof a&&(a=t instanceof r),this.objectMode=!!e.objectMode,a&&(this.objectMode=this.objectMode||!!e.writableObjectMode),this.highWaterMark=u(this,e,"writableHighWaterMark",a),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1,this.destroyed=!1;var i=!1===e.decodeStrings;this.decodeStrings=!i,this.defaultEncoding=e.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(e){!function(e,t){var n=e._writableState,s=n.sync,r=n.writecb;if("function"!=typeof r)throw new _;if(function(e){e.writing=!1,e.writecb=null,e.length-=e.writelen,e.writelen=0}(n),t)!function(e,t,n,s,r){--t.pendingcb,n?(process.nextTick(r,s),process.nextTick(P,e,t),e._writableState.errorEmitted=!0,w(e,s)):(r(s),e._writableState.errorEmitted=!0,w(e,s),P(e,t))}(e,n,s,t,r);else{var a=C(n)||e.destroyed;a||n.corked||n.bufferProcessing||!n.bufferedRequest||k(e,n),s?process.nextTick(T,e,n,a,r):T(e,n,a,r)}}(t,e)},this.writecb=null,this.writelen=0,this.bufferedRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.emitClose=!1!==e.emitClose,this.autoDestroy=!!e.autoDestroy,this.bufferedRequestCount=0,this.corkedRequestsFree=new s(this)}function x(e){var t=this instanceof(r=r||n(7890));if(!t&&!a.call(x,this))return new x(e);this._writableState=new E(e,this,t),this.writable=!0,e&&("function"==typeof e.write&&(this._write=e.write),"function"==typeof e.writev&&(this._writev=e.writev),"function"==typeof e.destroy&&(this._destroy=e.destroy),"function"==typeof e.final&&(this._final=e.final)),o.call(this)}function S(e,t,n,s,r,a,i){t.writelen=s,t.writecb=i,t.writing=!0,t.sync=!0,t.destroyed?t.onwrite(new g("write")):n?e._writev(r,t.onwrite):e._write(r,a,t.onwrite),t.sync=!1}function T(e,t,n,s){n||function(e,t){0===t.length&&t.needDrain&&(t.needDrain=!1,e.emit("drain"))}(e,t),t.pendingcb--,s(),P(e,t)}function k(e,t){t.bufferProcessing=!0;var n=t.bufferedRequest;if(e._writev&&n&&n.next){var r=t.bufferedRequestCount,a=new Array(r),i=t.corkedRequestsFree;i.entry=n;for(var o=0,l=!0;n;)a[o]=n,n.isBuf||(l=!1),n=n.next,o+=1;a.allBuffers=l,S(e,t,!0,t.length,a,"",i.finish),t.pendingcb++,t.lastBufferedRequest=null,i.next?(t.corkedRequestsFree=i.next,i.next=null):t.corkedRequestsFree=new s(t),t.bufferedRequestCount=0}else{for(;n;){var c=n.chunk,d=n.encoding,u=n.callback;if(S(e,t,!1,t.objectMode?1:c.length,c,d,u),n=n.next,t.bufferedRequestCount--,t.writing)break}null===n&&(t.lastBufferedRequest=null)}t.bufferedRequest=n,t.bufferProcessing=!1}function C(e){return e.ending&&0===e.length&&null===e.bufferedRequest&&!e.finished&&!e.writing}function z(e,t){e._final((function(n){t.pendingcb--,n&&w(e,n),t.prefinished=!0,e.emit("prefinish"),P(e,t)}))}function P(e,t){var n=C(t);if(n&&(function(e,t){t.prefinished||t.finalCalled||("function"!=typeof e._final||t.destroyed?(t.prefinished=!0,e.emit("prefinish")):(t.pendingcb++,t.finalCalled=!0,process.nextTick(z,e,t)))}(e,t),0===t.pendingcb&&(t.finished=!0,e.emit("finish"),t.autoDestroy))){var s=e._readableState;(!s||s.autoDestroy&&s.endEmitted)&&e.destroy()}return n}n(198)(x,o),E.prototype.getBuffer=function(){for(var e=this.bufferedRequest,t=[];e;)t.push(e),e=e.next;return t},function(){try{Object.defineProperty(E.prototype,"buffer",{get:i.deprecate((function(){return this.getBuffer()}),"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.","DEP0003")})}catch(e){}}(),"function"==typeof Symbol&&Symbol.hasInstance&&"function"==typeof Function.prototype[Symbol.hasInstance]?(a=Function.prototype[Symbol.hasInstance],Object.defineProperty(x,Symbol.hasInstance,{value:function(e){return!!a.call(this,e)||this===x&&e&&e._writableState instanceof E}})):a=function(e){return e instanceof this},x.prototype.pipe=function(){w(this,new m)},x.prototype.write=function(e,t,n){var s,r=this._writableState,a=!1,i=!r.objectMode&&(s=e,l.isBuffer(s)||s instanceof c);return i&&!l.isBuffer(e)&&(e=function(e){return l.from(e)}(e)),"function"==typeof t&&(n=t,t=null),i?t="buffer":t||(t=r.defaultEncoding),"function"!=typeof n&&(n=A),r.ending?function(e,t){var n=new y;w(e,n),process.nextTick(t,n)}(this,n):(i||function(e,t,n,s){var r;return null===n?r=new b:"string"==typeof n||t.objectMode||(r=new h("chunk",["string","Buffer"],n)),!r||(w(e,r),process.nextTick(s,r),!1)}(this,r,e,n))&&(r.pendingcb++,a=function(e,t,n,s,r,a){if(!n){var i=function(e,t,n){return e.objectMode||!1===e.decodeStrings||"string"!=typeof t||(t=l.from(t,n)),t}(t,s,r);s!==i&&(n=!0,r="buffer",s=i)}var o=t.objectMode?1:s.length;t.length+=o;var c=t.length<t.highWaterMark;if(c||(t.needDrain=!0),t.writing||t.corked){var d=t.lastBufferedRequest;t.lastBufferedRequest={chunk:s,encoding:r,isBuf:n,callback:a,next:null},d?d.next=t.lastBufferedRequest:t.bufferedRequest=t.lastBufferedRequest,t.bufferedRequestCount+=1}else S(e,t,!1,o,s,r,a);return c}(this,r,i,e,t,n)),a},x.prototype.cork=function(){this._writableState.corked++},x.prototype.uncork=function(){var e=this._writableState;e.corked&&(e.corked--,e.writing||e.corked||e.bufferProcessing||!e.bufferedRequest||k(this,e))},x.prototype.setDefaultEncoding=function(e){if("string"==typeof e&&(e=e.toLowerCase()),!(["hex","utf8","utf-8","ascii","binary","base64","ucs2","ucs-2","utf16le","utf-16le","raw"].indexOf((e+"").toLowerCase())>-1))throw new v(e);return this._writableState.defaultEncoding=e,this},Object.defineProperty(x.prototype,"writableBuffer",{enumerable:!1,get:function(){return this._writableState&&this._writableState.getBuffer()}}),Object.defineProperty(x.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),x.prototype._write=function(e,t,n){n(new p("_write()"))},x.prototype._writev=null,x.prototype.end=function(e,t,n){var s=this._writableState;return"function"==typeof e?(n=e,e=null,t=null):"function"==typeof t&&(n=t,t=null),null!=e&&this.write(e,t),s.corked&&(s.corked=1,this.uncork()),s.ending||function(e,t,n){t.ending=!0,P(e,t),n&&(t.finished?process.nextTick(n):e.once("finish",n)),t.ended=!0,e.writable=!1}(this,s,n),this},Object.defineProperty(x.prototype,"writableLength",{enumerable:!1,get:function(){return this._writableState.length}}),Object.defineProperty(x.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._writableState&&this._writableState.destroyed},set:function(e){this._writableState&&(this._writableState.destroyed=e)}}),x.prototype.destroy=d.destroy,x.prototype._undestroy=d.undestroy,x.prototype._destroy=function(e,t){t(e)}},9479:(e,t,n)=>{var s;function r(e,t,n){return(t=function(e){var t=function(e){if("object"!=typeof e||null===e)return e;var t=e[Symbol.toPrimitive];if(void 0!==t){var n=t.call(e,"string");if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==typeof t?t:String(t)}(t))in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var a=n(9890),i=Symbol("lastResolve"),o=Symbol("lastReject"),l=Symbol("error"),c=Symbol("ended"),d=Symbol("lastPromise"),u=Symbol("handlePromise"),f=Symbol("stream");function h(e,t){return{value:e,done:t}}function p(e){var t=e[i];if(null!==t){var n=e[f].read();null!==n&&(e[d]=null,e[i]=null,e[o]=null,t(h(n,!1)))}}function _(e){process.nextTick(p,e)}var m=Object.getPrototypeOf((function(){})),g=Object.setPrototypeOf((r(s={get stream(){return this[f]},next:function(){var e=this,t=this[l];if(null!==t)return Promise.reject(t);if(this[c])return Promise.resolve(h(void 0,!0));if(this[f].destroyed)return new Promise((function(t,n){process.nextTick((function(){e[l]?n(e[l]):t(h(void 0,!0))}))}));var n,s=this[d];if(s)n=new Promise(function(e,t){return function(n,s){e.then((function(){t[c]?n(h(void 0,!0)):t[u](n,s)}),s)}}(s,this));else{var r=this[f].read();if(null!==r)return Promise.resolve(h(r,!1));n=new Promise(this[u])}return this[d]=n,n}},Symbol.asyncIterator,(function(){return this})),r(s,"return",(function(){var e=this;return new Promise((function(t,n){e[f].destroy(null,(function(e){e?n(e):t(h(void 0,!0))}))}))})),s),m);e.exports=function(e){var t,n=Object.create(g,(r(t={},f,{value:e,writable:!0}),r(t,i,{value:null,writable:!0}),r(t,o,{value:null,writable:!0}),r(t,l,{value:null,writable:!0}),r(t,c,{value:e._readableState.endEmitted,writable:!0}),r(t,u,{value:function(e,t){var s=n[f].read();s?(n[d]=null,n[i]=null,n[o]=null,e(h(s,!1))):(n[i]=e,n[o]=t)},writable:!0}),t));return n[d]=null,a(e,(function(e){if(e&&"ERR_STREAM_PREMATURE_CLOSE"!==e.code){var t=n[o];return null!==t&&(n[d]=null,n[i]=null,n[o]=null,t(e)),void(n[l]=e)}var s=n[i];null!==s&&(n[d]=null,n[i]=null,n[o]=null,s(h(void 0,!0))),n[c]=!0})),e.on("readable",_.bind(null,n)),n}},8373:(e,t,n)=>{function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t,n){return(t=o(t))in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){for(var n=0;n<t.length;n++){var s=t[n];s.enumerable=s.enumerable||!1,s.configurable=!0,"value"in s&&(s.writable=!0),Object.defineProperty(e,o(s.key),s)}}function o(e){var t=function(e){if("object"!=typeof e||null===e)return e;var t=e[Symbol.toPrimitive];if(void 0!==t){var n=t.call(e,"string");if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==typeof t?t:String(t)}var l=n(8891).Buffer,c=n(8408).inspect,d=c&&c.custom||"inspect";e.exports=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.head=null,this.tail=null,this.length=0}var t,n;return t=e,(n=[{key:"push",value:function(e){var t={data:e,next:null};this.length>0?this.tail.next=t:this.head=t,this.tail=t,++this.length}},{key:"unshift",value:function(e){var t={data:e,next:this.head};0===this.length&&(this.tail=t),this.head=t,++this.length}},{key:"shift",value:function(){if(0!==this.length){var e=this.head.data;return 1===this.length?this.head=this.tail=null:this.head=this.head.next,--this.length,e}}},{key:"clear",value:function(){this.head=this.tail=null,this.length=0}},{key:"join",value:function(e){if(0===this.length)return"";for(var t=this.head,n=""+t.data;t=t.next;)n+=e+t.data;return n}},{key:"concat",value:function(e){if(0===this.length)return l.alloc(0);for(var t,n,s,r=l.allocUnsafe(e>>>0),a=this.head,i=0;a;)t=a.data,n=r,s=i,l.prototype.copy.call(t,n,s),i+=a.data.length,a=a.next;return r}},{key:"consume",value:function(e,t){var n;return e<this.head.data.length?(n=this.head.data.slice(0,e),this.head.data=this.head.data.slice(e)):n=e===this.head.data.length?this.shift():t?this._getString(e):this._getBuffer(e),n}},{key:"first",value:function(){return this.head.data}},{key:"_getString",value:function(e){var t=this.head,n=1,s=t.data;for(e-=s.length;t=t.next;){var r=t.data,a=e>r.length?r.length:e;if(a===r.length?s+=r:s+=r.slice(0,e),0==(e-=a)){a===r.length?(++n,t.next?this.head=t.next:this.head=this.tail=null):(this.head=t,t.data=r.slice(a));break}++n}return this.length-=n,s}},{key:"_getBuffer",value:function(e){var t=l.allocUnsafe(e),n=this.head,s=1;for(n.data.copy(t),e-=n.data.length;n=n.next;){var r=n.data,a=e>r.length?r.length:e;if(r.copy(t,t.length-e,0,a),0==(e-=a)){a===r.length?(++s,n.next?this.head=n.next:this.head=this.tail=null):(this.head=n,n.data=r.slice(a));break}++s}return this.length-=s,t}},{key:d,value:function(e,t){return c(this,r(r({},t),{},{depth:0,customInspect:!1}))}}])&&i(t.prototype,n),Object.defineProperty(t,"prototype",{writable:!1}),e}()},7804:e=>{function t(e,t){s(e,t),n(e)}function n(e){e._writableState&&!e._writableState.emitClose||e._readableState&&!e._readableState.emitClose||e.emit("close")}function s(e,t){e.emit("error",t)}e.exports={destroy:function(e,r){var a=this,i=this._readableState&&this._readableState.destroyed,o=this._writableState&&this._writableState.destroyed;return i||o?(r?r(e):e&&(this._writableState?this._writableState.errorEmitted||(this._writableState.errorEmitted=!0,process.nextTick(s,this,e)):process.nextTick(s,this,e)),this):(this._readableState&&(this._readableState.destroyed=!0),this._writableState&&(this._writableState.destroyed=!0),this._destroy(e||null,(function(e){!r&&e?a._writableState?a._writableState.errorEmitted?process.nextTick(n,a):(a._writableState.errorEmitted=!0,process.nextTick(t,a,e)):process.nextTick(t,a,e):r?(process.nextTick(n,a),r(e)):process.nextTick(n,a)})),this)},undestroy:function(){this._readableState&&(this._readableState.destroyed=!1,this._readableState.reading=!1,this._readableState.ended=!1,this._readableState.endEmitted=!1),this._writableState&&(this._writableState.destroyed=!1,this._writableState.ended=!1,this._writableState.ending=!1,this._writableState.finalCalled=!1,this._writableState.prefinished=!1,this._writableState.finished=!1,this._writableState.errorEmitted=!1)},errorOrDestroy:function(e,t){var n=e._readableState,s=e._writableState;n&&n.autoDestroy||s&&s.autoDestroy?e.destroy(t):e.emit("error",t)}}},9890:(e,t,n)=>{var s=n(9476).F.ERR_STREAM_PREMATURE_CLOSE;function r(){}e.exports=function e(t,n,a){if("function"==typeof n)return e(t,null,n);n||(n={}),a=function(e){var t=!1;return function(){if(!t){t=!0;for(var n=arguments.length,s=new Array(n),r=0;r<n;r++)s[r]=arguments[r];e.apply(this,s)}}}(a||r);var i=n.readable||!1!==n.readable&&t.readable,o=n.writable||!1!==n.writable&&t.writable,l=function(){t.writable||d()},c=t._writableState&&t._writableState.finished,d=function(){o=!1,c=!0,i||a.call(t)},u=t._readableState&&t._readableState.endEmitted,f=function(){i=!1,u=!0,o||a.call(t)},h=function(e){a.call(t,e)},p=function(){var e;return i&&!u?(t._readableState&&t._readableState.ended||(e=new s),a.call(t,e)):o&&!c?(t._writableState&&t._writableState.ended||(e=new s),a.call(t,e)):void 0},_=function(){t.req.on("finish",d)};return function(e){return e.setHeader&&"function"==typeof e.abort}(t)?(t.on("complete",d),t.on("abort",p),t.req?_():t.on("request",_)):o&&!t._writableState&&(t.on("end",l),t.on("close",l)),t.on("end",f),t.on("finish",d),!1!==n.error&&t.on("error",h),t.on("close",p),function(){t.removeListener("complete",d),t.removeListener("abort",p),t.removeListener("request",_),t.req&&t.req.removeListener("finish",d),t.removeListener("end",l),t.removeListener("close",l),t.removeListener("finish",d),t.removeListener("end",f),t.removeListener("error",h),t.removeListener("close",p)}}},7929:e=>{e.exports=function(){throw new Error("Readable.from is not available in the browser")}},7418:(e,t,n)=>{var s,r=n(9476).F,a=r.ERR_MISSING_ARGS,i=r.ERR_STREAM_DESTROYED;function o(e){if(e)throw e}function l(e){e()}function c(e,t){return e.pipe(t)}e.exports=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];var d,u=function(e){return e.length?"function"!=typeof e[e.length-1]?o:e.pop():o}(t);if(Array.isArray(t[0])&&(t=t[0]),t.length<2)throw new a("streams");var f=t.map((function(e,r){var a=r<t.length-1;return function(e,t,r,a){a=function(e){var t=!1;return function(){t||(t=!0,e.apply(void 0,arguments))}}(a);var o=!1;e.on("close",(function(){o=!0})),void 0===s&&(s=n(9890)),s(e,{readable:t,writable:r},(function(e){if(e)return a(e);o=!0,a()}));var l=!1;return function(t){if(!o&&!l)return l=!0,function(e){return e.setHeader&&"function"==typeof e.abort}(e)?e.abort():"function"==typeof e.destroy?e.destroy():void a(t||new i("pipe"))}}(e,a,r>0,(function(e){d||(d=e),e&&f.forEach(l),a||(f.forEach(l),u(d))}))}));return t.reduce(c)}},2103:(e,t,n)=>{var s=n(9476).F.ERR_INVALID_OPT_VALUE;e.exports={getHighWaterMark:function(e,t,n,r){var a=function(e,t,n){return null!=e.highWaterMark?e.highWaterMark:t?e[n]:null}(t,r,n);if(null!=a){if(!isFinite(a)||Math.floor(a)!==a||a<0)throw new s(r?n:"highWaterMark",a);return Math.floor(a)}return e.objectMode?16:16384}}},1341:(e,t,n)=>{e.exports=n(6827).EventEmitter},6451:(e,t,n)=>{(t=e.exports=n(9616)).Stream=t,t.Readable=t,t.Writable=n(3920),t.Duplex=n(7890),t.Transform=n(5118),t.PassThrough=n(8180),t.finished=n(9890),t.pipeline=n(7418)},1817:(e,t,n)=>{var s=n(8891),r=s.Buffer;function a(e,t){for(var n in e)t[n]=e[n]}function i(e,t,n){return r(e,t,n)}r.from&&r.alloc&&r.allocUnsafe&&r.allocUnsafeSlow?e.exports=s:(a(s,t),t.Buffer=i),i.prototype=Object.create(r.prototype),a(r,i),i.from=function(e,t,n){if("number"==typeof e)throw new TypeError("Argument must not be a number");return r(e,t,n)},i.alloc=function(e,t,n){if("number"!=typeof e)throw new TypeError("Argument must be a number");var s=r(e);return void 0!==t?"string"==typeof n?s.fill(t,n):s.fill(t):s.fill(0),s},i.allocUnsafe=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return r(e)},i.allocUnsafeSlow=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return s.SlowBuffer(e)}},8973:(e,t,n)=>{var s=n(8897),r=n(9381),a=n(6900)(),i=n(1399),o=n(1711),l=s("%Math.floor%");e.exports=function(e,t){if("function"!=typeof e)throw new o("`fn` is not a function");if("number"!=typeof t||t<0||t>4294967295||l(t)!==t)throw new o("`length` must be a positive 32-bit integer");var n=arguments.length>2&&!!arguments[2],s=!0,c=!0;if("length"in e&&i){var d=i(e,"length");d&&!d.configurable&&(s=!1),d&&!d.writable&&(c=!1)}return(s||c||!n)&&(a?r(e,"length",t,!0,!0):r(e,"length",t)),e}},3322:(e,t,n)=>{t.vm=void 0;var s,r=n(8891),a=(s=n(1733))&&s.__esModule?s:{default:s},i=function(e){var t=e.allowedSizes,n=e.defaultSize,s=e.padding;return function e(){var i=this,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:n;if(!this||this.constructor!==e)return new e(o);if(t&&!t.includes(o))throw new Error("Unsupported hash length");var l=new a.default({capacity:o});return this.update=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf8";if(r.Buffer.isBuffer(e))return l.absorb(e),i;if("string"==typeof e)return i.update(r.Buffer.from(e,t));throw new TypeError("Not a string or buffer")},this.digest=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"binary",t="string"==typeof e?{format:e}:e,n=l.squeeze({buffer:t.buffer,padding:t.padding||s});return t.format&&"binary"!==t.format?n.toString(t.format):n},this.reset=function(){return l.reset(),i},this}},o=i({allowedSizes:[224,256,384,512],defaultSize:512,padding:1});t.vm=o;var l=i({allowedSizes:[224,256,384,512],defaultSize:512,padding:6});i({allowedSizes:[128,256],defaultSize:256,padding:31});var c=o;l.SHA3Hash=c},1733:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var s,r=n(8891),a=(s=n(1356))&&s.__esModule?s:{default:s},i=function(e,t){for(var n=0;n<e.length;n+=8){var s=n/4;t[s]^=e[n+7]<<24|e[n+6]<<16|e[n+5]<<8|e[n+4],t[s+1]^=e[n+3]<<24|e[n+2]<<16|e[n+1]<<8|e[n]}return t},o=function(e,t){for(var n=0;n<t.length;n+=8){var s=n/4;t[n]=e[s+1],t[n+1]=e[s+1]>>>8,t[n+2]=e[s+1]>>>16,t[n+3]=e[s+1]>>>24,t[n+4]=e[s],t[n+5]=e[s]>>>8,t[n+6]=e[s]>>>16,t[n+7]=e[s]>>>24}return t};t.default=function(e){var t=this,n=e.capacity,s=e.padding,l=(0,a.default)(),c=n/8,d=200-n/4,u=0,f=new Uint32Array(50),h=r.Buffer.allocUnsafe(d);return this.absorb=function(e){for(var n=0;n<e.length;n++)h[u]=e[n],(u+=1)>=d&&(i(h,f),l(f),u=0);return t},this.squeeze=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={buffer:e.buffer||r.Buffer.allocUnsafe(c),padding:e.padding||s,queue:r.Buffer.allocUnsafe(h.length),state:new Uint32Array(f.length)};h.copy(t.queue);for(var n=0;n<f.length;n++)t.state[n]=f[n];t.queue.fill(0,u),t.queue[u]|=t.padding,t.queue[d-1]|=128,i(t.queue,t.state);for(var a=0;a<t.buffer.length;a+=d)l(t.state),o(t.state,t.buffer.slice(a,a+d));return t.buffer},this.reset=function(){return h.fill(0),f.fill(0),u=0,t},this}},737:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var s,r=(s=n(1120))&&s.__esModule?s:{default:s};t.default=function(e){for(var t=e.A,n=e.C,s=0;s<25;s+=5){for(var a=0;a<5;a++)(0,r.default)(t,s+a)(n,a);for(var i=0;i<5;i++){var o=2*(s+i),l=(i+1)%5*2,c=(i+2)%5*2;t[o]^=~n[l]&n[c],t[o+1]^=~n[l+1]&n[c+1]}}}},1120:e=>{e.exports=function(e,t){return function(n,s){var r=2*s,a=2*t;n[r]=e[a],n[r+1]=e[a+1]}}},1356:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var s=o(n(737)),r=o(n(9810)),a=o(n(3915)),i=o(n(8547));function o(e){return e&&e.__esModule?e:{default:e}}t.default=function(){var e=new Uint32Array(10),t=new Uint32Array(10),n=new Uint32Array(2);return function(o){for(var l=0;l<24;l++)(0,i.default)({A:o,C:e,D:t,W:n}),(0,a.default)({A:o,C:e,W:n}),(0,s.default)({A:o,C:e}),(0,r.default)({A:o,roundIndex:l});e.fill(0),t.fill(0),n.fill(0)}}},9810:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var s,r=(s=n(1))&&s.__esModule?s:{default:s};t.default=function(e){var t=e.A,n=2*e.roundIndex;t[0]^=r.default[n],t[1]^=r.default[n+1]}},1:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=new Uint32Array([0,1,0,32898,2147483648,32906,2147483648,2147516416,0,32907,0,2147483649,2147483648,2147516545,2147483648,32777,0,138,0,136,0,2147516425,0,2147483658,0,2147516555,2147483648,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,0,32778,2147483648,2147483658,2147483648,2147516545,2147483648,32896,0,2147483649,2147483648,2147516424]);t.default=n},3915:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var s=i(n(1795)),r=i(n(7997)),a=i(n(1120));function i(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.A,n=e.C,i=e.W;(0,a.default)(t,1)(i,0);for(var o=0,l=0,c=0,d=32,u=0;u<24;u++){var f=s.default[u],h=r.default[u];(0,a.default)(t,f)(n,0),o=i[0],l=i[1],d=32-h,i[c=h<32?0:1]=o<<h|l>>>d,i[(c+1)%2]=l<<h|o>>>d,(0,a.default)(i,0)(t,f),(0,a.default)(n,0)(i,0)}}},1795:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;t.default=[10,7,11,17,18,3,5,16,8,21,24,4,15,23,19,13,12,2,20,14,22,9,6,1]},7997:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;t.default=[1,3,6,10,15,21,28,36,45,55,2,14,27,41,56,8,25,43,62,18,39,61,20,44]},8547:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var s,r=(s=n(1120))&&s.__esModule?s:{default:s};t.default=function(e){for(var t=e.A,n=e.C,s=e.D,a=e.W,i=0,o=0,l=0;l<5;l++){var c=2*l,d=2*(l+5),u=2*(l+10),f=2*(l+15),h=2*(l+20);n[c]=t[c]^t[d]^t[u]^t[f]^t[h],n[c+1]=t[c+1]^t[d+1]^t[u+1]^t[f+1]^t[h+1]}for(var p=0;p<5;p++){(0,r.default)(n,(p+1)%5)(a,0),i=a[0],o=a[1],a[0]=i<<1|o>>>31,a[1]=o<<1|i>>>31,s[2*p]=n[(p+4)%5*2]^a[0],s[2*p+1]=n[(p+4)%5*2+1]^a[1];for(var _=0;_<25;_+=5)t[2*(_+p)]^=s[2*p],t[2*(_+p)+1]^=s[2*p+1]}}},5994:(e,t,n)=>{e.exports=r;var s=n(6827).EventEmitter;function r(){s.call(this)}n(198)(r,s),r.Readable=n(9616),r.Writable=n(3920),r.Duplex=n(7890),r.Transform=n(5118),r.PassThrough=n(8180),r.finished=n(9890),r.pipeline=n(7418),r.Stream=r,r.prototype.pipe=function(e,t){var n=this;function r(t){e.writable&&!1===e.write(t)&&n.pause&&n.pause()}function a(){n.readable&&n.resume&&n.resume()}n.on("data",r),e.on("drain",a),e._isStdio||t&&!1===t.end||(n.on("end",o),n.on("close",l));var i=!1;function o(){i||(i=!0,e.end())}function l(){i||(i=!0,"function"==typeof e.destroy&&e.destroy())}function c(e){if(d(),0===s.listenerCount(this,"error"))throw e}function d(){n.removeListener("data",r),e.removeListener("drain",a),n.removeListener("end",o),n.removeListener("close",l),n.removeListener("error",c),e.removeListener("error",c),n.removeListener("end",d),n.removeListener("close",d),e.removeListener("close",d)}return n.on("error",c),e.on("error",c),n.on("end",d),n.on("close",d),e.on("close",d),e.emit("pipe",n),e}},3102:(e,t,n)=>{var s=n(1817).Buffer,r=s.isEncoding||function(e){switch((e=""+e)&&e.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return!0;default:return!1}};function a(e){var t;switch(this.encoding=function(e){var t=function(e){if(!e)return"utf8";for(var t;;)switch(e){case"utf8":case"utf-8":return"utf8";case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return"utf16le";case"latin1":case"binary":return"latin1";case"base64":case"ascii":case"hex":return e;default:if(t)return;e=(""+e).toLowerCase(),t=!0}}(e);if("string"!=typeof t&&(s.isEncoding===r||!r(e)))throw new Error("Unknown encoding: "+e);return t||e}(e),this.encoding){case"utf16le":this.text=l,this.end=c,t=4;break;case"utf8":this.fillLast=o,t=4;break;case"base64":this.text=d,this.end=u,t=3;break;default:return this.write=f,void(this.end=h)}this.lastNeed=0,this.lastTotal=0,this.lastChar=s.allocUnsafe(t)}function i(e){return e<=127?0:e>>5==6?2:e>>4==14?3:e>>3==30?4:e>>6==2?-1:-2}function o(e){var t=this.lastTotal-this.lastNeed,n=function(e,t){if(128!=(192&t[0]))return e.lastNeed=0,"�";if(e.lastNeed>1&&t.length>1){if(128!=(192&t[1]))return e.lastNeed=1,"�";if(e.lastNeed>2&&t.length>2&&128!=(192&t[2]))return e.lastNeed=2,"�"}}(this,e);return void 0!==n?n:this.lastNeed<=e.length?(e.copy(this.lastChar,t,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):(e.copy(this.lastChar,t,0,e.length),void(this.lastNeed-=e.length))}function l(e,t){if((e.length-t)%2==0){var n=e.toString("utf16le",t);if(n){var s=n.charCodeAt(n.length-1);if(s>=55296&&s<=56319)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=e[e.length-2],this.lastChar[1]=e[e.length-1],n.slice(0,-1)}return n}return this.lastNeed=1,this.lastTotal=2,this.lastChar[0]=e[e.length-1],e.toString("utf16le",t,e.length-1)}function c(e){var t=e&&e.length?this.write(e):"";if(this.lastNeed){var n=this.lastTotal-this.lastNeed;return t+this.lastChar.toString("utf16le",0,n)}return t}function d(e,t){var n=(e.length-t)%3;return 0===n?e.toString("base64",t):(this.lastNeed=3-n,this.lastTotal=3,1===n?this.lastChar[0]=e[e.length-1]:(this.lastChar[0]=e[e.length-2],this.lastChar[1]=e[e.length-1]),e.toString("base64",t,e.length-n))}function u(e){var t=e&&e.length?this.write(e):"";return this.lastNeed?t+this.lastChar.toString("base64",0,3-this.lastNeed):t}function f(e){return e.toString(this.encoding)}function h(e){return e&&e.length?this.write(e):""}t.I=a,a.prototype.write=function(e){if(0===e.length)return"";var t,n;if(this.lastNeed){if(void 0===(t=this.fillLast(e)))return"";n=this.lastNeed,this.lastNeed=0}else n=0;return n<e.length?t?t+this.text(e,n):this.text(e,n):t||""},a.prototype.end=function(e){var t=e&&e.length?this.write(e):"";return this.lastNeed?t+"�":t},a.prototype.text=function(e,t){var n=function(e,t,n){var s=t.length-1;if(s<n)return 0;var r=i(t[s]);return r>=0?(r>0&&(e.lastNeed=r-1),r):--s<n||-2===r?0:(r=i(t[s]))>=0?(r>0&&(e.lastNeed=r-2),r):--s<n||-2===r?0:(r=i(t[s]))>=0?(r>0&&(2===r?r=0:e.lastNeed=r-3),r):0}(this,e,t);if(!this.lastNeed)return e.toString("utf8",t);this.lastTotal=n;var s=e.length-(n-this.lastNeed);return e.copy(this.lastChar,0,s),e.toString("utf8",t,s)},a.prototype.fillLast=function(e){if(this.lastNeed<=e.length)return e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal);e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,e.length),this.lastNeed-=e.length}},1527:(e,t,n)=>{function s(e){try{if(!n.g.localStorage)return!1}catch(e){return!1}var t=n.g.localStorage[e];return null!=t&&"true"===String(t).toLowerCase()}e.exports=function(e,t){if(s("noDeprecation"))return e;var n=!1;return function(){if(!n){if(s("throwDeprecation"))throw new Error(t);s("traceDeprecation")?console.trace(t):console.warn(t),n=!0}return e.apply(this,arguments)}}},5171:e=>{e.exports=function(e){return e&&"object"==typeof e&&"function"==typeof e.copy&&"function"==typeof e.fill&&"function"==typeof e.readUInt8}},1028:(e,t,n)=>{var s=n(5456),r=n(6940),a=n(6059),i=n(2116);function o(e){return e.call.bind(e)}var l="undefined"!=typeof BigInt,c="undefined"!=typeof Symbol,d=o(Object.prototype.toString),u=o(Number.prototype.valueOf),f=o(String.prototype.valueOf),h=o(Boolean.prototype.valueOf);if(l)var p=o(BigInt.prototype.valueOf);if(c)var _=o(Symbol.prototype.valueOf);function m(e,t){if("object"!=typeof e)return!1;try{return t(e),!0}catch(e){return!1}}function g(e){return"[object Map]"===d(e)}function b(e){return"[object Set]"===d(e)}function y(e){return"[object WeakMap]"===d(e)}function v(e){return"[object WeakSet]"===d(e)}function w(e){return"[object ArrayBuffer]"===d(e)}function A(e){return"undefined"!=typeof ArrayBuffer&&(w.working?w(e):e instanceof ArrayBuffer)}function E(e){return"[object DataView]"===d(e)}function x(e){return"undefined"!=typeof DataView&&(E.working?E(e):e instanceof DataView)}t.isArgumentsObject=s,t.isGeneratorFunction=r,t.isTypedArray=i,t.isPromise=function(e){return"undefined"!=typeof Promise&&e instanceof Promise||null!==e&&"object"==typeof e&&"function"==typeof e.then&&"function"==typeof e.catch},t.isArrayBufferView=function(e){return"undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(e):i(e)||x(e)},t.isUint8Array=function(e){return"Uint8Array"===a(e)},t.isUint8ClampedArray=function(e){return"Uint8ClampedArray"===a(e)},t.isUint16Array=function(e){return"Uint16Array"===a(e)},t.isUint32Array=function(e){return"Uint32Array"===a(e)},t.isInt8Array=function(e){return"Int8Array"===a(e)},t.isInt16Array=function(e){return"Int16Array"===a(e)},t.isInt32Array=function(e){return"Int32Array"===a(e)},t.isFloat32Array=function(e){return"Float32Array"===a(e)},t.isFloat64Array=function(e){return"Float64Array"===a(e)},t.isBigInt64Array=function(e){return"BigInt64Array"===a(e)},t.isBigUint64Array=function(e){return"BigUint64Array"===a(e)},g.working="undefined"!=typeof Map&&g(new Map),t.isMap=function(e){return"undefined"!=typeof Map&&(g.working?g(e):e instanceof Map)},b.working="undefined"!=typeof Set&&b(new Set),t.isSet=function(e){return"undefined"!=typeof Set&&(b.working?b(e):e instanceof Set)},y.working="undefined"!=typeof WeakMap&&y(new WeakMap),t.isWeakMap=function(e){return"undefined"!=typeof WeakMap&&(y.working?y(e):e instanceof WeakMap)},v.working="undefined"!=typeof WeakSet&&v(new WeakSet),t.isWeakSet=function(e){return v(e)},w.working="undefined"!=typeof ArrayBuffer&&w(new ArrayBuffer),t.isArrayBuffer=A,E.working="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof DataView&&E(new DataView(new ArrayBuffer(1),0,1)),t.isDataView=x;var S="undefined"!=typeof SharedArrayBuffer?SharedArrayBuffer:void 0;function T(e){return"[object SharedArrayBuffer]"===d(e)}function k(e){return void 0!==S&&(void 0===T.working&&(T.working=T(new S)),T.working?T(e):e instanceof S)}function C(e){return m(e,u)}function z(e){return m(e,f)}function P(e){return m(e,h)}function F(e){return l&&m(e,p)}function N(e){return c&&m(e,_)}t.isSharedArrayBuffer=k,t.isAsyncFunction=function(e){return"[object AsyncFunction]"===d(e)},t.isMapIterator=function(e){return"[object Map Iterator]"===d(e)},t.isSetIterator=function(e){return"[object Set Iterator]"===d(e)},t.isGeneratorObject=function(e){return"[object Generator]"===d(e)},t.isWebAssemblyCompiledModule=function(e){return"[object WebAssembly.Module]"===d(e)},t.isNumberObject=C,t.isStringObject=z,t.isBooleanObject=P,t.isBigIntObject=F,t.isSymbolObject=N,t.isBoxedPrimitive=function(e){return C(e)||z(e)||P(e)||F(e)||N(e)},t.isAnyArrayBuffer=function(e){return"undefined"!=typeof Uint8Array&&(A(e)||k(e))},["isProxy","isExternal","isModuleNamespaceObject"].forEach((function(e){Object.defineProperty(t,e,{enumerable:!1,value:function(){throw new Error(e+" is not supported in userland")}})}))},7877:(e,t,n)=>{var s=Object.getOwnPropertyDescriptors||function(e){for(var t=Object.keys(e),n={},s=0;s<t.length;s++)n[t[s]]=Object.getOwnPropertyDescriptor(e,t[s]);return n},r=/%[sdj%]/g;t.format=function(e){if(!b(e)){for(var t=[],n=0;n<arguments.length;n++)t.push(l(arguments[n]));return t.join(" ")}n=1;for(var s=arguments,a=s.length,i=String(e).replace(r,(function(e){if("%%"===e)return"%";if(n>=a)return e;switch(e){case"%s":return String(s[n++]);case"%d":return Number(s[n++]);case"%j":try{return JSON.stringify(s[n++])}catch(e){return"[Circular]"}default:return e}})),o=s[n];n<a;o=s[++n])m(o)||!w(o)?i+=" "+o:i+=" "+l(o);return i},t.deprecate=function(e,n){if("undefined"!=typeof process&&!0===process.noDeprecation)return e;if("undefined"==typeof process)return function(){return t.deprecate(e,n).apply(this,arguments)};var s=!1;return function(){if(!s){if(process.throwDeprecation)throw new Error(n);process.traceDeprecation?console.trace(n):console.error(n),s=!0}return e.apply(this,arguments)}};var a={},i=/^$/;if({NODE_ENV:"production"}.NODE_DEBUG){var o={NODE_ENV:"production"}.NODE_DEBUG;o=o.replace(/[|\\{}()[\]^$+?.]/g,"\\$&").replace(/\*/g,".*").replace(/,/g,"$|^").toUpperCase(),i=new RegExp("^"+o+"$","i")}function l(e,n){var s={seen:[],stylize:d};return arguments.length>=3&&(s.depth=arguments[2]),arguments.length>=4&&(s.colors=arguments[3]),_(n)?s.showHidden=n:n&&t._extend(s,n),y(s.showHidden)&&(s.showHidden=!1),y(s.depth)&&(s.depth=2),y(s.colors)&&(s.colors=!1),y(s.customInspect)&&(s.customInspect=!0),s.colors&&(s.stylize=c),u(s,e,s.depth)}function c(e,t){var n=l.styles[t];return n?"["+l.colors[n][0]+"m"+e+"["+l.colors[n][1]+"m":e}function d(e,t){return e}function u(e,n,s){if(e.customInspect&&n&&x(n.inspect)&&n.inspect!==t.inspect&&(!n.constructor||n.constructor.prototype!==n)){var r=n.inspect(s,e);return b(r)||(r=u(e,r,s)),r}var a=function(e,t){if(y(t))return e.stylize("undefined","undefined");if(b(t)){var n="'"+JSON.stringify(t).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return e.stylize(n,"string")}return g(t)?e.stylize(""+t,"number"):_(t)?e.stylize(""+t,"boolean"):m(t)?e.stylize("null","null"):void 0}(e,n);if(a)return a;var i=Object.keys(n),o=function(e){var t={};return e.forEach((function(e,n){t[e]=!0})),t}(i);if(e.showHidden&&(i=Object.getOwnPropertyNames(n)),E(n)&&(i.indexOf("message")>=0||i.indexOf("description")>=0))return f(n);if(0===i.length){if(x(n)){var l=n.name?": "+n.name:"";return e.stylize("[Function"+l+"]","special")}if(v(n))return e.stylize(RegExp.prototype.toString.call(n),"regexp");if(A(n))return e.stylize(Date.prototype.toString.call(n),"date");if(E(n))return f(n)}var c,d="",w=!1,S=["{","}"];return p(n)&&(w=!0,S=["[","]"]),x(n)&&(d=" [Function"+(n.name?": "+n.name:"")+"]"),v(n)&&(d=" "+RegExp.prototype.toString.call(n)),A(n)&&(d=" "+Date.prototype.toUTCString.call(n)),E(n)&&(d=" "+f(n)),0!==i.length||w&&0!=n.length?s<0?v(n)?e.stylize(RegExp.prototype.toString.call(n),"regexp"):e.stylize("[Object]","special"):(e.seen.push(n),c=w?function(e,t,n,s,r){for(var a=[],i=0,o=t.length;i<o;++i)C(t,String(i))?a.push(h(e,t,n,s,String(i),!0)):a.push("");return r.forEach((function(r){r.match(/^\d+$/)||a.push(h(e,t,n,s,r,!0))})),a}(e,n,s,o,i):i.map((function(t){return h(e,n,s,o,t,w)})),e.seen.pop(),function(e,t,n){return e.reduce((function(e,t){return t.indexOf("\n"),e+t.replace(/\u001b\[\d\d?m/g,"").length+1}),0)>60?n[0]+(""===t?"":t+"\n ")+" "+e.join(",\n  ")+" "+n[1]:n[0]+t+" "+e.join(", ")+" "+n[1]}(c,d,S)):S[0]+d+S[1]}function f(e){return"["+Error.prototype.toString.call(e)+"]"}function h(e,t,n,s,r,a){var i,o,l;if((l=Object.getOwnPropertyDescriptor(t,r)||{value:t[r]}).get?o=l.set?e.stylize("[Getter/Setter]","special"):e.stylize("[Getter]","special"):l.set&&(o=e.stylize("[Setter]","special")),C(s,r)||(i="["+r+"]"),o||(e.seen.indexOf(l.value)<0?(o=m(n)?u(e,l.value,null):u(e,l.value,n-1)).indexOf("\n")>-1&&(o=a?o.split("\n").map((function(e){return"  "+e})).join("\n").slice(2):"\n"+o.split("\n").map((function(e){return"   "+e})).join("\n")):o=e.stylize("[Circular]","special")),y(i)){if(a&&r.match(/^\d+$/))return o;(i=JSON.stringify(""+r)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(i=i.slice(1,-1),i=e.stylize(i,"name")):(i=i.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),i=e.stylize(i,"string"))}return i+": "+o}function p(e){return Array.isArray(e)}function _(e){return"boolean"==typeof e}function m(e){return null===e}function g(e){return"number"==typeof e}function b(e){return"string"==typeof e}function y(e){return void 0===e}function v(e){return w(e)&&"[object RegExp]"===S(e)}function w(e){return"object"==typeof e&&null!==e}function A(e){return w(e)&&"[object Date]"===S(e)}function E(e){return w(e)&&("[object Error]"===S(e)||e instanceof Error)}function x(e){return"function"==typeof e}function S(e){return Object.prototype.toString.call(e)}function T(e){return e<10?"0"+e.toString(10):e.toString(10)}t.debuglog=function(e){if(e=e.toUpperCase(),!a[e])if(i.test(e)){var n=process.pid;a[e]=function(){var s=t.format.apply(t,arguments);console.error("%s %d: %s",e,n,s)}}else a[e]=function(){};return a[e]},t.inspect=l,l.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},l.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},t.types=n(1028),t.isArray=p,t.isBoolean=_,t.isNull=m,t.isNullOrUndefined=function(e){return null==e},t.isNumber=g,t.isString=b,t.isSymbol=function(e){return"symbol"==typeof e},t.isUndefined=y,t.isRegExp=v,t.types.isRegExp=v,t.isObject=w,t.isDate=A,t.types.isDate=A,t.isError=E,t.types.isNativeError=E,t.isFunction=x,t.isPrimitive=function(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||void 0===e},t.isBuffer=n(5171);var k=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function C(e,t){return Object.prototype.hasOwnProperty.call(e,t)}t.log=function(){var e,n;console.log("%s - %s",(n=[T((e=new Date).getHours()),T(e.getMinutes()),T(e.getSeconds())].join(":"),[e.getDate(),k[e.getMonth()],n].join(" ")),t.format.apply(t,arguments))},t.inherits=n(198),t._extend=function(e,t){if(!t||!w(t))return e;for(var n=Object.keys(t),s=n.length;s--;)e[n[s]]=t[n[s]];return e};var z="undefined"!=typeof Symbol?Symbol("util.promisify.custom"):void 0;function P(e,t){if(!e){var n=new Error("Promise was rejected with a falsy value");n.reason=e,e=n}return t(e)}t.promisify=function(e){if("function"!=typeof e)throw new TypeError('The "original" argument must be of type Function');if(z&&e[z]){var t;if("function"!=typeof(t=e[z]))throw new TypeError('The "util.promisify.custom" argument must be of type Function');return Object.defineProperty(t,z,{value:t,enumerable:!1,writable:!1,configurable:!0}),t}function t(){for(var t,n,s=new Promise((function(e,s){t=e,n=s})),r=[],a=0;a<arguments.length;a++)r.push(arguments[a]);r.push((function(e,s){e?n(e):t(s)}));try{e.apply(this,r)}catch(e){n(e)}return s}return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),z&&Object.defineProperty(t,z,{value:t,enumerable:!1,writable:!1,configurable:!0}),Object.defineProperties(t,s(e))},t.promisify.custom=z,t.callbackify=function(e){if("function"!=typeof e)throw new TypeError('The "original" argument must be of type Function');function t(){for(var t=[],n=0;n<arguments.length;n++)t.push(arguments[n]);var s=t.pop();if("function"!=typeof s)throw new TypeError("The last argument must be of type Function");var r=this,a=function(){return s.apply(r,arguments)};e.apply(this,t).then((function(e){process.nextTick(a.bind(null,null,e))}),(function(e){process.nextTick(P.bind(null,e,a))}))}return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),Object.defineProperties(t,s(e)),t}},6059:(e,t,n)=>{var s=n(7270),r=n(2847),a=n(8179),i=n(9343),o=n(1399),l=i("Object.prototype.toString"),c=n(1432)(),d="undefined"==typeof globalThis?n.g:globalThis,u=r(),f=i("String.prototype.slice"),h=Object.getPrototypeOf,p=i("Array.prototype.indexOf",!0)||function(e,t){for(var n=0;n<e.length;n+=1)if(e[n]===t)return n;return-1},_={__proto__:null};s(u,c&&o&&h?function(e){var t=new d[e];if(Symbol.toStringTag in t){var n=h(t),s=o(n,Symbol.toStringTag);if(!s){var r=h(n);s=o(r,Symbol.toStringTag)}_["$"+e]=a(s.get)}}:function(e){var t=new d[e],n=t.slice||t.set;n&&(_["$"+e]=a(n))}),e.exports=function(e){if(!e||"object"!=typeof e)return!1;if(!c){var t=f(l(e),8,-1);return p(u,t)>-1?t:"Object"===t&&function(e){var t=!1;return s(_,(function(n,s){if(!t)try{n(e),t=f(s,1)}catch(e){}})),t}(e)}return o?function(e){var t=!1;return s(_,(function(n,s){if(!t)try{"$"+n(e)===s&&(t=f(s,1))}catch(e){}})),t}(e):null}},6497:()=>{},3891:()=>{},74:()=>{},9868:()=>{},8408:()=>{},4098:()=>{},2847:(e,t,n)=>{var s=n(6350),r="undefined"==typeof globalThis?n.g:globalThis;e.exports=function(){for(var e=[],t=0;t<s.length;t++)"function"==typeof r[s[t]]&&(e[e.length]=s[t]);return e}},6739:(e,t,n)=>{function s(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`positive integer expected, not ${e}`)}function r(e,...t){if(!((n=e)instanceof Uint8Array||null!=n&&"object"==typeof n&&"Uint8Array"===n.constructor.name))throw new Error("Uint8Array expected");var n;if(t.length>0&&!t.includes(e.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)}function a(e){if("function"!=typeof e||"function"!=typeof e.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");s(e.outputLen),s(e.blockLen)}function i(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function o(e,t){r(e);const n=t.outputLen;if(e.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}n.d(t,{CG:()=>o,ai:()=>s,ee:()=>r,t2:()=>i,tW:()=>a})},1805:(e,t,n)=>{n.d(t,{s:()=>u});var s=n(6739),r=n(7049);const a=(e,t,n)=>e&t^e&n^t&n;class i extends r.Vw{constructor(e,t,n,s){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=(0,r.O8)(this.buffer)}update(e){(0,s.t2)(this);const{view:t,buffer:n,blockLen:a}=this,i=(e=(0,r.ZJ)(e)).length;for(let s=0;s<i;){const o=Math.min(a-this.pos,i-s);if(o!==a)n.set(e.subarray(s,s+o),this.pos),this.pos+=o,s+=o,this.pos===a&&(this.process(t,0),this.pos=0);else{const t=(0,r.O8)(e);for(;a<=i-s;s+=a)this.process(t,s)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){(0,s.t2)(this),(0,s.CG)(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:a,isLE:i}=this;let{pos:o}=this;t[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>a-o&&(this.process(n,0),o=0);for(let e=o;e<a;e++)t[e]=0;!function(e,t,n,s){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,n,s);const r=BigInt(32),a=BigInt(4294967295),i=Number(n>>r&a),o=Number(n&a),l=s?4:0,c=s?0:4;e.setUint32(t+l,i,s),e.setUint32(t+c,o,s)}(n,a-8,BigInt(8*this.length),i),this.process(n,0);const l=(0,r.O8)(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const d=c/4,u=this.get();if(d>u.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<d;e++)l.setUint32(4*e,u[e],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:s,finished:r,destroyed:a,pos:i}=this;return e.length=s,e.pos=i,e.finished=r,e.destroyed=a,s%t&&e.buffer.set(n),e}}const o=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),l=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),c=new Uint32Array(64);class d extends i{constructor(){super(64,32,8,!1),this.A=0|l[0],this.B=0|l[1],this.C=0|l[2],this.D=0|l[3],this.E=0|l[4],this.F=0|l[5],this.G=0|l[6],this.H=0|l[7]}get(){const{A:e,B:t,C:n,D:s,E:r,F:a,G:i,H:o}=this;return[e,t,n,s,r,a,i,o]}set(e,t,n,s,r,a,i,o){this.A=0|e,this.B=0|t,this.C=0|n,this.D=0|s,this.E=0|r,this.F=0|a,this.G=0|i,this.H=0|o}process(e,t){for(let n=0;n<16;n++,t+=4)c[n]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=c[e-15],n=c[e-2],s=(0,r.Ow)(t,7)^(0,r.Ow)(t,18)^t>>>3,a=(0,r.Ow)(n,17)^(0,r.Ow)(n,19)^n>>>10;c[e]=a+c[e-7]+s+c[e-16]|0}let{A:n,B:s,C:i,D:l,E:d,F:u,G:f,H:h}=this;for(let e=0;e<64;e++){const t=h+((0,r.Ow)(d,6)^(0,r.Ow)(d,11)^(0,r.Ow)(d,25))+((p=d)&u^~p&f)+o[e]+c[e]|0,_=((0,r.Ow)(n,2)^(0,r.Ow)(n,13)^(0,r.Ow)(n,22))+a(n,s,i)|0;h=f,f=u,u=d,d=l+t|0,l=i,i=s,s=n,n=t+_|0}var p;n=n+this.A|0,s=s+this.B|0,i=i+this.C|0,l=l+this.D|0,d=d+this.E|0,u=u+this.F|0,f=f+this.G|0,h=h+this.H|0,this.set(n,s,i,l,d,u,f,h)}roundClean(){c.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const u=(0,r.ld)((()=>new d))},7049:(e,t,n)=>{n.d(t,{Vw:()=>h,Fc:()=>d,Id:()=>f,O8:()=>i,qv:()=>l,po:()=>_,Ow:()=>o,ZJ:()=>u,DH:()=>a,ld:()=>p});const s="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;var r=n(6739);const a=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4)),i=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),o=(e,t)=>e<<32-t|e>>>t,l=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0],c=e=>e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255;function d(e){for(let t=0;t<e.length;t++)e[t]=c(e[t])}function u(e){return"string"==typeof e&&(e=function(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}(e)),(0,r.ee)(e),e}function f(...e){let t=0;for(let n=0;n<e.length;n++){const s=e[n];(0,r.ee)(s),t+=s.length}const n=new Uint8Array(t);for(let t=0,s=0;t<e.length;t++){const r=e[t];n.set(r,s),s+=r.length}return n}class h{clone(){return this._cloneInto()}}function p(e){const t=t=>e().update(u(t)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}function _(e=32){if(s&&"function"==typeof s.getRandomValues)return s.getRandomValues(new Uint8Array(e));throw new Error("crypto.getRandomValues must be defined")}},9502:(e,t,n)=>{function s(e,t){const n=e.exec(t);return n?.groups}n.d(t,{BD:()=>r,Ge:()=>a,Yv:()=>s,wj:()=>i});const r=/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,a=/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,i=/^\(.+?\).*?$/},6027:(e,t,n)=>{function s(e){return"string"==typeof e?{address:e,type:"json-rpc"}:e}n.d(t,{J:()=>s})},9047:(e,t,n)=>{n.d(t,{T:()=>ae});var s=n(9502);const r=/^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/,a=/^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/,i=/^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/,o=/^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;function l(e){return o.test(e)}function c(e){return(0,s.Yv)(o,e)}const d=/^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/,u=/^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/,f=/^receive\(\) external payable$/;new Set(["memory","indexed","storage","calldata"]);const h=new Set(["indexed"]),p=new Set(["calldata","memory","storage"]);class _ extends Error{constructor(e,t={}){const n=t.cause instanceof _?t.cause.details:t.cause?.message?t.cause.message:t.details,s=t.cause instanceof _&&t.cause.docsPath||t.docsPath;super([e||"An error occurred.","",...t.metaMessages?[...t.metaMessages,""]:[],...s?[`Docs: https://abitype.dev${s}`]:[],...n?[`Details: ${n}`]:[],"Version: abitype@1.0.5"].join("\n")),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiTypeError"}),t.cause&&(this.cause=t.cause),this.details=n,this.docsPath=s,this.metaMessages=t.metaMessages,this.shortMessage=e}}class m extends _{constructor({type:e}){super("Unknown type.",{metaMessages:[`Type "${e}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"UnknownTypeError"})}}class g extends _{constructor({type:e}){super("Unknown type.",{metaMessages:[`Type "${e}" is not a valid ABI type.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"UnknownSolidityTypeError"})}}class b extends _{constructor({param:e}){super("Invalid ABI parameter.",{details:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidParameterError"})}}class y extends _{constructor({param:e,name:t}){super("Invalid ABI parameter.",{details:e,metaMessages:[`"${t}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SolidityProtectedKeywordError"})}}class v extends _{constructor({param:e,type:t,modifier:n}){super("Invalid ABI parameter.",{details:e,metaMessages:[`Modifier "${n}" not allowed${t?` in "${t}" type`:""}.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidModifierError"})}}class w extends _{constructor({param:e,type:t,modifier:n}){super("Invalid ABI parameter.",{details:e,metaMessages:[`Modifier "${n}" not allowed${t?` in "${t}" type`:""}.`,`Data location can only be specified for array, struct, or mapping types, but "${n}" was given.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidFunctionModifierError"})}}class A extends _{constructor({abiParameter:e}){super("Invalid ABI parameter.",{details:JSON.stringify(e,null,2),metaMessages:["ABI parameter type is invalid."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidAbiTypeParameterError"})}}class E extends _{constructor({signature:e,type:t}){super(`Invalid ${t} signature.`,{details:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidSignatureError"})}}class x extends _{constructor({signature:e}){super("Unknown signature.",{details:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"UnknownSignatureError"})}}class S extends _{constructor({signature:e}){super("Invalid struct signature.",{details:e,metaMessages:["No properties exist."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidStructSignatureError"})}}class T extends _{constructor({type:e}){super("Circular reference detected.",{metaMessages:[`Struct "${e}" is a circular reference.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"CircularReferenceError"})}}class k extends _{constructor({current:e,depth:t}){super("Unbalanced parentheses.",{metaMessages:[`"${e.trim()}" has too many ${t>0?"opening":"closing"} parentheses.`],details:`Depth "${t}"`}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidParenthesisError"})}}const C=new Map([["address",{type:"address"}],["bool",{type:"bool"}],["bytes",{type:"bytes"}],["bytes32",{type:"bytes32"}],["int",{type:"int256"}],["int256",{type:"int256"}],["string",{type:"string"}],["uint",{type:"uint256"}],["uint8",{type:"uint8"}],["uint16",{type:"uint16"}],["uint24",{type:"uint24"}],["uint32",{type:"uint32"}],["uint64",{type:"uint64"}],["uint96",{type:"uint96"}],["uint112",{type:"uint112"}],["uint160",{type:"uint160"}],["uint192",{type:"uint192"}],["uint256",{type:"uint256"}],["address owner",{type:"address",name:"owner"}],["address to",{type:"address",name:"to"}],["bool approved",{type:"bool",name:"approved"}],["bytes _data",{type:"bytes",name:"_data"}],["bytes data",{type:"bytes",name:"data"}],["bytes signature",{type:"bytes",name:"signature"}],["bytes32 hash",{type:"bytes32",name:"hash"}],["bytes32 r",{type:"bytes32",name:"r"}],["bytes32 root",{type:"bytes32",name:"root"}],["bytes32 s",{type:"bytes32",name:"s"}],["string name",{type:"string",name:"name"}],["string symbol",{type:"string",name:"symbol"}],["string tokenURI",{type:"string",name:"tokenURI"}],["uint tokenId",{type:"uint256",name:"tokenId"}],["uint8 v",{type:"uint8",name:"v"}],["uint256 balance",{type:"uint256",name:"balance"}],["uint256 tokenId",{type:"uint256",name:"tokenId"}],["uint256 value",{type:"uint256",name:"value"}],["event:address indexed from",{type:"address",name:"from",indexed:!0}],["event:address indexed to",{type:"address",name:"to",indexed:!0}],["event:uint indexed tokenId",{type:"uint256",name:"tokenId",indexed:!0}],["event:uint256 indexed tokenId",{type:"uint256",name:"tokenId",indexed:!0}]]);function z(e,t={}){if(function(e){return i.test(e)}(e)){const n=function(e){return(0,s.Yv)(i,e)}(e);if(!n)throw new E({signature:e,type:"function"});const r=L(n.parameters),a=[],o=r.length;for(let e=0;e<o;e++)a.push(G(r[e],{modifiers:p,structs:t,type:"function"}));const l=[];if(n.returns){const e=L(n.returns),s=e.length;for(let n=0;n<s;n++)l.push(G(e[n],{modifiers:p,structs:t,type:"function"}))}return{name:n.name,type:"function",stateMutability:n.stateMutability??"nonpayable",inputs:a,outputs:l}}if(function(e){return a.test(e)}(e)){const n=function(e){return(0,s.Yv)(a,e)}(e);if(!n)throw new E({signature:e,type:"event"});const r=L(n.parameters),i=[],o=r.length;for(let e=0;e<o;e++)i.push(G(r[e],{modifiers:h,structs:t,type:"event"}));return{name:n.name,type:"event",inputs:i}}if(function(e){return r.test(e)}(e)){const n=function(e){return(0,s.Yv)(r,e)}(e);if(!n)throw new E({signature:e,type:"error"});const a=L(n.parameters),i=[],o=a.length;for(let e=0;e<o;e++)i.push(G(a[e],{structs:t,type:"error"}));return{name:n.name,type:"error",inputs:i}}if(function(e){return d.test(e)}(e)){const n=function(e){return(0,s.Yv)(d,e)}(e);if(!n)throw new E({signature:e,type:"constructor"});const r=L(n.parameters),a=[],i=r.length;for(let e=0;e<i;e++)a.push(G(r[e],{structs:t,type:"constructor"}));return{type:"constructor",stateMutability:n.stateMutability??"nonpayable",inputs:a}}if(function(e){return u.test(e)}(e))return{type:"fallback"};if(function(e){return f.test(e)}(e))return{type:"receive",stateMutability:"payable"};throw new x({signature:e})}const P=/^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,F=/^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,N=/^u?int$/;function G(e,t){const n=function(e,t){return t?`${t}:${e}`:e}(e,t?.type);if(C.has(n))return C.get(n);const r=s.wj.test(e),a=(0,s.Yv)(r?F:P,e);if(!a)throw new b({param:e});if(a.name&&function(e){return"address"===e||"bool"===e||"function"===e||"string"===e||"tuple"===e||s.BD.test(e)||s.Ge.test(e)||R.test(e)}(a.name))throw new y({param:e,name:a.name});const i=a.name?{name:a.name}:{},o="indexed"===a.modifier?{indexed:!0}:{},l=t?.structs??{};let c,d={};if(r){c="tuple";const e=L(a.type),t=[],n=e.length;for(let s=0;s<n;s++)t.push(G(e[s],{structs:l}));d={components:t}}else if(a.type in l)c="tuple",d={components:l[a.type]};else if(N.test(a.type))c=`${a.type}256`;else if(c=a.type,"struct"!==t?.type&&!O(c))throw new g({type:c});if(a.modifier){if(!t?.modifiers?.has?.(a.modifier))throw new v({param:e,type:t?.type,modifier:a.modifier});if(p.has(a.modifier)&&!function(e,t){return t||"bytes"===e||"string"===e||"tuple"===e}(c,!!a.array))throw new w({param:e,type:t?.type,modifier:a.modifier})}const u={type:`${c}${a.array??""}`,...i,...o,...d};return C.set(n,u),u}function L(e,t=[],n="",s=0){const r=e.trim().length;for(let a=0;a<r;a++){const r=e[a],i=e.slice(a+1);switch(r){case",":return 0===s?L(i,[...t,n.trim()]):L(i,t,`${n}${r}`,s);case"(":return L(i,t,`${n}${r}`,s+1);case")":return L(i,t,`${n}${r}`,s-1);default:return L(i,t,`${n}${r}`,s)}}if(""===n)return t;if(0!==s)throw new k({current:n,depth:s});return t.push(n.trim()),t}function O(e){return"address"===e||"bool"===e||"function"===e||"string"===e||s.BD.test(e)||s.Ge.test(e)}const R=/^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/,M=/^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;function B(e,t,n=new Set){const r=[],a=e.length;for(let i=0;i<a;i++){const a=e[i];if(s.wj.test(a.type))r.push(a);else{const e=(0,s.Yv)(M,a.type);if(!e?.type)throw new A({abiParameter:a});const{array:i,type:o}=e;if(o in t){if(n.has(o))throw new T({type:o});r.push({...a,type:`tuple${i??""}`,components:B(t[o]??[],t,new Set([...n,o]))})}else{if(!O(o))throw new m({type:o});r.push(a)}}}return r}function Y(e){const t=function(e){const t={},n=e.length;for(let s=0;s<n;s++){const n=e[s];if(!l(n))continue;const r=c(n);if(!r)throw new E({signature:n,type:"struct"});const a=r.properties.split(";"),i=[],o=a.length;for(let e=0;e<o;e++){const t=a[e].trim();if(!t)continue;const n=G(t,{type:"struct"});i.push(n)}if(!i.length)throw new S({signature:n});t[r.name]=i}const s={},r=Object.entries(t),a=r.length;for(let e=0;e<a;e++){const[n,a]=r[e];s[n]=B(a,t)}return s}(e),n=[],s=e.length;for(let r=0;r<s;r++){const s=e[r];l(s)||n.push(z(s,t))}return n}var j=n(6027),H=n(4153);const I="0x82ad56cb";var X=n(9655),U=n(9302),J=n(1893),D=n(3329),q=n(8902),K=n(3608),W=n(2373),Z=n(2987),V=n(9042),Q=n(7426),$=n(3594),ee=n(5979),te=n(2545),ne=n(3513),se=n(6409),re=n(7338);async function ae(e,t){const{account:s=e.account,batch:r=Boolean(e.batch?.multicall),blockNumber:a,blockTag:i="latest",accessList:o,blobs:l,code:c,data:d,factory:u,factoryData:f,gas:h,gasPrice:p,maxFeePerBlobGas:_,maxFeePerGas:m,maxPriorityFeePerGas:g,nonce:b,to:y,value:v,stateOverride:w,...A}=t,E=s?(0,j.J)(s):void 0;if(c&&(u||f))throw new U.C("Cannot provide both `code` & `factory`/`factoryData` as parameters.");if(c&&y)throw new U.C("Cannot provide both `code` & `to` as parameters.");const x=c&&d,S=u&&f&&y&&d,T=x||S,k=x?function(e){const{code:t,data:n}=e;return(0,K.m)({abi:Y(["constructor(bytes, bytes)"]),bytecode:X.LX,args:[t,n]})}({code:c,data:d}):S?function(e){const{data:t,factory:n,factoryData:s,to:r}=e;return(0,K.m)({abi:Y(["constructor(address, bytes, address, bytes)"]),bytecode:X.WN,args:[r,t,n,s]})}({data:d,factory:u,factoryData:f,to:y}):d;try{(0,re.c)(t);const n=(a?(0,V.cK)(a):void 0)||i,s=(0,se.yH)(w),c=e.chain?.formatters?.transactionRequest?.format,d=(c||te.Bv)({...(0,ee.o)(A,{format:c}),from:E?.address,accessList:o,blobs:l,data:k,gas:h,gasPrice:p,maxFeePerBlobGas:_,maxFeePerGas:m,maxPriorityFeePerGas:g,nonce:b,to:T?void 0:y,value:v});if(r&&function({request:e}){const{data:t,to:n,...s}=e;return!(!t||t.startsWith(I)||!n||Object.values(s).filter((e=>void 0!==e)).length>0)}({request:d})&&!s)try{return await async function(e,t){const{batchSize:n=1024,wait:s=0}="object"==typeof e.batch?.multicall?e.batch.multicall:{},{blockNumber:r,blockTag:a="latest",data:i,multicallAddress:o,to:l}=t;let c=o;if(!c){if(!e.chain)throw new J.YE;c=(0,Z.M)({blockNumber:r,chain:e.chain,contract:"multicall3"})}const d=(r?(0,V.cK)(r):void 0)||a,{schedule:u}=(0,ne.u)({id:`${e.uid}.${d}`,wait:s,shouldSplitBatch(e){const t=e.reduce(((e,{data:t})=>e+(t.length-2)),0);return t>2*n},fn:async t=>{const n=t.map((e=>({allowFailure:!0,callData:e.data,target:e.to}))),s=(0,W.p)({abi:H.v2,args:[n],functionName:"aggregate3"}),r=await e.request({method:"eth_call",params:[{data:s,to:c},d]});return(0,q.e)({abi:H.v2,args:[n],functionName:"aggregate3",data:r||"0x"})}}),[{returnData:f,success:h}]=await u({data:i,to:l});if(!h)throw new D.$S({data:f});return"0x"===f?{data:void 0}:{data:f}}(e,{...d,blockNumber:a,blockTag:i})}catch(e){if(!(e instanceof J.YE||e instanceof J.rj))throw e}const u=await e.request({method:"eth_call",params:s?[d,n,s]:[d,n]});return"0x"===u?{data:void 0}:{data:u}}catch(s){const r=function(e){if(!(e instanceof U.C))return;const t=e.walk();return"object"==typeof t?.data?t.data?.data:t.data}(s),{offchainLookup:a,offchainLookupSignature:i}=await n.e(471).then(n.bind(n,4471));if(!1!==e.ccipRead&&r?.slice(0,10)===i&&y)return{data:await a(e,{data:r,to:y})};if(T&&"0x101bb98d"===r?.slice(0,10))throw new D.Po({factory:u});throw function(e,{docsPath:t,...n}){const s=(()=>{const t=(0,$.l)(e,n);return t instanceof Q.RM?e:t})();return new D.zX(s,{docsPath:t,...n})}(s,{...t,account:E,chain:e.chain})}}},4153:(e,t,n)=>{n.d(t,{Ag:()=>a,Rm:()=>l,SJ:()=>o,_:()=>c,oX:()=>i,v2:()=>s});const s=[{inputs:[{components:[{name:"target",type:"address"},{name:"allowFailure",type:"bool"},{name:"callData",type:"bytes"}],name:"calls",type:"tuple[]"}],name:"aggregate3",outputs:[{components:[{name:"success",type:"bool"},{name:"returnData",type:"bytes"}],name:"returnData",type:"tuple[]"}],stateMutability:"view",type:"function"}],r=[{inputs:[],name:"ResolverNotFound",type:"error"},{inputs:[],name:"ResolverWildcardNotSupported",type:"error"},{inputs:[],name:"ResolverNotContract",type:"error"},{inputs:[{name:"returnData",type:"bytes"}],name:"ResolverError",type:"error"},{inputs:[{components:[{name:"status",type:"uint16"},{name:"message",type:"string"}],name:"errors",type:"tuple[]"}],name:"HttpError",type:"error"}],a=[...r,{name:"resolve",type:"function",stateMutability:"view",inputs:[{name:"name",type:"bytes"},{name:"data",type:"bytes"}],outputs:[{name:"",type:"bytes"},{name:"address",type:"address"}]},{name:"resolve",type:"function",stateMutability:"view",inputs:[{name:"name",type:"bytes"},{name:"data",type:"bytes"},{name:"gateways",type:"string[]"}],outputs:[{name:"",type:"bytes"},{name:"address",type:"address"}]}],i=[...r,{name:"reverse",type:"function",stateMutability:"view",inputs:[{type:"bytes",name:"reverseName"}],outputs:[{type:"string",name:"resolvedName"},{type:"address",name:"resolvedAddress"},{type:"address",name:"reverseResolver"},{type:"address",name:"resolver"}]},{name:"reverse",type:"function",stateMutability:"view",inputs:[{type:"bytes",name:"reverseName"},{type:"string[]",name:"gateways"}],outputs:[{type:"string",name:"resolvedName"},{type:"address",name:"resolvedAddress"},{type:"address",name:"reverseResolver"},{type:"address",name:"resolver"}]}],o=[{name:"text",type:"function",stateMutability:"view",inputs:[{name:"name",type:"bytes32"},{name:"key",type:"string"}],outputs:[{name:"",type:"string"}]}],l=[{name:"addr",type:"function",stateMutability:"view",inputs:[{name:"name",type:"bytes32"}],outputs:[{name:"",type:"address"}]},{name:"addr",type:"function",stateMutability:"view",inputs:[{name:"name",type:"bytes32"},{name:"coinType",type:"uint256"}],outputs:[{name:"",type:"bytes"}]}],c=[{inputs:[{name:"_signer",type:"address"},{name:"_hash",type:"bytes32"},{name:"_signature",type:"bytes"}],stateMutability:"nonpayable",type:"constructor"}]},9655:(e,t,n)=>{n.d(t,{LX:()=>s,WN:()=>r,nP:()=>a});const s="0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe",r="0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe",a="0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572"},1919:(e,t,n)=>{n.d(t,{J9:()=>a,Mc:()=>r,fD:()=>s});const s={1:"An `assert` condition failed.",17:"Arithmetic operation resulted in underflow or overflow.",18:"Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",33:"Attempted to convert to an invalid type.",34:"Attempted to access a storage byte array that is incorrectly encoded.",49:"Performed `.pop()` on an empty array",50:"Array index is out of bounds.",65:"Allocated too much memory or created an array which is too large.",81:"Attempted to call a zero-initialized variable of internal function type."},r={inputs:[{name:"message",type:"string"}],name:"Error",type:"error"},a={inputs:[{name:"reason",type:"uint256"}],name:"Panic",type:"error"}},6956:(e,t,n)=>{n.d(t,{eL:()=>s,sz:()=>r});const s={gwei:9,wei:18},r={ether:-9,wei:9}},3686:(e,t,n)=>{n.d(t,{BI:()=>v,Iy:()=>l,Iz:()=>g,MR:()=>b,M_:()=>m,Nc:()=>d,O:()=>c,Wq:()=>h,YE:()=>f,YF:()=>o,YW:()=>i,_z:()=>p,d_:()=>T,dm:()=>S,fo:()=>w,gH:()=>u,j:()=>x,kE:()=>_,l3:()=>A,nK:()=>E,nM:()=>y});var s=n(113),r=n(6420),a=n(9302);class i extends a.C{constructor({docsPath:e}){super(["A constructor was not found on the ABI.","Make sure you are using the correct ABI and that the constructor exists on it."].join("\n"),{docsPath:e,name:"AbiConstructorNotFoundError"})}}class o extends a.C{constructor({docsPath:e}){super(["Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.","Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."].join("\n"),{docsPath:e,name:"AbiConstructorParamsNotFoundError"})}}a.C;class l extends a.C{constructor({data:e,params:t,size:n}){super([`Data size of ${n} bytes is too small for given parameters.`].join("\n"),{metaMessages:[`Params: (${(0,s.A)(t,{includeName:!0})})`,`Data:   ${e} (${n} bytes)`],name:"AbiDecodingDataSizeTooSmallError"}),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"params",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"size",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.data=e,this.params=t,this.size=n}}class c extends a.C{constructor(){super('Cannot decode zero data ("0x") with ABI parameters.',{name:"AbiDecodingZeroDataError"})}}class d extends a.C{constructor({expectedLength:e,givenLength:t,type:n}){super([`ABI encoding array length mismatch for type ${n}.`,`Expected length: ${e}`,`Given length: ${t}`].join("\n"),{name:"AbiEncodingArrayLengthMismatchError"})}}class u extends a.C{constructor({expectedSize:e,value:t}){super(`Size of bytes "${t}" (bytes${(0,r.E)(t)}) does not match expected size (bytes${e}).`,{name:"AbiEncodingBytesSizeMismatchError"})}}class f extends a.C{constructor({expectedLength:e,givenLength:t}){super(["ABI encoding params/values length mismatch.",`Expected length (params): ${e}`,`Given length (values): ${t}`].join("\n"),{name:"AbiEncodingLengthMismatchError"})}}a.C,a.C;class h extends a.C{constructor(e,{docsPath:t}){super([`Encoded error signature "${e}" not found on ABI.`,"Make sure you are using the correct ABI and that the error exists on it.",`You can look up the decoded signature here: https://openchain.xyz/signatures?query=${e}.`].join("\n"),{docsPath:t,name:"AbiErrorSignatureNotFoundError"}),Object.defineProperty(this,"signature",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.signature=e}}class p extends a.C{constructor({docsPath:e}){super("Cannot extract event signature from empty topics.",{docsPath:e,name:"AbiEventSignatureEmptyTopicsError"})}}class _ extends a.C{constructor(e,{docsPath:t}){super([`Encoded event signature "${e}" not found on ABI.`,"Make sure you are using the correct ABI and that the event exists on it.",`You can look up the signature here: https://openchain.xyz/signatures?query=${e}.`].join("\n"),{docsPath:t,name:"AbiEventSignatureNotFoundError"})}}class m extends a.C{constructor(e,{docsPath:t}={}){super([`Event ${e?`"${e}" `:""}not found on ABI.`,"Make sure you are using the correct ABI and that the event exists on it."].join("\n"),{docsPath:t,name:"AbiEventNotFoundError"})}}class g extends a.C{constructor(e,{docsPath:t}={}){super([`Function ${e?`"${e}" `:""}not found on ABI.`,"Make sure you are using the correct ABI and that the function exists on it."].join("\n"),{docsPath:t,name:"AbiFunctionNotFoundError"})}}class b extends a.C{constructor(e,{docsPath:t}){super([`Function "${e}" does not contain any \`outputs\` on ABI.`,"Cannot decode function result without knowing what the parameter types are.","Make sure you are using the correct ABI and that the function exists on it."].join("\n"),{docsPath:t,name:"AbiFunctionOutputsNotFoundError"})}}a.C;class y extends a.C{constructor(e,t){super("Found ambiguous types in overloaded ABI items.",{metaMessages:[`\`${e.type}\` in \`${(0,s.B)(e.abiItem)}\`, and`,`\`${t.type}\` in \`${(0,s.B)(t.abiItem)}\``,"","These types encode differently and cannot be distinguished at runtime.","Remove one of the ambiguous items in the ABI."],name:"AbiItemAmbiguityError"})}}class v extends a.C{constructor({expectedSize:e,givenSize:t}){super(`Expected bytes${e}, got bytes${t}.`,{name:"BytesSizeMismatchError"})}}class w extends a.C{constructor({abiItem:e,data:t,params:n,size:r}){super([`Data size of ${r} bytes is too small for non-indexed event parameters.`].join("\n"),{metaMessages:[`Params: (${(0,s.A)(n,{includeName:!0})})`,`Data:   ${t} (${r} bytes)`],name:"DecodeLogDataMismatch"}),Object.defineProperty(this,"abiItem",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"params",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"size",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.abiItem=e,this.data=t,this.params=n,this.size=r}}class A extends a.C{constructor({abiItem:e,param:t}){super([`Expected a topic for indexed event parameter${t.name?` "${t.name}"`:""} on event "${(0,s.B)(e,{includeName:!0})}".`].join("\n"),{name:"DecodeLogTopicsMismatch"}),Object.defineProperty(this,"abiItem",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.abiItem=e}}class E extends a.C{constructor(e,{docsPath:t}){super([`Type "${e}" is not a valid encoding type.`,"Please provide a valid ABI type."].join("\n"),{docsPath:t,name:"InvalidAbiEncodingType"})}}class x extends a.C{constructor(e,{docsPath:t}){super([`Type "${e}" is not a valid decoding type.`,"Please provide a valid ABI type."].join("\n"),{docsPath:t,name:"InvalidAbiDecodingType"})}}class S extends a.C{constructor(e){super([`Value "${e}" is not a valid array.`].join("\n"),{name:"InvalidArrayError"})}}class T extends a.C{constructor(e){super([`"${e}" is not a valid definition type.`,'Valid types: "function", "event", "error"'].join("\n"),{name:"InvalidDefinitionTypeError"})}}a.C},5372:(e,t,n)=>{n.d(t,{M:()=>r});var s=n(9302);class r extends s.C{constructor({address:e}){super(`Address "${e}" is invalid.`,{metaMessages:["- Address must be a hex value of 20 bytes (40 hex characters).","- Address must match its checksum counterpart."],name:"InvalidAddressError"})}}},9302:(e,t,n)=>{n.d(t,{C:()=>i});const s="2.21.15";let r=({docsBaseUrl:e,docsPath:t="",docsSlug:n})=>t?`${e??"https://viem.sh"}${t}${n?`#${n}`:""}`:void 0,a=s;class i extends Error{constructor(e,t={}){const n=t.cause instanceof i?t.cause.details:t.cause?.message?t.cause.message:t.details,o=t.cause instanceof i&&t.cause.docsPath||t.docsPath,l=r?.({...t,docsPath:o});super([e||"An error occurred.","",...t.metaMessages?[...t.metaMessages,""]:[],...l?[`Docs: ${l}`]:[],...n?[`Details: ${n}`]:[],...a?[`Version: ${a}`]:[]].join("\n"),t.cause?{cause:t.cause}:void 0),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"version",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"BaseError"}),this.details=n,this.docsPath=o,this.metaMessages=t.metaMessages,this.name=t.name??this.name,this.shortMessage=e,this.version=s}walk(e){return o(this,e)}}function o(e,t){return t?.(e)?e:e&&"object"==typeof e&&"cause"in e?o(e.cause,t):t?null:e}},1893:(e,t,n)=>{n.d(t,{EH:()=>a,YE:()=>o,jF:()=>i,rj:()=>r});var s=n(9302);class r extends s.C{constructor({blockNumber:e,chain:t,contract:n}){super(`Chain "${t.name}" does not support contract "${n.name}".`,{metaMessages:["This could be due to any of the following:",...e&&n.blockCreated&&n.blockCreated>e?[`- The contract "${n.name}" was not deployed until block ${n.blockCreated} (current block ${e}).`]:[`- The chain does not have the contract "${n.name}" configured.`]],name:"ChainDoesNotSupportContract"})}}class a extends s.C{constructor({chain:e,currentChainId:t}){super(`The current chain of the wallet (id: ${t}) does not match the target chain for the transaction (id: ${e.id} – ${e.name}).`,{metaMessages:[`Current Chain ID:  ${t}`,`Expected Chain ID: ${e.id} – ${e.name}`],name:"ChainMismatchError"})}}class i extends s.C{constructor(){super(["No chain was provided to the request.","Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."].join("\n"),{name:"ChainNotFoundError"})}}class o extends s.C{constructor(){super("No chain was provided to the Client.",{name:"ClientChainNotConfiguredError"})}}s.C},3329:(e,t,n)=>{n.d(t,{zX:()=>g,bG:()=>b,M:()=>y,rR:()=>v,Po:()=>w,$S:()=>A});var s=n(6027),r=n(1919),a=n(8440),i=n(113),o=n(1501);function l({abiItem:e,args:t,includeFunctionName:n=!0,includeName:s=!1}){if("name"in e&&"inputs"in e&&e.inputs)return`${n?e.name:""}(${e.inputs.map(((e,n)=>`${s&&e.name?`${e.name}: `:""}${"object"==typeof t[n]?(0,o.A)(t[n]):t[n]}`)).join(", ")})`}var c=n(3856),d=n(3538),u=n(1892),f=n(3686),h=n(9302),p=n(373),_=n(7740),m=n(9197);class g extends h.C{constructor(e,{account:t,docsPath:n,chain:r,data:a,gas:i,gasPrice:o,maxFeePerGas:l,maxPriorityFeePerGas:c,nonce:f,to:h,value:m,stateOverride:g}){const b=t?(0,s.J)(t):void 0;let y=(0,_.aO)({from:b?.address,to:h,value:void 0!==m&&`${(0,d.c)(m)} ${r?.nativeCurrency?.symbol||"ETH"}`,data:a,gas:i,gasPrice:void 0!==o&&`${(0,u.Q)(o)} gwei`,maxFeePerGas:void 0!==l&&`${(0,u.Q)(l)} gwei`,maxPriorityFeePerGas:void 0!==c&&`${(0,u.Q)(c)} gwei`,nonce:f});g&&(y+=`\n${(0,p.uj)(g)}`),super(e.shortMessage,{cause:e,docsPath:n,metaMessages:[...e.metaMessages?[...e.metaMessages," "]:[],"Raw Call Arguments:",y].filter(Boolean),name:"CallExecutionError"}),Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.cause=e}}class b extends h.C{constructor(e,{abi:t,args:n,contractAddress:s,docsPath:r,functionName:a,sender:o}){const d=(0,c.iY)({abi:t,args:n,name:a}),u=d?l({abiItem:d,args:n,includeFunctionName:!1,includeName:!1}):void 0,f=d?(0,i.B)(d,{includeName:!0}):void 0,h=(0,_.aO)({address:s&&(0,m.R)(s),function:f,args:u&&"()"!==u&&`${[...Array(a?.length??0).keys()].map((()=>" ")).join("")}${u}`,sender:o});super(e.shortMessage||`An unknown error occurred while executing the contract function "${a}".`,{cause:e,docsPath:r,metaMessages:[...e.metaMessages?[...e.metaMessages," "]:[],h&&"Contract Call:",h].filter(Boolean),name:"ContractFunctionExecutionError"}),Object.defineProperty(this,"abi",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"args",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"contractAddress",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"formattedArgs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"functionName",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"sender",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.abi=t,this.args=n,this.cause=e,this.contractAddress=s,this.functionName=a,this.sender=o}}class y extends h.C{constructor({abi:e,data:t,functionName:n,message:s}){let o,c,d,u,h;if(t&&"0x"!==t)try{c=(0,a.W)({abi:e,data:t});const{abiItem:n,errorName:s,args:o}=c;if("Error"===s)u=o[0];else if("Panic"===s){const[e]=o;u=r.fD[e]}else{const e=n?(0,i.B)(n,{includeName:!0}):void 0,t=n&&o?l({abiItem:n,args:o,includeFunctionName:!1,includeName:!1}):void 0;d=[e?`Error: ${e}`:"",t&&"()"!==t?`       ${[...Array(s?.length??0).keys()].map((()=>" ")).join("")}${t}`:""]}}catch(e){o=e}else s&&(u=s);o instanceof f.Wq&&(h=o.signature,d=[`Unable to decode signature "${h}" as it was not found on the provided ABI.`,"Make sure you are using the correct ABI and that the error exists on it.",`You can look up the decoded signature here: https://openchain.xyz/signatures?query=${h}.`]),super(u&&"execution reverted"!==u||h?[`The contract function "${n}" reverted with the following ${h?"signature":"reason"}:`,u||h].join("\n"):`The contract function "${n}" reverted.`,{cause:o,metaMessages:d,name:"ContractFunctionRevertedError"}),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"reason",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"signature",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.data=c,this.reason=u,this.signature=h}}class v extends h.C{constructor({functionName:e}){super(`The contract function "${e}" returned no data ("0x").`,{metaMessages:["This could be due to any of the following:",`  - The contract does not have the function "${e}",`,"  - The parameters passed to the contract function may be invalid, or","  - The address is not a contract."],name:"ContractFunctionZeroDataError"})}}class w extends h.C{constructor({factory:e}){super("Deployment for counterfactual contract call failed"+(e?` for factory "${e}".`:""),{metaMessages:["Please ensure:","- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).","- The `factoryData` is a valid encoded function call for contract deployment function on the factory."],name:"CounterfactualDeploymentFailedError"})}}class A extends h.C{constructor({data:e,message:t}){super(t||"",{name:"RawContractError"}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:3}),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.data=e}}},4112:(e,t,n)=>{n.d(t,{B4:()=>r,SK:()=>a,hX:()=>i});var s=n(9302);class r extends s.C{constructor({offset:e}){super(`Offset \`${e}\` cannot be negative.`,{name:"NegativeOffsetError"})}}class a extends s.C{constructor({length:e,position:t}){super(`Position \`${t}\` is out of bounds (\`0 < position < ${e}\`).`,{name:"PositionOutOfBoundsError"})}}class i extends s.C{constructor({count:e,limit:t}){super(`Recursive read limit of \`${t}\` exceeded (recursive read count: \`${e}\`).`,{name:"RecursiveReadLimitExceededError"})}}},7834:(e,t,n)=>{n.d(t,{Fl:()=>a,NV:()=>i,ii:()=>r});var s=n(9302);class r extends s.C{constructor({offset:e,position:t,size:n}){super(`Slice ${"start"===t?"starting":"ending"} at offset "${e}" is out-of-bounds (size: ${n}).`,{name:"SliceOffsetOutOfBoundsError"})}}class a extends s.C{constructor({size:e,targetSize:t,type:n}){super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (${e}) exceeds padding size (${t}).`,{name:"SizeExceedsPaddingSizeError"})}}class i extends s.C{constructor({size:e,targetSize:t,type:n}){super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} is expected to be ${t} ${n} long, but is ${e} ${n} long.`,{name:"InvalidBytesLengthError"})}}},9699:(e,t,n)=>{n.d(t,{Ty:()=>r,u:()=>i,xO:()=>a});var s=n(9302);class r extends s.C{constructor({max:e,min:t,signed:n,size:s,value:r}){super(`Number "${r}" is not in safe ${s?`${8*s}-bit ${n?"signed":"unsigned"} `:""}integer range ${e?`(${t} to ${e})`:`(above ${t})`}`,{name:"IntegerOutOfRangeError"})}}class a extends s.C{constructor(e){super(`Bytes value "${e}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,{name:"InvalidBytesBooleanError"})}}s.C,s.C;class i extends s.C{constructor({givenSize:e,maxSize:t}){super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`,{name:"SizeOverflowError"})}}},7426:(e,t,n)=>{n.d(t,{A7:()=>a,BG:()=>i,Fo:()=>h,K0:()=>l,Oh:()=>c,RM:()=>m,jj:()=>o,k5:()=>u,lN:()=>_,lY:()=>f,uC:()=>p,vW:()=>d});var s=n(1892),r=n(9302);class a extends r.C{constructor({cause:e,message:t}={}){const n=t?.replace("execution reverted: ","")?.replace("execution reverted","");super(`Execution reverted ${n?`with reason: ${n}`:"for an unknown reason"}.`,{cause:e,name:"ExecutionRevertedError"})}}Object.defineProperty(a,"code",{enumerable:!0,configurable:!0,writable:!0,value:3}),Object.defineProperty(a,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/execution reverted/});class i extends r.C{constructor({cause:e,maxFeePerGas:t}={}){super(`The fee cap (\`maxFeePerGas\`${t?` = ${(0,s.Q)(t)} gwei`:""}) cannot be higher than the maximum allowed value (2^256-1).`,{cause:e,name:"FeeCapTooHighError"})}}Object.defineProperty(i,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/});class o extends r.C{constructor({cause:e,maxFeePerGas:t}={}){super(`The fee cap (\`maxFeePerGas\`${t?` = ${(0,s.Q)(t)}`:""} gwei) cannot be lower than the block base fee.`,{cause:e,name:"FeeCapTooLowError"})}}Object.defineProperty(o,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/});class l extends r.C{constructor({cause:e,nonce:t}={}){super(`Nonce provided for the transaction ${t?`(${t}) `:""}is higher than the next one expected.`,{cause:e,name:"NonceTooHighError"})}}Object.defineProperty(l,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce too high/});class c extends r.C{constructor({cause:e,nonce:t}={}){super([`Nonce provided for the transaction ${t?`(${t}) `:""}is lower than the current nonce of the account.`,"Try increasing the nonce or find the latest nonce with `getTransactionCount`."].join("\n"),{cause:e,name:"NonceTooLowError"})}}Object.defineProperty(c,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce too low|transaction already imported|already known/});class d extends r.C{constructor({cause:e,nonce:t}={}){super(`Nonce provided for the transaction ${t?`(${t}) `:""}exceeds the maximum allowed nonce.`,{cause:e,name:"NonceMaxValueError"})}}Object.defineProperty(d,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce has max value/});class u extends r.C{constructor({cause:e}={}){super(["The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."].join("\n"),{cause:e,metaMessages:["This error could arise when the account does not have enough funds to:"," - pay for the total gas fee,"," - pay for the value to send."," ","The cost of the transaction is calculated as `gas * gas fee + value`, where:"," - `gas` is the amount of gas needed for transaction to execute,"," - `gas fee` is the gas fee,"," - `value` is the amount of ether to send to the recipient."],name:"InsufficientFundsError"})}}Object.defineProperty(u,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/insufficient funds|exceeds transaction sender account balance/});class f extends r.C{constructor({cause:e,gas:t}={}){super(`The amount of gas ${t?`(${t}) `:""}provided for the transaction exceeds the limit allowed for the block.`,{cause:e,name:"IntrinsicGasTooHighError"})}}Object.defineProperty(f,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/intrinsic gas too high|gas limit reached/});class h extends r.C{constructor({cause:e,gas:t}={}){super(`The amount of gas ${t?`(${t}) `:""}provided for the transaction is too low.`,{cause:e,name:"IntrinsicGasTooLowError"})}}Object.defineProperty(h,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/intrinsic gas too low/});class p extends r.C{constructor({cause:e}){super("The transaction type is not supported for this chain.",{cause:e,name:"TransactionTypeNotSupportedError"})}}Object.defineProperty(p,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/transaction type not valid/});class _ extends r.C{constructor({cause:e,maxPriorityFeePerGas:t,maxFeePerGas:n}={}){super([`The provided tip (\`maxPriorityFeePerGas\`${t?` = ${(0,s.Q)(t)} gwei`:""}) cannot be higher than the fee cap (\`maxFeePerGas\`${n?` = ${(0,s.Q)(n)} gwei`:""}).`].join("\n"),{cause:e,name:"TipAboveFeeCapError"})}}Object.defineProperty(_,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max priority fee per gas higher than max fee per gas|tip higher than fee cap/});class m extends r.C{constructor({cause:e}){super(`An error occurred while executing: ${e?.shortMessage}`,{cause:e,name:"UnknownNodeError"})}}},6809:(e,t,n)=>{n.d(t,{Ci:()=>i,J8:()=>o,MU:()=>l});var s=n(1501),r=n(9302),a=n(9197);class i extends r.C{constructor({body:e,cause:t,details:n,headers:r,status:i,url:o}){super("HTTP request failed.",{cause:t,details:n,metaMessages:[i&&`Status: ${i}`,`URL: ${(0,a.I)(o)}`,e&&`Request body: ${(0,s.A)(e)}`].filter(Boolean),name:"HttpRequestError"}),Object.defineProperty(this,"body",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"headers",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"status",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"url",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.body=e,this.headers=r,this.status=i,this.url=o}}r.C;class o extends r.C{constructor({body:e,error:t,url:n}){super("RPC Request failed.",{cause:t,details:t.message,metaMessages:[`URL: ${(0,a.I)(n)}`,`Request body: ${(0,s.A)(e)}`],name:"RpcRequestError"}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.code=t.code}}r.C;class l extends r.C{constructor({body:e,url:t}){super("The request took too long to respond.",{details:"The request timed out.",metaMessages:[`URL: ${(0,a.I)(t)}`,`Request body: ${(0,s.A)(e)}`],name:"TimeoutError"})}}},373:(e,t,n)=>{n.d(t,{Hi:()=>r,ft:()=>a,uj:()=>o});var s=n(9302);class r extends s.C{constructor({address:e}){super(`State for account "${e}" is set multiple times.`,{name:"AccountStateConflictError"})}}class a extends s.C{constructor(){super("state and stateDiff are set on the same account.",{name:"StateAssignmentConflictError"})}}function i(e){return e.reduce(((e,{slot:t,value:n})=>`${e}        ${t}: ${n}\n`),"")}function o(e){return e.reduce(((e,{address:t,...n})=>{let s=`${e}    ${t}:\n`;return n.nonce&&(s+=`      nonce: ${n.nonce}\n`),n.balance&&(s+=`      balance: ${n.balance}\n`),n.code&&(s+=`      code: ${n.code}\n`),n.state&&(s+="      state:\n",s+=i(n.state)),n.stateDiff&&(s+="      stateDiff:\n",s+=i(n.stateDiff)),s}),"  State Override:\n").slice(0,-1)}},7740:(e,t,n)=>{n.d(t,{$s:()=>c,Kc:()=>u,Kz:()=>d,Vg:()=>l,WA:()=>f,aO:()=>i,n3:()=>o});var s=n(3538),r=n(1892),a=n(9302);function i(e){const t=Object.entries(e).map((([e,t])=>void 0===t||!1===t?null:[e,t])).filter(Boolean),n=t.reduce(((e,[t])=>Math.max(e,t.length)),0);return t.map((([e,t])=>`  ${`${e}:`.padEnd(n+1)}  ${t}`)).join("\n")}class o extends a.C{constructor(){super(["Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.","Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."].join("\n"),{name:"FeeConflictError"})}}a.C;class l extends a.C{constructor({transaction:e}){super("Cannot infer a transaction type from provided transaction.",{metaMessages:["Provided Transaction:","{",i(e),"}","","To infer the type, either provide:","- a `type` to the Transaction, or","- an EIP-1559 Transaction with `maxFeePerGas`, or","- an EIP-2930 Transaction with `gasPrice` & `accessList`, or","- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or","- an EIP-7702 Transaction with `authorizationList`, or","- a Legacy Transaction with `gasPrice`"],name:"InvalidSerializableTransactionError"})}}a.C,a.C,a.C;class c extends a.C{constructor(e,{account:t,docsPath:n,chain:a,data:o,gas:l,gasPrice:c,maxFeePerGas:d,maxPriorityFeePerGas:u,nonce:f,to:h,value:p}){const _=i({chain:a&&`${a?.name} (id: ${a?.id})`,from:t?.address,to:h,value:void 0!==p&&`${(0,s.c)(p)} ${a?.nativeCurrency?.symbol||"ETH"}`,data:o,gas:l,gasPrice:void 0!==c&&`${(0,r.Q)(c)} gwei`,maxFeePerGas:void 0!==d&&`${(0,r.Q)(d)} gwei`,maxPriorityFeePerGas:void 0!==u&&`${(0,r.Q)(u)} gwei`,nonce:f});super(e.shortMessage,{cause:e,docsPath:n,metaMessages:[...e.metaMessages?[...e.metaMessages," "]:[],"Request Arguments:",_].filter(Boolean),name:"TransactionExecutionError"}),Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.cause=e}}class d extends a.C{constructor({blockHash:e,blockNumber:t,blockTag:n,hash:s,index:r}){let a="Transaction";n&&void 0!==r&&(a=`Transaction at block time "${n}" at index "${r}"`),e&&void 0!==r&&(a=`Transaction at block hash "${e}" at index "${r}"`),t&&void 0!==r&&(a=`Transaction at block number "${t}" at index "${r}"`),s&&(a=`Transaction with hash "${s}"`),super(`${a} could not be found.`,{name:"TransactionNotFoundError"})}}class u extends a.C{constructor({hash:e}){super(`Transaction receipt with hash "${e}" could not be found. The Transaction may not be processed on a block yet.`,{name:"TransactionReceiptNotFoundError"})}}class f extends a.C{constructor({hash:e}){super(`Timed out while waiting for transaction with hash "${e}" to be confirmed.`,{name:"WaitForTransactionReceiptTimeoutError"})}}},9197:(e,t,n)=>{n.d(t,{I:()=>r,R:()=>s});const s=e=>e,r=e=>e},9359:(e,t,n)=>{n.d(t,{n:()=>g});var s=n(3686),r=n(3887),a=n(9804),i=n(6420),o=n(5355),l=n(1577),c=n(9699),d=n(5261),u=n(9042);function f(e,t={}){void 0!==t.size&&(0,d.Sl)(e,{size:t.size});const n=(0,u.My)(e,t);return(0,d.uU)(n,t)}function h(e,t={}){let n=e;if(void 0!==t.size&&((0,d.Sl)(n,{size:t.size}),n=(0,l.B)(n)),n.length>1||n[0]>1)throw new c.xO(n);return Boolean(n[0])}function p(e,t={}){void 0!==t.size&&(0,d.Sl)(e,{size:t.size});const n=(0,u.My)(e,t);return(0,d.ME)(n,t)}var _=n(3588),m=n(2729);function g(e,t){const n="string"==typeof t?(0,_.aT)(t):t,r=(0,a.l)(n);if(0===(0,i.E)(n)&&e.length>0)throw new s.O;if((0,i.E)(t)&&(0,i.E)(t)<32)throw new s.Iy({data:"string"==typeof t?t:(0,u.My)(t),params:e,size:(0,i.E)(t)});let o=0;const l=[];for(let t=0;t<e.length;++t){const n=e[t];r.setPosition(o);const[s,a]=b(r,n,{staticPosition:0});o+=a,l.push(s)}return l}function b(e,t,{staticPosition:n}){const a=(0,m.k)(t.type);if(a){const[s,r]=a;return function(e,t,{length:n,staticPosition:s}){if(!n){const n=s+p(e.readBytes(v)),r=n+y;e.setPosition(n);const a=p(e.readBytes(y)),i=w(t);let o=0;const l=[];for(let n=0;n<a;++n){e.setPosition(r+(i?32*n:o));const[s,a]=b(e,t,{staticPosition:r});o+=a,l.push(s)}return e.setPosition(s+32),[l,32]}if(w(t)){const r=s+p(e.readBytes(v)),a=[];for(let s=0;s<n;++s){e.setPosition(r+32*s);const[n]=b(e,t,{staticPosition:r});a.push(n)}return e.setPosition(s+32),[a,32]}let r=0;const a=[];for(let i=0;i<n;++i){const[n,i]=b(e,t,{staticPosition:s+r});r+=i,a.push(n)}return[a,r]}(e,{...t,type:r},{length:s,staticPosition:n})}if("tuple"===t.type)return function(e,t,{staticPosition:n}){const s=0===t.components.length||t.components.some((({name:e})=>!e)),r=s?[]:{};let a=0;if(w(t)){const i=n+p(e.readBytes(v));for(let n=0;n<t.components.length;++n){const o=t.components[n];e.setPosition(i+a);const[l,c]=b(e,o,{staticPosition:i});a+=c,r[s?n:o?.name]=l}return e.setPosition(n+32),[r,32]}for(let i=0;i<t.components.length;++i){const o=t.components[i],[l,c]=b(e,o,{staticPosition:n});r[s?i:o?.name]=l,a+=c}return[r,a]}(e,t,{staticPosition:n});if("address"===t.type)return function(e){const t=e.readBytes(32);return[(0,r.o)((0,u.My)((0,o.A1)(t,-20))),32]}(e);if("bool"===t.type)return function(e){return[h(e.readBytes(32),{size:32}),32]}(e);if(t.type.startsWith("bytes"))return function(e,t,{staticPosition:n}){const[s,r]=t.type.split("bytes");if(!r){const t=p(e.readBytes(32));e.setPosition(n+t);const s=p(e.readBytes(32));if(0===s)return e.setPosition(n+32),["0x",32];const r=e.readBytes(s);return e.setPosition(n+32),[(0,u.My)(r),32]}return[(0,u.My)(e.readBytes(Number.parseInt(r),32)),32]}(e,t,{staticPosition:n});if(t.type.startsWith("uint")||t.type.startsWith("int"))return function(e,t){const n=t.type.startsWith("int"),s=Number.parseInt(t.type.split("int")[1]||"256"),r=e.readBytes(32);return[s>48?f(r,{signed:n}):p(r,{signed:n}),32]}(e,t);if("string"===t.type)return function(e,{staticPosition:t}){const n=t+p(e.readBytes(32));e.setPosition(n);const s=p(e.readBytes(32));if(0===s)return e.setPosition(t+32),["",32];const r=e.readBytes(s,32),a=function(e,t={}){let n=e;return void 0!==t.size&&((0,d.Sl)(n,{size:t.size}),n=(0,l.B)(n,{dir:"right"})),(new TextDecoder).decode(n)}((0,l.B)(r));return e.setPosition(t+32),[a,32]}(e,{staticPosition:n});throw new s.j(t.type,{docsPath:"/docs/contract/decodeAbiParameters"})}const y=32,v=32;function w(e){const{type:t}=e;if("string"===t)return!0;if("bytes"===t)return!0;if(t.endsWith("[]"))return!0;if("tuple"===t)return e.components?.some(w);const n=(0,m.k)(e.type);return!(!n||!w({...e,type:n[1]}))}},8440:(e,t,n)=>{n.d(t,{W:()=>c});var s=n(1919),r=n(3686),a=n(5355),i=n(5561),o=n(9359),l=n(113);function c(e){const{abi:t,data:n}=e,c=(0,a.di)(n,0,4);if("0x"===c)throw new r.O;const d=[...t||[],s.Mc,s.J9].find((e=>"error"===e.type&&c===(0,i.V)((0,l.B)(e))));if(!d)throw new r.Wq(c,{docsPath:"/docs/contract/decodeErrorResult"});return{abiItem:d,args:"inputs"in d&&d.inputs&&d.inputs.length>0?(0,o.n)(d.inputs,(0,a.di)(n,4)):void 0,errorName:d.name}}},8902:(e,t,n)=>{n.d(t,{e:()=>o});var s=n(3686),r=n(9359),a=n(3856);const i="/docs/contract/decodeFunctionResult";function o(e){const{abi:t,args:n,functionName:o,data:l}=e;let c=t[0];if(o){const e=(0,a.iY)({abi:t,args:n,name:o});if(!e)throw new s.Iz(o,{docsPath:i});c=e}if("function"!==c.type)throw new s.Iz(void 0,{docsPath:i});if(!c.outputs)throw new s.MR(c.name,{docsPath:i});const d=(0,r.n)(c.outputs,l);return d&&d.length>1?d:d&&1===d.length?d[0]:void 0}},2729:(e,t,n)=>{n.d(t,{h:()=>f,k:()=>_});var s=n(3686),r=n(5372),a=n(9302),i=n(7283),o=n(7673),l=n(5916),c=n(6420),d=n(5355),u=n(9042);function f(e,t){if(e.length!==t.length)throw new s.YE({expectedLength:e.length,givenLength:t.length});const n=function({params:e,values:t}){const n=[];for(let s=0;s<e.length;s++)n.push(h({param:e[s],value:t[s]}));return n}({params:e,values:t}),r=p(n);return 0===r.length?"0x":r}function h({param:e,value:t}){const n=_(e.type);if(n){const[r,a]=n;return function(e,{length:t,param:n}){const r=null===t;if(!Array.isArray(e))throw new s.dm(e);if(!r&&e.length!==t)throw new s.Nc({expectedLength:t,givenLength:e.length,type:`${n.type}[${t}]`});let a=!1;const i=[];for(let t=0;t<e.length;t++){const s=h({param:n,value:e[t]});s.dynamic&&(a=!0),i.push(s)}if(r||a){const e=p(i);if(r){const t=(0,u.cK)(i.length,{size:32});return{dynamic:!0,encoded:i.length>0?(0,o.xW)([t,e]):t}}if(a)return{dynamic:!0,encoded:e}}return{dynamic:!1,encoded:(0,o.xW)(i.map((({encoded:e})=>e)))}}(t,{length:r,param:{...e,type:a}})}if("tuple"===e.type)return function(e,{param:t}){let n=!1;const s=[];for(let r=0;r<t.components.length;r++){const a=t.components[r],i=h({param:a,value:e[Array.isArray(e)?r:a.name]});s.push(i),i.dynamic&&(n=!0)}return{dynamic:n,encoded:n?p(s):(0,o.xW)(s.map((({encoded:e})=>e)))}}(t,{param:e});if("address"===e.type)return function(e){if(!(0,i.P)(e))throw new r.M({address:e});return{dynamic:!1,encoded:(0,l.db)(e.toLowerCase())}}(t);if("bool"===e.type)return function(e){if("boolean"!=typeof e)throw new a.C(`Invalid boolean value: "${e}" (type: ${typeof e}). Expected: \`true\` or \`false\`.`);return{dynamic:!1,encoded:(0,l.db)((0,u.$P)(e))}}(t);if(e.type.startsWith("uint")||e.type.startsWith("int"))return function(e,{signed:t}){return{dynamic:!1,encoded:(0,u.cK)(e,{size:32,signed:t})}}(t,{signed:e.type.startsWith("int")});if(e.type.startsWith("bytes"))return function(e,{param:t}){const[,n]=t.type.split("bytes"),r=(0,c.E)(e);if(!n){let t=e;return r%32!=0&&(t=(0,l.db)(t,{dir:"right",size:32*Math.ceil((e.length-2)/2/32)})),{dynamic:!0,encoded:(0,o.xW)([(0,l.db)((0,u.cK)(r,{size:32})),t])}}if(r!==Number.parseInt(n))throw new s.gH({expectedSize:Number.parseInt(n),value:e});return{dynamic:!1,encoded:(0,l.db)(e,{dir:"right"})}}(t,{param:e});if("string"===e.type)return function(e){const t=(0,u.i3)(e),n=Math.ceil((0,c.E)(t)/32),s=[];for(let e=0;e<n;e++)s.push((0,l.db)((0,d.di)(t,32*e,32*(e+1)),{dir:"right"}));return{dynamic:!0,encoded:(0,o.xW)([(0,l.db)((0,u.cK)((0,c.E)(t),{size:32})),...s])}}(t);throw new s.nK(e.type,{docsPath:"/docs/contract/encodeAbiParameters"})}function p(e){let t=0;for(let n=0;n<e.length;n++){const{dynamic:s,encoded:r}=e[n];t+=s?32:(0,c.E)(r)}const n=[],s=[];let r=0;for(let a=0;a<e.length;a++){const{dynamic:i,encoded:o}=e[a];i?(n.push((0,u.cK)(t+r,{size:32})),s.push(o),r+=(0,c.E)(o)):n.push(o)}return(0,o.xW)([...n,...s])}function _(e){const t=e.match(/^(.*)\[(\d+)?\]$/);return t?[t[2]?Number(t[2]):null,t[1]]:void 0}},3608:(e,t,n)=>{n.d(t,{m:()=>o});var s=n(3686),r=n(7673),a=n(2729);const i="/docs/contract/encodeDeployData";function o(e){const{abi:t,args:n,bytecode:o}=e;if(!n||0===n.length)return o;const l=t.find((e=>"type"in e&&"constructor"===e.type));if(!l)throw new s.YW({docsPath:i});if(!("inputs"in l))throw new s.YF({docsPath:i});if(!l.inputs||0===l.inputs.length)throw new s.YF({docsPath:i});const c=(0,a.h)(l.inputs,n);return(0,r.aP)([o,c])}},2373:(e,t,n)=>{n.d(t,{p:()=>d});var s=n(7673),r=n(2729),a=n(3686),i=n(5561),o=n(113),l=n(3856);const c="/docs/contract/encodeFunctionData";function d(e){const{args:t}=e,{abi:n,functionName:d}=1===e.abi.length&&e.functionName?.startsWith("0x")?e:function(e){const{abi:t,args:n,functionName:s}=e;let r=t[0];if(s){const e=(0,l.iY)({abi:t,args:n,name:s});if(!e)throw new a.Iz(s,{docsPath:c});r=e}if("function"!==r.type)throw new a.Iz(void 0,{docsPath:c});return{abi:[r],functionName:(0,i.V)((0,o.B)(r))}}(e),u=n[0],f=d,h="inputs"in u&&u.inputs?(0,r.h)(u.inputs,t??[]):void 0;return(0,s.aP)([f,h??"0x"])}},113:(e,t,n)=>{n.d(t,{A:()=>a,B:()=>r});var s=n(3686);function r(e,{includeName:t=!1}={}){if("function"!==e.type&&"event"!==e.type&&"error"!==e.type)throw new s.d_(e.type);return`${e.name}(${a(e.inputs,{includeName:t})})`}function a(e,{includeName:t=!1}={}){return e?e.map((e=>function(e,{includeName:t}){return e.type.startsWith("tuple")?`(${a(e.components,{includeName:t})})${e.type.slice(5)}`:e.type+(t&&e.name?` ${e.name}`:"")}(e,{includeName:t}))).join(t?", ":","):""}},3856:(e,t,n)=>{n.d(t,{iY:()=>l});var s=n(3686),r=n(2768),a=n(7283),i=n(643),o=n(5561);function l(e){const{abi:t,args:n=[],name:a}=e,l=(0,r.q)(a,{strict:!1}),u=t.filter((e=>l?"function"===e.type?(0,o.V)(e)===a:"event"===e.type&&(0,i.h)(e)===a:"name"in e&&e.name===a));if(0===u.length)return;if(1===u.length)return u[0];let f;for(const e of u){if(!("inputs"in e))continue;if(!n||0===n.length){if(!e.inputs||0===e.inputs.length)return e;continue}if(!e.inputs)continue;if(0===e.inputs.length)continue;if(e.inputs.length!==n.length)continue;const t=n.every(((t,n)=>{const s="inputs"in e&&e.inputs[n];return!!s&&c(t,s)}));if(t){if(f&&"inputs"in f&&f.inputs){const t=d(e.inputs,f.inputs,n);if(t)throw new s.nM({abiItem:e,type:t[0]},{abiItem:f,type:t[1]})}f=e}}return f||u[0]}function c(e,t){const n=typeof e,s=t.type;switch(s){case"address":return(0,a.P)(e,{strict:!1});case"bool":return"boolean"===n;case"function":case"string":return"string"===n;default:return"tuple"===s&&"components"in t?Object.values(t.components).every(((t,n)=>c(Object.values(e)[n],t))):/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(s)?"number"===n||"bigint"===n:/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(s)?"string"===n||e instanceof Uint8Array:!!/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(s)&&Array.isArray(e)&&e.every((e=>c(e,{...t,type:s.replace(/(\[[0-9]{0,}\])$/,"")})))}}function d(e,t,n){for(const s in e){const r=e[s],i=t[s];if("tuple"===r.type&&"tuple"===i.type&&"components"in r&&"components"in i)return d(r.components,i.components,n[s]);const o=[r.type,i.type];if(o.includes("address")&&o.includes("bytes20")||(o.includes("address")&&o.includes("string")||o.includes("address")&&o.includes("bytes"))&&(0,a.P)(n[s],{strict:!1}))return o}}},3887:(e,t,n)=>{n.d(t,{b:()=>d,o:()=>c});var s=n(5372),r=n(3588),a=n(5971),i=n(645),o=n(7283);const l=new i.A(8192);function c(e,t){if(l.has(`${e}.${t}`))return l.get(`${e}.${t}`);const n=t?`${t}${e.toLowerCase()}`:e.substring(2).toLowerCase(),s=(0,a.S)((0,r.Af)(n),"bytes"),i=(t?n.substring(`${t}0x`.length):n).split("");for(let e=0;e<40;e+=2)s[e>>1]>>4>=8&&i[e]&&(i[e]=i[e].toUpperCase()),(15&s[e>>1])>=8&&i[e+1]&&(i[e+1]=i[e+1].toUpperCase());const o=`0x${i.join("")}`;return l.set(`${e}.${t}`,o),o}function d(e,t){if(!(0,o.P)(e,{strict:!1}))throw new s.M({address:e});return c(e,t)}},7283:(e,t,n)=>{n.d(t,{P:()=>o});var s=n(645),r=n(3887);const a=/^0x[a-fA-F0-9]{40}$/,i=new s.A(8192);function o(e,t){const{strict:n=!0}=t??{},s=`${e}.${n}`;if(i.has(s))return i.get(s);const o=!(!a.test(e)||e.toLowerCase()!==e&&n&&(0,r.o)(e)!==e);return i.set(s,o),o}},6907:(e,t,n)=>{n.d(t,{h:()=>a});var s=n(5372),r=n(7283);function a(e,t){if(!(0,r.P)(e,{strict:!1}))throw new s.M({address:e});if(!(0,r.P)(t,{strict:!1}))throw new s.M({address:t});return e.toLowerCase()===t.toLowerCase()}},2987:(e,t,n)=>{n.d(t,{M:()=>r});var s=n(1893);function r({blockNumber:e,chain:t,contract:n}){const r=t?.contracts?.[n];if(!r)throw new s.rj({chain:t,contract:{name:n}});if(e&&r.blockCreated&&r.blockCreated>e)throw new s.rj({blockNumber:e,chain:t,contract:{name:n,blockCreated:r.blockCreated}});return r.address}},9804:(e,t,n)=>{n.d(t,{l:()=>a});var s=n(4112);const r={bytes:new Uint8Array,dataView:new DataView(new ArrayBuffer(0)),position:0,positionReadCount:new Map,recursiveReadCount:0,recursiveReadLimit:Number.POSITIVE_INFINITY,assertReadLimit(){if(this.recursiveReadCount>=this.recursiveReadLimit)throw new s.hX({count:this.recursiveReadCount+1,limit:this.recursiveReadLimit})},assertPosition(e){if(e<0||e>this.bytes.length-1)throw new s.SK({length:this.bytes.length,position:e})},decrementPosition(e){if(e<0)throw new s.B4({offset:e});const t=this.position-e;this.assertPosition(t),this.position=t},getReadCount(e){return this.positionReadCount.get(e||this.position)||0},incrementPosition(e){if(e<0)throw new s.B4({offset:e});const t=this.position+e;this.assertPosition(t),this.position=t},inspectByte(e){const t=e??this.position;return this.assertPosition(t),this.bytes[t]},inspectBytes(e,t){const n=t??this.position;return this.assertPosition(n+e-1),this.bytes.subarray(n,n+e)},inspectUint8(e){const t=e??this.position;return this.assertPosition(t),this.bytes[t]},inspectUint16(e){const t=e??this.position;return this.assertPosition(t+1),this.dataView.getUint16(t)},inspectUint24(e){const t=e??this.position;return this.assertPosition(t+2),(this.dataView.getUint16(t)<<8)+this.dataView.getUint8(t+2)},inspectUint32(e){const t=e??this.position;return this.assertPosition(t+3),this.dataView.getUint32(t)},pushByte(e){this.assertPosition(this.position),this.bytes[this.position]=e,this.position++},pushBytes(e){this.assertPosition(this.position+e.length-1),this.bytes.set(e,this.position),this.position+=e.length},pushUint8(e){this.assertPosition(this.position),this.bytes[this.position]=e,this.position++},pushUint16(e){this.assertPosition(this.position+1),this.dataView.setUint16(this.position,e),this.position+=2},pushUint24(e){this.assertPosition(this.position+2),this.dataView.setUint16(this.position,e>>8),this.dataView.setUint8(this.position+2,255&e),this.position+=3},pushUint32(e){this.assertPosition(this.position+3),this.dataView.setUint32(this.position,e),this.position+=4},readByte(){this.assertReadLimit(),this._touch();const e=this.inspectByte();return this.position++,e},readBytes(e,t){this.assertReadLimit(),this._touch();const n=this.inspectBytes(e);return this.position+=t??e,n},readUint8(){this.assertReadLimit(),this._touch();const e=this.inspectUint8();return this.position+=1,e},readUint16(){this.assertReadLimit(),this._touch();const e=this.inspectUint16();return this.position+=2,e},readUint24(){this.assertReadLimit(),this._touch();const e=this.inspectUint24();return this.position+=3,e},readUint32(){this.assertReadLimit(),this._touch();const e=this.inspectUint32();return this.position+=4,e},get remaining(){return this.bytes.length-this.position},setPosition(e){const t=this.position;return this.assertPosition(e),this.position=e,()=>this.position=t},_touch(){if(this.recursiveReadLimit===Number.POSITIVE_INFINITY)return;const e=this.getReadCount();this.positionReadCount.set(this.position,e+1),e>0&&this.recursiveReadCount++}};function a(e,{recursiveReadLimit:t=8192}={}){const n=Object.create(r);return n.bytes=e,n.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength),n.positionReadCount=new Map,n.recursiveReadLimit=t,n}},7673:(e,t,n)=>{function s(e){return"string"==typeof e[0]?r(e):function(e){let t=0;for(const n of e)t+=n.length;const n=new Uint8Array(t);let s=0;for(const t of e)n.set(t,s),s+=t.length;return n}(e)}function r(e){return`0x${e.reduce(((e,t)=>e+t.replace("0x","")),"")}`}n.d(t,{aP:()=>r,xW:()=>s})},2768:(e,t,n)=>{function s(e,{strict:t=!0}={}){return!!e&&"string"==typeof e&&(t?/^0x[0-9a-fA-F]*$/.test(e):e.startsWith("0x"))}n.d(t,{q:()=>s})},5916:(e,t,n)=>{n.d(t,{db:()=>a,eV:()=>r});var s=n(7834);function r(e,{dir:t,size:n=32}={}){return"string"==typeof e?a(e,{dir:t,size:n}):function(e,{dir:t,size:n=32}={}){if(null===n)return e;if(e.length>n)throw new s.Fl({size:e.length,targetSize:n,type:"bytes"});const r=new Uint8Array(n);for(let s=0;s<n;s++){const a="right"===t;r[a?s:n-s-1]=e[a?s:e.length-s-1]}return r}(e,{dir:t,size:n})}function a(e,{dir:t,size:n=32}={}){if(null===n)return e;const r=e.replace("0x","");if(r.length>2*n)throw new s.Fl({size:Math.ceil(r.length/2),targetSize:n,type:"hex"});return`0x${r["right"===t?"padEnd":"padStart"](2*n,"0")}`}},6420:(e,t,n)=>{n.d(t,{E:()=>r});var s=n(2768);function r(e){return(0,s.q)(e,{strict:!1})?Math.ceil((e.length-2)/2):e.length}},5355:(e,t,n)=>{n.d(t,{A1:()=>c,di:()=>i,iN:()=>d});var s=n(7834),r=n(2768),a=n(6420);function i(e,t,n,{strict:s}={}){return(0,r.q)(e,{strict:!1})?d(e,t,n,{strict:s}):c(e,t,n,{strict:s})}function o(e,t){if("number"==typeof t&&t>0&&t>(0,a.E)(e)-1)throw new s.ii({offset:t,position:"start",size:(0,a.E)(e)})}function l(e,t,n){if("number"==typeof t&&"number"==typeof n&&(0,a.E)(e)!==n-t)throw new s.ii({offset:n,position:"end",size:(0,a.E)(e)})}function c(e,t,n,{strict:s}={}){o(e,t);const r=e.slice(t,n);return s&&l(r,t,n),r}function d(e,t,n,{strict:s}={}){o(e,t);const r=`0x${e.replace("0x","").slice(2*(t??0),2*(n??e.length))}`;return s&&l(r,t,n),r}},1577:(e,t,n)=>{function s(e,{dir:t="left"}={}){let n="string"==typeof e?e.replace("0x",""):e,s=0;for(let e=0;e<n.length-1&&"0"===n["left"===t?e:n.length-e-1].toString();e++)s++;return n="left"===t?n.slice(s):n.slice(0,n.length-s),"string"==typeof e?(1===n.length&&"right"===t&&(n=`${n}0`),`0x${n.length%2==1?`0${n}`:n}`):n}n.d(t,{B:()=>s})},5261:(e,t,n)=>{n.d(t,{ME:()=>o,Sl:()=>a,uU:()=>i});var s=n(9699),r=n(6420);function a(e,{size:t}){if((0,r.E)(e)>t)throw new s.u({givenSize:(0,r.E)(e),maxSize:t})}function i(e,t={}){const{signed:n}=t;t.size&&a(e,{size:t.size});const s=BigInt(e);if(!n)return s;const r=(e.length-2)/2;return s<=(1n<<8n*BigInt(r)-1n)-1n?s:s-BigInt(`0x${"f".padStart(2*r,"f")}`)-1n}function o(e,t={}){return Number(i(e,t))}},3588:(e,t,n)=>{n.d(t,{Af:()=>h,ZJ:()=>c,aT:()=>f});var s=n(9302),r=n(2768),a=n(5916),i=n(5261),o=n(9042);const l=new TextEncoder;function c(e,t={}){return"number"==typeof e||"bigint"==typeof e?function(e,t){return f((0,o.cK)(e,t))}(e,t):"boolean"==typeof e?function(e,t={}){const n=new Uint8Array(1);return n[0]=Number(e),"number"==typeof t.size?((0,i.Sl)(n,{size:t.size}),(0,a.eV)(n,{size:t.size})):n}(e,t):(0,r.q)(e)?f(e,t):h(e,t)}const d={zero:48,nine:57,A:65,F:70,a:97,f:102};function u(e){return e>=d.zero&&e<=d.nine?e-d.zero:e>=d.A&&e<=d.F?e-(d.A-10):e>=d.a&&e<=d.f?e-(d.a-10):void 0}function f(e,t={}){let n=e;t.size&&((0,i.Sl)(n,{size:t.size}),n=(0,a.eV)(n,{dir:"right",size:t.size}));let r=n.slice(2);r.length%2&&(r=`0${r}`);const o=r.length/2,l=new Uint8Array(o);for(let e=0,t=0;e<o;e++){const n=u(r.charCodeAt(t++)),a=u(r.charCodeAt(t++));if(void 0===n||void 0===a)throw new s.C(`Invalid byte sequence ("${r[t-2]}${r[t-1]}" in "${r}").`);l[e]=16*n+a}return l}function h(e,t={}){const n=l.encode(e);return"number"==typeof t.size?((0,i.Sl)(n,{size:t.size}),(0,a.eV)(n,{dir:"right",size:t.size})):n}},9042:(e,t,n)=>{n.d(t,{$P:()=>l,My:()=>c,cK:()=>d,i3:()=>f,nj:()=>o});var s=n(9699),r=n(5916),a=n(5261);const i=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function o(e,t={}){return"number"==typeof e||"bigint"==typeof e?d(e,t):"string"==typeof e?f(e,t):"boolean"==typeof e?l(e,t):c(e,t)}function l(e,t={}){const n=`0x${Number(e)}`;return"number"==typeof t.size?((0,a.Sl)(n,{size:t.size}),(0,r.eV)(n,{size:t.size})):n}function c(e,t={}){let n="";for(let t=0;t<e.length;t++)n+=i[e[t]];const s=`0x${n}`;return"number"==typeof t.size?((0,a.Sl)(s,{size:t.size}),(0,r.eV)(s,{dir:"right",size:t.size})):s}function d(e,t={}){const{signed:n,size:a}=t,i=BigInt(e);let o;a?o=n?(1n<<8n*BigInt(a)-1n)-1n:2n**(8n*BigInt(a))-1n:"number"==typeof e&&(o=BigInt(Number.MAX_SAFE_INTEGER));const l="bigint"==typeof o&&n?-o-1n:0;if(o&&i>o||i<l){const t="bigint"==typeof e?"n":"";throw new s.Ty({max:o?`${o}${t}`:void 0,min:`${l}${t}`,signed:n,size:a,value:`${e}${t}`})}const c=`0x${(n&&i<0?(1n<<BigInt(8*a))+BigInt(i):i).toString(16)}`;return a?(0,r.eV)(c,{size:a}):c}const u=new TextEncoder;function f(e,t={}){return c(u.encode(e),t)}},3594:(e,t,n)=>{n.d(t,{l:()=>a});var s=n(9302),r=n(7426);function a(e,t){const n=(e.details||"").toLowerCase(),a=e instanceof s.C?e.walk((e=>e?.code===r.A7.code)):e;return a instanceof s.C?new r.A7({cause:e,message:a.details}):r.A7.nodeMessage.test(n)?new r.A7({cause:e,message:e.details}):r.BG.nodeMessage.test(n)?new r.BG({cause:e,maxFeePerGas:t?.maxFeePerGas}):r.jj.nodeMessage.test(n)?new r.jj({cause:e,maxFeePerGas:t?.maxFeePerGas}):r.K0.nodeMessage.test(n)?new r.K0({cause:e,nonce:t?.nonce}):r.Oh.nodeMessage.test(n)?new r.Oh({cause:e,nonce:t?.nonce}):r.vW.nodeMessage.test(n)?new r.vW({cause:e,nonce:t?.nonce}):r.k5.nodeMessage.test(n)?new r.k5({cause:e}):r.lY.nodeMessage.test(n)?new r.lY({cause:e,gas:t?.gas}):r.Fo.nodeMessage.test(n)?new r.Fo({cause:e,gas:t?.gas}):r.uC.nodeMessage.test(n)?new r.uC({cause:e}):r.lN.nodeMessage.test(n)?new r.lN({cause:e,maxFeePerGas:t?.maxFeePerGas,maxPriorityFeePerGas:t?.maxPriorityFeePerGas}):new r.RM({cause:e})}},5979:(e,t,n)=>{function s(e,{format:t}){if(!t)return{};const n={};return function t(s){const r=Object.keys(s);for(const a of r)a in e&&(n[a]=e[a]),s[a]&&"object"==typeof s[a]&&!Array.isArray(s[a])&&t(s[a])}(t(e||{})),n}n.d(t,{o:()=>s})},2545:(e,t,n)=>{n.d(t,{Bv:()=>a});var s=n(9042);const r={legacy:"0x0",eip2930:"0x1",eip1559:"0x2",eip4844:"0x3",eip7702:"0x4"};function a(e){const t={};return void 0!==e.authorizationList&&(t.authorizationList=e.authorizationList.map((e=>({address:e.contractAddress,r:e.r,s:e.s,chainId:(0,s.cK)(e.chainId),nonce:(0,s.cK)(e.nonce),...void 0!==e.yParity?{yParity:(0,s.cK)(e.yParity)}:{},...void 0!==e.v&&void 0===e.yParity?{v:(0,s.cK)(e.v)}:{}})))),void 0!==e.accessList&&(t.accessList=e.accessList),void 0!==e.blobVersionedHashes&&(t.blobVersionedHashes=e.blobVersionedHashes),void 0!==e.blobs&&("string"!=typeof e.blobs[0]?t.blobs=e.blobs.map((e=>(0,s.My)(e))):t.blobs=e.blobs),void 0!==e.data&&(t.data=e.data),void 0!==e.from&&(t.from=e.from),void 0!==e.gas&&(t.gas=(0,s.cK)(e.gas)),void 0!==e.gasPrice&&(t.gasPrice=(0,s.cK)(e.gasPrice)),void 0!==e.maxFeePerBlobGas&&(t.maxFeePerBlobGas=(0,s.cK)(e.maxFeePerBlobGas)),void 0!==e.maxFeePerGas&&(t.maxFeePerGas=(0,s.cK)(e.maxFeePerGas)),void 0!==e.maxPriorityFeePerGas&&(t.maxPriorityFeePerGas=(0,s.cK)(e.maxPriorityFeePerGas)),void 0!==e.nonce&&(t.nonce=(0,s.cK)(e.nonce)),void 0!==e.to&&(t.to=e.to),void 0!==e.type&&(t.type=r[e.type]),void 0!==e.value&&(t.value=(0,s.cK)(e.value)),t}},5971:(e,t,n)=>{n.d(t,{S:()=>k});var s=n(6739);const r=BigInt(2**32-1),a=BigInt(32);function i(e,t=!1){return t?{h:Number(e&r),l:Number(e>>a&r)}:{h:0|Number(e>>a&r),l:0|Number(e&r)}}function o(e,t=!1){let n=new Uint32Array(e.length),s=new Uint32Array(e.length);for(let r=0;r<e.length;r++){const{h:a,l:o}=i(e[r],t);[n[r],s[r]]=[a,o]}return[n,s]}var l=n(7049);const c=[],d=[],u=[],f=BigInt(0),h=BigInt(1),p=BigInt(2),_=BigInt(7),m=BigInt(256),g=BigInt(113);for(let e=0,t=h,n=1,s=0;e<24;e++){[n,s]=[s,(2*n+3*s)%5],c.push(2*(5*s+n)),d.push((e+1)*(e+2)/2%64);let r=f;for(let e=0;e<7;e++)t=(t<<h^(t>>_)*g)%m,t&p&&(r^=h<<(h<<BigInt(e))-h);u.push(r)}const[b,y]=o(u,!0),v=(e,t,n)=>n>32?((e,t,n)=>t<<n-32|e>>>64-n)(e,t,n):((e,t,n)=>e<<n|t>>>32-n)(e,t,n),w=(e,t,n)=>n>32?((e,t,n)=>e<<n-32|t>>>64-n)(e,t,n):((e,t,n)=>t<<n|e>>>32-n)(e,t,n);class A extends l.Vw{constructor(e,t,n,r=!1,a=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=n,this.enableXOF=r,this.rounds=a,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,(0,s.ai)(n),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=(0,l.DH)(this.state)}keccak(){l.qv||(0,l.Fc)(this.state32),function(e,t=24){const n=new Uint32Array(10);for(let s=24-t;s<24;s++){for(let t=0;t<10;t++)n[t]=e[t]^e[t+10]^e[t+20]^e[t+30]^e[t+40];for(let t=0;t<10;t+=2){const s=(t+8)%10,r=(t+2)%10,a=n[r],i=n[r+1],o=v(a,i,1)^n[s],l=w(a,i,1)^n[s+1];for(let n=0;n<50;n+=10)e[t+n]^=o,e[t+n+1]^=l}let t=e[2],r=e[3];for(let n=0;n<24;n++){const s=d[n],a=v(t,r,s),i=w(t,r,s),o=c[n];t=e[o],r=e[o+1],e[o]=a,e[o+1]=i}for(let t=0;t<50;t+=10){for(let s=0;s<10;s++)n[s]=e[t+s];for(let s=0;s<10;s++)e[t+s]^=~n[(s+2)%10]&n[(s+4)%10]}e[0]^=b[s],e[1]^=y[s]}n.fill(0)}(this.state32,this.rounds),l.qv||(0,l.Fc)(this.state32),this.posOut=0,this.pos=0}update(e){(0,s.t2)(this);const{blockLen:t,state:n}=this,r=(e=(0,l.ZJ)(e)).length;for(let s=0;s<r;){const a=Math.min(t-this.pos,r-s);for(let t=0;t<a;t++)n[this.pos++]^=e[s++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:n,blockLen:s}=this;e[n]^=t,128&t&&n===s-1&&this.keccak(),e[s-1]^=128,this.keccak()}writeInto(e){(0,s.t2)(this,!1),(0,s.ee)(e),this.finish();const t=this.state,{blockLen:n}=this;for(let s=0,r=e.length;s<r;){this.posOut>=n&&this.keccak();const a=Math.min(n-this.posOut,r-s);e.set(t.subarray(this.posOut,this.posOut+a),s),this.posOut+=a,s+=a}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return(0,s.ai)(e),this.xofInto(new Uint8Array(e))}digestInto(e){if((0,s.CG)(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:n,outputLen:s,rounds:r,enableXOF:a}=this;return e||(e=new A(t,n,s,a,r)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=r,e.suffix=n,e.outputLen=s,e.enableXOF=a,e.destroyed=this.destroyed,e}}const E=((e,t,n)=>(0,l.ld)((()=>new A(t,e,n))))(1,136,32);var x=n(2768),S=n(3588),T=n(9042);function k(e,t){const n=t||"hex",s=E((0,x.q)(e,{strict:!1})?(0,S.ZJ)(e):e);return"bytes"===n?s:(0,T.nj)(s)}},643:(e,t,n)=>{n.d(t,{h:()=>s});const s=n(1754).k},5561:(e,t,n)=>{n.d(t,{V:()=>a});var s=n(5355),r=n(1754);const a=e=>(0,s.di)((0,r.k)(e),0,4)},1754:(e,t,n)=>{n.d(t,{k:()=>f});var s=n(3588),r=n(5971);const a=e=>(0,r.S)((0,s.ZJ)(e));var i=n(9502);const o=/^tuple(?<array>(\[(\d*)\])*)$/;function l(e){let t=e.type;if(o.test(e.type)&&"components"in e){t="(";const n=e.components.length;for(let s=0;s<n;s++)t+=l(e.components[s]),s<n-1&&(t+=", ");const s=(0,i.Yv)(o,e.type);return t+=`)${s?.array??""}`,l({...e,type:t})}return"indexed"in e&&e.indexed&&(t=`${t} indexed`),e.name?`${t} ${e.name}`:t}function c(e){let t="";const n=e.length;for(let s=0;s<n;s++)t+=l(e[s]),s!==n-1&&(t+=", ");return t}var d=n(9302);const u=e=>{var t;return function(e){let t=!0,n="",s=0,r="",a=!1;for(let i=0;i<e.length;i++){const o=e[i];if(["(",")",","].includes(o)&&(t=!0),"("===o&&s++,")"===o&&s--,t)if(0!==s)" "!==o?(r+=o,n+=o):","!==e[i-1]&&","!==n&&",("!==n&&(n="",t=!1);else if(" "===o&&["event","function",""].includes(r))r="";else if(r+=o,")"===o){a=!0;break}}if(!a)throw new d.C("Unable to normalize signature.");return r}("string"==typeof e?e:"function"===(t=e).type?`function ${t.name}(${c(t.inputs)})${t.stateMutability&&"nonpayable"!==t.stateMutability?` ${t.stateMutability}`:""}${t.outputs.length?` returns (${c(t.outputs)})`:""}`:"event"===t.type?`event ${t.name}(${c(t.inputs)})`:"error"===t.type?`error ${t.name}(${c(t.inputs)})`:"constructor"===t.type?`constructor(${c(t.inputs)})${"payable"===t.stateMutability?" payable":""}`:"fallback"===t.type?"fallback()":"receive() external payable")};function f(e){return t=u(e),a(t);var t}},645:(e,t,n)=>{n.d(t,{A:()=>s});class s extends Map{constructor(e){super(),Object.defineProperty(this,"maxSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxSize=e}get(e){const t=super.get(e);return super.has(e)&&void 0!==t&&(this.delete(e),super.set(e,t)),t}set(e,t){if(super.set(e,t),this.maxSize&&this.size>this.maxSize){const e=this.keys().next().value;e&&this.delete(e)}return this}}},3513:(e,t,n)=>{n.d(t,{u:()=>r});const s=new Map;function r({fn:e,id:t,shouldSplitBatch:n,wait:r=0,sort:a}){const i=async()=>{const t=l();o();const n=t.map((({args:e})=>e));0!==n.length&&e(n).then((e=>{a&&Array.isArray(e)&&e.sort(a);for(let n=0;n<t.length;n++){const{pendingPromise:s}=t[n];s.resolve?.([e[n],e])}})).catch((e=>{for(let n=0;n<t.length;n++){const{pendingPromise:s}=t[n];s.reject?.(e)}}))},o=()=>s.delete(t),l=()=>s.get(t)||[],c=e=>s.set(t,[...l(),e]);return{flush:o,async schedule(e){const t={},s=new Promise(((e,n)=>{t.resolve=e,t.reject=n})),a=n?.([...l().map((({args:e})=>e)),e]);return a&&i(),l().length>0?(c({args:e,pendingPromise:t}),s):(c({args:e,pendingPromise:t}),setTimeout(i,r),s)}}}},6409:(e,t,n)=>{n.d(t,{yH:()=>d});var s=n(5372),r=n(7834),a=n(373),i=n(7283),o=n(9042);function l(e){if(e&&0!==e.length)return e.reduce(((e,{slot:t,value:n})=>{if(66!==t.length)throw new r.NV({size:t.length,targetSize:66,type:"hex"});if(66!==n.length)throw new r.NV({size:n.length,targetSize:66,type:"hex"});return e[t]=n,e}),{})}function c(e){const{balance:t,nonce:n,state:s,stateDiff:r,code:i}=e,c={};if(void 0!==i&&(c.code=i),void 0!==t&&(c.balance=(0,o.cK)(t)),void 0!==n&&(c.nonce=(0,o.cK)(n)),void 0!==s&&(c.state=l(s)),void 0!==r){if(c.state)throw new a.ft;c.stateDiff=l(r)}return c}function d(e){if(!e)return;const t={};for(const{address:n,...r}of e){if(!(0,i.P)(n,{strict:!1}))throw new s.M({address:n});if(t[n])throw new a.Hi({address:n});t[n]=c(r)}return t}},1501:(e,t,n)=>{n.d(t,{A:()=>s});const s=(e,t,n)=>JSON.stringify(e,((e,n)=>{const s="bigint"==typeof n?n.toString():n;return"function"==typeof t?t(e,s):s}),n)},7338:(e,t,n)=>{n.d(t,{c:()=>c});var s=n(6027);const r=2n**256n-1n;var a=n(5372),i=n(7426),o=n(7740),l=n(7283);function c(e){const{account:t,gasPrice:n,maxFeePerGas:c,maxPriorityFeePerGas:d,to:u}=e,f=t?(0,s.J)(t):void 0;if(f&&!(0,l.P)(f.address))throw new a.M({address:f.address});if(u&&!(0,l.P)(u))throw new a.M({address:u});if(void 0!==n&&(void 0!==c||void 0!==d))throw new o.n3;if(c&&c>r)throw new i.BG({maxFeePerGas:c});if(d&&c&&d>c)throw new i.lN({maxFeePerGas:c,maxPriorityFeePerGas:d})}},3538:(e,t,n)=>{n.d(t,{c:()=>a});var s=n(6956),r=n(6473);function a(e,t="wei"){return(0,r.J)(e,s.eL[t])}},1892:(e,t,n)=>{n.d(t,{Q:()=>a});var s=n(6956),r=n(6473);function a(e,t="wei"){return(0,r.J)(e,s.sz[t])}},6473:(e,t,n)=>{function s(e,t){let n=e.toString();const s=n.startsWith("-");s&&(n=n.slice(1)),n=n.padStart(t,"0");let[r,a]=[n.slice(0,n.length-t),n.slice(n.length-t)];return a=a.replace(/(0+)$/,""),`${s?"-":""}${r||"0"}${a?`.${a}`:""}`}n.d(t,{J:()=>s})},4144:(e,t,n)=>{n.d(t,{DO:()=>i,Id:()=>b,My:()=>l,OG:()=>v,Ph:()=>h,Q5:()=>S,aT:()=>f,aY:()=>a,ex:()=>y,fg:()=>E,lX:()=>p,lq:()=>_,qj:()=>g,z:()=>m}),BigInt(0);const s=BigInt(1),r=BigInt(2);function a(e){return e instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name}function i(e){if(!a(e))throw new Error("Uint8Array expected")}const o=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function l(e){i(e);let t="";for(let n=0;n<e.length;n++)t+=o[e[n]];return t}function c(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);return BigInt(""===e?"0":`0x${e}`)}const d={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function u(e){return e>=d._0&&e<=d._9?e-d._0:e>=d._A&&e<=d._F?e-(d._A-10):e>=d._a&&e<=d._f?e-(d._a-10):void 0}function f(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);const t=e.length,n=t/2;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const s=new Uint8Array(n);for(let t=0,r=0;t<n;t++,r+=2){const n=u(e.charCodeAt(r)),a=u(e.charCodeAt(r+1));if(void 0===n||void 0===a){const t=e[r]+e[r+1];throw new Error('hex string expected, got non-hex character "'+t+'" at index '+r)}s[t]=16*n+a}return s}function h(e){return c(l(e))}function p(e){return i(e),c(l(Uint8Array.from(e).reverse()))}function _(e,t){return f(e.toString(16).padStart(2*t,"0"))}function m(e,t){return _(e,t).reverse()}function g(e,t,n){let s;if("string"==typeof t)try{s=f(t)}catch(n){throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${n}`)}else{if(!a(t))throw new Error(`${e} must be hex string or Uint8Array`);s=Uint8Array.from(t)}const r=s.length;if("number"==typeof n&&r!==n)throw new Error(`${e} expected ${n} bytes, got ${r}`);return s}function b(...e){let t=0;for(let n=0;n<e.length;n++){const s=e[n];i(s),t+=s.length}const n=new Uint8Array(t);for(let t=0,s=0;t<e.length;t++){const r=e[t];n.set(r,s),s+=r.length}return n}function y(e,t){if(e.length!==t.length)return!1;let n=0;for(let s=0;s<e.length;s++)n|=e[s]^t[s];return 0===n}const v=e=>(r<<BigInt(e-1))-s,w=e=>new Uint8Array(e),A=e=>Uint8Array.from(e);function E(e,t,n){if("number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof t||t<2)throw new Error("qByteLen must be a number");if("function"!=typeof n)throw new Error("hmacFn must be a function");let s=w(e),r=w(e),a=0;const i=()=>{s.fill(1),r.fill(0),a=0},o=(...e)=>n(r,s,...e),l=(e=w())=>{r=o(A([0]),e),s=o(),0!==e.length&&(r=o(A([1]),e),s=o())},c=()=>{if(a++>=1e3)throw new Error("drbg: tried 1000 values");let e=0;const n=[];for(;e<t;){s=o();const t=s.slice();n.push(t),e+=s.length}return b(...n)};return(e,t)=>{let n;for(i(),l(e);!(n=t(c()));)l();return i(),n}}const x={bigint:e=>"bigint"==typeof e,function:e=>"function"==typeof e,boolean:e=>"boolean"==typeof e,string:e=>"string"==typeof e,stringOrUint8Array:e=>"string"==typeof e||a(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>"function"==typeof e&&Number.isSafeInteger(e.outputLen)};function S(e,t,n={}){const s=(t,n,s)=>{const r=x[n];if("function"!=typeof r)throw new Error(`Invalid validator "${n}", expected function`);const a=e[t];if(!(s&&void 0===a||r(a,e)))throw new Error(`Invalid param ${String(t)}=${a} (${typeof a}), expected ${n}`)};for(const[e,n]of Object.entries(t))s(e,n,!1);for(const[e,t]of Object.entries(n))s(e,t,!0);return e}},7550:(e,t,n)=>{n.d(t,{secp256k1:()=>H});var s=n(1805),r=n(4144);const a=BigInt(0),i=BigInt(1),o=BigInt(2),l=BigInt(3),c=BigInt(4),d=BigInt(5),u=BigInt(8);function f(e,t){const n=e%t;return n>=a?n:t+n}function h(e,t,n){if(n<=a||t<a)throw new Error("Expected power/modulo > 0");if(n===i)return a;let s=i;for(;t>a;)t&i&&(s=s*e%n),e=e*e%n,t>>=i;return s}function p(e,t,n){let s=e;for(;t-- >a;)s*=s,s%=n;return s}function _(e,t){if(e===a||t<=a)throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);let n=f(e,t),s=t,r=a,o=i,l=i,c=a;for(;n!==a;){const e=s/n,t=s%n,a=r-l*e,i=o-c*e;s=n,n=t,r=l,o=c,l=a,c=i}if(s!==i)throw new Error("invert: does not exist");return f(r,t)}BigInt(9),BigInt(16);const m=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function g(e,t){const n=void 0!==t?t:e.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function b(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function y(e){const t=b(e);return t+Math.ceil(t/2)}var v=n(6739),w=n(7049);class A extends w.Vw{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,(0,v.tW)(e);const n=(0,w.ZJ)(t);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,r=new Uint8Array(s);r.set(n.length>s?e.create().update(n).digest():n);for(let e=0;e<r.length;e++)r[e]^=54;this.iHash.update(r),this.oHash=e.create();for(let e=0;e<r.length;e++)r[e]^=106;this.oHash.update(r),r.fill(0)}update(e){return(0,v.t2)(this),this.iHash.update(e),this}digestInto(e){(0,v.t2)(this),(0,v.ee)(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:s,destroyed:r,blockLen:a,outputLen:i}=this;return e.finished=s,e.destroyed=r,e.blockLen=a,e.outputLen=i,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const E=(e,t,n)=>new A(e,t).update(n).digest();E.create=(e,t)=>new A(e,t);const x=BigInt(0),S=BigInt(1);function T(e){return function(e){const t=m.reduce(((e,t)=>(e[t]="function",e)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"});(0,r.Q5)(e,t)}(e.Fp),(0,r.Q5)(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...g(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}const{Ph:k,aT:C}=r,z={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(e){const{Err:t}=z;if(e.length<2||2!==e[0])throw new t("Invalid signature integer tag");const n=e[1],s=e.subarray(2,n+2);if(!n||s.length!==n)throw new t("Invalid signature integer: wrong length");if(128&s[0])throw new t("Invalid signature integer: negative");if(0===s[0]&&!(128&s[1]))throw new t("Invalid signature integer: unnecessary leading zero");return{d:k(s),l:e.subarray(n+2)}},toSig(e){const{Err:t}=z,n="string"==typeof e?C(e):e;r.DO(n);let s=n.length;if(s<2||48!=n[0])throw new t("Invalid signature tag");if(n[1]!==s-2)throw new t("Invalid signature: incorrect length");const{d:a,l:i}=z._parseInt(n.subarray(2)),{d:o,l}=z._parseInt(i);if(l.length)throw new t("Invalid signature: left bytes after parsing");return{r:a,s:o}},hexFromSig(e){const t=e=>8&Number.parseInt(e[0],16)?"00"+e:e,n=e=>{const t=e.toString(16);return 1&t.length?`0${t}`:t},s=t(n(e.s)),r=t(n(e.r)),a=s.length/2,i=r.length/2,o=n(a),l=n(i);return`30${n(i+a+4)}02${l}${r}02${o}${s}`}},P=BigInt(0),F=BigInt(1),N=(BigInt(2),BigInt(3));function G(e){const t=function(e){const t=T(e);return r.Q5(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}(e),{Fp:n,n:s}=t,a=n.BYTES+1,o=2*n.BYTES+1;function l(e){return f(e,s)}function c(e){return _(e,s)}const{ProjectivePoint:d,normPrivateKeyToScalar:u,weierstrassEquation:h,isWithinCurveOrder:p}=function(e){const t=function(e){const t=T(e);r.Q5(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:s,a}=t;if(n){if(!s.eql(a,s.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof n||"bigint"!=typeof n.beta||"function"!=typeof n.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}(e),{Fp:n}=t,s=t.toBytes||((e,t,s)=>{const a=t.toAffine();return r.Id(Uint8Array.from([4]),n.toBytes(a.x),n.toBytes(a.y))}),a=t.fromBytes||(e=>{const t=e.subarray(1);return{x:n.fromBytes(t.subarray(0,n.BYTES)),y:n.fromBytes(t.subarray(n.BYTES,2*n.BYTES))}});function i(e){const{a:s,b:r}=t,a=n.sqr(e),i=n.mul(a,e);return n.add(n.add(i,n.mul(e,s)),r)}if(!n.eql(n.sqr(t.Gy),i(t.Gx)))throw new Error("bad generator point: equation left != right");function o(e){return"bigint"==typeof e&&P<e&&e<t.n}function l(e){if(!o(e))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(e){const{allowedPrivateKeyLengths:n,nByteLength:s,wrapPrivateKey:a,n:i}=t;if(n&&"bigint"!=typeof e){if(r.aY(e)&&(e=r.My(e)),"string"!=typeof e||!n.includes(e.length))throw new Error("Invalid key");e=e.padStart(2*s,"0")}let o;try{o="bigint"==typeof e?e:r.Ph((0,r.qj)("private key",e,s))}catch(t){throw new Error(`private key must be ${s} bytes, hex or bigint, not ${typeof e}`)}return a&&(o=f(o,i)),l(o),o}const d=new Map;function u(e){if(!(e instanceof h))throw new Error("ProjectivePoint expected")}class h{constructor(e,t,s){if(this.px=e,this.py=t,this.pz=s,null==e||!n.isValid(e))throw new Error("x required");if(null==t||!n.isValid(t))throw new Error("y required");if(null==s||!n.isValid(s))throw new Error("z required")}static fromAffine(e){const{x:t,y:s}=e||{};if(!e||!n.isValid(t)||!n.isValid(s))throw new Error("invalid affine point");if(e instanceof h)throw new Error("projective point not allowed");const r=e=>n.eql(e,n.ZERO);return r(t)&&r(s)?h.ZERO:new h(t,s,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(e){const t=n.invertBatch(e.map((e=>e.pz)));return e.map(((e,n)=>e.toAffine(t[n]))).map(h.fromAffine)}static fromHex(e){const t=h.fromAffine(a((0,r.qj)("pointHex",e)));return t.assertValidity(),t}static fromPrivateKey(e){return h.BASE.multiply(c(e))}_setWindowSize(e){this._WINDOW_SIZE=e,d.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:e,y:s}=this.toAffine();if(!n.isValid(e)||!n.isValid(s))throw new Error("bad point: x or y not FE");const r=n.sqr(s),a=i(e);if(!n.eql(r,a))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:e}=this.toAffine();if(n.isOdd)return!n.isOdd(e);throw new Error("Field doesn't support isOdd")}equals(e){u(e);const{px:t,py:s,pz:r}=this,{px:a,py:i,pz:o}=e,l=n.eql(n.mul(t,o),n.mul(a,r)),c=n.eql(n.mul(s,o),n.mul(i,r));return l&&c}negate(){return new h(this.px,n.neg(this.py),this.pz)}double(){const{a:e,b:s}=t,r=n.mul(s,N),{px:a,py:i,pz:o}=this;let l=n.ZERO,c=n.ZERO,d=n.ZERO,u=n.mul(a,a),f=n.mul(i,i),p=n.mul(o,o),_=n.mul(a,i);return _=n.add(_,_),d=n.mul(a,o),d=n.add(d,d),l=n.mul(e,d),c=n.mul(r,p),c=n.add(l,c),l=n.sub(f,c),c=n.add(f,c),c=n.mul(l,c),l=n.mul(_,l),d=n.mul(r,d),p=n.mul(e,p),_=n.sub(u,p),_=n.mul(e,_),_=n.add(_,d),d=n.add(u,u),u=n.add(d,u),u=n.add(u,p),u=n.mul(u,_),c=n.add(c,u),p=n.mul(i,o),p=n.add(p,p),u=n.mul(p,_),l=n.sub(l,u),d=n.mul(p,f),d=n.add(d,d),d=n.add(d,d),new h(l,c,d)}add(e){u(e);const{px:s,py:r,pz:a}=this,{px:i,py:o,pz:l}=e;let c=n.ZERO,d=n.ZERO,f=n.ZERO;const p=t.a,_=n.mul(t.b,N);let m=n.mul(s,i),g=n.mul(r,o),b=n.mul(a,l),y=n.add(s,r),v=n.add(i,o);y=n.mul(y,v),v=n.add(m,g),y=n.sub(y,v),v=n.add(s,a);let w=n.add(i,l);return v=n.mul(v,w),w=n.add(m,b),v=n.sub(v,w),w=n.add(r,a),c=n.add(o,l),w=n.mul(w,c),c=n.add(g,b),w=n.sub(w,c),f=n.mul(p,v),c=n.mul(_,b),f=n.add(c,f),c=n.sub(g,f),f=n.add(g,f),d=n.mul(c,f),g=n.add(m,m),g=n.add(g,m),b=n.mul(p,b),v=n.mul(_,v),g=n.add(g,b),b=n.sub(m,b),b=n.mul(p,b),v=n.add(v,b),m=n.mul(g,v),d=n.add(d,m),m=n.mul(w,v),c=n.mul(y,c),c=n.sub(c,m),m=n.mul(y,g),f=n.mul(w,f),f=n.add(f,m),new h(c,d,f)}subtract(e){return this.add(e.negate())}is0(){return this.equals(h.ZERO)}wNAF(e){return _.wNAFCached(this,d,e,(e=>{const t=n.invertBatch(e.map((e=>e.pz)));return e.map(((e,n)=>e.toAffine(t[n]))).map(h.fromAffine)}))}multiplyUnsafe(e){const s=h.ZERO;if(e===P)return s;if(l(e),e===F)return this;const{endo:r}=t;if(!r)return _.unsafeLadder(this,e);let{k1neg:a,k1:i,k2neg:o,k2:c}=r.splitScalar(e),d=s,u=s,f=this;for(;i>P||c>P;)i&F&&(d=d.add(f)),c&F&&(u=u.add(f)),f=f.double(),i>>=F,c>>=F;return a&&(d=d.negate()),o&&(u=u.negate()),u=new h(n.mul(u.px,r.beta),u.py,u.pz),d.add(u)}multiply(e){l(e);let s,r,a=e;const{endo:i}=t;if(i){const{k1neg:e,k1:t,k2neg:o,k2:l}=i.splitScalar(a);let{p:c,f:d}=this.wNAF(t),{p:u,f}=this.wNAF(l);c=_.constTimeNegate(e,c),u=_.constTimeNegate(o,u),u=new h(n.mul(u.px,i.beta),u.py,u.pz),s=c.add(u),r=d.add(f)}else{const{p:e,f:t}=this.wNAF(a);s=e,r=t}return h.normalizeZ([s,r])[0]}multiplyAndAddUnsafe(e,t,n){const s=h.BASE,r=(e,t)=>t!==P&&t!==F&&e.equals(s)?e.multiply(t):e.multiplyUnsafe(t),a=r(this,t).add(r(e,n));return a.is0()?void 0:a}toAffine(e){const{px:t,py:s,pz:r}=this,a=this.is0();null==e&&(e=a?n.ONE:n.inv(r));const i=n.mul(t,e),o=n.mul(s,e),l=n.mul(r,e);if(a)return{x:n.ZERO,y:n.ZERO};if(!n.eql(l,n.ONE))throw new Error("invZ was invalid");return{x:i,y:o}}isTorsionFree(){const{h:e,isTorsionFree:n}=t;if(e===F)return!0;if(n)return n(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:e,clearCofactor:n}=t;return e===F?this:n?n(h,this):this.multiplyUnsafe(t.h)}toRawBytes(e=!0){return this.assertValidity(),s(h,this,e)}toHex(e=!0){return r.My(this.toRawBytes(e))}}h.BASE=new h(t.Gx,t.Gy,n.ONE),h.ZERO=new h(n.ZERO,n.ONE,n.ZERO);const p=t.nBitLength,_=function(e,t){const n=(e,t)=>{const n=t.negate();return e?n:t},s=e=>({windows:Math.ceil(t/e)+1,windowSize:2**(e-1)});return{constTimeNegate:n,unsafeLadder(t,n){let s=e.ZERO,r=t;for(;n>x;)n&S&&(s=s.add(r)),r=r.double(),n>>=S;return s},precomputeWindow(e,t){const{windows:n,windowSize:r}=s(t),a=[];let i=e,o=i;for(let e=0;e<n;e++){o=i,a.push(o);for(let e=1;e<r;e++)o=o.add(i),a.push(o);i=o.double()}return a},wNAF(t,r,a){const{windows:i,windowSize:o}=s(t);let l=e.ZERO,c=e.BASE;const d=BigInt(2**t-1),u=2**t,f=BigInt(t);for(let e=0;e<i;e++){const t=e*o;let s=Number(a&d);a>>=f,s>o&&(s-=u,a+=S);const i=t,h=t+Math.abs(s)-1,p=e%2!=0,_=s<0;0===s?c=c.add(n(p,r[i])):l=l.add(n(_,r[h]))}return{p:l,f:c}},wNAFCached(e,t,n,s){const r=e._WINDOW_SIZE||1;let a=t.get(e);return a||(a=this.precomputeWindow(e,r),1!==r&&t.set(e,s(a))),this.wNAF(r,a,n)}}}(h,t.endo?Math.ceil(p/2):p);return{CURVE:t,ProjectivePoint:h,normPrivateKeyToScalar:c,weierstrassEquation:i,isWithinCurveOrder:o}}({...t,toBytes(e,t,s){const a=t.toAffine(),i=n.toBytes(a.x),o=r.Id;return s?o(Uint8Array.from([t.hasEvenY()?2:3]),i):o(Uint8Array.from([4]),i,n.toBytes(a.y))},fromBytes(e){const t=e.length,s=e[0],i=e.subarray(1);if(t!==a||2!==s&&3!==s){if(t===o&&4===s)return{x:n.fromBytes(i.subarray(0,n.BYTES)),y:n.fromBytes(i.subarray(n.BYTES,2*n.BYTES))};throw new Error(`Point of length ${t} was invalid. Expected ${a} compressed bytes or ${o} uncompressed bytes`)}{const e=r.Ph(i);if(!(P<(l=e)&&l<n.ORDER))throw new Error("Point is not on curve");const t=h(e);let a;try{a=n.sqrt(t)}catch(e){const t=e instanceof Error?": "+e.message:"";throw new Error("Point is not on curve"+t)}return!(1&~s)!=((a&F)===F)&&(a=n.neg(a)),{x:e,y:a}}var l}}),m=e=>r.My(r.lq(e,t.nByteLength));function g(e){return e>s>>F}const v=(e,t,n)=>r.Ph(e.slice(t,n));class w{constructor(e,t,n){this.r=e,this.s=t,this.recovery=n,this.assertValidity()}static fromCompact(e){const n=t.nByteLength;return e=(0,r.qj)("compactSignature",e,2*n),new w(v(e,0,n),v(e,n,2*n))}static fromDER(e){const{r:t,s:n}=z.toSig((0,r.qj)("DER",e));return new w(t,n)}assertValidity(){if(!p(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!p(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(e){return new w(this.r,this.s,e)}recoverPublicKey(e){const{r:s,s:a,recovery:i}=this,o=C((0,r.qj)("msgHash",e));if(null==i||![0,1,2,3].includes(i))throw new Error("recovery id invalid");const u=2===i||3===i?s+t.n:s;if(u>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const f=1&i?"03":"02",h=d.fromHex(f+m(u)),p=c(u),_=l(-o*p),g=l(a*p),b=d.BASE.multiplyAndAddUnsafe(h,_,g);if(!b)throw new Error("point at infinify");return b.assertValidity(),b}hasHighS(){return g(this.s)}normalizeS(){return this.hasHighS()?new w(this.r,l(-this.s),this.recovery):this}toDERRawBytes(){return r.aT(this.toDERHex())}toDERHex(){return z.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return r.aT(this.toCompactHex())}toCompactHex(){return m(this.r)+m(this.s)}}const A={isValidPrivateKey(e){try{return u(e),!0}catch(e){return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const e=y(t.n);return function(e,t,n=!1){const s=e.length,a=b(t),o=y(t);if(s<16||s<o||s>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${s}`);const l=f(n?(0,r.Ph)(e):(0,r.lX)(e),t-i)+i;return n?(0,r.z)(l,a):(0,r.lq)(l,a)}(t.randomBytes(e),t.n)},precompute:(e=8,t=d.BASE)=>(t._setWindowSize(e),t.multiply(BigInt(3)),t)};function E(e){const t=r.aY(e),n="string"==typeof e,s=(t||n)&&e.length;return t?s===a||s===o:n?s===2*a||s===2*o:e instanceof d}const k=t.bits2int||function(e){const n=r.Ph(e),s=8*e.length-t.nBitLength;return s>0?n>>BigInt(s):n},C=t.bits2int_modN||function(e){return l(k(e))},G=r.OG(t.nBitLength);function L(e){if("bigint"!=typeof e)throw new Error("bigint expected");if(!(P<=e&&e<G))throw new Error(`bigint expected < 2^${t.nBitLength}`);return r.lq(e,t.nByteLength)}const O={lowS:t.lowS,prehash:!1},R={lowS:t.lowS,prehash:!1};return d.BASE._setWindowSize(8),{CURVE:t,getPublicKey:function(e,t=!0){return d.fromPrivateKey(e).toRawBytes(t)},getSharedSecret:function(e,t,n=!0){if(E(e))throw new Error("first arg must be private key");if(!E(t))throw new Error("second arg must be public key");return d.fromHex(t).multiply(u(e)).toRawBytes(n)},sign:function(e,s,a=O){const{seed:i,k2sig:o}=function(e,s,a=O){if(["recovered","canonical"].some((e=>e in a)))throw new Error("sign() legacy options not supported");const{hash:i,randomBytes:o}=t;let{lowS:f,prehash:h,extraEntropy:_}=a;null==f&&(f=!0),e=(0,r.qj)("msgHash",e),h&&(e=(0,r.qj)("prehashed msgHash",i(e)));const m=C(e),b=u(s),y=[L(b),L(m)];if(null!=_&&!1!==_){const e=!0===_?o(n.BYTES):_;y.push((0,r.qj)("extraEntropy",e))}const v=r.Id(...y),A=m;return{seed:v,k2sig:function(e){const t=k(e);if(!p(t))return;const n=c(t),s=d.BASE.multiply(t).toAffine(),r=l(s.x);if(r===P)return;const a=l(n*l(A+r*b));if(a===P)return;let i=(s.x===r?0:2)|Number(s.y&F),o=a;return f&&g(a)&&(o=function(e){return g(e)?l(-e):e}(a),i^=1),new w(r,o,i)}}}(e,s,a),f=t;return r.fg(f.hash.outputLen,f.nByteLength,f.hmac)(i,o)},verify:function(e,n,s,a=R){const i=e;if(n=(0,r.qj)("msgHash",n),s=(0,r.qj)("publicKey",s),"strict"in a)throw new Error("options.strict was renamed to lowS");const{lowS:o,prehash:u}=a;let f,h;try{if("string"==typeof i||r.aY(i))try{f=w.fromDER(i)}catch(e){if(!(e instanceof z.Err))throw e;f=w.fromCompact(i)}else{if("object"!=typeof i||"bigint"!=typeof i.r||"bigint"!=typeof i.s)throw new Error("PARSE");{const{r:e,s:t}=i;f=new w(e,t)}}h=d.fromHex(s)}catch(e){if("PARSE"===e.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(o&&f.hasHighS())return!1;u&&(n=t.hash(n));const{r:p,s:_}=f,m=C(n),g=c(_),b=l(m*g),y=l(p*g),v=d.BASE.multiplyAndAddUnsafe(h,b,y)?.toAffine();return!!v&&l(v.x)===p},ProjectivePoint:d,Signature:w,utils:A}}function L(e){return{hash:e,hmac:(t,...n)=>E(e,t,(0,w.Id)(...n)),randomBytes:w.po}}BigInt(4);const O=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),R=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),M=BigInt(1),B=BigInt(2),Y=(e,t)=>(e+t/B)/t;const j=function(e,t,n=!1,s={}){if(e<=a)throw new Error(`Expected Field ORDER > 0, got ${e}`);const{nBitLength:p,nByteLength:m}=g(e,t);if(m>2048)throw new Error("Field lengths over 2048 bytes are not supported");const b=function(e){if(e%c===l){const t=(e+i)/c;return function(e,n){const s=e.pow(n,t);if(!e.eql(e.sqr(s),n))throw new Error("Cannot find square root");return s}}if(e%u===d){const t=(e-d)/u;return function(e,n){const s=e.mul(n,o),r=e.pow(s,t),a=e.mul(n,r),i=e.mul(e.mul(a,o),r),l=e.mul(a,e.sub(i,e.ONE));if(!e.eql(e.sqr(l),n))throw new Error("Cannot find square root");return l}}return function(e){const t=(e-i)/o;let n,s,r;for(n=e-i,s=0;n%o===a;n/=o,s++);for(r=o;r<e&&h(r,t,e)!==e-i;r++);if(1===s){const t=(e+i)/c;return function(e,n){const s=e.pow(n,t);if(!e.eql(e.sqr(s),n))throw new Error("Cannot find square root");return s}}const l=(n+i)/o;return function(e,a){if(e.pow(a,t)===e.neg(e.ONE))throw new Error("Cannot find square root");let o=s,c=e.pow(e.mul(e.ONE,r),n),d=e.pow(a,l),u=e.pow(a,n);for(;!e.eql(u,e.ONE);){if(e.eql(u,e.ZERO))return e.ZERO;let t=1;for(let n=e.sqr(u);t<o&&!e.eql(n,e.ONE);t++)n=e.sqr(n);const n=e.pow(c,i<<BigInt(o-t-1));c=e.sqr(n),d=e.mul(d,n),u=e.mul(u,c),o=t}return d}}(e)}(e),y=Object.freeze({ORDER:e,BITS:p,BYTES:m,MASK:(0,r.OG)(p),ZERO:a,ONE:i,create:t=>f(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("Invalid field element: expected bigint, got "+typeof t);return a<=t&&t<e},is0:e=>e===a,isOdd:e=>(e&i)===i,neg:t=>f(-t,e),eql:(e,t)=>e===t,sqr:t=>f(t*t,e),add:(t,n)=>f(t+n,e),sub:(t,n)=>f(t-n,e),mul:(t,n)=>f(t*n,e),pow:(e,t)=>function(e,t,n){if(n<a)throw new Error("Expected power > 0");if(n===a)return e.ONE;if(n===i)return t;let s=e.ONE,r=t;for(;n>a;)n&i&&(s=e.mul(s,r)),r=e.sqr(r),n>>=i;return s}(y,e,t),div:(t,n)=>f(t*_(n,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>_(t,e),sqrt:s.sqrt||(e=>b(y,e)),invertBatch:e=>function(e,t){const n=new Array(t.length),s=t.reduce(((t,s,r)=>e.is0(s)?t:(n[r]=t,e.mul(t,s))),e.ONE),r=e.inv(s);return t.reduceRight(((t,s,r)=>e.is0(s)?t:(n[r]=e.mul(t,n[r]),e.mul(t,s))),r),n}(y,e),cmov:(e,t,n)=>n?t:e,toBytes:e=>n?(0,r.z)(e,m):(0,r.lq)(e,m),fromBytes:e=>{if(e.length!==m)throw new Error(`Fp.fromBytes: expected ${m}, got ${e.length}`);return n?(0,r.lX)(e):(0,r.Ph)(e)}});return Object.freeze(y)}(O,void 0,void 0,{sqrt:function(e){const t=O,n=BigInt(3),s=BigInt(6),r=BigInt(11),a=BigInt(22),i=BigInt(23),o=BigInt(44),l=BigInt(88),c=e*e*e%t,d=c*c*e%t,u=p(d,n,t)*d%t,f=p(u,n,t)*d%t,h=p(f,B,t)*c%t,_=p(h,r,t)*h%t,m=p(_,a,t)*_%t,g=p(m,o,t)*m%t,b=p(g,l,t)*g%t,y=p(b,o,t)*m%t,v=p(y,n,t)*d%t,w=p(v,i,t)*_%t,A=p(w,s,t)*c%t,E=p(A,B,t);if(!j.eql(j.sqr(E),e))throw new Error("Cannot find square root");return E}}),H=function(e,t){const n=t=>G({...e,...L(t)});return Object.freeze({...n(t),create:n})}({a:BigInt(0),b:BigInt(7),Fp:j,n:R,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=R,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),s=-M*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),r=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),a=n,i=BigInt("0x100000000000000000000000000000000"),o=Y(a*e,t),l=Y(-s*e,t);let c=f(e-o*n-l*r,t),d=f(-o*s-l*a,t);const u=c>i,h=d>i;if(u&&(c=t-c),h&&(d=t-d),c>i||d>i)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:u,k1:c,k2neg:h,k2:d}}}},s.s);BigInt(0),H.ProjectivePoint},9543:e=>{e.exports=JSON.parse('{"aes-128-ecb":{"cipher":"AES","key":128,"iv":0,"mode":"ECB","type":"block"},"aes-192-ecb":{"cipher":"AES","key":192,"iv":0,"mode":"ECB","type":"block"},"aes-256-ecb":{"cipher":"AES","key":256,"iv":0,"mode":"ECB","type":"block"},"aes-128-cbc":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes-192-cbc":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes-256-cbc":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes128":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes192":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes256":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes-128-cfb":{"cipher":"AES","key":128,"iv":16,"mode":"CFB","type":"stream"},"aes-192-cfb":{"cipher":"AES","key":192,"iv":16,"mode":"CFB","type":"stream"},"aes-256-cfb":{"cipher":"AES","key":256,"iv":16,"mode":"CFB","type":"stream"},"aes-128-cfb8":{"cipher":"AES","key":128,"iv":16,"mode":"CFB8","type":"stream"},"aes-192-cfb8":{"cipher":"AES","key":192,"iv":16,"mode":"CFB8","type":"stream"},"aes-256-cfb8":{"cipher":"AES","key":256,"iv":16,"mode":"CFB8","type":"stream"},"aes-128-cfb1":{"cipher":"AES","key":128,"iv":16,"mode":"CFB1","type":"stream"},"aes-192-cfb1":{"cipher":"AES","key":192,"iv":16,"mode":"CFB1","type":"stream"},"aes-256-cfb1":{"cipher":"AES","key":256,"iv":16,"mode":"CFB1","type":"stream"},"aes-128-ofb":{"cipher":"AES","key":128,"iv":16,"mode":"OFB","type":"stream"},"aes-192-ofb":{"cipher":"AES","key":192,"iv":16,"mode":"OFB","type":"stream"},"aes-256-ofb":{"cipher":"AES","key":256,"iv":16,"mode":"OFB","type":"stream"},"aes-128-ctr":{"cipher":"AES","key":128,"iv":16,"mode":"CTR","type":"stream"},"aes-192-ctr":{"cipher":"AES","key":192,"iv":16,"mode":"CTR","type":"stream"},"aes-256-ctr":{"cipher":"AES","key":256,"iv":16,"mode":"CTR","type":"stream"},"aes-128-gcm":{"cipher":"AES","key":128,"iv":12,"mode":"GCM","type":"auth"},"aes-192-gcm":{"cipher":"AES","key":192,"iv":12,"mode":"GCM","type":"auth"},"aes-256-gcm":{"cipher":"AES","key":256,"iv":12,"mode":"GCM","type":"auth"}}')}},s={};function r(e){var t=s[e];if(void 0!==t)return t.exports;var a=s[e]={id:e,loaded:!1,exports:{}};return n[e](a,a.exports,r),a.loaded=!0,a.exports}r.m=n,r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.f={},r.e=e=>Promise.all(Object.keys(r.f).reduce(((t,n)=>(r.f[n](e,t),t)),[])),r.u=e=>e+".main.js",r.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),e={792:0},t=t=>{var n,s,{ids:a,modules:i,runtime:o}=t,l=0;for(n in i)r.o(i,n)&&(r.m[n]=i[n]);for(o&&o(r);l<a.length;l++)s=a[l],r.o(e,s)&&e[s]&&e[s][0](),e[a[l]]=0},r.f.j=(n,s)=>{var a=r.o(e,n)?e[n]:void 0;if(0!==a)if(a)s.push(a[1]);else{var i=import("./"+r.u(n)).then(t,(t=>{throw 0!==e[n]&&(e[n]=void 0),t}));i=Promise.race([i,new Promise((t=>a=e[n]=[t]))]),s.push(a[1]=i)}};var a={};r.d(a,{j:()=>Vd,FY:()=>Id,sL:()=>Xd,e$:()=>mo,wC:()=>Nr,D2:()=>ad,nB:()=>fc,eb:()=>fd,fH:()=>bc,QM:()=>di,NZ:()=>rd,eH:()=>Lc,F9:()=>id,b$:()=>Gc,pF:()=>sd,qu:()=>nd,f2:()=>fl,Qs:()=>Cl,bX:()=>Pl,lT:()=>ul,V7:()=>Tl,st:()=>da,be:()=>hd,Iy:()=>Ir,Bx:()=>ac,gn:()=>Ec,Fq:()=>U,Fr:()=>X,R6:()=>hc,Y5:()=>Ur,Hq:()=>wa,K:()=>$a,KA:()=>D,H2:()=>Qe,Rx:()=>mc,CU:()=>Gl,kb:()=>Ol,W2:()=>vc,W4:()=>gc,on:()=>Jo,XL:()=>dl,GQ:()=>ml,Yj:()=>pl,w2:()=>dc,Ze:()=>Xp,Tu:()=>Dp,nv:()=>qp,L7:()=>Al,QZ:()=>Dr,tZ:()=>xc,bR:()=>Ie,nq:()=>Up,Fx:()=>Jp,mR:()=>Ho,n_:()=>Fc,gO:()=>Go,RV:()=>Jd,JK:()=>Bl,Tx:()=>Vl,Us:()=>Cc,jD:()=>Wl,xr:()=>tc,tb:()=>$l,MD:()=>hl,ir:()=>Vo,aK:()=>ni,FP:()=>md,uI:()=>bd,y5:()=>gd,qN:()=>Vi,dP:()=>Jc,yV:()=>Uc,V4:()=>rc,mW:()=>y,dB:()=>ld,v_:()=>Hp,Oe:()=>jp,Cd:()=>li,GB:()=>ai,p2:()=>ri,vk:()=>Qd,hu:()=>Yr,m9:()=>eu,cg:()=>od,fz:()=>co,vK:()=>po,DU:()=>Kp,bx:()=>Dc,hU:()=>Po,$q:()=>_c,aP:()=>w,L5:()=>vo,v6:()=>wo,sc:()=>Fe,yy:()=>go,Zx:()=>Ae,Dg:()=>we,cI:()=>l,VJ:()=>wd,id:()=>vd});var i=r(7877),o=r(8891).Buffer;function l(e){const t=e.toString("hex");return 0===t.length?BigInt(0):BigInt(`0x${t}`)}function c(e,t){if(e<BigInt(0))throw new Error(`Cannot convert negative bigint ${e.toString()} to buffer with toBufferBE.`);const n=e.toString(16),s=o.from(n.padStart(2*t,"0").slice(0,2*t),"hex");if(s.length>t)throw new Error(`Number ${e.toString(16)} does not fit in ${t}`);return s}function d(e,t=!1){const n=e.toString(16),s=n.length%2==0?n.length:n.length+1;return`0x${n.padStart(t?64:s,"0")}`}function u(e){if(!/^(0x)?[0-9a-fA-F]*$/.test(e)||e.length%2!=0)throw new Error(`Invalid hex string: ${e}`);return o.from(e.replace(/^0x/i,""),"hex")}var f=r(74),h=r(6041),p=r(7989);const _=["silent","error","warn","info","verbose","debug"],m={NODE_ENV:"production"}.LOG_LEVEL?.toLowerCase(),g=_.includes(m)?m:"info",b={NODE_ENV:"production"}.DEBUG??"aztec:*";function y(e){const t=p(e),n={silent:()=>{},error:(e,n,s)=>A(t,"error",function(e,t){const n=t&&[t.name,t.message].filter((e=>!!e)).join(" ");return t?`${e}: ${n||t}`:e}(e,n),s),warn:(e,n)=>A(t,"warn",e,n),info:(e,n)=>A(t,"info",e,n),verbose:(e,n)=>A(t,"verbose",e,n),debug:(e,n)=>A(t,"debug",e,n)};return Object.assign(((e,n)=>A(t,"debug",e,n)),n)}p.enable(b);const v=[];function w(e){v.push(e)}function A(e,t,n,s){for(const r of v)r(t,e.namespace,n,s);n=s?`${n} ${function(e){return Object.entries(e??{}).map((([e,t])=>`${e}=${"object"==typeof t&&"toString"in t?t.toString():t}`)).join(" ")}(s)}`:n,e.enabled&&_.indexOf(t)<=_.indexOf(g)&&e("[%s] %s",t.toUpperCase(),n)}var E=r(8891).Buffer;class x{constructor(e,t=y("aztec:randomness_singleton")){this.seed=e,this.log=t,this.counter=0,void 0!==e?(this.log.debug(`Using pseudo-randomness with seed: ${e}`),this.counter=e):this.log.debug("Using true randomness")}static getInstance(){if(!x.instance){const e={NODE_ENV:"production"}.SEED?Number({NODE_ENV:"production"}.SEED):void 0;x.instance=new x(e)}return x.instance}isDeterministic(){return void 0!==this.seed}getBytes(e){if(void 0===this.seed)throw new Error("RandomnessSingleton is not implemented for non-deterministic mode");const t=E.alloc(e);for(let n=0;n<e;n++)t[n]=this.counter>>8*n&255;return this.counter++,t}}var S=r(8891).Buffer;const T=65536,k=e=>{const t=x.getInstance();if(t.isDeterministic())return t.getBytes(e);if(h)return f.randomBytes(e);const n="undefined"!=typeof window&&window.crypto?window.crypto:"undefined"!=typeof self&&self.crypto?self.crypto:void 0;if(!n)throw new Error("randomBytes UnsupportedEnvironment");const s=S.allocUnsafe(e);if(e>T)for(let t=0;t<e;t+=T)n.getRandomValues(s.slice(t,t+T));else n.getRandomValues(s);return s},C=e=>{const t=k(6);return parseInt(t.toString("hex"),16)%e};function z(e,t,n,s){if("a"===n&&!s)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!s:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===n?s:"a"===n?s.call(e):s?s.value:t.get(e)}function P(e,t,n,s,r){if("m"===s)throw new TypeError("Private method is not writable");if("a"===s&&!r)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!r:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===s?r.call(e,n):r?r.value=n:t.set(e,n),n}Object.create,Object.create,"function"==typeof SuppressedError&&SuppressedError;var F,N,G=r(8891).Buffer;class L{constructor(e,t=0){F.add(this),this.buffer=e,this.index=t}static asReader(e){if(e instanceof L)return e;const t=G.isBuffer(e)?e:G.from(e.buffer,e.byteOffset,e.byteLength);return new L(t)}isEmpty(){return this.index===this.buffer.length}readNumber(){return z(this,F,"m",N).call(this,4),this.index+=4,this.buffer.readUint32BE(this.index-4)}readNumbers(e){return Array.from({length:e},(()=>this.readNumber()))}readUInt16(){return z(this,F,"m",N).call(this,2),this.index+=2,this.buffer.readUInt16BE(this.index-2)}readUInt8(){return z(this,F,"m",N).call(this,1),this.index+=1,this.buffer.readUInt8(this.index-1)}readBoolean(){return z(this,F,"m",N).call(this,1),this.index+=1,Boolean(this.buffer.at(this.index-1))}readBytes(e){return z(this,F,"m",N).call(this,e),this.index+=e,G.from(this.buffer.subarray(this.index-e,this.index))}readToEnd(){const e=this.buffer.subarray(this.index);return this.index=this.buffer.length,e}readNumberVector(){return this.readVector({fromBuffer:e=>e.readNumber()})}readVector(e){const t=this.readNumber(),n=new Array(t);for(let s=0;s<t;s++)n[s]=e.fromBuffer(this);return n}readVectorUint8Prefix(e){const t=this.readUInt8(),n=new Array(t);for(let s=0;s<t;s++)n[s]=e.fromBuffer(this);return n}readArray(e,t){return Array.from({length:e},(()=>t.fromBuffer(this)))}readBufferArray(e=-1){const t=[],n=e>=0?this.index+e:this.buffer.length;for(z(this,F,"m",N).call(this,n-this.index);this.index<n;){const e=this.readBuffer();t.push(e)}if(this.index!==n)throw new Error(`Reader buffer was not fully consumed. Consumed up to ${this.index} bytes. End of data: ${n} bytes.`);return t}readObject(e){return e.fromBuffer(this)}peekBytes(e){return z(this,F,"m",N).call(this,e||0),this.buffer.subarray(this.index,e?this.index+e:void 0)}readString(){return this.readBuffer().toString()}readBuffer(){const e=this.readNumber();return z(this,F,"m",N).call(this,e),this.readBytes(e)}readMap(e){const t=this.readNumber(),n={};for(let s=0;s<t;s++){const t=this.readString(),s=this.readObject(e);n[t]=s}return n}getLength(){return this.buffer.length}}F=new WeakSet,N=function(e){if(this.index+e>this.buffer.length)throw new Error(`Attempted to read beyond buffer length. Start index: ${this.index}, Num bytes to read: ${e}, Buffer length: ${this.buffer.length}`)};class O{static register(e,t){this.registry.set(e,t)}static getConstructor(e){return this.registry.get(e)}}O.registry=new Map;var R=r(8891).Buffer;const M=R.alloc(32);class B{get value(){return this.toBigInt()}get size(){return B.SIZE_IN_BYTES}constructor(e){if(e instanceof R){if(e.length>B.SIZE_IN_BYTES)throw new Error(`Value length ${e.length} exceeds ${B.SIZE_IN_BYTES}`);this.asBuffer=e.length===B.SIZE_IN_BYTES?e:R.concat([R.alloc(B.SIZE_IN_BYTES-e.length),e])}else if("bigint"==typeof e||"number"==typeof e||"boolean"==typeof e){if(this.asBigInt=BigInt(e),this.asBigInt>=this.modulus())throw new Error(`Value 0x${this.asBigInt.toString(16)} is greater or equal to field modulus.`)}else{if(!(e instanceof B))throw new Error(`Type '${typeof e}' with value '${e}' passed to BaseField ctor.`);this.asBuffer=e.asBuffer,this.asBigInt=e.asBigInt}}toBuffer(){return this.asBuffer||(this.asBuffer=c(this.asBigInt,32)),R.from(this.asBuffer)}toString(){return`0x${this.toBuffer().toString("hex")}`}toBigInt(){if(void 0===this.asBigInt&&(this.asBigInt=l(this.asBuffer),this.asBigInt>=this.modulus()))throw new Error(`Value 0x${this.asBigInt.toString(16)} is greater or equal to field modulus.`);return this.asBigInt}toBool(){return Boolean(this.toBigInt())}toNumber(){const e=this.toBigInt();if(e>Number.MAX_SAFE_INTEGER)throw new Error(`Value ${e.toString(16)} greater than than max safe integer`);return Number(e)}toShortString(){const e=this.toString();return`${e.slice(0,10)}...${e.slice(-4)}`}equals(e){return this.toBuffer().equals(e.toBuffer())}lt(e){return this.toBigInt()<e.toBigInt()}cmp(e){const t=this.toBigInt(),n=e.toBigInt();return t===n?0:t<n?-1:1}isZero(){return this.toBuffer().equals(M)}isEmpty(){return this.isZero()}toFriendlyJSON(){return this.toString()}toField(){return this}}function Y(e,t){return new t(L.asReader(e).readBytes(B.SIZE_IN_BYTES))}function j(e,t){return new t(l(e)%t.MODULUS)}function H(e){return j(k(64),e)}function I(e,t){const n=e.replace(/^0x/i,""),s=n.match(/^[0-9A-F]+$/i)?.[0];if(void 0===s)throw new Error(`Invalid hex-encoded string: "${e}"`);return new t(R.from(s.length%2==1?"0"+s:s,"hex"))}B.SIZE_IN_BYTES=32;class X extends B{constructor(e){super(e)}[i.inspect.custom](){return`Fr<${this.toString()}>`}modulus(){return X.MODULUS}static random(){return H(X)}static zero(){return X.ZERO}static isZero(e){return e.isZero()}static fromBuffer(e){return Y(e,X)}static fromBufferReduce(e){return j(e,X)}static fromString(e){return I(e,X)}add(e){return new X((this.toBigInt()+e.toBigInt())%X.MODULUS)}square(){return new X(this.toBigInt()*this.toBigInt()%X.MODULUS)}negate(){return new X(X.MODULUS-this.toBigInt())}sub(e){const t=this.toBigInt()-e.toBigInt();return new X(t<0?t+X.MODULUS:t)}mul(e){return new X(this.toBigInt()*e.toBigInt()%X.MODULUS)}div(e){if(e.isZero())throw new Error("Division by zero");const t=function(e){const[t,n,s]=J(e,X.MODULUS);if(1n!=t)throw Error("Inverse does not exist");return new X(n>0?n:n+X.MODULUS)}(e.toBigInt());return this.mul(t)}ediv(e){if(e.isZero())throw new Error("Division by zero");return new X(this.toBigInt()/e.toBigInt())}toJSON(){return{type:"Fr",value:this.toString()}}}X.ZERO=new X(0n),X.ONE=new X(1n),X.MODULUS=0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001n,O.register("Fr",X);class U extends B{[i.inspect.custom](){return`Fq<${this.toString()}>`}get lo(){return new X(this.toBigInt()&U.LOW_MASK)}get hi(){return new X(this.toBigInt()>>U.HIGH_SHIFT)}constructor(e){super(e)}modulus(){return U.MODULUS}static random(){return H(U)}static zero(){return U.ZERO}static fromBuffer(e){return Y(e,U)}static fromBufferReduce(e){return j(e,U)}static fromString(e){return I(e,U)}static fromHighLow(e,t){return new U((e.toBigInt()<<U.HIGH_SHIFT)+t.toBigInt())}toJSON(){return{type:"Fq",value:this.toString()}}}function J(e,t){if(0n==e)return[t,0n,1n];{const[n,s,r]=J(t%e,e);return[n,r-t/e*s,s]}}U.ZERO=new U(0n),U.MODULUS=0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47n,U.HIGH_SHIFT=BigInt(B.SIZE_IN_BYTES/2*8),U.LOW_MASK=(1n<<U.HIGH_SHIFT)-1n,O.register("Fq",U);const D=U;class q{constructor(e,t=0){this.buffer=e,this.index=t}static asReader(e){return e instanceof q?e:new q(e)}readNumber(){const e=new DataView(this.buffer.buffer,this.buffer.byteOffset+this.index,4);return this.index+=4,e.getUint32(0,!1)}readBoolean(){return this.index+=1,Boolean(this.buffer.at(this.index-1))}readBytes(e){return this.index+=e,this.buffer.slice(this.index-e,this.index)}readNumberVector(){return this.readVector({fromBuffer:e=>e.readNumber()})}readVector(e){const t=this.readNumber(),n=new Array(t);for(let s=0;s<t;s++)n[s]=e.fromBuffer(this);return n}readArray(e,t){const n=new Array(e);for(let s=0;s<e;s++)n[s]=t.fromBuffer(this);return n}readObject(e){return e.fromBuffer(this)}peekBytes(e){return this.buffer.subarray(this.index,e?this.index+e:void 0)}readString(){return(new TextDecoder).decode(this.readBuffer())}readBuffer(){const e=this.readNumber();return this.readBytes(e)}readMap(e){const t=this.readNumber(),n={};for(let s=0;s<t;s++){const t=this.readString(),s=this.readObject(e);n[t]=s}return n}}const K=e=>{const t="undefined"!=typeof window&&window.crypto?window.crypto:"undefined"!=typeof self&&self.crypto?self.crypto:void 0;if(!t)throw new Error("randomBytes UnsupportedEnvironment");const n=new Uint8Array(e),s=65536;if(e>s)for(let r=0;r<e;r+=s)t.getRandomValues(n.subarray(r,r+s));else t.getRandomValues(n);return n};function W(e){e=new Uint8Array(e);let t=BigInt(0);const n=new DataView(e.buffer);for(let s=0;s<e.byteLength;s++)t=(t<<BigInt(8))+BigInt(n.getUint8(s));return t}function Z(e,t=32){const n=new Uint8Array(t),s=new DataView(n.buffer);for(let n=0;n<t;n++)s.setUint8(t-n-1,Number(e&BigInt(255))),e>>=BigInt(8);return n}var V,Q,$=r(8356).hp;class ee{constructor(e){const t="bigint"==typeof e?e:W(e);if(t>V.MAX_VALUE)throw new Error(`Value 0x${t.toString(16)} is greater or equal to field modulus.`);this.value="bigint"==typeof e?Z(e):e}static random(){return new this(W(K(64))%V.MODULUS)}static fromBuffer(e){return new this(q.asReader(e).readBytes(this.SIZE_IN_BYTES))}static fromBufferReduce(e){return new this(W(q.asReader(e).readBytes(this.SIZE_IN_BYTES))%V.MODULUS)}static fromString(e){return this.fromBuffer($.from(e.replace(/^0x/i,""),"hex"))}toBuffer(){return this.value}toString(){return"0x"+this.toBuffer().reduce(((e,t)=>e+t.toString(16).padStart(2,"0")),"")}equals(e){return this.value.every(((t,n)=>t===e.value[n]))}isZero(){return this.value.every((e=>0===e))}}V=ee,ee.ZERO=new V(0n),ee.MODULUS=0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001n,ee.MAX_VALUE=V.MODULUS-1n,ee.SIZE_IN_BYTES=32;class te{constructor(e){if(this.value=e,e>Q.MAX_VALUE)throw new Error(`Fq out of range ${e}.`)}static random(){return new this(W(K(64))%Q.MODULUS)}static fromBuffer(e){return new this(W(q.asReader(e).readBytes(this.SIZE_IN_BYTES)))}static fromBufferReduce(e){return new this(W(q.asReader(e).readBytes(this.SIZE_IN_BYTES))%ee.MODULUS)}static fromString(e){return this.fromBuffer($.from(e.replace(/^0x/i,""),"hex"))}toBuffer(){return Z(this.value,Q.SIZE_IN_BYTES)}toString(){return"0x"+this.value.toString(16)}equals(e){return this.value===e.value}isZero(){return 0n===this.value}}Q=te,te.MODULUS=0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47n,te.MAX_VALUE=Q.MODULUS-1n,te.SIZE_IN_BYTES=32;var ne=r(8356).hp;class se{constructor(e,t){this.x=e,this.y=t}static random(){return new se(ee.random(),ee.random())}static fromBuffer(e){const t=q.asReader(e);return new this(ee.fromBuffer(t),ee.fromBuffer(t))}static fromString(e){return se.fromBuffer(ne.from(e.replace(/^0x/i,""),"hex"))}toBuffer(){return ne.concat([this.x.toBuffer(),this.y.toBuffer()])}toString(){return"0x"+this.toBuffer().toString("hex")}equals(e){return this.x.equals(e.x)&&this.y.equals(e.y)}}se.SIZE_IN_BYTES=64,se.EMPTY=new se(ee.ZERO,ee.ZERO);class re{constructor(e){this.buffer=e}static fromBuffer(e){const t=q.asReader(e);return new re(t.readBytes(this.SIZE_IN_BYTES))}static random(){return new re(K(this.SIZE_IN_BYTES))}toBuffer(){return this.buffer}}re.SIZE_IN_BYTES=32;class ae{constructor(e){this.buffer=e}static fromBuffer(e){const t=q.asReader(e);return new ae(t.readBytes(this.SIZE_IN_BYTES))}static random(){return new ae(K(this.SIZE_IN_BYTES))}toBuffer(){return this.buffer}}ae.SIZE_IN_BYTES=64;class ie{constructor(e){this.buffer=e}static fromBuffer(e){const t=q.asReader(e);return new ie(t.readBytes(this.SIZE_IN_BYTES))}static random(){return new ie(K(this.SIZE_IN_BYTES))}toBuffer(){return this.buffer}}ie.SIZE_IN_BYTES=128;var oe=r(3891),le=r(8356).hp;const{BBSwiftModule:ce}=oe.NativeModules;class de{async pedersenCommit(e){const t=e.flatMap((e=>Array.from(e.toBuffer()))),n=await ce.pedersenCommit(t);if(!n)throw new Error("pedersenCommit returned null or encountered an error");return se.fromBuffer(n)}async pedersenHash(e,t){const n=e.flatMap((e=>Array.from(e.toBuffer()))),s=await ce.pedersenHash(n,t);if(!s)throw new Error("pedersenHash returned null or encountered an error");return ee.fromBuffer(s)}async poseidon2Hash(e){const t=e.flatMap((e=>Array.from(e.toBuffer()))),n=await ce.poseidon2Hash(t);if(!n)throw new Error("poseidon2Hash returned null or encountered an error");return ee.fromBuffer(n)}async eccGrumpkinMul(e,t){const n=await ce.eccGrumpkinMul(Array.from(e),Array.from(t));if(!n)throw new Error("eccGrumpkinMul returned null or encountered an error");return le.from(n)}async eccGrumpkinAdd(e,t){const n=await ce.eccGrumpkinAdd(Array.from(e),Array.from(t));if(!n)throw new Error("eccGrumpkinAdd returned null or encountered an error");return le.from(n)}async pedersenHashes(e,t){throw new Error("pedersenHashes not supported")}async pedersenHashBuffer(e,t){throw new Error("pedersenHashBuffer not supported")}async poseidon2Hashes(e){throw new Error("poseidon2Hashes not supported")}async poseidon2Permutation(e){throw new Error("poseidon2Permutation not supported")}async blake2s(e){throw new Error("blake2s not supported")}async blake2sToField(e){throw new Error("blake2sToField not supported")}async schnorrComputePublicKey(e){throw new Error("schnorrComputePublicKey not supported")}async schnorrNegatePublicKey(e){throw new Error("schnorrNegatePublicKey not supported")}async schnorrConstructSignature(e,t){throw new Error("schnorrConstructSignature not supported")}async schnorrVerifySignature(e,t,n,s){throw new Error("schnorrVerifySignature not supported")}async schnorrMultisigCreateMultisigPublicKey(e){throw new Error("schnorrMultisigCreateMultisigPublicKey not supported")}async schnorrMultisigValidateAndCombineSignerPubkeys(e){throw new Error("schnorrMultisigValidateAndCombineSignerPubkeys not supported")}async schnorrMultisigConstructSignatureRound1(){throw new Error("schnorrMultisigConstructSignatureRound1 not supported")}async schnorrMultisigConstructSignatureRound2(e,t,n,s,r){throw new Error("schnorrMultisigConstructSignatureRound2 not supported")}async schnorrMultisigCombineSignatures(e,t,n,s){throw new Error("schnorrMultisigCombineSignatures not supported")}async aesEncryptBufferCbc(e,t,n,s){throw new Error("aesEncryptBufferCbc not supported")}async aesDecryptBufferCbc(e,t,n,s){throw new Error("aesDecryptBufferCbc not supported")}async srsInitSrs(e,t,n){throw new Error("srsInitSrs not supported")}async srsInitGrumpkinSrs(e,t){throw new Error("srsInitGrumpkinSrs not supported")}async examplesSimpleCreateAndVerifyProof(){throw new Error("examplesSimpleCreateAndVerifyProof not supported")}async testThreads(e,t){throw new Error("testThreads not supported")}async commonInitSlabAllocator(e){throw new Error("commonInitSlabAllocator not supported")}async acirGetCircuitSizes(e,t){throw new Error("acirGetCircuitSizes not supported")}async acirNewAcirComposer(e){throw new Error("acirNewAcirComposer not supported")}async acirDeleteAcirComposer(e){throw new Error("acirDeleteAcirComposer not supported")}async acirCreateCircuit(e,t,n){throw new Error("acirCreateCircuit not supported")}async acirInitProvingKey(e,t){throw new Error("acirInitProvingKey not supported")}async acirCreateProof(e,t,n){throw new Error("acirCreateProof not supported")}async acirProveAndVerifyUltraHonk(e,t){throw new Error("acirProveAndVerifyUltraHonk not supported")}async acirProveAndVerifyMegaHonk(e,t){throw new Error("acirProveAndVerifyMegaHonk not supported")}async acirFoldAndVerifyProgramStack(e,t){throw new Error("acirFoldAndVerifyProgramStack not supported")}async acirLoadVerificationKey(e,t){throw new Error("acirLoadVerificationKey not supported")}async acirInitVerificationKey(e){throw new Error("acirInitVerificationKey not supported")}async acirGetVerificationKey(e){throw new Error("acirGetVerificationKey not supported")}async acirGetProvingKey(e,t){throw new Error("acirGetProvingKey not supported")}async acirVerifyProof(e,t){throw new Error("acirVerifyProof not supported")}async acirGetSolidityVerifier(e){throw new Error("acirGetSolidityVerifier not supported")}async acirSerializeProofIntoFields(e,t,n){throw new Error("acirSerializeProofIntoFields not supported")}async acirSerializeVerificationKeyIntoFields(e){throw new Error("acirSerializeVerificationKeyIntoFields not supported")}async acirProveUltraHonk(e,t){throw new Error("acirProveUltraHonk not supported")}async acirVerifyUltraHonk(e,t){throw new Error("acirVerifyUltraHonk not supported")}async acirWriteVkUltraHonk(e){throw new Error("acirWriteVkUltraHonk not supported")}async acirProofAsFieldsUltraHonk(e){throw new Error("acirProofAsFieldsUltraHonk not supported")}async acirVkAsFieldsUltraHonk(e){throw new Error("acirVkAsFieldsUltraHonk not supported")}}class ue{static async new(){return new ue}static initSingleton(){console.log("initSingleton called")}static getSingleton(){return ue.new()}}class fe extends de{static new(){return new fe}}var he=r(3322);function pe(e){return new he.vm(256).update(e).digest()}function _e(e){const t=new he.vm(256);return t.reset(),t.update(e),t.digest("hex")}var me=r(6460),ge=r(8891).Buffer;function be(e,t=4){const n=ge.alloc(t);return n.writeUInt32BE(e,t-4),n}function ye(e){const t=ge.alloc(1);return t.writeUInt8(e,0),t}function ve(e){const t=ge.alloc(4);return t.writeUInt32BE(e.length,0),ge.concat([t,e])}function we(e){const t=e.toString("hex");return 0===t.length?BigInt(0):BigInt(`0x${t}`)}function Ae(e){if(32!==e.length)throw new Error("Buffer must be 32 bytes");const t=ge.concat([ge.alloc(16),e.subarray(0,16)]),n=ge.concat([ge.alloc(16),e.subarray(16,32)]);return[X.fromBuffer(t),X.fromBuffer(n)]}var Ee=r(8891).Buffer;function xe(e,t=4){const n=Te(e);let s;if(1===t)s=Ee.alloc(1),s.writeUInt8(n.length,0);else{if(4!==t)throw new Error(`Unsupported prefix length. Got ${t}, expected 1 or 4`);s=Ee.alloc(4),s.writeUInt32BE(n.length,0)}return Ee.concat([s,...n])}function Se(e,t=1){const n=Ee.alloc(t);return n.writeUInt8(e?1:0,t-1),n}function Te(...e){const t=[];for(const n of e)if(Array.isArray(n))t.push(...Te(...n));else if(Ee.isBuffer(n))t.push(n);else if("boolean"==typeof n)t.push(Se(n));else if("bigint"==typeof n){if(n>BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"))throw new Error(`BigInt ${n} does not fit into 32 bytes`);t.push(ze(n))}else if("number"==typeof n)t.push(be(n));else if("string"==typeof n)t.push(be(n.length)),t.push(Ee.from(n));else{if(!("toBuffer"in n))throw new Error(`Cannot serialize input to buffer: ${typeof n} ${n.constructor?.name}`);t.push(n.toBuffer())}return t}function ke(...e){const t=[];for(const n of e)if(Array.isArray(n))t.push(...ke(...n));else if(n instanceof X)t.push(n);else if("boolean"==typeof n||"number"==typeof n||"bigint"==typeof n)t.push(new X(n));else if("toFields"in n)t.push(...n.toFields());else if("toFr"in n)t.push(n.toFr());else if("toField"in n)t.push(n.toField());else{if(!Ee.isBuffer(n))throw new Error(`Cannot serialize input to field: ${typeof n} ${n.constructor?.name}`);t.push(X.fromBuffer(n))}return t}function Ce(...e){return Ee.concat(Te(...e))}function ze(e,t=32){return c(e,t)}var Pe=r(8891).Buffer;const Fe=e=>Pe.from(me.sha256().update(e).digest()),Ne=e=>function(e){if(32!==e.length)throw new Error("Buffer to truncate must be 32 bytes");return ge.concat([ge.alloc(1),e.subarray(0,31)])}(Fe(e)),Ge=e=>{const t=Ce(e);return X.fromBuffer(Ne(t))};var Le=r(8891).Buffer;const Oe=e=>{const t=Ce(e);return D.fromBufferReduce((e=>Le.from(me.sha512().update(e).digest()))(t))};var Re=r(8891).Buffer;async function Me(e,t=0){const n=ke(e),s=fe.new(),r=await s.pedersenHash(n.map((e=>new ee(e.toBuffer()))),t);return X.fromBuffer(Re.from(r.toBuffer()))}var Be=r(8891).Buffer;async function Ye(e){const t=ke(e),n=fe.new();return X.fromBuffer(Be.from((await n.poseidon2Hash(t.map((e=>new ee(e.toBuffer()))))).toBuffer()))}class je{constructor(e,t=0){if(this.fields=e,this.index=t,this.length=e.length,t>=this.length)throw new Error("Offset out of bounds.")}static asReader(e){return e instanceof je?e:new je(e)}readField(){if(this.index===this.length)throw new Error("Not enough fields to be consumed.");return this.fields[this.index++]}readFq(){return U.fromHighLow(this.readField(),this.readField())}readBoolean(){const e=this.readField().toBigInt();if(e>1n)throw new Error("Field is not a boolean.");return 1n==e}readU32(){const e=this.readField().toBigInt();if(e>=1n<<32n)throw new Error("Field is not a u32.");return Number(e)}readFieldArray(e){const t=[];for(let n=0;n<e;++n)t.push(this.readField());return t}readArray(e,t){return Array.from({length:e},(()=>t.fromFields(this)))}readObject(e){return e.fromFields(this)}}var He=r(8891).Buffer;class Ie{constructor(e,t,n){this.x=e,this.y=t,this.isInfinite=n,this.kind="point"}static random(){return new Ie(X.random(),X.random(),!1)}static fromBuffer(e){const t=L.asReader(e);return new this(X.fromBuffer(t),X.fromBuffer(t),!1)}static fromString(e){return this.fromBuffer(He.from(e.replace(/^0x/i,""),"hex"))}toFields(){return[this.x,this.y,new X(this.isInfinite)]}static fromFields(e){const t=je.asReader(e);return new this(t.readField(),t.readField(),t.readBoolean())}toBigInts(){return{x:this.x.toBigInt(),y:this.y.toBigInt(),isInfinite:this.isInfinite?1n:0n}}toBuffer(){if(this.isInfinite)throw new Error("Cannot serialize infinite point without isInfinite flag");const e=Ce([this.x,this.y]);if(e.length!==Ie.SIZE_IN_BYTES)throw new Error(`Invalid buffer length for Point: ${e.length}`);return e}toString(){return"0x"+this.toBuffer().toString("hex")}toShortString(){const e=this.toString();return`${e.slice(0,10)}...${e.slice(-4)}`}toNoirStruct(){return{x:this.x,y:this.y,is_infinite:this.isInfinite}}equals(e){return this.x.equals(e.x)&&this.y.equals(e.y)}isZero(){return this.x.isZero()&&this.y.isZero()}hash(){return Ye(this.toFields())}get inf(){return this.x.isZero()&&this.y.isZero()&&this.isInfinite}isOnGrumpkin(){if(this.inf)return!0;const e=new X(17),t=this.y.square(),n=this.x.square().mul(this.x).sub(e);return t.equals(n)}}Ie.ZERO=new Ie(X.ZERO,X.ZERO,!1),Ie.SIZE_IN_BYTES=2*X.SIZE_IN_BYTES;var Xe=r(8891).Buffer;class Ue{constructor(e){this.fields=e}toFields(){return this.fields}static random(){return this.fromField(X.random())}toFieldsBuffer(){return Xe.concat([this.fields[0].toBuffer(),this.fields[1].toBuffer()])}toBuffer(){const e=this.fields[0].toBuffer(),t=this.fields[1].toBuffer();return e[0]=t[31],e}equals(e){return this.toBigInt()===e.toBigInt()}toBigInt(){return l(this.toBuffer())}static fromBuffer(e){if(32!=e.length)throw new Error("Invalid size of coordinate buffer");const t=Xe.alloc(32);e.copy(t,0,0,32);const n=Xe.alloc(32);return n[31]=t[0],t[0]=0,new Ue([X.fromBuffer(t),X.fromBuffer(n)])}static fromField(e){const t=e.toBuffer(),n=Xe.alloc(32);return n[31]=t[0],t[0]=0,new Ue([X.fromBuffer(t),X.fromBuffer(n)])}}Ue.ZERO=new Ue([X.ZERO,X.ZERO]);const Je=64,De=64,qe=32,Ke=5,We=16,Ze=16,Ve=256,Qe=1,$e=11121068431693264234253912047066709627593769337094408533543930778360n,et=1e9,tt=1e8;var nt,st;function rt(e){let t=e.length;for(;--t>=0;)e[t]=0}(st=nt||(nt={}))[st.NOTE_HASH=1]="NOTE_HASH",st[st.NOTE_HASH_NONCE=2]="NOTE_HASH_NONCE",st[st.UNIQUE_NOTE_HASH=3]="UNIQUE_NOTE_HASH",st[st.SILOED_NOTE_HASH=4]="SILOED_NOTE_HASH",st[st.MESSAGE_NULLIFIER=5]="MESSAGE_NULLIFIER",st[st.INITIALIZATION_NULLIFIER=6]="INITIALIZATION_NULLIFIER",st[st.OUTER_NULLIFIER=7]="OUTER_NULLIFIER",st[st.PUBLIC_DATA_READ=8]="PUBLIC_DATA_READ",st[st.PUBLIC_DATA_UPDATE_REQUEST=9]="PUBLIC_DATA_UPDATE_REQUEST",st[st.FUNCTION_DATA=10]="FUNCTION_DATA",st[st.FUNCTION_LEAF=11]="FUNCTION_LEAF",st[st.CONTRACT_DEPLOYMENT_DATA=12]="CONTRACT_DEPLOYMENT_DATA",st[st.CONSTRUCTOR=13]="CONSTRUCTOR",st[st.CONSTRUCTOR_ARGS=14]="CONSTRUCTOR_ARGS",st[st.CONTRACT_ADDRESS_V1=15]="CONTRACT_ADDRESS_V1",st[st.CONTRACT_LEAF=16]="CONTRACT_LEAF",st[st.CALL_CONTEXT=17]="CALL_CONTEXT",st[st.CALL_STACK_ITEM=18]="CALL_STACK_ITEM",st[st.CALL_STACK_ITEM_2=19]="CALL_STACK_ITEM_2",st[st.SECRET_HASH=20]="SECRET_HASH",st[st.L2_TO_L1_MSG=21]="L2_TO_L1_MSG",st[st.TX_CONTEXT=22]="TX_CONTEXT",st[st.PUBLIC_LEAF_INDEX=23]="PUBLIC_LEAF_INDEX",st[st.PUBLIC_DATA_LEAF=24]="PUBLIC_DATA_LEAF",st[st.SIGNED_TX_REQUEST=25]="SIGNED_TX_REQUEST",st[st.GLOBAL_VARIABLES=26]="GLOBAL_VARIABLES",st[st.PARTIAL_ADDRESS=27]="PARTIAL_ADDRESS",st[st.BLOCK_HASH=28]="BLOCK_HASH",st[st.SIDE_EFFECT=29]="SIDE_EFFECT",st[st.FEE_PAYLOAD=30]="FEE_PAYLOAD",st[st.TX_REQUEST=33]="TX_REQUEST",st[st.SIGNATURE_PAYLOAD=34]="SIGNATURE_PAYLOAD",st[st.VK=41]="VK",st[st.PRIVATE_CIRCUIT_PUBLIC_INPUTS=42]="PRIVATE_CIRCUIT_PUBLIC_INPUTS",st[st.PUBLIC_CIRCUIT_PUBLIC_INPUTS=43]="PUBLIC_CIRCUIT_PUBLIC_INPUTS",st[st.FUNCTION_ARGS=44]="FUNCTION_ARGS",st[st.AUTHWIT_INNER=45]="AUTHWIT_INNER",st[st.AUTHWIT_OUTER=46]="AUTHWIT_OUTER",st[st.AUTHWIT_NULLIFIER=47]="AUTHWIT_NULLIFIER",st[st.NSK_M=48]="NSK_M",st[st.IVSK_M=49]="IVSK_M",st[st.OVSK_M=50]="OVSK_M",st[st.TSK_M=51]="TSK_M",st[st.PUBLIC_KEYS_HASH=52]="PUBLIC_KEYS_HASH",st[st.NOTE_NULLIFIER=53]="NOTE_NULLIFIER",st[st.INNER_NOTE_HASH=54]="INNER_NOTE_HASH",st[st.NOTE_CONTENT_HASH=55]="NOTE_CONTENT_HASH",st[st.SYMMETRIC_KEY=56]="SYMMETRIC_KEY";const at=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),it=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),ot=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),lt=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),ct=new Array(576);rt(ct);const dt=new Array(60);rt(dt);const ut=new Array(512);rt(ut);const ft=new Array(256);rt(ft);const ht=new Array(29);rt(ht);const pt=new Array(30);function _t(e,t,n,s,r){this.static_tree=e,this.extra_bits=t,this.extra_base=n,this.elems=s,this.max_length=r,this.has_stree=e&&e.length}let mt,gt,bt;function yt(e,t){this.dyn_tree=e,this.max_code=0,this.stat_desc=t}rt(pt);const vt=e=>e<256?ut[e]:ut[256+(e>>>7)],wt=(e,t)=>{e.pending_buf[e.pending++]=255&t,e.pending_buf[e.pending++]=t>>>8&255},At=(e,t,n)=>{e.bi_valid>16-n?(e.bi_buf|=t<<e.bi_valid&65535,wt(e,e.bi_buf),e.bi_buf=t>>16-e.bi_valid,e.bi_valid+=n-16):(e.bi_buf|=t<<e.bi_valid&65535,e.bi_valid+=n)},Et=(e,t,n)=>{At(e,n[2*t],n[2*t+1])},xt=(e,t)=>{let n=0;do{n|=1&e,e>>>=1,n<<=1}while(--t>0);return n>>>1},St=(e,t,n)=>{const s=new Array(16);let r,a,i=0;for(r=1;r<=15;r++)i=i+n[r-1]<<1,s[r]=i;for(a=0;a<=t;a++){let t=e[2*a+1];0!==t&&(e[2*a]=xt(s[t]++,t))}},Tt=e=>{let t;for(t=0;t<286;t++)e.dyn_ltree[2*t]=0;for(t=0;t<30;t++)e.dyn_dtree[2*t]=0;for(t=0;t<19;t++)e.bl_tree[2*t]=0;e.dyn_ltree[512]=1,e.opt_len=e.static_len=0,e.sym_next=e.matches=0},kt=e=>{e.bi_valid>8?wt(e,e.bi_buf):e.bi_valid>0&&(e.pending_buf[e.pending++]=e.bi_buf),e.bi_buf=0,e.bi_valid=0},Ct=(e,t,n,s)=>{const r=2*t,a=2*n;return e[r]<e[a]||e[r]===e[a]&&s[t]<=s[n]},zt=(e,t,n)=>{const s=e.heap[n];let r=n<<1;for(;r<=e.heap_len&&(r<e.heap_len&&Ct(t,e.heap[r+1],e.heap[r],e.depth)&&r++,!Ct(t,s,e.heap[r],e.depth));)e.heap[n]=e.heap[r],n=r,r<<=1;e.heap[n]=s},Pt=(e,t,n)=>{let s,r,a,i,o=0;if(0!==e.sym_next)do{s=255&e.pending_buf[e.sym_buf+o++],s+=(255&e.pending_buf[e.sym_buf+o++])<<8,r=e.pending_buf[e.sym_buf+o++],0===s?Et(e,r,t):(a=ft[r],Et(e,a+256+1,t),i=at[a],0!==i&&(r-=ht[a],At(e,r,i)),s--,a=vt(s),Et(e,a,n),i=it[a],0!==i&&(s-=pt[a],At(e,s,i)))}while(o<e.sym_next);Et(e,256,t)},Ft=(e,t)=>{const n=t.dyn_tree,s=t.stat_desc.static_tree,r=t.stat_desc.has_stree,a=t.stat_desc.elems;let i,o,l,c=-1;for(e.heap_len=0,e.heap_max=573,i=0;i<a;i++)0!==n[2*i]?(e.heap[++e.heap_len]=c=i,e.depth[i]=0):n[2*i+1]=0;for(;e.heap_len<2;)l=e.heap[++e.heap_len]=c<2?++c:0,n[2*l]=1,e.depth[l]=0,e.opt_len--,r&&(e.static_len-=s[2*l+1]);for(t.max_code=c,i=e.heap_len>>1;i>=1;i--)zt(e,n,i);l=a;do{i=e.heap[1],e.heap[1]=e.heap[e.heap_len--],zt(e,n,1),o=e.heap[1],e.heap[--e.heap_max]=i,e.heap[--e.heap_max]=o,n[2*l]=n[2*i]+n[2*o],e.depth[l]=(e.depth[i]>=e.depth[o]?e.depth[i]:e.depth[o])+1,n[2*i+1]=n[2*o+1]=l,e.heap[1]=l++,zt(e,n,1)}while(e.heap_len>=2);e.heap[--e.heap_max]=e.heap[1],((e,t)=>{const n=t.dyn_tree,s=t.max_code,r=t.stat_desc.static_tree,a=t.stat_desc.has_stree,i=t.stat_desc.extra_bits,o=t.stat_desc.extra_base,l=t.stat_desc.max_length;let c,d,u,f,h,p,_=0;for(f=0;f<=15;f++)e.bl_count[f]=0;for(n[2*e.heap[e.heap_max]+1]=0,c=e.heap_max+1;c<573;c++)d=e.heap[c],f=n[2*n[2*d+1]+1]+1,f>l&&(f=l,_++),n[2*d+1]=f,d>s||(e.bl_count[f]++,h=0,d>=o&&(h=i[d-o]),p=n[2*d],e.opt_len+=p*(f+h),a&&(e.static_len+=p*(r[2*d+1]+h)));if(0!==_){do{for(f=l-1;0===e.bl_count[f];)f--;e.bl_count[f]--,e.bl_count[f+1]+=2,e.bl_count[l]--,_-=2}while(_>0);for(f=l;0!==f;f--)for(d=e.bl_count[f];0!==d;)u=e.heap[--c],u>s||(n[2*u+1]!==f&&(e.opt_len+=(f-n[2*u+1])*n[2*u],n[2*u+1]=f),d--)}})(e,t),St(n,c,e.bl_count)},Nt=(e,t,n)=>{let s,r,a=-1,i=t[1],o=0,l=7,c=4;for(0===i&&(l=138,c=3),t[2*(n+1)+1]=65535,s=0;s<=n;s++)r=i,i=t[2*(s+1)+1],++o<l&&r===i||(o<c?e.bl_tree[2*r]+=o:0!==r?(r!==a&&e.bl_tree[2*r]++,e.bl_tree[32]++):o<=10?e.bl_tree[34]++:e.bl_tree[36]++,o=0,a=r,0===i?(l=138,c=3):r===i?(l=6,c=3):(l=7,c=4))},Gt=(e,t,n)=>{let s,r,a=-1,i=t[1],o=0,l=7,c=4;for(0===i&&(l=138,c=3),s=0;s<=n;s++)if(r=i,i=t[2*(s+1)+1],!(++o<l&&r===i)){if(o<c)do{Et(e,r,e.bl_tree)}while(0!=--o);else 0!==r?(r!==a&&(Et(e,r,e.bl_tree),o--),Et(e,16,e.bl_tree),At(e,o-3,2)):o<=10?(Et(e,17,e.bl_tree),At(e,o-3,3)):(Et(e,18,e.bl_tree),At(e,o-11,7));o=0,a=r,0===i?(l=138,c=3):r===i?(l=6,c=3):(l=7,c=4)}};let Lt=!1;const Ot=(e,t,n,s)=>{At(e,0+(s?1:0),3),kt(e),wt(e,n),wt(e,~n),n&&e.pending_buf.set(e.window.subarray(t,t+n),e.pending),e.pending+=n};var Rt={_tr_init:e=>{Lt||((()=>{let e,t,n,s,r;const a=new Array(16);for(n=0,s=0;s<28;s++)for(ht[s]=n,e=0;e<1<<at[s];e++)ft[n++]=s;for(ft[n-1]=s,r=0,s=0;s<16;s++)for(pt[s]=r,e=0;e<1<<it[s];e++)ut[r++]=s;for(r>>=7;s<30;s++)for(pt[s]=r<<7,e=0;e<1<<it[s]-7;e++)ut[256+r++]=s;for(t=0;t<=15;t++)a[t]=0;for(e=0;e<=143;)ct[2*e+1]=8,e++,a[8]++;for(;e<=255;)ct[2*e+1]=9,e++,a[9]++;for(;e<=279;)ct[2*e+1]=7,e++,a[7]++;for(;e<=287;)ct[2*e+1]=8,e++,a[8]++;for(St(ct,287,a),e=0;e<30;e++)dt[2*e+1]=5,dt[2*e]=xt(e,5);mt=new _t(ct,at,257,286,15),gt=new _t(dt,it,0,30,15),bt=new _t(new Array(0),ot,0,19,7)})(),Lt=!0),e.l_desc=new yt(e.dyn_ltree,mt),e.d_desc=new yt(e.dyn_dtree,gt),e.bl_desc=new yt(e.bl_tree,bt),e.bi_buf=0,e.bi_valid=0,Tt(e)},_tr_stored_block:Ot,_tr_flush_block:(e,t,n,s)=>{let r,a,i=0;e.level>0?(2===e.strm.data_type&&(e.strm.data_type=(e=>{let t,n=4093624447;for(t=0;t<=31;t++,n>>>=1)if(1&n&&0!==e.dyn_ltree[2*t])return 0;if(0!==e.dyn_ltree[18]||0!==e.dyn_ltree[20]||0!==e.dyn_ltree[26])return 1;for(t=32;t<256;t++)if(0!==e.dyn_ltree[2*t])return 1;return 0})(e)),Ft(e,e.l_desc),Ft(e,e.d_desc),i=(e=>{let t;for(Nt(e,e.dyn_ltree,e.l_desc.max_code),Nt(e,e.dyn_dtree,e.d_desc.max_code),Ft(e,e.bl_desc),t=18;t>=3&&0===e.bl_tree[2*lt[t]+1];t--);return e.opt_len+=3*(t+1)+5+5+4,t})(e),r=e.opt_len+3+7>>>3,a=e.static_len+3+7>>>3,a<=r&&(r=a)):r=a=n+5,n+4<=r&&-1!==t?Ot(e,t,n,s):4===e.strategy||a===r?(At(e,2+(s?1:0),3),Pt(e,ct,dt)):(At(e,4+(s?1:0),3),((e,t,n,s)=>{let r;for(At(e,t-257,5),At(e,n-1,5),At(e,s-4,4),r=0;r<s;r++)At(e,e.bl_tree[2*lt[r]+1],3);Gt(e,e.dyn_ltree,t-1),Gt(e,e.dyn_dtree,n-1)})(e,e.l_desc.max_code+1,e.d_desc.max_code+1,i+1),Pt(e,e.dyn_ltree,e.dyn_dtree)),Tt(e),s&&kt(e)},_tr_tally:(e,t,n)=>(e.pending_buf[e.sym_buf+e.sym_next++]=t,e.pending_buf[e.sym_buf+e.sym_next++]=t>>8,e.pending_buf[e.sym_buf+e.sym_next++]=n,0===t?e.dyn_ltree[2*n]++:(e.matches++,t--,e.dyn_ltree[2*(ft[n]+256+1)]++,e.dyn_dtree[2*vt(t)]++),e.sym_next===e.sym_end),_tr_align:e=>{At(e,2,3),Et(e,256,ct),(e=>{16===e.bi_valid?(wt(e,e.bi_buf),e.bi_buf=0,e.bi_valid=0):e.bi_valid>=8&&(e.pending_buf[e.pending++]=255&e.bi_buf,e.bi_buf>>=8,e.bi_valid-=8)})(e)}},Mt=(e,t,n,s)=>{let r=65535&e,a=e>>>16&65535,i=0;for(;0!==n;){i=n>2e3?2e3:n,n-=i;do{r=r+t[s++]|0,a=a+r|0}while(--i);r%=65521,a%=65521}return r|a<<16};const Bt=new Uint32Array((()=>{let e,t=[];for(var n=0;n<256;n++){e=n;for(var s=0;s<8;s++)e=1&e?3988292384^e>>>1:e>>>1;t[n]=e}return t})());var Yt=(e,t,n,s)=>{const r=Bt,a=s+n;e^=-1;for(let n=s;n<a;n++)e=e>>>8^r[255&(e^t[n])];return~e},jt={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},Ht={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init:It,_tr_stored_block:Xt,_tr_flush_block:Ut,_tr_tally:Jt,_tr_align:Dt}=Rt,{Z_NO_FLUSH:qt,Z_PARTIAL_FLUSH:Kt,Z_FULL_FLUSH:Wt,Z_FINISH:Zt,Z_BLOCK:Vt,Z_OK:Qt,Z_STREAM_END:$t,Z_STREAM_ERROR:en,Z_DATA_ERROR:tn,Z_BUF_ERROR:nn,Z_DEFAULT_COMPRESSION:sn,Z_FILTERED:rn,Z_HUFFMAN_ONLY:an,Z_RLE:on,Z_FIXED:ln,Z_DEFAULT_STRATEGY:cn,Z_UNKNOWN:dn,Z_DEFLATED:un}=Ht,fn=258,hn=262,pn=42,_n=113,mn=666,gn=(e,t)=>(e.msg=jt[t],t),bn=e=>2*e-(e>4?9:0),yn=e=>{let t=e.length;for(;--t>=0;)e[t]=0},vn=e=>{let t,n,s,r=e.w_size;t=e.hash_size,s=t;do{n=e.head[--s],e.head[s]=n>=r?n-r:0}while(--t);t=r,s=t;do{n=e.prev[--s],e.prev[s]=n>=r?n-r:0}while(--t)};let wn=(e,t,n)=>(t<<e.hash_shift^n)&e.hash_mask;const An=e=>{const t=e.state;let n=t.pending;n>e.avail_out&&(n=e.avail_out),0!==n&&(e.output.set(t.pending_buf.subarray(t.pending_out,t.pending_out+n),e.next_out),e.next_out+=n,t.pending_out+=n,e.total_out+=n,e.avail_out-=n,t.pending-=n,0===t.pending&&(t.pending_out=0))},En=(e,t)=>{Ut(e,e.block_start>=0?e.block_start:-1,e.strstart-e.block_start,t),e.block_start=e.strstart,An(e.strm)},xn=(e,t)=>{e.pending_buf[e.pending++]=t},Sn=(e,t)=>{e.pending_buf[e.pending++]=t>>>8&255,e.pending_buf[e.pending++]=255&t},Tn=(e,t,n,s)=>{let r=e.avail_in;return r>s&&(r=s),0===r?0:(e.avail_in-=r,t.set(e.input.subarray(e.next_in,e.next_in+r),n),1===e.state.wrap?e.adler=Mt(e.adler,t,r,n):2===e.state.wrap&&(e.adler=Yt(e.adler,t,r,n)),e.next_in+=r,e.total_in+=r,r)},kn=(e,t)=>{let n,s,r=e.max_chain_length,a=e.strstart,i=e.prev_length,o=e.nice_match;const l=e.strstart>e.w_size-hn?e.strstart-(e.w_size-hn):0,c=e.window,d=e.w_mask,u=e.prev,f=e.strstart+fn;let h=c[a+i-1],p=c[a+i];e.prev_length>=e.good_match&&(r>>=2),o>e.lookahead&&(o=e.lookahead);do{if(n=t,c[n+i]===p&&c[n+i-1]===h&&c[n]===c[a]&&c[++n]===c[a+1]){a+=2,n++;do{}while(c[++a]===c[++n]&&c[++a]===c[++n]&&c[++a]===c[++n]&&c[++a]===c[++n]&&c[++a]===c[++n]&&c[++a]===c[++n]&&c[++a]===c[++n]&&c[++a]===c[++n]&&a<f);if(s=fn-(f-a),a=f-fn,s>i){if(e.match_start=t,i=s,s>=o)break;h=c[a+i-1],p=c[a+i]}}}while((t=u[t&d])>l&&0!=--r);return i<=e.lookahead?i:e.lookahead},Cn=e=>{const t=e.w_size;let n,s,r;do{if(s=e.window_size-e.lookahead-e.strstart,e.strstart>=t+(t-hn)&&(e.window.set(e.window.subarray(t,t+t-s),0),e.match_start-=t,e.strstart-=t,e.block_start-=t,e.insert>e.strstart&&(e.insert=e.strstart),vn(e),s+=t),0===e.strm.avail_in)break;if(n=Tn(e.strm,e.window,e.strstart+e.lookahead,s),e.lookahead+=n,e.lookahead+e.insert>=3)for(r=e.strstart-e.insert,e.ins_h=e.window[r],e.ins_h=wn(e,e.ins_h,e.window[r+1]);e.insert&&(e.ins_h=wn(e,e.ins_h,e.window[r+3-1]),e.prev[r&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=r,r++,e.insert--,!(e.lookahead+e.insert<3)););}while(e.lookahead<hn&&0!==e.strm.avail_in)},zn=(e,t)=>{let n,s,r,a=e.pending_buf_size-5>e.w_size?e.w_size:e.pending_buf_size-5,i=0,o=e.strm.avail_in;do{if(n=65535,r=e.bi_valid+42>>3,e.strm.avail_out<r)break;if(r=e.strm.avail_out-r,s=e.strstart-e.block_start,n>s+e.strm.avail_in&&(n=s+e.strm.avail_in),n>r&&(n=r),n<a&&(0===n&&t!==Zt||t===qt||n!==s+e.strm.avail_in))break;i=t===Zt&&n===s+e.strm.avail_in?1:0,Xt(e,0,0,i),e.pending_buf[e.pending-4]=n,e.pending_buf[e.pending-3]=n>>8,e.pending_buf[e.pending-2]=~n,e.pending_buf[e.pending-1]=~n>>8,An(e.strm),s&&(s>n&&(s=n),e.strm.output.set(e.window.subarray(e.block_start,e.block_start+s),e.strm.next_out),e.strm.next_out+=s,e.strm.avail_out-=s,e.strm.total_out+=s,e.block_start+=s,n-=s),n&&(Tn(e.strm,e.strm.output,e.strm.next_out,n),e.strm.next_out+=n,e.strm.avail_out-=n,e.strm.total_out+=n)}while(0===i);return o-=e.strm.avail_in,o&&(o>=e.w_size?(e.matches=2,e.window.set(e.strm.input.subarray(e.strm.next_in-e.w_size,e.strm.next_in),0),e.strstart=e.w_size,e.insert=e.strstart):(e.window_size-e.strstart<=o&&(e.strstart-=e.w_size,e.window.set(e.window.subarray(e.w_size,e.w_size+e.strstart),0),e.matches<2&&e.matches++,e.insert>e.strstart&&(e.insert=e.strstart)),e.window.set(e.strm.input.subarray(e.strm.next_in-o,e.strm.next_in),e.strstart),e.strstart+=o,e.insert+=o>e.w_size-e.insert?e.w_size-e.insert:o),e.block_start=e.strstart),e.high_water<e.strstart&&(e.high_water=e.strstart),i?4:t!==qt&&t!==Zt&&0===e.strm.avail_in&&e.strstart===e.block_start?2:(r=e.window_size-e.strstart,e.strm.avail_in>r&&e.block_start>=e.w_size&&(e.block_start-=e.w_size,e.strstart-=e.w_size,e.window.set(e.window.subarray(e.w_size,e.w_size+e.strstart),0),e.matches<2&&e.matches++,r+=e.w_size,e.insert>e.strstart&&(e.insert=e.strstart)),r>e.strm.avail_in&&(r=e.strm.avail_in),r&&(Tn(e.strm,e.window,e.strstart,r),e.strstart+=r,e.insert+=r>e.w_size-e.insert?e.w_size-e.insert:r),e.high_water<e.strstart&&(e.high_water=e.strstart),r=e.bi_valid+42>>3,r=e.pending_buf_size-r>65535?65535:e.pending_buf_size-r,a=r>e.w_size?e.w_size:r,s=e.strstart-e.block_start,(s>=a||(s||t===Zt)&&t!==qt&&0===e.strm.avail_in&&s<=r)&&(n=s>r?r:s,i=t===Zt&&0===e.strm.avail_in&&n===s?1:0,Xt(e,e.block_start,n,i),e.block_start+=n,An(e.strm)),i?3:1)},Pn=(e,t)=>{let n,s;for(;;){if(e.lookahead<hn){if(Cn(e),e.lookahead<hn&&t===qt)return 1;if(0===e.lookahead)break}if(n=0,e.lookahead>=3&&(e.ins_h=wn(e,e.ins_h,e.window[e.strstart+3-1]),n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!==n&&e.strstart-n<=e.w_size-hn&&(e.match_length=kn(e,n)),e.match_length>=3)if(s=Jt(e,e.strstart-e.match_start,e.match_length-3),e.lookahead-=e.match_length,e.match_length<=e.max_lazy_match&&e.lookahead>=3){e.match_length--;do{e.strstart++,e.ins_h=wn(e,e.ins_h,e.window[e.strstart+3-1]),n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart}while(0!=--e.match_length);e.strstart++}else e.strstart+=e.match_length,e.match_length=0,e.ins_h=e.window[e.strstart],e.ins_h=wn(e,e.ins_h,e.window[e.strstart+1]);else s=Jt(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++;if(s&&(En(e,!1),0===e.strm.avail_out))return 1}return e.insert=e.strstart<2?e.strstart:2,t===Zt?(En(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(En(e,!1),0===e.strm.avail_out)?1:2},Fn=(e,t)=>{let n,s,r;for(;;){if(e.lookahead<hn){if(Cn(e),e.lookahead<hn&&t===qt)return 1;if(0===e.lookahead)break}if(n=0,e.lookahead>=3&&(e.ins_h=wn(e,e.ins_h,e.window[e.strstart+3-1]),n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),e.prev_length=e.match_length,e.prev_match=e.match_start,e.match_length=2,0!==n&&e.prev_length<e.max_lazy_match&&e.strstart-n<=e.w_size-hn&&(e.match_length=kn(e,n),e.match_length<=5&&(e.strategy===rn||3===e.match_length&&e.strstart-e.match_start>4096)&&(e.match_length=2)),e.prev_length>=3&&e.match_length<=e.prev_length){r=e.strstart+e.lookahead-3,s=Jt(e,e.strstart-1-e.prev_match,e.prev_length-3),e.lookahead-=e.prev_length-1,e.prev_length-=2;do{++e.strstart<=r&&(e.ins_h=wn(e,e.ins_h,e.window[e.strstart+3-1]),n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart)}while(0!=--e.prev_length);if(e.match_available=0,e.match_length=2,e.strstart++,s&&(En(e,!1),0===e.strm.avail_out))return 1}else if(e.match_available){if(s=Jt(e,0,e.window[e.strstart-1]),s&&En(e,!1),e.strstart++,e.lookahead--,0===e.strm.avail_out)return 1}else e.match_available=1,e.strstart++,e.lookahead--}return e.match_available&&(s=Jt(e,0,e.window[e.strstart-1]),e.match_available=0),e.insert=e.strstart<2?e.strstart:2,t===Zt?(En(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(En(e,!1),0===e.strm.avail_out)?1:2};function Nn(e,t,n,s,r){this.good_length=e,this.max_lazy=t,this.nice_length=n,this.max_chain=s,this.func=r}const Gn=[new Nn(0,0,0,0,zn),new Nn(4,4,8,4,Pn),new Nn(4,5,16,8,Pn),new Nn(4,6,32,32,Pn),new Nn(4,4,16,16,Fn),new Nn(8,16,32,32,Fn),new Nn(8,16,128,128,Fn),new Nn(8,32,128,256,Fn),new Nn(32,128,258,1024,Fn),new Nn(32,258,258,4096,Fn)];function Ln(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=un,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(1146),this.dyn_dtree=new Uint16Array(122),this.bl_tree=new Uint16Array(78),yn(this.dyn_ltree),yn(this.dyn_dtree),yn(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(16),this.heap=new Uint16Array(573),yn(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(573),yn(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}const On=e=>{if(!e)return 1;const t=e.state;return!t||t.strm!==e||t.status!==pn&&57!==t.status&&69!==t.status&&73!==t.status&&91!==t.status&&103!==t.status&&t.status!==_n&&t.status!==mn?1:0},Rn=e=>{if(On(e))return gn(e,en);e.total_in=e.total_out=0,e.data_type=dn;const t=e.state;return t.pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=2===t.wrap?57:t.wrap?pn:_n,e.adler=2===t.wrap?0:1,t.last_flush=-2,It(t),Qt},Mn=e=>{const t=Rn(e);var n;return t===Qt&&((n=e.state).window_size=2*n.w_size,yn(n.head),n.max_lazy_match=Gn[n.level].max_lazy,n.good_match=Gn[n.level].good_length,n.nice_match=Gn[n.level].nice_length,n.max_chain_length=Gn[n.level].max_chain,n.strstart=0,n.block_start=0,n.lookahead=0,n.insert=0,n.match_length=n.prev_length=2,n.match_available=0,n.ins_h=0),t},Bn=(e,t,n,s,r,a)=>{if(!e)return en;let i=1;if(t===sn&&(t=6),s<0?(i=0,s=-s):s>15&&(i=2,s-=16),r<1||r>9||n!==un||s<8||s>15||t<0||t>9||a<0||a>ln||8===s&&1!==i)return gn(e,en);8===s&&(s=9);const o=new Ln;return e.state=o,o.strm=e,o.status=pn,o.wrap=i,o.gzhead=null,o.w_bits=s,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=r+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+3-1)/3),o.window=new Uint8Array(2*o.w_size),o.head=new Uint16Array(o.hash_size),o.prev=new Uint16Array(o.w_size),o.lit_bufsize=1<<r+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new Uint8Array(o.pending_buf_size),o.sym_buf=o.lit_bufsize,o.sym_end=3*(o.lit_bufsize-1),o.level=t,o.strategy=a,o.method=n,Mn(e)};var Yn=Bn,jn=(e,t)=>On(e)||2!==e.state.wrap?en:(e.state.gzhead=t,Qt),Hn=(e,t)=>{if(On(e)||t>Vt||t<0)return e?gn(e,en):en;const n=e.state;if(!e.output||0!==e.avail_in&&!e.input||n.status===mn&&t!==Zt)return gn(e,0===e.avail_out?nn:en);const s=n.last_flush;if(n.last_flush=t,0!==n.pending){if(An(e),0===e.avail_out)return n.last_flush=-1,Qt}else if(0===e.avail_in&&bn(t)<=bn(s)&&t!==Zt)return gn(e,nn);if(n.status===mn&&0!==e.avail_in)return gn(e,nn);if(n.status===pn&&0===n.wrap&&(n.status=_n),n.status===pn){let t=un+(n.w_bits-8<<4)<<8,s=-1;if(s=n.strategy>=an||n.level<2?0:n.level<6?1:6===n.level?2:3,t|=s<<6,0!==n.strstart&&(t|=32),t+=31-t%31,Sn(n,t),0!==n.strstart&&(Sn(n,e.adler>>>16),Sn(n,65535&e.adler)),e.adler=1,n.status=_n,An(e),0!==n.pending)return n.last_flush=-1,Qt}if(57===n.status)if(e.adler=0,xn(n,31),xn(n,139),xn(n,8),n.gzhead)xn(n,(n.gzhead.text?1:0)+(n.gzhead.hcrc?2:0)+(n.gzhead.extra?4:0)+(n.gzhead.name?8:0)+(n.gzhead.comment?16:0)),xn(n,255&n.gzhead.time),xn(n,n.gzhead.time>>8&255),xn(n,n.gzhead.time>>16&255),xn(n,n.gzhead.time>>24&255),xn(n,9===n.level?2:n.strategy>=an||n.level<2?4:0),xn(n,255&n.gzhead.os),n.gzhead.extra&&n.gzhead.extra.length&&(xn(n,255&n.gzhead.extra.length),xn(n,n.gzhead.extra.length>>8&255)),n.gzhead.hcrc&&(e.adler=Yt(e.adler,n.pending_buf,n.pending,0)),n.gzindex=0,n.status=69;else if(xn(n,0),xn(n,0),xn(n,0),xn(n,0),xn(n,0),xn(n,9===n.level?2:n.strategy>=an||n.level<2?4:0),xn(n,3),n.status=_n,An(e),0!==n.pending)return n.last_flush=-1,Qt;if(69===n.status){if(n.gzhead.extra){let t=n.pending,s=(65535&n.gzhead.extra.length)-n.gzindex;for(;n.pending+s>n.pending_buf_size;){let r=n.pending_buf_size-n.pending;if(n.pending_buf.set(n.gzhead.extra.subarray(n.gzindex,n.gzindex+r),n.pending),n.pending=n.pending_buf_size,n.gzhead.hcrc&&n.pending>t&&(e.adler=Yt(e.adler,n.pending_buf,n.pending-t,t)),n.gzindex+=r,An(e),0!==n.pending)return n.last_flush=-1,Qt;t=0,s-=r}let r=new Uint8Array(n.gzhead.extra);n.pending_buf.set(r.subarray(n.gzindex,n.gzindex+s),n.pending),n.pending+=s,n.gzhead.hcrc&&n.pending>t&&(e.adler=Yt(e.adler,n.pending_buf,n.pending-t,t)),n.gzindex=0}n.status=73}if(73===n.status){if(n.gzhead.name){let t,s=n.pending;do{if(n.pending===n.pending_buf_size){if(n.gzhead.hcrc&&n.pending>s&&(e.adler=Yt(e.adler,n.pending_buf,n.pending-s,s)),An(e),0!==n.pending)return n.last_flush=-1,Qt;s=0}t=n.gzindex<n.gzhead.name.length?255&n.gzhead.name.charCodeAt(n.gzindex++):0,xn(n,t)}while(0!==t);n.gzhead.hcrc&&n.pending>s&&(e.adler=Yt(e.adler,n.pending_buf,n.pending-s,s)),n.gzindex=0}n.status=91}if(91===n.status){if(n.gzhead.comment){let t,s=n.pending;do{if(n.pending===n.pending_buf_size){if(n.gzhead.hcrc&&n.pending>s&&(e.adler=Yt(e.adler,n.pending_buf,n.pending-s,s)),An(e),0!==n.pending)return n.last_flush=-1,Qt;s=0}t=n.gzindex<n.gzhead.comment.length?255&n.gzhead.comment.charCodeAt(n.gzindex++):0,xn(n,t)}while(0!==t);n.gzhead.hcrc&&n.pending>s&&(e.adler=Yt(e.adler,n.pending_buf,n.pending-s,s))}n.status=103}if(103===n.status){if(n.gzhead.hcrc){if(n.pending+2>n.pending_buf_size&&(An(e),0!==n.pending))return n.last_flush=-1,Qt;xn(n,255&e.adler),xn(n,e.adler>>8&255),e.adler=0}if(n.status=_n,An(e),0!==n.pending)return n.last_flush=-1,Qt}if(0!==e.avail_in||0!==n.lookahead||t!==qt&&n.status!==mn){let s=0===n.level?zn(n,t):n.strategy===an?((e,t)=>{let n;for(;;){if(0===e.lookahead&&(Cn(e),0===e.lookahead)){if(t===qt)return 1;break}if(e.match_length=0,n=Jt(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++,n&&(En(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,t===Zt?(En(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(En(e,!1),0===e.strm.avail_out)?1:2})(n,t):n.strategy===on?((e,t)=>{let n,s,r,a;const i=e.window;for(;;){if(e.lookahead<=fn){if(Cn(e),e.lookahead<=fn&&t===qt)return 1;if(0===e.lookahead)break}if(e.match_length=0,e.lookahead>=3&&e.strstart>0&&(r=e.strstart-1,s=i[r],s===i[++r]&&s===i[++r]&&s===i[++r])){a=e.strstart+fn;do{}while(s===i[++r]&&s===i[++r]&&s===i[++r]&&s===i[++r]&&s===i[++r]&&s===i[++r]&&s===i[++r]&&s===i[++r]&&r<a);e.match_length=fn-(a-r),e.match_length>e.lookahead&&(e.match_length=e.lookahead)}if(e.match_length>=3?(n=Jt(e,1,e.match_length-3),e.lookahead-=e.match_length,e.strstart+=e.match_length,e.match_length=0):(n=Jt(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++),n&&(En(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,t===Zt?(En(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(En(e,!1),0===e.strm.avail_out)?1:2})(n,t):Gn[n.level].func(n,t);if(3!==s&&4!==s||(n.status=mn),1===s||3===s)return 0===e.avail_out&&(n.last_flush=-1),Qt;if(2===s&&(t===Kt?Dt(n):t!==Vt&&(Xt(n,0,0,!1),t===Wt&&(yn(n.head),0===n.lookahead&&(n.strstart=0,n.block_start=0,n.insert=0))),An(e),0===e.avail_out))return n.last_flush=-1,Qt}return t!==Zt?Qt:n.wrap<=0?$t:(2===n.wrap?(xn(n,255&e.adler),xn(n,e.adler>>8&255),xn(n,e.adler>>16&255),xn(n,e.adler>>24&255),xn(n,255&e.total_in),xn(n,e.total_in>>8&255),xn(n,e.total_in>>16&255),xn(n,e.total_in>>24&255)):(Sn(n,e.adler>>>16),Sn(n,65535&e.adler)),An(e),n.wrap>0&&(n.wrap=-n.wrap),0!==n.pending?Qt:$t)},In=e=>{if(On(e))return en;const t=e.state.status;return e.state=null,t===_n?gn(e,tn):Qt},Xn=(e,t)=>{let n=t.length;if(On(e))return en;const s=e.state,r=s.wrap;if(2===r||1===r&&s.status!==pn||s.lookahead)return en;if(1===r&&(e.adler=Mt(e.adler,t,n,0)),s.wrap=0,n>=s.w_size){0===r&&(yn(s.head),s.strstart=0,s.block_start=0,s.insert=0);let e=new Uint8Array(s.w_size);e.set(t.subarray(n-s.w_size,n),0),t=e,n=s.w_size}const a=e.avail_in,i=e.next_in,o=e.input;for(e.avail_in=n,e.next_in=0,e.input=t,Cn(s);s.lookahead>=3;){let e=s.strstart,t=s.lookahead-2;do{s.ins_h=wn(s,s.ins_h,s.window[e+3-1]),s.prev[e&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=e,e++}while(--t);s.strstart=e,s.lookahead=2,Cn(s)}return s.strstart+=s.lookahead,s.block_start=s.strstart,s.insert=s.lookahead,s.lookahead=0,s.match_length=s.prev_length=2,s.match_available=0,e.next_in=i,e.input=o,e.avail_in=a,s.wrap=r,Qt};const Un=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var Jn=function(e){const t=Array.prototype.slice.call(arguments,1);for(;t.length;){const n=t.shift();if(n){if("object"!=typeof n)throw new TypeError(n+"must be non-object");for(const t in n)Un(n,t)&&(e[t]=n[t])}}return e},Dn=e=>{let t=0;for(let n=0,s=e.length;n<s;n++)t+=e[n].length;const n=new Uint8Array(t);for(let t=0,s=0,r=e.length;t<r;t++){let r=e[t];n.set(r,s),s+=r.length}return n};let qn=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(e){qn=!1}const Kn=new Uint8Array(256);for(let e=0;e<256;e++)Kn[e]=e>=252?6:e>=248?5:e>=240?4:e>=224?3:e>=192?2:1;Kn[254]=Kn[254]=1;var Wn=e=>{if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(e);let t,n,s,r,a,i=e.length,o=0;for(r=0;r<i;r++)n=e.charCodeAt(r),55296==(64512&n)&&r+1<i&&(s=e.charCodeAt(r+1),56320==(64512&s)&&(n=65536+(n-55296<<10)+(s-56320),r++)),o+=n<128?1:n<2048?2:n<65536?3:4;for(t=new Uint8Array(o),a=0,r=0;a<o;r++)n=e.charCodeAt(r),55296==(64512&n)&&r+1<i&&(s=e.charCodeAt(r+1),56320==(64512&s)&&(n=65536+(n-55296<<10)+(s-56320),r++)),n<128?t[a++]=n:n<2048?(t[a++]=192|n>>>6,t[a++]=128|63&n):n<65536?(t[a++]=224|n>>>12,t[a++]=128|n>>>6&63,t[a++]=128|63&n):(t[a++]=240|n>>>18,t[a++]=128|n>>>12&63,t[a++]=128|n>>>6&63,t[a++]=128|63&n);return t},Zn=(e,t)=>{const n=t||e.length;if("function"==typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(e.subarray(0,t));let s,r;const a=new Array(2*n);for(r=0,s=0;s<n;){let t=e[s++];if(t<128){a[r++]=t;continue}let i=Kn[t];if(i>4)a[r++]=65533,s+=i-1;else{for(t&=2===i?31:3===i?15:7;i>1&&s<n;)t=t<<6|63&e[s++],i--;i>1?a[r++]=65533:t<65536?a[r++]=t:(t-=65536,a[r++]=55296|t>>10&1023,a[r++]=56320|1023&t)}}return((e,t)=>{if(t<65534&&e.subarray&&qn)return String.fromCharCode.apply(null,e.length===t?e:e.subarray(0,t));let n="";for(let s=0;s<t;s++)n+=String.fromCharCode(e[s]);return n})(a,r)},Vn=(e,t)=>{(t=t||e.length)>e.length&&(t=e.length);let n=t-1;for(;n>=0&&128==(192&e[n]);)n--;return n<0||0===n?t:n+Kn[e[n]]>t?n:t},Qn=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0};const $n=Object.prototype.toString,{Z_NO_FLUSH:es,Z_SYNC_FLUSH:ts,Z_FULL_FLUSH:ns,Z_FINISH:ss,Z_OK:rs,Z_STREAM_END:as,Z_DEFAULT_COMPRESSION:is,Z_DEFAULT_STRATEGY:os,Z_DEFLATED:ls}=Ht;function cs(e){this.options=Jn({level:is,method:ls,chunkSize:16384,windowBits:15,memLevel:8,strategy:os},e||{});let t=this.options;t.raw&&t.windowBits>0?t.windowBits=-t.windowBits:t.gzip&&t.windowBits>0&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new Qn,this.strm.avail_out=0;let n=Yn(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(n!==rs)throw new Error(jt[n]);if(t.header&&jn(this.strm,t.header),t.dictionary){let e;if(e="string"==typeof t.dictionary?Wn(t.dictionary):"[object ArrayBuffer]"===$n.call(t.dictionary)?new Uint8Array(t.dictionary):t.dictionary,n=Xn(this.strm,e),n!==rs)throw new Error(jt[n]);this._dict_set=!0}}function ds(e,t){const n=new cs(t);if(n.push(e,!0),n.err)throw n.msg||jt[n.err];return n.result}cs.prototype.push=function(e,t){const n=this.strm,s=this.options.chunkSize;let r,a;if(this.ended)return!1;for(a=t===~~t?t:!0===t?ss:es,"string"==typeof e?n.input=Wn(e):"[object ArrayBuffer]"===$n.call(e)?n.input=new Uint8Array(e):n.input=e,n.next_in=0,n.avail_in=n.input.length;;)if(0===n.avail_out&&(n.output=new Uint8Array(s),n.next_out=0,n.avail_out=s),(a===ts||a===ns)&&n.avail_out<=6)this.onData(n.output.subarray(0,n.next_out)),n.avail_out=0;else{if(r=Hn(n,a),r===as)return n.next_out>0&&this.onData(n.output.subarray(0,n.next_out)),r=In(this.strm),this.onEnd(r),this.ended=!0,r===rs;if(0!==n.avail_out){if(a>0&&n.next_out>0)this.onData(n.output.subarray(0,n.next_out)),n.avail_out=0;else if(0===n.avail_in)break}else this.onData(n.output)}return!0},cs.prototype.onData=function(e){this.chunks.push(e)},cs.prototype.onEnd=function(e){e===rs&&(this.result=Dn(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg};var us={Deflate:cs,deflate:ds,deflateRaw:function(e,t){return(t=t||{}).raw=!0,ds(e,t)},gzip:function(e,t){return(t=t||{}).gzip=!0,ds(e,t)},constants:Ht};const fs=16209;var hs=function(e,t){let n,s,r,a,i,o,l,c,d,u,f,h,p,_,m,g,b,y,v,w,A,E,x,S;const T=e.state;n=e.next_in,x=e.input,s=n+(e.avail_in-5),r=e.next_out,S=e.output,a=r-(t-e.avail_out),i=r+(e.avail_out-257),o=T.dmax,l=T.wsize,c=T.whave,d=T.wnext,u=T.window,f=T.hold,h=T.bits,p=T.lencode,_=T.distcode,m=(1<<T.lenbits)-1,g=(1<<T.distbits)-1;e:do{h<15&&(f+=x[n++]<<h,h+=8,f+=x[n++]<<h,h+=8),b=p[f&m];t:for(;;){if(y=b>>>24,f>>>=y,h-=y,y=b>>>16&255,0===y)S[r++]=65535&b;else{if(!(16&y)){if(64&y){if(32&y){T.mode=16191;break e}e.msg="invalid literal/length code",T.mode=fs;break e}b=p[(65535&b)+(f&(1<<y)-1)];continue t}for(v=65535&b,y&=15,y&&(h<y&&(f+=x[n++]<<h,h+=8),v+=f&(1<<y)-1,f>>>=y,h-=y),h<15&&(f+=x[n++]<<h,h+=8,f+=x[n++]<<h,h+=8),b=_[f&g];;){if(y=b>>>24,f>>>=y,h-=y,y=b>>>16&255,16&y){if(w=65535&b,y&=15,h<y&&(f+=x[n++]<<h,h+=8,h<y&&(f+=x[n++]<<h,h+=8)),w+=f&(1<<y)-1,w>o){e.msg="invalid distance too far back",T.mode=fs;break e}if(f>>>=y,h-=y,y=r-a,w>y){if(y=w-y,y>c&&T.sane){e.msg="invalid distance too far back",T.mode=fs;break e}if(A=0,E=u,0===d){if(A+=l-y,y<v){v-=y;do{S[r++]=u[A++]}while(--y);A=r-w,E=S}}else if(d<y){if(A+=l+d-y,y-=d,y<v){v-=y;do{S[r++]=u[A++]}while(--y);if(A=0,d<v){y=d,v-=y;do{S[r++]=u[A++]}while(--y);A=r-w,E=S}}}else if(A+=d-y,y<v){v-=y;do{S[r++]=u[A++]}while(--y);A=r-w,E=S}for(;v>2;)S[r++]=E[A++],S[r++]=E[A++],S[r++]=E[A++],v-=3;v&&(S[r++]=E[A++],v>1&&(S[r++]=E[A++]))}else{A=r-w;do{S[r++]=S[A++],S[r++]=S[A++],S[r++]=S[A++],v-=3}while(v>2);v&&(S[r++]=S[A++],v>1&&(S[r++]=S[A++]))}break}if(64&y){e.msg="invalid distance code",T.mode=fs;break e}b=_[(65535&b)+(f&(1<<y)-1)]}}break}}while(n<s&&r<i);v=h>>3,n-=v,h-=v<<3,f&=(1<<h)-1,e.next_in=n,e.next_out=r,e.avail_in=n<s?s-n+5:5-(n-s),e.avail_out=r<i?i-r+257:257-(r-i),T.hold=f,T.bits=h};const ps=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),_s=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),ms=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),gs=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]);var bs=(e,t,n,s,r,a,i,o)=>{const l=o.bits;let c,d,u,f,h,p,_=0,m=0,g=0,b=0,y=0,v=0,w=0,A=0,E=0,x=0,S=null;const T=new Uint16Array(16),k=new Uint16Array(16);let C,z,P,F=null;for(_=0;_<=15;_++)T[_]=0;for(m=0;m<s;m++)T[t[n+m]]++;for(y=l,b=15;b>=1&&0===T[b];b--);if(y>b&&(y=b),0===b)return r[a++]=20971520,r[a++]=20971520,o.bits=1,0;for(g=1;g<b&&0===T[g];g++);for(y<g&&(y=g),A=1,_=1;_<=15;_++)if(A<<=1,A-=T[_],A<0)return-1;if(A>0&&(0===e||1!==b))return-1;for(k[1]=0,_=1;_<15;_++)k[_+1]=k[_]+T[_];for(m=0;m<s;m++)0!==t[n+m]&&(i[k[t[n+m]]++]=m);if(0===e?(S=F=i,p=20):1===e?(S=ps,F=_s,p=257):(S=ms,F=gs,p=0),x=0,m=0,_=g,h=a,v=y,w=0,u=-1,E=1<<y,f=E-1,1===e&&E>852||2===e&&E>592)return 1;for(;;){C=_-w,i[m]+1<p?(z=0,P=i[m]):i[m]>=p?(z=F[i[m]-p],P=S[i[m]-p]):(z=96,P=0),c=1<<_-w,d=1<<v,g=d;do{d-=c,r[h+(x>>w)+d]=C<<24|z<<16|P}while(0!==d);for(c=1<<_-1;x&c;)c>>=1;if(0!==c?(x&=c-1,x+=c):x=0,m++,0==--T[_]){if(_===b)break;_=t[n+i[m]]}if(_>y&&(x&f)!==u){for(0===w&&(w=y),h+=g,v=_-w,A=1<<v;v+w<b&&(A-=T[v+w],!(A<=0));)v++,A<<=1;if(E+=1<<v,1===e&&E>852||2===e&&E>592)return 1;u=x&f,r[u]=y<<24|v<<16|h-a}}return 0!==x&&(r[h+x]=_-w<<24|64<<16),o.bits=y,0};const{Z_FINISH:ys,Z_BLOCK:vs,Z_TREES:ws,Z_OK:As,Z_STREAM_END:Es,Z_NEED_DICT:xs,Z_STREAM_ERROR:Ss,Z_DATA_ERROR:Ts,Z_MEM_ERROR:ks,Z_BUF_ERROR:Cs,Z_DEFLATED:zs}=Ht,Ps=16180,Fs=16190,Ns=16191,Gs=16192,Ls=16194,Os=16199,Rs=16200,Ms=16206,Bs=16209,Ys=e=>(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24);function js(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const Hs=e=>{if(!e)return 1;const t=e.state;return!t||t.strm!==e||t.mode<Ps||t.mode>16211?1:0},Is=e=>{if(Hs(e))return Ss;const t=e.state;return e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=Ps,t.last=0,t.havedict=0,t.flags=-1,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new Int32Array(852),t.distcode=t.distdyn=new Int32Array(592),t.sane=1,t.back=-1,As},Xs=e=>{if(Hs(e))return Ss;const t=e.state;return t.wsize=0,t.whave=0,t.wnext=0,Is(e)},Us=(e,t)=>{let n;if(Hs(e))return Ss;const s=e.state;return t<0?(n=0,t=-t):(n=5+(t>>4),t<48&&(t&=15)),t&&(t<8||t>15)?Ss:(null!==s.window&&s.wbits!==t&&(s.window=null),s.wrap=n,s.wbits=t,Xs(e))},Js=(e,t)=>{if(!e)return Ss;const n=new js;e.state=n,n.strm=e,n.window=null,n.mode=Ps;const s=Us(e,t);return s!==As&&(e.state=null),s};let Ds,qs,Ks=!0;const Ws=e=>{if(Ks){Ds=new Int32Array(512),qs=new Int32Array(32);let t=0;for(;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(bs(1,e.lens,0,288,Ds,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;bs(2,e.lens,0,32,qs,0,e.work,{bits:5}),Ks=!1}e.lencode=Ds,e.lenbits=9,e.distcode=qs,e.distbits=5},Zs=(e,t,n,s)=>{let r;const a=e.state;return null===a.window&&(a.wsize=1<<a.wbits,a.wnext=0,a.whave=0,a.window=new Uint8Array(a.wsize)),s>=a.wsize?(a.window.set(t.subarray(n-a.wsize,n),0),a.wnext=0,a.whave=a.wsize):(r=a.wsize-a.wnext,r>s&&(r=s),a.window.set(t.subarray(n-s,n-s+r),a.wnext),(s-=r)?(a.window.set(t.subarray(n-s,n),0),a.wnext=s,a.whave=a.wsize):(a.wnext+=r,a.wnext===a.wsize&&(a.wnext=0),a.whave<a.wsize&&(a.whave+=r))),0};var Vs=Xs,Qs=Js,$s=(e,t)=>{let n,s,r,a,i,o,l,c,d,u,f,h,p,_,m,g,b,y,v,w,A,E,x=0;const S=new Uint8Array(4);let T,k;const C=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(Hs(e)||!e.output||!e.input&&0!==e.avail_in)return Ss;n=e.state,n.mode===Ns&&(n.mode=Gs),i=e.next_out,r=e.output,l=e.avail_out,a=e.next_in,s=e.input,o=e.avail_in,c=n.hold,d=n.bits,u=o,f=l,E=As;e:for(;;)switch(n.mode){case Ps:if(0===n.wrap){n.mode=Gs;break}for(;d<16;){if(0===o)break e;o--,c+=s[a++]<<d,d+=8}if(2&n.wrap&&35615===c){0===n.wbits&&(n.wbits=15),n.check=0,S[0]=255&c,S[1]=c>>>8&255,n.check=Yt(n.check,S,2,0),c=0,d=0,n.mode=16181;break}if(n.head&&(n.head.done=!1),!(1&n.wrap)||(((255&c)<<8)+(c>>8))%31){e.msg="incorrect header check",n.mode=Bs;break}if((15&c)!==zs){e.msg="unknown compression method",n.mode=Bs;break}if(c>>>=4,d-=4,A=8+(15&c),0===n.wbits&&(n.wbits=A),A>15||A>n.wbits){e.msg="invalid window size",n.mode=Bs;break}n.dmax=1<<n.wbits,n.flags=0,e.adler=n.check=1,n.mode=512&c?16189:Ns,c=0,d=0;break;case 16181:for(;d<16;){if(0===o)break e;o--,c+=s[a++]<<d,d+=8}if(n.flags=c,(255&n.flags)!==zs){e.msg="unknown compression method",n.mode=Bs;break}if(57344&n.flags){e.msg="unknown header flags set",n.mode=Bs;break}n.head&&(n.head.text=c>>8&1),512&n.flags&&4&n.wrap&&(S[0]=255&c,S[1]=c>>>8&255,n.check=Yt(n.check,S,2,0)),c=0,d=0,n.mode=16182;case 16182:for(;d<32;){if(0===o)break e;o--,c+=s[a++]<<d,d+=8}n.head&&(n.head.time=c),512&n.flags&&4&n.wrap&&(S[0]=255&c,S[1]=c>>>8&255,S[2]=c>>>16&255,S[3]=c>>>24&255,n.check=Yt(n.check,S,4,0)),c=0,d=0,n.mode=16183;case 16183:for(;d<16;){if(0===o)break e;o--,c+=s[a++]<<d,d+=8}n.head&&(n.head.xflags=255&c,n.head.os=c>>8),512&n.flags&&4&n.wrap&&(S[0]=255&c,S[1]=c>>>8&255,n.check=Yt(n.check,S,2,0)),c=0,d=0,n.mode=16184;case 16184:if(1024&n.flags){for(;d<16;){if(0===o)break e;o--,c+=s[a++]<<d,d+=8}n.length=c,n.head&&(n.head.extra_len=c),512&n.flags&&4&n.wrap&&(S[0]=255&c,S[1]=c>>>8&255,n.check=Yt(n.check,S,2,0)),c=0,d=0}else n.head&&(n.head.extra=null);n.mode=16185;case 16185:if(1024&n.flags&&(h=n.length,h>o&&(h=o),h&&(n.head&&(A=n.head.extra_len-n.length,n.head.extra||(n.head.extra=new Uint8Array(n.head.extra_len)),n.head.extra.set(s.subarray(a,a+h),A)),512&n.flags&&4&n.wrap&&(n.check=Yt(n.check,s,h,a)),o-=h,a+=h,n.length-=h),n.length))break e;n.length=0,n.mode=16186;case 16186:if(2048&n.flags){if(0===o)break e;h=0;do{A=s[a+h++],n.head&&A&&n.length<65536&&(n.head.name+=String.fromCharCode(A))}while(A&&h<o);if(512&n.flags&&4&n.wrap&&(n.check=Yt(n.check,s,h,a)),o-=h,a+=h,A)break e}else n.head&&(n.head.name=null);n.length=0,n.mode=16187;case 16187:if(4096&n.flags){if(0===o)break e;h=0;do{A=s[a+h++],n.head&&A&&n.length<65536&&(n.head.comment+=String.fromCharCode(A))}while(A&&h<o);if(512&n.flags&&4&n.wrap&&(n.check=Yt(n.check,s,h,a)),o-=h,a+=h,A)break e}else n.head&&(n.head.comment=null);n.mode=16188;case 16188:if(512&n.flags){for(;d<16;){if(0===o)break e;o--,c+=s[a++]<<d,d+=8}if(4&n.wrap&&c!==(65535&n.check)){e.msg="header crc mismatch",n.mode=Bs;break}c=0,d=0}n.head&&(n.head.hcrc=n.flags>>9&1,n.head.done=!0),e.adler=n.check=0,n.mode=Ns;break;case 16189:for(;d<32;){if(0===o)break e;o--,c+=s[a++]<<d,d+=8}e.adler=n.check=Ys(c),c=0,d=0,n.mode=Fs;case Fs:if(0===n.havedict)return e.next_out=i,e.avail_out=l,e.next_in=a,e.avail_in=o,n.hold=c,n.bits=d,xs;e.adler=n.check=1,n.mode=Ns;case Ns:if(t===vs||t===ws)break e;case Gs:if(n.last){c>>>=7&d,d-=7&d,n.mode=Ms;break}for(;d<3;){if(0===o)break e;o--,c+=s[a++]<<d,d+=8}switch(n.last=1&c,c>>>=1,d-=1,3&c){case 0:n.mode=16193;break;case 1:if(Ws(n),n.mode=Os,t===ws){c>>>=2,d-=2;break e}break;case 2:n.mode=16196;break;case 3:e.msg="invalid block type",n.mode=Bs}c>>>=2,d-=2;break;case 16193:for(c>>>=7&d,d-=7&d;d<32;){if(0===o)break e;o--,c+=s[a++]<<d,d+=8}if((65535&c)!=(c>>>16^65535)){e.msg="invalid stored block lengths",n.mode=Bs;break}if(n.length=65535&c,c=0,d=0,n.mode=Ls,t===ws)break e;case Ls:n.mode=16195;case 16195:if(h=n.length,h){if(h>o&&(h=o),h>l&&(h=l),0===h)break e;r.set(s.subarray(a,a+h),i),o-=h,a+=h,l-=h,i+=h,n.length-=h;break}n.mode=Ns;break;case 16196:for(;d<14;){if(0===o)break e;o--,c+=s[a++]<<d,d+=8}if(n.nlen=257+(31&c),c>>>=5,d-=5,n.ndist=1+(31&c),c>>>=5,d-=5,n.ncode=4+(15&c),c>>>=4,d-=4,n.nlen>286||n.ndist>30){e.msg="too many length or distance symbols",n.mode=Bs;break}n.have=0,n.mode=16197;case 16197:for(;n.have<n.ncode;){for(;d<3;){if(0===o)break e;o--,c+=s[a++]<<d,d+=8}n.lens[C[n.have++]]=7&c,c>>>=3,d-=3}for(;n.have<19;)n.lens[C[n.have++]]=0;if(n.lencode=n.lendyn,n.lenbits=7,T={bits:n.lenbits},E=bs(0,n.lens,0,19,n.lencode,0,n.work,T),n.lenbits=T.bits,E){e.msg="invalid code lengths set",n.mode=Bs;break}n.have=0,n.mode=16198;case 16198:for(;n.have<n.nlen+n.ndist;){for(;x=n.lencode[c&(1<<n.lenbits)-1],m=x>>>24,g=x>>>16&255,b=65535&x,!(m<=d);){if(0===o)break e;o--,c+=s[a++]<<d,d+=8}if(b<16)c>>>=m,d-=m,n.lens[n.have++]=b;else{if(16===b){for(k=m+2;d<k;){if(0===o)break e;o--,c+=s[a++]<<d,d+=8}if(c>>>=m,d-=m,0===n.have){e.msg="invalid bit length repeat",n.mode=Bs;break}A=n.lens[n.have-1],h=3+(3&c),c>>>=2,d-=2}else if(17===b){for(k=m+3;d<k;){if(0===o)break e;o--,c+=s[a++]<<d,d+=8}c>>>=m,d-=m,A=0,h=3+(7&c),c>>>=3,d-=3}else{for(k=m+7;d<k;){if(0===o)break e;o--,c+=s[a++]<<d,d+=8}c>>>=m,d-=m,A=0,h=11+(127&c),c>>>=7,d-=7}if(n.have+h>n.nlen+n.ndist){e.msg="invalid bit length repeat",n.mode=Bs;break}for(;h--;)n.lens[n.have++]=A}}if(n.mode===Bs)break;if(0===n.lens[256]){e.msg="invalid code -- missing end-of-block",n.mode=Bs;break}if(n.lenbits=9,T={bits:n.lenbits},E=bs(1,n.lens,0,n.nlen,n.lencode,0,n.work,T),n.lenbits=T.bits,E){e.msg="invalid literal/lengths set",n.mode=Bs;break}if(n.distbits=6,n.distcode=n.distdyn,T={bits:n.distbits},E=bs(2,n.lens,n.nlen,n.ndist,n.distcode,0,n.work,T),n.distbits=T.bits,E){e.msg="invalid distances set",n.mode=Bs;break}if(n.mode=Os,t===ws)break e;case Os:n.mode=Rs;case Rs:if(o>=6&&l>=258){e.next_out=i,e.avail_out=l,e.next_in=a,e.avail_in=o,n.hold=c,n.bits=d,hs(e,f),i=e.next_out,r=e.output,l=e.avail_out,a=e.next_in,s=e.input,o=e.avail_in,c=n.hold,d=n.bits,n.mode===Ns&&(n.back=-1);break}for(n.back=0;x=n.lencode[c&(1<<n.lenbits)-1],m=x>>>24,g=x>>>16&255,b=65535&x,!(m<=d);){if(0===o)break e;o--,c+=s[a++]<<d,d+=8}if(g&&!(240&g)){for(y=m,v=g,w=b;x=n.lencode[w+((c&(1<<y+v)-1)>>y)],m=x>>>24,g=x>>>16&255,b=65535&x,!(y+m<=d);){if(0===o)break e;o--,c+=s[a++]<<d,d+=8}c>>>=y,d-=y,n.back+=y}if(c>>>=m,d-=m,n.back+=m,n.length=b,0===g){n.mode=16205;break}if(32&g){n.back=-1,n.mode=Ns;break}if(64&g){e.msg="invalid literal/length code",n.mode=Bs;break}n.extra=15&g,n.mode=16201;case 16201:if(n.extra){for(k=n.extra;d<k;){if(0===o)break e;o--,c+=s[a++]<<d,d+=8}n.length+=c&(1<<n.extra)-1,c>>>=n.extra,d-=n.extra,n.back+=n.extra}n.was=n.length,n.mode=16202;case 16202:for(;x=n.distcode[c&(1<<n.distbits)-1],m=x>>>24,g=x>>>16&255,b=65535&x,!(m<=d);){if(0===o)break e;o--,c+=s[a++]<<d,d+=8}if(!(240&g)){for(y=m,v=g,w=b;x=n.distcode[w+((c&(1<<y+v)-1)>>y)],m=x>>>24,g=x>>>16&255,b=65535&x,!(y+m<=d);){if(0===o)break e;o--,c+=s[a++]<<d,d+=8}c>>>=y,d-=y,n.back+=y}if(c>>>=m,d-=m,n.back+=m,64&g){e.msg="invalid distance code",n.mode=Bs;break}n.offset=b,n.extra=15&g,n.mode=16203;case 16203:if(n.extra){for(k=n.extra;d<k;){if(0===o)break e;o--,c+=s[a++]<<d,d+=8}n.offset+=c&(1<<n.extra)-1,c>>>=n.extra,d-=n.extra,n.back+=n.extra}if(n.offset>n.dmax){e.msg="invalid distance too far back",n.mode=Bs;break}n.mode=16204;case 16204:if(0===l)break e;if(h=f-l,n.offset>h){if(h=n.offset-h,h>n.whave&&n.sane){e.msg="invalid distance too far back",n.mode=Bs;break}h>n.wnext?(h-=n.wnext,p=n.wsize-h):p=n.wnext-h,h>n.length&&(h=n.length),_=n.window}else _=r,p=i-n.offset,h=n.length;h>l&&(h=l),l-=h,n.length-=h;do{r[i++]=_[p++]}while(--h);0===n.length&&(n.mode=Rs);break;case 16205:if(0===l)break e;r[i++]=n.length,l--,n.mode=Rs;break;case Ms:if(n.wrap){for(;d<32;){if(0===o)break e;o--,c|=s[a++]<<d,d+=8}if(f-=l,e.total_out+=f,n.total+=f,4&n.wrap&&f&&(e.adler=n.check=n.flags?Yt(n.check,r,f,i-f):Mt(n.check,r,f,i-f)),f=l,4&n.wrap&&(n.flags?c:Ys(c))!==n.check){e.msg="incorrect data check",n.mode=Bs;break}c=0,d=0}n.mode=16207;case 16207:if(n.wrap&&n.flags){for(;d<32;){if(0===o)break e;o--,c+=s[a++]<<d,d+=8}if(4&n.wrap&&c!==(4294967295&n.total)){e.msg="incorrect length check",n.mode=Bs;break}c=0,d=0}n.mode=16208;case 16208:E=Es;break e;case Bs:E=Ts;break e;case 16210:return ks;default:return Ss}return e.next_out=i,e.avail_out=l,e.next_in=a,e.avail_in=o,n.hold=c,n.bits=d,(n.wsize||f!==e.avail_out&&n.mode<Bs&&(n.mode<Ms||t!==ys))&&Zs(e,e.output,e.next_out,f-e.avail_out),u-=e.avail_in,f-=e.avail_out,e.total_in+=u,e.total_out+=f,n.total+=f,4&n.wrap&&f&&(e.adler=n.check=n.flags?Yt(n.check,r,f,e.next_out-f):Mt(n.check,r,f,e.next_out-f)),e.data_type=n.bits+(n.last?64:0)+(n.mode===Ns?128:0)+(n.mode===Os||n.mode===Ls?256:0),(0===u&&0===f||t===ys)&&E===As&&(E=Cs),E},er=e=>{if(Hs(e))return Ss;let t=e.state;return t.window&&(t.window=null),e.state=null,As},tr=(e,t)=>{if(Hs(e))return Ss;const n=e.state;return 2&n.wrap?(n.head=t,t.done=!1,As):Ss},nr=(e,t)=>{const n=t.length;let s,r,a;return Hs(e)?Ss:(s=e.state,0!==s.wrap&&s.mode!==Fs?Ss:s.mode===Fs&&(r=1,r=Mt(r,t,n,0),r!==s.check)?Ts:(a=Zs(e,t,n,n),a?(s.mode=16210,ks):(s.havedict=1,As)))},sr=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1};const rr=Object.prototype.toString,{Z_NO_FLUSH:ar,Z_FINISH:ir,Z_OK:or,Z_STREAM_END:lr,Z_NEED_DICT:cr,Z_STREAM_ERROR:dr,Z_DATA_ERROR:ur,Z_MEM_ERROR:fr}=Ht;function hr(e){this.options=Jn({chunkSize:65536,windowBits:15,to:""},e||{});const t=this.options;t.raw&&t.windowBits>=0&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(t.windowBits>=0&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),t.windowBits>15&&t.windowBits<48&&(15&t.windowBits||(t.windowBits|=15)),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new Qn,this.strm.avail_out=0;let n=Qs(this.strm,t.windowBits);if(n!==or)throw new Error(jt[n]);if(this.header=new sr,tr(this.strm,this.header),t.dictionary&&("string"==typeof t.dictionary?t.dictionary=Wn(t.dictionary):"[object ArrayBuffer]"===rr.call(t.dictionary)&&(t.dictionary=new Uint8Array(t.dictionary)),t.raw&&(n=nr(this.strm,t.dictionary),n!==or)))throw new Error(jt[n])}function pr(e,t){const n=new hr(t);if(n.push(e),n.err)throw n.msg||jt[n.err];return n.result}hr.prototype.push=function(e,t){const n=this.strm,s=this.options.chunkSize,r=this.options.dictionary;let a,i,o;if(this.ended)return!1;for(i=t===~~t?t:!0===t?ir:ar,"[object ArrayBuffer]"===rr.call(e)?n.input=new Uint8Array(e):n.input=e,n.next_in=0,n.avail_in=n.input.length;;){for(0===n.avail_out&&(n.output=new Uint8Array(s),n.next_out=0,n.avail_out=s),a=$s(n,i),a===cr&&r&&(a=nr(n,r),a===or?a=$s(n,i):a===ur&&(a=cr));n.avail_in>0&&a===lr&&n.state.wrap>0&&0!==e[n.next_in];)Vs(n),a=$s(n,i);switch(a){case dr:case ur:case cr:case fr:return this.onEnd(a),this.ended=!0,!1}if(o=n.avail_out,n.next_out&&(0===n.avail_out||a===lr))if("string"===this.options.to){let e=Vn(n.output,n.next_out),t=n.next_out-e,r=Zn(n.output,e);n.next_out=t,n.avail_out=s-t,t&&n.output.set(n.output.subarray(e,e+t),0),this.onData(r)}else this.onData(n.output.length===n.next_out?n.output:n.output.subarray(0,n.next_out));if(a!==or||0!==o){if(a===lr)return a=er(this.strm),this.onEnd(a),this.ended=!0,!0;if(0===n.avail_in)break}}return!0},hr.prototype.onData=function(e){this.chunks.push(e)},hr.prototype.onEnd=function(e){e===or&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=Dn(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg};var _r={Inflate:hr,inflate:pr,inflateRaw:function(e,t){return(t=t||{}).raw=!0,pr(e,t)},ungzip:pr,constants:Ht};const{Deflate:mr,deflate:gr,deflateRaw:br,gzip:yr}=us,{Inflate:vr,inflate:wr,inflateRaw:Ar,ungzip:Er}=_r;var xr,Sr,Tr=wr,kr=r(8891).Buffer;function Cr(e){const t=e.functions.filter((e=>e.isInitializer));return t.length>1?t.find((e=>"constructor"===e.name))??t.find((e=>"initializer"===e.name))??t.find((e=>0===e.parameters?.length))??t.find((e=>e.functionType===xr.PRIVATE))??t[0]:t[0]}(Sr=xr||(xr={})).PRIVATE="private",Sr.PUBLIC="public",Sr.UNCONSTRAINED="unconstrained";var zr=r(4247),Pr=r(8891).Buffer,Fr=r(8891).Buffer;class Nr extends X{constructor(e){if(32!==e.length)throw new Error(`Invalid AztecAddress length ${e.length}.`);super(e)}[i.inspect.custom](){return`AztecAddress<${this.toString()}>`}static zero(){return Nr.ZERO}static fromBuffer(e){return Y(e,Nr)}static fromField(e){return new Nr(e.toBuffer())}static fromFields(e){const t=je.asReader(e);return Nr.fromField(t.readField())}static fromBigInt(e){return Nr.fromField(new X(e))}static fromString(e){const t=Fr.from(e.replace(/^0x/i,""),"hex");return new Nr(t)}static random(){return new Nr(super.random().toBuffer())}toJSON(){return{type:"AztecAddress",value:this.toString()}}}function Gr(e){return"struct"===e.kind&&e.path.endsWith("address::AztecAddress")}Nr.ZERO=new Nr(Fr.alloc(32)),O.register("AztecAddress",Nr);class Lr{constructor(e,t){this.returnTypes=e,this.flattened=t}decodeReturn(e){switch(e.kind){case"field":return this.getNextField().toBigInt();case"integer":if("signed"===e.sign)throw new Error("Unsupported type: signed integer");return this.getNextField().toBigInt();case"boolean":return!this.getNextField().isZero();case"array":{const t=[];for(let n=0;n<e.length;n+=1)t.push(this.decodeReturn(e.type));return t}case"struct":{const t={};if(Gr(e))return new Nr(this.getNextField().toBuffer());for(const n of e.fields)t[n.name]=this.decodeReturn(n.type);return t}case"string":{const t=[];for(let n=0;n<e.length;n+=1)t.push(this.getNextField().toBigInt());return t}default:throw new Error(`Unsupported type: ${e}`)}}getNextField(){const e=this.flattened.shift();if(!e)throw new Error("Not enough return values");return e}decode(){if(this.returnTypes.length>1)throw new Error("Multiple return values not supported");return 0===this.returnTypes.length?[]:this.decodeReturn(this.returnTypes[0])}}function Or(e,t){return new Lr(e,t.slice()).decode()}class Rr{constructor(e,t,n=!1){this.name=e,this.parameters=t,this.includeNames=n,this.separator=n?", ":","}getParameterType(e){switch(e.kind){case"field":return"Field";case"integer":if("signed"===e.sign)throw new Error("Unsupported type: signed integer");return`u${e.width}`;case"boolean":return"bool";case"array":return`[${this.getParameterType(e.type)};${e.length}]`;case"string":return`str<${e.length}>`;case"struct":return`(${e.fields.map((e=>`${this.decodeParameter(e)}`)).join(this.separator)})`;default:throw new Error(`Unsupported type: ${e}`)}}decodeParameter(e){const t=this.getParameterType(e.type);return this.includeNames?`${e.name}: ${t}`:t}decode(){return`${this.name}(${this.parameters.map((e=>this.decodeParameter(e))).join(this.separator)})`}}var Mr=r(8891).Buffer;class Br{constructor(e,t){this.abi=e,this.args=t,this.flattened=[]}static typeSize(e){switch(e.kind){case"field":case"boolean":case"integer":return 1;case"string":return e.length;case"array":return e.length*Br.typeSize(e.type);case"struct":return e.fields.reduce(((e,t)=>e+Br.typeSize(t.type)),0);default:throw new Error(`Unhandled abi type: ${e}`)}}encodeArgument(e,t,n){if(void 0===t||null==t)throw new Error(`Undefined argument ${n??"unnamed"} of type ${e.kind}`);switch(e.kind){case"field":if("number"==typeof t)this.flattened.push(new X(BigInt(t)));else if("bigint"==typeof t)this.flattened.push(new X(t));else if("string"==typeof t)this.flattened.push(X.fromString(t));else if("boolean"==typeof t)this.flattened.push(new X(t?1n:0n));else{if("object"!=typeof t)throw new Error(`Invalid argument "${t}" of type ${e.kind}`);if(Mr.isBuffer(t))this.flattened.push(X.fromBuffer(t));else{if("function"!=typeof t.toField)throw new Error(`Argument for ${n} cannot be serialized to a field`);this.flattened.push(t.toField())}}break;case"boolean":this.flattened.push(new X(t?1n:0n));break;case"array":for(let s=0;s<e.length;s+=1)this.encodeArgument(e.type,t[s],`${n}[${s}]`);break;case"string":for(let n=0;n<e.length;n+=1){const e=n<t.length?BigInt(t.charCodeAt(n)):0n;this.flattened.push(new X(e))}break;case"struct":{const s=function(e){return function(e){return"struct"===e.kind&&e.path.endsWith("address::EthAddress")}(e)||Gr(e)}(e);if(s&&void 0===t.address&&void 0===t.inner){this.encodeArgument({kind:"field"},t,`${n}.inner`);break}if(s&&void 0!==t.address){this.encodeArgument({kind:"field"},t.address,`${n}.address`);break}if(function(e){return"struct"===e.kind&&e.path.endsWith("types::abis::function_selector::FunctionSelector")}(e)){this.encodeArgument({kind:"integer",sign:"unsigned",width:32},t.value??t,`${n}.inner`);break}if(function(e){return"struct"===e.kind&&1===e.fields.length&&"inner"===e.fields[0].name&&"field"===e.fields[0].type.kind}(e)){this.encodeArgument({kind:"field"},t.inner??t,`${n}.inner`);break}for(const s of e.fields)this.encodeArgument(s.type,t[s.name],`${n}.${s.name}`);break}case"integer":if("string"==typeof t){const e=BigInt(t);this.flattened.push(new X(e))}else this.flattened.push(new X(t));break;default:throw new Error(`Unsupported type: ${e}`)}}encode(){for(let e=0;e<this.abi.parameters.length;e+=1){const t=this.abi.parameters[e];this.encodeArgument(t.type,this.args[e],t.name)}return this.flattened}}function Yr(e,t){return new Br(e,t).encode()}class jr{constructor(e){if(this.value=e,e>2**(8*jr.SIZE)-1)throw new Error(`Selector must fit in ${jr.SIZE} bytes (got value ${e}).`)}isEmpty(){return 0===this.value}toBuffer(e=jr.SIZE){return c(BigInt(this.value),e)}toString(){return"0x"+this.toBuffer().toString("hex")}[i.inspect.custom](){return`Selector<${this.toString()}>`}equals(e){return this.value===e.value}toField(){return new X(BigInt(this.value))}}jr.SIZE=4;var Hr=r(8891).Buffer;class Ir extends jr{static fromBuffer(e){const t=L.asReader(e),n=Number(l(t.readBytes(jr.SIZE)));return new Ir(n)}static fromField(e){return new Ir(Number(e.toBigInt()))}static fromSignature(e){if(/\s/.test(e))throw new Error("Signature cannot contain whitespace");return Ir.fromBuffer(pe(Hr.from(e)).subarray(0,jr.SIZE))}static fromString(e){const t=u(e);if(t.length!==jr.SIZE)throw new Error(`Invalid Selector length ${t.length} (expected ${jr.SIZE}).`);return Ir.fromBuffer(t)}static empty(){return new Ir(0)}static random(){return Ir.fromBuffer(k(jr.SIZE))}}var Xr=r(8891).Buffer;class Ur extends jr{equals(e,t){return"string"==typeof e?this.equals(Ur.fromNameAndParameters(e,t)):"object"==typeof e&&"name"in e?this.equals(Ur.fromNameAndParameters(e.name,e.parameters)):this.value===e.value}static fromBuffer(e){const t=L.asReader(e),n=Number(l(t.readBytes(jr.SIZE)));return new Ur(n)}static fromField(e){return new Ur(Number(e.toBigInt()))}static fromFields(e){const t=je.asReader(e);return Ur.fromField(t.readField())}static fromSignature(e){if(/\s/.test(e))throw new Error("Signature cannot contain whitespace");return Ur.fromBuffer(pe(Xr.from(e)).subarray(0,jr.SIZE))}static fromString(e){const t=u(e);if(t.length!==jr.SIZE)throw new Error(`Invalid Selector length ${t.length} (expected ${jr.SIZE}).`);return Ur.fromBuffer(t)}static empty(){return new Ur(0)}static fromNameAndParameters(e,t){const{name:n,parameters:s}="string"==typeof e?{name:e,parameters:t}:e,r=function(e,t){return new Rr(e,t).decode()}(n,s);return this.fromSignature(r)}static random(){return Ur.fromBuffer(k(jr.SIZE))}toJSON(){return{type:"FunctionSelector",value:this.toString()}}}O.register("FunctionSelector",Ur);var Jr=r(8891).Buffer;class Dr extends jr{static fromBuffer(e){const t=L.asReader(e),n=Number(l(t.readBytes(jr.SIZE)));return new Dr(n)}static fromString(e){const t=e.replace(/^0x/i,""),n=Jr.from(t,"hex");return Dr.fromBuffer(n)}static fromField(e){return new Dr(Number(e.toBigInt()))}static empty(){return new Dr(0)}static random(){return Dr.fromBuffer(k(jr.SIZE))}toJSON(){return{type:"NoteSelector",value:this.toString()}}static fromJSON(e){return Dr.fromString(e.value)}}let qr;O.register("NoteSelector",Dr),new class{constructor(){this.logs=[]}enable(){qr=(...e)=>{this.logs.push([(new Date).toISOString(),...e])}}getLogs(e=0){return e?this.logs.slice(-e):this.logs}clear(e=this.logs.length){this.logs=this.logs.slice(e)}};var Kr=r(8891).Buffer;class Wr{constructor(e,t){this.height=e,this.nodes=t;const n=2**(e+1)-1;if(t.length!==n)throw new Error(`Invalid node count for Merkle tree: got ${t.length} but expected ${n}`)}get root(){return this.nodes[this.nodes.length-1]}get leaves(){return this.nodes.slice(0,2**this.height)}getSiblingPath(e){if(Kr.isBuffer(e))return this.getSiblingPath(this.getIndex(e));const t=e;if(t<0||t>=2**this.height)throw new Error(`Invalid leaf index: got ${t} but leaves count is ${2**this.height}`);const n=this.nodes;let s=Math.ceil(n.length/2),r=0,a=t;const i=[];for(;s>1;){const e=1&a;i.push(n[r+a+(e?-1:1)]),r+=s,s>>=1,a>>=1}return i}getIndex(e){return this.leaves.findIndex((t=>t.equals(e)))}drawTree(){const e=[],t=this.nodes,n=Math.ceil(t.length/2);let s=1,r=n,a=0;for(;r>0;)e.push(t.slice(a,a+r).map((e=>e.toString("hex").slice(0,8)+" ".repeat(9*(s-1))))),a+=r,s<<=1,r>>=1;return e.reverse().map((e=>e.join(" "))).join("\n")}}var Zr=r(8891).Buffer;class Vr{constructor(e){this.height=e,this.zeroHashes=[]}async setHasher(e=Zr.alloc(32),t=async(e,t)=>(await Me([e,t])).toBuffer()){this.hasher=t,this.zeroHashes=[e];for(let e=0;e<this.height;e++){const t=this.zeroHashes[e],n=await this.hasher(t,t);this.zeroHashes.push(n)}}async computeTree(e=[]){if(0===e.length)return new Wr(this.height,[this.zeroHashes[this.zeroHashes.length-1]]);let t=e.slice();for(let n=0;n<this.height;++n){const s=2**(this.height-n),r=[];for(let t=0;t<e.length/2;++t){const s=e[2*t],a=e[2*t+1]||this.zeroHashes[n];if(!this.hasher)throw new Error("MerkleTreeCalculator: setHasher() must be called before computing a tree.");r[t]=await this.hasher(s,a)}t=t.concat(new Array(s-e.length).fill(this.zeroHashes[n]),r),e=r}return new Wr(this.height,t)}async computeTreeRoot(e=[]){if(0===e.length)return this.zeroHashes[this.zeroHashes.length-1];e=e.slice();for(let t=0;t<this.height;++t){let n=0;for(;n<e.length/2;++n){const s=e[2*n],r=e[2*n+1]||this.zeroHashes[t];if(!this.hasher)throw new Error("MerkleTreeCalculator: setHasher() must be called before computing a tree.");e[n]=await this.hasher(s,r)}e=e.slice(0,n)}return e[0]}}var Qr=r(8891).Buffer;const $r=1,ea=(ta=Fe,na=X,e=>j(ta(e),na));var ta,na;async function sa(e){if("privateFunctionRoot"in e&&"unconstrainedFunctionRoot"in e&&"metadataHash"in e){const{privateFunctionRoot:t,unconstrainedFunctionRoot:n,metadataHash:s}=e,r=[t,n,s].map((e=>e.toBuffer()));return ea(Qr.concat([ye($r),...r]))}const t=await ra(e),n=await sa(await ra(e));return y("aztec:circuits:artifact_hash").debug("Computed artifact hash",{artifactHash:n,...t}),n}async function ra(e){const t=await aa(e,xr.PRIVATE),n=await aa(e,xr.UNCONSTRAINED),s=function(e){const t={name:e.name,outputs:e.outputs};return["AuthRegistry","KeyRegistry","GasToken","ContractInstanceDeployer","ContractClassRegisterer"].includes(e.name)?ea(Qr.from(JSON.stringify({name:e.name}),"utf-8")):ea(Qr.from(JSON.stringify(t),"utf-8"))}(e);return{privateFunctionRoot:t,unconstrainedFunctionRoot:n,metadataHash:s}}async function aa(e,t){const n=(await async function(e,t){const n=function(e,t){return e.functions.filter((e=>e.functionType===t)).map((e=>({...e,selector:Ur.fromNameAndParameters(e.name,e.parameters)}))).sort(((e,t)=>e.selector.value-t.selector.value)).map(ia)}(e,t);if(0===n.length)return;const s=Math.ceil(Math.log2(n.length)),r=new Vr(s);return await r.setHasher(Qr.alloc(32),(async(e,t)=>ea(Qr.concat([e,t])).toBuffer())),r.computeTree(n.map((e=>e.toBuffer())))}(e,t))?.root;return n?X.fromBuffer(n):X.ZERO}function ia(e){const t="selector"in e?e.selector:Ur.fromNameAndParameters(e);return ea(Qr.concat([ye($r),t.toBuffer()]))}function oa(e,t,n){if(e.length>n)throw new Error("Array size exceeds target length");return[...e,...Array(n-e.length).fill(t)]}function la(e){return e.filter((e=>e&&("isZero"in e?!e.isZero():!e.isEmpty()))).map((e=>e.toBuffer().length)).reduce(((e,t)=>e+t),0)}var ca=r(8891).Buffer;class da{constructor(e){if(this.buffer=e,e.length!==da.SIZE_IN_BYTES)throw new Error(`Expect buffer size to be ${da.SIZE_IN_BYTES}. Got ${e.length}.`)}static fromString(e){if(!da.isAddress(e))throw new Error(`Invalid address string: ${e}`);return new da(ca.from(e.replace(/^0x/i,""),"hex"))}static random(){return new da(k(20))}static isAddress(e){return!!/^(0x)?[0-9a-f]{40}$/i.test(e)&&(!(!/^(0x|0X)?[0-9a-f]{40}$/.test(e)&&!/^(0x|0X)?[0-9A-F]{40}$/.test(e))||da.checkAddressChecksum(e))}isZero(){return this.equals(da.ZERO)}static checkAddressChecksum(e){const t=_e((e=e.replace(/^0x/i,"")).toLowerCase());for(let n=0;n<40;n++)if(parseInt(t[n],16)>7&&e[n].toUpperCase()!==e[n]||parseInt(t[n],16)<=7&&e[n].toLowerCase()!==e[n])return!1;return!0}static toChecksumAddress(e){if(!da.isAddress(e))throw new Error("Invalid address string.");const t=_e(e=e.toLowerCase().replace(/^0x/i,""));let n="0x";for(let s=0;s<e.length;s++)parseInt(t[s],16)>7?n+=e[s].toUpperCase():n+=e[s];return n}equals(e){return this.buffer.equals(e.buffer)}toString(){return`0x${this.buffer.toString("hex")}`}[i.inspect.custom](){return`EthAddress<${this.toString()}>`}toChecksumString(){return da.toChecksumAddress(this.buffer.toString("hex"))}toBuffer(){return this.buffer}toBuffer32(){const e=ca.alloc(32);return this.buffer.copy(e,12),e}toField(){return X.fromBuffer(this.toBuffer32())}static fromField(e){return new da(e.toBuffer().slice(-da.SIZE_IN_BYTES))}static fromFields(e){const t=je.asReader(e);return da.fromField(t.readField())}static fromBuffer(e){const t=L.asReader(e);return new da(t.readBytes(da.SIZE_IN_BYTES))}toFriendlyJSON(){return this.toString()}toJSON(){return{type:"EthAddress",value:this.toString()}}}da.SIZE_IN_BYTES=20,da.ZERO=new da(ca.alloc(da.SIZE_IN_BYTES)),O.register("EthAddress",da);const ua=["da","l2"];class fa{constructor(e,t){this.daGas=e,this.l2Gas=t}clone(){return new fa(this.daGas,this.l2Gas)}get(e){return this[`${e}Gas`]}equals(e){return this.daGas===e.daGas&&this.l2Gas===e.l2Gas}static from(e){return new fa(e.daGas??0,e.l2Gas??0)}static empty(){return new fa(0,0)}static test(){return new fa(1e9,1e9)}isEmpty(){return 0===this.daGas&&0===this.l2Gas}static fromBuffer(e){const t=L.asReader(e);return new fa(t.readNumber(),t.readNumber())}toBuffer(){return Ce(this.daGas,this.l2Gas)}[i.inspect.custom](){return`Gas { daGas=${this.daGas} l2Gas=${this.l2Gas} }`}add(e){return new fa(this.daGas+e.daGas,this.l2Gas+e.l2Gas)}sub(e){return new fa(this.daGas-e.daGas,this.l2Gas-e.l2Gas)}mul(e){return new fa(Math.ceil(this.daGas*e),Math.ceil(this.l2Gas*e))}computeFee(e){return ua.reduce(((t,n)=>t.add(e.get(n).mul(new X(this.get(n))))),X.ZERO)}toFields(){return ke(this.daGas,this.l2Gas)}static fromFields(e){const t=je.asReader(e);return new fa(t.readU32(),t.readU32())}toJSON(){return{daGas:this.daGas,l2Gas:this.l2Gas}}static fromJSON(e){return new fa(e.daGas,e.l2Gas)}}function ha(e,t,n=0){return Array.from({length:e},((e,s)=>t(s+n)))}function pa(e){return e.reduce(((e,t,n)=>{if(!t.isEmpty()){if(e!==n)throw new Error("Non-empty items must be placed continuously from index 0.");return e+1}return e}),0)}function _a(e,t,n=e.length){const s=pa(e),r=pa(t);if(s+r>n)throw new Error("Combined non-empty items exceeded the maximum allowed.");const a=[...e];return t.slice(0,r).forEach(((e,t)=>a[t+s]=e)),a}function ma(e){return e.every((e=>e.isEmpty()))}class ga{constructor(e,t,n,s,r){this.msgSender=e,this.storageContractAddress=t,this.functionSelector=n,this.isDelegateCall=s,this.isStaticCall=r}static empty(){return new ga(Nr.ZERO,Nr.ZERO,Ur.empty(),!1,!1)}isEmpty(){return this.msgSender.isZero()&&this.storageContractAddress.isZero()&&this.functionSelector.isEmpty()&&X.ZERO}static from(e){return new ga(...ga.getFields(e))}static getFields(e){return[e.msgSender,e.storageContractAddress,e.functionSelector,e.isDelegateCall,e.isStaticCall]}toBuffer(){return Ce(...ga.getFields(this))}toFields(){const e=ke(...ga.getFields(this));if(5!==e.length)throw new Error(`Invalid number of fields for CallContext. Expected 5, got ${e.length}`);return e}static fromBuffer(e){const t=L.asReader(e);return new ga(t.readObject(Nr),t.readObject(Nr),t.readObject(Ur),t.readBoolean(),t.readBoolean())}static fromFields(e){const t=je.asReader(e);return new ga(t.readObject(Nr),t.readObject(Nr),t.readObject(Ur),t.readBoolean(),t.readBoolean())}equals(e){return e.msgSender.equals(this.msgSender)&&e.storageContractAddress.equals(this.storageContractAddress)&&e.functionSelector.equals(this.functionSelector)&&e.isDelegateCall===this.isDelegateCall&&e.isStaticCall===this.isStaticCall}async hash(){return await Me(this.toFields(),nt.CALL_CONTEXT)}}class ba{constructor(e,t,n,s){this.storageSlot=e,this.currentValue=t,this.counter=n,this.contractAddress=s}static from(e){return new ba(e.storageSlot,e.currentValue,e.counter,e.contractAddress)}toBuffer(){return Ce(this.storageSlot,this.currentValue,new X(this.counter))}static fromBuffer(e){const t=L.asReader(e);return new ba(X.fromBuffer(t),X.fromBuffer(t),X.fromBuffer(t).toNumber())}static empty(){return new ba(X.ZERO,X.ZERO,0)}isEmpty(){return this.storageSlot.isZero()&&this.currentValue.isZero()&&0==this.counter}toFriendlyJSON(){return`Slot=${this.storageSlot.toFriendlyJSON()}: ${this.currentValue.toFriendlyJSON()}`}toFields(){const e=[this.storageSlot,this.currentValue,new X(this.counter)];if(3!==e.length)throw new Error(`Invalid number of fields for ContractStorageRead. Expected 3, got ${e.length}`);return e}static fromFields(e){const t=je.asReader(e),n=t.readField(),s=t.readField(),r=t.readField().toNumber();return new ba(n,s,r)}}class ya{constructor(e,t,n,s){this.storageSlot=e,this.newValue=t,this.counter=n,this.contractAddress=s}toBuffer(){return Ce(this.storageSlot,this.newValue,this.counter)}static fromBuffer(e){const t=L.asReader(e);return new ya(X.fromBuffer(t),X.fromBuffer(t),t.readNumber())}static from(e){return new ya(...ya.getFields(e))}static getFields(e){return[e.storageSlot,e.newValue,e.counter,e.contractAddress]}static empty(){return new ya(X.ZERO,X.ZERO,0)}isEmpty(){return this.storageSlot.isZero()&&this.newValue.isZero()}toFriendlyJSON(){return`Slot=${this.storageSlot.toFriendlyJSON()}: ${this.newValue.toFriendlyJSON()}, sideEffectCounter=${this.counter}`}toFields(){const e=[this.storageSlot,this.newValue,new X(this.counter)];if(3!==e.length)throw new Error(`Invalid number of fields for ContractStorageUpdateRequest. Expected 3, got ${e.length}`);return e}static fromFields(e){const t=je.asReader(e),n=t.readField(),s=t.readField();return new ya(n,s,t.readU32())}}class va{constructor(e,t){this.feePerDaGas=new X(e),this.feePerL2Gas=new X(t)}clone(){return new va(this.feePerDaGas,this.feePerL2Gas)}equals(e){return this.feePerDaGas.equals(e.feePerDaGas)&&this.feePerL2Gas.equals(e.feePerL2Gas)}get(e){switch(e){case"da":return this.feePerDaGas;case"l2":return this.feePerL2Gas}}static from(e){return new va(e.feePerDaGas,e.feePerL2Gas)}static random(){return new va(X.random(),X.random())}static empty(){return new va(X.ZERO,X.ZERO)}static default(){return new va(X.ONE,X.ONE)}isEmpty(){return this.feePerDaGas.isZero()&&this.feePerL2Gas.isZero()}static fromBuffer(e){const t=L.asReader(e);return new va(t.readObject(X),t.readObject(X))}toBuffer(){return Ce(this.feePerDaGas,this.feePerL2Gas)}static fromFields(e){const t=je.asReader(e);return new va(t.readField(),t.readField())}toFields(){return ke(this.feePerDaGas,this.feePerL2Gas)}static fromJSON(e){return new va(X.fromString(e.feePerDaGas),X.fromString(e.feePerL2Gas))}toJSON(){return{feePerDaGas:this.feePerDaGas.toString(),feePerL2Gas:this.feePerL2Gas.toString()}}[i.inspect.custom](){return`GasFees { feePerDaGas=${this.feePerDaGas} feePerL2Gas=${this.feePerL2Gas} }`}}class wa{constructor(e,t,n,s,r,a,i){this.chainId=e,this.version=t,this.blockNumber=n,this.timestamp=s,this.coinbase=r,this.feeRecipient=a,this.gasFees=i}getSize(){return this.toBuffer().length}static from(e){return new wa(...wa.getFields(e))}static empty(){return new wa(X.ZERO,X.ZERO,X.ZERO,X.ZERO,da.ZERO,Nr.ZERO,va.empty())}static fromBuffer(e){const t=L.asReader(e);return new wa(X.fromBuffer(t),X.fromBuffer(t),X.fromBuffer(t),X.fromBuffer(t),t.readObject(da),t.readObject(Nr),t.readObject(va))}static fromJSON(e){return new wa(X.fromString(e.chainId),X.fromString(e.version),X.fromString(e.blockNumber),X.fromString(e.timestamp),da.fromString(e.coinbase),Nr.fromString(e.feeRecipient),va.fromJSON(e.gasFees))}static fromFields(e){const t=je.asReader(e);return new wa(t.readField(),t.readField(),t.readField(),t.readField(),da.fromField(t.readField()),Nr.fromField(t.readField()),va.fromFields(t))}static getFields(e){return[e.chainId,e.version,e.blockNumber,e.timestamp,e.coinbase,e.feeRecipient,e.gasFees]}toBuffer(){return Ce(...wa.getFields(this))}toFields(){const e=ke(...wa.getFields(this));if(8!==e.length)throw new Error(`Invalid number of fields for GlobalVariables. Expected 8, got ${e.length}`);return e}toJSON(){return{chainId:this.chainId.toString(),version:this.version.toString(),blockNumber:this.blockNumber.toString(),timestamp:this.timestamp.toString(),coinbase:this.coinbase.toString(),feeRecipient:this.feeRecipient.toString(),gasFees:this.gasFees.toJSON()}}clone(){return wa.fromBuffer(this.toBuffer())}isEmpty(){return this.chainId.isZero()&&this.version.isZero()&&this.blockNumber.isZero()&&this.timestamp.isZero()&&this.coinbase.isZero()&&this.feeRecipient.isZero()&&this.gasFees.isEmpty()}}var Aa=r(8891).Buffer;const Ea=32;class xa{constructor(e,t,n,s){if(this.numTxs=e,this.txsEffectsHash=t,this.inHash=n,this.outHash=s,t.length!==Ea)throw new Error("txsEffectsHash buffer must be 32 bytes");if(0!==t[0])throw new Error("txsEffectsHash buffer should be truncated and left padded");if(n.length!==Ea)throw new Error("inHash buffer must be 32 bytes");if(0!==n[0])throw new Error("inHash buffer should be truncated and left padded");if(s.length!==Ea)throw new Error("outHash buffer must be 32 bytes");if(0!==s[0])throw new Error("outHash buffer should be truncated and left padded")}getSize(){return this.toBuffer().length}toBuffer(){return Ce(this.numTxs,this.txsEffectsHash,this.inHash,this.outHash)}toFields(){const e=[this.numTxs,X.fromBuffer(this.txsEffectsHash),X.fromBuffer(this.inHash),X.fromBuffer(this.outHash)];if(4!==e.length)throw new Error(`Expected content commitment to have 4 fields, but it has ${e.length} fields`);return e}static fromBuffer(e){const t=L.asReader(e);return new xa(t.readObject(X),t.readBytes(Ea),t.readBytes(Ea),t.readBytes(Ea))}static fromFields(e){const t=je.asReader(e);return new xa(t.readField(),t.readField().toBuffer(),t.readField().toBuffer(),t.readField().toBuffer())}static empty(){return new xa(X.zero(),Aa.alloc(Ea),Aa.alloc(Ea),Aa.alloc(Ea))}isEmpty(){return this.numTxs.isZero()&&this.txsEffectsHash.equals(Aa.alloc(Ea))&&this.inHash.equals(Aa.alloc(Ea))&&this.outHash.equals(Aa.alloc(Ea))}toString(){return this.toBuffer().toString("hex")}static fromString(e){const t=Aa.from(e.replace(/^0x/i,""),"hex");return xa.fromBuffer(t)}}class Sa{constructor(e){this.items=e}toBuffer(){return Ce(this.items.length,this.items)}toFriendlyJSON(){return this.items}}var Ta,ka,Ca,za;(za=Ta||(Ta={}))[za.STANDARD=0]="STANDARD",za[za.ULTRA=1]="ULTRA",(Ca=ka||(ka={}))[Ca.Base=0]="Base",Ca[Ca.Merge=1]="Merge",Ca[Ca.Root=2]="Root";const Pa="hex";var Fa=r(8891).Buffer;class Na{constructor(e,t){this.root=e,this.nextAvailableLeafIndex=t}getSize(){return this.root.size+4}toBuffer(){return Ce(this.root,this.nextAvailableLeafIndex)}toFields(){return[this.root,new X(this.nextAvailableLeafIndex)]}toString(){return this.toBuffer().toString(Pa)}static fromBuffer(e){const t=L.asReader(e);return new Na(X.fromBuffer(t),t.readNumber())}static fromString(e){return Na.fromBuffer(Fa.from(e,Pa))}static fromFields(e){const t=je.asReader(e);return new Na(t.readField(),Number(t.readField().toBigInt()))}static zero(){return new Na(X.ZERO,0)}isZero(){return this.root.isZero()&&0===this.nextAvailableLeafIndex}}class Ga{constructor(e,t,n){this.noteHashTree=e,this.nullifierTree=t,this.publicDataTree=n}getSize(){return this.noteHashTree.getSize()+this.nullifierTree.getSize()+this.publicDataTree.getSize()}static fromBuffer(e){const t=L.asReader(e);return new Ga(t.readObject(Na),t.readObject(Na),t.readObject(Na))}static fromFields(e){const t=je.asReader(e),n=Na.fromFields(t),s=Na.fromFields(t),r=Na.fromFields(t);return new Ga(n,s,r)}static empty(){return new Ga(Na.zero(),Na.zero(),Na.zero())}toBuffer(){return Ce(this.noteHashTree,this.nullifierTree,this.publicDataTree)}toFields(){const e=[...this.noteHashTree.toFields(),...this.nullifierTree.toFields(),...this.publicDataTree.toFields()];if(6!==e.length)throw new Error(`Invalid number of fields for PartialStateReference. Expected 6, got ${e.length}`);return e}isEmpty(){return this.noteHashTree.isZero()&&this.nullifierTree.isZero()&&this.publicDataTree.isZero()}}class La{constructor(e,t){this.l1ToL2MessageTree=e,this.partial=t}getSize(){return this.l1ToL2MessageTree.getSize()+this.partial.getSize()}toBuffer(){return Ce(this.l1ToL2MessageTree,this.partial)}toFields(){const e=[...this.l1ToL2MessageTree.toFields(),...this.partial.toFields()];if(8!==e.length)throw new Error(`Invalid number of fields for StateReference. Expected 8, got ${e.length}`);return e}static fromBuffer(e){const t=L.asReader(e);return new La(t.readObject(Na),t.readObject(Ga))}static fromFields(e){const t=je.asReader(e),n=Na.fromFields(t),s=Ga.fromFields(t);return new La(n,s)}static empty(){return new La(Na.zero(),Ga.empty())}isEmpty(){return this.l1ToL2MessageTree.isZero()&&this.partial.isEmpty()}}var Oa=r(8891).Buffer;class Ra{constructor(e,t,n,s,r){this.lastArchive=e,this.contentCommitment=t,this.state=n,this.globalVariables=s,this.totalFees=r}static getFields(e){return[e.lastArchive,e.contentCommitment,e.state,e.globalVariables,e.totalFees]}getSize(){return this.lastArchive.getSize()+this.contentCommitment.getSize()+this.state.getSize()+this.globalVariables.getSize()+this.totalFees.size}toBuffer(){return Ce(...Ra.getFields(this))}toFields(){const e=ke(...Ra.getFields(this));if(23!==e.length)throw new Error(`Invalid number of fields for Header. Expected 23, got ${e.length}`);return e}clone(){return Ra.fromBuffer(this.toBuffer())}static fromBuffer(e){const t=L.asReader(e);return new Ra(t.readObject(Na),t.readObject(xa),t.readObject(La),t.readObject(wa),t.readObject(X))}static fromFields(e){const t=je.asReader(e);return new Ra(Na.fromFields(t),xa.fromFields(t),La.fromFields(t),wa.fromFields(t),t.readField())}static empty(){return new Ra(Na.zero(),xa.empty(),La.empty(),wa.empty(),X.ZERO)}isEmpty(){return this.lastArchive.isZero()&&this.contentCommitment.isEmpty()&&this.state.isEmpty()&&this.globalVariables.isEmpty()}toString(){return this.toBuffer().toString("hex")}static fromString(e){const t=Oa.from(e.replace(/^0x/i,""),"hex");return Ra.fromBuffer(t)}async hash(){return await Me(this.toFields(),nt.BLOCK_HASH)}}class Ma{constructor(e,t,n){this.recipient=e,this.content=t,this.counter=n}static empty(){return new Ma(da.ZERO,X.zero(),0)}equals(e){return this.recipient.equals(e.recipient)&&this.content.equals(e.content)&&this.counter===e.counter}toBuffer(){return Ce(this.recipient,this.content,this.counter)}toFields(){const e=[this.recipient.toField(),this.content,new X(this.counter)];if(3!==e.length)throw new Error(`Invalid number of fields for L2ToL1Message. Expected 3, got ${e.length}`);return e}static fromFields(e){const t=je.asReader(e);return new Ma(t.readObject(da),t.readField(),t.readU32())}static fromBuffer(e){const t=L.asReader(e);return new Ma(t.readObject(da),t.readObject(X),t.readNumber())}isEmpty(){return this.recipient.isZero()&&this.content.isZero()&&!this.counter}}class Ba{constructor(e,t,n){this.value=e,this.counter=t,this.length=n}toFields(){return[this.value,new X(this.counter),this.length]}static fromFields(e){const t=je.asReader(e);return new Ba(t.readField(),t.readU32(),t.readField())}isEmpty(){return this.value.isZero()&&this.length.isZero()&&!this.counter}static empty(){return new Ba(X.zero(),0,X.zero())}toBuffer(){return Ce(this.value,this.counter,this.length)}static fromBuffer(e){const t=L.asReader(e);return new Ba(X.fromBuffer(t),t.readNumber(),X.fromBuffer(t))}toString(){return`value=${this.value} counter=${this.counter} length=${this.length}`}[i.inspect.custom](){return`LogHash { ${this.toString()} }`}}class Ya{constructor(e,t){this.value=e,this.counter=t}toFields(){return[this.value,new X(this.counter)]}static fromFields(e){const t=je.asReader(e);return new Ya(t.readField(),t.readU32())}isEmpty(){return this.value.isZero()&&!this.counter}static empty(){return new Ya(X.zero(),0)}toBuffer(){return Ce(this.value,this.counter)}static fromBuffer(e){const t=L.asReader(e);return new Ya(X.fromBuffer(t),t.readNumber())}toString(){return`value=${this.value} counter=${this.counter}`}scope(e){return new ja(this,e)}}class ja{constructor(e,t){this.noteHash=e,this.contractAddress=t}get counter(){return this.noteHash.counter}get value(){return this.noteHash.value}toFields(){return[...this.noteHash.toFields(),this.contractAddress.toField()]}static fromFields(e){const t=je.asReader(e);return new ja(t.readObject(Ya),Nr.fromField(t.readField()))}isEmpty(){return this.noteHash.isEmpty()&&this.contractAddress.isZero()}static empty(){return new ja(Ya.empty(),Nr.ZERO)}toBuffer(){return Ce(this.noteHash,this.contractAddress)}static fromBuffer(e){const t=L.asReader(e);return new ja(Ya.fromBuffer(t),Nr.fromBuffer(t))}toString(){return`noteHash=${this.noteHash} contractAddress=${this.contractAddress}`}}class Ha{constructor(e,t,n){this.value=e,this.counter=t,this.noteHash=n}toFields(){return[this.value,new X(this.counter),this.noteHash]}static fromFields(e){const t=je.asReader(e);return new Ha(t.readField(),t.readU32(),t.readField())}isEmpty(){return this.value.isZero()&&!this.counter&&this.noteHash.isZero()}static empty(){return new Ha(X.zero(),0,X.zero())}toBuffer(){return Ce(this.value,this.counter,this.noteHash)}static fromBuffer(e){const t=L.asReader(e);return new Ha(X.fromBuffer(t),t.readNumber(),X.fromBuffer(t))}toString(){return`value=${this.value} counter=${this.counter} noteHash=${this.noteHash}`}scope(e){return new Ia(this,e)}}class Ia{constructor(e,t){this.nullifier=e,this.contractAddress=t}get counter(){return this.nullifier.counter}get value(){return this.nullifier.value}get nullifiedNoteHash(){return this.nullifier.noteHash}toFields(){return[...this.nullifier.toFields(),this.contractAddress.toField()]}static fromFields(e){const t=je.asReader(e);return new Ia(t.readObject(Ha),Nr.fromField(t.readField()))}isEmpty(){return this.nullifier.isEmpty()&&this.contractAddress.isZero()}static empty(){return new Ia(Ha.empty(),Nr.ZERO)}toBuffer(){return Ce(this.nullifier,this.contractAddress)}static fromBuffer(e){const t=L.asReader(e);return new Ia(Ha.fromBuffer(t),Nr.fromBuffer(t))}toString(){return`nullifier=${this.nullifier} contractAddress=${this.contractAddress}`}}class Xa{constructor(e,t){this.value=e,this.counter=t}toBuffer(){return Ce(this.value,this.counter)}static fromBuffer(e){const t=L.asReader(e);return new Xa(X.fromBuffer(t),t.readNumber())}toFields(){return[this.value,new X(this.counter)]}static fromFields(e){const t=je.asReader(e);return new Xa(t.readField(),t.readU32())}isEmpty(){return this.value.isZero()&&!this.counter}static empty(){return new Xa(X.zero(),0)}scope(e){return new Ua(this,e)}}class Ua{constructor(e,t){this.readRequest=e,this.contractAddress=t}get value(){return this.readRequest.value}get counter(){return this.readRequest.counter}toBuffer(){return Ce(this.readRequest,this.contractAddress)}static fromBuffer(e){const t=L.asReader(e);return new Ua(Xa.fromBuffer(t),Nr.fromBuffer(t))}toFields(){return[...this.readRequest.toFields(),this.contractAddress.toField()]}static fromFields(e){const t=je.asReader(e);return new Ua(t.readObject(Xa),Nr.fromField(t.readField()))}isEmpty(){return this.readRequest.isEmpty()&&this.contractAddress.isZero()}static empty(){return new Ua(Xa.empty(),Nr.ZERO)}}var Ja,Da=r(8891).Buffer;function qa(e){return e===Ja.OK||e===Ja.APP_LOGIC_REVERTED||e===Ja.TEARDOWN_REVERTED||e===Ja.BOTH_REVERTED}!function(e){e[e.OK=0]="OK",e[e.APP_LOGIC_REVERTED=1]="APP_LOGIC_REVERTED",e[e.TEARDOWN_REVERTED=2]="TEARDOWN_REVERTED",e[e.BOTH_REVERTED=3]="BOTH_REVERTED"}(Ja||(Ja={}));class Ka{constructor(e){this.code=e.valueOf()}equals(e){return this.code===e.code}isOK(){return this.equals(Ka.OK)}getDescription(){switch(this.code){case Ja.OK:return"OK";case Ja.APP_LOGIC_REVERTED:return"Application logic reverted";case Ja.TEARDOWN_REVERTED:return"Teardown reverted";case Ja.BOTH_REVERTED:return"Both reverted";default:return`Unknown RevertCode: ${this.code}`}}toHashPreimage(){const e=Da.alloc(Ka.PREIMAGE_SIZE_IN_BYTES-Ka.PACKED_SIZE_IN_BYTES);return Da.concat([e,this.toBuffer()])}toBuffer(){const e=Da.alloc(Ka.PACKED_SIZE_IN_BYTES);return e.writeUInt8(this.code,0),e}toField(){return new X(this.toBuffer())}getSerializedLength(){return this.toBuffer().length}static fromField(e){if(!qa(e.toNumber()))throw new Error(`Invalid RevertCode: ${e.toNumber()}`);return new Ka(e.toNumber())}static fromFields(e){const t=je.asReader(e);return Ka.fromField(t.readField())}static fromBuffer(e){const t=L.asReader(e).readBytes(Ka.PACKED_SIZE_IN_BYTES).readUInt8(0);if(!qa(t))throw new Error(`Invalid RevertCode: ${t}`);return new Ka(t)}static random(){return new Ka(Math.floor(Math.random()*Ka.NUM_OPTIONS))}[i.inspect.custom](){return`RevertCode<${this.code.toString()}>`}}Ka.OK=new Ka(Ja.OK),Ka.APP_LOGIC_REVERTED=new Ka(Ja.APP_LOGIC_REVERTED),Ka.TEARDOWN_REVERTED=new Ka(Ja.TEARDOWN_REVERTED),Ka.BOTH_REVERTED=new Ka(Ja.BOTH_REVERTED),Ka.PREIMAGE_SIZE_IN_BYTES=32,Ka.PACKED_SIZE_IN_BYTES=1,Ka.NUM_OPTIONS=4;class Wa{constructor(e,t,n,s,r,a,i,o,l,c,d,u,f,h,p,_,m,g,b,y,v,w,A){this.callContext=e,this.argsHash=t,this.returnsHash=n,this.noteHashReadRequests=s,this.nullifierReadRequests=r,this.nullifierNonExistentReadRequests=a,this.l1ToL2MsgReadRequests=i,this.contractStorageUpdateRequests=o,this.contractStorageReads=l,this.publicCallStackHashes=c,this.noteHashes=d,this.nullifiers=u,this.l2ToL1Msgs=f,this.startSideEffectCounter=h,this.endSideEffectCounter=p,this.unencryptedLogsHashes=_,this.historicalHeader=m,this.globalVariables=g,this.proverAddress=b,this.revertCode=y,this.startGasLeft=v,this.endGasLeft=w,this.transactionFee=A}static from(e){return new Wa(...Wa.getFields(e))}static empty(){return new Wa(ga.empty(),X.ZERO,X.ZERO,ha(16,Xa.empty),ha(16,Xa.empty),ha(16,Xa.empty),ha(16,Xa.empty),ha(32,ya.empty),ha(32,ba.empty),ha(16,X.zero),ha(16,Ya.empty),ha(16,Ha.empty),ha(2,Ma.empty),X.ZERO,X.ZERO,ha(4,Ba.empty),Ra.empty(),wa.empty(),Nr.ZERO,Ka.OK,fa.empty(),fa.empty(),X.ZERO)}isEmpty(){return this.callContext.isEmpty()&&this.argsHash.isZero()&&this.returnsHash.isZero()&&ma(this.nullifierReadRequests)&&ma(this.nullifierNonExistentReadRequests)&&ma(this.l1ToL2MsgReadRequests)&&ma(this.contractStorageUpdateRequests)&&ma(this.contractStorageReads)&&function(e,t){for(const n of e)if(!t(n))return!1;return!0}(this.publicCallStackHashes,(e=>e.isZero()))&&ma(this.noteHashes)&&ma(this.nullifiers)&&ma(this.l2ToL1Msgs)&&this.startSideEffectCounter.isZero()&&this.endSideEffectCounter.isZero()&&ma(this.unencryptedLogsHashes)&&this.historicalHeader.isEmpty()&&this.globalVariables.isEmpty()&&this.proverAddress.isZero()&&this.revertCode.isOK()&&this.startGasLeft.isEmpty()&&this.endGasLeft.isEmpty()&&this.transactionFee.isZero()}static getFields(e){return[e.callContext,e.argsHash,e.returnsHash,e.noteHashReadRequests,e.nullifierReadRequests,e.nullifierNonExistentReadRequests,e.l1ToL2MsgReadRequests,e.contractStorageUpdateRequests,e.contractStorageReads,e.publicCallStackHashes,e.noteHashes,e.nullifiers,e.l2ToL1Msgs,e.startSideEffectCounter,e.endSideEffectCounter,e.unencryptedLogsHashes,e.historicalHeader,e.globalVariables,e.proverAddress,e.revertCode,e.startGasLeft,e.endGasLeft,e.transactionFee]}toBuffer(){return Ce(...Wa.getFields(this))}toFields(){const e=ke(...Wa.getFields(this));if(481!==e.length)throw new Error(`Invalid number of fields for PublicCircuitPublicInputs. Expected 481, got ${e.length}`);return e}static fromBuffer(e){const t=L.asReader(e);return new Wa(t.readObject(ga),t.readObject(X),t.readObject(X),t.readArray(16,Xa),t.readArray(16,Xa),t.readArray(16,Xa),t.readArray(16,Xa),t.readArray(32,ya),t.readArray(32,ba),t.readArray(16,X),t.readArray(16,Ya),t.readArray(16,Ha),t.readArray(2,Ma),t.readObject(X),t.readObject(X),t.readArray(4,Ba),t.readObject(Ra),t.readObject(wa),t.readObject(Nr),t.readObject(Ka),t.readObject(fa),t.readObject(fa),t.readObject(X))}static fromFields(e){const t=je.asReader(e);return new Wa(ga.fromFields(t),t.readField(),t.readField(),t.readArray(16,Xa),t.readArray(16,Xa),t.readArray(16,Xa),t.readArray(16,Xa),t.readArray(32,ya),t.readArray(32,ba),t.readFieldArray(16),t.readArray(16,Ya),t.readArray(16,Ha),t.readArray(2,Ma),t.readField(),t.readField(),t.readArray(4,Ba),Ra.fromFields(t),wa.fromFields(t),Nr.fromFields(t),Ka.fromFields(t),fa.fromFields(t),fa.fromFields(t),t.readField())}async hash(){return await Me(this.toFields(),nt.PUBLIC_CIRCUIT_PUBLIC_INPUTS)}}r(8891).Buffer;class Za{constructor(e,t,n){this.msgSender=e,this.storageContractAddress=t,this.isStaticCall=n}toFields(){return ke([this.msgSender,this.storageContractAddress,this.isStaticCall])}static fromFields(e){const t=je.asReader(e);return new Za(t.readObject(Nr),t.readObject(Nr),t.readBoolean())}static empty(){return new Za(Nr.ZERO,Nr.ZERO,!1)}isEmpty(){return this.msgSender.isZero()&&this.storageContractAddress.isZero()&&!this.isStaticCall}static from(e){return new Za(...Za.getFields(e))}static getFields(e){return[e.msgSender,e.storageContractAddress,e.isStaticCall]}toBuffer(){return Ce(...Za.getFields(this))}static fromBuffer(e){const t=L.asReader(e);return new Za(new Nr(t.readBytes(32)),new Nr(t.readBytes(32)),t.readBoolean())}equals(e){return e.msgSender.equals(this.msgSender)&&e.storageContractAddress.equals(this.storageContractAddress)&&e.isStaticCall===this.isStaticCall}}class Va{constructor(e,t,n,s,r){this.hash=e,this.callerContractAddress=t,this.callerContext=n,this.startSideEffectCounter=s,this.endSideEffectCounter=r}toBuffer(){return Ce(this.hash,this.callerContractAddress,this.callerContext,this.startSideEffectCounter,this.endSideEffectCounter)}get counter(){return this.startSideEffectCounter.toNumber()}static fromBuffer(e){const t=L.asReader(e);return new Va(X.fromBuffer(t),t.readObject(Nr),t.readObject(Za),X.fromBuffer(t),X.fromBuffer(t))}static fromFields(e){const t=je.asReader(e);return new Va(t.readField(),t.readObject(Nr),t.readObject(Za),t.readField(),t.readField())}isEmpty(){return this.hash.isZero()&&this.callerContractAddress.isZero()&&this.callerContext.isEmpty()&&this.startSideEffectCounter.isZero()&&this.endSideEffectCounter.isZero()}static empty(){return new Va(X.ZERO,Nr.ZERO,Za.empty(),X.ZERO,X.ZERO)}equals(e){return e.hash.equals(this.hash)&&e.callerContractAddress.equals(this.callerContractAddress)&&e.callerContext.equals(this.callerContext)&&e.startSideEffectCounter.equals(this.startSideEffectCounter)&&e.endSideEffectCounter.equals(this.endSideEffectCounter)}toString(){return`CallRequest(hash: ${this.hash.toString()}, callerContractAddress: ${this.callerContractAddress.toString()}, callerContext: ${this.callerContext.toString()}, startSideEffectCounter: ${this.startSideEffectCounter.toString()}, endSideEffectCounter: ${this.endSideEffectCounter.toString()})`}}var Qa=r(8891).Buffer;class $a{generator(){return $a.generator}async mul(e,t){const n=fe.new();return Ie.fromBuffer(await n.eccGrumpkinMul(e.toBuffer(),t.toBuffer()))}async add(e,t){const n=fe.new();return Ie.fromBuffer(await n.eccGrumpkinAdd(e.toBuffer(),t.toBuffer()))}batchMul(e,t){throw new Error("batchMul not supported")}getRandomFr(){throw new Error("getRandomFr not supported")}reduce512BufferToFr(e){throw new Error("reduce512BufferToFr not supported")}}$a.generator=Ie.fromBuffer(Qa.from([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,207,19,94,117,6,164,93,99,45,39,13,69,241,24,18,148,131,63,196,141,130,63,39,44]));var ei=r(8891).Buffer;class ti{constructor(e,t,n,s){this.masterNullifierPublicKey=e,this.masterIncomingViewingPublicKey=t,this.masterOutgoingViewingPublicKey=n,this.masterTaggingPublicKey=s}async hash(){return this.isEmpty()?X.ZERO:await Ye([this.masterNullifierPublicKey,this.masterIncomingViewingPublicKey,this.masterOutgoingViewingPublicKey,this.masterTaggingPublicKey,nt.PUBLIC_KEYS_HASH])}isEmpty(){return this.masterNullifierPublicKey.isZero()&&this.masterIncomingViewingPublicKey.isZero()&&this.masterOutgoingViewingPublicKey.isZero()&&this.masterTaggingPublicKey.isZero()}static empty(){return new ti(Ie.ZERO,Ie.ZERO,Ie.ZERO,Ie.ZERO)}equals(e){return this.masterNullifierPublicKey.equals(e.masterNullifierPublicKey)&&this.masterIncomingViewingPublicKey.equals(e.masterIncomingViewingPublicKey)&&this.masterOutgoingViewingPublicKey.equals(e.masterOutgoingViewingPublicKey)&&this.masterTaggingPublicKey.equals(e.masterTaggingPublicKey)}toBuffer(){return Ce([this.masterNullifierPublicKey,this.masterIncomingViewingPublicKey,this.masterOutgoingViewingPublicKey,this.masterTaggingPublicKey])}static fromBuffer(e){const t=L.asReader(e),n=t.readObject(Ie),s=t.readObject(Ie),r=t.readObject(Ie),a=t.readObject(Ie);return new ti(n,s,r,a)}toNoirStruct(){return{npk_m:this.masterNullifierPublicKey.toNoirStruct(),ivpk_m:this.masterIncomingViewingPublicKey.toNoirStruct(),ovpk_m:this.masterOutgoingViewingPublicKey.toNoirStruct(),tpk_m:this.masterTaggingPublicKey.toNoirStruct()}}toFields(){return[...this.masterNullifierPublicKey.toFields(),...this.masterIncomingViewingPublicKey.toFields(),...this.masterOutgoingViewingPublicKey.toFields(),...this.masterTaggingPublicKey.toFields()]}static fromFields(e){const t=je.asReader(e);return new ti(t.readObject(Ie),t.readObject(Ie),t.readObject(Ie),t.readObject(Ie))}toString(){return this.toBuffer().toString("hex")}static fromString(e){return ti.fromBuffer(ei.from(e,"hex"))}}async function ni(e,t){return await si(e,t,"n")}async function si(e,t,n){const s=function(e){const t=`${e.toUpperCase()}SK_M`;return nt[t]}(n);return await Ye([e.hi,e.lo,t,s])}function ri(e){return Oe([e,nt.NSK_M])}function ai(e){return Oe([e,nt.IVSK_M])}async function ii(e,t){const n=await Ye([e,t,nt.CONTRACT_ADDRESS_V1]);return Nr.fromField(n)}async function oi(e){const t=new $a;return await t.mul(t.generator(),e)}async function li(e){const t=ri(e),n=ai(e),s=function(e){return Oe([e,nt.OVSK_M])}(e),r=Oe([e,nt.TSK_M]),a=await oi(t),i=await oi(n),o=await oi(s),l=await oi(r);return{masterNullifierSecretKey:t,masterIncomingViewingSecretKey:n,masterOutgoingViewingSecretKey:s,masterTaggingSecretKey:r,publicKeys:new ti(a,i,o,l)}}new $a;var ci=r(8891).Buffer;class di{constructor(e,t,n){this.address=e,this.publicKeys=t,this.partialAddress=n,this.validate()}static async random(){return await this.fromSecretKeyAndPartialAddress(X.random(),X.random())}static async fromSecretKeyAndPartialAddress(e,t){const{publicKeys:n}=await li(e),s=await ii(await n.hash(),t);return new di(s,n,t)}static async fromSecretKeyAndInstance(e,t){const n=await $i(t);return await di.fromSecretKeyAndPartialAddress(e,n)}async validate(){const e=await ii(await this.publicKeys.hash(),this.partialAddress);if(!e.equals(this.address))throw new Error(`Address cannot be derived from public keys and partial address (received ${this.address.toString()}, derived ${e.toString()})`)}toReadableString(){return`Address: ${this.address.toString()}\nMaster Nullifier Public Key: ${this.publicKeys.masterNullifierPublicKey.toString()}\nMaster Incoming Viewing Public Key: ${this.publicKeys.masterIncomingViewingPublicKey.toString()}\nMaster Outgoing Viewing Public Key: ${this.publicKeys.masterOutgoingViewingPublicKey.toString()}\nMaster Tagging Public Key: ${this.publicKeys.masterTaggingPublicKey.toString()}\nPartial Address: ${this.partialAddress.toString()}\n`}equals(e){return this.address.equals(e.address)&&this.publicKeys.equals(e.publicKeys)&&this.partialAddress.equals(e.partialAddress)}toBuffer(){return Ce([this.address,this.publicKeys,this.partialAddress])}static fromBuffer(e){const t=L.asReader(e),n=t.readObject(Nr),s=t.readObject(ti),r=t.readObject(X);return new di(n,s,r)}static fromString(e){return this.fromBuffer(ci.from(e.replace(/^0x/i,""),"hex"))}toString(){return`0x${this.toBuffer().toString("hex")}`}}di.SIZE_IN_BYTES=128;class ui{constructor(e,t,n,s){this.gasLimits=e,this.teardownGasLimits=t,this.maxFeesPerGas=n,this.inclusionFee=s}getSize(){return this.toBuffer().length}static from(e){return new ui(fa.from(e.gasLimits),fa.from(e.teardownGasLimits),va.from(e.maxFeesPerGas),e.inclusionFee)}clone(){return new ui(this.gasLimits.clone(),this.teardownGasLimits.clone(),this.maxFeesPerGas.clone(),this.inclusionFee)}getFeeLimit(){return ua.reduce(((e,t)=>this.maxFeesPerGas.get(t).mul(new X(this.gasLimits.get(t))).add(e)),X.ZERO).add(this.inclusionFee)}static empty(){return new ui(fa.empty(),fa.empty(),va.empty(),X.ZERO)}static default(e){return ui.from({gasLimits:{l2Gas:et,daGas:et},teardownGasLimits:{l2Gas:tt,daGas:tt},maxFeesPerGas:{feePerL2Gas:new X(10),feePerDaGas:new X(10)},inclusionFee:new X(0),...e})}static teardownless(){return ui.default({teardownGasLimits:fa.from({l2Gas:0,daGas:0})})}static simulation(){return ui.default()}isEmpty(){return this.gasLimits.isEmpty()&&this.teardownGasLimits.isEmpty()&&this.maxFeesPerGas.isEmpty()&&this.inclusionFee.isZero()}equals(e){return this.gasLimits.equals(e.gasLimits)&&this.teardownGasLimits.equals(e.teardownGasLimits)&&this.maxFeesPerGas.equals(e.maxFeesPerGas)&&this.inclusionFee.equals(e.inclusionFee)}static fromBuffer(e){const t=L.asReader(e);return new ui(t.readObject(fa),t.readObject(fa),t.readObject(va),t.readObject(X))}toBuffer(){return Ce(...ui.getFields(this))}static fromFields(e){const t=je.asReader(e);return new ui(t.readObject(fa),t.readObject(fa),t.readObject(va),t.readField())}toFields(){const e=ke(...ui.getFields(this));if(7!==e.length)throw new Error(`Invalid number of fields for GasSettings. Expected 7 but got ${e.length}`);return e}static getFields(e){return[e.gasLimits,e.teardownGasLimits,e.maxFeesPerGas,e.inclusionFee]}getLimits(){return this.gasLimits}getInitialAvailable(){return this.gasLimits.sub(this.teardownGasLimits)}getTeardownLimits(){return this.teardownGasLimits}}class fi{constructor(e,t,n){this.gasSettings=n,this.chainId=new X(e),this.version=new X(t)}getSize(){return this.chainId.size+this.version.size+this.gasSettings.getSize()}clone(){return new fi(this.chainId,this.version,this.gasSettings.clone())}toBuffer(){return Ce(...fi.getFields(this))}static fromFields(e){const t=je.asReader(e);return new fi(t.readField(),t.readField(),t.readObject(ui))}toFields(){const e=ke(...fi.getFields(this));if(9!==e.length)throw new Error(`Invalid number of fields for TxContext. Expected 9, got ${e.length}`);return e}static fromBuffer(e){const t=L.asReader(e);return new fi(X.fromBuffer(t),X.fromBuffer(t),t.readObject(ui))}static empty(e=0,t=0){return new fi(new X(e),new X(t),ui.empty())}isEmpty(){return this.chainId.isZero()&&this.version.isZero()&&this.gasSettings.isEmpty()}static from(e){return new fi(...fi.getFields(e))}static getFields(e){return[e.chainId,e.version,e.gasSettings]}async hash(){return await Me(this.toFields(),nt.TX_CONTEXT)}}class hi{constructor(e,t){this.selector=e,this.isPrivate=t}static fromAbi(e){return new hi(Ur.fromNameAndParameters(e.name,e.parameters),e.functionType===xr.PRIVATE)}toBuffer(){return Ce(this.selector,this.isPrivate)}toFields(){const e=[this.selector.toField(),new X(this.isPrivate)];if(2!==e.length)throw new Error(`Invalid number of fields for FunctionData. Expected 2, got ${e.length}`);return e}isEmpty(){return this.selector.isEmpty()}equals(e){return this.selector.equals(e.selector)&&this.isPrivate===e.isPrivate}static empty(e){return new hi(Ur.empty(),e?.isPrivate??!1)}static fromBuffer(e){const t=L.asReader(e);return new hi(t.readObject(Ur),t.readBoolean())}static fromFields(e){const t=je.asReader(e),n=Ur.fromFields(t),s=t.readBoolean();return new hi(n,s)}async hash(){return await Me(this.toFields(),nt.FUNCTION_DATA)}}class pi{constructor(e,t,n){this.leafSlot=e,this.newValue=t,this.sideEffectCounter=n}static from(e){return new pi(e.leafIndex,e.newValue,e.sideEffectCounter)}get counter(){return this.sideEffectCounter}get position(){return this.leafSlot}toBuffer(){return Ce(this.leafSlot,this.newValue,this.sideEffectCounter)}isEmpty(){return this.leafSlot.isZero()&&this.newValue.isZero()}static fromFields(e){const t=je.asReader(e);return new pi(t.readField(),t.readField(),t.readU32())}static isEmpty(e){return e.isEmpty()}equals(e){return this.leafSlot.equals(e.leafSlot)&&this.newValue.equals(e.newValue)}static fromBuffer(e){const t=L.asReader(e);return new pi(X.fromBuffer(t),X.fromBuffer(t),t.readNumber())}static empty(){return new pi(X.ZERO,X.ZERO,0)}toFriendlyJSON(){return`Leaf=${this.leafSlot.toFriendlyJSON()}: ${this.newValue.toFriendlyJSON()}, SideEffectCounter=${this.sideEffectCounter}`}[i.inspect.custom](){return`PublicDataUpdateRequest { leafSlot: ${this.leafSlot.toFriendlyJSON()}, newValue: ${this.newValue.toFriendlyJSON()}, sideEffectCounter: ${this.sideEffectCounter} }`}}i.inspect.custom;var _i=r(8891).Buffer;class mi{constructor(e,t,n,s,r,a,i,o,l,c,d){this.noteHashes=e,this.nullifiers=t,this.l2ToL1Msgs=n,this.noteEncryptedLogsHash=s,this.encryptedLogsHash=r,this.unencryptedLogsHash=a,this.noteEncryptedLogPreimagesLength=i,this.encryptedLogPreimagesLength=o,this.unencryptedLogPreimagesLength=l,this.publicDataUpdateRequests=c,this.gasUsed=d}getSize(){return la(this.noteHashes)+la(this.nullifiers)+la(this.l2ToL1Msgs)+this.noteEncryptedLogsHash.size+this.encryptedLogsHash.size+this.unencryptedLogsHash.size+this.noteEncryptedLogPreimagesLength.size+this.encryptedLogPreimagesLength.size+this.unencryptedLogPreimagesLength.size+la(this.publicDataUpdateRequests)+this.gasUsed.toBuffer().length}static getFields(e){return[e.noteHashes,e.nullifiers,e.l2ToL1Msgs,e.noteEncryptedLogsHash,e.encryptedLogsHash,e.unencryptedLogsHash,e.noteEncryptedLogPreimagesLength,e.encryptedLogPreimagesLength,e.unencryptedLogPreimagesLength,e.publicDataUpdateRequests,e.gasUsed]}static from(e){return new mi(...mi.getFields(e))}toBuffer(){return Ce(...mi.getFields(this))}toString(){return this.toBuffer().toString("hex")}static fromBuffer(e){const t=L.asReader(e);return new mi(t.readArray(Je,X),t.readArray(De,X),t.readArray(8,X),X.fromBuffer(t),X.fromBuffer(t),X.fromBuffer(t),X.fromBuffer(t),X.fromBuffer(t),X.fromBuffer(t),t.readArray(63,pi),t.readObject(fa))}static fromString(e){return mi.fromBuffer(_i.from(e,"hex"))}static empty(){return new mi(ha(Je,X.zero),ha(De,X.zero),ha(8,X.zero),X.zero(),X.zero(),X.zero(),X.zero(),X.zero(),X.zero(),ha(63,pi.empty),fa.empty())}[i.inspect.custom](){return`CombinedAccumulatedData {\n      noteHashes: [${this.noteHashes.filter((e=>!e.isZero())).map((e=>(0,i.inspect)(e))).join(", ")}],\n      nullifiers: [${this.nullifiers.filter((e=>!e.isZero())).map((e=>(0,i.inspect)(e))).join(", ")}],\n      l2ToL1Msgs: [${this.l2ToL1Msgs.filter((e=>!e.isZero())).map((e=>(0,i.inspect)(e))).join(", ")}],\n      noteEncryptedLogsHash: ${this.noteEncryptedLogsHash.toString()},\n      encryptedLogsHash: ${this.encryptedLogsHash.toString()},\n      unencryptedLogsHash: ${this.unencryptedLogsHash.toString()},\n      noteEncryptedLogPreimagesLength: ${this.noteEncryptedLogPreimagesLength.toString()},\n      encryptedLogPreimagesLength: ${this.encryptedLogPreimagesLength.toString()},\n      unencryptedLogPreimagesLength: ${this.unencryptedLogPreimagesLength.toString()},\n      publicDataUpdateRequests: [${this.publicDataUpdateRequests.filter((e=>!e.isEmpty())).map((e=>(0,i.inspect)(e))).join(", ")}],\n      gasUsed: ${(0,i.inspect)(this.gasUsed)}\n    }`}}class gi{constructor(e,t,n,s){this.historicalHeader=e,this.txContext=t,this.vkTreeRoot=n,this.globalVariables=s}toBuffer(){return Ce(this.historicalHeader,this.txContext,this.vkTreeRoot,this.globalVariables)}getSize(){return this.historicalHeader.getSize()+this.txContext.getSize()+this.globalVariables.getSize()}static from({historicalHeader:e,txContext:t,vkTreeRoot:n,globalVariables:s}){return new gi(e,t,n,s)}static fromBuffer(e){const t=L.asReader(e);return new gi(t.readObject(Ra),t.readObject(fi),X.fromBuffer(t),t.readObject(wa))}static fromFields(e){const t=je.asReader(e);return new gi(t.readObject(Ra),t.readObject(fi),t.readField(),t.readObject(wa))}static empty(){return new gi(Ra.empty(),fi.empty(),X.ZERO,wa.empty())}}r(8891).Buffer;class bi{constructor(e,t){this.isSome=e,this.value=t}toBuffer(){return Ce(...bi.getFields(this))}toFields(){const e=ke(...bi.getFields(this));if(2!==e.length)throw new Error(`Invalid number of fields for MaxBlockNumber. Expected 2, got ${e.length}`);return e}static fromBuffer(e){const t=L.asReader(e);return new bi(t.readBoolean(),X.fromBuffer(t))}static fromFields(e){const t=je.asReader(e);return new bi(t.readBoolean(),t.readField())}static empty(){return new bi(!1,X.ZERO)}isEmpty(){return!this.isSome&&this.value.isZero()}static from(e){return new bi(...bi.getFields(e))}static getFields(e){return[e.isSome,e.value]}}var yi=r(8891).Buffer;class vi{constructor(e){this.maxBlockNumber=e}getSize(){return this.toBuffer().length}toBuffer(){return Ce(this.maxBlockNumber)}toString(){return this.toBuffer().toString("hex")}static fromFields(e){const t=je.asReader(e);return new vi(bi.fromFields(t))}static fromBuffer(e){const t=L.asReader(e);return new vi(t.readObject(bi))}static fromString(e){return vi.fromBuffer(yi.from(e,"hex"))}static empty(){return new vi(bi.empty())}}var wi=r(8891).Buffer;class Ai{constructor(e,t,n,s,r,a){this.rollupValidationRequests=e,this.end=t,this.constants=n,this.startState=s,this.revertCode=r,this.feePayer=a}getNonEmptyNullifiers(){return this.end.nullifiers.filter((e=>!e.isZero()))}getTransactionFee(e){return this.end.gasUsed.computeFee(e).add(this.constants.txContext.gasSettings.inclusionFee)}toBuffer(){return Ce(this.rollupValidationRequests,this.end,this.constants,this.startState,this.revertCode,this.feePayer)}static fromBuffer(e){const t=L.asReader(e);return new Ai(t.readObject(vi),t.readObject(mi),t.readObject(gi),t.readObject(Ga),t.readObject(Ka),t.readObject(Nr))}static empty(){return new Ai(vi.empty(),mi.empty(),gi.empty(),Ga.empty(),Ka.OK,Nr.ZERO)}toString(){return this.toBuffer().toString("hex")}static fromString(e){return Ai.fromBuffer(wi.from(e,"hex"))}}var Ei=r(8891).Buffer;class xi{constructor(e,t){this.buffer=e,this.numPublicInputs=t}static fromBuffer(e){const t=L.asReader(e),n=t.readNumber(),s=t.readBytes(n),r=t.readNumber();return new xi(s,r)}toBuffer(){return Ce(this.buffer.length,this.buffer,this.numPublicInputs)}toString(){return this.toBuffer().toString("hex")}withoutPublicInputs(){return this.numPublicInputs>0?this.buffer.subarray(ee.SIZE_IN_BYTES*this.numPublicInputs):this.buffer}static fromString(e){return xi.fromBuffer(Ei.from(e,"hex"))}}r(8891).Buffer,r(8891).Buffer,r(8891).Buffer;class Si{constructor(e,t){this.pkM=e,this.skApp=t instanceof X?t:new X(t.toBigInt())}toBuffer(){return Ce(this.pkM,this.skApp)}get skAppAsGrumpkinScalar(){return new D(this.skApp.toBigInt())}static fromBuffer(e){const t=L.asReader(e);return new Si(Ie.fromBuffer(t),X.fromBuffer(t))}toFields(){const e=[this.pkM.toFields(),this.skApp].flat();if(4!==e.length)throw new Error(`Invalid number of fields for KeyValidationRequest. Expected 4, got ${e.length}`);return e}static fromFields(e){const t=je.asReader(e);return new Si(Ie.fromFields(t),t.readField())}isEmpty(){return this.pkM.isZero()&&this.skApp.isZero()}static empty(){return new Si(Ie.ZERO,X.ZERO)}static random(){return new Si(Ie.random(),X.random())}}class Ti{constructor(e,t){this.request=e,this.skAppGenerator=t}toBuffer(){return Ce(this.request,this.skAppGenerator)}static fromBuffer(e){const t=L.asReader(e);return new Ti(t.readObject(Si),X.fromBuffer(t))}toFields(){const e=[...this.request.toFields(),this.skAppGenerator];if(5!==e.length)throw new Error(`Invalid number of fields for KeyValidationRequestAndGenerator. Expected 5, got ${e.length}`);return e}static fromFields(e){const t=je.asReader(e);return new Ti(Si.fromFields(t),t.readField())}isEmpty(){return this.request.isEmpty()&&this.skAppGenerator.isZero()}static empty(){return new Ti(Si.empty(),X.ZERO)}}class ki{constructor(e,t,n){this.leafSlot=e,this.value=t,this.sideEffectCounter=n}static from(e){return new ki(e.leafIndex,e.value)}toBuffer(){return Ce(this.leafSlot,this.value)}isEmpty(){return this.leafSlot.isZero()&&this.value.isZero()}static fromFields(e){const t=je.asReader(e);return new ki(t.readField(),t.readField())}static fromBuffer(e){const t=L.asReader(e);return new ki(X.fromBuffer(t),X.fromBuffer(t))}static empty(){return new ki(X.ZERO,X.ZERO)}toFriendlyJSON(){return`Leaf=${this.leafSlot.toFriendlyJSON()}: ${this.value.toFriendlyJSON()}`}equals(e){return this.leafSlot.equals(e.leafSlot)&&this.value.equals(e.value)}}class Ci{constructor(e,t){this.request=e,this.contractAddress=t}toBuffer(){return Ce(this.request,this.contractAddress)}static fromBuffer(e){const t=L.asReader(e);return new Ci(Ti.fromBuffer(t),Nr.fromBuffer(t))}toFields(){const e=[...this.request.toFields(),this.contractAddress];if(6!==e.length)throw new Error(`Invalid number of fields for ScopedKeyValidationRequestAndGenerator. Expected 6, got ${e.length}`);return e}static fromFields(e){const t=je.asReader(e);return new Ci(Ti.fromFields(t),Nr.fromFields(t))}isEmpty(){return this.request.isEmpty()&&this.contractAddress.isZero()}static empty(){return new Ci(Ti.empty(),Nr.ZERO)}}var zi,Pi,Fi=r(8891).Buffer;class Ni{constructor(e,t,n,s,r,a){this.forRollup=e,this.noteHashReadRequests=t,this.nullifierReadRequests=n,this.nullifierNonExistentReadRequests=s,this.scopedKeyValidationRequestsAndGenerators=r,this.publicDataReads=a}getSize(){return this.forRollup.getSize()+la(this.noteHashReadRequests)+la(this.nullifierReadRequests)+la(this.nullifierNonExistentReadRequests)+la(this.scopedKeyValidationRequestsAndGenerators)+la(this.publicDataReads)}toBuffer(){return Ce(this.forRollup,this.noteHashReadRequests,this.nullifierReadRequests,this.nullifierNonExistentReadRequests,this.scopedKeyValidationRequestsAndGenerators,this.publicDataReads)}toString(){return this.toBuffer().toString("hex")}static fromFields(e){const t=je.asReader(e);return new Ni(t.readObject(vi),t.readArray(64,Ua),t.readArray(64,Ua),t.readArray(64,Ua),t.readArray(64,Ci),t.readArray(64,ki))}static fromBuffer(e){const t=L.asReader(e);return new Ni(t.readObject(vi),t.readArray(64,Ua),t.readArray(64,Ua),t.readArray(64,Ua),t.readArray(64,Ci),t.readArray(64,ki))}static fromString(e){return Ni.fromBuffer(Fi.from(e,"hex"))}static empty(){return new Ni(vi.empty(),ha(64,Ua.empty),ha(64,Ua.empty),ha(64,Ua.empty),ha(64,Ci.empty),ha(64,ki.empty))}[i.inspect.custom](){return`ValidationRequests {\n  forRollup: ${(0,i.inspect)(this.forRollup)},\n  noteHashReadRequests: [${this.noteHashReadRequests.filter((e=>!e.isEmpty())).map((e=>(0,i.inspect)(e))).join(", ")}],\n  nullifierReadRequests: [${this.nullifierReadRequests.filter((e=>!e.isEmpty())).map((e=>(0,i.inspect)(e))).join(", ")}],\n  nullifierNonExistentReadRequests: [${this.nullifierNonExistentReadRequests.filter((e=>!e.isEmpty())).map((e=>(0,i.inspect)(e))).join(", ")}],\n  scopedKeyValidationRequestsAndGenerators: [${this.scopedKeyValidationRequestsAndGenerators.filter((e=>!e.isEmpty())).map((e=>(0,i.inspect)(e))).join(", ")}],\n  publicDataReads: [${this.publicDataReads.filter((e=>!e.isEmpty())).map((e=>(0,i.inspect)(e))).join(", ")}]\n}`}}class Gi{constructor(e,t,n,s){this.origin=e,this.functionData=t,this.argsHash=n,this.txContext=s}static getFields(e){return[e.origin,e.functionData,e.argsHash,e.txContext]}static from(e){return new Gi(...Gi.getFields(e))}toBuffer(){return Ce([...Gi.getFields(this)])}toFields(){const e=ke(...Gi.getFields(this));if(13!==e.length)throw new Error(`Invalid number of fields for TxRequest. Expected 13, got ${e.length}`);return e}static fromBuffer(e){const t=L.asReader(e);return new Gi(t.readObject(Nr),t.readObject(hi),X.fromBuffer(t),t.readObject(fi))}async hash(){return await Me(this.toFields(),nt.TX_REQUEST)}static empty(){return new Gi(Nr.ZERO,hi.empty(),X.zero(),fi.empty())}isEmpty(){return this.origin.isZero()&&this.functionData.isEmpty()&&this.argsHash.isZero()&&this.txContext.isEmpty()}}(Pi=zi||(zi={}))[Pi.NADA=0]="NADA",Pi[Pi.PENDING=1]="PENDING",Pi[Pi.SETTLED=2]="SETTLED";var Li=r(8891).Buffer;class Oi{constructor(e,t,n){this.nullifier=e,this.nextNullifier=t,this.nextIndex=n}getKey(){return this.nullifier.toBigInt()}getNextKey(){return this.nextNullifier.toBigInt()}getNextIndex(){return this.nextIndex}asLeaf(){return new Ri(this.nullifier)}toBuffer(){return Li.concat(this.toHashInputs())}toHashInputs(){return[Li.from(this.nullifier.toBuffer()),Li.from(this.nextNullifier.toBuffer()),Li.from(c(this.nextIndex,32))]}toFields(){return this.toHashInputs().map((e=>X.fromBuffer(e)))}clone(){return new Oi(this.nullifier,this.nextNullifier,this.nextIndex)}toJSON(){return{nullifier:this.nullifier.toString(),nextNullifier:this.nextNullifier.toString(),nextIndex:"0x"+this.nextIndex.toString(16)}}static empty(){return new Oi(X.ZERO,X.ZERO,0n)}static fromBuffer(e){const t=L.asReader(e);return new Oi(t.readObject(X),t.readObject(X),l(t.readBytes(32)))}static fromLeaf(e,t,n){return new Oi(e.nullifier,new X(t),n)}static clone(e){return new Oi(e.nullifier,e.nextNullifier,e.nextIndex)}static fromJSON(e){return new Oi(X.fromString(e.nullifier),X.fromString(e.nextNullifier),BigInt(e.nextIndex))}}class Ri{constructor(e){this.nullifier=e}getKey(){return this.nullifier.toBigInt()}toBuffer(){return this.nullifier.toBuffer()}isEmpty(){return this.nullifier.isZero()}updateTo(e){throw new Error("Nullifiers are create only")}static buildDummy(e){return new Ri(new X(e))}static fromBuffer(e){return new Ri(X.fromBuffer(e))}}var Mi=r(8891).Buffer;class Bi{constructor(e,t,n,s){this.slot=e,this.value=t,this.nextSlot=n,this.nextIndex=s}getKey(){return this.slot.toBigInt()}getNextKey(){return this.nextSlot.toBigInt()}getNextIndex(){return this.nextIndex}asLeaf(){return new Yi(this.slot,this.value)}toBuffer(){return Mi.concat(this.toHashInputs())}toHashInputs(){return[Mi.from(this.slot.toBuffer()),Mi.from(this.value.toBuffer()),Mi.from(c(this.nextIndex,32)),Mi.from(this.nextSlot.toBuffer())]}clone(){return new Bi(this.slot,this.value,this.nextSlot,this.nextIndex)}static empty(){return new Bi(X.ZERO,X.ZERO,X.ZERO,0n)}static fromBuffer(e){const t=L.asReader(e),n=X.fromBuffer(t),s=X.fromBuffer(t),r=l(t.readBytes(32)),a=X.fromBuffer(t);return new Bi(n,s,a,r)}static fromLeaf(e,t,n){return new Bi(e.slot,e.value,new X(t),n)}static clone(e){return new Bi(e.slot,e.value,e.nextSlot,e.nextIndex)}}class Yi{constructor(e,t){this.slot=e,this.value=t}getKey(){return this.slot.toBigInt()}toBuffer(){return Ce([this.slot,this.value])}static fromBuffer(e){const t=L.asReader(e);return new Yi(X.fromBuffer(t),X.fromBuffer(t))}equals(e){return this.slot.equals(e.slot)&&this.value.equals(e.value)}toString(){return`PublicDataTreeLeaf(${this.slot.toString()}, ${this.value.toString()})`}isEmpty(){return this.slot.isZero()&&this.value.isZero()}updateTo(e){if(!this.slot.equals(e.slot))throw new Error("Invalid update: slots do not match");return new Yi(this.slot,e.value)}static buildDummy(e){return new Yi(new X(e),new X(0))}static empty(){return new Yi(X.ZERO,X.ZERO)}}var ji=r(8891).Buffer;class Hi{constructor(e,t,n,s,r,a,i,o,l){this.noteHashes=e,this.nullifiers=t,this.l2ToL1Msgs=n,this.noteEncryptedLogsHashes=s,this.encryptedLogsHashes=r,this.unencryptedLogsHashes=a,this.publicDataUpdateRequests=i,this.publicCallStack=o,this.gasUsed=l}getSize(){return la(this.noteHashes)+la(this.nullifiers)+la(this.l2ToL1Msgs)+la(this.noteEncryptedLogsHashes)+la(this.encryptedLogsHashes)+la(this.unencryptedLogsHashes)+la(this.publicDataUpdateRequests)+la(this.publicCallStack)+this.gasUsed.toBuffer().length}toBuffer(){return Ce(this.noteHashes,this.nullifiers,this.l2ToL1Msgs,this.noteEncryptedLogsHashes,this.encryptedLogsHashes,this.unencryptedLogsHashes,this.publicDataUpdateRequests,this.publicCallStack,this.gasUsed)}toString(){return this.toBuffer().toString("hex")}isEmpty(){return this.noteHashes.every((e=>e.isEmpty()))&&this.nullifiers.every((e=>e.isEmpty()))&&this.l2ToL1Msgs.every((e=>e.isZero()))&&this.noteEncryptedLogsHashes.every((e=>e.isEmpty()))&&this.encryptedLogsHashes.every((e=>e.isEmpty()))&&this.unencryptedLogsHashes.every((e=>e.isEmpty()))&&this.publicDataUpdateRequests.every((e=>e.isEmpty()))&&this.publicCallStack.every((e=>e.isEmpty()))&&this.gasUsed.isEmpty()}[i.inspect.custom](){return`PublicAccumulatedData {\n  noteHashes: [${this.noteHashes.filter((e=>!e.isEmpty())).map((e=>(0,i.inspect)(e))).join(", ")}],\n  nullifiers: [${this.nullifiers.filter((e=>!e.isEmpty())).map((e=>(0,i.inspect)(e))).join(", ")}],\n  l2ToL1Msgs: [${this.l2ToL1Msgs.filter((e=>!e.isZero())).map((e=>(0,i.inspect)(e))).join(", ")}],\n  noteEncryptedLogsHashes: [${this.noteEncryptedLogsHashes.filter((e=>!e.isEmpty())).map((e=>(0,i.inspect)(e))).join(", ")}],\n  encryptedLogsHashes: [${this.encryptedLogsHashes.filter((e=>!e.isEmpty())).map((e=>(0,i.inspect)(e))).join(", ")}],\n  unencryptedLogsHashes: [${this.unencryptedLogsHashes.filter((e=>!e.isEmpty())).map((e=>(0,i.inspect)(e))).join(", ")}],\n  publicDataUpdateRequests: [${this.publicDataUpdateRequests.filter((e=>!e.isEmpty())).map((e=>(0,i.inspect)(e))).join(", ")}],\n  publicCallStack: [${this.publicCallStack.filter((e=>!e.isEmpty())).map((e=>(0,i.inspect)(e))).join(", ")}],\n  gasUsed: [${(0,i.inspect)(this.gasUsed)}]\n}`}static fromBuffer(e){const t=L.asReader(e);return new this(t.readArray(Je,Ya),t.readArray(De,Ha),t.readArray(8,X),t.readArray(64,Ba),t.readArray(8,Ba),t.readArray(8,Ba),t.readArray(63,pi),t.readArray(qe,Va),t.readObject(fa))}static fromFields(e){const t=je.asReader(e);return new this(t.readArray(Je,Ya),t.readArray(De,Ha),t.readFieldArray(8),t.readArray(64,Ba),t.readArray(8,Ba),t.readArray(8,Ba),t.readArray(63,pi),t.readArray(qe,Va),t.readObject(fa))}static fromString(e){return this.fromBuffer(ji.from(e,"hex"))}static empty(){return new this(ha(Je,Ya.empty),ha(De,Ha.empty),ha(8,X.zero),ha(64,Ba.empty),ha(8,Ba.empty),ha(8,Ba.empty),ha(63,pi.empty),ha(qe,Va.empty),fa.empty())}}var Ii=r(8891).Buffer;class Xi{constructor(e,t,n,s,r,a,i){this.validationRequests=e,this.endNonRevertibleData=t,this.end=n,this.constants=s,this.revertCode=r,this.publicTeardownCallStack=a,this.feePayer=i}toBuffer(){return Ce(this.validationRequests,this.endNonRevertibleData,this.end,this.constants,this.revertCode,this.publicTeardownCallStack,this.feePayer)}clone(){return Xi.fromBuffer(this.toBuffer())}toString(){return this.toBuffer().toString("hex")}static fromString(e){return Xi.fromBuffer(Ii.from(e,"hex"))}get needsSetup(){return!this.endNonRevertibleData.publicCallStack[0].isEmpty()}get needsAppLogic(){return!this.end.publicCallStack[0].isEmpty()}get needsTeardown(){return!this.publicTeardownCallStack[0].isEmpty()}static fromBuffer(e){const t=L.asReader(e);return new Xi(t.readObject(Ni),t.readObject(Hi),t.readObject(Hi),t.readObject(gi),t.readObject(Ka),t.readArray(qe,Va),t.readObject(Nr))}static empty(){return new Xi(Ni.empty(),Hi.empty(),Hi.empty(),gi.empty(),Ka.OK,ha(qe,Va.empty),Nr.ZERO)}static fromFields(e){const t=je.asReader(e);return new Xi(Ni.fromFields(t),Hi.fromFields(t),Hi.fromFields(t),gi.fromFields(t),Ka.fromField(t.readField()),t.readArray(qe,Va),Nr.fromFields(t))}[i.inspect.custom](){return`PublicKernelCircuitPublicInputs {\n      validationRequests: ${(0,i.inspect)(this.validationRequests)},\n      endNonRevertibleData: ${(0,i.inspect)(this.endNonRevertibleData)},\n      end: ${(0,i.inspect)(this.end)},\n      constants: ${(0,i.inspect)(this.constants)},\n      revertCode: ${this.revertCode},\n      publicTeardownCallStack: ${(0,i.inspect)(this.publicTeardownCallStack)}\n      feePayer: ${this.feePayer}\n      }`}}class Ui{constructor(e,t,n,s){this.validationRequests=e,this.endNonRevertibleData=t,this.end=n,this.publicTeardownCallStack=s}getSize(){return this.validationRequests.getSize()+this.endNonRevertibleData.getSize()+this.end.getSize()+la(this.publicTeardownCallStack)}get needsSetup(){return!this.endNonRevertibleData.publicCallStack[0].isEmpty()}get needsAppLogic(){return!this.end.publicCallStack[0].isEmpty()}get needsTeardown(){return!this.publicTeardownCallStack[0].isEmpty()}static fromBuffer(e){const t=L.asReader(e);return new Ui(t.readObject(Ni),t.readObject(Hi),t.readObject(Hi),t.readArray(qe,Va))}toBuffer(){return Ce(this.validationRequests,this.endNonRevertibleData,this.end,this.publicTeardownCallStack)}static empty(){return new Ui(Ni.empty(),Hi.empty(),Hi.empty(),ha(qe,Va.empty))}}class Ji{constructor(e,t){this.rollupValidationRequests=e,this.end=t}static fromBuffer(e){const t=L.asReader(e);return new Ji(t.readObject(vi),t.readObject(mi))}getSize(){return this.rollupValidationRequests.getSize()+this.end.getSize()}toBuffer(){return Ce(this.rollupValidationRequests,this.end)}static empty(){return new Ji(vi.empty(),mi.empty())}}class Di{constructor(e,t,n,s,r){if(this.constants=e,this.revertCode=t,this.feePayer=n,this.forPublic=s,this.forRollup=r,!s&&!r)throw new Error("Missing partial public inputs for private tail circuit.");if(s&&r)throw new Error("Cannot create PrivateKernelTailCircuitPublicInputs that is for both public kernel circuit and rollup circuit.")}get publicInputs(){return this.forPublic??this.forRollup}getSize(){return(this.forPublic?.getSize()??0)+(this.forRollup?.getSize()??0)+this.constants.getSize()+this.revertCode.getSerializedLength()+this.feePayer.size}toPublicKernelCircuitPublicInputs(){if(!this.forPublic)throw new Error("Private tail public inputs is not for public circuit.");return new Xi(this.forPublic.validationRequests,this.forPublic.endNonRevertibleData,this.forPublic.end,this.constants,this.revertCode,this.forPublic.publicTeardownCallStack,this.feePayer)}toKernelCircuitPublicInputs(){if(!this.forRollup)throw new Error("Private tail public inputs is not for rollup circuit.");return new Ai(this.forRollup.rollupValidationRequests,this.forRollup.end,this.constants,Ga.empty(),this.revertCode,this.feePayer)}numberOfPublicCallRequests(){return this.forPublic?pa(this.forPublic.endNonRevertibleData.publicCallStack)+pa(this.forPublic.end.publicCallStack)+pa(this.forPublic.publicTeardownCallStack):0}getNonEmptyNoteHashes(){return(this.forPublic?_a(this.forPublic.endNonRevertibleData.noteHashes,this.forPublic.end.noteHashes).map((e=>e.value)):this.forRollup.end.noteHashes).filter((e=>!e.isZero()))}getNonEmptyNullifiers(){return(this.forPublic?_a(this.forPublic.endNonRevertibleData.nullifiers,this.forPublic.end.nullifiers).map((e=>e.value)):this.forRollup.end.nullifiers).filter((e=>!e.isZero()))}static fromBuffer(e){const t=L.asReader(e),n=t.readBoolean();return new Di(t.readObject(gi),t.readObject(Ka),t.readObject(Nr),n?t.readObject(Ui):void 0,n?void 0:t.readObject(Ji))}toBuffer(){const e=!!this.forPublic;return Ce(e,this.constants,this.revertCode,this.feePayer,e?this.forPublic.toBuffer():this.forRollup.toBuffer())}static empty(){return new Di(gi.empty(),Ka.OK,Nr.ZERO,void 0,Ji.empty())}}class qi{constructor(e,t,n,s,r,a,i,o){this.contractAddress=e,this.callContext=t,this.functionData=n,this.argsHash=s,this.returnsHash=r,this.revertCode=a,this.startGasLeft=i,this.endGasLeft=o}static getFields(e){return[e.contractAddress,e.callContext,e.functionData,e.argsHash,e.returnsHash,e.revertCode,e.startGasLeft,e.endGasLeft]}toFields(){const e=ke(...qi.getFields(this));if(15!==e.length)throw new Error(`Invalid number of fields for PublicCallStackItemCompressed. Expected 15, got ${e.length}`);return e}toBuffer(){return Ce(...qi.getFields(this))}static fromBuffer(e){const t=L.asReader(e);return new qi(t.readObject(Nr),t.readObject(ga),t.readObject(hi),t.readObject(X),t.readObject(X),t.readObject(Ka),t.readObject(fa),t.readObject(fa))}static fromFields(e){const t=je.asReader(e);return new qi(Nr.fromFields(t),ga.fromFields(t),hi.fromFields(t),t.readField(),t.readField(),Ka.fromFields(t),fa.fromFields(t),fa.fromFields(t))}static empty(){return new qi(Nr.ZERO,ga.empty(),hi.empty({isPrivate:!1}),X.ZERO,X.ZERO,Ka.OK,fa.empty(),fa.empty())}isEmpty(){return this.contractAddress.isZero()&&this.callContext.isEmpty()&&this.functionData.isEmpty()&&this.argsHash.isEmpty()&&this.returnsHash.isEmpty()&&this.revertCode===Ka.OK&&this.startGasLeft.isEmpty()&&this.endGasLeft.isEmpty()}async hash(){return await Me(this.toFields(),nt.CALL_STACK_ITEM)}}class Ki{constructor(e,t,n,s){this.contractAddress=e,this.functionData=t,this.publicInputs=n,this.isExecutionRequest=s}static getFields(e){return[e.contractAddress,e.functionData,e.publicInputs,e.isExecutionRequest]}toBuffer(){return Ce(...Ki.getFields(this))}static fromBuffer(e){const t=L.asReader(e);return new Ki(t.readObject(Nr),t.readObject(hi),t.readObject(Wa),t.readBoolean())}static fromFields(e){const t=je.asReader(e),n=Nr.fromFields(t),s=hi.fromFields(t),r=Wa.fromFields(t),a=t.readBoolean();return new Ki(n,s,r,a)}static empty(){return new Ki(Nr.ZERO,hi.empty({isPrivate:!1}),Wa.empty(),!1)}isEmpty(){return this.contractAddress.isZero()&&this.functionData.isEmpty()&&this.publicInputs.isEmpty()}getCompressed(){let e=this.publicInputs;if(this.isExecutionRequest){const{callContext:t,argsHash:n}=this.publicInputs;e=Wa.empty(),e.callContext=t,e.argsHash=n}return new qi(this.contractAddress,e.callContext,this.functionData,e.argsHash,e.returnsHash,e.revertCode,e.startGasLeft,e.endGasLeft)}async toCallRequest(e){if(this.isEmpty())return Va.empty();const t=this.publicInputs.callContext.isDelegateCall?new Za(e.msgSender,e.storageContractAddress,e.isStaticCall):Za.empty(),n=await this.getCompressed().hash();return new Va(n,e.storageContractAddress,t,X.ZERO,X.ZERO)}}r(8891).Buffer,r(8891).Buffer,r(8891).Buffer,r(8891).Buffer,r(8891).Buffer,r(8891).Buffer;class Wi{constructor(e,t,n,s,r,a){this.contractAddress=e,this.functionSelector=t,this.callContext=n,this.parentCallContext=s,this.sideEffectCounter=r,this.args=a}getSize(){return this.isEmpty()?0:this.toBuffer().length}toBuffer(){return Ce(this.contractAddress,this.functionSelector,this.callContext,this.parentCallContext,this.sideEffectCounter,new Sa(this.args))}static fromBuffer(e){const t=L.asReader(e);return new Wi(new Nr(t.readBytes(32)),Ur.fromBuffer(t),ga.fromBuffer(t),ga.fromBuffer(t),t.readNumber(),t.readVector(X))}static from(e){return new Wi(...Wi.getFields(e))}static getFields(e){return[e.contractAddress,e.functionSelector,e.callContext,e.parentCallContext,e.sideEffectCounter,e.args]}async toPublicCallStackItem(){const e=Wa.empty();return e.callContext=this.callContext,e.argsHash=await this.getArgsHash(),new Ki(this.contractAddress,new hi(this.functionSelector,!1),e,!0)}async toCallRequest(){const e=await this.toPublicCallStackItem(),t=this.callContext.isDelegateCall?new Za(this.parentCallContext.msgSender,this.parentCallContext.storageContractAddress,this.parentCallContext.isStaticCall):Za.empty();return new Va(await e.getCompressed().hash(),this.parentCallContext.storageContractAddress,t,new X(this.sideEffectCounter),X.ZERO)}async getArgsHash(){return await Zi(this.args)}static empty(){return new Wi(Nr.ZERO,Ur.empty(),ga.empty(),ga.empty(),0,[])}isEmpty(){return this.contractAddress.isZero()&&this.functionSelector.isEmpty()&&this.callContext.isEmpty()&&this.parentCallContext.isEmpty()&&0==this.sideEffectCounter&&0===this.args.length}[i.inspect.custom](){return`PublicCallRequest {\n      contractAddress: ${this.contractAddress}\n      functionSelector: ${this.functionSelector}\n      callContext: ${this.callContext}\n      parentCallContext: ${this.parentCallContext}\n      sideEffectCounter: ${this.sideEffectCounter}\n      args: ${this.args}\n    }`}}async function Zi(e){if(0===e.length)return X.ZERO;if(e.length>Ve)throw new Error(`Hashing ${e.length} args exceeds max of ${Ve}`);let t=await Promise.all(zr(e,We).map((async e=>(e.length<We&&(e=oa(e,X.ZERO,We)),await Me(e,nt.FUNCTION_ARGS)))));return t.length<Ze&&(t=oa(t,X.ZERO,Ze)),await Me(t,nt.FUNCTION_ARGS)}async function Vi(e){return await Me([e],nt.SECRET_HASH)}async function Qi(e){const t=await $i(e),n=e.publicKeysHash;return await ii(n,t)}async function $i(e){const t="saltedInitializationHash"in e?e.saltedInitializationHash:await async function(e){return await Me([e.salt,e.initializationHash,e.deployer],nt.PARTIAL_ADDRESS)}(e);return await Me([e.contractClassId,t],nt.PARTIAL_ADDRESS)}async function eo(e,t){const n=await Zi(t);return await Me([e,n],nt.CONSTRUCTOR)}let to;r(8891).Buffer,r(8891).Buffer,r(8891).Buffer,r(8891).Buffer,r(8891).Buffer;const no=2;async function so(e){return(await Me([e.selector,e.vkHash],nt.FUNCTION_LEAF)).toBuffer()}async function ro(e){return(await ao(e)).id}async function ao(e){const t=e.artifactHash,n="privateFunctionsRoot"in e?e.privateFunctionsRoot:await async function(e){return X.fromBuffer(await(await async function(){if(!to){const e=(await Me(new Array(no).fill(0))).toBuffer();to=new Vr(Ke),await to.setHasher(e)}return to}()).computeTreeRoot(await async function(e){const t=[...e].sort(((e,t)=>e.selector.value-t.selector.value));return await Promise.all(t.map(so))}(e)))}(e.privateFunctions),s="publicBytecodeCommitment"in e?e.publicBytecodeCommitment:io(e.packedBytecode);return{id:await Me([t,n,s],nt.CONTRACT_LEAF),artifactHash:t,privateFunctionsRoot:n,publicBytecodeCommitment:s}}function io(e){return new X(5)}function oo(e){return L.asReader(e).readVector({fromBuffer:e=>({selector:Ur.fromBuffer(e.readBytes(4)),bytecode:e.readBuffer()})})}const lo=(e,t)=>e.selector.toField().cmp(t.selector.toField());async function co(e){const t="artifactHash"in e?e.artifactHash:await sa(e),n=e.functions.filter((e=>e.functionType===xr.PUBLIC)).map((e=>({selector:Ur.fromNameAndParameters(e.name,e.parameters),bytecode:e.bytecode}))).sort(lo),s={version:1,artifactHash:t,publicFunctions:n,packedBytecode:(r=n,xe(r.map((e=>Ce(e.selector,function(e,t=4){const n=ge.alloc(t);return n.writeInt32BE(e,t-4),n}(e.bytecode.length),e.bytecode))))),privateFunctions:e.functions.filter((e=>e.functionType===xr.PRIVATE)).map(uo).sort(lo)};var r;return{...s,...await ao(s)}}function uo(e){return{selector:Ur.fromNameAndParameters(e.name,e.parameters),vkHash:(e.verificationKey,X.ZERO)}}var fo=r(8891).Buffer;class ho{constructor(e,t,n,s,r){this.contractClassId=e,this.version=t,this.artifactHash=n,this.privateFunctionsRoot=s,this.packedPublicBytecode=r}static isContractClassRegisteredEvent(e){return l(e.subarray(0,32))==$e}static fromLogs(e,t){return e.filter((e=>ho.isContractClassRegisteredEvent(e.data))).filter((e=>e.contractAddress.equals(t))).map((e=>this.fromLogData(e.data)))}static fromLogData(e){if(!this.isContractClassRegisteredEvent(e))throw new Error(`Log data for ContractClassRegisteredEvent is not prefixed with magic value 0x${$e}`);const t=new L(e.subarray(32)),n=t.readObject(X),s=t.readObject(X).toNumber(),r=t.readObject(X),a=t.readObject(X),i=function(e){const[t,...n]=e;return Pr.concat(n.map((e=>e.toBuffer().subarray(1)))).subarray(0,t.toNumber())}(zr(t.readToEnd(),X.SIZE_IN_BYTES).map(fo.from).map(X.fromBuffer));return new ho(n,s,r,a,i)}async toContractClassPublic(){const e=await ro({artifactHash:this.artifactHash,privateFunctionsRoot:this.privateFunctionsRoot,publicBytecodeCommitment:io(this.packedPublicBytecode)});if(!e.equals(this.contractClassId))throw new Error(`Invalid contract class id: computed ${e.toString()} but event broadcasted ${this.contractClassId.toString()}`);if(1!==this.version)throw new Error(`Unexpected contract class version ${this.version}`);return{id:this.contractClassId,artifactHash:this.artifactHash,packedBytecode:this.packedPublicBytecode,privateFunctionsRoot:this.privateFunctionsRoot,publicFunctions:oo(this.packedPublicBytecode),version:this.version,privateFunctions:[],unconstrainedFunctions:[]}}}async function po(e,t){const n=t.constructorArgs??[],s=t.salt??X.random(),r=function(e,t){if("string"==typeof t){const n=e.functions.find((e=>e.name===t));if(!n)throw new Error(`No constructor found with name ${t}`);return n}return t??Cr(e)}(e,t.constructorArtifact),a=t.deployer??Nr.ZERO,i=await co(e),o=await ro(i),l=r&&t?.skipArgsDecoding?await eo(Ur.fromNameAndParameters(r?.name,r?.parameters),n):await async function(e,t){if(!e)return X.ZERO;const n=Ur.fromNameAndParameters(e.name,e.parameters),s=Yr(e,t);return await eo(n,s)}(r,n),c={contractClassId:o,initializationHash:l,publicKeysHash:t.publicKeysHash??X.ZERO,salt:s,deployer:a,version:1};return{...c,address:await Qi(c)}}r(8891).Buffer,r(8891).Buffer;var _o=r(8891).Buffer;class mo{constructor(e,t){this.requestHash=e,this.witness=t.map((e=>new X(e)))}toBuffer(){return Ce(this.requestHash,new Sa(this.witness))}static fromBuffer(e){const t=L.asReader(e);return new mo(X.fromBuffer(t),t.readVector(X))}toString(){return"0x"+this.toBuffer().toString("hex")}static fromString(e){const t=e.replace(/^0x/,"");return mo.fromBuffer(_o.from(t,"hex"))}}function go(e,t){return new Promise((n=>setTimeout((()=>n(t)),e)))}class bo{constructor(){this.start=performance?performance.now():Date.now()}us(){return 1e3*this.ms()}ms(){return(performance?performance.now():Date.now())-this.start}s(){return this.ms()/1e3}}class yo extends Error{}async function vo(e,t="Operation",n=function*(){const e=[1,1,1,2,4,8,16,32,64];let t=0;for(;;)yield e[Math.min(t++,e.length-1)]}(),s=y("aztec:foundation:retry"),r=!1){for(;;)try{return await e()}catch(e){if(e instanceof yo)throw e;const a=n.next().value;if(void 0===a)throw e;s.verbose(`${t} failed. Will retry in ${a}s...`),!r&&s.error(e),await go(1e3*a);continue}}async function wo(e,t="",n=0,s=1){const r=new bo;for(;;){const a=await e();if(a)return a;if(await go(1e3*s),n&&r.s()>n)throw new Error(t?`Timeout awaiting ${t}`:"Timeout")}}function Ao(e,t){if(!e)throw new Error(t)}class Eo{constructor(e,t){if(this.toClass=new Map,this.toName=new Map,e)for(const t of Object.keys(e))this.register(t,e[t],"string");if(t)for(const e of Object.keys(t))this.register(e,t[e],"object")}register(e,t,n){Ao("Buffer"!==e,"'Buffer' handling is hardcoded. Cannot use as name."),Ao(t.prototype.toString||t.prototype.toJSON,`Class ${e} must define a toString() OR toJSON() method.`),Ao(t.fromString||t.fromJSON,`Class ${e} must define a fromString() OR fromJSON() static method.`),this.toName.set(t,[e,n]),this.toClass.set(e,[t,n])}isRegisteredClassName(e){return this.toClass.has(e)}isRegisteredClass(e){if(!e||!e.constructor)return!1;const t=e.constructor.name;return this.toName.has(e)||this.isRegisteredClassName(t)}toClassObj(e){const t=this.toClass.get(e.type);Ao(t,"Could not find type in lookup.");const[n,s]=t;return"string"===s&&"string"==typeof e.data?n.fromString(e.data):n.fromJSON(e.data)}toJsonObj(e){const{type:t,encoding:n}=this.lookupObject(e);return{type:t,data:"string"===n?e.toString():e.toJSON()}}lookupObject(e){const t=this.toName.get(e.constructor);if(t)return{type:t[0],encoding:t[1]};const n=this.toClass.get(e.constructor.name);if(n)return{type:e.constructor.name,encoding:n[1]};throw new Error(`Could not find class ${e.constructor.name} in lookup.`)}}var xo=r(8891);function So(e,t){return JSON.stringify(e,((e,t)=>"bigint"==typeof t?JSON.stringify({type:"bigint",data:t.toString()}):t),t?2:0)}function To(e,t){if(null!==t){if(void 0===t)return t;if(t&&"Buffer"===t.type&&"string"==typeof t.data)return xo.Buffer.from(t.data,"base64");if("bigint"===t.type&&"string"==typeof t.data)return BigInt(t.data);if("string"==typeof t.type){if(e.isRegisteredClassName(t.type))return e.toClassObj(t);throw new Error(`Object ${t.type} not registered for serialization FROM JSON`)}if(Array.isArray(t))return t.map((t=>To(e,t)));if("object"==typeof t){const n={};for(const s of Object.keys(t))n[s]=To(e,t[s]);return n}return t}}function ko(e,t){if("bigint"==typeof t)return{type:"bigint",data:t.toString()};if(!t)return t;if(xo.Buffer.isBuffer(t))return{type:"Buffer",data:t.toString("base64")};if(e.isRegisteredClass(t.constructor))return e.toJsonObj(t);if(Array.isArray(t))return t.map((t=>ko(e,t)));if("object"==typeof t){if(function(e){if(null===e)return!1;let t=e,n=0;for(;null!==Object.getPrototypeOf(t);){if(n>=1e3)return!1;t=Object.getPrototypeOf(t),n++}return Object.getPrototypeOf(e)===t}(t)){const n={};for(const s of Object.keys(t))n[s]=ko(e,t[s]);return n}throw new Error(`Object ${t.constructor.name} not registered for serialization TO JSON`)}return t}r(2617);const Co=y("json-rpc:json_rpc_client");async function zo(e,t,n,s,r=!1){let a,o;Co.debug((0,i.format)("JsonRpcClient.fetch",e,t,"->",n)),a=s?await fetch(`${e}/${t}`,{method:"POST",body:So(n),headers:{"content-type":"application/json"}}):await fetch(e,{method:"POST",body:So({...n,method:t}),headers:{"content-type":"application/json"}});try{o=await a.json()}catch(e){if(!a.ok)throw new Error(a.statusText);throw new Error(`Failed to parse body as JSON: ${a.text()}`)}if(!a.ok)throw r||a.status>=400&&a.status<500?new yo("(JSON-RPC PROPAGATED) "+o.error.message):new Error("(JSON-RPC PROPAGATED) "+o.error.message);return o}function Po(e,t,n){return async(s,r,a,i)=>await vo((()=>zo(s,r,a,i,t)),`JsonRpcClient request ${r} to ${s}`,function*(e){for(const t of e)yield t}(e),n,!1)}function Fo(e,t,n,s,r,a=zo){const o=new Eo(t,n);let l=0;const c=async(t,n)=>{const r={jsonrpc:"2.0",id:l++,method:t,params:n.map((e=>ko(o,e)))};Co.debug((0,i.format)("JsonRpcClient.request",t,"<-",n));const c=await a(e,t,r,s);if(Co.debug((0,i.format)("JsonRpcClient.result",t,"->",c)),c.error)throw c.error;if(![null,void 0,"null","undefined"].includes(c.result))return To(o,c.result)};return new Proxy({},{get:(e,t)=>{if("symbol"==typeof t)return Reflect.get(e,t);let n=t;return r&&(n=`${r}_${t}`),["then","catch"].includes(t)?Reflect.get(e,t):(...e)=>(Co.debug((0,i.format)("JsonRpcClient.constructor","proxy",n,"<-",e)),c(n,e))}})}var No=r(8891).Buffer;class Go{static ZERO(e,t,n){const s=[];let r=t;for(let t=0;t<e;++t)s.push(r),r=n.hash(r,r);return new Go(e,s)}constructor(e,t){this.pathSize=e,this.data=function(e,t){if(e.length!==t)throw new Error(`Wrong 'fixed array' size. Expected ${t}, got ${e.length}.`);return e}(t,e)}toBuffer(){return xe(this.data)}toBufferArray(){return this.data}toFields(){return this.data.map((e=>X.fromBuffer(e)))}toTuple(){const e=this.toFields();return ha(e.length,(t=>e[t]),0)}static fromBuffer(e,t=0){const{elem:n}=Go.deserialize(e,t);return n}static deserialize(e,t=0){const{elem:n,adv:s}=function(e,t,n=0){let s=n;const r=t.readUInt32BE(s);s+=4;const a=new Array(r);for(let n=0;n<r;++n){const{elem:r,adv:i}=e(t,s);s+=i,a[n]=r}return{elem:a,adv:s-n}}(((e,t)=>({elem:e.slice(t,t+32),adv:32})),e,t),r=n.length;return{elem:new Go(r,n),adv:s}}toString(){return this.toBuffer().toString("hex")}static fromString(e){return Go.fromBuffer(No.from(e,"hex"))}getSubtreeSiblingPath(e){const t=this.data.slice(e),n=this.pathSize-e;return new Go(n,t)}}class Lo{constructor(e,t,n){this.index=e,this.leafPreimage=t,this.siblingPath=n}toFields(){return[new X(this.index),...this.leafPreimage.toFields(),...this.siblingPath.toFields()]}toJSON(){return{index:"0x"+this.index.toString(16),leafPreimage:this.leafPreimage.toJSON(),siblingPath:this.siblingPath.toString()}}static fromJSON(e){return new Lo(BigInt(e.index),Oi.fromJSON(e.leafPreimage),Go.fromString(e.siblingPath))}}var Oo=r(8891).Buffer;class Ro{encryptBufferCBC(e,t,n){return console.log("encryptBufferCBC not supported"),Oo.from(e)}decryptBufferCBC(e,t,n){return console.log("decryptBufferCBC not supported"),Oo.from(e)}}r(8891).Buffer,r(8891).Buffer;var Mo=r(8891).Buffer;class Bo{generator(){return Bo.generator}mul(e,t){throw new Error("mul not supported")}getRandomFr(){throw new Error("getRandomFr not supported")}reduce512BufferToFr(e){throw new Error("reduce512BufferToFr not supported")}}Bo.generator=Mo.from([121,190,102,126,249,220,187,172,85,160,98,149,206,135,11,7,2,155,252,219,45,206,40,217,89,242,129,91,22,248,23,152,72,58,218,119,38,163,196,101,93,164,251,252,14,17,8,168,253,23,180,72,166,133,84,25,156,71,208,143,251,16,212,184]);var Yo=r(8891).Buffer;class jo{constructor(e){if(this.buffer=e,e.length!==jo.SIZE)throw new Error(`Invalid signature buffer of length ${e.length}.`)}static isSignature(e){return/^(0x)?[0-9a-f]{128}$/i.test(e)}static fromString(e){if(!jo.isSignature(e))throw new Error(`Invalid signature string: ${e}`);return new jo(Yo.from(e.replace(/^0x/i,""),"hex"))}static random(){return new jo(k(64))}get s(){return this.buffer.subarray(0,32)}get e(){return this.buffer.subarray(32)}toBuffer(){return this.buffer}static fromBuffer(e){const t=L.asReader(e);return new jo(t.readBytes(jo.SIZE))}toString(){return`0x${this.buffer.toString("hex")}`}toFields(){const e=this.toBuffer(),t=Yo.alloc(32),n=Yo.alloc(32),s=Yo.alloc(32);return e.copy(t,1,0,31),e.copy(n,1,31,62),e.copy(s,1,62,64),function(e,t){return e.map(t)}([t,n,s],X.fromBuffer)}}jo.SIZE=64,jo.EMPTY=new jo(Yo.alloc(64));class Ho{computePublicKey(e){return console.log("computePublicKey not supported"),{x:e.toBuffer(),y:e.toBuffer()}}constructSignature(e,t){return console.log("constructSignature not supported"),t}verifySignature(e,t,n){return console.log("constructSignature not supported"),!1}}function Io(e=0,t=void 0,n=void 0,s=void 0){return new Ra(Xo(e+256),function(e=0,t,n){return new xa(new X(e),t??c(BigInt(e+256),Ea),n??c(BigInt(e+512),Ea),c(BigInt(e+768),Ea))}(e+512,n,s),function(e=0){return new La(Xo(e),function(e=0){return new Ga(Xo(e),Xo(e+1),Xo(e+2))}(e+1))}(e+1536),function(e=1,t){return new wa(new X(e),new X(e+1),new X(void 0!==t?t:e+2),new X(e+3),da.fromField(new X(e+4)),Nr.fromField(new X(e+5)),new va(new X(e+6),new X(e+7)))}(e+=1792,t),new X(BigInt(e+2048)))}function Xo(e=1){return new Na(new X(e),e)}r(8891).Buffer;var Uo=r(8891).Buffer;class Jo{constructor(e,t,n){this.archive=e,this.header=t,this.body=n}static fromFields(e){return new this(e.archive,e.header,e.body)}static fromBuffer(e){const t=L.asReader(e),n=t.readObject(Ra),s=t.readObject(Na),r=t.readObject(fc);return Jo.fromFields({archive:s,header:n,body:r})}toBuffer(){return Ce(this.header,this.archive,this.body)}static fromString(e){return Jo.fromBuffer(Uo.from(e,Pa))}toString(){return this.toBuffer().toString(Pa)}static random(e,t=4,n=2,s=3,r=2,a=1,i=void 0){const o=fc.random(t,n,s,r,a),l=o.getTxsEffectsHash();return Jo.fromFields({archive:Xo(1),header:Io(0,e,l,i),body:o})}static empty(){return Jo.fromFields({archive:Na.zero(),header:Ra.empty(),body:fc.empty()})}get number(){return Number(this.header.globalVariables.blockNumber.toBigInt())}async hash(){return await this.header.hash()}getPublicInputsHash(){const e=[this.header.globalVariables,Na.zero(),Na.zero(),Na.zero(),Na.zero(),this.header.lastArchive,this.header.state.partial.noteHashTree,this.header.state.partial.nullifierTree,this.header.state.partial.publicDataTree,this.header.state.l1ToL2MessageTree,this.archive,this.body.getTxsEffectsHash()];return Ge(e)}getStartStateHash(){const e=Ce(new X(Number(this.header.globalVariables.blockNumber.toBigInt())-1),Na.zero(),Na.zero(),Na.zero(),Na.zero(),this.header.lastArchive);return Fe(e)}getEndStateHash(){const e=Ce(this.header.globalVariables.blockNumber,this.header.state.partial.noteHashTree,this.header.state.partial.nullifierTree,this.header.state.partial.publicDataTree,this.header.state.l1ToL2MessageTree,this.archive);return Fe(e)}getStats(){const e={noteEncryptedLogLength:this.body.txEffects.reduce(((e,t)=>e+t.noteEncryptedLogs.getSerializedLength()),0),noteEncryptedLogCount:this.body.txEffects.reduce(((e,t)=>e+t.noteEncryptedLogs.getTotalLogCount()),0),encryptedLogLength:this.body.txEffects.reduce(((e,t)=>e+t.encryptedLogs.getSerializedLength()),0),encryptedLogCount:this.body.txEffects.reduce(((e,t)=>e+t.encryptedLogs.getTotalLogCount()),0),unencryptedLogCount:this.body.txEffects.reduce(((e,t)=>e+t.unencryptedLogs.getTotalLogCount()),0),unencryptedLogSize:this.body.txEffects.reduce(((e,t)=>e+t.unencryptedLogs.getSerializedLength()),0)};return{txCount:this.body.txEffects.length,blockNumber:this.number,...e}}}var Do=r(8891).Buffer;class qo{constructor(e){this.data=e}get length(){return this.data.length}toBuffer(){return this.data}toJSON(){return{data:this.data.toString("hex")}}static fromJSON(e){return new qo(Do.from(e.data,"hex"))}static fromBuffer(e){return new qo(e)}hash(){const e=this.toBuffer();return Ne(e)}getSiloedHash(){return this.hash()}static random(){const e=Ie.random(),t=k(144-Ie.SIZE_IN_BYTES),n=Do.concat([X.random().toBuffer(),t,e.toBuffer()]);return new qo(n)}static empty(){return new qo(Do.alloc(0))}}var Ko=r(8891).Buffer;class Wo{constructor(e,t){this.data=e,this.maskedContractAddress=t}get length(){return this.data.length}toBuffer(){return Ko.concat([this.maskedContractAddress.toBuffer(),this.data])}toJSON(){return{data:this.data.toString("hex"),maskedContractAddress:this.maskedContractAddress.toString()}}static fromJSON(e){return new Wo(Ko.from(e.data,"hex"),X.fromString(e.maskedContractAddress))}static fromBuffer(e){return new Wo(e.subarray(32),new X(e.subarray(0,32)))}hash(){return Ne(this.data)}getSiloedHash(){const e=this.hash();return Ne(Ko.concat([this.maskedContractAddress.toBuffer(),e]))}static random(){const e=Ie.random(),t=k(144-Ie.SIZE_IN_BYTES),n=Ko.concat([X.random().toBuffer(),t,e.toBuffer()]);return new Wo(n,X.random())}}var Zo=r(8891).Buffer;class Vo{constructor(e,t){this.contractAddress=e,this.data=t}get length(){return this.data.length+Nr.SIZE_IN_BYTES+4}toBuffer(){return Zo.concat([this.contractAddress.toBuffer(),ve(this.data)])}toHumanReadable(){const e=function(e){const t=e.every((e=>e>=32&&e<=126))?e.toString("ascii"):`0x${e.toString("hex")}`;return t}(this.data);return`UnencryptedL2Log(contractAddress: ${this.contractAddress.toString()}, data: ${e})`}toJSON(){return{contractAddress:this.contractAddress.toString(),data:this.data.toString("hex")}}static fromJSON(e){return new Vo(Nr.fromString(e.contractAddress),Zo.from(e.data,"hex"))}static fromBuffer(e){const t=L.asReader(e),n=Nr.fromBuffer(t),s=t.readBuffer();return new Vo(n,s)}hash(){const e=this.toBuffer();return Ne(e)}getSiloedHash(){const e=this.hash();return Ne(Zo.concat([this.contractAddress.toBuffer(),e]))}static random(){const e=Nr.random(),t=k(1)[0],n=k(t);return new Vo(e,n)}}var Qo=r(8891).Buffer;class $o{constructor(e){this.logs=e}toBuffer(){const e=this.logs.map((e=>ve(e.toBuffer())));return ve(Qo.concat(e))}getSerializedLength(){return this.getKernelLength()+4}getKernelLength(){return this.logs.reduce(((e,t)=>e+t.length+4),0)}hash(){const e=Qo.concat(this.logs.map((e=>e.hash())));return Ne(e)}toJSON(){return{logs:this.logs.map((e=>e.toJSON()))}}}class el extends $o{static empty(){return new el([])}static fromBuffer(e,t=!0){const n=new L(e,0),s=t?n.readNumber():-1,r=n.readBufferArray(s);return new el(r.map(qo.fromBuffer))}static random(e){if(e>16)throw new Error(`Trying to create ${e} logs for one call (max: 16)`);const t=[];for(let n=0;n<e;n++)t.push(qo.random());return new el(t)}static fromJSON(e){const t=e.logs.map(qo.fromJSON);return new el(t)}}class tl extends $o{static empty(){return new tl([])}static fromBuffer(e,t=!0){const n=new L(e,0),s=t?n.readNumber():-1,r=n.readBufferArray(s);return new tl(r.map(Wo.fromBuffer))}static random(e){if(e>4)throw new Error(`Trying to create ${e} logs for one call (max: 4)`);const t=[];for(let n=0;n<e;n++)t.push(Wo.random());return new tl(t)}static fromJSON(e){const t=e.logs.map(Wo.fromJSON);return new tl(t)}}class nl extends $o{static empty(){return new nl([])}static fromBuffer(e,t=!0){const n=new L(e,0),s=t?n.readNumber():-1,r=n.readBufferArray(s);return new nl(r.map(Vo.fromBuffer))}static random(e){if(e>4)throw new Error(`Trying to create ${e} logs for one call (max: 4)`);const t=[];for(let n=0;n<e;n++)t.push(Vo.random());return new nl(t)}static fromJSON(e){const t=e.logs.map(Vo.fromJSON);return new nl(t)}}var sl=r(7842),rl=r(8891).Buffer;class al{constructor(e){this.functionLogs=e}toBuffer(){const e=this.functionLogs.map((e=>e.toBuffer()));return ve(rl.concat(e))}getSerializedLength(){return this.functionLogs.reduce(((e,t)=>e+t.getSerializedLength()),0)+4}getKernelLength(){return this.functionLogs.reduce(((e,t)=>e+t.getKernelLength()),0)}getTotalLogCount(){return this.functionLogs.reduce(((e,t)=>e+t.logs.length),0)}addFunctionLogs(e){this.functionLogs.push(...e)}toJSON(){return{functionLogs:this.functionLogs.map((e=>e.toJSON()))}}unrollLogs(){return this.functionLogs.flatMap((e=>e.logs))}equals(e){return sl(this,e)}filter(e,t){for(const n of this.functionLogs){let s=!1;for(const t of n.logs)-1!==e.findIndex((e=>e.value.equals(X.fromBuffer(t.getSiloedHash()))))&&(s=!0);s&&t.addFunctionLogs([n])}return t}}class il extends al{static empty(){return new il([])}static fromBuffer(e,t=!0){const n=L.asReader(e),s=t?n.readNumber():-1,r=n.readBufferArray(s).map((e=>nl.fromBuffer(e,!1)));return new il(r)}static random(e,t){if(e*t>8)throw new Error(`Trying to create ${e*t} logs for one tx (max: 8)`);const n=[];for(let s=0;s<e;s++)n.push(nl.random(t));return new il(n)}static fromJSON(e){const t=e.functionLogs.map((e=>nl.fromJSON(e)));return new il(t)}hash(){const e=this.unrollLogs();if(0==e.length)return rl.alloc(32);let t=rl.alloc(0);for(const n of e)t=rl.concat([t,n.getSiloedHash()]);for(let n=0;n<8-e.length;n++)t=rl.concat([t,rl.alloc(32)]);return Ne(t)}}class ol extends al{static empty(){return new ol([])}static fromBuffer(e,t=!0){const n=L.asReader(e),s=t?n.readNumber():-1,r=n.readBufferArray(s).map((e=>el.fromBuffer(e,!1)));return new ol(r)}static random(e,t){if(e*t>64)throw new Error(`Trying to create ${e*t} logs for one tx (max: 64)`);const n=[];for(let s=0;s<e;s++)n.push(el.random(t));return new ol(n)}static fromJSON(e){const t=e.functionLogs.map((e=>el.fromJSON(e)));return new ol(t)}hash(){const e=this.unrollLogs();if(0==e.length)return rl.alloc(32);let t=rl.alloc(0);for(const n of e)t=rl.concat([t,n.hash()]);for(let n=0;n<64-e.length;n++)t=rl.concat([t,rl.alloc(32)]);return Ne(t)}}class ll extends al{static empty(){return new ll([])}static fromBuffer(e,t=!0){const n=L.asReader(e),s=t?n.readNumber():-1,r=n.readBufferArray(s).map((e=>tl.fromBuffer(e,!1)));return new ll(r)}static random(e,t){if(e*t>8)throw new Error(`Trying to create ${e*t} logs for one tx (max: 8)`);const n=[];for(let s=0;s<e;s++)n.push(tl.random(t));return new ll(n)}static fromJSON(e){const t=e.functionLogs.map((e=>tl.fromJSON(e)));return new ll(t)}hash(){const e=this.unrollLogs();if(0==e.length)return rl.alloc(32);let t=rl.alloc(0);for(const n of e)t=rl.concat([t,n.getSiloedHash()]);for(let n=0;n<8-e.length;n++)t=rl.concat([t,rl.alloc(32)]);return Ne(t)}}var cl=r(8891).Buffer;class dl{constructor(e){this.txLogs=e}toBuffer(){const e=this.txLogs.map((e=>e.toBuffer()));return ve(cl.concat(e))}getSerializedLength(){return this.txLogs.reduce(((e,t)=>e+t.getSerializedLength()),0)+4}getTotalLogCount(){return this.txLogs.reduce(((e,t)=>e+t.getTotalLogCount()),0)}toString(){return this.toBuffer().toString("hex")}toJSON(){return{txLogs:this.txLogs.map((e=>e.toJSON()))}}equals(e){return sl(this,e)}static getTotalLogCount(e){return e.reduce(((e,t)=>e+t.getTotalLogCount()),0)}}class ul extends dl{static fromJSON(e){const t=e.txLogs.map((e=>ol.fromJSON(e)));return new ul(t)}static fromBuffer(e){const t=L.asReader(e),n=t.readNumber(),s=t.readBufferArray(n).map((e=>ol.fromBuffer(e,!1)));return new ul(s)}static fromString(e){const t=cl.from(e,"hex");return ul.fromBuffer(t)}static random(e,t,n){const s=[];for(let r=0;r<e;r++)s.push(ol.random(t,n));return new ul(s)}static unrollLogs(e){const t=[];for(const n of e)if(n)for(const e of n.txLogs)t.push(...e.unrollLogs());return t}}class fl extends dl{static fromJSON(e){const t=e.txLogs.map((e=>ll.fromJSON(e)));return new fl(t)}static fromBuffer(e){const t=L.asReader(e),n=t.readNumber(),s=t.readBufferArray(n).map((e=>ll.fromBuffer(e,!1)));return new fl(s)}static fromString(e){const t=cl.from(e,"hex");return fl.fromBuffer(t)}static random(e,t,n){const s=[];for(let r=0;r<e;r++)s.push(ll.random(t,n));return new fl(s)}static unrollLogs(e){const t=[];for(const n of e)if(n)for(const e of n.txLogs)t.push(...e.unrollLogs());return t}}class hl extends dl{static fromJSON(e){const t=e.txLogs.map((e=>il.fromJSON(e)));return new hl(t)}static fromBuffer(e){const t=L.asReader(e),n=t.readNumber(),s=t.readBufferArray(n).map((e=>il.fromBuffer(e,!1)));return new hl(s)}static fromString(e){const t=cl.from(e,"hex");return hl.fromBuffer(t)}static random(e,t,n){const s=[];for(let r=0;r<e;r++)s.push(il.random(t,n));return new hl(s)}static unrollLogs(e){const t=[];for(const n of e)if(n)for(const e of n.txLogs)t.push(...e.unrollLogs());return t}}var pl,_l=r(8891).Buffer;class ml{constructor(e,t,n){if(this.blockNumber=e,this.txIndex=t,this.logIndex=n,!Number.isInteger(e)||e<Qe)throw new Error(`Invalid block number: ${e}`);if(!Number.isInteger(t))throw new Error(`Invalid tx index: ${t}`);if(!Number.isInteger(n))throw new Error(`Invalid log index: ${n}`)}toBuffer(){return _l.concat([c(BigInt(this.blockNumber),4),c(BigInt(this.txIndex),4),c(BigInt(this.logIndex),4)])}static fromBuffer(e){const t=L.asReader(e),n=t.readNumber(),s=t.readNumber(),r=t.readNumber();return new ml(n,s,r)}toString(){return`${this.blockNumber}-${this.txIndex}-${this.logIndex}`}static fromString(e){const[t,n,s]=e.split("-"),r=Number(t),a=Number(n),i=Number(s);return new ml(r,a,i)}toHumanReadable(){return`logId: (blockNumber: ${this.blockNumber}, txIndex: ${this.txIndex}, logIndex: ${this.logIndex})`}}!function(e){e[e.NOTEENCRYPTED=0]="NOTEENCRYPTED",e[e.ENCRYPTED=1]="ENCRYPTED",e[e.UNENCRYPTED=2]="UNENCRYPTED"}(pl||(pl={})),r(721);var gl=r(8891).Buffer;async function bl(e,t){if(t.isZero())throw new Error("Attempting to derive AES secret with a zero public key. You have probably passed a zero public key in your Noir code somewhere thinking that the note won't broadcasted... but it was.");const n=new $a,s=await n.mul(t,e),r=gl.concat([s.toBuffer(),ye(nt.SYMMETRIC_KEY)]);return Fe(r)}r(8891).Buffer;var yl=r(8891).Buffer;class vl extends Sa{static fromBuffer(e){const t=L.asReader(e);return new vl(t.readVector(X))}static random(){const e=C(10)+1,t=Array.from({length:e},(()=>X.random()));return new vl(t)}toString(){return"0x"+this.toBuffer().toString("hex")}static fromString(e){const t=e.replace(/^0x/,"");return vl.fromBuffer(yl.from(t,"hex"))}get length(){return this.items.length}equals(e){return this.items.every(((t,n)=>t.equals(e.items[n])))}}class wl extends vl{}class Al extends vl{}var El=r(8891).Buffer;class xl{static async fromCiphertextToBuffer(e,t,n){const s=El.isBuffer(e)?e:El.from(e.map((e=>Number(e)))),r=await bl(t,n),a=r.subarray(0,16),i=r.subarray(16,32);return(new Ro).decryptBufferCBC(s,i,a)}async computeCiphertext(e,t){const n=bl(e,t),s=(await n).subarray(0,16),r=(await n).subarray(16,32),a=new Ro,i=this.toBuffer();return a.encryptBufferCBC(i,r,s)}}class Sl extends xl{constructor(e,t,n){super(),this.randomness=e,this.eventTypeId=t,this.event=n}toBuffer(){const e=this.event.toBuffer().subarray(4);return Ce(this.randomness,this.eventTypeId,e)}static fromBuffer(e){const t=L.asReader(e),n=X.fromBuffer(t),s=X.fromBuffer(t),r=t.getLength()/32-2,a=new wl(t.readArray(r,X));return new Sl(n,s,a)}static async fromCiphertext(e,t,n){const s=await super.fromCiphertextToBuffer(e,t,n);return Sl.fromBuffer(s)}}class Tl extends xl{constructor(e,t,n){super(),this.storageSlot=e,this.noteTypeId=t,this.note=n}toBuffer(){const e=this.note.toBuffer().subarray(4);return Ce(this.storageSlot,this.noteTypeId.toField(),e)}static fromBuffer(e){const t=L.asReader(e),n=X.fromBuffer(t),s=Dr.fromField(X.fromBuffer(t)),r=t.getLength()/32-2,a=new Al(t.readArray(r,X));return new Tl(n,s,a)}static async fromCiphertext(e,t,n){const s=await super.fromCiphertextToBuffer(e,t,n);return Tl.fromBuffer(s)}}var kl=r(8891).Buffer;class Cl{constructor(e){this.address=e}toBuffer(){return this.address.toBuffer()}static fromBuffer(e){return new Cl(Nr.fromBuffer(e))}async computeCiphertext(e,t){const n=await bl(e,t),s=n.subarray(0,16),r=n.subarray(16,32),a=new Ro,i=this.toBuffer();return a.encryptBufferCBC(i,r,s)}static async fromCiphertext(e,t,n){const s=kl.isBuffer(e)?e:kl.from(e.map((e=>Number(e)))),r=await bl(t,n),a=r.subarray(0,16),i=r.subarray(16,32),o=(new Ro).decryptBufferCBC(s,i,a);return Cl.fromBuffer(o)}}var zl=r(8891).Buffer;class Pl{constructor(e,t,n){this.ephSk=e,this.recipient=t,this.recipientIvpkApp=n}toBuffer(){const e=Ce([this.ephSk.hi,this.ephSk.lo]);return Ce(e,this.recipient,this.recipientIvpkApp)}static fromBuffer(e){const t=L.asReader(e),n=t.readObject(X),s=t.readObject(X),r=D.fromHighLow(n,s),a=t.readObject(Nr),i=t.readObject(Ie);return new Pl(r,a,i)}async computeCiphertext(e,t){const n=await Pl.derivePoseidonAESSecret(e,t),s=n.subarray(0,16),r=n.subarray(16,32),a=new Ro,i=this.toBuffer();return a.encryptBufferCBC(i,r,s)}static async fromCiphertext(e,t,n){const s=zl.isBuffer(e)?e:zl.from(e.map((e=>Number(e)))),r=await Pl.derivePoseidonAESSecret(t,n),a=r.subarray(0,16),i=r.subarray(16,32),o=(new Ro).decryptBufferCBC(s,i,a);return Pl.fromBuffer(o)}static async derivePoseidonAESSecret(e,t){return(await Ye([e.hi,e.lo,t.x,t.y,nt.SYMMETRIC_KEY])).toBuffer()}}var Fl=r(8891).Buffer;class Nl{async _encrypt(e,t,n,s,r,a){if(s.isZero())throw new Error("Attempting to encrypt an event log with a zero ivpk.");const i=await oi(t),o=new Cl(e),l=await o.computeCiphertext(t,s),c=await o.computeCiphertext(t,r.pkM),d=s,u=await a.computeCiphertext(t,d),f=await new Pl(t,n,d).computeCiphertext(r.skAppAsGrumpkinScalar,i);return Fl.concat([i.toBuffer(),l,c,f,u])}static async _decryptAsIncoming(e,t,n){const s=L.asReader(e),r=s.readObject(Ie),a=await Cl.fromCiphertext(s.readBytes(48),t,r);s.readBytes(48),s.readBytes(176);const i=s.readToEnd(),o=function(e){return e}(t,a.address),l=await n(i,o,r);return[a.address,l]}static async _decryptAsOutgoing(e,t,n){const s=L.asReader(e),r=s.readObject(Ie);s.readBytes(48);const a=await Cl.fromCiphertext(s.readBytes(48),t,r),i=await async function(e,t){const n=await si(e,t,"ov");return D.fromBuffer(n.toBuffer())}(t,a.address),o=await Pl.fromCiphertext(s.readBytes(176),i,r),l=s.readToEnd(),c=await n(l,o.ephSk,o.recipientIvpkApp);return[a.address,c]}static async ensureMatchedMaskedContractAddress(e,t,n){if(!(await Me([e,t],0)).equals(n))throw new Error("The provided masked contract address does not match with the incoming address from header and randomness from body")}}class Gl extends Nl{constructor(e,t,n,s){super(),this.event=e,this.contractAddress=t,this.randomness=n,this.eventTypeId=s}static fromBuffer(e){const t=L.asReader(e);return new Gl(t.readObject(wl),t.readObject(Nr),X.fromBuffer(t),t.readObject(Ir))}toBuffer(){return Ce([this.event,this.contractAddress,this.randomness,this.eventTypeId])}static random(){return new Gl(wl.random(),Nr.random(),X.random(),Ir.random())}async encrypt(e,t,n,s){return await super._encrypt(this.contractAddress,e,t,n,s,new Sl(this.randomness,this.eventTypeId.toField(),this.event))}static async decryptAsIncoming(e,t){const n=L.asReader(e.data);X.fromBuffer(n),X.fromBuffer(n);const[s,r]=await super._decryptAsIncoming(n.readToEnd(),t,Sl.fromCiphertext),a=Ir.fromField(r.eventTypeId);return this.ensureMatchedMaskedContractAddress(s,r.randomness,e.maskedContractAddress),new Gl(r.event,s,r.randomness,a)}static async decryptAsOutgoing(e,t){const n=L.asReader(e.data);X.fromBuffer(n),X.fromBuffer(n);const[s,r]=await super._decryptAsOutgoing(n.readToEnd(),t,Sl.fromCiphertext),a=Ir.fromField(r.eventTypeId);return this.ensureMatchedMaskedContractAddress(s,r.randomness,e.maskedContractAddress),new Gl(r.event,s,r.randomness,a)}}var Ll=r(8891).Buffer;class Ol extends Nl{constructor(e,t,n,s){super(),this.note=e,this.contractAddress=t,this.storageSlot=n,this.noteTypeId=s}static fromBuffer(e){const t=L.asReader(e);return new Ol(t.readObject(Al),t.readObject(Nr),X.fromBuffer(t),t.readObject(Dr))}toBuffer(){return Ce([this.note,this.contractAddress,this.storageSlot,this.noteTypeId])}static random(e=Nr.random()){return new Ol(Al.random(),e,X.random(),Dr.random())}encrypt(e,t,n,s){return super._encrypt(this.contractAddress,e,t,n,s,new Tl(this.storageSlot,this.noteTypeId,this.note))}static async decryptAsIncoming(e,t){const n=Ll.isBuffer(e)?e:Ll.from(e.map((e=>Number(e)))),s=L.asReader(n),[r,a]=await super._decryptAsIncoming(s.readToEnd(),t,Tl.fromCiphertext);return new Ol(a.note,r,a.storageSlot,a.noteTypeId)}static async decryptAsOutgoing(e,t){const n=Ll.isBuffer(e)?e:Ll.from(e.map((e=>Number(e)))),s=L.asReader(n),[r,a]=await super._decryptAsOutgoing(s.readToEnd(),t,Tl.fromCiphertext);return new Ol(a.note,r,a.storageSlot,a.noteTypeId)}equals(e){return this.note.equals(e.note)&&this.contractAddress.equals(e.contractAddress)&&this.storageSlot.equals(e.storageSlot)&&this.noteTypeId.equals(e.noteTypeId)}}var Rl=r(8891).Buffer;const Ml=new X(33);class Bl{constructor(e,t=Ml,n=Ml){this.payload=e,this.incomingTag=t,this.outgoingTag=n}static fromBuffer(e,t=Ol){const n=L.asReader(e),s=X.fromBuffer(n),r=X.fromBuffer(n),a=t===Ol?Ol.fromBuffer(n):Gl.fromBuffer(n);return new Bl(a,s,r)}toBuffer(){return Ce(this.incomingTag,this.outgoingTag,this.payload)}static random(e=Ol,t=Nr.random()){return new Bl(e===Ol?Ol.random(t):Gl.random())}async encrypt(e,t,n,s){return Ce(this.incomingTag,this.outgoingTag,await this.payload.encrypt(e,t,n,s))}static async decryptAsIncoming(e,t,n=Ol){try{if(n===Gl){const n=L.asReader(e.data),s=X.fromBuffer(n),r=X.fromBuffer(n),a=await Gl.decryptAsIncoming(e,t);return new Bl(a,s,r)}{const n=Rl.isBuffer(e)?e:Rl.from(e.map((e=>Number(e)))),s=L.asReader(n),r=X.fromBuffer(s),a=X.fromBuffer(s),i=await Ol.decryptAsIncoming(s.readToEnd(),t);return new Bl(i,r,a)}}catch(e){if(!(e.message.endsWith("is greater or equal to field modulus.")||e.message.startsWith("Invalid AztecAddress length")||e.message.startsWith("Selector must fit in")||e.message.startsWith("Attempted to read beyond buffer length")))throw e;return}}static async decryptAsOutgoing(e,t,n=Ol){try{if(n===Gl){const n=L.asReader(e.data),s=X.fromBuffer(n),r=X.fromBuffer(n),a=await Gl.decryptAsOutgoing(e,t);return new Bl(a,s,r)}{const n=Rl.isBuffer(e)?e:Rl.from(e.map((e=>Number(e)))),s=L.asReader(n),r=X.fromBuffer(s),a=X.fromBuffer(s),i=await Ol.decryptAsOutgoing(s.readToEnd(),t);return new Bl(i,r,a)}}catch(e){if(!(e.message.endsWith("is greater or equal to field modulus.")||e.message.startsWith("Invalid AztecAddress length")||e.message.startsWith("Selector must fit in")||e.message.startsWith("Attempted to read beyond buffer length")))throw e;return}}}var Yl=r(8891).Buffer;class jl{constructor(e,t){this.id=e,this.log=t}toBuffer(){return Yl.concat([this.id.toBuffer(),this.log.toBuffer()])}toString(){return this.toBuffer().toString("hex")}toHumanReadable(){return`${this.id.toHumanReadable()}, ${this.log.toHumanReadable()}`}equals(e){return sl(this,e)}static fromBuffer(e){const t=L.asReader(e),n=ml.fromBuffer(t),s=Vo.fromBuffer(t);return new jl(n,s)}static fromString(e){const t=Yl.from(e,"hex");return jl.fromBuffer(t)}}var Hl,Il=r(8891).Buffer;class Xl{constructor(e,t,n){this.index=e,this.leafPreimage=t,this.siblingPath=n}toFields(){return[new X(this.index),new X(this.leafPreimage.slot),new X(this.leafPreimage.value),new X(this.leafPreimage.nextIndex),new X(this.leafPreimage.nextSlot),...this.siblingPath.toFields()]}toBuffer(){return Ce([this.index,this.leafPreimage,this.siblingPath])}toString(){return this.toBuffer().toString("hex")}static fromBuffer(e){const t=L.asReader(e);return new Xl(l(t.readBytes(32)),t.readObject(Bi),Go.fromBuffer(t.readBytes(1284)))}static fromString(e){return Xl.fromBuffer(Il.from(e,"hex"))}}function Ul(e,t){const n={};for(const s in e)n[s]=t(e[s]);return n}!function(e){e.NON_PUBLIC="non-public",e.SETUP="setup",e.APP_LOGIC="app-logic",e.TEARDOWN="teardown",e.TAIL="tail"}(Hl||(Hl={}));var Jl=r(8891).Buffer;class Dl{constructor(e,t){this.values=e,this.nested=t??[]}toJSON(){return{values:this.values?.map((e=>e.toString())),nested:this.nested.map((e=>e.toJSON()))}}static fromJSON(e){return new Dl(e.values?.map(X.fromString),e.nested?.map((e=>Dl.fromJSON(e))))}}class ql{constructor(e,t,n,s,r,a,i){this.encryptedLogs=e,this.unencryptedLogs=t,this.revertReason=n,this.constants=s,this.end=r,this.publicReturnValues=a,this.gasUsed=i}toJSON(){return{encryptedLogs:this.encryptedLogs.toJSON(),unencryptedLogs:this.unencryptedLogs.toJSON(),revertReason:this.revertReason,constants:this.constants.toBuffer().toString("hex"),end:this.end.toBuffer().toString("hex"),publicReturnValues:this.publicReturnValues.map((e=>e?.toJSON())),gasUsed:Ul(this.gasUsed,(e=>e?.toJSON()))}}static fromJSON(e){return new ql(ll.fromJSON(e.encryptedLogs),il.fromJSON(e.unencryptedLogs),e.revertReason,gi.fromBuffer(Jl.from(e.constants,"hex")),mi.fromBuffer(Jl.from(e.end,"hex")),Array.isArray(e.publicReturnValues)?e.publicReturnValues.map((e=>Dl.fromJSON(e))):[],Ul(e.gasUsed,(e=>e?fa.fromJSON(e):void 0)))}}var Kl=r(8891).Buffer;class Wl{constructor(e){if(this.buffer=e,e.length!==Wl.SIZE)throw new Error(`Expected buffer to have length ${Wl.SIZE} but was ${e.length}`)}toBuffer(){return this.buffer}static fromBuffer(e){const t=L.asReader(e);return new Wl(t.readBytes(Wl.SIZE))}equals(e){return this.buffer.equals(e.buffer)}isZero(){return this.buffer.equals(Kl.alloc(32,0))}toString(){return this.buffer.toString("hex")}toBigInt(){return function(e,t=0,n=32){return{elem:l(e.subarray(t,t+n)),adv:n}}(this.buffer,0,Wl.SIZE).elem}static fromBigInt(e){return new Wl(ze(e,Wl.SIZE))}static fromBuffer28(e){if(28!=e.length)throw new Error("Expected TxHash input buffer to be 28 bytes");const t=Kl.concat([Kl.alloc(this.SIZE-28),e]);return new Wl(t)}static fromString(e){return new Wl(Kl.from(e,"hex"))}static random(){return new Wl(Kl.from(k(Wl.SIZE)))}}Wl.SIZE=32,Wl.ZERO=new Wl(Kl.alloc(Wl.SIZE));var Zl=r(8891).Buffer;class Vl{constructor(e,t,n,s,r,a,i){this.data=e,this.proof=t,this.noteEncryptedLogs=n,this.encryptedLogs=s,this.unencryptedLogs=r,this.enqueuedPublicFunctionCalls=a,this.publicTeardownFunctionCall=i;const o=e.numberOfPublicCallRequests(),l=a.length+(i.isEmpty()?0:1);if(o!==l)throw new Error(`Mismatch number of enqueued public function calls in kernel circuit public inputs (expected\n          ${o}, got ${l})`)}hasPublicCalls(){return this.data.numberOfPublicCallRequests()>0}static fromBuffer(e){const t=L.asReader(e);return new Vl(t.readObject(Di),t.readObject(xi),t.readObject(ol),t.readObject(ll),t.readObject(il),t.readArray(t.readNumber(),Wi),t.readObject(Wi))}toBuffer(){return Ce([this.data,this.proof,this.noteEncryptedLogs,this.encryptedLogs,this.unencryptedLogs,this.enqueuedPublicFunctionCalls.length,this.enqueuedPublicFunctionCalls,this.publicTeardownFunctionCall])}toJSON(){return{data:this.data.toBuffer().toString("hex"),noteEncryptedLogs:this.noteEncryptedLogs.toBuffer().toString("hex"),encryptedLogs:this.encryptedLogs.toBuffer().toString("hex"),unencryptedLogs:this.unencryptedLogs.toBuffer().toString("hex"),proof:this.proof.toBuffer().toString("hex"),enqueuedPublicFunctions:this.enqueuedPublicFunctionCalls.map((e=>e.toBuffer().toString("hex")))??[],publicTeardownFunctionCall:this.publicTeardownFunctionCall.toBuffer().toString("hex")}}getUnencryptedLogs(e){return e.getUnencryptedLogs({txHash:this.getTxHash()})}static fromJSON(e){const t=Di.fromBuffer(Zl.from(e.data,"hex")),n=ol.fromBuffer(Zl.from(e.noteEncryptedLogs,"hex")),s=ll.fromBuffer(Zl.from(e.encryptedLogs,"hex")),r=il.fromBuffer(Zl.from(e.unencryptedLogs,"hex")),a=Zl.from(e.proof,"hex"),i=e.enqueuedPublicFunctions?e.enqueuedPublicFunctions.map((e=>Wi.fromBuffer(Zl.from(e,"hex")))):[],o=Wi.fromBuffer(Zl.from(e.publicTeardownFunctionCall,"hex"));return new Vl(t,xi.fromBuffer(a),n,s,r,i,o)}getTxHash(){const e=this.data.getNonEmptyNullifiers()[0];if(!e||e.isZero())throw new Error("Cannot get tx hash since first nullifier is missing");return new Wl(e.toBuffer())}getStats(){return{txHash:this.getTxHash().toString(),noteEncryptedLogCount:this.noteEncryptedLogs.getTotalLogCount(),encryptedLogCount:this.encryptedLogs.getTotalLogCount(),unencryptedLogCount:this.unencryptedLogs.getTotalLogCount(),noteEncryptedLogSize:this.noteEncryptedLogs.getSerializedLength(),encryptedLogSize:this.encryptedLogs.getSerializedLength(),unencryptedLogSize:this.unencryptedLogs.getSerializedLength(),newCommitmentCount:this.data.getNonEmptyNoteHashes().length,newNullifierCount:this.data.getNonEmptyNullifiers().length,proofSize:this.proof.buffer.length,size:this.toBuffer().length,feePaymentMethod:this.data.forPublic?.needsTeardown?this.data.forPublic?.needsSetup?0x43417bb1n===this.enqueuedPublicFunctionCalls.at(-1).functionSelector.toField().toBigInt()?"fpc_public":"fpc_private":"native":"none",classRegisteredCount:this.unencryptedLogs.unrollLogs().filter((e=>ho.isContractClassRegisteredEvent(e.data))).length}}getSize(){return this.data.getSize()+this.proof.buffer.length+this.noteEncryptedLogs.getSerializedLength()+this.encryptedLogs.getSerializedLength()+this.unencryptedLogs.getSerializedLength()+la(this.enqueuedPublicFunctionCalls)+la([this.publicTeardownFunctionCall])}static getHash(e){return function(e){return void 0!==e.hash}(e)?e.hash:e.getTxHash()}static getHashes(e){return e.map(Vl.getHash)}static clone(e){const t=Di.fromBuffer(e.data.toBuffer()),n=xi.fromBuffer(e.proof.toBuffer()),s=ol.fromBuffer(Zl.from(e.noteEncryptedLogs.toBuffer())),r=ll.fromBuffer(e.encryptedLogs.toBuffer()),a=il.fromBuffer(e.unencryptedLogs.toBuffer()),i=e.enqueuedPublicFunctionCalls.map((e=>Wi.fromBuffer(e.toBuffer()))),o=Wi.fromBuffer(e.publicTeardownFunctionCall.toBuffer());return new Vl(t,n,s,r,a,i,o)}filterRevertedLogs(e){this.encryptedLogs=this.encryptedLogs.filter(e.endNonRevertibleData.encryptedLogsHashes,ll.empty()),this.unencryptedLogs=this.unencryptedLogs.filter(e.endNonRevertibleData.unencryptedLogsHashes,il.empty()),this.noteEncryptedLogs=this.noteEncryptedLogs.filter(e.endNonRevertibleData.noteEncryptedLogsHashes,ol.empty())}}class Ql{constructor(e,t,n){this.tx=e,this.privateReturnValues=t,this.publicOutput=n}toJSON(){return{tx:this.tx.toJSON(),privateReturnValues:this.privateReturnValues&&this.privateReturnValues.toJSON(),publicOutput:this.publicOutput&&this.publicOutput.toJSON()}}static fromJSON(e){const t=Vl.fromJSON(e.tx),n=e.publicOutput?ql.fromJSON(e.publicOutput):void 0,s=e.privateReturnValues?Dl.fromJSON(e.privateReturnValues):void 0;return new Ql(t,s,n)}}var $l,ec=r(8891).Buffer;!function(e){e.DROPPED="dropped",e.PENDING="pending",e.SUCCESS="success",e.APP_LOGIC_REVERTED="app_logic_reverted",e.TEARDOWN_REVERTED="teardown_reverted",e.BOTH_REVERTED="both_reverted"}($l||($l={}));class tc{constructor(e,t,n,s,r,a,i){this.txHash=e,this.status=t,this.error=n,this.transactionFee=s,this.blockHash=r,this.blockNumber=a,this.debugInfo=i}toJSON(){return{txHash:this.txHash.toString(),status:this.status.toString(),error:this.error,blockHash:this.blockHash?.toString("hex"),blockNumber:this.blockNumber,transactionFee:this.transactionFee?.toString()}}static fromJSON(e){const t=Wl.fromString(e.txHash),n=e.status,s=e.error,r=e.transactionFee?BigInt(e.transactionFee):void 0,a=e.blockHash?ec.from(e.blockHash,"hex"):void 0,i=e.blockNumber?Number(e.blockNumber):void 0;return new tc(t,n,s,r,a,i)}static statusFromRevertCode(e){if(e.equals(Ka.OK))return $l.SUCCESS;if(e.equals(Ka.APP_LOGIC_REVERTED))return $l.APP_LOGIC_REVERTED;if(e.equals(Ka.TEARDOWN_REVERTED))return $l.TEARDOWN_REVERTED;if(e.equals(Ka.BOTH_REVERTED))return $l.BOTH_REVERTED;throw new Error(`Unknown revert code: ${e}`)}}new WeakMap;var nc=r(8891).Buffer;class sc{constructor(e,t,n,s,r,a,i,o,l,c,d,u){if(this.revertCode=e,this.transactionFee=t,this.noteHashes=n,this.nullifiers=s,this.l2ToL1Msgs=r,this.publicDataWrites=a,this.noteEncryptedLogsLength=i,this.encryptedLogsLength=o,this.unencryptedLogsLength=l,this.noteEncryptedLogs=c,this.encryptedLogs=d,this.unencryptedLogs=u,n.length>Je)throw new Error(`Too many note hashes: ${n.length}, max: 64`);if(n.forEach((e=>{if(e.isZero())throw new Error("Note hash is zero")})),s.length>De)throw new Error(`Too many nullifiers: ${s.length}, max: 64`);if(s.forEach((e=>{if(e.isZero())throw new Error("Nullifier is zero")})),r.length>8)throw new Error(`Too many L2 to L1 messages: ${r.length}, max: 8`);if(r.forEach((e=>{if(e.isZero())throw new Error("L2 to L1 message is zero")})),a.length>64)throw new Error(`Too many public data writes: ${a.length}, max: 64`);a.forEach((e=>{if(e.isEmpty())throw new Error("Public data write is empty")}))}toBuffer(){return Ce([this.revertCode,this.transactionFee,xe(this.noteHashes,1),xe(this.nullifiers,1),xe(this.l2ToL1Msgs,1),xe(this.publicDataWrites,1),this.noteEncryptedLogsLength,this.encryptedLogsLength,this.unencryptedLogsLength,this.noteEncryptedLogs,this.encryptedLogs,this.unencryptedLogs])}static fromBuffer(e){const t=L.asReader(e);return new sc(Ka.fromBuffer(t),X.fromBuffer(t),t.readVectorUint8Prefix(X),t.readVectorUint8Prefix(X),t.readVectorUint8Prefix(X),t.readVectorUint8Prefix(Tc),X.fromBuffer(t),X.fromBuffer(t),X.fromBuffer(t),t.readObject(ol),t.readObject(ll),t.readObject(il))}hash(){const e=(e,t)=>nc.concat([e,nc.alloc(t-e.length)]),t=e(Ce(this.noteHashes),X.SIZE_IN_BYTES*Je),n=e(Ce(this.nullifiers),X.SIZE_IN_BYTES*De),s=e(Ce(this.l2ToL1Msgs),8*X.SIZE_IN_BYTES),r=e(Ce(this.publicDataWrites),64*Tc.SIZE_IN_BYTES),a=this.noteEncryptedLogs.hash(),i=this.encryptedLogs.hash(),o=this.unencryptedLogs.hash(),l=nc.concat([this.revertCode.toHashPreimage(),this.transactionFee.toBuffer(),t,n,s,r,this.noteEncryptedLogsLength.toBuffer(),this.encryptedLogsLength.toBuffer(),this.unencryptedLogsLength.toBuffer(),a,i,o]);return Ne(l)}static random(e=2,t=3,n=2,s=1){const r=ol.random(e,n),a=ll.random(e,n),i=il.random(t,s);return new sc(Ka.random(),X.random(),ha(Je,X.random),ha(De,X.random),ha(8,X.random),ha(64,Tc.random),new X(r.getKernelLength()),new X(a.getKernelLength()),new X(i.getKernelLength()),r,a,i)}static empty(){return new sc(Ka.OK,X.ZERO,[],[],[],[],X.ZERO,X.ZERO,X.ZERO,ol.empty(),ll.empty(),il.empty())}isEmpty(){return 0===this.nullifiers.length}toString(){return this.toBuffer().toString("hex")}[i.inspect.custom](){return`TxEffect { \n      revertCode: ${this.revertCode},\n      transactionFee: ${this.transactionFee},\n      note hashes: [${this.noteHashes.map((e=>e.toString())).join(", ")}],\n      nullifiers: [${this.nullifiers.map((e=>e.toString())).join(", ")}],\n      l2ToL1Msgs: [${this.l2ToL1Msgs.map((e=>e.toString())).join(", ")}],\n      publicDataWrites: [${this.publicDataWrites.map((e=>e.toString())).join(", ")}],\n      noteEncryptedLogsLength: ${this.noteEncryptedLogsLength},\n      encryptedLogsLength: ${this.encryptedLogsLength},\n      unencryptedLogsLength: ${this.unencryptedLogsLength},\n      noteEncryptedLogs: ${JSON.stringify(this.noteEncryptedLogs.toJSON())},\n      encryptedLogs: ${JSON.stringify(this.encryptedLogs.toJSON())},\n      unencryptedLogs: ${JSON.stringify(this.unencryptedLogs.toJSON())}\n     }`}static fromString(e){return sc.fromBuffer(nc.from(e,"hex"))}get txHash(){return new Wl(this.nullifiers[0].toBuffer())}}function rc(e,t=zo){return Fo(e,{AztecAddress:Nr,EthAddress:da,ExtendedUnencryptedL2Log:jl,Fr:X,EventSelector:Ir,FunctionSelector:Ur,Header:Ra,L2Block:Jo,TxEffect:sc,LogId:ml,TxHash:Wl,PublicDataWitness:Xl,SiblingPath:Go},{PublicSimulationOutput:ql,Tx:Vl,TxReceipt:tc,EncryptedNoteL2BlockL2Logs:ul,UnencryptedL2BlockL2Logs:hl,NullifierMembershipWitness:Lo},!1,"node",t)}var ac,ic,oc,lc,cc,dc,uc=r(8891).Buffer;class fc{constructor(e){this.txEffects=e,e.forEach((e=>{if(e.isEmpty())throw new Error("Empty tx effect not allowed in Body")}))}toBuffer(){return Ce(this.txEffects.length,this.txEffects)}static fromBuffer(e){return new this(L.asReader(e).readVector(sc))}[i.inspect.custom](){return`Body {\n  txEffects: ${(0,i.inspect)(this.txEffects)},\n  emptyTxEffectsCount: ${this.numberOfTxsIncludingPadded},\n  emptyTxEffectHash: ${sc.empty().hash().toString("hex")},\n  txsEffectsHash: ${this.getTxsEffectsHash().toString("hex")},\n}`}getTxsEffectsHash(){const e=sc.empty().hash();let t=this.txEffects.map((e=>e.hash()));return t.length<2&&(t=oa(t,e,2)),(e=>{const t=Math.ceil(Math.log2(e.length));let[n,s]=1&e.length?[e.length-1,e[e.length-1]]:[e.length,uc.alloc(0)],r=e.slice(0,n),a=[];for(let e=0;e<t;e++){for(let e=0;e<n;e+=2)a[e/2]=Ne(uc.concat([r[e],r[e+1]]));n/=2,1&n&&(s.length?(a.push(s),n+=1,s=uc.alloc(0)):(n-=1,s=a[n])),r=a,a=[]}return r[0]})(t)}get noteEncryptedLogs(){const e=this.txEffects.map((e=>e.noteEncryptedLogs));return new ul(e)}get encryptedLogs(){const e=this.txEffects.map((e=>e.encryptedLogs));return new fl(e)}get unencryptedLogs(){const e=this.txEffects.map((e=>e.unencryptedLogs));return new hl(e)}get numberOfTxsIncludingPadded(){const e=this.txEffects.length;return e<=2?2:e}static random(e=4,t=2,n=3,s=2,r=1){const a=[...new Array(e)].map((e=>sc.random(t,n,s,r)));return new fc(a)}static empty(){return new fc([])}}class hc{constructor(e,t,n,s,r,a,i){this.name=e,this.to=t,this.selector=n,this.type=s,this.isStatic=r,this.args=a,this.returnTypes=i}static getFields(e){return[e.name,e.to,e.selector,e.type,e.isStatic,e.args,e.returnTypes]}static from(e){return new hc(...hc.getFields(e))}static empty(){return{name:"",to:Nr.ZERO,selector:Ur.empty(),type:xr.PUBLIC,isStatic:!1,args:[],returnTypes:[]}}}!function(e){e.Encrypted="Encrypted",e.Unencrypted="Unencrypted"}(ac||(ac={}));class pc extends Error{constructor(e,t){super(e),this.txHashes=t,this.name=z(ic,ic,"f",oc)}static isBlockProofError(e){return e&&"object"==typeof e&&e.name===z(ic,ic,"f",oc)}}ic=pc,oc={value:"BlockProofError"},function(e){e[e.PRIVATE_KERNEL_EMPTY=0]="PRIVATE_KERNEL_EMPTY",e[e.PUBLIC_VM=1]="PUBLIC_VM",e[e.PUBLIC_KERNEL_NON_TAIL=2]="PUBLIC_KERNEL_NON_TAIL",e[e.PUBLIC_KERNEL_TAIL=3]="PUBLIC_KERNEL_TAIL",e[e.BASE_ROLLUP=4]="BASE_ROLLUP",e[e.MERGE_ROLLUP=5]="MERGE_ROLLUP",e[e.ROOT_ROLLUP=6]="ROOT_ROLLUP",e[e.BASE_PARITY=7]="BASE_PARITY",e[e.ROOT_PARITY=8]="ROOT_PARITY"}(lc||(lc={})),function(e){e[e.SUCCESS=0]="SUCCESS",e[e.FAILURE=1]="FAILURE"}(cc||(cc={})),y("aztec:l2_block_downloader"),function(e){e[e.NULLIFIER_TREE=0]="NULLIFIER_TREE",e[e.NOTE_HASH_TREE=1]="NOTE_HASH_TREE",e[e.PUBLIC_DATA_TREE=2]="PUBLIC_DATA_TREE",e[e.L1_TO_L2_MESSAGE_TREE=3]="L1_TO_L2_MESSAGE_TREE",e[e.ARCHIVE=4]="ARCHIVE"}(dc||(dc={}));const _c=()=>Object.values(dc).filter((e=>!isNaN(Number(e))));class mc{constructor(e,t){this.sender=e,this.chainId=t}static empty(){return new mc(da.ZERO,0)}toFields(){return[this.sender.toField(),new X(BigInt(this.chainId))]}toBuffer(){return Ce(this.sender,this.chainId)}static fromBuffer(e){const t=L.asReader(e),n=t.readObject(da),s=t.readNumber();return new mc(n,s)}static random(){return new mc(da.random(),C(1e3))}}class gc{constructor(e,t){this.recipient=e,this.version=t}static empty(){return new gc(Nr.ZERO,0)}toFields(){return[this.recipient.toField(),new X(BigInt(this.version))]}toBuffer(){return Ce(this.recipient,this.version)}static fromBuffer(e){const t=L.asReader(e),n=Nr.fromBuffer(t),s=t.readNumber();return new gc(n,s)}static random(){return new gc(Nr.random(),C(1e3))}}var bc,yc=r(8891).Buffer;class vc{constructor(e,t,n,s){this.sender=e,this.recipient=t,this.content=n,this.secretHash=s}toFields(){return[...this.sender.toFields(),...this.recipient.toFields(),this.content,this.secretHash]}toBuffer(){return Ce(this.sender,this.recipient,this.content,this.secretHash)}hash(){return Ge(this.toFields())}static fromBuffer(e){const t=L.asReader(e),n=t.readObject(mc),s=t.readObject(gc),r=X.fromBuffer(t),a=X.fromBuffer(t);return new vc(n,s,r,a)}toString(){return this.toBuffer().toString("hex")}static fromString(e){const t=yc.from(e,"hex");return vc.fromBuffer(t)}static empty(){return new vc(mc.empty(),gc.empty(),X.ZERO,X.ZERO)}static random(){return new vc(mc.random(),gc.random(),X.random(),X.random())}}!function(e){e[e.EQ=1]="EQ",e[e.NEQ=2]="NEQ",e[e.LT=3]="LT",e[e.LTE=4]="LTE",e[e.GT=5]="GT",e[e.GTE=6]="GTE"}(bc||(bc={}));var wc,Ac=r(8891).Buffer;class Ec{constructor(e,t,n,s,r,a){this.note=e,this.owner=t,this.contractAddress=n,this.storageSlot=s,this.noteTypeId=r,this.txHash=a}toBuffer(){return Ac.concat([this.note.toBuffer(),this.owner.toBuffer(),this.contractAddress.toBuffer(),this.storageSlot.toBuffer(),this.noteTypeId.toBuffer(),this.txHash.buffer])}static fromBuffer(e){const t=L.asReader(e);return new this(Al.fromBuffer(t),Nr.fromBuffer(t),Nr.fromBuffer(t),X.fromBuffer(t),t.readObject(Dr),new Wl(t.readBytes(Wl.SIZE)))}toString(){return"0x"+this.toBuffer().toString("hex")}static fromString(e){const t=e.replace(/^0x/,"");return Ec.fromBuffer(Ac.from(t,"hex"))}}!function(e){e[e.ACTIVE=1]="ACTIVE",e[e.ACTIVE_OR_NULLIFIED=2]="ACTIVE_OR_NULLIFIED"}(wc||(wc={}));class xc{constructor(e,t){this.values=e,this.hash=t}static async fromValues(e){return new xc(e,await Zi(e))}toBuffer(){return Ce(new Sa(this.values),this.hash)}static fromBuffer(e){const t=L.asReader(e);return new xc(t.readVector(X),X.fromBuffer(t))}}var Sc=r(8891).Buffer;class Tc{constructor(e,t){this.leafIndex=e,this.newValue=t}static from(e){return new Tc(e.leafIndex,e.newValue)}toBuffer(){return Ce(this.leafIndex,this.newValue)}toString(){return this.toBuffer().toString(Pa)}isEmpty(){return this.leafIndex.isZero()&&this.newValue.isZero()}static fromBuffer(e){const t=L.asReader(e);return new Tc(X.fromBuffer(t),X.fromBuffer(t))}static fromString(e){return Tc.fromBuffer(Sc.from(e,Pa))}static empty(){return new Tc(X.ZERO,X.ZERO)}static random(){return new Tc(X.random(),X.random())}static isEmpty(e){return e.isEmpty()}}Tc.SIZE_IN_BYTES=2*X.SIZE_IN_BYTES,Error;var kc=r(8891).Buffer;class Cc{constructor(e,t,n,s,r,a){this.origin=e,this.functionSelector=t,this.firstCallArgsHash=n,this.txContext=s,this.argsOfCalls=r,this.authWitnesses=a}toTxRequest(){return new Gi(this.origin,new hi(this.functionSelector,!0),this.firstCallArgsHash,this.txContext)}static getFields(e){return[e.origin,e.functionSelector,e.firstCallArgsHash,e.txContext,e.argsOfCalls,e.authWitnesses]}static from(e){return new Cc(...Cc.getFields(e))}toBuffer(){return Ce(this.origin,this.functionSelector,this.firstCallArgsHash,this.txContext,new Sa(this.argsOfCalls),new Sa(this.authWitnesses))}toString(){return this.toBuffer().toString("hex")}static fromBuffer(e){const t=L.asReader(e);return new Cc(t.readObject(Nr),t.readObject(Ur),X.fromBuffer(t),t.readObject(fi),t.readVector(xc),t.readVector(mo))}static fromString(e){return Cc.fromBuffer(kc.from(e,"hex"))}}function zc(e,t,n=.1){const s=e.tx.data.publicInputs.end.gasUsed.sub(t).add(e.tx.data.forPublic?.endNonRevertibleData.gasUsed??fa.empty());if(e.publicOutput){const t=Object.values(e.publicOutput.gasUsed).filter(Boolean).reduce(((e,t)=>e.add(t)),fa.empty()),r=e.publicOutput.gasUsed[Hl.TEARDOWN]??fa.empty();return{totalGas:s.add(t).mul(1+n),teardownGas:r.mul(1+n)}}return{totalGas:s.mul(1+n),teardownGas:fa.empty()}}const Pc={timeout:60,interval:1,waitForNotesSync:!0,debug:!1};class Fc{constructor(e,t){this.pxe=e,this.txHashPromise=t}getTxHash(){return this.txHashPromise}async getReceipt(){const e=await this.getTxHash();return await this.pxe.getTxReceipt(e)}async wait(e){if(console.log("[wait in SentTx]"),e?.debug&&!1===e.waitForNotesSync)throw new Error("Cannot set debug to true if waitForNotesSync is false");const t=await this.waitForReceipt(e);if(t.status!==$l.SUCCESS&&!e?.dontThrowOnRevert)throw new Error(`Transaction ${await this.getTxHash()} was ${t.status}. Reason: ${t.error??"unknown"}`);if(e?.debug){const e=await this.getTxHash();console.log("[wait in SentTx] txHash: ",e.toString());const n=await this.pxe.getTxEffect(e),s=await this.pxe.getIncomingNotes({txHash:e}),r=await this.pxe.getOutgoingNotes({txHash:e});t.debugInfo={noteHashes:n.noteHashes,nullifiers:n.nullifiers,publicDataWrites:n.publicDataWrites,l2ToL1Msgs:n.l2ToL1Msgs,visibleIncomingNotes:s,visibleOutgoingNotes:r}}return t}async getUnencryptedLogs(){return await this.wait(),this.pxe.getUnencryptedLogs({txHash:await this.getTxHash()})}async getVisibleNotes(){return await this.wait(),this.pxe.getIncomingNotes({txHash:await this.getTxHash()})}async waitForReceipt(e){const t=await this.getTxHash();return console.log("[wait in SentTx] txHash: ",t.toString()),await wo((async()=>{const n=await this.pxe.getTxReceipt(t);if(n.status===$l.PENDING)return;if(n.status===$l.DROPPED)return n;if(!(e?.waitForNotesSync??Pc.waitForNotesSync))return n;const{blocks:s,notes:r}=await this.pxe.getSyncStatus(),a=n.blockNumber;return s>=a&&Object.values(r).every((e=>e>=a))?n:void 0}),"isMined",e?.timeout??Pc.timeout,e?.interval??Pc.interval)}}class Nc{constructor(e){this.wallet=e,this.log=y("aztec:js:contract_interaction")}async prove(e={}){console.log("[prove in BaseContractInteraction]");const t=this.txRequest??await this.create(e);return this.tx=await this.wallet.proveTx(t,!e.skipPublicSimulation),this.tx}async send(e={}){console.log("[send in BaseContractInteraction]");const t=(async()=>{const t=this.tx??await this.prove(e);return await this.wallet.sendTx(t)})();return new Fc(this.wallet,t)}async estimateGas(e){console.log("[estimateGas in BaseContractInteraction]"),this.txRequest=void 0;const t=await this.create({...e,estimateGas:!1});this.txRequest=void 0;const n=await this.wallet.simulateTx(t,!0),{totalGas:s,teardownGas:r}=zc(n,(e?.fee?.gasSettings??ui.default()).teardownGasLimits);return{gasLimits:s,teardownGasLimits:r}}async getFeeOptionsFromEstimatedGas(e){console.log("[getFeeOptionsFromEstimatedGas in BaseContractInteraction]");const t=e.fee;if(t){const n=await this.wallet.createTxExecutionRequest(e),s=await this.wallet.simulateTx(n,!0),{totalGas:r,teardownGas:a}=zc(s,t.gasSettings.teardownGasLimits);this.log.debug(`Estimated gas limits for tx: DA=${r.daGas} L2=${r.l2Gas} teardownDA=${a.daGas} teardownL2=${a.l2Gas}`);const i=ui.default({...t.gasSettings,gasLimits:r,teardownGasLimits:a});return{...t,gasSettings:i}}return t}}class Gc extends Nc{constructor(e,t,n,s){if(super(e),this.contractAddress=t,this.functionDao=n,this.args=s,s.some((e=>null==e)))throw new Error("All function interaction arguments must be defined and not null. Received: "+s)}async create(e){if(this.functionDao.functionType===xr.UNCONSTRAINED)throw new Error("Can't call `create` on an unconstrained function.");if(!this.txRequest){const t=[this.request()],n=e?.estimateGas?await this.getFeeOptionsFromEstimatedGas({calls:t,fee:e?.fee}):e?.fee;this.txRequest=await this.wallet.createTxExecutionRequest({calls:t,fee:n})}return this.txRequest}request(){const e=Yr(this.functionDao,this.args);return{name:this.functionDao.name,args:e,selector:Ur.fromNameAndParameters(this.functionDao.name,this.functionDao.parameters),type:this.functionDao.functionType,to:this.contractAddress,isStatic:this.functionDao.isStatic,returnTypes:this.functionDao.returnTypes}}async simulate(e={}){if(this.functionDao.functionType==xr.UNCONSTRAINED)return await this.wallet.simulateUnconstrained(this.functionDao.name,this.args,this.contractAddress,e?.from);const t=await this.create(),n=await this.wallet.simulateTx(t,!0,e?.from),s=this.functionDao.functionType==xr.PRIVATE?n.privateReturnValues?.nested?.[0].values:n.publicOutput?.publicReturnValues?.[0].values;return s?Or(this.functionDao.returnTypes,s):[]}}class Lc{constructor(e,t,n){this.instance=e,this.artifact=t,this.wallet=n,this.methods={},t.functions.forEach((e=>{this.methods[e.name]=Object.assign(((...t)=>new Gc(this.wallet,this.instance.address,e,t)),{get selector(){return Ur.fromNameAndParameters(e.name,e.parameters)}})}))}get address(){return this.instance.address}get partialAddress(){return console.log("partialAddress called in ContractBase: ",this.instance?.address.toString()),$i(this.instance)}withWallet(e){return new Lc(this.instance,this.artifact,e)}}async function Oc(e,t,n=[]){const s=await co(e),r=await po(e,{constructorArgs:n,salt:new X(t)});return{instance:r,contractClass:s,artifact:e,address:r.address}}const Rc="aztec(private)",Mc="aztec(public)",Bc="aztec(public-vm)",Yc="aztec(internal)",jc="aztec(initializer)",Hc="aztec(view)",Ic="0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f";var Xc=r(8891).Buffer;function Uc(e){return Xc.from(JSON.stringify(e,((e,t)=>"bytecode"===e&&null!==t&&"object"==typeof t&&"Buffer"===t.type&&Array.isArray(t.data)?Xc.from(t.data).toString("base64"):t)),"utf-8")}function Jc(e){return JSON.parse(e.toString("utf-8"),((e,t)=>"bytecode"===e&&"string"==typeof t?Xc.from(t,"base64"):"object"==typeof t&&null!==t&&"NoteSelector"===t.type?new Dr(Number(t.value)):"object"==typeof t&&null!==t&&"Fr"===t.type?new X(BigInt(t.value)):t))}function Dc(e){return function(e){if("object"!=typeof e)return!1;const t=e;if("string"!=typeof t.name)return!1;if(!Array.isArray(t.functions))return!1;for(const e of t.functions){if("string"!=typeof e.name)return!1;if("string"!=typeof e.functionType)return!1}return!0}(e)?e:function(e){return{name:e.name,functions:e.functions.map((t=>function(e,t){if(void 0===e.custom_attributes)throw new Error(`No custom attributes found for contract function ${e.name}. Try rebuilding the contract with the latest nargo version.`);const n=function(e){return e.custom_attributes.includes(Rc)?xr.PRIVATE:e.custom_attributes.includes(Mc)||e.custom_attributes.includes(Bc)?xr.PUBLIC:e.is_unconstrained?xr.UNCONSTRAINED:xr.PRIVATE}(e),s=e.custom_attributes.includes(Yc),r=e.custom_attributes.includes(Hc);let a=e.abi.parameters.map(qc);(function(e){const t=e[0];return"struct"===t?.type.kind&&t.type.path.includes("ContextInputs")})(a)&&(a=a.slice(1));let i=[];if(n===xr.UNCONSTRAINED&&e.abi.return_type)i=[e.abi.return_type.abi_type];else{const n=`${t.name}::${e.name}_abi`,s=t.outputs.structs.functions.find((e=>"struct"===e.kind&&e.path===n));if(s){if("struct"!==s.kind)throw new Error("Could not generate contract function artifact");const e=s.fields.find((e=>"return_type"===e.name));e&&(i=[e.type])}}return{name:e.name,functionType:n,isInternal:s,isStatic:r,isInitializer:e.custom_attributes.includes(jc),parameters:a,returnTypes:i,bytecode:Xc.from(e.bytecode,"base64"),verificationKey:Ic,debugSymbols:e.debug_symbols}}(t,e))),outputs:e.outputs,storageLayout:Kc(e),notes:Wc(e),fileMap:e.file_map,aztecNrVersion:void 0}}(e)}function qc(e){const{visibility:t}=e;if("databus"===t)throw new Error(`Unsupported visibility ${e.visibility} for noir contract function parameter ${e.name}.`);return{...e,visibility:t}}function Kc(e){const t=(e.outputs.globals.storage?e.outputs.globals.storage[0]:{fields:[]}).fields;return t?t.reduce(((e,t)=>{const n=t.name,s=t.value.fields[0].value;return e[n]={slot:X.fromString(s.value)},e}),{}):{}}function Wc(e){const t=e.outputs.globals.notes;return t?t.reduce(((e,t)=>{const n=t.fields[1].value,s=Dr.fromField(X.fromString(t.fields[0].value));return e[n]={id:s,typ:n},e}),{}):{}}const Zc=Dc(JSON.parse('{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"ContractClassRegisterer","functions":[{"name":"broadcast_private_function","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"contract_class_id","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId"},"visibility":"private"},{"name":"artifact_metadata_hash","type":{"kind":"field"},"visibility":"private"},{"name":"unconstrained_functions_artifact_tree_root","type":{"kind":"field"},"visibility":"private"},{"name":"private_function_tree_sibling_path","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"},{"name":"private_function_tree_leaf_index","type":{"kind":"field"},"visibility":"private"},{"name":"artifact_function_tree_sibling_path","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"},{"name":"artifact_function_tree_leaf_index","type":{"kind":"field"},"visibility":"private"},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"metadata_hash","type":{"kind":"field"}},{"name":"vk_hash","type":{"kind":"field"}}],"kind":"struct","path":"events::private_function_broadcasted::InnerPrivateFunction"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"1ZftasIwFIbvJb9Fcj5y0ngrY4xO6yhIFa2DId770q2pjmaIx23MX5r2fdLTnKdfB7OonvcvT3WzXO/M7OFgVut52dbrJo4OBtzHtt2mbLrhri23rZnZiamaRfw9TsyyXlVmRhaOk1EOBUIfRWEY0oC5NHnGPk2FDRfSgQP36eAcDWlke3ycGJB7Ldzfa+HF3xXO4KFPMxLcWHi4pXAq0A5r6GRIB+7mRvuLc0NubkJMS0NI/OUIHYRZqPDFsJ7iRxDlIEbvE0TsLpyLnBos5w3+RgdHNk0e/9Po3PnfVeR+oiKRVJF3dtQGmOYvMmJKLRc6ozBRQUPl3b1IgYrC6ymccvZe6Yt0Afhw6hLGjvVUoaKChnJWRYGKQhVFKopVlFNRoqJUbjiVG07lhqjcEJUbonJDVG6Iyg1RuSEqN0TlhqjcEJUbXuWGV7nh8264MFA+R9H1lJtC/j4PMLyzQLBnr3Px0RpHr+W2Lp9XVfdJ0u3cN/P0hRKH7dvmc0/MvgM="},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2b3U7bQBCF18GhBoOb2HGckEAIBaTehRSScMfLtM/d60p9haqss6Mclmm0UcdLVool5LG9O+ebsz+EyERqfSSvP5GJ2+Z8rN4f1ObFnGf/dzwI5po1yRkFwtkKhPMoEM5YkDNiOPU5NrFed3rNfVLr9fjuIXbWA30Ez9W2RLZqYgJ8eC1V6Wr2fAzJEVwZ8Ng8o7PGSc0zBEtNkXUbuEeFtuAe6RzBPdrBSCcxpgjX+5RskOXyvs4+XcOJyUXcKcT4bAzWxQ3V2Jav8bGRMXn1rqExqVcx+d42uRO4pjE4NbHgb44H1I7Mz6k1F2KIR9CW2pEfLWDVx7narJfTLf1iq18GbY6hn7230DWNtfaqa2J9btOeAPkb8HCm86byed+MTWx5l0JNGXgioz1f6fxn6u0RWdfXEGfAcy7Os1578nWux+4zsMvkfXrUXnUsr84srzJogwydBvyLQJdy03WH0ZbzYrHS2l0HL7oMT9ezF11GW9CLZ62dO3iRMzy5Zy9yRlvOi+U3rV04eFEwPIVnLwpGW86Lef0ZoOfgRY/h6Xn2osdoC66Rel6UDl6UDE/p2YuS0Rb04ofW7jt40Wd4+p696DPagl5819qVgxcVw1N59qJitAX3zvrzxcDBiwHDM/DsxYDRFvRirrWHDl4MGZ6hZy+GjLbgGqm1Lxy8uGB4Ljx7QXq7MvcCZK4CZC72gDmxYhntRb1/jhy8GDE8I89e4HcuuzCXe8CcWLGM9uJJa48dvBgzPGPPXpDersx5gMxFgMz9AJnLAJmrAJn3YT4nViyjvaz30EsHLy4ZnkvPXpDersx5gMyjAJmLPWBOrFhGe1l/N3fl4MUVw3Pl2QvS25V5ECBzdw+YEyuW0V4utPbEwYsJwzPx7AXp7co8DJC5CpB5FCBzESBzP0DmMkDmwxr0w5zvATO+e/S7UZ75c2rxkGfKYlQWYwpxBozU9kXJva+SWbWT1lTcj/X42POFrqeNas9XOu+XBmrSeW/l89Z/I9yZXPQO3y3j1b2JI+FxuoO8EejQ/RjiX9CW2pEftB8Qu36X68bE91v6Tax+GbS5gX63Vj+6prHW3v00cVNzy2Ved9RmLX8Fngb2wUd8J1eBV8pipGMCPNfyPA8N1TnDd/j+KNm1N7W8OrG8yqAN7tEftW8emA/M/2LGzxMncA956F7LqgX/v2EKOf4CARQXTpY1AAA=","debug_symbols":"ndpBattQGIXRvWgciu9v6T0pWymlOIlTDMYOsVMoJnuv3NIF9Mz0JN3ZNzq82/Cyf/r48f1wej1fhsevt+F4ft5dD+fTeroNmy81/3l7edud7i8u1937dXjctv4w7E8v61Ovz4fh9XDcr8+bfH57uI8WGG03MoqMSkZbGY0ymmTUZNRlJEVspYhRihiliFGKGKWIUYoYpYhRihiliFGKGKWISYqYpIhJipikiEmKmKSISYqYpIhJipikiCZFNCmiSRFNimhSRJMimhTRpIgmRTQpoksRXYroUkSXIroU0aWILkV0KaJLEV2KmKWIWYqYpYhZipiliFmKmKWIWYqYpYhZilikiEWKWKSIRYpYpIhFilikiEWKWKSIRYrIZkOr0KpotaXVSKuJVo1WnVYzraiNUBuhNkJthNoItRFqI9RGqI1QG6E2itooaqOojaI2itooaqOojaI2CDRDohkizZBphlAzpJoh1gy5Zgg2Q7IZos2QbYZwM6SbId4M+WYIOEPCGSLOkHGGkDOknCHmDDlnCDpD0hmizpB1hrAzpJ0h7gx5Zwg8Q+IZIs+QeYbQM6SeIfYMuWcIPkPyGaLPkH2G8DOknyH+DPlnCEBDAhoi0JCBhhA0pKAhBg05aAhCQxIaotCQhYYwNKShIQ4NeWgIREMiGiLRkImGUDSkoiEWDblokYsWuWiRixa5aJGLFrlokYsWuWiRixa5aJGLFrlokYsWuWiRixa5aJGLFrlokYsWuWiRixa5aJGLFrlokYsWuWiRixa5aNlFT3LRIhctctEiFy1y0SIXLXLR+m8XXU8/d++H3dNxf7/be//4cXr+d9V3PV5/vf39sv77Gw=="},{"name":"register","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"artifact_hash","type":{"kind":"field"},"visibility":"private"},{"name":"private_functions_root","type":{"kind":"field"},"visibility":"private"},{"name":"public_bytecode_commitment","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"1ZfdbsIwDIXfJdcIxXbsNLzKNE0dPxMSKoifSRPi3ddCEzrIVGG2iV2h0PMlx/VxoXszmb7u3l7m1Wy5MaOnvVksx+V2vqzq1d6AO363WZVVs9xsy/XWjOzATKtJ/XkYmNl8MTUjsnAYXOlQILRSFAdJDZhTk3fYqqmwoUcdXHCtOjBTUqOzh+eBAf6vxuXvjDvw0KodEtxp3N9jnAq06R6yJHVwx72LX9w75PYGTsWCWP/lhBpCm4U8coQKwR5bIaUGoCNGVxxPgNwJCBRLQSi45wQONvaXA9pu4ZnoMFkf92aiy/uE+GiGKGsI2SUI6apx2Qdas30aGws9Vch5yKQ7ZN+MZF8Z/HCO5CcciURHnu1lGyAM8zNNLh5C0m0eRipoqPy49lKgovBmCmlI2bp8EcfFh3OXsO7YiXJWRYGKQhVFKsqpKFZRoqK8iipUlCobrMoGq7LBqmywKhusygarssGqbLAqG6zKBquyIapsiCobosqGqLIh+WxwSJTPUXw7JUPIP+cBokWCYDt/qeuf1nr1Xq7n5eti2rxdNRd31Ti+bNXL7cfqdKXWfgI="},{"name":"broadcast_unconstrained_function","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"contract_class_id","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId"},"visibility":"private"},{"name":"artifact_metadata_hash","type":{"kind":"field"},"visibility":"private"},{"name":"private_functions_artifact_tree_root","type":{"kind":"field"},"visibility":"private"},{"name":"artifact_function_tree_sibling_path","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"},{"name":"artifact_function_tree_leaf_index","type":{"kind":"field"},"visibility":"private"},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"metadata_hash","type":{"kind":"field"}}],"kind":"struct","path":"events::unconstrained_function_broadcasted::InnerUnconstrainedFunction"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"1ZZha8IwEIb/Sz4XySWXu8S/MsaoWkdBqmgdDPG/L3VNdTRDPLcxP5W075Necw9pDmpRzfavL3WzXO/U9OmgVut52dbrJo4OCtzp3m5TNt1w15bbVk11oapmEa/HQi3rVaWmVsOxGOUMQeijhhCGNJhc2jKaPm29DlfSAQP26eCcHdIG9fG5UECPWjj/XeEIDH0ajYU7C/f3FG690cMaOhrSAU9zh9+b2+jc3OhdWkj0bL68oYMgB7k4fQ85tmEEmSzEmN7kPPCVb6Fzg+mywd/o4Kzm5IOzdvTt9t9VhD9REVGqiJ0etUFP8q5atEkTsheUSVSQUHm/rlIgosztFExc1gL2aW/gcO6SiR3rKRRRTkSRiGIR5UVUkFCkRRSIKCOiRG6QyA0SuUEiN0jkBoncIJEbLHKDRW6wyA0WucEiN1jkBovcYJEbnHdjOEZw4BwVbqdwAvl9HiCVaCHoi+Nc/LXG0Vu5rcvZqupO9t3DfTNPB/04bN83n09i9gM="}],"outputs":{"globals":{},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"artifact_hash","type":{"kind":"field"}},{"name":"private_functions_root","type":{"kind":"field"}},{"name":"public_bytecode_commitment","type":{"kind":"field"}}],"kind":"struct","path":"ContractClassRegisterer::register_parameters"}}],"kind":"struct","path":"ContractClassRegisterer::register_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"contract_class_id","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId"}},{"name":"artifact_metadata_hash","type":{"kind":"field"}},{"name":"unconstrained_functions_artifact_tree_root","type":{"kind":"field"}},{"name":"private_function_tree_sibling_path","type":{"kind":"array","length":5,"type":{"kind":"field"}}},{"name":"private_function_tree_leaf_index","type":{"kind":"field"}},{"name":"artifact_function_tree_sibling_path","type":{"kind":"array","length":5,"type":{"kind":"field"}}},{"name":"artifact_function_tree_leaf_index","type":{"kind":"field"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"metadata_hash","type":{"kind":"field"}},{"name":"vk_hash","type":{"kind":"field"}}],"kind":"struct","path":"events::private_function_broadcasted::InnerPrivateFunction"}}],"kind":"struct","path":"ContractClassRegisterer::broadcast_private_function_parameters"}}],"kind":"struct","path":"ContractClassRegisterer::broadcast_private_function_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"contract_class_id","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId"}},{"name":"artifact_metadata_hash","type":{"kind":"field"}},{"name":"private_functions_artifact_tree_root","type":{"kind":"field"}},{"name":"artifact_function_tree_sibling_path","type":{"kind":"array","length":5,"type":{"kind":"field"}}},{"name":"artifact_function_tree_leaf_index","type":{"kind":"field"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"metadata_hash","type":{"kind":"field"}}],"kind":"struct","path":"events::unconstrained_function_broadcasted::InnerUnconstrainedFunction"}}],"kind":"struct","path":"ContractClassRegisterer::broadcast_unconstrained_function_parameters"}}],"kind":"struct","path":"ContractClassRegisterer::broadcast_unconstrained_function_abi"}]}},"file_map":{"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\\n    oracle::{\\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\\n    call_private_function::call_private_function_internal, header::get_header_at,\\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\\n    enqueue_public_function_call::{\\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\\n    parse_public_call_stack_item_from_oracle\\n}\\n}\\n};\\nuse dep::protocol_types::{\\n    abis::{\\n    caller_context::CallerContext, function_selector::FunctionSelector,\\n    max_block_number::MaxBlockNumber,\\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\\n},\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\\n},\\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\\n};\\n\\n// When finished, one can call .finish() to convert back to the abi\\nstruct PrivateContext {\\n    // docs:start:private-context\\n    inputs: PrivateContextInputs,\\n    side_effect_counter: u32,\\n\\n    min_revertible_side_effect_counter: u32,\\n    is_fee_payer: bool,\\n\\n    args_hash: Field,\\n    return_hash: Field,\\n\\n    max_block_number: MaxBlockNumber,\\n\\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\\n\\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\\n\\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\\n    public_teardown_function_hash: Field,\\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\\n    // docs:end:private-context\\n\\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\\n    historical_header: Header,\\n\\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\\n\\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\\n    // fetching the same request multiple times.\\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\\n}\\n\\nimpl PrivateContext {\\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\\n        PrivateContext {\\n            inputs,\\n            side_effect_counter: inputs.start_side_effect_counter + 1,\\n            min_revertible_side_effect_counter: 0,\\n            is_fee_payer: false,\\n            args_hash,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            historical_header: inputs.historical_header,\\n            private_call_requests: BoundedVec::new(),\\n            public_call_stack_hashes: BoundedVec::new(),\\n            public_teardown_function_hash: 0,\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            note_encrypted_logs_hashes: BoundedVec::new(),\\n            encrypted_logs_hashes: BoundedVec::new(),\\n            unencrypted_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\\n        }\\n    }\\n\\n    fn msg_sender(self) -> AztecAddress {\\n        self.inputs.call_context.msg_sender\\n    }\\n\\n    fn this_address(self) -> AztecAddress {\\n        self.inputs.call_context.storage_contract_address\\n    }\\n\\n    fn chain_id(self) -> Field {\\n        self.inputs.tx_context.chain_id\\n    }\\n\\n    fn version(self) -> Field {\\n        self.inputs.tx_context.version\\n    }\\n\\n    fn selector(self) -> FunctionSelector {\\n        self.inputs.call_context.function_selector\\n    }\\n\\n    fn get_args_hash(self) -> Field {\\n        self.args_hash\\n    }\\n\\n    fn push_note_hash(&mut self, note_hash: Field) {\\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\\n    }\\n\\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\\n    // - consider creating a separate function with 1 arg for the zero note hash case.\\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\\n    }\\n\\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\\n    // included in).\\n    fn get_header(self) -> Header {\\n        self.historical_header\\n    }\\n\\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\\n    // of historical header.\\n    pub fn get_header_at(self, block_number: u32) -> Header {\\n        get_header_at(block_number, self)\\n    }\\n\\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\\n        pack_returns(returns_hasher.fields);\\n        self.return_hash = returns_hasher.hash();\\n    }\\n\\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\\n        PrivateCircuitPublicInputs {\\n            call_context: self.inputs.call_context,\\n            args_hash: self.args_hash,\\n            returns_hash: self.return_hash,\\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\\n            is_fee_payer: self.is_fee_payer,\\n            max_block_number: self.max_block_number,\\n            note_hash_read_requests: self.note_hash_read_requests.storage,\\n            nullifier_read_requests: self.nullifier_read_requests.storage,\\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\\n            note_hashes: self.note_hashes.storage,\\n            nullifiers: self.nullifiers.storage,\\n            private_call_requests: self.private_call_requests.storage,\\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\\n            public_teardown_function_hash: self.public_teardown_function_hash,\\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\\n            end_side_effect_counter: self.side_effect_counter,\\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\\n            historical_header: self.historical_header,\\n            tx_context: self.inputs.tx_context\\n        }\\n    }\\n\\n    pub fn set_as_fee_payer(&mut self) {\\n        dep::protocol_types::debug_log::debug_log_format(\\"Setting {0} as fee payer\\", [self.this_address().to_field()]);\\n        self.is_fee_payer = true;\\n    }\\n\\n    pub fn end_setup(&mut self) {\\n        // dep::protocol_types::debug_log::debug_log_format(\\n        //     \\"Ending setup at counter {0}\\",\\n        //     [self.side_effect_counter as Field]\\n        // );\\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\\n    }\\n\\n    // docs:start:max-block-number\\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\\n        // docs:end:max-block-number\\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\\n    }\\n\\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\\n        self.note_hash_read_requests.push(side_effect);\\n    }\\n\\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\\n        self.nullifier_read_requests.push(request);\\n    }\\n\\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\\n    }\\n\\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\\n    }\\n\\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\\n\\n        if cached_request.pk_m.hash() == pk_m_hash {\\n            // We get a match so the cached request is the latest one \\n            cached_request.sk_app\\n        } else {\\n            // We didn\'t get a match meaning the cached result is stale. We fetch new values from oracle and instruct\\n            // protocol circuits to validate them by storing the validation request in context.\\n            let request = get_key_validation_request(pk_m_hash, key_index);\\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\\n            // valid key request and not the one corresponding to pk_m_hash).\\n            assert(request.pk_m.hash() == pk_m_hash);\\n            self.key_validation_requests_and_generators.push(request_and_generator);\\n            self.last_key_validation_requests[key_index] = Option::some(request);\\n            request.sk_app\\n        }\\n    }\\n\\n    // docs:start:context_message_portal\\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\\n        // docs:end:context_message_portal\\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\\n        self.l2_to_l1_msgs.push(message);\\n    }\\n\\n    // docs:start:context_consume_l1_to_l2_message\\n    // docs:start:consume_l1_to_l2_message\\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\\n        // docs:end:context_consume_l1_to_l2_message\\n        let nullifier = process_l1_to_l2_message(\\n            self.historical_header.state.l1_to_l2_message_tree.root,\\n            self.this_address(),\\n            sender,\\n            self.chain_id(),\\n            self.version(),\\n            content,\\n            secret\\n        );\\n\\n        // Push nullifier (and the \\"commitment\\" corresponding to this can be \\"empty\\")\\n        self.push_nullifier(nullifier, 0)\\n    }\\n    // docs:end:consume_l1_to_l2_message\\n\\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\\n    // used in siloing later on e.g. \'handshaking\' contract w/ known address.\\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\\n        let counter = self.next_counter();\\n        let contract_address = self.this_address();\\n        let len = log.len() as Field + 4;\\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\\n        self.encrypted_logs_hashes.push(side_effect);\\n\\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\\n    }\\n\\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\\n        let counter = self.next_counter();\\n        let len = log.len() as Field + 4;\\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\\n        self.note_encrypted_logs_hashes.push(side_effect);\\n\\n        emit_encrypted_note_log(note_hash_counter, log, counter);\\n    }\\n\\n    pub fn call_private_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) -> PackedReturns {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\\n    }\\n\\n    pub fn static_call_private_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) -> PackedReturns {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\\n    }\\n\\n    pub fn delegate_call_private_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) -> PackedReturns {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\\n    }\\n\\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) -> PackedReturns {\\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\\n    }\\n\\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) -> PackedReturns {\\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\\n    }\\n\\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) -> PackedReturns {\\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\\n    }\\n\\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n        is_delegate_call: bool\\n    ) -> PackedReturns {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let start_side_effect_counter = self.side_effect_counter;\\n        let item = call_private_function_internal(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            start_side_effect_counter,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\\n        self.side_effect_counter = end_side_effect_counter + 1;\\n\\n        // TODO (fees) figure out why this crashes the prover and enable it\\n        // we need this in order to pay fees inside child call contexts\\n        // assert(\\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\\n        //     | (item.public_inputs.min_revertible_side_effect_counter\\n        //         > self.min_revertible_side_effect_counter)\\n        // );\\n\\n        // if item.public_inputs.min_revertible_side_effect_counter\\n        //     > self.min_revertible_side_effect_counter {\\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\\n        // }\\n\\n        assert(contract_address.eq(item.contract_address));\\n        assert(function_selector.eq(item.function_data.selector));\\n\\n        assert(args_hash == item.public_inputs.args_hash);\\n\\n        // Assert that the call context of the call generated by the oracle matches our request.\\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\\n\\n        if (is_delegate_call) {\\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\\n            assert(\\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\\n            );\\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\\n        } else {\\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\\n            assert(\\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\\n            );\\n        }\\n\\n        let mut caller_context = CallerContext::empty();\\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\\n        if is_delegate_call {\\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\\n        }\\n        self.private_call_requests.push(\\n            PrivateCallRequest {\\n            target: item.contract_address,\\n            call_context: item.public_inputs.call_context,\\n            function_data: item.function_data,\\n            args_hash: item.public_inputs.args_hash,\\n            returns_hash: item.public_inputs.returns_hash,\\n            caller_context,\\n            start_side_effect_counter,\\n            end_side_effect_counter\\n        }\\n        );\\n\\n        PackedReturns::new(item.public_inputs.returns_hash)\\n    }\\n\\n    pub fn call_public_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\\n    }\\n\\n    pub fn static_call_public_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\\n    }\\n\\n    pub fn delegate_call_public_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\\n    }\\n\\n    pub fn call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) {\\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\\n    }\\n\\n    pub fn static_call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) {\\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\\n    }\\n\\n    pub fn delegate_call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) {\\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\\n    }\\n\\n    pub fn call_public_function_with_packed_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n        is_delegate_call: bool\\n    ) {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let fields = enqueue_public_function_call_internal(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            self.side_effect_counter,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        let item = parse_public_call_stack_item_from_oracle(fields);\\n        self.validate_call_stack_item_from_oracle(\\n            item,\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        self.side_effect_counter = self.side_effect_counter + 1;\\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\\n    }\\n\\n    pub fn set_public_teardown_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\\n    }\\n\\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n        is_delegate_call: bool\\n    ) {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let fields = set_public_teardown_function_call_internal(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            self.side_effect_counter,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        let item = parse_public_call_stack_item_from_oracle(fields);\\n        self.validate_call_stack_item_from_oracle(\\n            item,\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        self.side_effect_counter = self.side_effect_counter + 1;\\n        self.public_teardown_function_hash = item.get_compressed().hash();\\n    }\\n\\n    fn validate_call_stack_item_from_oracle(\\n        self,\\n        item: PublicCallStackItem,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n        is_delegate_call: bool\\n    ) {\\n        assert(contract_address.eq(item.contract_address));\\n        assert(function_selector.eq(item.function_data.selector));\\n\\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\\n\\n        assert(args_hash == item.public_inputs.args_hash);\\n\\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\\n\\n        if (is_delegate_call) {\\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\\n            assert(\\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\\n            );\\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\\n        } else {\\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\\n            assert(\\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\\n            );\\n        }\\n    }\\n\\n    fn next_counter(&mut self) -> u32 {\\n        let counter = self.side_effect_counter;\\n        self.side_effect_counter += 1;\\n        counter\\n    }\\n}\\n\\nimpl Empty for PrivateContext {\\n    fn empty() -> Self {\\n        PrivateContext {\\n            inputs: PrivateContextInputs::empty(),\\n            side_effect_counter: 0 as u32,\\n            min_revertible_side_effect_counter: 0 as u32,\\n            is_fee_payer: false,\\n            args_hash: 0,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            private_call_requests: BoundedVec::new(),\\n            public_call_stack_hashes: BoundedVec::new(),\\n            public_teardown_function_hash: 0,\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            historical_header: Header::empty(),\\n            note_encrypted_logs_hashes: BoundedVec::new(),\\n            encrypted_logs_hashes: BoundedVec::new(),\\n            unencrypted_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\\n        }\\n    }\\n}\\n"},"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\\n},\\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\\n};\\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\\n\\npub fn compute_secret_hash(secret: Field) -> Field {\\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\\n}\\n\\npub fn compute_unencrypted_log_hash<T, N, M>(\\n    contract_address: AztecAddress,\\n    log: T\\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\\n    // can\'t use N - not in scope error\\n    let n = message_bytes.len();\\n    let mut hash_bytes = [0; M];\\n    // Address is converted to 32 bytes in ts\\n    let address_bytes = contract_address.to_be_bytes_arr();\\n    for i in 0..32 {\\n        hash_bytes[i] = address_bytes[i];\\n    }\\n    let len_bytes = (n as Field).to_be_bytes(4);\\n    for i in 0..4 {\\n        hash_bytes[32 + i] = len_bytes[i];\\n    }\\n    for i in 0..n {\\n        hash_bytes[36 + i] = message_bytes[i];\\n    }\\n\\n    sha256_to_field(hash_bytes)\\n}\\n\\npub fn compute_message_hash(\\n    sender: EthAddress,\\n    chain_id: Field,\\n    recipient: AztecAddress,\\n    version: Field,\\n    content: Field,\\n    secret_hash: Field\\n) -> Field {\\n    let mut hash_bytes = [0 as u8; 192];\\n    let sender_bytes = sender.to_field().to_be_bytes(32);\\n    let chain_id_bytes = chain_id.to_be_bytes(32);\\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\\n    let version_bytes = version.to_be_bytes(32);\\n    let content_bytes = content.to_be_bytes(32);\\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\\n\\n    for i in 0..32 {\\n        hash_bytes[i] = sender_bytes[i];\\n        hash_bytes[i + 32] = chain_id_bytes[i];\\n        hash_bytes[i + 64] = recipient_bytes[i];\\n        hash_bytes[i + 96] = version_bytes[i];\\n        hash_bytes[i + 128] = content_bytes[i];\\n        hash_bytes[i + 160] = secret_hash_bytes[i];\\n    }\\n\\n    sha256_to_field(hash_bytes)\\n}\\n\\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\\n// in the L1 to L2 message tree\\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\\n    pedersen_hash(\\n        [message_hash, secret, leaf_index],\\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\\n    )\\n}\\n\\nstruct ArgsHasher {\\n    fields: [Field],\\n}\\n\\nimpl Hash for ArgsHasher {\\n    fn hash(self) -> Field {\\n        hash_args(self.fields)\\n    }\\n}\\n\\nimpl ArgsHasher {\\n    pub fn new() -> Self {\\n        Self { fields: [] }\\n    }\\n\\n    pub fn add(&mut self, field: Field) {\\n        self.fields = self.fields.push_back(field);\\n    }\\n\\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\\n        for i in 0..N {\\n            self.fields = self.fields.push_back(fields[i]);\\n        }\\n    }\\n}\\n\\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\\n    hash_args(args.as_slice())\\n}\\n\\npub fn hash_args(args: [Field]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        assert(args.len() <= MAX_ARGS_LENGTH, \\"Args length exceeds maximum\\");\\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\\n\\n        let mut current_chunk_index = 0;\\n        let mut index_inside_current_chunk = 0;\\n        for i in 0..args.len() {\\n            current_chunk_values[index_inside_current_chunk] = args[i];\\n            index_inside_current_chunk+=1;\\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\\n                current_chunk_index+=1;\\n                index_inside_current_chunk = 0;\\n            }\\n        }\\n        if index_inside_current_chunk > 0 {\\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\\n        }\\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\n#[test]\\nfn compute_var_args_hash() {\\n    let mut input = ArgsHasher::new();\\n    for i in 0..MAX_ARGS_LENGTH {\\n        input.add(i as Field);\\n    }\\n    let hash = input.hash();\\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\\n}\\n\\n#[test]\\nfn compute_unenc_log_hash_array() {\\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\\n    let log = [\\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\\n    ];\\n    let hash = compute_unencrypted_log_hash(contract_address, log);\\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\\n}\\n\\n#[test]\\nfn compute_unenc_log_hash_addr() {\\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\\n    let hash = compute_unencrypted_log_hash(contract_address, log);\\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\\n}\\n\\n#[test]\\nfn compute_unenc_log_hash_str() {\\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\\n    let log = \\"dummy\\";\\n    let hash = compute_unencrypted_log_hash(contract_address, log);\\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\\n}\\n\\n#[test]\\nfn compute_unenc_log_hash_longer_str() {\\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\\n    let log = \\"Hello this is a string\\";\\n    let hash = compute_unencrypted_log_hash(contract_address, log);\\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\\n}\\n"},"124":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::{address::AztecAddress, point::Point};\\n\\n// = 480 + 32 * N bytes\\n#[oracle(emitEncryptedNoteLog)]\\nunconstrained fn emit_encrypted_note_log_oracle<M>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\\n\\nunconstrained pub fn emit_encrypted_note_log<M>(\\n    note_hash_counter: u32,\\n    encrypted_note: [u8; M],\\n    counter: u32\\n) {\\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\\n}\\n\\n#[oracle(emitEncryptedEventLog)]\\nunconstrained fn emit_encrypted_event_log_oracle<M>(\\n    _contract_address: AztecAddress,\\n    _randomness: Field,\\n    _encrypted_event: [u8; M],\\n    _counter: u32\\n) {}\\n\\nunconstrained pub fn emit_encrypted_event_log<M>(\\n    contract_address: AztecAddress,\\n    randomness: Field,\\n    encrypted_event: [u8; M],\\n    counter: u32\\n) {\\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\\n}\\n\\n// = 480 + 32 * N bytes\\n#[oracle(computeEncryptedNoteLog)]\\nunconstrained fn compute_encrypted_note_log_oracle<N, M>(\\n    _contract_address: AztecAddress,\\n    _storage_slot: Field,\\n    _note_type_id: Field,\\n    _ovsk_app: Field,\\n    _ovpk_m: Point,\\n    _ivpk_m: Point,\\n    _preimage: [Field; N]\\n) -> [u8; M] {}\\n\\nunconstrained pub fn compute_encrypted_note_log<N, M>(\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    ovsk_app: Field,\\n    ovpk_m: Point,\\n    ivpk_m: Point,\\n    preimage: [Field; N]\\n) -> [u8; M] {\\n    compute_encrypted_note_log_oracle(\\n        contract_address,\\n        storage_slot,\\n        note_type_id,\\n        ovsk_app,\\n        ovpk_m,\\n        ivpk_m,\\n        preimage\\n    )\\n}\\n\\n// = 480 + 32 * N bytes\\n#[oracle(computeEncryptedEventLog)]\\nunconstrained fn compute_encrypted_event_log_oracle<N, M>(\\n    _contract_address: AztecAddress,\\n    _randomness: Field,\\n    _event_type_id: Field,\\n    _ovsk_app: Field,\\n    _ovpk_m: Point,\\n    _ivpk_m: Point,\\n    _preimage: [Field; N]\\n) -> [u8; M] {}\\n\\nunconstrained pub fn compute_encrypted_event_log<N, M>(\\n    contract_address: AztecAddress,\\n    randomness: Field,\\n    event_type_id: Field,\\n    ovsk_app: Field,\\n    ovpk_m: Point,\\n    ivpk_m: Point,\\n    preimage: [Field; N]\\n) -> [u8; M] {\\n    compute_encrypted_event_log_oracle(\\n        contract_address,\\n        randomness,\\n        event_type_id,\\n        ovsk_app,\\n        ovpk_m,\\n        ivpk_m,\\n        preimage\\n    )\\n}\\n\\n#[oracle(emitUnencryptedLog)]\\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\\n\\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\\n    contract_address: AztecAddress,\\n    message: T,\\n    counter: u32\\n) -> Field {\\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\\n}\\n\\n#[oracle(emitContractClassUnencryptedLog)]\\nunconstrained fn emit_contract_class_unencrypted_log_private<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {}\\n\\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\\n}\\n"},"236":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"// Utility function to console.log data in the acir simulator\\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \\"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\\"`\\n\\n#[oracle(debugLog)]\\nunconstrained fn debug_log_oracle<M, N>(_msg: str<M>, args: [Field]) {}\\n\\n/// NOTE: call this with a str<N> msg of form\\n/// \\"some string with {0} and {1} ... {N}\\"\\n/// and an array of N field which will be formatted\\n/// into the string in the simulator.\\n/// Example:\\n/// debug_log_format(\\"get_2(slot:{0}) =>\\\\n\\\\t0:{1}\\\\n\\\\t1:{2}\\", [storage_slot, note0_hash, note1_hash]);\\n/// debug_log_format(\\"whole array: {}\\", [e1, e2, e3, e4]);\\nunconstrained pub fn debug_log_format<M, N>(msg: str<M>, args: [Field; N]) {\\n    debug_log_oracle(msg, args.as_slice());\\n}\\n\\n/// NOTE: call this with a str<N> msg of length > 1\\n/// Example:\\n/// `debug_log(\\"blah blah this is a debug string\\");`\\nunconstrained pub fn debug_log<N>(msg: str<N>) {\\n    debug_log_format(msg, []);\\n}\\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\\n    abis::{\\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\\n},\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\\n},\\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\\n    recursion::verification_key::VerificationKey, traits::is_empty,\\n    utils::field::field_from_bytes_32_trunc\\n};\\nuse std::hash::{pedersen_hash_with_separator, sha256};\\n\\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\\n    let sha256_hashed = sha256(bytes_to_hash);\\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\\n\\n    hash_in_a_field\\n}\\n\\npub fn private_functions_root_from_siblings(\\n    selector: FunctionSelector,\\n    vk_hash: Field,\\n    function_leaf_index: Field,\\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\\n) -> Field {\\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\\n    let function_leaf = function_leaf_preimage.hash();\\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\\n}\\n\\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\\n    // Hashing tx hash with note index in tx is guaranteed to be unique\\n    pedersen_hash(\\n        [\\n        tx_hash,\\n        note_index_in_tx as Field\\n    ],\\n        GENERATOR_INDEX__NOTE_HASH_NONCE\\n    )\\n}\\n\\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\\n    let inputs = [nonce, inner_note_hash];\\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\\n}\\n\\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\\n    pedersen_hash(\\n        [\\n        app.to_field(),\\n        unique_note_hash\\n    ],\\n        GENERATOR_INDEX__SILOED_NOTE_HASH\\n    )\\n}\\n\\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\\n    if note_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\\n    }\\n}\\n\\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\\n    pedersen_hash(\\n        [\\n        app.to_field(),\\n        nullifier\\n    ],\\n        GENERATOR_INDEX__OUTER_NULLIFIER\\n    )\\n}\\n\\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\\n    if nullifier.contract_address.is_zero() {\\n        nullifier.value() // Return value instead of 0 because the first nullifier\'s contract address is zero.\\n    } else {\\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\\n    }\\n}\\n\\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\\n    // NB: A unique separator will be needed for masked_contract_address\\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\\n    if randomness == 0 {\\n        // In some cases, we actually want to reveal the contract address we are siloing with:\\n        // e.g. \'handshaking\' contract w/ known address\\n        // An app providing randomness = 0 signals to not mask the address.\\n        masked_contract_address = address.to_field();\\n    }\\n    accumulate_sha256([masked_contract_address, log_hash])\\n}\\n\\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\\n    if log_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_encrypted_log_hash(\\n            log_hash.contract_address,\\n            log_hash.log_hash.randomness,\\n            log_hash.log_hash.value\\n        )\\n    }\\n}\\n\\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\\n    accumulate_sha256([address.to_field(), log_hash])\\n}\\n\\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\\n    if log_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\\n    }\\n}\\n\\npub fn merkle_hash(left: Field, right: Field) -> Field {\\n    pedersen_hash([left, right], 0)\\n}\\n\\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\\n    // Original cpp code\\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\\n    // The above cpp method is only ever called on verification key, so it has been special cased here\\n    let _hash_index = GENERATOR_INDEX__VK;\\n    0\\n}\\n\\npub fn compute_l2_to_l1_hash(\\n    contract_address: AztecAddress,\\n    recipient: EthAddress,\\n    content: Field,\\n    rollup_version_id: Field,\\n    chain_id: Field\\n) -> Field {\\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\\n\\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\\n    for i in 0..inputs.len() {\\n        // TODO are bytes be in fr.to_buffer() ?\\n        let item_bytes = inputs[i].to_be_bytes(32);\\n        for j in 0..32 {\\n            bytes.push(item_bytes[j]);\\n        }\\n    }\\n\\n    sha256_to_field(bytes.storage)\\n}\\n\\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\\n    if msg.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_l2_to_l1_hash(\\n            msg.contract_address,\\n            msg.message.recipient,\\n            msg.message.content,\\n            rollup_version_id,\\n            chain_id\\n        )\\n    }\\n}\\n\\n// Computes sha256 hash of 2 input hashes.\\n//\\n// NB: This method now takes in two 31 byte fields - it assumes that any input\\n// is the result of a sha_to_field hash and => is truncated\\n//\\n// TODO(Jan and David): This is used for the encrypted_log hashes.\\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\\n//\\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\\n    // This is a note about the cpp code, since it takes an array of Fields\\n    // instead of a U128.\\n    // 4 Field elements when converted to bytes will usually \\n    // occupy 4 * 32 = 128 bytes.\\n    // However, this function is making the assumption that each Field \\n    // only occupies 128 bits.\\n    //\\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\\n\\n    // Concatentate two fields into 32x2 = 64 bytes\\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\\n    let mut hash_input_flattened = [0; 64];\\n    for offset in 0..input.len() {\\n        let input_as_bytes = input[offset].to_be_bytes(32);\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n\\n    sha256_to_field(hash_input_flattened)\\n}\\n\\n// Computes the final logs hash for a tx.\\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\\n// to avoid doubling code, since we can\'t define the byte len to be 32*N directly. \\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n    // Ideally we would push to a slice then hash, but there is no sha_slice\\n    // Hardcode to 256 bytes for now\\n    let mut hash = sha256_to_field(hash_input_flattened);\\n    // Not having a 0 value hash for empty logs causes issues with empty txs\\n    // used for padding. Returning early is currently unsupported.\\n    // We always provide sorted logs here, so 0 being empty means all are empty.\\n    if is_empty(logs[0]) {\\n        hash = 0;\\n    }\\n    hash\\n}\\n\\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n    // Ideally we would push to a slice then hash, but there is no sha_slice\\n    // Hardcode to 256 bytes for now\\n    let mut hash = sha256_to_field(hash_input_flattened);\\n    // Not having a 0 value hash for empty logs causes issues with empty txs\\n    // used for padding. Returning early is currently unsupported.\\n    // We always provide sorted logs here, so 0 being empty means all are empty.\\n    if is_empty(logs[0]) {\\n        hash = 0;\\n    }\\n    hash\\n}\\n\\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\\n}\\n\\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\\n}\\n\\n#[test]\\nfn smoke_sha256_to_field() {\\n    let full_buffer = [\\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\\n    ];\\n    let result = sha256_to_field(full_buffer);\\n\\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\\n\\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\\n    let result_bytes = sha256(full_buffer);\\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\\n    assert(truncated_field == result);\\n    let mod_res = result + (result_bytes[31] as Field);\\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\\n}\\n\\n#[test]\\nfn compute_l2_l1_hash() {\\n    // All zeroes\\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\\n\\n    // Non-zero case\\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\\n}\\n"},"248":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_class_id.nr","source":"use crate::constants::GENERATOR_INDEX__CONTRACT_LEAF;\\nuse crate::traits::{ToField, FromField, Hash, Serialize, Deserialize};\\n\\nstruct ContractClassId {\\n  inner: Field\\n}\\n\\nimpl Eq for ContractClassId {\\n    fn eq(self, other: ContractClassId) -> bool {\\n        other.inner == self.inner\\n    }\\n}\\n\\nimpl ToField for ContractClassId {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl FromField for ContractClassId {\\n    fn from_field(value: Field) -> Self {\\n        Self { inner: value }\\n    }\\n}\\n\\nimpl Serialize<1> for ContractClassId {\\n    fn serialize(self: Self) -> [Field; 1] {\\n        [self.inner]\\n    }\\n}\\n\\nimpl Deserialize<1> for ContractClassId {\\n  fn deserialize(fields: [Field; 1]) -> Self {\\n        Self { inner: fields[0] }\\n    }\\n}\\n\\nimpl ContractClassId {\\n    pub fn compute(\\n        artifact_hash: Field,\\n        private_functions_root: Field,\\n        public_bytecode_commitment: Field\\n    ) -> Self {\\n        let hash = std::hash::pedersen_hash_with_separator(\\n            [\\n            artifact_hash,\\n            private_functions_root,\\n            public_bytecode_commitment\\n        ],\\n            GENERATOR_INDEX__CONTRACT_LEAF\\n        ); // TODO(@spalladino): Update generator index\\n\\n        ContractClassId::from_field(hash)\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n"},"301":{"path":"/usr/src/noir-projects/noir-contracts/contracts/contract_class_registerer_contract/src/main.nr","source":"mod events;\\nmod capsule;\\n\\ncontract ContractClassRegisterer {\\n    use dep::aztec::prelude::{AztecAddress, EthAddress, FunctionSelector};\\n    use dep::aztec::protocol_types::{\\n        contract_class_id::ContractClassId,\\n        constants::{\\n        ARTIFACT_FUNCTION_TREE_MAX_HEIGHT, FUNCTION_TREE_HEIGHT,\\n        MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS,\\n        MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS,\\n        MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS, REGISTERER_CONTRACT_CLASS_REGISTERED_MAGIC_VALUE\\n    },\\n        traits::Serialize, abis::log_hash::LogHash\\n    };\\n\\n    use dep::aztec::{context::PrivateContext, oracle::logs::emit_contract_class_unencrypted_log_private_internal};\\n\\n    use crate::events::{\\n        class_registered::ContractClassRegistered,\\n        private_function_broadcasted::{ClassPrivateFunctionBroadcasted, PrivateFunction, InnerPrivateFunction},\\n        unconstrained_function_broadcasted::{ClassUnconstrainedFunctionBroadcasted, UnconstrainedFunction, InnerUnconstrainedFunction}\\n    };\\n\\n    // docs:start:import_pop_capsule\\n    use crate::capsule::pop_capsule;\\n    // docs:end:import_pop_capsule\\n\\n    #[aztec(private)]\\n    fn register(artifact_hash: Field, private_functions_root: Field, public_bytecode_commitment: Field) {\\n        // TODO: Validate public_bytecode_commitment is the correct commitment of packed_public_bytecode\\n        // TODO: Validate packed_public_bytecode is legit public bytecode\\n\\n        // docs:start:pop_capsule\\n        let packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS] = pop_capsule();\\n        // docs:end:pop_capsule\\n\\n        // Compute contract class id from preimage\\n        let contract_class_id = ContractClassId::compute(\\n            artifact_hash,\\n            private_functions_root,\\n            public_bytecode_commitment\\n        );\\n\\n        // Emit the contract class id as a nullifier to be able to prove that this class has been (not) registered\\n        let event = ContractClassRegistered { contract_class_id, version: 1, artifact_hash, private_functions_root, packed_public_bytecode };\\n        context.push_nullifier(contract_class_id.to_field(), 0);\\n\\n        // Broadcast class info including public bytecode\\n        dep::aztec::oracle::debug_log::debug_log_format(\\n            \\"ContractClassRegistered: {}\\",\\n            [\\n            contract_class_id.to_field(),\\n            artifact_hash,\\n            private_functions_root,\\n            public_bytecode_commitment\\n        ]\\n        );\\n        emit_contract_class_unencrypted_log(&mut context, event.serialize());\\n    }\\n\\n    #[aztec(private)]\\n    fn broadcast_private_function(\\n        contract_class_id: ContractClassId,\\n        artifact_metadata_hash: Field,\\n        unconstrained_functions_artifact_tree_root: Field,\\n        private_function_tree_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\\n        private_function_tree_leaf_index: Field,\\n        artifact_function_tree_sibling_path: [Field; ARTIFACT_FUNCTION_TREE_MAX_HEIGHT],\\n        artifact_function_tree_leaf_index: Field,\\n        function_data: InnerPrivateFunction\\n    ) {\\n        let private_bytecode: [Field; MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS] = pop_capsule();\\n\\n        let event = ClassPrivateFunctionBroadcasted {\\n            contract_class_id,\\n            artifact_metadata_hash,\\n            unconstrained_functions_artifact_tree_root,\\n            private_function_tree_sibling_path,\\n            private_function_tree_leaf_index,\\n            artifact_function_tree_sibling_path,\\n            artifact_function_tree_leaf_index,\\n            function: PrivateFunction {\\n                selector: function_data.selector,\\n                metadata_hash: function_data.metadata_hash,\\n                vk_hash: function_data.vk_hash,\\n                bytecode: private_bytecode\\n            }\\n        };\\n        dep::aztec::oracle::debug_log::debug_log_format(\\n            \\"ClassPrivateFunctionBroadcasted: {}\\",\\n            [\\n            contract_class_id.to_field(),\\n            artifact_metadata_hash,\\n            unconstrained_functions_artifact_tree_root,\\n            function_data.selector.to_field(),\\n            function_data.vk_hash,\\n            function_data.metadata_hash\\n        ]\\n        );\\n        emit_contract_class_unencrypted_log(&mut context, event.serialize());\\n    }\\n\\n    #[aztec(private)]\\n    fn broadcast_unconstrained_function(\\n        contract_class_id: ContractClassId,\\n        artifact_metadata_hash: Field,\\n        private_functions_artifact_tree_root: Field,\\n        artifact_function_tree_sibling_path: [Field; ARTIFACT_FUNCTION_TREE_MAX_HEIGHT],\\n        artifact_function_tree_leaf_index: Field,\\n        function_data: InnerUnconstrainedFunction\\n    ) {\\n        let unconstrained_bytecode: [Field; MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS] = pop_capsule();\\n        let event = ClassUnconstrainedFunctionBroadcasted {\\n            contract_class_id,\\n            artifact_metadata_hash,\\n            private_functions_artifact_tree_root,\\n            artifact_function_tree_sibling_path,\\n            artifact_function_tree_leaf_index,\\n            function: UnconstrainedFunction {\\n                selector: function_data.selector,\\n                metadata_hash: function_data.metadata_hash,\\n                bytecode: unconstrained_bytecode\\n            }\\n        };\\n        dep::aztec::oracle::debug_log::debug_log_format(\\n            \\"ClassUnconstrainedFunctionBroadcasted: {}\\",\\n            [\\n            contract_class_id.to_field(),\\n            artifact_metadata_hash,\\n            private_functions_artifact_tree_root,\\n            function_data.selector.to_field(),\\n            function_data.metadata_hash\\n        ]\\n        );\\n        emit_contract_class_unencrypted_log(&mut context, event.serialize());\\n    }\\n\\n    // This fn exists separately from emit_unencrypted_log because sha hashing the preimage\\n    // is too large to compile (16,200 fields, 518,400 bytes) => the oracle hashes it\\n    // It is ONLY used with contract_class_registerer_contract since we already assert correctness:\\n    // - Contract class -> we will commit to the packed bytecode (currently a TODO)\\n    // - Private function -> we provide a membership proof\\n    // - Unconstrained function -> we provide a membership proof\\n    // Ordinary logs are not protected by the above so this fn shouldn\'t be called by anything else\\n    #[contract_library_method]\\n    pub fn emit_contract_class_unencrypted_log<N>(context: &mut PrivateContext, log: [Field; N]) {\\n        let contract_address = context.this_address();\\n        let counter = context.next_counter();\\n        let log_hash = emit_contract_class_unencrypted_log_private_internal(contract_address, log, counter);\\n        // 40 = addr (32) + raw log len (4) + processed log len (4)\\n        let len = 40 + N * 32;\\n        let side_effect = LogHash { value: log_hash, counter, length: len };\\n        context.unencrypted_logs_hashes.push(side_effect);\\n    }\\n}\\n"},"302":{"path":"/usr/src/noir-projects/noir-contracts/contracts/contract_class_registerer_contract/src/capsule.nr","source":"// We should extract this to a shared lib in aztec-nr once we settle on a design for capsules\\n\\n// docs:start:pop_capsule\\n#[oracle(popCapsule)]\\nunconstrained fn pop_capsule_oracle<N>() -> [Field; N] {}\\n\\n// A capsule is a \\"blob\\" of data that is passed to the contract through an oracle.\\nunconstrained pub fn pop_capsule<N>() -> [Field; N] {\\n    pop_capsule_oracle()\\n}\\n// docs:end:pop_capsule"}}}')),Vc=Nr.fromBigInt(13402924717071282069537366635406026232165444473509746327951838324587448220160n),Qc=Dc(JSON.parse('{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"ContractInstanceDeployer","functions":[{"name":"deploy","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"contract_class_id","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId"},"visibility":"private"},{"name":"initialization_hash","type":{"kind":"field"},"visibility":"private"},{"name":"public_keys_hash","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::public_keys_hash::PublicKeysHash"},"visibility":"private"},{"name":"universal_deploy","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2b3U7bQBCF18GhBoOb2HGckEAIBaTehRSScMfLtM/d60p9haqss6Mclmm0UcdLVool5LG9O+ebsz+EyERqfSSvP5GJ2+Z8rN4f1ObFnGf/dzwI5po1yRkFwtkKhPMoEM5YkDNiOPU5NrFed3rNfVLr9fjuIXbWA30Ez9W2RLZqYgJ8eC1V6Wr2fAzJEVwZ8Ng8o7PGSc0zBEtNkXUbuEeFtuAe6RzBPdrBSCcxpgjX+5RskOXyvs4+XcOJyUXcKcT4bAzWxQ3V2Jav8bGRMXn1rqExqVcx+d42uRO4pjE4NbHgb44H1I7Mz6k1F2KIR9CW2pEfLWDVx7narJfTLf1iq18GbY6hn7230DWNtfaqa2J9btOeAPkb8HCm86byed+MTWx5l0JNGXgioz1f6fxn6u0RWdfXEGfAcy7Os1578nWux+4zsMvkfXrUXnUsr84srzJogwydBvyLQJdy03WH0ZbzYrHS2l0HL7oMT9ezF11GW9CLZ62dO3iRMzy5Zy9yRlvOi+U3rV04eFEwPIVnLwpGW86Lef0ZoOfgRY/h6Xn2osdoC66Rel6UDl6UDE/p2YuS0Rb04ofW7jt40Wd4+p696DPagl5819qVgxcVw1N59qJitAX3zvrzxcDBiwHDM/DsxYDRFvRirrWHDl4MGZ6hZy+GjLbgGqm1Lxy8uGB4Ljx7QXq7MvcCZK4CZC72gDmxYhntRb1/jhy8GDE8I89e4HcuuzCXe8CcWLGM9uJJa48dvBgzPGPPXpDersx5gMxFgMz9AJnLAJmrAJn3YT4nViyjvaz30EsHLy4ZnkvPXpDersx5gMyjAJmLPWBOrFhGe1l/N3fl4MUVw3Pl2QvS25V5ECBzdw+YEyuW0V4utPbEwYsJwzPx7AXp7co8DJC5CpB5FCBzESBzP0DmMkDmwxr0w5zvATO+e/S7UZ75c2rxkGfKYlQWYwpxBozU9kXJva+SWbWT1lTcj/X42POFrqeNas9XOu+XBmrSeW/l89Z/I9yZXPQO3y3j1b2JI+FxuoO8EejQ/RjiX9CW2pEftB8Qu36X68bE91v6Tax+GbS5gX63Vj+6prHW3v00cVNzy2Ved9RmLX8Fngb2wUd8J1eBV8pipGMCPNfyPA8N1TnDd/j+KNm1N7W8OrG8yqAN7tEftW8emA/M/2LGzxMncA956F7LqgX/v2EKOf4CARQXTpY1AAA=","debug_symbols":"ndpBattQGIXRvWhsiu9v6T3JWymlOIlTDMYOsVMoJnuv3dIF9Mz0JN3ZNzq82/Cyf/r48f1wej1fhu3X23A8P++uh/PpfroN6y81/3l7edudHi8u1937ddhuWl8N+9PL/anX52p4PRz3w7aW9vlt9RgtMNqsZRQZlYw2MhplNMmoyajLSIrYSBGjFDFKEaMUMUoRoxQxShGjFDFKEaMUMUoRkxQxSRGTFDFJEZMUMUkRkxQxSRGTFDFJEU2KaFJEkyKaFNGkiCZFNCmiSRFNimhSRJciuhTRpYguRXQpoksRXYroUkSXIroUMUsRsxQxSxGzFDFLEbMUMUsRsxQxSxGzFLFIEYsUsUgRixSxSBGLFLFIEYsUsUgRixSR9ZpWoVXRakOrkVYTrRqtOq1mWlEboTZCbYTaCLURaiPURqiNUBuhNkJtFLVR1EZRG0VtFLVR1EZRG0VtEGiGRDNEmiHTDKFmSDVDrBlyzRBshmQzRJsh2wzhZkg3Q7wZ8s0QcIaEM0ScIeMMIWdIOUPMGXLOEHSGpDNEnSHrDGFnSDtD3BnyzhB4hsQzRJ4h8wyhZ0g9Q+wZcs8QfIbkM0SfIfsM4WdIP0P8GfLPEICGBDREoCEDDSFoSEFDDBpy0BCEhiQ0RKEhCw1haEhDQxwa8tAQiIZENESiIRMNoWhIRUMsGnLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0bKLnuSiRS5a5KJFLlrkokUuWuSi9d8uej/93L0fdk/H/eNu7+Pjx+n531Xf+/H66+3vl/u/vwE="}],"outputs":{"globals":{},"structs":{"events":[{"fields":[{"name":"DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE","type":{"kind":"field"}},{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"version","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"salt","type":{"kind":"field"}},{"name":"contract_class_id","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId"}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"public_keys_hash","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::public_keys_hash::PublicKeysHash"}},{"name":"deployer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"ContractInstanceDeployer::ContractInstanceDeployed"}],"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"salt","type":{"kind":"field"}},{"name":"contract_class_id","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId"}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"public_keys_hash","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::public_keys_hash::PublicKeysHash"}},{"name":"universal_deploy","type":{"kind":"boolean"}}],"kind":"struct","path":"ContractInstanceDeployer::deploy_parameters"}}],"kind":"struct","path":"ContractInstanceDeployer::deploy_abi"}]}},"file_map":{"23":{"path":"std/field/mod.nr","source":"mod bn254;\\nuse bn254::lt as bn254_lt;\\n\\nimpl Field {\\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\\n        crate::assert_constant(bit_size);\\n        self.__to_le_bits(bit_size)\\n    }\\n\\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\\n        crate::assert_constant(bit_size);\\n        self.__to_be_bits(bit_size)\\n    }\\n\\n    #[builtin(to_le_bits)]\\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\\n\\n    #[builtin(to_be_bits)]\\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\\n\\n    #[builtin(apply_range_constraint)]\\n    fn __assert_max_bit_size(self, bit_size: u32) {}\\n\\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\\n        crate::assert_constant(bit_size);\\n        assert(bit_size < modulus_num_bits() as u32);\\n        self.__assert_max_bit_size(bit_size);\\n    }\\n\\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\\n        self.to_le_radix(256, byte_size)\\n    }\\n\\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\\n        self.to_be_radix(256, byte_size)\\n    }\\n\\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\\n        crate::assert_constant(radix);\\n        crate::assert_constant(result_len);\\n        self.__to_le_radix(radix, result_len)\\n    }\\n\\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\\n        crate::assert_constant(radix);\\n        crate::assert_constant(result_len);\\n        self.__to_be_radix(radix, result_len)\\n    }\\n\\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\\n    // `_radix` must be less than 256\\n    #[builtin(to_le_radix)]\\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\\n\\n    #[builtin(to_be_radix)]\\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\\n\\n    // Returns self to the power of the given exponent value.\\n    // Caution: we assume the exponent fits into 32 bits\\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\\n    pub fn pow_32(self, exponent: Field) -> Field {\\n        let mut r: Field = 1;\\n        let b = exponent.to_le_bits(32);\\n\\n        for i in 1..33 {\\n            r *= r;\\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\\n        }\\n        r\\n    }\\n\\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\\n    pub fn sgn0(self) -> u1 {\\n        self as u1\\n    }\\n\\n    pub fn lt(self, another: Field) -> bool {\\n        if crate::compat::is_bn254() {\\n            bn254_lt(self, another)\\n        } else {\\n            lt_fallback(self, another)\\n        }\\n    }\\n}\\n\\n#[builtin(modulus_num_bits)]\\npub fn modulus_num_bits() -> u64 {}\\n\\n#[builtin(modulus_be_bits)]\\npub fn modulus_be_bits() -> [u1] {}\\n\\n#[builtin(modulus_le_bits)]\\npub fn modulus_le_bits() -> [u1] {}\\n\\n#[builtin(modulus_be_bytes)]\\npub fn modulus_be_bytes() -> [u8] {}\\n\\n#[builtin(modulus_le_bytes)]\\npub fn modulus_le_bytes() -> [u8] {}\\n// Convert a 32 byte array to a field element by modding\\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\\n    // Convert it to a field element\\n    let mut v = 1;\\n    let mut high = 0 as Field;\\n    let mut low = 0 as Field;\\n\\n    for i in 0..16 {\\n        high = high + (bytes32[15 - i] as Field) * v;\\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\\n        v = v * 256;\\n    }\\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\\n    low + high * v\\n}\\n\\nfn lt_fallback(x: Field, y: Field) -> bool {\\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\\n    let x_bytes = x.to_le_bytes(num_bytes);\\n    let y_bytes = y.to_le_bytes(num_bytes);\\n    let mut x_is_lt = false;\\n    let mut done = false;\\n    for i in 0..num_bytes {\\n        if (!done) {\\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\\n            let bytes_match = x_byte == y_byte;\\n            if !bytes_match {\\n                x_is_lt = x_byte < y_byte;\\n                done = true;\\n            }\\n        }\\n    }\\n    x_is_lt\\n}\\n\\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\\nuse crate::default::Default;\\n\\nglobal RATE: u32 = 3;\\n\\nstruct Poseidon2 {\\n    cache: [Field;3],\\n    state: [Field;4],\\n    cache_size: u32,\\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2 {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        if message_size == N {\\n            Poseidon2::hash_internal(input, N, false)\\n        } else {\\n            Poseidon2::hash_internal(input, message_size, true)\\n        }\\n    }\\n\\n    fn new(iv: Field) -> Poseidon2 {\\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) -> [Field; RATE] {\\n        // zero-pad the cache\\n        for i in 0..RATE {\\n            if i >= self.cache_size {\\n                self.cache[i] = 0;\\n            }\\n        }\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            self.state[i] += self.cache[i];\\n        }\\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\\n        // return `RATE` number of field elements from the sponge state.\\n        let mut result = [0; RATE];\\n        for i in 0..RATE {\\n            result[i] = self.state[i];\\n        }\\n        result\\n    }\\n\\n    fn absorb(&mut self, input: Field) {\\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            let _ = self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        } else if self.squeeze_mode {\\n            // If we\'re in squeeze mode, switch to absorb mode and add the input into the cache.\\n            // N.B. I don\'t think this code path can be reached?!\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n            self.squeeze_mode = false;\\n        }\\n    }\\n\\n    fn squeeze(&mut self) -> Field {\\n        if self.squeeze_mode & (self.cache_size == 0) {\\n            // If we\'re in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\\n            // Switch to absorb mode.\\n            self.squeeze_mode = false;\\n            self.cache_size = 0;\\n        }\\n        if !self.squeeze_mode {\\n            // If we\'re in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\\n            // matched\\n            let new_output_elements = self.perform_duplex();\\n            self.squeeze_mode = true;\\n            for i in 0..RATE {\\n                self.cache[i] = new_output_elements[i];\\n            }\\n            self.cache_size = RATE;\\n        }\\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\\n        let result = self.cache[0];\\n        for i in 1..RATE {\\n            if i < self.cache_size {\\n                self.cache[i - 1] = self.cache[i];\\n            }\\n        }\\n        self.cache_size -= 1;\\n        self.cache[self.cache_size] = 0;\\n        result\\n    }\\n\\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\\n        let two_pow_64 = 18446744073709551616;\\n        let iv : Field = (in_len as Field) * two_pow_64;\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n\\nstruct Poseidon2Hasher{\\n    _state: [Field],\\n}\\n\\nimpl Hasher for Poseidon2Hasher {\\n    fn finish(self) -> Field {\\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..self._state.len() {\\n            sponge.absorb(self._state[i]);\\n        }\\n        sponge.squeeze()\\n    }\\n\\n    fn write(&mut self, input: Field){\\n        self._state = self._state.push_back(input);\\n    }\\n}\\n\\nimpl Default for Poseidon2Hasher {\\n    fn default() -> Self {\\n        Poseidon2Hasher {\\n            _state: &[],\\n        }\\n    }\\n}\\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\\n    oracle::{\\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\\n    call_private_function::call_private_function_internal, header::get_header_at,\\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\\n    enqueue_public_function_call::{\\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\\n    parse_public_call_stack_item_from_oracle\\n}\\n}\\n};\\nuse dep::protocol_types::{\\n    abis::{\\n    caller_context::CallerContext, function_selector::FunctionSelector,\\n    max_block_number::MaxBlockNumber,\\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\\n},\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\\n},\\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\\n};\\n\\n// When finished, one can call .finish() to convert back to the abi\\nstruct PrivateContext {\\n    // docs:start:private-context\\n    inputs: PrivateContextInputs,\\n    side_effect_counter: u32,\\n\\n    min_revertible_side_effect_counter: u32,\\n    is_fee_payer: bool,\\n\\n    args_hash: Field,\\n    return_hash: Field,\\n\\n    max_block_number: MaxBlockNumber,\\n\\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\\n\\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\\n\\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\\n    public_teardown_function_hash: Field,\\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\\n    // docs:end:private-context\\n\\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\\n    historical_header: Header,\\n\\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\\n\\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\\n    // fetching the same request multiple times.\\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\\n}\\n\\nimpl PrivateContext {\\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\\n        PrivateContext {\\n            inputs,\\n            side_effect_counter: inputs.start_side_effect_counter + 1,\\n            min_revertible_side_effect_counter: 0,\\n            is_fee_payer: false,\\n            args_hash,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            historical_header: inputs.historical_header,\\n            private_call_requests: BoundedVec::new(),\\n            public_call_stack_hashes: BoundedVec::new(),\\n            public_teardown_function_hash: 0,\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            note_encrypted_logs_hashes: BoundedVec::new(),\\n            encrypted_logs_hashes: BoundedVec::new(),\\n            unencrypted_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\\n        }\\n    }\\n\\n    fn msg_sender(self) -> AztecAddress {\\n        self.inputs.call_context.msg_sender\\n    }\\n\\n    fn this_address(self) -> AztecAddress {\\n        self.inputs.call_context.storage_contract_address\\n    }\\n\\n    fn chain_id(self) -> Field {\\n        self.inputs.tx_context.chain_id\\n    }\\n\\n    fn version(self) -> Field {\\n        self.inputs.tx_context.version\\n    }\\n\\n    fn selector(self) -> FunctionSelector {\\n        self.inputs.call_context.function_selector\\n    }\\n\\n    fn get_args_hash(self) -> Field {\\n        self.args_hash\\n    }\\n\\n    fn push_note_hash(&mut self, note_hash: Field) {\\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\\n    }\\n\\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\\n    // - consider creating a separate function with 1 arg for the zero note hash case.\\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\\n    }\\n\\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\\n    // included in).\\n    fn get_header(self) -> Header {\\n        self.historical_header\\n    }\\n\\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\\n    // of historical header.\\n    pub fn get_header_at(self, block_number: u32) -> Header {\\n        get_header_at(block_number, self)\\n    }\\n\\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\\n        pack_returns(returns_hasher.fields);\\n        self.return_hash = returns_hasher.hash();\\n    }\\n\\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\\n        PrivateCircuitPublicInputs {\\n            call_context: self.inputs.call_context,\\n            args_hash: self.args_hash,\\n            returns_hash: self.return_hash,\\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\\n            is_fee_payer: self.is_fee_payer,\\n            max_block_number: self.max_block_number,\\n            note_hash_read_requests: self.note_hash_read_requests.storage,\\n            nullifier_read_requests: self.nullifier_read_requests.storage,\\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\\n            note_hashes: self.note_hashes.storage,\\n            nullifiers: self.nullifiers.storage,\\n            private_call_requests: self.private_call_requests.storage,\\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\\n            public_teardown_function_hash: self.public_teardown_function_hash,\\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\\n            end_side_effect_counter: self.side_effect_counter,\\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\\n            historical_header: self.historical_header,\\n            tx_context: self.inputs.tx_context\\n        }\\n    }\\n\\n    pub fn set_as_fee_payer(&mut self) {\\n        dep::protocol_types::debug_log::debug_log_format(\\"Setting {0} as fee payer\\", [self.this_address().to_field()]);\\n        self.is_fee_payer = true;\\n    }\\n\\n    pub fn end_setup(&mut self) {\\n        // dep::protocol_types::debug_log::debug_log_format(\\n        //     \\"Ending setup at counter {0}\\",\\n        //     [self.side_effect_counter as Field]\\n        // );\\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\\n    }\\n\\n    // docs:start:max-block-number\\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\\n        // docs:end:max-block-number\\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\\n    }\\n\\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\\n        self.note_hash_read_requests.push(side_effect);\\n    }\\n\\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\\n        self.nullifier_read_requests.push(request);\\n    }\\n\\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\\n    }\\n\\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\\n    }\\n\\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\\n\\n        if cached_request.pk_m.hash() == pk_m_hash {\\n            // We get a match so the cached request is the latest one \\n            cached_request.sk_app\\n        } else {\\n            // We didn\'t get a match meaning the cached result is stale. We fetch new values from oracle and instruct\\n            // protocol circuits to validate them by storing the validation request in context.\\n            let request = get_key_validation_request(pk_m_hash, key_index);\\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\\n            // valid key request and not the one corresponding to pk_m_hash).\\n            assert(request.pk_m.hash() == pk_m_hash);\\n            self.key_validation_requests_and_generators.push(request_and_generator);\\n            self.last_key_validation_requests[key_index] = Option::some(request);\\n            request.sk_app\\n        }\\n    }\\n\\n    // docs:start:context_message_portal\\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\\n        // docs:end:context_message_portal\\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\\n        self.l2_to_l1_msgs.push(message);\\n    }\\n\\n    // docs:start:context_consume_l1_to_l2_message\\n    // docs:start:consume_l1_to_l2_message\\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\\n        // docs:end:context_consume_l1_to_l2_message\\n        let nullifier = process_l1_to_l2_message(\\n            self.historical_header.state.l1_to_l2_message_tree.root,\\n            self.this_address(),\\n            sender,\\n            self.chain_id(),\\n            self.version(),\\n            content,\\n            secret\\n        );\\n\\n        // Push nullifier (and the \\"commitment\\" corresponding to this can be \\"empty\\")\\n        self.push_nullifier(nullifier, 0)\\n    }\\n    // docs:end:consume_l1_to_l2_message\\n\\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\\n    // used in siloing later on e.g. \'handshaking\' contract w/ known address.\\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\\n        let counter = self.next_counter();\\n        let contract_address = self.this_address();\\n        let len = log.len() as Field + 4;\\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\\n        self.encrypted_logs_hashes.push(side_effect);\\n\\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\\n    }\\n\\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\\n        let counter = self.next_counter();\\n        let len = log.len() as Field + 4;\\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\\n        self.note_encrypted_logs_hashes.push(side_effect);\\n\\n        emit_encrypted_note_log(note_hash_counter, log, counter);\\n    }\\n\\n    pub fn call_private_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) -> PackedReturns {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\\n    }\\n\\n    pub fn static_call_private_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) -> PackedReturns {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\\n    }\\n\\n    pub fn delegate_call_private_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) -> PackedReturns {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\\n    }\\n\\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) -> PackedReturns {\\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\\n    }\\n\\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) -> PackedReturns {\\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\\n    }\\n\\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) -> PackedReturns {\\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\\n    }\\n\\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n        is_delegate_call: bool\\n    ) -> PackedReturns {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let start_side_effect_counter = self.side_effect_counter;\\n        let item = call_private_function_internal(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            start_side_effect_counter,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\\n        self.side_effect_counter = end_side_effect_counter + 1;\\n\\n        // TODO (fees) figure out why this crashes the prover and enable it\\n        // we need this in order to pay fees inside child call contexts\\n        // assert(\\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\\n        //     | (item.public_inputs.min_revertible_side_effect_counter\\n        //         > self.min_revertible_side_effect_counter)\\n        // );\\n\\n        // if item.public_inputs.min_revertible_side_effect_counter\\n        //     > self.min_revertible_side_effect_counter {\\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\\n        // }\\n\\n        assert(contract_address.eq(item.contract_address));\\n        assert(function_selector.eq(item.function_data.selector));\\n\\n        assert(args_hash == item.public_inputs.args_hash);\\n\\n        // Assert that the call context of the call generated by the oracle matches our request.\\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\\n\\n        if (is_delegate_call) {\\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\\n            assert(\\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\\n            );\\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\\n        } else {\\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\\n            assert(\\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\\n            );\\n        }\\n\\n        let mut caller_context = CallerContext::empty();\\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\\n        if is_delegate_call {\\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\\n        }\\n        self.private_call_requests.push(\\n            PrivateCallRequest {\\n            target: item.contract_address,\\n            call_context: item.public_inputs.call_context,\\n            function_data: item.function_data,\\n            args_hash: item.public_inputs.args_hash,\\n            returns_hash: item.public_inputs.returns_hash,\\n            caller_context,\\n            start_side_effect_counter,\\n            end_side_effect_counter\\n        }\\n        );\\n\\n        PackedReturns::new(item.public_inputs.returns_hash)\\n    }\\n\\n    pub fn call_public_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\\n    }\\n\\n    pub fn static_call_public_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\\n    }\\n\\n    pub fn delegate_call_public_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\\n    }\\n\\n    pub fn call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) {\\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\\n    }\\n\\n    pub fn static_call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) {\\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\\n    }\\n\\n    pub fn delegate_call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) {\\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\\n    }\\n\\n    pub fn call_public_function_with_packed_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n        is_delegate_call: bool\\n    ) {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let fields = enqueue_public_function_call_internal(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            self.side_effect_counter,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        let item = parse_public_call_stack_item_from_oracle(fields);\\n        self.validate_call_stack_item_from_oracle(\\n            item,\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        self.side_effect_counter = self.side_effect_counter + 1;\\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\\n    }\\n\\n    pub fn set_public_teardown_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\\n    }\\n\\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n        is_delegate_call: bool\\n    ) {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let fields = set_public_teardown_function_call_internal(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            self.side_effect_counter,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        let item = parse_public_call_stack_item_from_oracle(fields);\\n        self.validate_call_stack_item_from_oracle(\\n            item,\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        self.side_effect_counter = self.side_effect_counter + 1;\\n        self.public_teardown_function_hash = item.get_compressed().hash();\\n    }\\n\\n    fn validate_call_stack_item_from_oracle(\\n        self,\\n        item: PublicCallStackItem,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n        is_delegate_call: bool\\n    ) {\\n        assert(contract_address.eq(item.contract_address));\\n        assert(function_selector.eq(item.function_data.selector));\\n\\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\\n\\n        assert(args_hash == item.public_inputs.args_hash);\\n\\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\\n\\n        if (is_delegate_call) {\\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\\n            assert(\\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\\n            );\\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\\n        } else {\\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\\n            assert(\\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\\n            );\\n        }\\n    }\\n\\n    fn next_counter(&mut self) -> u32 {\\n        let counter = self.side_effect_counter;\\n        self.side_effect_counter += 1;\\n        counter\\n    }\\n}\\n\\nimpl Empty for PrivateContext {\\n    fn empty() -> Self {\\n        PrivateContext {\\n            inputs: PrivateContextInputs::empty(),\\n            side_effect_counter: 0 as u32,\\n            min_revertible_side_effect_counter: 0 as u32,\\n            is_fee_payer: false,\\n            args_hash: 0,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            private_call_requests: BoundedVec::new(),\\n            public_call_stack_hashes: BoundedVec::new(),\\n            public_teardown_function_hash: 0,\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            historical_header: Header::empty(),\\n            note_encrypted_logs_hashes: BoundedVec::new(),\\n            encrypted_logs_hashes: BoundedVec::new(),\\n            unencrypted_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\\n        }\\n    }\\n}\\n"},"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\\n},\\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\\n};\\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\\n\\npub fn compute_secret_hash(secret: Field) -> Field {\\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\\n}\\n\\npub fn compute_unencrypted_log_hash<T, N, M>(\\n    contract_address: AztecAddress,\\n    log: T\\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\\n    // can\'t use N - not in scope error\\n    let n = message_bytes.len();\\n    let mut hash_bytes = [0; M];\\n    // Address is converted to 32 bytes in ts\\n    let address_bytes = contract_address.to_be_bytes_arr();\\n    for i in 0..32 {\\n        hash_bytes[i] = address_bytes[i];\\n    }\\n    let len_bytes = (n as Field).to_be_bytes(4);\\n    for i in 0..4 {\\n        hash_bytes[32 + i] = len_bytes[i];\\n    }\\n    for i in 0..n {\\n        hash_bytes[36 + i] = message_bytes[i];\\n    }\\n\\n    sha256_to_field(hash_bytes)\\n}\\n\\npub fn compute_message_hash(\\n    sender: EthAddress,\\n    chain_id: Field,\\n    recipient: AztecAddress,\\n    version: Field,\\n    content: Field,\\n    secret_hash: Field\\n) -> Field {\\n    let mut hash_bytes = [0 as u8; 192];\\n    let sender_bytes = sender.to_field().to_be_bytes(32);\\n    let chain_id_bytes = chain_id.to_be_bytes(32);\\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\\n    let version_bytes = version.to_be_bytes(32);\\n    let content_bytes = content.to_be_bytes(32);\\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\\n\\n    for i in 0..32 {\\n        hash_bytes[i] = sender_bytes[i];\\n        hash_bytes[i + 32] = chain_id_bytes[i];\\n        hash_bytes[i + 64] = recipient_bytes[i];\\n        hash_bytes[i + 96] = version_bytes[i];\\n        hash_bytes[i + 128] = content_bytes[i];\\n        hash_bytes[i + 160] = secret_hash_bytes[i];\\n    }\\n\\n    sha256_to_field(hash_bytes)\\n}\\n\\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\\n// in the L1 to L2 message tree\\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\\n    pedersen_hash(\\n        [message_hash, secret, leaf_index],\\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\\n    )\\n}\\n\\nstruct ArgsHasher {\\n    fields: [Field],\\n}\\n\\nimpl Hash for ArgsHasher {\\n    fn hash(self) -> Field {\\n        hash_args(self.fields)\\n    }\\n}\\n\\nimpl ArgsHasher {\\n    pub fn new() -> Self {\\n        Self { fields: [] }\\n    }\\n\\n    pub fn add(&mut self, field: Field) {\\n        self.fields = self.fields.push_back(field);\\n    }\\n\\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\\n        for i in 0..N {\\n            self.fields = self.fields.push_back(fields[i]);\\n        }\\n    }\\n}\\n\\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\\n    hash_args(args.as_slice())\\n}\\n\\npub fn hash_args(args: [Field]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        assert(args.len() <= MAX_ARGS_LENGTH, \\"Args length exceeds maximum\\");\\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\\n\\n        let mut current_chunk_index = 0;\\n        let mut index_inside_current_chunk = 0;\\n        for i in 0..args.len() {\\n            current_chunk_values[index_inside_current_chunk] = args[i];\\n            index_inside_current_chunk+=1;\\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\\n                current_chunk_index+=1;\\n                index_inside_current_chunk = 0;\\n            }\\n        }\\n        if index_inside_current_chunk > 0 {\\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\\n        }\\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\n#[test]\\nfn compute_var_args_hash() {\\n    let mut input = ArgsHasher::new();\\n    for i in 0..MAX_ARGS_LENGTH {\\n        input.add(i as Field);\\n    }\\n    let hash = input.hash();\\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\\n}\\n\\n#[test]\\nfn compute_unenc_log_hash_array() {\\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\\n    let log = [\\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\\n    ];\\n    let hash = compute_unencrypted_log_hash(contract_address, log);\\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\\n}\\n\\n#[test]\\nfn compute_unenc_log_hash_addr() {\\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\\n    let hash = compute_unencrypted_log_hash(contract_address, log);\\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\\n}\\n\\n#[test]\\nfn compute_unenc_log_hash_str() {\\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\\n    let log = \\"dummy\\";\\n    let hash = compute_unencrypted_log_hash(contract_address, log);\\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\\n}\\n\\n#[test]\\nfn compute_unenc_log_hash_longer_str() {\\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\\n    let log = \\"Hello this is a string\\";\\n    let hash = compute_unencrypted_log_hash(contract_address, log);\\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\\n}\\n"},"124":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::{address::AztecAddress, point::Point};\\n\\n// = 480 + 32 * N bytes\\n#[oracle(emitEncryptedNoteLog)]\\nunconstrained fn emit_encrypted_note_log_oracle<M>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\\n\\nunconstrained pub fn emit_encrypted_note_log<M>(\\n    note_hash_counter: u32,\\n    encrypted_note: [u8; M],\\n    counter: u32\\n) {\\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\\n}\\n\\n#[oracle(emitEncryptedEventLog)]\\nunconstrained fn emit_encrypted_event_log_oracle<M>(\\n    _contract_address: AztecAddress,\\n    _randomness: Field,\\n    _encrypted_event: [u8; M],\\n    _counter: u32\\n) {}\\n\\nunconstrained pub fn emit_encrypted_event_log<M>(\\n    contract_address: AztecAddress,\\n    randomness: Field,\\n    encrypted_event: [u8; M],\\n    counter: u32\\n) {\\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\\n}\\n\\n// = 480 + 32 * N bytes\\n#[oracle(computeEncryptedNoteLog)]\\nunconstrained fn compute_encrypted_note_log_oracle<N, M>(\\n    _contract_address: AztecAddress,\\n    _storage_slot: Field,\\n    _note_type_id: Field,\\n    _ovsk_app: Field,\\n    _ovpk_m: Point,\\n    _ivpk_m: Point,\\n    _preimage: [Field; N]\\n) -> [u8; M] {}\\n\\nunconstrained pub fn compute_encrypted_note_log<N, M>(\\n    contract_address: AztecAddress,\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    ovsk_app: Field,\\n    ovpk_m: Point,\\n    ivpk_m: Point,\\n    preimage: [Field; N]\\n) -> [u8; M] {\\n    compute_encrypted_note_log_oracle(\\n        contract_address,\\n        storage_slot,\\n        note_type_id,\\n        ovsk_app,\\n        ovpk_m,\\n        ivpk_m,\\n        preimage\\n    )\\n}\\n\\n// = 480 + 32 * N bytes\\n#[oracle(computeEncryptedEventLog)]\\nunconstrained fn compute_encrypted_event_log_oracle<N, M>(\\n    _contract_address: AztecAddress,\\n    _randomness: Field,\\n    _event_type_id: Field,\\n    _ovsk_app: Field,\\n    _ovpk_m: Point,\\n    _ivpk_m: Point,\\n    _preimage: [Field; N]\\n) -> [u8; M] {}\\n\\nunconstrained pub fn compute_encrypted_event_log<N, M>(\\n    contract_address: AztecAddress,\\n    randomness: Field,\\n    event_type_id: Field,\\n    ovsk_app: Field,\\n    ovpk_m: Point,\\n    ivpk_m: Point,\\n    preimage: [Field; N]\\n) -> [u8; M] {\\n    compute_encrypted_event_log_oracle(\\n        contract_address,\\n        randomness,\\n        event_type_id,\\n        ovsk_app,\\n        ovpk_m,\\n        ivpk_m,\\n        preimage\\n    )\\n}\\n\\n#[oracle(emitUnencryptedLog)]\\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\\n\\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\\n    contract_address: AztecAddress,\\n    message: T,\\n    counter: u32\\n) -> Field {\\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\\n}\\n\\n#[oracle(emitContractClassUnencryptedLog)]\\nunconstrained fn emit_contract_class_unencrypted_log_private<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {}\\n\\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\\n}\\n"},"130":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs_traits.nr","source":"use dep::protocol_types::address::AztecAddress;\\n\\n// TODO: this is awful but since we can\'t have a fn that maps [Field; N] -> [u8; 480 + N * 32]\\n// (where N is the note pre-image size and 480 + N * 32 is the encryption output size)\\n// The fns for LensForEncryptedLog are never used, it\'s just to tell the compiler what the lens are\\n\\n// The to_bytes fn for ToBytesForUnencryptedLog is used to allow us to hash some generic T\\n\\n// I could have omitted N from the trait, but wanted to keep it strictly for field arrs\\n// TODO(1139): Once we enc inside the circuit, we will no longer need the oracle to return\\n// anything, so we can remove this trait\\ntrait LensForEncryptedLog<N, M> {\\n    // N = note preimage input in fields\\n    // M = encryption output len in bytes (= 480 + N * 32)\\n    fn output_fields(self: [Field; N]) -> [Field; N];\\n    fn output_bytes(self: [Field; N]) -> [u8; M];\\n}\\n\\nimpl LensForEncryptedLog<1, 512> for [Field; 1] {\\n    fn output_fields(self) -> [Field; 1] {[self[0]; 1]}\\n    fn output_bytes(self) -> [u8; 512] {[self[0] as u8; 512]}\\n}\\nimpl LensForEncryptedLog<2, 544> for [Field; 2] {\\n    fn output_fields(self) -> [Field; 2] {[self[0]; 2]}\\n    fn output_bytes(self) -> [u8; 544] {[self[0] as u8; 544]}\\n}\\nimpl LensForEncryptedLog<3, 576> for [Field; 3] {\\n    fn output_fields(self) -> [Field; 3] {[self[0]; 3]}\\n    fn output_bytes(self) -> [u8; 576] {[self[0] as u8; 576]}\\n}\\nimpl LensForEncryptedLog<4, 608> for [Field; 4] {\\n    fn output_fields(self) -> [Field; 4] {[self[0]; 4]}\\n    fn output_bytes(self) -> [u8; 608] {[self[0] as u8; 608]}\\n}\\nimpl LensForEncryptedLog<5, 640> for [Field; 5] {\\n    fn output_fields(self) -> [Field; 5] {[self[0]; 5]}\\n    fn output_bytes(self) -> [u8; 640] {[self[0] as u8; 640]}\\n}\\nimpl LensForEncryptedLog<6, 672> for [Field; 6] {\\n    fn output_fields(self) -> [Field; 6] {[self[0]; 6]}\\n    fn output_bytes(self) -> [u8; 672] {[self[0] as u8; 672]}\\n}\\nimpl LensForEncryptedLog<7, 704> for [Field; 7] {\\n    fn output_fields(self) -> [Field; 7] {[self[0]; 7]}\\n    fn output_bytes(self) -> [u8; 704] {[self[0] as u8; 704]}\\n}\\nimpl LensForEncryptedLog<8, 736> for [Field; 8] {\\n    fn output_fields(self) -> [Field; 8] {[self[0]; 8]}\\n    fn output_bytes(self) -> [u8; 736] {[self[0] as u8; 736]}\\n}\\nimpl LensForEncryptedLog<9, 768> for [Field; 9] {\\n    fn output_fields(self) -> [Field; 9] {[self[0]; 9]}\\n    fn output_bytes(self) -> [u8; 768] {[self[0] as u8; 768]}\\n}\\nimpl LensForEncryptedLog<10, 800> for [Field; 10] {\\n    fn output_fields(self) -> [Field; 10] {[self[0]; 10]}\\n    fn output_bytes(self) -> [u8; 800] {[self[0] as u8; 800]}\\n}\\nimpl LensForEncryptedLog<11, 832> for [Field; 11] {\\n    fn output_fields(self) -> [Field; 11] {[self[0]; 11]}\\n    fn output_bytes(self) -> [u8; 832] {[self[0] as u8; 832]}\\n}\\nimpl LensForEncryptedLog<12, 864> for [Field; 12] {\\n    fn output_fields(self) -> [Field; 12] {[self[0]; 12]}\\n    fn output_bytes(self) -> [u8; 864] {[self[0] as u8; 864]}\\n}\\n\\ntrait LensForEncryptedEvent<N, M> {\\n    // N = event preimage input in bytes\\n    // M = encryption output len in bytes (= 480 + M)\\n    fn output(self: [u8; N]) -> [u8; M];\\n}\\n\\nimpl LensForEncryptedEvent<96, 512> for [u8; 96] {\\n    fn output(self) -> [u8; 512] {[self[0] as u8; 512]}\\n}\\nimpl LensForEncryptedEvent<128, 544> for [u8; 128] {\\n    fn output(self) -> [u8; 544] {[self[0] as u8; 544]}\\n}\\nimpl LensForEncryptedEvent<160, 576> for [u8; 160] {\\n    fn output(self) -> [u8; 576] {[self[0] as u8; 576]}\\n}\\nimpl LensForEncryptedEvent<192, 608> for [u8; 192] {\\n    fn output(self) -> [u8; 608] {[self[0] as u8; 608]}\\n}\\nimpl LensForEncryptedEvent<224, 640> for [u8; 224] {\\n    fn output(self) -> [u8; 640] {[self[0] as u8; 640]}\\n}\\nimpl LensForEncryptedEvent<256, 672> for [u8; 256] {\\n    fn output(self) -> [u8; 672] {[self[0] as u8; 672]}\\n}\\n\\n// This trait defines the length of the inputs in bytes to\\n// the unencrypted log hash fn, where the log can be any type T\\n// as long as the ACVM can convert to fields.\\ntrait ToBytesForUnencryptedLog<N, M> {\\n    // N = preimage input in bytes (32 * num fields or chars)\\n    // M = full log input in bytes ( = N + 40 = N + 32 for addr, + 4 for selector, + 4 for len)\\n    fn to_be_bytes_arr(self) -> [u8; N];\\n    fn output_bytes(self) -> [u8; M];\\n}\\n\\nimpl ToBytesForUnencryptedLog<32, 68> for Field {\\n    fn to_be_bytes_arr(self) -> [u8; 32] {\\n        self.to_be_bytes(32).as_array()\\n    }\\n    fn output_bytes(self) -> [u8; 68] {[self as u8; 68]}\\n}\\n\\nimpl ToBytesForUnencryptedLog<32, 68> for AztecAddress {\\n    fn to_be_bytes_arr(self) -> [u8; 32] {\\n        self.to_field().to_be_bytes(32).as_array()\\n    }\\n    fn output_bytes(self) -> [u8; 68] {[self.to_field() as u8; 68]}\\n}\\n\\nfn arr_to_be_bytes_arr<N, L>(fields: [Field; L]) -> [u8; N] {\\n    let mut bytes: [u8] = &[];\\n    for i in 0..L {\\n        // Note that bytes.append() results in bound error\\n        let to_add = fields[i].to_be_bytes(32);\\n        for j in 0..32 {\\n            bytes = bytes.push_back(to_add[j]);\\n        }\\n    }\\n    bytes.as_array()\\n}\\n\\n// each character of a string is converted into a byte\\n// then an ACVM field via the oracle => we recreate here\\nfn str_to_be_bytes_arr<N, L>(string: str<L>) -> [u8; N] {\\n    let chars_bytes = string.as_bytes();\\n    let mut bytes: [u8] = &[];\\n    for i in 0..L {\\n        let to_add = (chars_bytes[i] as Field).to_be_bytes(32);\\n        for j in 0..32 {\\n            bytes = bytes.push_back(to_add[j]);\\n        }\\n    }\\n    bytes.as_array()\\n}\\n\\nimpl ToBytesForUnencryptedLog<32, 68> for [Field; 1] {\\n    fn to_be_bytes_arr(self) -> [u8; 32] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 68] {\\n        [self[0] as u8; 68]\\n    }\\n}\\n\\nimpl ToBytesForUnencryptedLog<64, 100> for [Field; 2] {\\n    fn to_be_bytes_arr(self) -> [u8; 64] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 100] {\\n        [self[0] as u8; 100]\\n    }\\n}\\n\\nimpl ToBytesForUnencryptedLog<96, 132> for [Field; 3] {\\n    fn to_be_bytes_arr(self) -> [u8; 96] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 132] {\\n        [self[0] as u8; 132]\\n    }\\n}\\n\\nimpl ToBytesForUnencryptedLog<128, 164> for [Field; 4] {\\n    fn to_be_bytes_arr(self) -> [u8; 128] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 164] {\\n        [self[0] as u8; 164]\\n    }\\n}\\n\\nimpl ToBytesForUnencryptedLog<160, 196> for [Field; 5] {\\n    fn to_be_bytes_arr(self) -> [u8; 160] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 196] {\\n        [self[0] as u8; 196]\\n    }\\n}\\n\\nimpl ToBytesForUnencryptedLog<192, 228> for [Field; 6] {\\n    fn to_be_bytes_arr(self) -> [u8; 192] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 228] {\\n        [self[0] as u8; 228]\\n    }\\n}\\n\\nimpl ToBytesForUnencryptedLog<224, 260> for [Field; 7] {\\n    fn to_be_bytes_arr(self) -> [u8; 224] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 260] {\\n        [self[0] as u8; 260]\\n    }\\n}\\n\\nimpl ToBytesForUnencryptedLog<256, 292> for [Field; 8] {\\n    fn to_be_bytes_arr(self) -> [u8; 256] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 292] {\\n        [self[0] as u8; 292]\\n    }\\n}\\n\\nimpl ToBytesForUnencryptedLog<288, 324> for [Field; 9] {\\n    fn to_be_bytes_arr(self) -> [u8; 288] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 324] {\\n        [self[0] as u8; 324]\\n    }\\n}\\n\\nimpl ToBytesForUnencryptedLog<320, 356> for [Field; 10] {\\n    fn to_be_bytes_arr(self) -> [u8; 320] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 356] {\\n        [self[0] as u8; 356]\\n    }\\n}\\n\\nimpl ToBytesForUnencryptedLog<352, 388> for [Field; 11] {\\n    fn to_be_bytes_arr(self) -> [u8; 352] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 388] {\\n        [self[0] as u8; 388]\\n    }\\n}\\n\\nimpl ToBytesForUnencryptedLog<384, 420> for [Field; 12] {\\n    fn to_be_bytes_arr(self) -> [u8; 384] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 420] {\\n        [self[0] as u8; 420]\\n    }\\n}\\n\\nimpl ToBytesForUnencryptedLog<416, 452> for [Field; 13] {\\n    fn to_be_bytes_arr(self) -> [u8; 416] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 452] {\\n        [self[0] as u8; 452]\\n    }\\n}\\n\\nimpl ToBytesForUnencryptedLog<448, 484> for [Field; 14] {\\n    fn to_be_bytes_arr(self) -> [u8; 448] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 484] {\\n        [self[0] as u8; 484]\\n    }\\n}\\n\\nimpl ToBytesForUnencryptedLog<480, 516> for [Field; 15] {\\n    fn to_be_bytes_arr(self) -> [u8; 480] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 516] {\\n        [self[0] as u8; 516]\\n    }\\n}\\n\\nimpl ToBytesForUnencryptedLog<512, 548> for [Field; 16] {\\n    fn to_be_bytes_arr(self) -> [u8; 512] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 548] {\\n        [self[0] as u8; 548]\\n    }\\n}\\n\\nimpl ToBytesForUnencryptedLog<544, 580> for [Field; 17] {\\n    fn to_be_bytes_arr(self) -> [u8; 544] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 580] {\\n        [self[0] as u8; 580]\\n    }\\n}\\n\\nimpl ToBytesForUnencryptedLog<576, 612> for [Field; 18] {\\n    fn to_be_bytes_arr(self) -> [u8; 576] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 612] {\\n        [self[0] as u8; 612]\\n    }\\n}\\n\\nimpl ToBytesForUnencryptedLog<608, 644> for [Field; 19] {\\n    fn to_be_bytes_arr(self) -> [u8; 608] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 644] {\\n        [self[0] as u8; 644]\\n    }\\n}\\n\\nimpl ToBytesForUnencryptedLog<640, 676> for [Field; 20] {\\n    fn to_be_bytes_arr(self) -> [u8; 640] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 676] {\\n        [self[0] as u8; 676]\\n    }\\n}\\n\\nimpl ToBytesForUnencryptedLog<672, 708> for [Field; 21] {\\n    fn to_be_bytes_arr(self) -> [u8; 672] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 708] {\\n        [self[0] as u8; 708]\\n    }\\n}\\n\\nimpl ToBytesForUnencryptedLog<704, 740> for [Field; 22] {\\n    fn to_be_bytes_arr(self) -> [u8; 704] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 740] {\\n        [self[0] as u8; 740]\\n    }\\n}\\n\\nimpl ToBytesForUnencryptedLog<736, 772> for [Field; 23] {\\n    fn to_be_bytes_arr(self) -> [u8; 736] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 772] {\\n        [self[0] as u8; 772]\\n    }\\n}\\n\\nimpl ToBytesForUnencryptedLog<768, 804> for [Field; 24] {\\n    fn to_be_bytes_arr(self) -> [u8; 768] {\\n        arr_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; 804] {\\n        [self[0] as u8; 804]\\n    }\\n}\\n\\nimpl<N,M,L> ToBytesForUnencryptedLog<N, M> for str<L> where [Field; L]: ToBytesForUnencryptedLog<N,M> {\\n    fn to_be_bytes_arr(self) -> [u8; N] {\\n        str_to_be_bytes_arr(self)\\n    }\\n    fn output_bytes(self) -> [u8; M] {\\n        [0; M]\\n    }\\n}\\n"},"236":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"// Utility function to console.log data in the acir simulator\\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \\"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\\"`\\n\\n#[oracle(debugLog)]\\nunconstrained fn debug_log_oracle<M, N>(_msg: str<M>, args: [Field]) {}\\n\\n/// NOTE: call this with a str<N> msg of form\\n/// \\"some string with {0} and {1} ... {N}\\"\\n/// and an array of N field which will be formatted\\n/// into the string in the simulator.\\n/// Example:\\n/// debug_log_format(\\"get_2(slot:{0}) =>\\\\n\\\\t0:{1}\\\\n\\\\t1:{2}\\", [storage_slot, note0_hash, note1_hash]);\\n/// debug_log_format(\\"whole array: {}\\", [e1, e2, e3, e4]);\\nunconstrained pub fn debug_log_format<M, N>(msg: str<M>, args: [Field; N]) {\\n    debug_log_oracle(msg, args.as_slice());\\n}\\n\\n/// NOTE: call this with a str<N> msg of length > 1\\n/// Example:\\n/// `debug_log(\\"blah blah this is a debug string\\");`\\nunconstrained pub fn debug_log<N>(msg: str<N>) {\\n    debug_log_format(msg, []);\\n}\\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\\n    abis::{\\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\\n},\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\\n},\\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\\n    recursion::verification_key::VerificationKey, traits::is_empty,\\n    utils::field::field_from_bytes_32_trunc\\n};\\nuse std::hash::{pedersen_hash_with_separator, sha256};\\n\\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\\n    let sha256_hashed = sha256(bytes_to_hash);\\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\\n\\n    hash_in_a_field\\n}\\n\\npub fn private_functions_root_from_siblings(\\n    selector: FunctionSelector,\\n    vk_hash: Field,\\n    function_leaf_index: Field,\\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\\n) -> Field {\\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\\n    let function_leaf = function_leaf_preimage.hash();\\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\\n}\\n\\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\\n    // Hashing tx hash with note index in tx is guaranteed to be unique\\n    pedersen_hash(\\n        [\\n        tx_hash,\\n        note_index_in_tx as Field\\n    ],\\n        GENERATOR_INDEX__NOTE_HASH_NONCE\\n    )\\n}\\n\\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\\n    let inputs = [nonce, inner_note_hash];\\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\\n}\\n\\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\\n    pedersen_hash(\\n        [\\n        app.to_field(),\\n        unique_note_hash\\n    ],\\n        GENERATOR_INDEX__SILOED_NOTE_HASH\\n    )\\n}\\n\\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\\n    if note_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\\n    }\\n}\\n\\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\\n    pedersen_hash(\\n        [\\n        app.to_field(),\\n        nullifier\\n    ],\\n        GENERATOR_INDEX__OUTER_NULLIFIER\\n    )\\n}\\n\\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\\n    if nullifier.contract_address.is_zero() {\\n        nullifier.value() // Return value instead of 0 because the first nullifier\'s contract address is zero.\\n    } else {\\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\\n    }\\n}\\n\\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\\n    // NB: A unique separator will be needed for masked_contract_address\\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\\n    if randomness == 0 {\\n        // In some cases, we actually want to reveal the contract address we are siloing with:\\n        // e.g. \'handshaking\' contract w/ known address\\n        // An app providing randomness = 0 signals to not mask the address.\\n        masked_contract_address = address.to_field();\\n    }\\n    accumulate_sha256([masked_contract_address, log_hash])\\n}\\n\\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\\n    if log_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_encrypted_log_hash(\\n            log_hash.contract_address,\\n            log_hash.log_hash.randomness,\\n            log_hash.log_hash.value\\n        )\\n    }\\n}\\n\\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\\n    accumulate_sha256([address.to_field(), log_hash])\\n}\\n\\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\\n    if log_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\\n    }\\n}\\n\\npub fn merkle_hash(left: Field, right: Field) -> Field {\\n    pedersen_hash([left, right], 0)\\n}\\n\\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\\n    // Original cpp code\\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\\n    // The above cpp method is only ever called on verification key, so it has been special cased here\\n    let _hash_index = GENERATOR_INDEX__VK;\\n    0\\n}\\n\\npub fn compute_l2_to_l1_hash(\\n    contract_address: AztecAddress,\\n    recipient: EthAddress,\\n    content: Field,\\n    rollup_version_id: Field,\\n    chain_id: Field\\n) -> Field {\\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\\n\\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\\n    for i in 0..inputs.len() {\\n        // TODO are bytes be in fr.to_buffer() ?\\n        let item_bytes = inputs[i].to_be_bytes(32);\\n        for j in 0..32 {\\n            bytes.push(item_bytes[j]);\\n        }\\n    }\\n\\n    sha256_to_field(bytes.storage)\\n}\\n\\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\\n    if msg.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_l2_to_l1_hash(\\n            msg.contract_address,\\n            msg.message.recipient,\\n            msg.message.content,\\n            rollup_version_id,\\n            chain_id\\n        )\\n    }\\n}\\n\\n// Computes sha256 hash of 2 input hashes.\\n//\\n// NB: This method now takes in two 31 byte fields - it assumes that any input\\n// is the result of a sha_to_field hash and => is truncated\\n//\\n// TODO(Jan and David): This is used for the encrypted_log hashes.\\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\\n//\\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\\n    // This is a note about the cpp code, since it takes an array of Fields\\n    // instead of a U128.\\n    // 4 Field elements when converted to bytes will usually \\n    // occupy 4 * 32 = 128 bytes.\\n    // However, this function is making the assumption that each Field \\n    // only occupies 128 bits.\\n    //\\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\\n\\n    // Concatentate two fields into 32x2 = 64 bytes\\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\\n    let mut hash_input_flattened = [0; 64];\\n    for offset in 0..input.len() {\\n        let input_as_bytes = input[offset].to_be_bytes(32);\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n\\n    sha256_to_field(hash_input_flattened)\\n}\\n\\n// Computes the final logs hash for a tx.\\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\\n// to avoid doubling code, since we can\'t define the byte len to be 32*N directly. \\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n    // Ideally we would push to a slice then hash, but there is no sha_slice\\n    // Hardcode to 256 bytes for now\\n    let mut hash = sha256_to_field(hash_input_flattened);\\n    // Not having a 0 value hash for empty logs causes issues with empty txs\\n    // used for padding. Returning early is currently unsupported.\\n    // We always provide sorted logs here, so 0 being empty means all are empty.\\n    if is_empty(logs[0]) {\\n        hash = 0;\\n    }\\n    hash\\n}\\n\\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n    // Ideally we would push to a slice then hash, but there is no sha_slice\\n    // Hardcode to 256 bytes for now\\n    let mut hash = sha256_to_field(hash_input_flattened);\\n    // Not having a 0 value hash for empty logs causes issues with empty txs\\n    // used for padding. Returning early is currently unsupported.\\n    // We always provide sorted logs here, so 0 being empty means all are empty.\\n    if is_empty(logs[0]) {\\n        hash = 0;\\n    }\\n    hash\\n}\\n\\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\\n}\\n\\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\\n}\\n\\n#[test]\\nfn smoke_sha256_to_field() {\\n    let full_buffer = [\\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\\n    ];\\n    let result = sha256_to_field(full_buffer);\\n\\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\\n\\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\\n    let result_bytes = sha256(full_buffer);\\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\\n    assert(truncated_field == result);\\n    let mod_res = result + (result_bytes[31] as Field);\\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\\n}\\n\\n#[test]\\nfn compute_l2_l1_hash() {\\n    // All zeroes\\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\\n\\n    // Non-zero case\\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\\n}\\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\\n};\\n\\n// Aztec address\\nstruct AztecAddress {\\n    inner : Field\\n}\\n\\nimpl Eq for AztecAddress {\\n    fn eq(self, other : Self) -> bool {\\n        self.to_field() == other.to_field()\\n    }\\n}\\n\\nimpl Empty for AztecAddress {\\n    fn empty() -> Self {\\n        Self {\\n            inner : 0\\n        }\\n    }\\n}\\n\\nimpl ToField for AztecAddress {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl FromField for AztecAddress {\\n    fn from_field(value: Field) -> AztecAddress {\\n        AztecAddress { inner: value }\\n    }\\n}\\n\\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\\n        [self.to_field()]\\n    }\\n}\\n\\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\\n        FromField::from_field(fields[0])\\n    }\\n}\\n\\nimpl AztecAddress {\\n    pub fn zero() -> Self {\\n        Self { inner: 0 }\\n    }\\n\\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\\n        AztecAddress::from_field(\\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\\n        )\\n    }\\n\\n    pub fn is_zero(self) -> bool {\\n        self.inner == 0\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n\\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\\n        Self { inner: result }\\n    }\\n}\\n\\n#[test]\\nfn compute_address_from_partial_and_pub_keys_hash() {\\n    let pub_keys_hash = PublicKeysHash::from_field(1);\\n    let partial_address = PartialAddress::from_field(2);\\n\\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\\n}\\n\\n#[test]\\nfn from_field_to_field() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(FromField::from_field(address.to_field()), address);\\n}\\n\\n#[test]\\nfn serde() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\\n}\\n"},"292":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\\n    address::{\\n    eth_address::EthAddress, salted_initialization_hash::SaltedInitializationHash,\\n    aztec_address::AztecAddress\\n},\\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\\n    hash::pedersen_hash, traits::{ToField, FromField, Serialize, Deserialize}\\n};\\n\\nglobal PARTIAL_ADDRESS_LENGTH = 1;\\n\\n// Partial address\\nstruct PartialAddress {\\n    inner : Field\\n}\\n\\nimpl ToField for PartialAddress {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\\n        [self.to_field()]\\n    }\\n}\\n\\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\\n       PartialAddress { inner: fields[0] }\\n    }\\n}\\n\\nimpl PartialAddress {\\n    pub fn from_field(field: Field) -> Self {\\n        Self { inner: field }\\n    }\\n\\n    pub fn compute(\\n        contract_class_id: ContractClassId,\\n        salt: Field,\\n        initialization_hash: Field,\\n        deployer: AztecAddress\\n    ) -> Self {\\n        PartialAddress::compute_from_salted_initialization_hash(\\n            contract_class_id,\\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\\n        )\\n    }\\n\\n    pub fn compute_from_salted_initialization_hash(\\n        contract_class_id: ContractClassId,\\n        salted_initialization_hash: SaltedInitializationHash\\n    ) -> Self {\\n        PartialAddress::from_field(\\n            pedersen_hash(\\n                [\\n            contract_class_id.to_field(),\\n            salted_initialization_hash.to_field()\\n        ],\\n                GENERATOR_INDEX__PARTIAL_ADDRESS\\n            )\\n        )\\n    }\\n\\n    pub fn to_field(self) -> Field {\\n        self.inner\\n    }\\n\\n    pub fn is_zero(self) -> bool {\\n        self.to_field() == 0\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n"},"293":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\\n    address::{eth_address::EthAddress, aztec_address::AztecAddress},\\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, traits::ToField\\n};\\n\\n// Salted initialization hash. Used in the computation of a partial address.\\nstruct SaltedInitializationHash {\\n    inner: Field\\n}\\n\\nimpl ToField for SaltedInitializationHash {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl SaltedInitializationHash {\\n    pub fn from_field(field: Field) -> Self {\\n        Self { inner: field }\\n    }\\n\\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\\n        SaltedInitializationHash::from_field(\\n            pedersen_hash(\\n                [\\n            salt,\\n            initialization_hash,\\n            deployer.to_field()\\n        ],\\n                GENERATOR_INDEX__PARTIAL_ADDRESS\\n            )\\n        )\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n"},"296":{"path":"/usr/src/noir-projects/noir-contracts/contracts/contract_instance_deployer_contract/src/main.nr","source":"contract ContractInstanceDeployer {\\n    use dep::aztec::protocol_types::{\\n        address::{AztecAddress, EthAddress, PublicKeysHash, PartialAddress},\\n        contract_class_id::ContractClassId, constants::DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE,\\n        traits::Serialize, abis::log_hash::LogHash\\n    };\\n    use dep::aztec::{\\n        context::PrivateContext, hash::compute_unencrypted_log_hash,\\n        oracle::logs::emit_unencrypted_log_private_internal\\n    };\\n\\n    #[aztec(event)]\\n    struct ContractInstanceDeployed {\\n        DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE: Field,\\n        address: AztecAddress,\\n        version: u8,\\n        salt: Field, \\n        contract_class_id: ContractClassId, \\n        initialization_hash: Field, \\n        public_keys_hash: PublicKeysHash, \\n        deployer: AztecAddress,\\n    }\\n\\n    #[aztec(private)]\\n    fn deploy(\\n        salt: Field,\\n        contract_class_id: ContractClassId,\\n        initialization_hash: Field,\\n        public_keys_hash: PublicKeysHash,\\n        universal_deploy: bool\\n    ) {\\n        // TODO(@spalladino): assert nullifier_exists silo(contract_class_id, ContractClassRegisterer)\\n\\n        let deployer = if universal_deploy {\\n            AztecAddress::zero()\\n        } else {\\n            context.msg_sender()\\n        };\\n\\n        let partial_address = PartialAddress::compute(contract_class_id, salt, initialization_hash, deployer);\\n\\n        let address = AztecAddress::compute(public_keys_hash, partial_address);\\n\\n        // Emit the address as a nullifier to be able to prove that this instance has been (not) deployed\\n        context.push_nullifier(address.to_field(), 0);\\n\\n        // Broadcast the event\\n        let event = ContractInstanceDeployed {\\n            DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE,\\n            contract_class_id,\\n            address,\\n            public_keys_hash,\\n            initialization_hash,\\n            salt,\\n            deployer,\\n            version: 1\\n        };\\n\\n        let payload = event.serialize();\\n        dep::aztec::oracle::debug_log::debug_log_format(\\"ContractInstanceDeployed: {}\\", payload);\\n\\n        let contract_address = context.this_address();\\n        let counter = context.next_counter();\\n\\n        // @todo This is very inefficient, we are doing a lot of back and forth conversions.\\n        let log_slice = payload.to_be_bytes_arr();\\n        let log_hash = compute_unencrypted_log_hash(contract_address, payload);\\n        // 40 = addr (32) + raw log len (4) + processed log len (4)\\n        let len = 40 + log_slice.len().to_field();\\n        let side_effect = LogHash { value: log_hash, counter, length: len };\\n        context.unencrypted_logs_hashes.push(side_effect);\\n\\n        let _void = emit_unencrypted_log_private_internal(contract_address, payload, counter);\\n    }\\n}\\n"}}}')),$c=Nr.fromBigInt(19511485909966796736993840362353440247573331327062358513665772226446629198132n);class ed extends Lc{constructor(e,t,n){super(e,t,n)}}async function td(e,t){const{artifactHash:n,privateFunctionsRoot:s,publicBytecodeCommitment:r,packedBytecode:a}=await co(t);console.log("[registerContractClass] artifactHash: ",n.toString()),console.log("[registerContractClass] privateFunctionsRoot: ",s.toString()),console.log("[registerContractClass] publicBytecodeCommitment: ",r.toString());const i=function(e,t){const n=[new X(e.length),...zr(e,X.SIZE_IN_BYTES-1).map((e=>{const t=Pr.alloc(X.SIZE_IN_BYTES);return Pr.from(e).copy(t,1),X.fromBuffer(t)}))];if(n.length>t)throw new Error(`Input buffer exceeds maximum size: got ${n.length} but max is 20000`);return[...n,...Array(t-n.length).fill(X.ZERO)]}(a,2e4),o=await async function(e){const{artifact:t,instance:n}=await async function(){const e=await Oc(Zc,1);if(!e.address.equals(Vc))throw new Error(`Incorrect address for class registerer (got ${e.address.toString()} but expected ${Vc.toString()}).`);return e}();return new ed(n,t,e)}(e);return console.log("[registerContractClass] registerer: ",o.address.toString()),await e.addCapsule(i),o.methods.register(n,s,r)}class nd extends Fc{constructor(e,t,n,s){super(e,t),this.postDeployCtor=n,this.instance=s,this.log=y("aztec:js:deploy_sent_tx")}async deployed(e){console.log("deployed");const t=await this.wait(e);return this.log.info(`Contract ${this.instance.address.toString()} successfully deployed.`),t.contract}async wait(e){const t=await super.wait(e);console.log("[wait in DeploySentTx] receipt.txHash: ",t.txHash.toString());const n=await this.getContractObject(e?.wallet);return console.log("[wait in DeploySentTx] contract address: ",n.address.toString()),console.log("[wait in DeploySentTx] contract instance address: ",n.instance.address.toString()),console.log("[wait in DeploySentTx] instance contractClassId: ",n.instance.contractClassId.toString()),console.log("[wait in DeploySentTx] instance deployer: ",n.instance.deployer.toString()),console.log("[wait in DeploySentTx] instance publicKeysHash: ",n.instance.publicKeysHash.toString()),console.log("[wait in DeploySentTx] instance initializationHash: ",n.instance.initializationHash.toString()),console.log("[wait in DeploySentTx] instance salt: ",n.instance.salt.toString()),console.log("[wait in DeploySentTx] instance version: ",n.instance.version.toString()),{...t,contract:n}}getContractObject(e){const t=e??(!!this.pxe.createTxExecutionRequest&&this.pxe);if(!t)throw new Error("A wallet is required for creating a contract instance");return this.postDeployCtor(this.instance.address,t)}}class sd extends Nc{constructor(e,t,n,s,r=[],a){super(t),this.publicKeysHash=e,this.artifact=n,this.postDeployCtor=s,this.args=r,this.instance=void 0,this.constructorArtifact=function(e,t){if("string"==typeof t){const n=e.functions.find((e=>e.name===t));if(!n)throw new Error(`Constructor method ${t} not found in contract artifact`);if(!n.isInitializer)throw new Error(`Method ${t} is not an initializer`);return n}if(void 0===t)return Cr(e);if(!t.isInitializer)throw new Error(`Method ${t.name} is not an initializer`);return t}(n,a)}async create(e={}){return this.txRequest||(this.txRequest=await this.wallet.createTxExecutionRequest(await this.request(e))),console.log("[create DeployMethod] txRequest.origin: ",this.txRequest.origin.toString()),this.txRequest}async request(e={}){if(console.log("request called"),!this.functionCalls){console.log("registering contract");const t=await this.getInstance(e);console.log("[request] instance address: ",t.address.toString()),await this.wallet.registerContract({artifact:this.artifact,instance:t});const n=await this.getDeploymentFunctionCalls(e),s=await this.getInitializeFunctionCalls(e);if(n.calls.length+s.calls.length===0)throw new Error(`No function calls needed to deploy contract ${this.artifact.name}`);const r={calls:[...n.calls,...s.calls],authWitnesses:[...n.authWitnesses??[],...s.authWitnesses??[]],packedArguments:[...n.packedArguments??[],...s.packedArguments??[]],fee:e.fee};console.log("[request] options.estimateGas: ",e.estimateGas),e.estimateGas&&(await this.getDeploymentFunctionCalls(e),r.fee=await this.getFeeOptionsFromEstimatedGas(r)),this.functionCalls=r}return this.functionCalls}async getDeploymentFunctionCalls(e={}){const t=[],n=await this.getInstance(e);console.log("[getDeploymentFunctionCalls] instance address: ",n.address.toString());const s=await co(this.artifact);if(!n.contractClassId.equals(s.id))throw new Error(`Contract class mismatch when deploying contract: got ${n.contractClassId.toString()} from instance and ${s.id.toString()} from artifact`);return console.log("[getDeploymentFunctionCalls] options.skipClassRegistration: ",e.skipClassRegistration),e.skipClassRegistration||(await this.wallet.isContractClassPubliclyRegistered(s.id)?this.log.debug(`Skipping registration of already registered contract class ${s.id.toString()} for ${n.address.toString()}`):(this.log.info(`Creating request for registering contract class ${s.id.toString()} as part of deployment for ${n.address.toString()}`),t.push((await td(this.wallet,this.artifact)).request()))),console.log("[getDeploymentFunctionCalls] options.skipPublicDeployment: ",e.skipPublicDeployment),e.skipPublicDeployment||t.push((await async function(e,t){const n=await async function(e){const{artifact:t,instance:n}=await async function(){const e=await Oc(Qc,1);if(!e.address.equals($c))throw new Error(`Incorrect address for contract deployer (got ${e.address.toString()} but expected ${$c.toString()}).`);return e}();return new ed(n,t,e)}(e),{salt:s,contractClassId:r,publicKeysHash:a,deployer:i}=t,o=i.isZero();if(!o&&!e.getAddress().equals(i))throw new Error(`Expected deployer ${i.toString()} does not match sender wallet ${e.getAddress().toString()}`);return n.methods.deploy(s,r,t.initializationHash,a,o)}(this.wallet,n)).request()),{calls:t}}async getInitializeFunctionCalls(e){const{address:t}=await this.getInstance(e);console.log("[getInitializeFunctionCalls] address: ",t.toString());const n=[];if(this.constructorArtifact&&!e.skipInitialization){const e=new Gc(this.wallet,t,this.constructorArtifact,this.args);n.push(e.request())}return Promise.resolve({calls:n})}async send(e={}){const t=(await super.send(e)).getTxHash(),n=await this.getInstance(e);return console.log("[send] instance address: ",n.address.toString()),this.log.debug(`Sent deployment tx of ${this.artifact.name} contract with deployment address ${n.address.toString()}`),new nd(this.wallet,t,this.postDeployCtor,n)}async getInstance(e={}){return this.instance||(this.instance=await po(this.artifact,{constructorArgs:this.args,salt:e.contractAddressSalt,publicKeysHash:this.publicKeysHash,constructorArtifact:this.constructorArtifact,deployer:e.universalDeploy?Nr.ZERO:this.wallet.getAddress()})),this.instance}async prove(e){return await super.prove(e)}async estimateGas(e){return await super.estimateGas(e)}get address(){return this.instance?.address}get partialAddress(){return console.log("get partialAddress called in DeployMethod: ",this.instance?.address.toString()),this.log.debug("get partialAddress called in DeployMethod"),this.instance&&$i(this.instance)}}class rd extends Lc{static async at(e,t,n){console.log("[at in Contract] artifact: ",t.name),console.log("[at in Contract] address: ",e.toString());const s=await n.getContractInstance(e);if(void 0===s)throw new Error(`Contract instance at ${e.toString()} has not been registered in the wallet's PXE`);return new rd(s,t,n)}static deploy(e,t,n,s){return console.log("[deploy in Contract] artifact: ",t.name),console.log("[deploy in Contract] wallet address: ",e.getAddress().toString()),new sd(X.ZERO,e,t,((e,n)=>rd.at(e,t,n)),n,s)}static deployWithPublicKeysHash(e,t,n,s,r){return console.log("[deployWithPublicKeysHash in Contract] artifact: ",n.name),console.log("[deployWithPublicKeysHash in Contract] wallet address: ",t.getAddress().toString()),new sd(e,t,n,((e,t)=>rd.at(e,n,t)),s,r)}}class ad extends Nc{constructor(e,t){super(e),this.calls=t}async create(e){if(!this.txRequest){const t=this.calls,n=e?.estimateGas?await this.getFeeOptionsFromEstimatedGas({calls:t,fee:e?.fee}):e?.fee;this.txRequest=await this.wallet.createTxExecutionRequest({calls:t,fee:n})}return this.txRequest}async simulate(e={}){const{calls:t,unconstrained:n}=this.calls.reduce(((e,t,n)=>(t.type===xr.UNCONSTRAINED?e.unconstrained.push([t,n]):e.calls.push([t,n,t.type===xr.PRIVATE?e.privateIndex++:e.publicIndex++]),e)),{calls:[],unconstrained:[],publicIndex:0,privateIndex:0}),s=await this.wallet.createTxExecutionRequest({calls:t.map((e=>e[0]))}),r=n.map((async t=>{const n=t[0];return[await this.wallet.simulateUnconstrained(n.name,n.args,n.to,e?.from),t[1]]})),[a,i]=await Promise.all([Promise.all(r),await this.wallet.simulateTx(s,!0,e?.from)]),o=[];return a.forEach((([e,t])=>{o[t]=e})),t.forEach((([e,t,n])=>{const s=e.type==xr.PRIVATE?i.privateReturnValues?.nested?.[n].values:i.publicOutput?.publicReturnValues?.[n].values;o[t]=s?Or(e.returnTypes,s):[]})),o}}class id{constructor(e,t,n,s){this.artifact=e,this.wallet=t,this.publicKeysHash=n,this.constructorName=s}deploy(...e){return new sd(this.publicKeysHash??X.ZERO,this.wallet,this.artifact,((e,t)=>rd.at(e,this.artifact,t)),e,this.constructorName)}}async function od(e){const t=new $a;return await t.mul(t.generator(),e)}const ld=(e,t=Po([1,2,3],!1))=>Fo(e,{AuthWitness:mo,AztecAddress:Nr,CompleteAddress:di,FunctionSelector:Ur,EthAddress:da,ExtendedNote:Ec,ExtendedUnencryptedL2Log:jl,Fr:X,GrumpkinScalar:D,L2Block:Jo,TxEffect:sc,LogId:ml,Note:Al,Point:Ie,TxExecutionRequest:Cc,TxHash:Wl,NoteSelector:Dr},{Tx:Vl,SimulatedTx:Ql,TxReceipt:tc,EncryptedNoteL2BlockL2Logs:ul,UnencryptedL2BlockL2Logs:hl,NullifierMembershipWitness:Lo},!1,"pxe",t);var cd=r(6497),dd=r.n(cd),ud=r(8891).Buffer;class fd{constructor(e,t){this.eth=e,this.aztec=t}static create(e,t){const n=new hd(e),s=new pd(t,n);return new fd(n,s)}}class hd{constructor(e,t=y("aztec:cheat_codes:eth")){this.rpcUrl=e,this.logger=t}async rpcCall(e,t){const n={body:`{"jsonrpc":"2.0", "method": "${e}", "params": ${JSON.stringify(t)}, "id": 1}`,method:"POST",headers:{"Content-Type":"application/json"}};return await(await fetch(this.rpcUrl,n)).json()}async blockNumber(){const e=await this.rpcCall("eth_blockNumber",[]);return parseInt(e.result,16)}async chainId(){const e=await this.rpcCall("eth_chainId",[]);return parseInt(e.result,16)}async timestamp(){const e=await this.rpcCall("eth_getBlockByNumber",["latest",!0]);return parseInt(e.result.timestamp,16)}async mine(e=1){const t=await this.rpcCall("hardhat_mine",[e]);if(t.error)throw new Error(`Error mining: ${t.error.message}`);this.logger.info(`Mined ${e} blocks`)}async setNextBlockTimestamp(e){const t=await this.rpcCall("evm_setNextBlockTimestamp",[e]);if(t.error)throw new Error(`Error setting next block timestamp: ${t.error.message}`);this.logger.info(`Set next block timestamp to ${e}`)}async dumpChainState(e){const t=await this.rpcCall("hardhat_dumpState",[]);if(t.error)throw new Error(`Error dumping state: ${t.error.message}`);const n=JSON.stringify(t.result);dd().writeFileSync(`${e}.json`,n,"utf8"),this.logger.info(`Dumped state to ${e}`)}async loadChainState(e){const t=JSON.parse(dd().readFileSync(`${e}.json`,"utf8")),n=await this.rpcCall("hardhat_loadState",[t]);if(n.error)throw new Error(`Error loading state: ${n.error.message}`);this.logger.info(`Loaded state from ${e}`)}async load(e,t){const n=await this.rpcCall("eth_getStorageAt",[e.toString(),d(t),"latest"]);return BigInt(n.result)}async store(e,t,n){const s=await this.rpcCall("hardhat_setStorageAt",[e.toString(),d(t),d(n,!0)]);if(s.error)throw new Error(`Error setting storage for contract ${e} at ${t}: ${s.error.message}`);this.logger.info(`Set storage for contract ${e} at ${t} to ${n}`)}keccak256(e,t){const n=d(t,!0).substring(2)+d(e,!0).substring(2);return l(pe(ud.from(n,"hex")))}async startImpersonating(e){const t=await this.rpcCall("hardhat_impersonateAccount",[e.toString()]);if(t.error)throw new Error(`Error impersonating ${e}: ${t.error.message}`);this.logger.info(`Impersonating ${e}`)}async stopImpersonating(e){const t=await this.rpcCall("hardhat_stopImpersonatingAccount",[e.toString()]);if(t.error)throw new Error(`Error when stopping the impersonation of ${e}: ${t.error.message}`);this.logger.info(`Stopped impersonating ${e}`)}async etch(e,t){const n=await this.rpcCall("hardhat_setCode",[e.toString(),t]);if(n.error)throw new Error(`Error setting bytecode for ${e}: ${n.error.message}`);this.logger.info(`Set bytecode for ${e} to ${t}`)}async getBytecode(e){return(await this.rpcCall("eth_getCode",[e.toString(),"latest"])).result}}class pd{constructor(e,t,n=y("aztec:cheat_codes:aztec")){this.pxe=e,this.eth=t,this.logger=n}async computeSlotInMap(e,t){return await Me([new X(e),new X(t)])}async blockNumber(){return await this.pxe.getBlockNumber()}async warp(e){const t=(await this.pxe.getNodeInfo()).l1ContractAddresses.rollupAddress;await this.eth.setNextBlockTimestamp(e),await this.eth.store(t,2n,BigInt(e)),await this.eth.store(t,3n,BigInt(e))}async loadPublic(e,t){return await this.pxe.getPublicStorageAt(e,new X(t))}async loadPrivate(e,t,n){return(await this.pxe.getIncomingNotes({owner:e,contractAddress:t,storageSlot:new X(n)})).map((e=>e.note))}}var _d=r(8891).Buffer;const md=async(e,t)=>{const n=t.chainId,s=t.version;if("caller"in e){const t=e.action instanceof Gc?e.action.request():e.action;return await yd(t.to.toField(),n,s,await gd(e.caller,t))}{const t=_d.isBuffer(e.innerHash)?X.fromBuffer(e.innerHash):e.innerHash;return await yd(e.consumer,n,s,t)}},gd=async(e,t)=>await bd([e.toField(),t.selector.toField(),(await xc.fromValues(t.args)).hash]),bd=async e=>await Me(e,nt.AUTHWIT_INNER),yd=async(e,t,n,s)=>await Me([e.toField(),t,n,s],nt.AUTHWIT_OUTER),vd=async(e,t)=>{await wo((async()=>{try{return t?.debug("Attempting to contact PXE..."),await e.getNodeInfo(),!0}catch(e){t?.verbose("Failed to contact PXE")}}),"RPC Get Node Info")};async function wd(e,t,{interval:n,timeout:s}=Pc){const r=t.address.toString();await wo((async()=>{const t=await e.getSyncStatus(),n=t.notes[r];return void 0!==n&&n>=t.blocks}),"waitForAccountSynch",s,n)}var Ad,Ed,xd,Sd,Td;class kd{constructor(e){Ad.set(this,[]),Ed.set(this,[]),xd.set(this,X.random()),Sd.set(this,void 0),P(this,Sd,e,"f")}async init(e){for(const t of e)z(this,Ad,"f").push(await xc.fromValues(t.args));return P(this,Ed,e.map(((e,t)=>({args_hash:z(this,Ad,"f")[t].hash,function_selector:e.selector.toField(),target_address:e.to.toField(),is_public:e.type==xr.PUBLIC,is_static:e.isStatic}))),"f"),this}get function_calls(){return z(this,Ed,"f")}get nonce(){return z(this,xd,"f")}get packedArguments(){return z(this,Ad,"f")}async hash(){return await Me(this.toFields(),z(this,Sd,"f"))}functionCallsToFields(){return z(this,Ed,"f").flatMap((e=>[e.args_hash,e.function_selector,e.target_address,new X(e.is_public),new X(e.is_static)]))}static async fromFunctionCalls(e){const t=new Cd(0);return await t.init(e)}static async fromAppExecution(e){if(e.length>4)throw new Error(`Expected at most 4 function calls, got ${e.length}`);const t=oa(e,hc.empty(),4),n=new Cd(nt.SIGNATURE_PAYLOAD);return await n.init(t)}static async fromFeeOptions(e,t){const n=await(t?.paymentMethod.getFunctionCalls(t?.gasSettings))??[],s=await(t?.paymentMethod.getFeePayer(t?.gasSettings)),r=!!s&&s.equals(e),a=oa(n,hc.empty(),2),i=new zd(nt.FEE_PAYLOAD,r);return await i.init(a)}}Ad=new WeakMap,Ed=new WeakMap,xd=new WeakMap,Sd=new WeakMap;class Cd extends kd{toFields(){return[...this.functionCallsToFields(),this.nonce]}}class zd extends kd{constructor(e,t){super(e),Td.set(this,void 0),P(this,Td,t,"f")}toFields(){return[...this.functionCallsToFields(),this.nonce,new X(z(this,Td,"f"))]}get is_fee_payer(){return z(this,Td,"f")}}Td=new WeakMap;const Pd=Dc(JSON.parse('{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"MultiCallEntrypoint","functions":[{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2b3U7bQBCF18GhBoOb2HGckEAIBaTehRSScMfLtM/d60p9haqss6Mclmm0UcdLVool5LG9O+ebsz+EyERqfSSvP5GJ2+Z8rN4f1ObFnGf/dzwI5po1yRkFwtkKhPMoEM5YkDNiOPU5NrFed3rNfVLr9fjuIXbWA30Ez9W2RLZqYgJ8eC1V6Wr2fAzJEVwZ8Ng8o7PGSc0zBEtNkXUbuEeFtuAe6RzBPdrBSCcxpgjX+5RskOXyvs4+XcOJyUXcKcT4bAzWxQ3V2Jav8bGRMXn1rqExqVcx+d42uRO4pjE4NbHgb44H1I7Mz6k1F2KIR9CW2pEfLWDVx7narJfTLf1iq18GbY6hn7230DWNtfaqa2J9btOeAPkb8HCm86byed+MTWx5l0JNGXgioz1f6fxn6u0RWdfXEGfAcy7Os1578nWux+4zsMvkfXrUXnUsr84srzJogwydBvyLQJdy03WH0ZbzYrHS2l0HL7oMT9ezF11GW9CLZ62dO3iRMzy5Zy9yRlvOi+U3rV04eFEwPIVnLwpGW86Lef0ZoOfgRY/h6Xn2osdoC66Rel6UDl6UDE/p2YuS0Rb04ofW7jt40Wd4+p696DPagl5819qVgxcVw1N59qJitAX3zvrzxcDBiwHDM/DsxYDRFvRirrWHDl4MGZ6hZy+GjLbgGqm1Lxy8uGB4Ljx7QXq7MvcCZK4CZC72gDmxYhntRb1/jhy8GDE8I89e4HcuuzCXe8CcWLGM9uJJa48dvBgzPGPPXpDersx5gMxFgMz9AJnLAJmrAJn3YT4nViyjvaz30EsHLy4ZnkvPXpDersx5gMyjAJmLPWBOrFhGe1l/N3fl4MUVw3Pl2QvS25V5ECBzdw+YEyuW0V4utPbEwYsJwzPx7AXp7co8DJC5CpB5FCBzESBzP0DmMkDmwxr0w5zvATO+e/S7UZ75c2rxkGfKYlQWYwpxBozU9kXJva+SWbWT1lTcj/X42POFrqeNas9XOu+XBmrSeW/l89Z/I9yZXPQO3y3j1b2JI+FxuoO8EejQ/RjiX9CW2pEftB8Qu36X68bE91v6Tax+GbS5gX63Vj+6prHW3v00cVNzy2Ved9RmLX8Fngb2wUd8J1eBV8pipGMCPNfyPA8N1TnDd/j+KNm1N7W8OrG8yqAN7tEftW8emA/M/2LGzxMncA956F7LqgX/v2EKOf4CARQXTpY1AAA=","debug_symbols":"ndpRattAGIXRveg5FN/f0swoWymlOIlTDMEJsVMoJnuv3dIF9LxpJN237+kwl+lp//Dx4/vh+Px6mu6/XqaX18fd+fB6vJ4u0+ZLjT9vT2+74+3F6bx7P0/329bvpv3x6frU6/Nuej687K/P6/j8dncbrTDabmQUGZWMtjKaZbTIqMmoy0iK2EoRsxQxSxGzFDFLEbMUMUsRsxQxSxGzFDFLEYsUsUgRixSxSBGLFLFIEYsUsUgRixSxSBFNimhSRJMimhTRpIgmRTQpokkRTYpoUkSXIroU0aWILkV0KaJLEV2K6FJElyK6FDGkiCFFDCliSBFDihhSxJAihhQxpIghRaxSxCpFrFLEKkWsUsQqRaxSxCpFrFLEKkVks6FVaFW02tJqptVCq0arTqtBK2oj1EaojVAboTZCbYTaCLURaiPURqiNojaK2ihqo6iNojaK2ihqo6gNAs2QaIZIM2SaIdQMqWaINUOuGYLNkGyGaDNkmyHcDOlmiDdDvhkCzpBwhogzZJwh5AwpZ4g5Q84Zgs6QdIaoM2SdIewMaWeIO0PeGQLPkHiGyDNkniH0DKlniD1D7hmCz5B8hugzZJ8h/AzpZ4g/Q/4ZAtCQgIYINGSgIQQNKWiIQUMOGoLQkISGKDRkoSEMDWloiENDHhoC0ZCIhkg0ZKIhFA2paIhFQy5a5KJFLlrkokUuWuSiRS5a5KJFLlrkokUuWuSiRS5a5KJFLlrkokUuWuSiRS5a5KJFLlrkokUuWuSiRS5a5KJFLlrkokUuWnbRk1y0yEWLXLTIRYtctMhFi1y0/ttFr6efu/fD7uFlf7vbe/v4cXz8d9X3ejz/evv75frvbw=="},{"name":"entrypoint","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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NVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXONVu9c81W71yz1TvXbPW+Ja5yqVxV55qt3rlmq3eu2eqda7Z655qt3rlmq3eu2eqda7Z655qt3rlmq3eu2eqda7Z655qt3rlmq3eu2eqda7Z655qt3rlmq3eu2eqda7Z655qt3rlmq3eu2eqda7Z655qt3rlmq3eu2eqda7Z655qt3rlmq3eu2eqda7Z655qt3rlmq3eu2eqda7Z655qt3rlmq3eu2eqda7Z655qt3rlmq3eu2eqda7Z655qt3rlmq3eu2eqda7Z655qt3rlmq3eu2eqda7Z655qt3rlmq3eu2eqda7Z655qt3rlmq3eu2eqda7Z655qt3rlmq3eu2eqda7Z655qt3rlmq3eu2eqda7Z655qt3rlmq3eu2eqda7Z655qt3rlmq3eu2eqda7Z655qt3rlmq3eu2eqda7Z655qt3rlmq3eu2eqda7Z655qt3rlmq3eu2eqda7Z655qt3rlmq3eu2eqda7Z655qt3qlmq9eNarb6rVwmV3Url8lV3cplclW3chNXuUyu6lYuk6u6lcvkqm7lMrmqW7lcropqtvqtXC5XRTVb/VYul6uimq1+K5fLVVHNVr+Vy+WqqGar38rlclVUs9Vv5XK5KqrZ6rdyuVwV1Wz1W7lcropqtvqtXC5XRTVb/VYul6uimq1+K5fLVVHNVr+Vy+WqqGar38rlclVUs9Vv5XK5KqrZ6rdyuVwV1Wz1W7lcropqtvqtXC5XRTVb/VYul6uimq1+K5fLVVHNVr+Vy+WqqGar38rlclVUs9Vv5XK5KqrZ6rdyuVwV1Wz1W7lcropqtvqtXC5XRTVb/VYul6uimq1+K5fLVVHNVr+Vy+WqqGar38rl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/mW5XK9UlXz3slyuV6pKvndZLtcrVSXfuSyX65Wqku9blsv1SlXJdy3L5XqlquR7luVyvVJV8h3LcrleqSr5fmW5XK9UlXy3slyuV6pKvldZLtcrVSXfqSyX65Wqku9Tlsv1SlXJdynL5XqlqrtXqrp7parkW7Llcr1SVfNKVc0rVSXfgS6X65Wqku9Al8v1SlXJd6DL5XqlquQ70OVyvVJV8h3ocrleqSr5DnS5XK9UlXwHulyuV6ry2q0+ee1Wn7x2q09eu9Unr93qk9du9clrt/rktVt98tqtPnntVp+8dqtPXrvVJ6/d6pPXbvXJa7f65LVbffLarT557VafvHarT1671Sev3eqT1271yWu3+uS1W33y2q0+ee1Wn7x2q09eu9Unr93qk9du9clrt/rktVt98tqtPnntVp+8dqtPXrvVJ6/d6pPXbvXJa7f65LVbffLarT557VafvHarT1671Wev3eqz12712Wu3+uy1W32+NS+5Vqlq9tqtPnvtVp+9dqvPXrvVZ6/d6rPXbvXZa7f67LVbffbarT577VafvXarz1671Wev3eqz12712Wu3+uy1W3322q0+e+1Wn712q89eu9Vnr93qs9du9dlrt/rstVt99tqtPnvtVp+9dqvPXrvVZ6/d6rPXbvXZa7f67LVbffbarT577VafvXarz1671Wev3eqz12712Wu3+uy1W3322q0+e+1Wn712q89eu9Vnr93qs9du9dlrt/rstVt99tqtPnvtVp+9dqvPXrvVZ6/d6rPXbvXZa7f67LVbffbarT577VafvXarz1671Wev3eqz12712Wu3+uy1W3322q0+e+1Wn712q89eu9Vnr93qs9du9dlrt/rstVt99tqtPnvtVp+9dqvPXrvVZ6/d6rPXbvXZa7f67LVbffbarT577VafvXarz1671Wev3eqz12712Wu3+uy1W3322q0+e+1Wn712q89eu9Vnr93qs9du9bvXbvW71271u9du9bvXbvX7rXnJtUpVd6/d6nev3ep3r93qd6/d6nev3ep3r93qd6/d6nev3ep3r93qd6/d6nev3ep3r93qd6/d6vdK27ePbX68eLufyC303I3ILfTJfOz788XbidxCn8wRuYU+mSNyC30yR+QW6rsBuZX2M0fkVnruBuRWeu4G5BbquxG5zUuuV6qqtJ85InfYVPWS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ybVKVdvNKlVtN6tUtd2sUtV280pVk1eqqnTHPiLXK1VVutkekdu85HqlqkpXwSNyvVJVpQvYEbleqarSteeIXK9UVemycUSuV6qqdMU3ItcrVVW6WBuR65WqKl1njcj1SlWVLpFG5HqlqkpXNyNyvVJVpQuTEbleqarSNcWIXK9UVelyYESuV6qqdCUvItcrVVW6CBeR65WqKl0/i8j1SlWVLn1F5HqlqkpXrSJyvVJVpQtOEbleqarStaKIXK9UVekyT0SuV6qqdIUmItcrVVW6uBKR65WqKl0Xicj1SlWVLmlE5HqlqkpXIyJyvVJVpQsJEbleqarSNYCIXK9UVWmrfkSuV6qqtPk+ItcrVVXaTh+R65WqKm2Qj8j1SlWVtrxH5Hqlqkqb2CNyvVKV1271zWu3+ua1W33z2q2+ee1W37x2q29eu9U3r93qm9du9c1rt/rmtVt989qtvnntVt+8dqtvXrvVN6/d6pvXbvXNa7f67rVbfffarb577VbfvXar77fmJdcqVe1eu9V3r93qu9du9d1rt/rutVt999qtvnvtVt+9dqvvXrvVd6/d6rvXbvXda7f67rVbfffarb577VbfvXar71671Xev3eq712713Wu3+u61W3332q2+e+1W3712q+9eu9V3r93qu9du9d1rt/rutVt999qtvnvtVt+9dqvvXrvVd6/d6rvXbvXda7f67rVbfffarb577VbfvXar71671Xev3eq712713Wu3+u61W3332q2+e+1W3712q+9eu9V3r93qu9du9d1rt/rutVt999qtvnvtVt+9dqvvXrvVd6/d6rvXbvXda7f67rVbfffarb577VbfvXar71671Xev3eq712713Wu3+u61W3332q2+e+1W3712q+9eu9V3r93qu9du9d1rt/rutVt999qtvnvtVt+9dqvvXrvVd6/d6rvXbvXda7f67rVbfffarb577VbfvXar71671Xev3eq712713Wu3+u61W3332q1+eO1WP7x2qx9eu9UPr93qx615ybVKVYfXbvXDa7f64bVb/fDarX547VY/vHarH1671Q+v3eqH1271w2u3+uG1W/3w2q1+eO1WP7x2qx9eu9UPr93qh9du9cNrt/rhtVv98NqtfnjtVj+8dqsfXrvVD6/d6ofXbvXDa7f64bVb/fDarX547VY/vHarH1671Q+v3eqH1271w2u3+uG1W/3w2q1+eO1WP7x2qx9eu9UPr93qh9du9cNrt/rhtVv98NqtfnjtVj+8dqsfXrvVD6/d6ofXbvXDa7f64bVb/fDarX547VY/vHarH1671Q+v3eqH1271w2u3+uG1W/3w2q1+eO1WP7x2qx9eu9UPr93qh9du9cNrt/rhtVv98NqtfnjtVj+8dqsfXrvVD6/d6ofXbvXDa7f64bVb/fDarX547VY/vHarH1671Q+v3eqH1271w2u3+uG1W/3w2q1+eO1WP7x2qx9eu9UPr93qh9du9cNrt/rhtVv98NqtfnjtVj+sdqtvN6vd6l9ynVLVl1ynVPUl1ylVfcltXnKdUtWXXKdU9SXXKVV9yXVKVV9yvVKV1W71L7leqcpqt/qXXK9UZbVb/UuuV6qy2q3+JdcrVVntVv+S65WqrHarf8n1SlVWu9W/5HqlKqvd6l9yvVKV1W71L7leqcpqt/qXXK9UZbVb/UuuV6qy2q3+JdcrVVntVv+S65WqrHarf8n1SlVWu9W/5HqlKqvd6l9yvVKV1W71L7leqcpqt/qXXK9UZbVb/UuuV6qy2q3+JdcrVVntVv+S65WqrHarf8n1SlVWu9W/5HqlKqvd6l9yvVKV1W71L7leqcpqt/qXXK9UZbVb/UuuV6qy2q3+JdcrVVntVv+S65WqrHarf8n1SlVWu9W/5HqlKqvd6l9yvVKV1W71L7leqcpqt/qXXK9UZbVb/UuuV6qy2q3+JdcrVVntVv+S65WqrHarf8n1SlVWu9W/5HqlKqvd6l9yvVKV1W71L7leqcpqt/qXXK9UZbVb/UuuV6qy2q3+JdcrVVntVv+Sa5WqJq/d6pPXbvXJa7f65LVb/UuMl1yrVDV57VafvHarT1671Sev3eqT1271yWu3+uS1W33y2q0+ee1Wn7x2q09eu9Unr93qk9du9clrt/rktVt98tqtPnntVp+8dqtPXrvVJ6/d6pPXbvXJa7f65LVbffLarT557VafvHarT1671Sev3eqT1271yWu3+uS1W33y2q0+ee1Wn7x2q09eu9Unr93qk9du9clrt/rktVt98tqtPnntVp+8dqtPXrvVJ6/d6pPXbvXJa7f65LVbffLarT557VafvHarT1671Sev3eqT1271yWu3+uS1W33y2q0+ee1Wn7x2q09eu9Unr93q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29++i+1v38X2t+9i+9t3sf3tu9j+9l1sf/sutr99F9vfvovtb9/F9rfvYvvbd7H97bvY/vZdbH/7Lra/fRfb376L7W/fxfa372L723ex/e272P72XWx/+y62v30X29++i+1v38X2t+9i+9t3sf3tu9j+9l1sf/sutr99F9vfvovtb9/F9rfvYvvbd7H97bvY/vZdbH/7Lra/fRfb376L7W/fxfa372L723ex/e272P72XWx/+y62v30X29++i+1v38X2t+9i+9t3sf3tu9j+9l1sf/sutr99F9vfvovtbz/E9rcfYvvbD7H97YfY/vbjVsX0auWrQ2x/+yG2v/0Q299+iO1vP8T2tx9i+9sPsf3th9j+9kNsf/shtr/9ENvffojtbz/E9rcfYvvbD7H97YfY/vZDbH/7Iba//RDb336I7W8/xPa3H2L72w+x/e2H2P72Q2x/+yG2v/0Q299+iO1vP8T2tx9i+9sPsf3th9j+9kNsf/shtr/9ENvffojtbz/E9rcfYvvbD7H97YfY/vZDbH/7Iba//RDb336I7W8/xPa3H2L72w+x/e2H2P72Q2x/+yG2v/0Q299+iO1vP8T2tx9i+9sPsf3th9j+9kNsf/shtr/9ENvffojtbz/E9rcfYvvbD7H97YfY/vZDbH/7Iba//RDb336I7W8/xPa3H2L72w+x/e2H2P72Q2x/+yG2v/0Q299+iO1vP8T2tx9i+9sPsf3th9j+9kNsf/shtr/9ENvffojtbz/E9rcfYvvbD7H97YfY/vZDbH/7Iba//RDb336I7W8/xPa3H1r727eb1v72u16pfHXXK5Wv7nql8tVdbxXTK5Wv7nql8tVdr1S+uuuVyld3vWL5Smt/+12vWL7S2t9+1yuWr7T2t9/1iuUrrf3td71i+Uprf/tdr1i+0trfftcrlq+09rff9YrlK6397Xe9YvlKa3/7Xa9YvtLa337XK5avtPa33/WK5Sut/e13vWL5Smt/+12vWL7S2t9+1yuWr7T2t9/1iuUrrf3td71i+Uprf/tdr1i+0trfftcrlq+09rff9YrlK6397Xe9YvlKa3/7Xa9YvtLa337XK5avtPa33/WK5Sut/e13vWL5Smt/+12vWL7S2t9+1yuWr7T2t9/1iuUrrf3td71i+Uprf/tdr1i+0trfftcrlq+09rff9YrlK6397Xe9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+atKl2665jXzV5WuunTNa+avKl0w6ZrXzF9VutbRNa+Zv6p0maJrXjN/VekKQ9e8Zv6q0sWBrnnN/FWlzf1d85r5q0rb9bvmNfNXlTbgd81r5q8qbanvmtfMX1XaJN81r5m/qrTtvWteM39ltr99M9vfvpntb9/M9rdvZvvbN7P97ZvZ/vbNbH/7Zra/fTPb376Z7W/fzPa3b2b72zez/e2b2f72zWx/+2a2v30z29++m+1v3832t+9m+9t3s/3t+62Zzevlr3az/e272f723Wx/+262v30329++m+1v3832t+9m+9t3s/3tu9n+9t1sf/tutr99N9vfvpvtb9/N9rfvZvvbd7P97bvZ/vbdbH/7bra/fTfb376b7W/fzfa372b723ez/e272f723Wx/+262v30329++m+1v3832t+9m+9t3s/3tu9n+9t1sf/tutr99N9vfvpvtb9/N9rfvZvvbd7P97bvZ/vbdbH/7bra/fTfb376b7W/fzfa372b723ez/e272f723Wx/+262v30329++m+1v3832t+9m+9t3s/3tu9n+9t1sf/tutr99N9vfvpvtb9/N9rfvZvvbd7P97bvZ/vbdbH/7bra/fTfb376b7W/fzfa372b723ez/e272f723Wx/+262v30329++m+1v3832t+9m+9t3s/3tu9n+9t1sf/tutr99N9vfvpvtb9/N9rfvZvvbd7P97bvZ/vbdbH/7bra/fTfb376b7W8/zPa3H2b72w+z/e2H2f7249bM5vXyV4fZ/vbDbH/7Yba//TDb336Y7W8/zPa3H2b72w+z/e2H2f72w2x/+2G2v/0w299+mO1vP8z2tx9m+9sPs/3th9n+9sNsf/thtr/9MNvffpjtbz/M9rcfZvvbD7P97YfZ/vbDbH/7Yba//TDb336Y7W8/zPa3H2b72w+z/e2H2f72w2x/+2G2v/0w299+mO1vP8z2tx9m+9sPs/3th9n+9sNsf/thtr/9MNvffpjtbz/M9rcfZvvbD7P97YfZ/vbDbH/7Yba//TDb336Y7W8/zPa3H2b72w+z/e2H2f72w2x/+2G2v/0w299+mO1vP8z2tx9m+9sPs/3th9n+9sNsf/thtr/9MNvffpjtbz/M9rcfZvvbD7P97YfZ/vbDbH/7Yba//TDb336Y7W8/zPa3H2b72w+z/e2H2f72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"}],"outputs":{"globals":{},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"}}],"kind":"struct","path":"MultiCallEntrypoint::entrypoint_parameters"}}],"kind":"struct","path":"MultiCallEntrypoint::entrypoint_abi"}]}},"file_map":{"5":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\\n\\nstruct BoundedVec<T, let MaxLen: u32> {\\n    storage: [T; MaxLen],\\n    len: u32,\\n}\\n\\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\\n    pub fn new() -> Self {\\n        let zeroed = crate::unsafe::zeroed();\\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\\n    }\\n\\n    /// Get an element from the vector at the given index.\\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\\n    pub fn get(self, index: u32) -> T {\\n        assert(index < self.len);\\n        self.get_unchecked(index)\\n    }\\n\\n    /// Get an element from the vector at the given index.\\n    /// Responds with undefined data for `index` where `self.len < index < self.max_len()`.\\n    pub fn get_unchecked(self, index: u32) -> T {\\n        self.storage[index]\\n    }\\n\\n    /// Write an element to the vector at the given index.\\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\\n    pub fn set(&mut self, index: u32, value: T) {\\n        assert(index < self.len, \\"Attempted to write past end of BoundedVec\\");\\n        self.set_unchecked(index, value)\\n    }\\n\\n    /// Write an element to the vector at the given index.\\n    /// Does not check whether the passed `index` is a valid index within the vector.\\n    ///\\n    /// Silently writes past the end of the vector for `index` where `self.len < index < self.max_len()`\\n    /// Panics if the given index points beyond the maximum length of the vector (`self.max_len()`).\\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\\n        self.storage[index] = value;\\n    }\\n\\n    pub fn push(&mut self, elem: T) {\\n        assert(self.len < MaxLen, \\"push out of bounds\\");\\n\\n        self.storage[self.len] = elem;\\n        self.len += 1;\\n    }\\n\\n    pub fn len(self) -> u32 {\\n        self.len\\n    }\\n\\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\\n        MaxLen\\n    }\\n\\n    // This is a intermediate method, while we don\'t have an\\n    // .extend method\\n    pub fn storage(self) -> [T; MaxLen] {\\n        self.storage\\n    }\\n\\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\\n        let new_len = self.len + array.len();\\n        assert(new_len <= MaxLen, \\"extend_from_array out of bounds\\");\\n        for i in 0..array.len() {\\n            self.storage[self.len + i] = array[i];\\n        }\\n        self.len = new_len;\\n    }\\n\\n    pub fn extend_from_slice(&mut self, slice: [T]) {\\n        let new_len = self.len + slice.len();\\n        assert(new_len <= MaxLen, \\"extend_from_slice out of bounds\\");\\n        for i in 0..slice.len() {\\n            self.storage[self.len + i] = slice[i];\\n        }\\n        self.len = new_len;\\n    }\\n\\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\\n        let append_len = vec.len();\\n        let new_len = self.len + append_len;\\n        assert(new_len <= MaxLen, \\"extend_from_bounded_vec out of bounds\\");\\n\\n        let mut exceeded_len = false;\\n        for i in 0..Len {\\n            exceeded_len |= i == append_len;\\n            if !exceeded_len {\\n                self.storage[self.len + i] = vec.get_unchecked(i);\\n            }\\n        }\\n        self.len = new_len;\\n    }\\n\\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\\n        assert(Len <= MaxLen, \\"from array out of bounds\\");\\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\\n        vec.extend_from_array(array);\\n        vec\\n    }\\n\\n    pub fn pop(&mut self) -> T {\\n        assert(self.len > 0);\\n        self.len -= 1;\\n\\n        let elem = self.storage[self.len];\\n        self.storage[self.len] = crate::unsafe::zeroed();\\n        elem\\n    }\\n\\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\\n        let mut ret = false;\\n        let mut exceeded_len = false;\\n        for i in 0..MaxLen {\\n            exceeded_len |= i == self.len;\\n            if !exceeded_len {\\n                ret |= predicate(self.storage[i]);\\n            }\\n        }\\n        ret\\n    }\\n\\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\\n        let mut ret = BoundedVec::new();\\n        ret.len = self.len();\\n        for i in 0..MaxLen {\\n            if i < self.len() {\\n                ret.storage[i] = f(self.get_unchecked(i));\\n            }\\n        }\\n        ret\\n    }\\n}\\n\\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\\n        // TODO: https://github.com/noir-lang/noir/issues/4837\\n        //\\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\\n        \\n        (self.len == other.len) & (self.storage == other.storage)\\n    }\\n}\\n\\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen>  {\\n        BoundedVec::from_array(array)\\n    }\\n}\\n\\nmod bounded_vec_tests {\\n    // TODO: Allow imports from \\"super\\"\\n    use crate::collections::bounded_vec::BoundedVec;\\n\\n    #[test]\\n    fn empty_equality() {\\n        let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\\n        let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\\n\\n        assert_eq(bounded_vec1, bounded_vec2);\\n    }\\n\\n    #[test]\\n    fn inequality() {\\n        let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\\n        let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\\n        bounded_vec1.push(1);\\n        bounded_vec2.push(2);\\n\\n        assert(bounded_vec1 != bounded_vec2);\\n    }\\n\\n    mod set {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn set_updates_values_properly() {\\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\\n\\n            vec.set(0, 42);\\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\\n\\n            vec.set(1, 43);\\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\\n\\n            vec.set(2, 44);\\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\\n\\n            vec.set(1, 10);\\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\\n\\n            vec.set(0, 0);\\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\\n        }\\n\\n        #[test(should_fail_with = \\"Attempted to write past end of BoundedVec\\")]\\n        fn panics_when_writing_elements_past_end_of_vec() {\\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\\n            vec.set(0, 42);\\n\\n            // Need to use println to avoid DIE removing the write operation.\\n            crate::println(vec.get(0));\\n        }\\n    }\\n\\n    mod map {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn applies_function_correctly() {\\n            // docs:start:bounded-vec-map-example\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\\n            let result = vec.map(|value| value * 2);\\n            // docs:end:bounded-vec-map-example\\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\\n\\n            assert_eq(result, expected);\\n        }\\n\\n        #[test]\\n        fn applies_function_that_changes_return_type() {\\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\\n            let result = vec.map(|value| (value * 2)  as Field);\\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\\n\\n            assert_eq(result, expected);\\n        }\\n\\n        #[test]\\n        fn does_not_apply_function_past_len() {\\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\\n            let expected = BoundedVec::from_array([5, 1]);\\n\\n            assert_eq(result, expected);\\n            assert_eq(result.storage()[2], 0);\\n        }\\n    }\\n\\n    mod from_array {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn empty() {\\n            let empty_array: [Field; 0] = [];\\n            let bounded_vec = BoundedVec::from_array([]);\\n\\n            assert_eq(bounded_vec.max_len(), 0);\\n            assert_eq(bounded_vec.len(), 0);\\n            assert_eq(bounded_vec.storage(), empty_array);\\n        }\\n\\n        #[test]\\n        fn equal_len() {\\n            let array = [1, 2, 3];\\n            let bounded_vec = BoundedVec::from_array(array);\\n\\n            assert_eq(bounded_vec.max_len(), 3);\\n            assert_eq(bounded_vec.len(), 3);\\n            assert_eq(bounded_vec.storage(), array);\\n        }\\n\\n        #[test]\\n        fn max_len_greater_then_array_len() {\\n            let array = [1, 2, 3];\\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\\n\\n            assert_eq(bounded_vec.max_len(), 10);\\n            assert_eq(bounded_vec.len(), 3);\\n            assert_eq(bounded_vec.storage()[0], 1);\\n            assert_eq(bounded_vec.storage()[1], 2);\\n            assert_eq(bounded_vec.storage()[2], 3);\\n        }\\n\\n        #[test(should_fail_with=\\"from array out of bounds\\")]\\n        fn max_len_lower_then_array_len() {\\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\\n        }\\n    }\\n\\n    mod trait_from {\\n        use crate::collections::bounded_vec::BoundedVec;\\n\\n        #[test]\\n        fn simple() {\\n            let array = [1, 2];\\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\\n\\n            assert_eq(bounded_vec.max_len(), 10);\\n            assert_eq(bounded_vec.len(), 2);\\n            assert_eq(bounded_vec.storage()[0], 1);\\n            assert_eq(bounded_vec.storage()[1], 2);\\n        }\\n    }\\n}\\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\\nuse bn254::lt as bn254_lt;\\n\\nimpl Field {\\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\\n        crate::assert_constant(bit_size);\\n        self.__to_le_bits(bit_size)\\n    }\\n\\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\\n        crate::assert_constant(bit_size);\\n        self.__to_be_bits(bit_size)\\n    }\\n\\n    #[builtin(to_le_bits)]\\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\\n\\n    #[builtin(to_be_bits)]\\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\\n\\n    #[builtin(apply_range_constraint)]\\n    fn __assert_max_bit_size(self, bit_size: u32) {}\\n\\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\\n        crate::assert_constant(bit_size);\\n        assert(bit_size < modulus_num_bits() as u32);\\n        self.__assert_max_bit_size(bit_size);\\n    }\\n\\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\\n        self.to_le_radix(256, byte_size)\\n    }\\n\\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\\n        self.to_be_radix(256, byte_size)\\n    }\\n\\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\\n        crate::assert_constant(radix);\\n        crate::assert_constant(result_len);\\n        self.__to_le_radix(radix, result_len)\\n    }\\n\\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\\n        crate::assert_constant(radix);\\n        crate::assert_constant(result_len);\\n        self.__to_be_radix(radix, result_len)\\n    }\\n\\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\\n    // `_radix` must be less than 256\\n    #[builtin(to_le_radix)]\\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\\n\\n    #[builtin(to_be_radix)]\\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\\n\\n    // Returns self to the power of the given exponent value.\\n    // Caution: we assume the exponent fits into 32 bits\\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\\n    pub fn pow_32(self, exponent: Field) -> Field {\\n        let mut r: Field = 1;\\n        let b = exponent.to_le_bits(32);\\n\\n        for i in 1..33 {\\n            r *= r;\\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\\n        }\\n        r\\n    }\\n\\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\\n    pub fn sgn0(self) -> u1 {\\n        self as u1\\n    }\\n\\n    pub fn lt(self, another: Field) -> bool {\\n        if crate::compat::is_bn254() {\\n            bn254_lt(self, another)\\n        } else {\\n            lt_fallback(self, another)\\n        }\\n    }\\n}\\n\\n#[builtin(modulus_num_bits)]\\npub fn modulus_num_bits() -> u64 {}\\n\\n#[builtin(modulus_be_bits)]\\npub fn modulus_be_bits() -> [u1] {}\\n\\n#[builtin(modulus_le_bits)]\\npub fn modulus_le_bits() -> [u1] {}\\n\\n#[builtin(modulus_be_bytes)]\\npub fn modulus_be_bytes() -> [u8] {}\\n\\n#[builtin(modulus_le_bytes)]\\npub fn modulus_le_bytes() -> [u8] {}\\n// Convert a 32 byte array to a field element by modding\\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\\n    // Convert it to a field element\\n    let mut v = 1;\\n    let mut high = 0 as Field;\\n    let mut low = 0 as Field;\\n\\n    for i in 0..16 {\\n        high = high + (bytes32[15 - i] as Field) * v;\\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\\n        v = v * 256;\\n    }\\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\\n    low + high * v\\n}\\n\\nfn lt_fallback(x: Field, y: Field) -> bool {\\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\\n    let x_bytes = x.to_le_bytes(num_bytes);\\n    let y_bytes = y.to_le_bytes(num_bytes);\\n    let mut x_is_lt = false;\\n    let mut done = false;\\n    for i in 0..num_bytes {\\n        if (!done) {\\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\\n            let bytes_match = x_byte == y_byte;\\n            if !bytes_match {\\n                x_is_lt = x_byte < y_byte;\\n                done = true;\\n            }\\n        }\\n    }\\n    x_is_lt\\n}\\n\\n"},"56":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/entrypoint/app.nr","source":"use dep::aztec::prelude::PrivateContext;\\nuse dep::aztec::protocol_types::{constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD, hash::pedersen_hash, traits::{Hash, Serialize}};\\n\\nuse crate::entrypoint::function_call::{FunctionCall, FUNCTION_CALL_SIZE_IN_BYTES};\\n\\n// FUNCTION_CALL_SIZE * ACCOUNT_MAX_CALLS + 1\\nglobal APP_PAYLOAD_SIZE: u64 = 21;\\n// FUNCTION_CALL_SIZE_IN_BYTES * ACCOUNT_MAX_CALLS + 32\\nglobal APP_PAYLOAD_SIZE_IN_BYTES: u64 = 424;\\n\\nglobal ACCOUNT_MAX_CALLS: u64 = 4;\\n\\n// Note: If you change the following struct you have to update default_entrypoint.ts\\n// docs:start:app-payload-struct\\nstruct AppPayload {\\n  function_calls: [FunctionCall; ACCOUNT_MAX_CALLS],\\n  nonce: Field,\\n}\\n// docs:end:app-payload-struct\\n\\nimpl Serialize<APP_PAYLOAD_SIZE> for AppPayload {\\n  // Serializes the entrypoint struct\\n  fn serialize(self) -> [Field; APP_PAYLOAD_SIZE] {\\n    let mut fields: BoundedVec<Field, APP_PAYLOAD_SIZE> = BoundedVec::new();\\n    for call in self.function_calls {\\n      fields.extend_from_array(call.serialize());\\n    }\\n    fields.push(self.nonce);\\n    fields.storage\\n  }\\n}\\n\\nimpl Hash for AppPayload {\\n  fn hash(self) -> Field {\\n    pedersen_hash(\\n      self.serialize(),\\n      GENERATOR_INDEX__SIGNATURE_PAYLOAD\\n    )\\n  }\\n}\\n\\nimpl AppPayload {\\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\\n    fn to_be_bytes(self) -> [u8; APP_PAYLOAD_SIZE_IN_BYTES] {\\n        let mut bytes: BoundedVec<u8, APP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\\n\\n        for i in 0..ACCOUNT_MAX_CALLS {\\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\\n        }\\n        bytes.extend_from_slice(self.nonce.to_be_bytes(32));\\n\\n        bytes.storage\\n    }\\n\\n    // Executes all private and public calls\\n    // docs:start:entrypoint-execute-calls\\n    fn execute_calls(self, context: &mut PrivateContext) {\\n        for call in self.function_calls {\\n            if !call.target_address.is_zero() {\\n                if call.is_public {\\n                    context.call_public_function_with_packed_args(\\n                        call.target_address,\\n                        call.function_selector,\\n                        call.args_hash,\\n                        call.is_static,\\n                        false\\n                    );\\n                } else {\\n                    let _result = context.call_private_function_with_packed_args(\\n                        call.target_address,\\n                        call.function_selector,\\n                        call.args_hash,\\n                        call.is_static,\\n                        false\\n                    );\\n                }\\n            }\\n        }\\n    }\\n    // docs:end:entrypoint-execute-calls\\n}\\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\\n    oracle::{\\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\\n    call_private_function::call_private_function_internal, header::get_header_at,\\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\\n    enqueue_public_function_call::{\\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\\n    parse_public_call_stack_item_from_oracle\\n}\\n}\\n};\\nuse dep::protocol_types::{\\n    abis::{\\n    caller_context::CallerContext, function_selector::FunctionSelector,\\n    max_block_number::MaxBlockNumber,\\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\\n},\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\\n},\\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\\n};\\n\\n// When finished, one can call .finish() to convert back to the abi\\nstruct PrivateContext {\\n    // docs:start:private-context\\n    inputs: PrivateContextInputs,\\n    side_effect_counter: u32,\\n\\n    min_revertible_side_effect_counter: u32,\\n    is_fee_payer: bool,\\n\\n    args_hash: Field,\\n    return_hash: Field,\\n\\n    max_block_number: MaxBlockNumber,\\n\\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\\n\\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\\n\\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\\n    public_teardown_function_hash: Field,\\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\\n    // docs:end:private-context\\n\\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\\n    historical_header: Header,\\n\\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\\n\\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\\n    // fetching the same request multiple times.\\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\\n}\\n\\nimpl PrivateContext {\\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\\n        PrivateContext {\\n            inputs,\\n            side_effect_counter: inputs.start_side_effect_counter + 1,\\n            min_revertible_side_effect_counter: 0,\\n            is_fee_payer: false,\\n            args_hash,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            historical_header: inputs.historical_header,\\n            private_call_requests: BoundedVec::new(),\\n            public_call_stack_hashes: BoundedVec::new(),\\n            public_teardown_function_hash: 0,\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            note_encrypted_logs_hashes: BoundedVec::new(),\\n            encrypted_logs_hashes: BoundedVec::new(),\\n            unencrypted_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\\n        }\\n    }\\n\\n    fn msg_sender(self) -> AztecAddress {\\n        self.inputs.call_context.msg_sender\\n    }\\n\\n    fn this_address(self) -> AztecAddress {\\n        self.inputs.call_context.storage_contract_address\\n    }\\n\\n    fn chain_id(self) -> Field {\\n        self.inputs.tx_context.chain_id\\n    }\\n\\n    fn version(self) -> Field {\\n        self.inputs.tx_context.version\\n    }\\n\\n    fn selector(self) -> FunctionSelector {\\n        self.inputs.call_context.function_selector\\n    }\\n\\n    fn get_args_hash(self) -> Field {\\n        self.args_hash\\n    }\\n\\n    fn push_note_hash(&mut self, note_hash: Field) {\\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\\n    }\\n\\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\\n    // - consider creating a separate function with 1 arg for the zero note hash case.\\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\\n    }\\n\\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\\n    // included in).\\n    fn get_header(self) -> Header {\\n        self.historical_header\\n    }\\n\\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\\n    // of historical header.\\n    pub fn get_header_at(self, block_number: u32) -> Header {\\n        get_header_at(block_number, self)\\n    }\\n\\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\\n        pack_returns(returns_hasher.fields);\\n        self.return_hash = returns_hasher.hash();\\n    }\\n\\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\\n        PrivateCircuitPublicInputs {\\n            call_context: self.inputs.call_context,\\n            args_hash: self.args_hash,\\n            returns_hash: self.return_hash,\\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\\n            is_fee_payer: self.is_fee_payer,\\n            max_block_number: self.max_block_number,\\n            note_hash_read_requests: self.note_hash_read_requests.storage,\\n            nullifier_read_requests: self.nullifier_read_requests.storage,\\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\\n            note_hashes: self.note_hashes.storage,\\n            nullifiers: self.nullifiers.storage,\\n            private_call_requests: self.private_call_requests.storage,\\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\\n            public_teardown_function_hash: self.public_teardown_function_hash,\\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\\n            end_side_effect_counter: self.side_effect_counter,\\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\\n            historical_header: self.historical_header,\\n            tx_context: self.inputs.tx_context\\n        }\\n    }\\n\\n    pub fn set_as_fee_payer(&mut self) {\\n        dep::protocol_types::debug_log::debug_log_format(\\"Setting {0} as fee payer\\", [self.this_address().to_field()]);\\n        self.is_fee_payer = true;\\n    }\\n\\n    pub fn end_setup(&mut self) {\\n        // dep::protocol_types::debug_log::debug_log_format(\\n        //     \\"Ending setup at counter {0}\\",\\n        //     [self.side_effect_counter as Field]\\n        // );\\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\\n    }\\n\\n    // docs:start:max-block-number\\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\\n        // docs:end:max-block-number\\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\\n    }\\n\\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\\n        self.note_hash_read_requests.push(side_effect);\\n    }\\n\\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\\n        self.nullifier_read_requests.push(request);\\n    }\\n\\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\\n    }\\n\\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\\n    }\\n\\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\\n\\n        if cached_request.pk_m.hash() == pk_m_hash {\\n            // We get a match so the cached request is the latest one \\n            cached_request.sk_app\\n        } else {\\n            // We didn\'t get a match meaning the cached result is stale. We fetch new values from oracle and instruct\\n            // protocol circuits to validate them by storing the validation request in context.\\n            let request = get_key_validation_request(pk_m_hash, key_index);\\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\\n            // valid key request and not the one corresponding to pk_m_hash).\\n            assert(request.pk_m.hash() == pk_m_hash);\\n            self.key_validation_requests_and_generators.push(request_and_generator);\\n            self.last_key_validation_requests[key_index] = Option::some(request);\\n            request.sk_app\\n        }\\n    }\\n\\n    // docs:start:context_message_portal\\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\\n        // docs:end:context_message_portal\\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\\n        self.l2_to_l1_msgs.push(message);\\n    }\\n\\n    // docs:start:context_consume_l1_to_l2_message\\n    // docs:start:consume_l1_to_l2_message\\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\\n        // docs:end:context_consume_l1_to_l2_message\\n        let nullifier = process_l1_to_l2_message(\\n            self.historical_header.state.l1_to_l2_message_tree.root,\\n            self.this_address(),\\n            sender,\\n            self.chain_id(),\\n            self.version(),\\n            content,\\n            secret\\n        );\\n\\n        // Push nullifier (and the \\"commitment\\" corresponding to this can be \\"empty\\")\\n        self.push_nullifier(nullifier, 0)\\n    }\\n    // docs:end:consume_l1_to_l2_message\\n\\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\\n    // used in siloing later on e.g. \'handshaking\' contract w/ known address.\\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\\n        let counter = self.next_counter();\\n        let contract_address = self.this_address();\\n        let len = log.len() as Field + 4;\\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\\n        self.encrypted_logs_hashes.push(side_effect);\\n\\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\\n    }\\n\\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\\n        let counter = self.next_counter();\\n        let len = log.len() as Field + 4;\\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\\n        self.note_encrypted_logs_hashes.push(side_effect);\\n\\n        emit_encrypted_note_log(note_hash_counter, log, counter);\\n    }\\n\\n    pub fn call_private_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) -> PackedReturns {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\\n    }\\n\\n    pub fn static_call_private_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) -> PackedReturns {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\\n    }\\n\\n    pub fn delegate_call_private_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) -> PackedReturns {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\\n    }\\n\\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) -> PackedReturns {\\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\\n    }\\n\\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) -> PackedReturns {\\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\\n    }\\n\\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) -> PackedReturns {\\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\\n    }\\n\\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n        is_delegate_call: bool\\n    ) -> PackedReturns {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let start_side_effect_counter = self.side_effect_counter;\\n        let item = call_private_function_internal(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            start_side_effect_counter,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\\n        self.side_effect_counter = end_side_effect_counter + 1;\\n\\n        // TODO (fees) figure out why this crashes the prover and enable it\\n        // we need this in order to pay fees inside child call contexts\\n        // assert(\\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\\n        //     | (item.public_inputs.min_revertible_side_effect_counter\\n        //         > self.min_revertible_side_effect_counter)\\n        // );\\n\\n        // if item.public_inputs.min_revertible_side_effect_counter\\n        //     > self.min_revertible_side_effect_counter {\\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\\n        // }\\n\\n        assert(contract_address.eq(item.contract_address));\\n        assert(function_selector.eq(item.function_data.selector));\\n\\n        assert(args_hash == item.public_inputs.args_hash);\\n\\n        // Assert that the call context of the call generated by the oracle matches our request.\\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\\n\\n        if (is_delegate_call) {\\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\\n            assert(\\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\\n            );\\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\\n        } else {\\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\\n            assert(\\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\\n            );\\n        }\\n\\n        let mut caller_context = CallerContext::empty();\\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\\n        if is_delegate_call {\\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\\n        }\\n        self.private_call_requests.push(\\n            PrivateCallRequest {\\n            target: item.contract_address,\\n            call_context: item.public_inputs.call_context,\\n            function_data: item.function_data,\\n            args_hash: item.public_inputs.args_hash,\\n            returns_hash: item.public_inputs.returns_hash,\\n            caller_context,\\n            start_side_effect_counter,\\n            end_side_effect_counter\\n        }\\n        );\\n\\n        PackedReturns::new(item.public_inputs.returns_hash)\\n    }\\n\\n    pub fn call_public_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\\n    }\\n\\n    pub fn static_call_public_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\\n    }\\n\\n    pub fn delegate_call_public_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\\n    }\\n\\n    pub fn call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) {\\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\\n    }\\n\\n    pub fn static_call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) {\\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\\n    }\\n\\n    pub fn delegate_call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) {\\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\\n    }\\n\\n    pub fn call_public_function_with_packed_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n        is_delegate_call: bool\\n    ) {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let fields = enqueue_public_function_call_internal(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            self.side_effect_counter,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        let item = parse_public_call_stack_item_from_oracle(fields);\\n        self.validate_call_stack_item_from_oracle(\\n            item,\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        self.side_effect_counter = self.side_effect_counter + 1;\\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\\n    }\\n\\n    pub fn set_public_teardown_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\\n    }\\n\\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n        is_delegate_call: bool\\n    ) {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let fields = set_public_teardown_function_call_internal(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            self.side_effect_counter,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        let item = parse_public_call_stack_item_from_oracle(fields);\\n        self.validate_call_stack_item_from_oracle(\\n            item,\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        self.side_effect_counter = self.side_effect_counter + 1;\\n        self.public_teardown_function_hash = item.get_compressed().hash();\\n    }\\n\\n    fn validate_call_stack_item_from_oracle(\\n        self,\\n        item: PublicCallStackItem,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n        is_delegate_call: bool\\n    ) {\\n        assert(contract_address.eq(item.contract_address));\\n        assert(function_selector.eq(item.function_data.selector));\\n\\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\\n\\n        assert(args_hash == item.public_inputs.args_hash);\\n\\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\\n\\n        if (is_delegate_call) {\\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\\n            assert(\\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\\n            );\\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\\n        } else {\\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\\n            assert(\\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\\n            );\\n        }\\n    }\\n\\n    fn next_counter(&mut self) -> u32 {\\n        let counter = self.side_effect_counter;\\n        self.side_effect_counter += 1;\\n        counter\\n    }\\n}\\n\\nimpl Empty for PrivateContext {\\n    fn empty() -> Self {\\n        PrivateContext {\\n            inputs: PrivateContextInputs::empty(),\\n            side_effect_counter: 0 as u32,\\n            min_revertible_side_effect_counter: 0 as u32,\\n            is_fee_payer: false,\\n            args_hash: 0,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            private_call_requests: BoundedVec::new(),\\n            public_call_stack_hashes: BoundedVec::new(),\\n            public_teardown_function_hash: 0,\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            historical_header: Header::empty(),\\n            note_encrypted_logs_hashes: BoundedVec::new(),\\n            encrypted_logs_hashes: BoundedVec::new(),\\n            unencrypted_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\\n        }\\n    }\\n}\\n"},"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\\n},\\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\\n};\\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\\n\\npub fn compute_secret_hash(secret: Field) -> Field {\\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\\n}\\n\\npub fn compute_unencrypted_log_hash<T, N, M>(\\n    contract_address: AztecAddress,\\n    log: T\\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\\n    // can\'t use N - not in scope error\\n    let n = message_bytes.len();\\n    let mut hash_bytes = [0; M];\\n    // Address is converted to 32 bytes in ts\\n    let address_bytes = contract_address.to_be_bytes_arr();\\n    for i in 0..32 {\\n        hash_bytes[i] = address_bytes[i];\\n    }\\n    let len_bytes = (n as Field).to_be_bytes(4);\\n    for i in 0..4 {\\n        hash_bytes[32 + i] = len_bytes[i];\\n    }\\n    for i in 0..n {\\n        hash_bytes[36 + i] = message_bytes[i];\\n    }\\n\\n    sha256_to_field(hash_bytes)\\n}\\n\\npub fn compute_message_hash(\\n    sender: EthAddress,\\n    chain_id: Field,\\n    recipient: AztecAddress,\\n    version: Field,\\n    content: Field,\\n    secret_hash: Field\\n) -> Field {\\n    let mut hash_bytes = [0 as u8; 192];\\n    let sender_bytes = sender.to_field().to_be_bytes(32);\\n    let chain_id_bytes = chain_id.to_be_bytes(32);\\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\\n    let version_bytes = version.to_be_bytes(32);\\n    let content_bytes = content.to_be_bytes(32);\\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\\n\\n    for i in 0..32 {\\n        hash_bytes[i] = sender_bytes[i];\\n        hash_bytes[i + 32] = chain_id_bytes[i];\\n        hash_bytes[i + 64] = recipient_bytes[i];\\n        hash_bytes[i + 96] = version_bytes[i];\\n        hash_bytes[i + 128] = content_bytes[i];\\n        hash_bytes[i + 160] = secret_hash_bytes[i];\\n    }\\n\\n    sha256_to_field(hash_bytes)\\n}\\n\\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\\n// in the L1 to L2 message tree\\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\\n    pedersen_hash(\\n        [message_hash, secret, leaf_index],\\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\\n    )\\n}\\n\\nstruct ArgsHasher {\\n    fields: [Field],\\n}\\n\\nimpl Hash for ArgsHasher {\\n    fn hash(self) -> Field {\\n        hash_args(self.fields)\\n    }\\n}\\n\\nimpl ArgsHasher {\\n    pub fn new() -> Self {\\n        Self { fields: [] }\\n    }\\n\\n    pub fn add(&mut self, field: Field) {\\n        self.fields = self.fields.push_back(field);\\n    }\\n\\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\\n        for i in 0..N {\\n            self.fields = self.fields.push_back(fields[i]);\\n        }\\n    }\\n}\\n\\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\\n    hash_args(args.as_slice())\\n}\\n\\npub fn hash_args(args: [Field]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        assert(args.len() <= MAX_ARGS_LENGTH, \\"Args length exceeds maximum\\");\\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\\n\\n        let mut current_chunk_index = 0;\\n        let mut index_inside_current_chunk = 0;\\n        for i in 0..args.len() {\\n            current_chunk_values[index_inside_current_chunk] = args[i];\\n            index_inside_current_chunk+=1;\\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\\n                current_chunk_index+=1;\\n                index_inside_current_chunk = 0;\\n            }\\n        }\\n        if index_inside_current_chunk > 0 {\\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\\n        }\\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\n#[test]\\nfn compute_var_args_hash() {\\n    let mut input = ArgsHasher::new();\\n    for i in 0..MAX_ARGS_LENGTH {\\n        input.add(i as Field);\\n    }\\n    let hash = input.hash();\\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\\n}\\n\\n#[test]\\nfn compute_unenc_log_hash_array() {\\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\\n    let log = [\\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\\n    ];\\n    let hash = compute_unencrypted_log_hash(contract_address, log);\\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\\n}\\n\\n#[test]\\nfn compute_unenc_log_hash_addr() {\\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\\n    let hash = compute_unencrypted_log_hash(contract_address, log);\\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\\n}\\n\\n#[test]\\nfn compute_unenc_log_hash_str() {\\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\\n    let log = \\"dummy\\";\\n    let hash = compute_unencrypted_log_hash(contract_address, log);\\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\\n}\\n\\n#[test]\\nfn compute_unenc_log_hash_longer_str() {\\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\\n    let log = \\"Hello this is a string\\";\\n    let hash = compute_unencrypted_log_hash(contract_address, log);\\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\\n}\\n"},"135":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\\n};\\n\\n#[oracle(callPrivateFunction)]\\nunconstrained fn call_private_function_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _start_side_effect_counter: u32,\\n    _is_static_call: bool,\\n    _is_delegate_call: bool\\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\\n\\nunconstrained pub fn call_private_function_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    start_side_effect_counter: u32,\\n    is_static_call: bool,\\n    is_delegate_call: bool\\n) -> PrivateCallStackItem {\\n    let fields = call_private_function_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        start_side_effect_counter,\\n        is_static_call,\\n        is_delegate_call\\n    );\\n\\n    PrivateCallStackItem::deserialize(fields)\\n}\\n"},"140":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{\\n    abis::{\\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\\n},\\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\\n    utils::reader::Reader,\\n    constants::{\\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\\n}\\n};\\n\\n#[oracle(enqueuePublicFunctionCall)]\\nunconstrained fn enqueue_public_function_call_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _side_effect_counter: u32,\\n    _is_static_call: bool,\\n    _is_delegate_call: bool\\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\\n\\nunconstrained pub fn enqueue_public_function_call_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    side_effect_counter: u32,\\n    is_static_call: bool,\\n    is_delegate_call: bool\\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\\n    enqueue_public_function_call_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        side_effect_counter,\\n        is_static_call,\\n        is_delegate_call\\n    )\\n}\\n\\n#[oracle(setPublicTeardownFunctionCall)]\\nunconstrained fn set_public_teardown_function_call_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _side_effect_counter: u32,\\n    _is_static_call: bool,\\n    _is_delegate_call: bool\\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\\n\\nunconstrained pub fn set_public_teardown_function_call_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    side_effect_counter: u32,\\n    is_static_call: bool,\\n    is_delegate_call: bool\\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\\n    set_public_teardown_function_call_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        side_effect_counter,\\n        is_static_call,\\n        is_delegate_call\\n    )\\n}\\n\\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\\n    let mut reader = Reader::new(fields);\\n\\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\\n    // WARNING: if updating, see comment in public_call_stack_item.ts\'s PublicCallStackItem.hash()\\n    let item = PublicCallStackItem {\\n        contract_address: AztecAddress::from_field(reader.read()),\\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\\n        public_inputs: PublicCircuitPublicInputs {\\n            call_context: reader.read_struct(CallContext::deserialize),\\n            start_side_effect_counter: reader.read_u32(),\\n            args_hash: reader.read(),\\n            returns_hash: 0,\\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\\n            end_side_effect_counter: 0,\\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\\n            historical_header: Header::empty(),\\n            global_variables: GlobalVariables::empty(),\\n            prover_address: AztecAddress::zero(),\\n            revert_code: 0,\\n            start_gas_left: Gas::empty(),\\n            end_gas_left: Gas::empty(),\\n            transaction_fee: 0\\n        },\\n        is_execution_request: true\\n    };\\n    reader.finish();\\n\\n    item\\n}\\n"},"167":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr","source":"use crate::{\\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\\n    constants::{GAS_LENGTH, FIXED_DA_GAS, FIXED_L2_GAS}, hash::pedersen_hash,\\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\\n    abis::gas_fees::GasFees\\n};\\nuse std::ops::{Add, Sub};\\n\\nstruct Gas {\\n    da_gas: u32,\\n    l2_gas: u32,\\n}\\n\\nimpl Gas {\\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\\n        Self { da_gas, l2_gas }\\n    }\\n\\n    pub fn tx_overhead() -> Self {\\n        Self { da_gas: FIXED_DA_GAS, l2_gas: FIXED_L2_GAS }\\n    }\\n\\n    pub fn compute_fee(self, fees: GasFees) -> Field {\\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\\n    }\\n\\n    pub fn is_empty(self) -> bool {\\n        (self.da_gas == 0) & (self.l2_gas == 0)\\n    }\\n\\n    pub fn within(self, limits: Gas) -> bool {\\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\\n    }\\n}\\n\\nimpl Add for Gas {\\n    fn add(self, other: Gas) -> Self {\\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\\n    }\\n}\\n\\nimpl Sub for Gas {\\n    fn sub(self, other: Gas) -> Self {\\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\\n    }\\n}\\n\\nimpl Serialize<GAS_LENGTH> for Gas {\\n    fn serialize(self) -> [Field; GAS_LENGTH] {\\n        [self.da_gas as Field, self.l2_gas as Field]\\n    }\\n}\\n\\nimpl Deserialize<GAS_LENGTH> for Gas {\\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\\n    }\\n}\\n\\nimpl Eq for Gas {\\n    fn eq(self, other : Gas) -> bool {\\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\\n    }\\n}\\n\\nimpl Empty for Gas {\\n    fn empty() -> Self {\\n        Gas::new(0, 0)\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = Gas::empty();\\n    let serialized = item.serialize();\\n    let deserialized = Gas::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n\\n"},"169":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr","source":"use crate::{\\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\\n    utils::{arrays::array_concat, reader::Reader}\\n};\\n\\nstruct NoteHash {\\n    value: Field,\\n    counter: u32,\\n}\\n\\nimpl Ordered for NoteHash {\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl Eq for NoteHash {\\n    fn eq(self, other: NoteHash) -> bool {\\n        (self.value == other.value)\\n            & (self.counter == other.counter) \\n    }\\n}\\n\\nimpl Empty for NoteHash {\\n    fn empty() -> Self {\\n        NoteHash {\\n            value: 0,\\n            counter: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\\n        [self.value, self.counter as Field]\\n    }\\n}\\n\\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\\n        Self {\\n            value: values[0],\\n            counter: values[1] as u32,\\n        }\\n    }\\n}\\n\\nimpl NoteHash {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNoteHash {\\n        ScopedNoteHash { note_hash: self, contract_address }\\n    }\\n}\\n\\nstruct ScopedNoteHash {\\n    note_hash: NoteHash,\\n    contract_address: AztecAddress,\\n}\\n\\nimpl Scoped<NoteHash> for ScopedNoteHash {\\n    fn inner(self) -> NoteHash {\\n        self.note_hash\\n    }\\n    fn contract_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n}\\n\\nimpl Ordered for ScopedNoteHash {\\n    fn counter(self) -> u32 {\\n        self.note_hash.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for ScopedNoteHash {\\n    fn value(self) -> Field {\\n        self.note_hash.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.note_hash.counter\\n    }\\n}\\n\\nimpl Eq for ScopedNoteHash {\\n    fn eq(self, other: ScopedNoteHash) -> bool {\\n        (self.note_hash == other.note_hash)\\n            & (self.contract_address == other.contract_address)\\n    }\\n}\\n\\nimpl Empty for ScopedNoteHash {\\n    fn empty() -> Self {\\n        ScopedNoteHash {\\n            note_hash: NoteHash::empty(),\\n            contract_address: AztecAddress::zero(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\\n        array_concat(self.note_hash.serialize(), [self.contract_address.to_field()])\\n    }\\n}\\n\\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\\n        let mut reader = Reader::new(values);\\n        let res = Self {\\n            note_hash: reader.read_struct(NoteHash::deserialize),\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n        };\\n        reader.finish();\\n        res\\n    }\\n}\\n\\nimpl Readable for ScopedNoteHash {\\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\\n        assert_eq(self.note_hash.value, read_request.value(), \\"Value of the note hash does not match read request\\");\\n        assert_eq(self.contract_address, read_request.contract_address, \\"Contract address of the note hash does not match read request\\");\\n        assert(\\n            read_request.counter() > self.note_hash.counter, \\"Read request counter must be greater than the counter of the note hash\\"\\n        );\\n    }\\n}\\n\\nimpl ScopedNoteHash {\\n    pub fn expose_to_public(self) -> NoteHash {\\n        // Hide the actual counter when exposing it to the public kernel.\\n        NoteHash { value: self.note_hash.value, counter: 0 }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = NoteHash::empty();\\n    let serialized = item.serialize();\\n    let deserialized = NoteHash::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n\\n#[test]\\nfn serialization_of_empty_scoped() {\\n    let item = ScopedNoteHash::empty();\\n    let serialized = item.serialize();\\n    let deserialized = ScopedNoteHash::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"170":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr","source":"use crate::{\\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\\n    abis::side_effect::Ordered, utils::reader::Reader\\n};\\n\\nstruct GasFees {\\n    fee_per_da_gas: Field,\\n    fee_per_l2_gas: Field,\\n}\\n\\nimpl GasFees {\\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\\n        Self { fee_per_da_gas, fee_per_l2_gas }\\n    }\\n\\n    pub fn default() -> Self {\\n        GasFees::new(1, 1)\\n    }\\n\\n    pub fn is_empty(self) -> bool {\\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\\n    }\\n}\\n\\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\\n    }\\n}\\n\\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\\n        GasFees::new(serialized[0], serialized[1])\\n    }\\n}\\n\\nimpl Eq for GasFees {\\n    fn eq(self, other : GasFees) -> bool {\\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\\n    }\\n}\\n\\nimpl Empty for GasFees {\\n    fn empty() -> Self {\\n        GasFees::new(0, 0)\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = GasFees::empty();\\n    let serialized = item.serialize();\\n    let deserialized = GasFees::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"172":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr","source":"use crate::{\\n    abis::{\\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\\n},\\n    constants::{\\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL, MAX_NULLIFIERS_PER_CALL,\\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\\n    MAX_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\\n},\\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\\n    transaction::tx_context::TxContext, utils::arrays::validate_array\\n};\\n\\nstruct PrivateCircuitPublicInputsArrayLengths {\\n    note_hash_read_requests: u32,\\n    nullifier_read_requests: u32,\\n    key_validation_requests_and_generators: u32,\\n    note_hashes: u32,\\n    nullifiers: u32,\\n    l2_to_l1_msgs: u32,\\n    private_call_requests: u32,\\n    public_call_stack_hashes: u32,\\n    note_encrypted_logs_hashes: u32,\\n    encrypted_logs_hashes: u32,\\n    unencrypted_logs_hashes: u32,\\n}\\n\\nimpl PrivateCircuitPublicInputsArrayLengths {\\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\\n        PrivateCircuitPublicInputsArrayLengths {\\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\\n            note_hashes: validate_array(public_inputs.note_hashes),\\n            nullifiers: validate_array(public_inputs.nullifiers),\\n            l2_to_l1_msgs: validate_array(public_inputs.l2_to_l1_msgs),\\n            private_call_requests: validate_array(public_inputs.private_call_requests),\\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\\n        }\\n    }\\n}\\n\\nstruct PrivateCircuitPublicInputs {\\n    call_context: CallContext,\\n\\n    args_hash: Field,\\n    returns_hash: Field,\\n\\n    min_revertible_side_effect_counter: u32,\\n    is_fee_payer: bool,\\n\\n    max_block_number: MaxBlockNumber,\\n\\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\\n\\n    note_hashes: [NoteHash; MAX_NOTE_HASHES_PER_CALL],\\n    nullifiers: [Nullifier; MAX_NULLIFIERS_PER_CALL],\\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\\n    public_teardown_function_hash: Field,\\n    l2_to_l1_msgs: [L2ToL1Message; MAX_L2_TO_L1_MSGS_PER_CALL],\\n\\n    start_side_effect_counter : u32,\\n    end_side_effect_counter : u32,\\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\\n\\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\\n    historical_header: Header,\\n\\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\\n    tx_context: TxContext,\\n}\\n\\nimpl Eq for PrivateCircuitPublicInputs {\\n    fn eq(self, other: Self) -> bool {\\n        self.call_context.eq(other.call_context) &\\n        self.args_hash.eq(other.args_hash) &\\n        (self.returns_hash == other.returns_hash) &\\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\\n        (self.is_fee_payer == other.is_fee_payer) &\\n        (self.max_block_number == other.max_block_number) &\\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\\n        (self.note_hashes == other.note_hashes) &\\n        (self.nullifiers == other.nullifiers) &\\n        (self.private_call_requests == other.private_call_requests) &\\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\\n        (self.l2_to_l1_msgs == other.l2_to_l1_msgs) &\\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\\n        self.historical_header.eq(other.historical_header) &\\n        self.tx_context.eq(other.tx_context)\\n    }\\n}\\n\\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\\n        fields.extend_from_array(self.call_context.serialize());\\n        fields.push(self.args_hash);\\n        fields.push(self.returns_hash);\\n\\n        fields.push(self.min_revertible_side_effect_counter as Field);\\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\\n\\n        fields.extend_from_array(self.max_block_number.serialize());\\n\\n        for i in 0..self.note_hash_read_requests.len() {\\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\\n        }\\n        for i in 0..self.nullifier_read_requests.len() {\\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\\n        }\\n        for i in 0..self.key_validation_requests_and_generators.len() {\\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\\n        }\\n        for i in 0..self.note_hashes.len() {\\n            fields.extend_from_array(self.note_hashes[i].serialize());\\n        }\\n        for i in 0..self.nullifiers.len() {\\n            fields.extend_from_array(self.nullifiers[i].serialize());\\n        }\\n        for i in 0..self.private_call_requests.len() {\\n            fields.extend_from_array(self.private_call_requests[i].serialize());\\n        }\\n        fields.extend_from_array(self.public_call_stack_hashes);\\n        fields.push(self.public_teardown_function_hash);\\n        for i in 0..self.l2_to_l1_msgs.len() {\\n            fields.extend_from_array(self.l2_to_l1_msgs[i].serialize());\\n        }\\n        fields.push(self.start_side_effect_counter as Field);\\n        fields.push(self.end_side_effect_counter as Field);\\n        for i in 0..self.note_encrypted_logs_hashes.len() {\\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\\n        }\\n        for i in 0..self.encrypted_logs_hashes.len() {\\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\\n        }\\n        for i in 0..self.unencrypted_logs_hashes.len() {\\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\\n        }\\n        fields.extend_from_array(self.historical_header.serialize());\\n        fields.extend_from_array(self.tx_context.serialize());\\n\\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\\n        let mut reader = Reader::new(serialized);\\n        let inputs = Self {\\n            call_context: reader.read_struct(CallContext::deserialize),\\n            args_hash: reader.read(),\\n            returns_hash: reader.read(),\\n            min_revertible_side_effect_counter: reader.read() as u32,\\n            is_fee_payer: reader.read() == 1,\\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\\n            note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL]),\\n            nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL]),\\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\\n            public_teardown_function_hash: reader.read(),\\n            l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL]),\\n            start_side_effect_counter: reader.read() as u32,\\n            end_side_effect_counter: reader.read() as u32,\\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\\n            historical_header: reader.read_struct(Header::deserialize),\\n            tx_context: reader.read_struct(TxContext::deserialize),\\n        };\\n\\n        reader.finish();\\n        inputs\\n    }\\n}\\n\\nimpl Hash for PrivateCircuitPublicInputs {\\n    fn hash(self) -> Field {\\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\\n    }\\n}\\n\\nimpl Empty for PrivateCircuitPublicInputs {\\n    fn empty() -> Self {\\n        PrivateCircuitPublicInputs {\\n            call_context: CallContext::empty(),\\n            args_hash: 0,\\n            returns_hash: 0,\\n            min_revertible_side_effect_counter: 0 as u32,\\n            is_fee_payer: false,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\\n            public_teardown_function_hash: 0,\\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\\n            start_side_effect_counter : 0 as u32,\\n            end_side_effect_counter : 0 as u32,\\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\\n            historical_header: Header::empty(),\\n            tx_context: TxContext::empty(),\\n        }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let pcpi = PrivateCircuitPublicInputs::empty();\\n    let serialized = pcpi.serialize();\\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\\n    assert(pcpi.eq(deserialized));\\n}\\n\\n#[test]\\nfn empty_hash() {\\n    let inputs = PrivateCircuitPublicInputs::empty();\\n    let hash = inputs.hash();\\n    // Value from private_circuit_public_inputs.test.ts \\"computes empty item hash\\" test\\n    let test_data_empty_hash = 0x15c9b0a92b9b541598e24c9f0b0b4b04b7f2408599751c45aa12de671fd9b363;\\n    assert_eq(hash, test_data_empty_hash);\\n}\\n"},"173":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item_compressed.nr","source":"use crate::abis::{call_context::CallContext, function_data::FunctionData, gas::Gas};\\nuse crate::address::AztecAddress;\\nuse crate::constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH};\\nuse crate::traits::{Hash, Empty, Serialize, Deserialize};\\nuse crate::utils::reader::Reader;\\n\\n/**\\n * A compressed version of the PublicCallStackItem struct used to compute the \\"hash\\"\\n * of a PublicCallStackItem.\\n * \\n * Historically, we have been zeroing most values in the PublicCallStackItem struct\\n * to compute the hash involved when adding a PublicCallStackItem to the PublicCallStack.\\n * \\n * This struct is used to store the values that we did not zero out, and allow us to hash\\n * only these, thereby skipping a lot of computation and saving us a lot of constraints\\n * \\n * Essentially this struct exists such that we don\'t have a `hash` function in the \\n * PublicCallStackItem struct that practically throws away some values of the struct\\n * without clearly indicating that it does so.\\n */\\nstruct PublicCallStackItemCompressed {\\n    contract_address: AztecAddress,\\n    call_context: CallContext,\\n    function_data: FunctionData,\\n    args_hash: Field,\\n    returns_hash: Field,\\n    revert_code: u8,\\n    start_gas_left: Gas,\\n    end_gas_left: Gas,\\n}\\n\\nimpl Eq for PublicCallStackItemCompressed {\\n    fn eq(self, other: PublicCallStackItemCompressed) -> bool {\\n        (self.contract_address == other.contract_address)\\n            & (self.call_context == other.call_context)\\n            & (self.function_data == other.function_data)\\n            & (self.args_hash == other.args_hash)\\n            & (self.returns_hash == other.returns_hash)\\n            & (self.revert_code == other.revert_code)\\n            & (self.start_gas_left == other.start_gas_left)\\n            & (self.end_gas_left == other.end_gas_left)\\n    }\\n}\\n\\nimpl Hash for PublicCallStackItemCompressed {\\n    fn hash(self) -> Field {\\n        std::hash::pedersen_hash_with_separator(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\\n    }\\n}\\n\\nimpl Empty for PublicCallStackItemCompressed {\\n    fn empty() -> Self {\\n        PublicCallStackItemCompressed {\\n            contract_address: AztecAddress::empty(),\\n            call_context: CallContext::empty(),\\n            function_data: FunctionData::empty(),\\n            args_hash: 0,\\n            returns_hash: 0,\\n            revert_code: 0,\\n            start_gas_left: Gas::empty(),\\n            end_gas_left: Gas::empty(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\\n    fn serialize(self) -> [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH] {\\n        let mut fields: BoundedVec<Field, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> = BoundedVec::new();\\n\\n        fields.push(self.contract_address.to_field());\\n        fields.extend_from_array(self.call_context.serialize());\\n        fields.extend_from_array(self.function_data.serialize());\\n        fields.push(self.args_hash);\\n        fields.push(self.returns_hash);\\n        fields.push(self.revert_code as Field);\\n        fields.extend_from_array(self.start_gas_left.serialize());\\n        fields.extend_from_array(self.end_gas_left.serialize());\\n\\n        assert_eq(fields.len(), PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH);\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\\n  fn deserialize(fields: [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH]) -> PublicCallStackItemCompressed {\\n    let mut reader = Reader::new(fields);\\n\\n    let item = PublicCallStackItemCompressed {\\n      contract_address: reader.read_struct(AztecAddress::deserialize),\\n      call_context: reader.read_struct(CallContext::deserialize),\\n      function_data: reader.read_struct(FunctionData::deserialize),\\n      args_hash: reader.read(),\\n      returns_hash: reader.read(),\\n      revert_code: reader.read() as u8,\\n      start_gas_left: reader.read_struct(Gas::deserialize),\\n      end_gas_left: reader.read_struct(Gas::deserialize),\\n    };\\n    reader.finish();\\n    item\\n  }\\n}\\n"},"175":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr","source":"use crate::{\\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\\n};\\n\\n// docs:start:global-variables\\nstruct GlobalVariables {\\n    chain_id : Field,\\n    version : Field,\\n    block_number : Field,\\n    timestamp : u64,\\n    coinbase : EthAddress,\\n    fee_recipient : AztecAddress,\\n    gas_fees : GasFees\\n}\\n// docs:end:global-variables\\n\\nimpl GlobalVariables {\\n    fn is_empty(self) -> bool {\\n        (self.chain_id == 0)\\n            & (self.version == 0)\\n            & (self.block_number == 0)\\n            & (self.timestamp == 0)\\n            & (self.coinbase.is_zero())\\n            & (self.fee_recipient.is_zero())\\n            & (self.gas_fees.is_empty())\\n    }\\n}\\n\\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\\n\\n        serialized.push(self.chain_id);\\n        serialized.push(self.version);\\n        serialized.push(self.block_number);\\n        serialized.push(self.timestamp as Field);\\n        serialized.push(self.coinbase.to_field());\\n        serialized.push(self.fee_recipient.to_field());\\n        serialized.extend_from_array(self.gas_fees.serialize());\\n\\n        serialized.storage\\n    }\\n}\\n\\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\\n        let mut reader = Reader::new(serialized);\\n        GlobalVariables {\\n            chain_id: reader.read(),\\n            version: reader.read(),\\n            block_number: reader.read(),\\n            timestamp: reader.read() as u64,\\n            coinbase: EthAddress::from_field(reader.read()),\\n            fee_recipient: AztecAddress::from_field(reader.read()),\\n            gas_fees: reader.read_struct(GasFees::deserialize)\\n        }\\n    }\\n}\\n\\nimpl Eq for GlobalVariables {\\n    fn eq(self, other : GlobalVariables) -> bool {\\n        (self.chain_id == other.chain_id) &\\n        (self.version == other.version) &\\n        (self.block_number == other.block_number) &\\n        (self.timestamp == other.timestamp) &\\n        (self.coinbase == other.coinbase) &\\n        (self.fee_recipient == other.fee_recipient) &\\n        (self.gas_fees == other.gas_fees) \\n    }\\n}\\n\\nimpl Empty for GlobalVariables {\\n    fn empty() -> Self {\\n        Self {\\n            chain_id: 0,\\n            version: 0,\\n            block_number: 0,\\n            timestamp: 0,\\n            coinbase: EthAddress::empty(),\\n            fee_recipient: AztecAddress::empty(),\\n            gas_fees: GasFees::empty()\\n        }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let vars = GlobalVariables::empty();\\n    let _serialized = vars.serialize();\\n    let _deserialized = GlobalVariables::deserialize(_serialized);\\n}\\n"},"176":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr","source":"use crate::{\\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\\n    utils::{arrays::array_concat, reader::Reader}\\n};\\n\\nstruct ReadRequest {\\n    value: Field,\\n    counter: u32,\\n}\\n\\nimpl Ordered for ReadRequest {\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl Eq for ReadRequest {\\n    fn eq(self, read_request: ReadRequest) -> bool {\\n        (self.value == read_request.value)\\n        & (self.counter == read_request.counter)\\n    }\\n}\\n\\nimpl Empty for ReadRequest {\\n    fn empty() -> Self {\\n        ReadRequest {\\n            value: 0,\\n            counter: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\\n        [self.value, self.counter as Field]\\n    }\\n}\\n\\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\\n        Self {\\n            value: values[0],\\n            counter: values[1] as u32,\\n        }\\n    }\\n}\\n\\nimpl ReadRequest {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\\n        ScopedReadRequest { read_request: self, contract_address }\\n    }\\n}\\n\\nstruct ScopedReadRequest {\\n    read_request: ReadRequest,\\n    contract_address: AztecAddress,\\n}\\n\\nimpl Scoped<ReadRequest> for ScopedReadRequest {\\n    fn inner(self) -> ReadRequest {\\n        self.read_request\\n    }\\n    fn contract_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n}\\n\\nimpl Eq for ScopedReadRequest {\\n    fn eq(self, other: ScopedReadRequest) -> bool {\\n        (self.read_request == other.read_request)\\n        & (self.contract_address.eq(other.contract_address))\\n    }\\n}\\n\\nimpl Empty for ScopedReadRequest {\\n    fn empty() -> Self {\\n        ScopedReadRequest {\\n            read_request: ReadRequest::empty(),\\n            contract_address: AztecAddress::empty(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\\n    }\\n}\\n\\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\\n        let mut reader = Reader::new(values);\\n        let res = Self {\\n            read_request: reader.read_struct(ReadRequest::deserialize),\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n        };\\n        reader.finish();\\n        res\\n    }\\n}\\n\\nimpl ScopedReadRequest {\\n    pub fn value(self) -> Field {\\n        self.read_request.value\\n    }\\n    pub fn counter(self) -> u32 {\\n        self.read_request.counter\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty_read() {\\n    let item = ReadRequest::empty();\\n    let serialized = item.serialize();\\n    let deserialized = ReadRequest::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n\\n#[test]\\nfn serialization_of_empty_scoped() {\\n    let item = ScopedReadRequest::empty();\\n    let serialized = item.serialize();\\n    let deserialized = ScopedReadRequest::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"179":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr","source":"use crate::{\\n    address::AztecAddress,\\n    abis::validation_requests::{\\n    key_validation_request::KeyValidationRequest,\\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\\n},\\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\\n    utils::{arrays::array_concat, reader::Reader}\\n};\\n\\nstruct KeyValidationRequestAndGenerator {\\n    request: KeyValidationRequest,\\n    sk_app_generator: Field,\\n}\\n\\nimpl Eq for KeyValidationRequestAndGenerator {\\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\\n    }\\n}\\n\\nimpl Empty for KeyValidationRequestAndGenerator {\\n    fn empty() -> Self {\\n        KeyValidationRequestAndGenerator {\\n            request: KeyValidationRequest::empty(),\\n            sk_app_generator: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\\n        array_concat(self.request.serialize(), [self.sk_app_generator])\\n    }\\n}\\n\\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\\n        let mut reader = Reader::new(fields);\\n        let res = Self {\\n            request: reader.read_struct(KeyValidationRequest::deserialize),\\n            sk_app_generator: reader.read(),\\n        };\\n        reader.finish();\\n        res\\n    }\\n}\\n\\nimpl KeyValidationRequestAndGenerator {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = KeyValidationRequestAndGenerator::empty();\\n    let serialized = item.serialize();\\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"180":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\\n\\nstruct KeyValidationRequest {\\n    pk_m: Point,\\n    sk_app: Field, // not a grumpkin scalar because it\'s output of poseidon2\\n}\\n\\nimpl Eq for KeyValidationRequest {\\n    fn eq(self, request: KeyValidationRequest) -> bool {\\n        (request.pk_m.eq(self.pk_m))\\n            & (request.sk_app.eq(self.sk_app))\\n    }\\n}\\n\\nimpl Empty for KeyValidationRequest {\\n    fn empty() -> Self {\\n        KeyValidationRequest {\\n            pk_m: Point::empty(),\\n            sk_app: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\\n        [\\n            self.pk_m.x,\\n            self.pk_m.y,\\n            self.pk_m.is_infinite as Field,\\n            self.sk_app,\\n        ]\\n    }\\n}\\n\\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\\n        Self {\\n            pk_m: Point::new(fields[0], fields[1], fields[2] as bool),\\n            sk_app: fields[3],\\n        }\\n    }\\n}\\n\\n"},"184":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr","source":"use crate::{\\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH},\\n    hash::compute_siloed_nullifier, traits::{Empty, Hash, Serialize, Deserialize},\\n    utils::{arrays::array_concat, reader::Reader}\\n};\\n\\nstruct Nullifier {\\n    value: Field,\\n    counter: u32,\\n    note_hash: Field,\\n}\\n\\nimpl Ordered for Nullifier {\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for Nullifier {\\n    fn value(self) -> Field {\\n        self.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl Eq for Nullifier {\\n    fn eq(self, other: Nullifier) -> bool {\\n        (self.value == other.value)\\n            & (self.counter == other.counter)\\n            & (self.note_hash == other.note_hash) \\n    }\\n}\\n\\nimpl Empty for Nullifier {\\n    fn empty() -> Self {\\n        Nullifier {\\n            value: 0,\\n            counter: 0,\\n            note_hash: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\\n        [self.value, self.counter as Field, self.note_hash]\\n    }\\n}\\n\\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\\n        Self {\\n            value: values[0],\\n            counter: values[1] as u32,\\n            note_hash: values[2],\\n        }\\n    }\\n}\\n\\nimpl Readable for Nullifier {\\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\\n        // Public kernels output Nullifier instead of ScopedNullifier.\\n        // The nullifier value has been siloed.\\n        let siloed_request_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\\n        assert_eq(self.value, siloed_request_value, \\"Value of the nullifier does not match read request\\");\\n        assert(\\n            read_request.counter() > self.counter, \\"Read request counter must be greater than the counter of the nullifier\\"\\n        );\\n    }\\n}\\n\\nimpl Nullifier {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\\n        ScopedNullifier { nullifier: self, contract_address }\\n    }\\n}\\n\\nstruct ScopedNullifier {\\n    nullifier: Nullifier,\\n    contract_address: AztecAddress,\\n}\\n\\nimpl Scoped<Nullifier> for ScopedNullifier {\\n    fn inner(self) -> Nullifier {\\n        self.nullifier\\n    }\\n    fn contract_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n}\\n\\nimpl Ordered for ScopedNullifier {\\n    fn counter(self) -> u32 {\\n        self.nullifier.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for ScopedNullifier {\\n    fn value(self) -> Field {\\n        self.nullifier.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.nullifier.counter\\n    }\\n}\\n\\nimpl Eq for ScopedNullifier {\\n    fn eq(self, other: ScopedNullifier) -> bool {\\n        (self.nullifier == other.nullifier)\\n            & (self.contract_address == other.contract_address) \\n    }\\n}\\n\\nimpl Empty for ScopedNullifier {\\n    fn empty() -> Self {\\n        ScopedNullifier {\\n            nullifier: Nullifier::empty(),\\n            contract_address: AztecAddress::empty(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\\n    }\\n}\\n\\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\\n        let mut reader = Reader::new(values);\\n        let res = Self {\\n            nullifier: reader.read_struct(Nullifier::deserialize),\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n        };\\n        reader.finish();\\n        res\\n    }\\n}\\n\\nimpl Readable for ScopedNullifier {\\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\\n        assert_eq(self.nullifier.value, read_request.value(), \\"Value of the nullifier does not match read request\\");\\n        assert_eq(self.contract_address, read_request.contract_address, \\"Contract address of the nullifier does not match read request\\");\\n        assert(\\n            read_request.counter() > self.nullifier.counter, \\"Read request counter must be greater than the counter of the nullifier\\"\\n        );\\n    }\\n}\\n\\nimpl ScopedNullifier {\\n    pub fn nullified_note_hash(self) -> Field {\\n        self.nullifier.note_hash\\n    }\\n\\n    pub fn expose_to_public(self) -> Nullifier {\\n        // Hide the actual counter and note hash when exposing it to the public kernel.\\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = Nullifier::empty();\\n    let serialized = item.serialize();\\n    let deserialized = Nullifier::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n\\n#[test]\\nfn serialization_of_empty_scoped() {\\n    let item = ScopedNullifier::empty();\\n    let serialized = item.serialize();\\n    let deserialized = ScopedNullifier::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"193":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\\n\\nglobal SELECTOR_SIZE = 4;\\n\\nstruct FunctionSelector {\\n    // 1st 4-bytes of abi-encoding of function.\\n    inner: u32,\\n}\\n\\nimpl Eq for FunctionSelector {\\n    fn eq(self, function_selector: FunctionSelector) -> bool {\\n        function_selector.inner == self.inner\\n    }\\n}\\n\\nimpl Serialize<1> for FunctionSelector {\\n    fn serialize(self: Self) -> [Field; 1] {\\n        [self.inner as Field]\\n    }\\n}\\n\\nimpl Deserialize<1> for FunctionSelector {\\n    fn deserialize(fields: [Field; 1]) -> Self {\\n        Self {\\n            inner: fields[0] as u32\\n        }\\n    }\\n}\\n\\nimpl FromField for FunctionSelector {\\n    fn from_field(field: Field) -> Self {\\n        Self { inner: field as u32 }\\n    }\\n}\\n\\nimpl ToField for FunctionSelector {\\n    fn to_field(self) -> Field {\\n        self.inner as Field\\n    }\\n}\\n\\nimpl Empty for FunctionSelector {\\n    fn empty() -> Self {\\n        Self { inner: 0 as u32 }\\n    }\\n}\\n\\nimpl FunctionSelector {\\n    pub fn from_u32(value: u32) -> Self {\\n        Self { inner: value }\\n    }\\n\\n    pub fn from_signature<N>(signature: str<N>) -> Self {\\n        let bytes = signature.as_bytes();\\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\\n\\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\\n        for i in 0..SELECTOR_SIZE {\\n            selector_be_bytes[i] = hash[i];\\n        }\\n\\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\\n    }\\n\\n    pub fn zero() -> Self {\\n        Self { inner: 0 }\\n    }\\n}\\n"},"194":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr","source":"use crate::{\\n    abis::{\\n    private_call_stack_item::PrivateCallStackItem, call_context::CallContext,\\n    function_data::FunctionData, caller_context::CallerContext,\\n    side_effect::{Ordered, RangeOrdered, Scoped}\\n},\\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\\n};\\n\\nstruct PrivateCallRequest {\\n    target: AztecAddress,\\n    call_context: CallContext,\\n    function_data: FunctionData,\\n    args_hash: Field,\\n    returns_hash: Field,\\n    caller_context: CallerContext,\\n    start_side_effect_counter: u32,\\n    end_side_effect_counter: u32,\\n}\\n\\nimpl Ordered for PrivateCallRequest {\\n    fn counter(self) -> u32 {\\n        self.start_side_effect_counter\\n    }\\n}\\n\\nimpl RangeOrdered for PrivateCallRequest {\\n    fn counter_start(self) -> u32 {\\n        self.start_side_effect_counter\\n    }\\n    fn counter_end(self) -> u32 {\\n        self.end_side_effect_counter\\n    }\\n}\\n\\nimpl Eq for PrivateCallRequest {\\n    fn eq(self, other: PrivateCallRequest) -> bool {\\n        (self.target == other.target) \\n            & (self.call_context == other.call_context) \\n            & (self.function_data == other.function_data) \\n            & (self.args_hash == other.args_hash) \\n            & (self.returns_hash == other.returns_hash)\\n            & (self.caller_context == other.caller_context)\\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\\n    }\\n}\\n\\nimpl Empty for PrivateCallRequest {\\n    fn empty() -> Self {\\n        PrivateCallRequest {\\n            target: AztecAddress::empty(),\\n            call_context: CallContext::empty(),\\n            function_data: FunctionData::empty(),\\n            args_hash: 0,\\n            returns_hash: 0,\\n            caller_context: CallerContext::empty(),\\n            start_side_effect_counter: 0,\\n            end_side_effect_counter: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\\n\\n        fields.push(self.target.to_field());\\n        fields.extend_from_array(self.call_context.serialize());\\n        fields.extend_from_array(self.function_data.serialize());\\n        fields.push(self.args_hash);\\n        fields.push(self.returns_hash);\\n        fields.extend_from_array(self.caller_context.serialize());\\n        fields.push(self.start_side_effect_counter as Field);\\n        fields.push(self.end_side_effect_counter as Field);\\n\\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\\n        let mut reader = Reader::new(fields);\\n        let item = PrivateCallRequest {\\n            target: reader.read_struct(AztecAddress::deserialize),\\n            call_context: reader.read_struct(CallContext::deserialize),\\n            function_data: reader.read_struct(FunctionData::deserialize),\\n            args_hash: reader.read(),\\n            returns_hash: reader.read(),\\n            caller_context: reader.read_struct(CallerContext::deserialize),\\n            start_side_effect_counter: reader.read_u32(),\\n            end_side_effect_counter: reader.read_u32(),\\n        };\\n        reader.finish();\\n        item\\n    }\\n}\\n\\nimpl PrivateCallRequest {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\\n        ScopedPrivateCallRequest { call_request: self, contract_address }\\n    }\\n\\n    pub fn matches_stack_item(self, stack_item: PrivateCallStackItem) -> bool {\\n        (self.target == stack_item.contract_address)\\n            & (self.call_context == stack_item.public_inputs.call_context)\\n            & (self.function_data == stack_item.function_data)\\n            & (self.args_hash == stack_item.public_inputs.args_hash)\\n            & (self.returns_hash == stack_item.public_inputs.returns_hash)\\n            & (self.start_side_effect_counter\\n                                == stack_item.public_inputs.start_side_effect_counter)\\n            & (self.end_side_effect_counter\\n                                    == stack_item.public_inputs.end_side_effect_counter)\\n    }\\n}\\n\\nstruct ScopedPrivateCallRequest {\\n    call_request: PrivateCallRequest,\\n    contract_address: AztecAddress,\\n}\\n\\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\\n    fn inner(self) -> PrivateCallRequest {\\n        self.call_request\\n    }\\n    fn contract_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n}\\n\\nimpl Ordered for ScopedPrivateCallRequest {\\n    fn counter(self) -> u32 {\\n        self.call_request.counter_start()\\n    }\\n}\\n\\nimpl RangeOrdered for ScopedPrivateCallRequest {\\n    fn counter_start(self) -> u32 {\\n        self.call_request.counter_start()\\n    }\\n    fn counter_end(self) -> u32 {\\n        self.call_request.counter_end()\\n    }\\n}\\n\\nimpl Eq for ScopedPrivateCallRequest {\\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\\n        (self.call_request == other.call_request)\\n            & (self.contract_address == other.contract_address)\\n    }\\n}\\n\\nimpl Empty for ScopedPrivateCallRequest {\\n    fn empty() -> Self {\\n        ScopedPrivateCallRequest {\\n            call_request: PrivateCallRequest::empty(),\\n            contract_address: AztecAddress::zero(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\\n\\n        fields.extend_from_array(self.call_request.serialize());\\n        fields.extend_from_array(self.contract_address.serialize());\\n\\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\\n        let mut reader = Reader::new(fields);\\n        let item = ScopedPrivateCallRequest {\\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n        };\\n        reader.finish();\\n        item\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = ScopedPrivateCallRequest::empty();\\n    let serialized = item.serialize();\\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"199":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr","source":"use crate::{\\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\\n    abis::gas_fees::GasFees,\\n    constants::{\\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\\n    DEFAULT_INCLUSION_FEE\\n},\\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\\n    utils::reader::Reader\\n};\\n\\nstruct GasSettings {\\n    gas_limits: Gas,\\n    teardown_gas_limits: Gas,\\n    max_fees_per_gas: GasFees,\\n    inclusion_fee: Field,\\n}\\n\\nimpl GasSettings {\\n    pub fn new(\\n        gas_limits: Gas,\\n        teardown_gas_limits: Gas,\\n        max_fees_per_gas: GasFees,\\n        inclusion_fee: Field\\n    ) -> Self {\\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\\n    }\\n\\n    pub fn default() -> Self {\\n        GasSettings::new(\\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\\n            DEFAULT_INCLUSION_FEE\\n        )\\n    }\\n}\\n\\nimpl Eq for GasSettings {\\n    fn eq(self, other: Self) -> bool {\\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\\n    }\\n}\\n\\nimpl Empty for GasSettings {\\n    fn empty() -> Self {\\n        GasSettings::new(\\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\\n        )\\n    }\\n}\\n\\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\\n\\n        serialized.extend_from_array(self.gas_limits.serialize());\\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\\n        serialized.push(self.inclusion_fee);\\n    \\n        serialized.storage\\n    }\\n}\\n\\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\\n        let mut reader = Reader::new(serialized);\\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = GasSettings::empty();\\n    let serialized = item.serialize();\\n    let deserialized = GasSettings::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"208":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr","source":"use crate::{\\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\\n    address::AztecAddress,\\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\\n};\\n\\nstruct PrivateCallStackItem {\\n    // This is the _actual_ contract address relating to where this function\'s code resides in the\\n    // contract tree. Regardless of whether this is a call or delegatecall, this\\n    // `contract_address` _does not change_. Amongst other things, it\'s used as a lookup for\\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\\n    contract_address: AztecAddress,\\n    function_data: FunctionData,\\n    public_inputs: PrivateCircuitPublicInputs,\\n}\\n\\nimpl Eq for PrivateCallStackItem {\\n    fn eq(self, other: Self) -> bool {\\n        self.contract_address.eq(other.contract_address) &\\n        self.function_data.eq(other.function_data) &\\n        self.public_inputs.eq(other.public_inputs)\\n    }\\n}\\n\\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\\n\\n        fields.push(self.contract_address.to_field());\\n        fields.extend_from_array(self.function_data.serialize());\\n        fields.extend_from_array(self.public_inputs.serialize());\\n\\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\\n        let mut reader = Reader::new(serialized);\\n\\n        let item = Self {\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n            function_data: reader.read_struct(FunctionData::deserialize),\\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\\n        };\\n\\n        reader.finish();\\n        item\\n    }\\n}\\n\\nimpl Hash for PrivateCallStackItem {\\n    fn hash(self) -> Field {\\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\\n    }\\n}\\n\\nimpl Empty for PrivateCallStackItem {\\n    fn empty() -> Self {\\n        PrivateCallStackItem {\\n            contract_address: AztecAddress::empty(),\\n            function_data: FunctionData::empty(),\\n            public_inputs: PrivateCircuitPublicInputs::empty(),\\n        }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = PrivateCallStackItem::empty();\\n    let serialized = item.serialize();\\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n\\n#[test]\\nfn empty_hash() {\\n    let mut item = PrivateCallStackItem::empty();\\n    item.function_data.is_private = true;\\n    let hash = item.hash();\\n\\n    // Value from private_call_stack_item.test.ts \\"computes empty item hash\\" test\\n    let test_data_empty_hash = 0x065f2831db9ac0db5e710bd3a865b5facd8cf83f1585e1af8fd1d6ce9c47f685;\\n    assert_eq(hash, test_data_empty_hash);\\n}\\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr","source":"use crate::address::AztecAddress;\\nuse crate::traits::{Empty, Serialize, Deserialize};\\nuse crate::constants::CALLER_CONTEXT_LENGTH;\\nuse crate::utils::reader::Reader;\\n\\nstruct CallerContext {\\n    msg_sender: AztecAddress,\\n    storage_contract_address: AztecAddress,\\n    is_static_call: bool,\\n}\\n\\nimpl Eq for CallerContext {\\n    fn eq(self, other: CallerContext) -> bool {\\n        other.msg_sender.eq(self.msg_sender)\\n            & other.storage_contract_address.eq(self.storage_contract_address)\\n            & other.is_static_call == self.is_static_call\\n    }\\n}\\n\\nimpl Empty for CallerContext {\\n    fn empty() -> Self {\\n        CallerContext {\\n            msg_sender: AztecAddress::zero(),\\n            storage_contract_address: AztecAddress::zero(),\\n            is_static_call: false,\\n        }\\n    }\\n}\\n\\nimpl CallerContext {\\n    pub fn is_empty(self) -> bool {\\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\\n    }\\n\\n    // Different to an empty context, a hidden context won\'t reveal the caller\'s msg_sender and storage_contract_address,\\n    // but will still propagate the is_static_call flag.\\n    pub fn is_hidden(self) -> bool {\\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\\n    }\\n}\\n\\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\\n\\n    fields.extend_from_array(self.msg_sender.serialize());\\n    fields.extend_from_array(self.storage_contract_address.serialize());\\n    fields.push(self.is_static_call as Field);\\n\\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\\n\\n    fields.storage\\n  }\\n}\\n\\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\\n    let mut reader = Reader::new(fields);\\n\\n    let item = CallerContext {\\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\\n      is_static_call: reader.read_bool(),\\n    };\\n    reader.finish();\\n    item\\n  }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = CallerContext::empty();\\n    let serialized = item.serialize();\\n    let deserialized = CallerContext::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"211":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr","source":"use crate::{\\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\\n    constants::{\\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\\n},\\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\\n};\\n\\nstruct LogHash {\\n    value: Field,\\n    counter: u32,\\n    length: Field,\\n}\\n\\nimpl Ordered for LogHash {\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for LogHash {\\n    fn value(self) -> Field {\\n        self.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl Eq for LogHash {\\n    fn eq(self, other: LogHash) -> bool {\\n        (self.value == other.value)\\n            & (self.counter == other.counter)\\n            & (self.length == other.length) \\n    }\\n}\\n\\nimpl Empty for LogHash {\\n    fn empty() -> Self {\\n        LogHash {\\n            value: 0,\\n            counter: 0,\\n            length: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\\n        [self.value, self.counter as Field, self.length]\\n    }\\n}\\n\\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\\n        Self {\\n            value: values[0],\\n            counter: values[1] as u32,\\n            length: values[2],\\n        }\\n    }\\n}\\n\\nimpl LogHash {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\\n        ScopedLogHash { log_hash: self, contract_address }\\n    }\\n}\\n\\nstruct ScopedLogHash {\\n    log_hash: LogHash,\\n    contract_address: AztecAddress,\\n}\\n\\nimpl Scoped<LogHash> for ScopedLogHash {\\n    fn inner(self) -> LogHash {\\n        self.log_hash\\n    }\\n    fn contract_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n}\\n\\nimpl Ordered for ScopedLogHash {\\n    fn counter(self) -> u32 {\\n        self.log_hash.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for ScopedLogHash {\\n    fn value(self) -> Field {\\n        self.log_hash.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.log_hash.counter\\n    }\\n}\\n\\nimpl Eq for ScopedLogHash {\\n    fn eq(self, other: ScopedLogHash) -> bool {\\n        (self.log_hash == other.log_hash)\\n            & (self.contract_address == other.contract_address) \\n    }\\n}\\n\\nimpl Empty for ScopedLogHash {\\n    fn empty() -> Self {\\n        ScopedLogHash {\\n            log_hash: LogHash::empty(),\\n            contract_address: AztecAddress::empty(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\\n    }\\n}\\n\\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\\n        let mut reader = Reader::new(values);\\n        let res = Self {\\n            log_hash: reader.read_struct(LogHash::deserialize),\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n        };\\n        reader.finish();\\n        res\\n    }\\n}\\n\\nimpl ScopedLogHash {\\n    pub fn expose_to_public(self) -> LogHash {\\n        // Hide the counter when exposing to public.\\n        // The log hash must already be siloed when we call this.\\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\\n    }\\n}\\n\\nstruct EncryptedLogHash {\\n    value: Field,\\n    counter: u32,\\n    length: Field,\\n    randomness: Field,\\n}\\n\\nimpl Ordered for EncryptedLogHash {\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for EncryptedLogHash {\\n    fn value(self) -> Field {\\n        self.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl Eq for EncryptedLogHash {\\n    fn eq(self, other: EncryptedLogHash) -> bool {\\n        (self.value == other.value)\\n            & (self.counter == other.counter)\\n            & (self.length == other.length) \\n            & (self.randomness == other.randomness) \\n    }\\n}\\n\\nimpl Empty for EncryptedLogHash {\\n    fn empty() -> Self {\\n        EncryptedLogHash {\\n            value: 0,\\n            counter: 0,\\n            length: 0,\\n            randomness: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\\n        [self.value, self.counter as Field, self.length, self.randomness]\\n    }\\n}\\n\\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\\n        Self {\\n            value: values[0],\\n            counter: values[1] as u32,\\n            length: values[2],\\n            randomness: values[3],\\n        }\\n    }\\n}\\n\\nimpl EncryptedLogHash {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\\n    }\\n}\\n\\nstruct ScopedEncryptedLogHash {\\n    log_hash: EncryptedLogHash,\\n    contract_address: AztecAddress,\\n}\\n\\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\\n    fn inner(self) -> EncryptedLogHash {\\n        self.log_hash\\n    }\\n    fn contract_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n}\\n\\nimpl ScopedEncryptedLogHash {\\n    pub fn expose_to_public(self) -> LogHash {\\n        // Hide the secret randomness and counter when exposing to public\\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\\n        // The log hash will already be silo\'d when we call this\\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\\n    }\\n}\\n\\nimpl Ordered for ScopedEncryptedLogHash {\\n    fn counter(self) -> u32 {\\n        self.log_hash.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\\n    fn value(self) -> Field {\\n        self.log_hash.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.log_hash.counter\\n    }\\n}\\n\\nimpl Eq for ScopedEncryptedLogHash {\\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\\n        (self.log_hash == other.log_hash)\\n            & (self.contract_address == other.contract_address) \\n    }\\n}\\n\\nimpl Empty for ScopedEncryptedLogHash {\\n    fn empty() -> Self {\\n        ScopedEncryptedLogHash {\\n            log_hash: EncryptedLogHash::empty(),\\n            contract_address: AztecAddress::empty(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\\n    }\\n}\\n\\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\\n        let mut reader = Reader::new(values);\\n        let res = Self {\\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n        };\\n        reader.finish();\\n        res\\n    }\\n}\\n\\nstruct NoteLogHash {\\n    value: Field,\\n    counter: u32,\\n    length: Field,\\n    note_hash_counter: u32,\\n}\\n\\nimpl NoteLogHash {\\n    pub fn expose_to_public(self) -> LogHash {\\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\\n        LogHash { value: self.value, counter: 0, length: self.length }\\n    }\\n}\\n\\nimpl Ordered for NoteLogHash {\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for NoteLogHash {\\n    fn value(self) -> Field {\\n        self.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl Eq for NoteLogHash {\\n    fn eq(self, other: NoteLogHash) -> bool {\\n        (self.value == other.value)\\n            & (self.counter == other.counter)\\n            & (self.length == other.length) \\n            & (self.note_hash_counter == other.note_hash_counter) \\n    }\\n}\\n\\nimpl Empty for NoteLogHash {\\n    fn empty() -> Self {\\n        NoteLogHash {\\n            value: 0,\\n            counter: 0,\\n            length: 0,\\n            note_hash_counter: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\\n    }\\n}\\n\\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\\n        Self {\\n            value: values[0],\\n            counter: values[1] as u32,\\n            length: values[2],\\n            note_hash_counter: values[3] as u32,\\n        }\\n    }\\n}\\n"},"215":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr","source":"struct AppendOnlyTreeSnapshot {\\n    root : Field,\\n    // TODO(Alvaro) change this to a u64\\n    next_available_leaf_index : u32\\n}\\n\\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\\n\\nimpl AppendOnlyTreeSnapshot {\\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\\n        [self.root, self.next_available_leaf_index as Field]\\n    }\\n\\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\\n    }\\n\\n    pub fn zero() -> Self {\\n        Self { root: 0, next_available_leaf_index: 0 }\\n    }\\n}\\n\\nimpl Eq for AppendOnlyTreeSnapshot {\\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\\n    }\\n}\\n"},"216":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\\n    abis::function_selector::FunctionSelector, address::AztecAddress,\\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\\n};\\n\\n// docs:start:call-context\\nstruct CallContext {\\n    msg_sender : AztecAddress,\\n    storage_contract_address : AztecAddress,\\n    function_selector : FunctionSelector,\\n\\n    is_delegate_call : bool,\\n    is_static_call : bool,\\n}\\n// docs:end:call-context\\n\\nimpl Eq for CallContext {\\n    fn eq(self, other: CallContext) -> bool {\\n        self.serialize() == other.serialize()\\n    }\\n}\\n\\nimpl Hash for CallContext {\\n    fn hash(self) -> Field {\\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\\n    }\\n}\\n\\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\\n\\n        serialized.push(self.msg_sender.to_field());\\n        serialized.push(self.storage_contract_address.to_field());\\n        serialized.push(self.function_selector.to_field());\\n        serialized.push(self.is_delegate_call as Field);\\n        serialized.push(self.is_static_call as Field);\\n    \\n        serialized.storage\\n    }\\n}\\n\\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\\n        let mut reader = Reader::new(serialized);\\n        CallContext {\\n            msg_sender: AztecAddress::from_field(reader.read()),\\n            storage_contract_address: AztecAddress::from_field(reader.read()),\\n            function_selector: FunctionSelector::from_field(reader.read()),\\n            is_delegate_call: reader.read() as bool,\\n            is_static_call: reader.read() as bool,\\n        }\\n    }\\n}\\n\\nimpl Empty for CallContext {\\n    fn empty() -> Self {\\n        CallContext {\\n            msg_sender: AztecAddress::empty(),\\n            storage_contract_address: AztecAddress::empty(),\\n            function_selector: FunctionSelector::empty(),\\n            is_delegate_call: false,\\n            is_static_call: false,\\n        }\\n    }\\n}\\n\\n#[test]\\nfn serialize_deserialize_of_empty() {\\n    let context = CallContext::empty();\\n    let serialized = context.serialize();\\n    let deserialized = CallContext::deserialize(serialized);\\n    assert(context.eq(deserialized));\\n}\\n\\n#[test]\\nfn test_eq() {\\n    let mut context1 = CallContext::empty();\\n    let mut context2 = CallContext::empty();\\n\\n    context1.is_delegate_call = true;\\n    context2.is_delegate_call = true;\\n\\n    let address: AztecAddress = AztecAddress::from_field(69420);\\n    context1.msg_sender = address;\\n    context2.msg_sender = address;\\n\\n    assert(context1.eq(context2));\\n}\\n\\n#[test(should_fail)]\\nfn not_eq_test_eq() {\\n    let mut context1 = CallContext::empty();\\n    let mut context2 = CallContext::empty();\\n\\n    context1.is_delegate_call = true;\\n    context2.is_delegate_call = false;\\n\\n    let address1: AztecAddress = AztecAddress::from_field(69420);\\n    let address2: AztecAddress = AztecAddress::from_field(42069);\\n\\n    context1.msg_sender = address1;\\n    context2.msg_sender = address2;\\n\\n    assert(context1.eq(context2));\\n}\\n\\n#[test]\\nfn hash_smoke() {\\n    let context = CallContext::empty();\\n    let _hashed = context.hash();\\n}\\n"},"217":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\\n\\nstruct MaxBlockNumber {\\n    _opt: Option<u32>\\n}\\n\\nimpl Empty for MaxBlockNumber {\\n    fn empty() -> Self {\\n        Self { _opt: Option::none() }\\n    }\\n}\\n\\nimpl Eq for MaxBlockNumber {\\n    fn eq(self, other: Self) -> bool {\\n        self._opt == other._opt\\n    }\\n}\\n\\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\\n        [self._opt._is_some as Field, self._opt._value as Field]\\n    }\\n}\\n\\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\\n        MaxBlockNumber {\\n            _opt: Option {\\n                _is_some: serialized[0] as bool,\\n                _value: serialized[1] as u32,\\n            }\\n        }\\n    }\\n}\\n\\nimpl MaxBlockNumber {\\n    pub fn new(max_block_number: u32) -> Self {\\n        Self { _opt: Option::some(max_block_number) }\\n    }\\n\\n    pub fn is_none(self) -> bool {\\n        self._opt.is_none()\\n    }\\n\\n    pub fn is_some(self) -> bool {\\n        self._opt.is_some()\\n    }\\n\\n    pub fn unwrap(self) -> u32 {\\n        self._opt.unwrap()\\n    }\\n\\n    pub fn unwrap_unchecked(self) -> u32 {\\n        self._opt.unwrap_unchecked()\\n    }\\n\\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\\n        if rhs.is_none() {\\n            lhs // lhs might also be none, but in that case both would be\\n        } else {\\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\\n        }\\n    }\\n\\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\\n        if lhs._opt.is_none() {\\n            MaxBlockNumber::new(rhs)\\n        } else {\\n            let lhs_value = lhs._opt.unwrap_unchecked();\\n\\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\\n        }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = MaxBlockNumber::empty();\\n    let serialized = item.serialize();\\n    let deserialized = MaxBlockNumber::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n\\n#[test]\\nfn zeroed_is_none() {\\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\\n    // and though we should eventually move everything to use `default`, it\'s good to check for now that both are\\n    // equivalent.\\n    let a = MaxBlockNumber::empty();\\n    assert(a.is_none());\\n}\\n\\n#[test]\\nfn serde_default() {\\n    let a = MaxBlockNumber::empty();\\n    let b = MaxBlockNumber::deserialize(a.serialize());\\n    assert(b.is_none());\\n}\\n\\n#[test]\\nfn serde_some() {\\n    let a = MaxBlockNumber::new(13);\\n    let b = MaxBlockNumber::deserialize(a.serialize());\\n    assert_eq(b.unwrap(), 13);\\n}\\n\\n#[test(should_fail)]\\nfn default_unwrap_panics() {\\n    let a = MaxBlockNumber::empty();\\n    let _ = a.unwrap();\\n}\\n\\n#[test]\\nfn min_default_default() {\\n    let a = MaxBlockNumber::empty();\\n    let b = MaxBlockNumber::empty();\\n\\n    assert(MaxBlockNumber::min(a, b).is_none());\\n}\\n\\n#[test]\\nfn min_default_some() {\\n    let a = MaxBlockNumber::empty();\\n    let b = MaxBlockNumber::new(13);\\n\\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\\n}\\n\\n#[test]\\nfn min_some_some() {\\n    let a = MaxBlockNumber::new(13);\\n    let b = MaxBlockNumber::new(42);\\n\\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\\n}\\n\\n#[test]\\nfn min_with_u32_default() {\\n    let a = MaxBlockNumber::empty();\\n    let b = 42;\\n\\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\\n}\\n\\n#[test]\\nfn min_with_u32_some() {\\n    let a = MaxBlockNumber::new(13);\\n    let b = 42;\\n    let c = 8;\\n\\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\\n}\\n"},"220":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr","source":"use crate::{\\n    abis::function_selector::FunctionSelector,\\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\\n    traits::{Serialize, Hash, Deserialize, Empty}\\n};\\n\\nstruct FunctionData {\\n    selector : FunctionSelector,\\n    is_private : bool,\\n}\\n\\nimpl Eq for FunctionData {\\n    fn eq(self, other: Self) -> bool {\\n        self.selector.eq(other.selector) &\\n        (self.is_private == other.is_private)\\n    }\\n}\\n\\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\\n    // A field is ~256 bits\\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\\n    // This method will simply return a bit packed Field instead of hashing\\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\\n        [\\n            self.selector.to_field(),\\n            self.is_private as Field,\\n        ]\\n    }\\n}\\n\\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\\n        Self {\\n            selector: FunctionSelector::from_field(serialized[0]),\\n            is_private: serialized[1] as bool,\\n        }\\n    }\\n}\\n\\nimpl Hash for FunctionData {\\n    fn hash(self) -> Field {\\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\\n    }\\n}\\n\\nimpl Empty for FunctionData {\\n    fn empty() -> Self {\\n        FunctionData {\\n            selector: FunctionSelector::empty(),\\n            is_private: false\\n        }\\n    }\\n\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let data = FunctionData::empty();\\n    let serialized = data.serialize();\\n    let deserialized = FunctionData::deserialize(serialized);\\n    assert(data.eq(deserialized));\\n}\\n\\n#[test]\\nfn empty_hash() {\\n    let data = FunctionData::empty();\\n    let hash = data.hash();\\n\\n    // Value from function_data.test.ts \\"computes empty function data hash\\" test\\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\\n    assert_eq(hash, test_data_empty_hash);\\n}\\n"},"227":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr","source":"use crate::{\\n    address::{AztecAddress, EthAddress},\\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\\n    utils::{arrays::array_concat, reader::Reader}\\n};\\n\\n// Note: Not to be confused with L2ToL1Msg in Solidity\\nstruct L2ToL1Message {\\n    recipient: EthAddress,\\n    content: Field,\\n    counter: u32,\\n}\\n\\nimpl Ordered for L2ToL1Message {\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl Empty for L2ToL1Message {\\n    fn empty() -> Self {\\n        Self {\\n            recipient: EthAddress::empty(),\\n            content: 0,\\n            counter: 0,\\n        }\\n    }\\n}\\n\\nimpl Eq for L2ToL1Message {\\n    fn eq(self, other: Self) -> bool {\\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\\n    }\\n}\\n\\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\\n        [self.recipient.to_field(), self.content, self.counter as Field]\\n    }\\n}\\n\\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\\n        Self {\\n            recipient: EthAddress::from_field(values[0]),\\n            content: values[1],\\n            counter: values[2] as u32,\\n        }\\n    }\\n}\\n\\nimpl L2ToL1Message {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\\n        ScopedL2ToL1Message { message: self, contract_address }\\n    }\\n}\\n\\nstruct ScopedL2ToL1Message {\\n    message: L2ToL1Message,\\n    contract_address: AztecAddress,\\n}\\n\\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\\n    fn inner(self) -> L2ToL1Message {\\n        self.message\\n    }\\n    fn contract_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n}\\n\\nimpl Ordered for ScopedL2ToL1Message {\\n    fn counter(self) -> u32 {\\n        self.message.counter\\n    }\\n}\\n\\nimpl Eq for ScopedL2ToL1Message {\\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\\n        (self.message == other.message)\\n            & (self.contract_address == other.contract_address) \\n    }\\n}\\n\\nimpl Empty for ScopedL2ToL1Message {\\n    fn empty() -> Self {\\n        ScopedL2ToL1Message {\\n            message: L2ToL1Message::empty(),\\n            contract_address: AztecAddress::empty(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\\n    }\\n}\\n\\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\\n        let mut reader = Reader::new(values);\\n        let res = Self {\\n            message: reader.read_struct(L2ToL1Message::deserialize),\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n        };\\n        reader.finish();\\n        res\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty_l2() {\\n    let item = L2ToL1Message::empty();\\n    let serialized = item.serialize();\\n    let deserialized = L2ToL1Message::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n\\n#[test]\\nfn serialization_of_empty_scoped_l2() {\\n    let item = ScopedL2ToL1Message::empty();\\n    let serialized = item.serialize();\\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"237":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr","source":"use crate::{\\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\\n    utils::arr_copy_slice\\n};\\n\\nstruct ContentCommitment {\\n  num_txs: Field,\\n  txs_effects_hash: Field,\\n  in_hash: Field,\\n  out_hash: Field,\\n}\\n\\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\\n\\n    fields.push(self.num_txs);\\n    fields.push(self.txs_effects_hash);\\n    fields.push(self.in_hash);\\n    fields.push(self.out_hash);\\n\\n    fields.storage\\n  }\\n}\\n\\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\\n    let num_txs = serialized[0];\\n\\n    let txs_effects_hash = serialized[1];\\n\\n    let in_hash = serialized[2];\\n\\n    let out_hash = serialized[3];\\n\\n    Self {\\n      num_txs,\\n      txs_effects_hash,\\n      in_hash,\\n      out_hash,\\n    }\\n  }\\n}\\n\\nimpl Empty for ContentCommitment {\\n  fn empty() -> Self {\\n    Self {\\n      num_txs: 0,\\n      txs_effects_hash: 0,\\n      in_hash: 0,\\n      out_hash: 0,\\n    }\\n  }\\n}\\n\\nimpl Eq for ContentCommitment {\\n  fn eq(self, other: Self) -> bool {\\n    (self.num_txs == other.num_txs)\\n      & (self.txs_effects_hash == other.txs_effects_hash)\\n      & (self.in_hash == other.in_hash)\\n      & (self.out_hash == other.out_hash)\\n  }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let empty = ContentCommitment::empty();\\n    let serialized = empty.serialize();\\n    let deserialized = ContentCommitment::deserialize(serialized);\\n\\n    assert(empty.eq(deserialized));\\n}\\n"},"239":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr","source":"use crate::{\\n    abis::{\\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\\n},\\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\\n    utils::arr_copy_slice, content_commitment::ContentCommitment\\n};\\n\\n// docs:start:header\\nstruct Header {\\n    last_archive: AppendOnlyTreeSnapshot,\\n    content_commitment: ContentCommitment,\\n    state: StateReference,\\n    global_variables: GlobalVariables,\\n    total_fees: Field\\n}\\n// docs:end:header\\n\\nimpl Eq for Header {\\n    fn eq(self, other: Self) -> bool {\\n        self.last_archive.eq(other.last_archive) &\\n        self.content_commitment.eq(other.content_commitment) &\\n        self.state.eq(other.state) &\\n        self.global_variables.eq(other.global_variables) &\\n        self.total_fees.eq(other.total_fees)\\n    }\\n}\\n\\nimpl Serialize<HEADER_LENGTH> for Header {\\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\\n\\n        fields.extend_from_array(self.last_archive.serialize());\\n        fields.extend_from_array(self.content_commitment.serialize());\\n        fields.extend_from_array(self.state.serialize());\\n        fields.extend_from_array(self.global_variables.serialize());\\n        fields.push(self.total_fees);\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<HEADER_LENGTH> for Header {\\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\\n        let mut offset = 0;\\n\\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\\n\\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\\n\\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\\n        offset = offset + STATE_REFERENCE_LENGTH;\\n\\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\\n\\n        let total_fees = serialized[offset];\\n\\n        Header {\\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\\n            state: StateReference::deserialize(state_fields),\\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\\n            total_fees\\n        }\\n    }\\n}\\n\\nimpl Empty for Header {\\n    fn empty() -> Self {\\n        Self {\\n            last_archive: AppendOnlyTreeSnapshot::zero(),\\n            content_commitment: ContentCommitment::empty(),\\n            state: StateReference::empty(),\\n            global_variables: GlobalVariables::empty(),\\n            total_fees: 0\\n        }\\n    }\\n}\\n\\nimpl Hash for Header {\\n    fn hash(self) -> Field {\\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let header = Header::empty();\\n    let serialized = header.serialize();\\n    let deserialized = Header::deserialize(serialized);\\n    assert(header.eq(deserialized));\\n}\\n\\n#[test]\\nfn hash_smoke() {\\n    let header = Header::empty();\\n    let _hashed = header.hash();\\n}\\n\\n#[test]\\nfn empty_hash_is_zero() {\\n    let header = Header::empty();\\n    let hash = header.hash();\\n\\n    // Value from new_contract_data.test.ts \\"computes empty hash\\" test\\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\\n    assert_eq(hash, test_data_empty_hash);\\n}\\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\\n    abis::{\\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\\n},\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\\n},\\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\\n    recursion::verification_key::VerificationKey, traits::is_empty,\\n    utils::field::field_from_bytes_32_trunc\\n};\\nuse std::hash::{pedersen_hash_with_separator, sha256};\\n\\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\\n    let sha256_hashed = sha256(bytes_to_hash);\\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\\n\\n    hash_in_a_field\\n}\\n\\npub fn private_functions_root_from_siblings(\\n    selector: FunctionSelector,\\n    vk_hash: Field,\\n    function_leaf_index: Field,\\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\\n) -> Field {\\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\\n    let function_leaf = function_leaf_preimage.hash();\\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\\n}\\n\\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\\n    // Hashing tx hash with note index in tx is guaranteed to be unique\\n    pedersen_hash(\\n        [\\n        tx_hash,\\n        note_index_in_tx as Field\\n    ],\\n        GENERATOR_INDEX__NOTE_HASH_NONCE\\n    )\\n}\\n\\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\\n    let inputs = [nonce, inner_note_hash];\\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\\n}\\n\\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\\n    pedersen_hash(\\n        [\\n        app.to_field(),\\n        unique_note_hash\\n    ],\\n        GENERATOR_INDEX__SILOED_NOTE_HASH\\n    )\\n}\\n\\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\\n    if note_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\\n    }\\n}\\n\\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\\n    pedersen_hash(\\n        [\\n        app.to_field(),\\n        nullifier\\n    ],\\n        GENERATOR_INDEX__OUTER_NULLIFIER\\n    )\\n}\\n\\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\\n    if nullifier.contract_address.is_zero() {\\n        nullifier.value() // Return value instead of 0 because the first nullifier\'s contract address is zero.\\n    } else {\\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\\n    }\\n}\\n\\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\\n    // NB: A unique separator will be needed for masked_contract_address\\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\\n    if randomness == 0 {\\n        // In some cases, we actually want to reveal the contract address we are siloing with:\\n        // e.g. \'handshaking\' contract w/ known address\\n        // An app providing randomness = 0 signals to not mask the address.\\n        masked_contract_address = address.to_field();\\n    }\\n    accumulate_sha256([masked_contract_address, log_hash])\\n}\\n\\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\\n    if log_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_encrypted_log_hash(\\n            log_hash.contract_address,\\n            log_hash.log_hash.randomness,\\n            log_hash.log_hash.value\\n        )\\n    }\\n}\\n\\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\\n    accumulate_sha256([address.to_field(), log_hash])\\n}\\n\\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\\n    if log_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\\n    }\\n}\\n\\npub fn merkle_hash(left: Field, right: Field) -> Field {\\n    pedersen_hash([left, right], 0)\\n}\\n\\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\\n    // Original cpp code\\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\\n    // The above cpp method is only ever called on verification key, so it has been special cased here\\n    let _hash_index = GENERATOR_INDEX__VK;\\n    0\\n}\\n\\npub fn compute_l2_to_l1_hash(\\n    contract_address: AztecAddress,\\n    recipient: EthAddress,\\n    content: Field,\\n    rollup_version_id: Field,\\n    chain_id: Field\\n) -> Field {\\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\\n\\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\\n    for i in 0..inputs.len() {\\n        // TODO are bytes be in fr.to_buffer() ?\\n        let item_bytes = inputs[i].to_be_bytes(32);\\n        for j in 0..32 {\\n            bytes.push(item_bytes[j]);\\n        }\\n    }\\n\\n    sha256_to_field(bytes.storage)\\n}\\n\\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\\n    if msg.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_l2_to_l1_hash(\\n            msg.contract_address,\\n            msg.message.recipient,\\n            msg.message.content,\\n            rollup_version_id,\\n            chain_id\\n        )\\n    }\\n}\\n\\n// Computes sha256 hash of 2 input hashes.\\n//\\n// NB: This method now takes in two 31 byte fields - it assumes that any input\\n// is the result of a sha_to_field hash and => is truncated\\n//\\n// TODO(Jan and David): This is used for the encrypted_log hashes.\\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\\n//\\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\\n    // This is a note about the cpp code, since it takes an array of Fields\\n    // instead of a U128.\\n    // 4 Field elements when converted to bytes will usually \\n    // occupy 4 * 32 = 128 bytes.\\n    // However, this function is making the assumption that each Field \\n    // only occupies 128 bits.\\n    //\\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\\n\\n    // Concatentate two fields into 32x2 = 64 bytes\\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\\n    let mut hash_input_flattened = [0; 64];\\n    for offset in 0..input.len() {\\n        let input_as_bytes = input[offset].to_be_bytes(32);\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n\\n    sha256_to_field(hash_input_flattened)\\n}\\n\\n// Computes the final logs hash for a tx.\\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\\n// to avoid doubling code, since we can\'t define the byte len to be 32*N directly. \\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n    // Ideally we would push to a slice then hash, but there is no sha_slice\\n    // Hardcode to 256 bytes for now\\n    let mut hash = sha256_to_field(hash_input_flattened);\\n    // Not having a 0 value hash for empty logs causes issues with empty txs\\n    // used for padding. Returning early is currently unsupported.\\n    // We always provide sorted logs here, so 0 being empty means all are empty.\\n    if is_empty(logs[0]) {\\n        hash = 0;\\n    }\\n    hash\\n}\\n\\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n    // Ideally we would push to a slice then hash, but there is no sha_slice\\n    // Hardcode to 256 bytes for now\\n    let mut hash = sha256_to_field(hash_input_flattened);\\n    // Not having a 0 value hash for empty logs causes issues with empty txs\\n    // used for padding. Returning early is currently unsupported.\\n    // We always provide sorted logs here, so 0 being empty means all are empty.\\n    if is_empty(logs[0]) {\\n        hash = 0;\\n    }\\n    hash\\n}\\n\\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\\n}\\n\\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\\n}\\n\\n#[test]\\nfn smoke_sha256_to_field() {\\n    let full_buffer = [\\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\\n    ];\\n    let result = sha256_to_field(full_buffer);\\n\\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\\n\\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\\n    let result_bytes = sha256(full_buffer);\\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\\n    assert(truncated_field == result);\\n    let mod_res = result + (result_bytes[31] as Field);\\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\\n}\\n\\n#[test]\\nfn compute_l2_l1_hash() {\\n    // All zeroes\\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\\n\\n    // Non-zero case\\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\\n}\\n"},"241":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr","source":"use crate::{\\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\\n    traits::{Deserialize, Empty, Serialize}\\n};\\n\\nstruct PartialStateReference {\\n    note_hash_tree: AppendOnlyTreeSnapshot,\\n    nullifier_tree: AppendOnlyTreeSnapshot,\\n    public_data_tree: AppendOnlyTreeSnapshot,\\n}\\n\\nimpl Eq for PartialStateReference {\\n    fn eq(self, other: PartialStateReference) -> bool {\\n        self.note_hash_tree.eq(other.note_hash_tree) &\\n        self.nullifier_tree.eq(other.nullifier_tree) &\\n        self.public_data_tree.eq(other.public_data_tree)\\n    }\\n}\\n\\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\\n        let serialized_public_data_tree = self.public_data_tree.serialize();\\n\\n        [\\n            serialized_note_hash_tree[0], \\n            serialized_note_hash_tree[1],\\n            serialized_nullifier_tree[0],\\n            serialized_nullifier_tree[1],\\n            serialized_public_data_tree[0],\\n            serialized_public_data_tree[1],\\n        ]\\n    }\\n}\\n\\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\\n        PartialStateReference {\\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\\n                [serialized[0], serialized[1]]\\n            ),\\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\\n                [serialized[2], serialized[3]]\\n            ),\\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\\n                [serialized[4], serialized[5]]\\n            ),\\n        }\\n    }\\n}\\n\\nimpl Empty for PartialStateReference {\\n    fn empty() -> Self {\\n        Self {\\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\\n        }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let partial = PartialStateReference::empty();\\n    let _serialized = partial.serialize();\\n    let _deserialized = PartialStateReference::deserialize(_serialized);\\n}\\n"},"243":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr","source":"use crate::{\\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\\n    abis::gas_settings::GasSettings\\n};\\n\\n// docs:start:tx-context\\nstruct TxContext {\\n    chain_id : Field,\\n    version : Field,\\n    gas_settings: GasSettings,\\n}\\n// docs:end:tx-context\\n\\nimpl TxContext {\\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\\n        TxContext { chain_id, version, gas_settings }\\n    }\\n}\\n\\nimpl Eq for TxContext {\\n    fn eq(self, other: Self) -> bool {\\n        (self.chain_id == other.chain_id) &\\n        (self.version == other.version) &\\n        (self.gas_settings.eq(other.gas_settings))\\n    }\\n}\\n\\nimpl Empty for TxContext {\\n    fn empty() -> Self {\\n        TxContext {\\n            chain_id: 0,\\n            version: 0,\\n            gas_settings: GasSettings::empty(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\\n\\n        fields.push(self.chain_id);\\n        fields.push(self.version);\\n        fields.extend_from_array(self.gas_settings.serialize());\\n\\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\\n        let mut reader = Reader::new(serialized);\\n\\n        let context = Self {\\n            chain_id: reader.read(),\\n            version: reader.read(),\\n            gas_settings: reader.read_struct(GasSettings::deserialize),\\n        };\\n\\n        reader.finish();\\n        context\\n    }\\n}\\n\\nimpl Hash for TxContext {\\n    fn hash(self) -> Field {\\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let context = TxContext::empty();\\n    let serialized = context.serialize();\\n    let deserialized = TxContext::deserialize(serialized);\\n    assert(context.eq(deserialized));\\n}\\n\\n#[test]\\nfn empty_hash() {\\n    let context = TxContext::empty();\\n    let hash = context.hash();\\n\\n    // Value from tx_context.test.ts \\"computes empty item hash\\" test\\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\\n    assert_eq(hash, test_data_empty_hash);\\n}\\n"},"249":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr","source":"use crate::{\\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\\n    utils::arr_copy_slice\\n};\\n\\nstruct StateReference {\\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\\n    partial: PartialStateReference,\\n}\\n\\nimpl Eq for StateReference {\\n    fn eq(self, other: StateReference) -> bool {\\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\\n        self.partial.eq(other.partial)\\n    }\\n}\\n\\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\\n\\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\\n        fields.extend_from_array(self.partial.serialize());\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\\n        let mut offset = 0;\\n\\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\\n\\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\\n\\n        StateReference {\\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\\n            partial: PartialStateReference::deserialize(partial_fields),\\n        }\\n    }\\n}\\n\\nimpl Empty for StateReference {\\n    fn empty() -> Self {\\n        Self {\\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\\n            partial: PartialStateReference::empty(),\\n        }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let state = StateReference::empty();\\n    let _serialized = state.serialize();\\n    let _deserialized = StateReference::deserialize(_serialized);\\n}\\n"},"263":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\\n    data: [Field; N],\\n    offset: u32,\\n}\\n\\nimpl<N> Reader<N> {\\n    pub fn new(data: [Field; N]) -> Self {\\n        Self { data, offset: 0 }\\n    }\\n\\n    pub fn read(&mut self) -> Field {\\n        let result = self.data[self.offset];\\n        self.offset += 1;\\n        result\\n    }\\n\\n    pub fn read_u32(&mut self) -> u32 {\\n        self.read() as u32\\n    }\\n\\n    pub fn read_bool(&mut self) -> bool {\\n        self.read() as bool\\n    }\\n\\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\\n        for i in 0..K {\\n            result[i] = self.data[self.offset + i];\\n        }\\n        self.offset += K;\\n        result\\n    }\\n\\n    // TODO(#4394)\\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\\n        let result = deserialise(self.read_array([0; K]));\\n        result\\n    }\\n\\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\\n        for i in 0..C {\\n            result[i] = self.read_struct(deserialise);\\n        }\\n        result\\n    }\\n\\n    pub fn finish(self) {\\n        assert(self.offset == self.data.len(), \\"Reader did not read all data\\");\\n    }\\n}\\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\\n// because there is no criteria for what we should not put in here.\\n// Reducing the size of this package would be welcome.\\n\\nmod arrays;\\nmod field;\\nmod reader;\\nmod uint256;\\n\\n// if predicate == true then return lhs, else return rhs\\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\\n    if predicate { lhs } else { rhs }\\n}\\n\\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\\n    let iterator_len = if N > M { M } else { N };\\n    for i in 0..iterator_len {\\n        dst[i] = src[i + offset];\\n    }\\n    dst\\n}\\n"},"289":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\\n};\\n\\nstruct EthAddress{\\n    inner : Field\\n}\\n\\nimpl Eq for EthAddress {\\n    fn eq(self, other : Self) -> bool {\\n        self.to_field() == other.to_field()\\n    }\\n}\\n\\nimpl Empty for EthAddress {\\n    fn empty() -> Self {\\n        Self {\\n            inner : 0\\n        }\\n    }\\n}\\n\\nimpl ToField for EthAddress {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\\n        [self.inner]\\n    }\\n}\\n\\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\\n        EthAddress::from_field(fields[0])\\n    }\\n}\\n\\nimpl EthAddress {\\n    pub fn zero() -> Self {\\n        Self { inner: 0 }\\n    }\\n\\n    pub fn from_field(field: Field) -> Self {\\n        field.assert_max_bit_size(160);\\n        Self { inner: field }\\n    }\\n\\n    pub fn is_zero(self) -> bool {\\n        self.inner == 0\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n\\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\\n        Self { inner: result }\\n    }\\n}\\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\\n};\\n\\n// Aztec address\\nstruct AztecAddress {\\n    inner : Field\\n}\\n\\nimpl Eq for AztecAddress {\\n    fn eq(self, other : Self) -> bool {\\n        self.to_field() == other.to_field()\\n    }\\n}\\n\\nimpl Empty for AztecAddress {\\n    fn empty() -> Self {\\n        Self {\\n            inner : 0\\n        }\\n    }\\n}\\n\\nimpl ToField for AztecAddress {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl FromField for AztecAddress {\\n    fn from_field(value: Field) -> AztecAddress {\\n        AztecAddress { inner: value }\\n    }\\n}\\n\\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\\n        [self.to_field()]\\n    }\\n}\\n\\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\\n        FromField::from_field(fields[0])\\n    }\\n}\\n\\nimpl AztecAddress {\\n    pub fn zero() -> Self {\\n        Self { inner: 0 }\\n    }\\n\\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\\n        AztecAddress::from_field(\\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\\n        )\\n    }\\n\\n    pub fn is_zero(self) -> bool {\\n        self.inner == 0\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n\\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\\n        Self { inner: result }\\n    }\\n}\\n\\n#[test]\\nfn compute_address_from_partial_and_pub_keys_hash() {\\n    let pub_keys_hash = PublicKeysHash::from_field(1);\\n    let partial_address = PartialAddress::from_field(2);\\n\\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\\n}\\n\\n#[test]\\nfn from_field_to_field() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(FromField::from_field(address.to_field()), address);\\n}\\n\\n#[test]\\nfn serde() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\\n}\\n"},"398":{"path":"/usr/src/noir-projects/noir-contracts/contracts/multi_call_entrypoint_contract/src/main.nr","source":"// An entrypoint contract that allows everything to go through. Only used for testing\\n// Pair this with SignerlessWallet to perform multiple actions before any account contracts are deployed (and without authentication)\\ncontract MultiCallEntrypoint {\\n    use dep::std;\\n\\n    use dep::aztec::prelude::AztecAddress;\\n    use dep::authwit::entrypoint::app::AppPayload;\\n\\n    #[aztec(private)]\\n    fn entrypoint(app_payload: AppPayload) {\\n        app_payload.execute_calls(&mut context);\\n    }\\n}\\n"}}}'));class Fd{constructor(e,t,n=Nr.ZERO){this.chainId=e,this.version=t,this.address=n}async setAddress(){this.address=await async function(){return(await async function(){return await Oc(Pd,1,[])}()).address}()}async createTxExecutionRequest(e){const{calls:t,authWitnesses:n=[],packedArguments:s=[]}=e,r=await kd.fromAppExecution(t),a=this.getEntrypointAbi(),i=await xc.fromValues(Yr(a,[r])),o=e.fee?.gasSettings??ui.default(),l=Cc.from({firstCallArgsHash:i.hash,origin:this.address,functionSelector:Ur.fromNameAndParameters(a.name,a.parameters),txContext:new fi(this.chainId,this.version,o),argsOfCalls:[...r.packedArguments,...s,i],authWitnesses:n});return Promise.resolve(l)}getEntrypointAbi(){return{name:"entrypoint",isInitializer:!1,functionType:"private",isInternal:!1,isStatic:!1,parameters:[{name:"app_payload",type:{kind:"struct",path:"authwit::entrypoint::app::AppPayload",fields:[{name:"function_calls",type:{kind:"array",length:4,type:{kind:"struct",path:"authwit::entrypoint::function_call::FunctionCall",fields:[{name:"args_hash",type:{kind:"field"}},{name:"function_selector",type:{kind:"struct",path:"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",fields:[{name:"inner",type:{kind:"integer",sign:"unsigned",width:32}}]}},{name:"target_address",type:{kind:"struct",path:"authwit::aztec::protocol_types::address::AztecAddress",fields:[{name:"inner",type:{kind:"field"}}]}},{name:"is_public",type:{kind:"boolean"}},{name:"is_static",type:{kind:"boolean"}}]}}},{name:"nonce",type:{kind:"field"}}]},visibility:"public"}],returnTypes:[]}}}Dc(JSON.parse('{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"AuthRegistry","functions":[{"name":"is_consumable","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/+2aWU8jRxDH2xchju1hbGxsbMCA72MwxrAoWfYxT3mLFClPUW5FyiHlUJSvmE+VrqquqRkGzapWmxZa7UiD29X/X9fRY3tKw8iUjNmvGHucGHeUrcU0zJ59KcD5yvDIDor2LDRMgU1jmASqOHYyU8IRCMs4sh5M5cL+qY0NrbBfvoWJMqw1MgWAPqgYZGFoz70RDnf2rI45sH2ah6MKf0gD2IcjmbELfmpfPyLxvhPXxkUymppgNdJUaYjoX2JmtI4oCOqC1gWtO/RXMTPaQBQEDUEbgjYc+q2YGQ0QBUEgaCBo4NA/xczoAaIgOBD0QNADh/4kZkZDREEQChoKGjr0NzEz2kQUBE1Bm4I26TWL1PMR620oZkZbiIKgJWhL0FbWWyvOLQex3v4QM6OHiILgUNBDQQ8d+pWYGW0jCoK2oG1B29lA2/HWK5FQj9T1SEuP1PIRW7lfxMxoB1EQdATtCNpx6NdiZvQIURAcCXok6JFDvxEzo11EQdAVtCto16E/i5nRHqIg6AnaE7Tn0O/FzOgxoiA4FvRY0ONsZY/jT4ASaeiRjh6pe8kl9BJYNx+xW/qPmBntIwqCvqB9QftZb/24DErkSI/0vATW0CMdPdL1grymYvYq+E7MjA4QBcFA0IGgg6y3QVxsJdLSI4Ee6XjxcqBHGl5y6XpBjvORc7DX5T75FkEjN8d8NwxqM+Y7Zrti2chxgq5O0q5OCR7QkGfgRvxUREO53z7fw+G501+4+/nLAgovwQQnRlyld5wu2C7HLDsTxzRRJCNMsochvA4hhkRYjwK+K7hsb0mDOca1KUltTtI9xJ7kdDIyFZM+YJUBNkXoyW1IyS1TxWAH9DXAC1YT8/SaRcr5SCokTub0k3JCU6KdeRwvHGcUL9TwrILDqntbHqE7c05dV5nLS05eQl3iil1IxUbpil1KeCO74Od0qZXcloN4gknCUhPBJqQZ0RBes0igR8J8xAb4u5gZnSIKgqmgU0GnWW/T+JsjB7HefhQzozNEQTATdCboLOttFv/0KJGmHmnpka4eCfVI8NbTt/uzETOjc0RBMBd0Lug8620ee1MidT0S6pHASy4dPdL1grymYvYq+FvMjC4QBcFC0IWgi6y3RfwpVSL9fMQGGImZ0SWiIFgKuhR0mfW2jLdWiYz1SKBHQj0y0SMdPTLVIz0v+9LSI10v+xJ4yeUNKtbWIzUvuQTP9YIJvHzEJs+hYvaL9gcxM7pCFAQrQVeCrrLeVnFOSiTUI2090sxHbBmuxczoGlEQrAVdC7rOelvHP1E5CLQcxY+l73hA0Eizwd0FqKmLHdGKyS42QldR2tUVwWsa8gw0Nlciupb+ZUtd7Nbpb1wXu6MuFtrMGzgx4hf0jtMFZjdm2UYc00SRjDDJHqDE26FdKRnWo4Cxi4VsH6Txi+LalKU2kUn1ZInOPCJRmauDoVSf3JLIuX4SqeQjEt86bkwjt8ia2s7ItZ0Vajcrrt2sSvqbp7Z9k07tapSc4SsJRNfxrcp1YndJs3EFfxIJ9EioRyZ6pKNHpnqkp0eaeqSlR7pe9iXwkv7Mi5f6O1SxjpcLxs81NvfyqezrkYWXrXz/nfz+O/n/3v2Wl4q19UjNSy7Bc71gAi8fsclzrdjSSy6hlyv5DdJfvfWfJGgZSl9K3/CAoEm3BMapqV3c0IrJdnGLrrZpV66du6Yhz7ykTpBFt9J/3FG7eOf0L1y7eE/t4j2Y4MSIv6B3nC4w92OW7cQxTRTJCJPsAR7u3g3t+88SYT0KGNvFDbWLjx8FYstFjwJhqpJI+6lHxjfprms75fa6YFLPKm/24meVgOwwWfgPiB0G4w5+bA0y6ZKjRtwXVl85/3jKv5eSqRE/ttzSEDYuQiRyZwJB05gntzgCoHgJw+6/cP4H0PaWlvIqAAA=","debug_symbols":"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"},{"name":"set_authorized","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"},{"name":"authorize","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/+2Z227bRhCGV8faUeIkNilK1ImSSMmS6ti+aC/auFcF+gC96mXRJrnJAcgBecc8VXZmdviToaBgg4QwghCgSM7+38zsLCl5zNS0jDlqG7tNjNvs1ZE5MV17aND+h9Eze9K0e+PENNQkOnLSYl1L9qKOTRkNkvdm5twZsZGwnTnUdBb24+QXo0k9pI9uatTlcaZZ/mTYSNsxfYiG/B6lGElNx5Q38nKHszZ3ZG+JN3bTy5puoAeHPdEcyykdq0j3MFJKSSdz9/d2QUP+7lbzpe2e5HuP9o6Ecpe2NBTO3O/wkYbuUwUlyGO7n+YVe4CKnZYr9hDpnVqHf9vjmYgfOHHAkzyjM2CBaE7llNG3MCsaMkqCEGgINHToK5gV7TNKgj7QPtC+Q1/DrGjEKAkioBHQyKH/wqzogFESDIAOgA4c+gxmRYeMkmAIdAh06NAnMCsaM0qCGGgMNHZoArOiI0ZJMAI6Ajpy6BuYFR0zSoIx0DHQsUOfw6zohFESTIBOgE7kWEVCfyTwR+LDiJ3TFcyKThklwRToFOi0Gm2aRzuA2GgvYVZ0xigJZkBnQGfVaLO8gp5I4I/E/kjkj4xrQT5TMbs+72FWNGGUBAnQBGhSjZbkT/EBxEb7H2ZF54ySYA50DnTu0EcwK7pglAQLoAugi2qii3yJPZEzfyTwR0J/pO+PRP7IwB8Z1rIuI39kXMu6BLXM5TMVs8/NC5gVXTJKgiXQJdClQ9/BrGjKKAlSoCnQtJpoms/NEwn8kfi2Jhb5I/3bUDF7FzyFWdGMURJkQDOgWTVals/JEwn9kYU/Eh9GbBmuYVZ0xSgJVkBXQFfVaKv8J+sAQsONv9DP3DBo0MRo10Jqji9satoG25pDrcuhzgVeyamOUMN0DtEWfdGuy6c7p//ZFoIUFw0WXpCJds74T7nS6RJzkalsg8Ay0BQjDWqELR0T6+m3QlqfJPxrw832Bg3lOq9NF7VZl3u9k7Q40hKtVIdT6e1dkrULvRdpH0aQ3ypveNfOyaqT+6J2ttfR7pnb2Damv9m37Jvy1M7T4ojeSSTa5n+6bAurK5qNK/heJPBHQn+k749E/sjAHxn6I7E/MvJHxrWsS1DL9Ce1RJl+RxWLarlh6rnHZrU8lYk/Mq9lKX98J//4Tv7Wqz+qpWILf2RZy1yC23rDBLU8Yv3bWrG0lrmEtdzJXzD97Kv/JNFw8yn6hhsGTbklME4t7eJGPBbbxR2H2pVDuXZuK6c68lg6QRU9Qv9xKe3ipdNfuXbxWtpFaqHp7cMVZ/yfXOl0ibnOVHaBwDLQFCMNagT6j/BlYj39U0jrk4S5XaTZ3si7RHrNWHhfucvL1EGZduX2qp0WR1rOyS5fnd7e1cn72fOGI+i4XlLAwQfaPwJpU8mGhB4AAA==","debug_symbols":"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"},{"name":"set_authorized_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"approver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"},{"name":"authorize","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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5Lw6qrXyUoeVlzqsvNRRraq18lKHlZc6rLzUYeWlDicvtd2cvNR2c/JS283JS203Jy+13apVtU5ears5eant5uSltpuTl9puVl4q07b7jmqtvFSmze4d1Vp5qUxbzDuqtfJSmTZ2d1Rr5aUybafuqNbKS2XaxNxRrZWXyrR1uKNaKy+VacNuR7VWXirTNtmOaq28VKbNqR3VWnmpTFtCO6q18lKZNmJ2VGvlpTJtf+yo1spLZdp02FGtlZfKtNWvo1orL5Vpg11HtVZeKtO2to5qrbxUps1kHdVaealMW7g6qrXyUpk2TnVUa+WlMm1X6qjWyktl2iTUUa2Vl8q0NaejWisvlWlDTEe1Vl4q0zaUjmqtvFSmzR8d1Vp5qUxbLjqqtfJSmTY6dFRr5aUybS/oqNbKS2Wa1N9RrZWXyjTxvqNaKy+VaSp9R7VWXirT5PiOaq28VKbp7h3VWnmpTBPYO6q18lKZpqR3VGvlpazmnm9Wc883q7nnm9Xc881q7vlmNfd8s5p7vlnNPd+s5p5vVnPPN6u555vV3PPNau75ZjX3fLOae75ZzT3frOaeb1Zzz3eruee71dzz3Wru+W4193y/VatqnbzUbjX3fLeae75bzT3freae71Zzz3eruee71dzz3Wru+W4193y3mnu+W809363mnu9Wc893q7nnu9Xc891q7vluNfd8t5p7vlvNPd+t5p7vVnPPd6u557vV3PPdau75bjX3fLeae75bzT3freae71Zzz3eruee71dzz3Wru+W4193y3mnu+W809363mnu9Wc893q7nnu9Xc891q7vluNfd8t5p7vlvNPd+t5p7vVnPPd6u557vV3PPdau75bjX3fLeae75bzT3freae71Zzz3eruee71dzz3Wru+W4193y3mnu+W809363mnu9Wc893q7nnu9Xc891q7vluNfd8t5p7vlvNPd+t5p7vVnPPd6u557vV3PPdau75bjX3fLeae75bzT3freae71Zzz3eruee71dzz3Wru+W4193y3mnu+W809363mnu9Wc893q7nnu9Xc891q7vluNfd8t5p7vlvNPd+t5p7vVnPPd6u554fV3PPDau75YTX3/LCae37cqlW1Tl7qsJp7fljNPT+s5p4fVnPPD6u554fV3PPDau75YTX3/LCae35YzT0/rOaeH1Zzzw+rueeH1dzzw2ru+WE19/ywmnt+WM09P6zmnh9Wc88Pq7nnh9Xc88Nq7vlhNff8sJp7fljNPT+s5p4fVnPPD6u554fV3PPDau75YTX3/LCae35YzT0/rOaeH1Zzzw+rueeH1dzzw2ru+WE19/ywmnt+WM09P6zmnh9Wc88Pq7nnh9Xc88Nq7vlhNff8sJp7fljNPT+s5p4fVnPPD6u554fV3PPDau75YTX3/LCae35YzT0/rOaeH1Zzzw+rueeH1dzzw2ru+WE19/ywmnt+WM09P6zmnh9Wc88Pq7nnh9Xc88Nq7vlhNff8sJp7fljNPT+s5p4fVnPPD6u554fV3PPDau75YTX3/LCae35YzT0/rOaeH1Zzzw+rueeH1dzzw2ru+WE19/ywmnt+WM09P6zmnh9Wc88Pq7nnh9Pc8+3mNPf8Xq2Rl7pXa+Sl7tUaeal7tdWqWiMvda/WyEvdqzXyUvdqjbzUvVorL+U09/xerZWXcpp7fq/Wyks5zT2/V2vlpZzmnt+rtfJSTnPP79VaeSmnuef3aq28lNPc83u1Vl7Kae75vVorL+U09/xerZWXcpp7fq/Wyks5zT2/V2vlpZzmnt+rtfJSTnPP79VaeSmnuef3aq28lNPc83u1Vl7Kae75vVorL+U09/xerZWXcpp7fq/Wyks5zT2/V2vlpZzmnt+rtfJSTnPP79VaeSmnuef3aq28lNPc83u1Vl7Kae75vVorL+U09/xerZWXcpp7fq/Wyks5zT2/V2vlpZzmnt+rtfJSTnPP79VaeSmnuef3aq28lNPc83u1Vl7Kae75vVorL+U09/xerZWXcpp7fq/Wyks5zT2/V2vlpZzmnt+rtfJSTnPP79VaeSmnuef3aq28lNPc83u1Vl7Kae75vVorL+U09/xerZWXcpp7fq/Wyks5zT2/V2vlpZzmnt+rtfJSTnPP79U6ealiNfe8WM09L1Zzz4vV3PN7LVbVOnmpYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc89LptnY91PfnqeejsZ7v3OOeZ6XXy+e5718neOof/Odp9v0ePF0276zO169834833lqvPNSp1+vXer8WvtE7gPt39Q+kRdD+ze1r2hvq30in472b2qfKLWg/ZvaJ8pwaP+m9okSLdq/qX2iz0rQ/i3tp0ybSdD+Te3p6/lqT18vq/b7A8ZyLK+1p6/nq31Fe1vt6ev5ak9fL6v225f262vt6ev5ak9fz1d7+nq22mfakof2b2pPX89Xe/p6WbVfHt/TXdbttfb09Xy1r2hvqz19PV/t6ev5ak9fz1d7+nq+2tPXs9U+08ZmtH9Te/p6vtrT1/PVnr6er/YV7W21p6/nqz19PV/t6ev5ak9fz1d7+nq22s/09Xy1p6/nqz19PV/t6ev5al/R3lZ7+nq+2tPX89Wevp6v9vT1fLWnr2erfaWv56s9fT1f7enr+WpPX89X+4r2ttrT1/PVnr6er/b09Xy1p6/nqz19PVvtF/p6vtqT74dqf3+Hh0TlOGal9s29GUtFe1vtyfe+2pPvfbUn3/tqT7731Z58b6v9Sr731Z7v7fhqz/d2fLWnr+erfUX7pNo3dyOu9PV8taev56s9fT1f7enrZdW+uSNtpa9nq/1GX89Xe/p6vtrT1/PVnr6er/YV7ZNq3/ye7kZfz1d7+nq+2tPX89Wevp6v9vT1bLXf6ev5ak9fz1d7+nq+2tPX89W+or2t9vT1fLWnr+erPX09X+3p6/lqT1/PVvuDvp6v9vT1fLWnr+erPX09X+0r2ttqT1/PV3v6er7a09fz1Z6+nq/29PVctZ9v9PV8taev56s9fT1f7enr+Wpf0d5We/p6vtrT1/PVnr6er/b09Xy1p69nq32hr+erPX09X+3p6/lqT77Xa6/cbjEXUnh0hcjK0RUi0UZXiNwZXKGJdBhdITJcdIVIWtEV4nsO0RWqKBRcIXoK0RWipzBWodaOs3mipxBdIXoK0RWipxBcoZmewliFWjt45pmeQnSF6ClEV4ieQnSFKgoFV4ieQnSF6CmMVaj5XZ+ZnkJ0hegpRFeInkJwhSo9hegK0VOIrhA9hegK0VOIrlBFoeAK0VOIrhA9hegK0VOIrhA9hegK0VMIrtBCTyG6QvQUoitETyG6QvQUoitUUSi4QvQUoitETyG6QvQUoitETyG6QvQUgiu00lOIrhA9hegK0VOIrhA9hegKVRQKrhA9hegK0VOIrhA9hegK0VOIrhA9heAKbfQUoitETyG6QvQUoitETyG6QhWFgitEHupRqOwPHvM0rUqFmjMaN/JQdIXIQ8EV2slD0RUiD0VXiDwUXSHyUHSFKgoFV4jPWKMrxGes0RWipxBdIXoKYxVqTkTf6SkEV+igpxBdIXoK0RWipzBWoeY054OeQnSFKgoFV4ieQnSF6ClEV4ieQnSF6CmMVaj5XZ+DnkJsheqNnkJ0hegpRFeInkJ0hegpRFeoolBwhegpRFeInkJ0hegpRFeInkJ0hegpBFeo0FOIrhA9hegK0VOIrhA9hegKVRQKrhA9hegK0VOIrhA9hegK0VOIrhA9heAKTfQUoitETyG6QvQUoitETyG6QhWFgitETyG6QvQUoitETyG6QvQUoitETyG4QjM9hegK0VOIrhA9hegK0VOIrlBFoeAK0VOIrhA9hegKkYe6FLo9QM7lW4U/MKOxVvJQdIXIQ9EVIg9FV4g8FF2hikLBFSIPRVeIPBRdIT5jja4Qn7FGV4ieQnCFFnoKYxVqTUSvCz2F6ArRU4iuED2F6ApVFBqqUGuac13oKURXiJ5CdIXoKURXiJ5CdIXoKQRXaKWnMFah5nd9VnoK0RWipxBdIXoK0RWqKBRcIXoK0RWipxBdIXoK0RWipxBdIXoKwRXa6ClEV4ieQnSF6ClEV4ieQnSFKgoFV4ieQnSF6ClEV4ieQnSF6ClEV4ieQnCFdnoK0RWipxBdIXoK0RWipxBdoYpCwRWipxBdIXoK0RWipxBdIXoK0RWipxBcoYOeQnSF6ClEV4ieQnSF6ClEV6iiUHCF6ClEV4ieQnSF6ClEV4ieQmyFlht5qEeh27w8FLrtN6VCrRmNy408FF0h8lB0hSoKBVeIPBRdIfJQdIXIQ9EVIg9FV4jPWIMrVPiMNbpC9BSiK0RPYaxCrYnoS6GnEF2hikLBFaKnEF0hegpjFWpNc14KPYXoCtFTiK4QPYXgCk30FKIrRE8hukL0FMYq1Pyuz0RPIbpCFYWCK0RPIbpC9BSiK0RPIbpC9BSiK0RPIbhCMz2F6ArRU4iuED2F6ArRU4iuUEWh4ArRU4iuED2F6ArRU4iuED2F6ArRUwiuUKWnEF0hegrRFaKnEF0hegrRFaooFFwhegrRFaKnEF0hegrRFaKnEF0hegrBFVroKURXiJ5CdIXoKURXiJ5CdIUqCgVXiJ5CdIXoKURXiJ5CdIXoKURXiJ5CcIVWegrRFfLNQ9JJimuFo4Sjb7bQcvRNAFqOvj5dy9HXTWs5+npeKcfN15lqOfp+JqXl6PvJkZYjeUbDscJRMdl4I89oOJJnNBzJMxqO5Jkejs1poRt5RsJxJ89oOJJnNBzJMxqO5BkNxwpHxeeFO3lGw5E8o+FIntFwJM9oOJJnJBwP8oyGI3lGw5E8o+FIntFwrHCUcCTPaDiSZzQcyTMajuQZDUfyjILjeiPPaDiSZzQcyTMajuQZDccKRwlH8oyGI3lGw5E8o+FIntFwJM9IOBbyjIYjeUbDkTyj4Uie0XCscJRwJM9oOJJnNBzJMxqO5BkNR/KMhONEntFwJM9oOJJnNBxj+8dtekx+O/bp1uB4f/Xjxdv8utrYLk9dbWwvpq42tmNSVxvb14irnWO7j7eqfe9pf+z78yJ5/QSfYzuKsWxiu4SxbGJ3MseyqbA5ZZPIMcrZJPKXcjaJ3OjnEtv5mZ8cE/ncoRwTOeiRHKutNxdztPXxYo62nl/M0TYfiDlWOEo42uYOMUfbjCLmSJ7RcCTPaDiSZyQcg+/5vg5H8oyGI3lGw5E8o+FY4SjhSJ7RcCTPaDiSZzQcyTMajuQZCcfgO4avw5E8o+FIntFwJM9oOFY4SjiSZzQcyTMajuQZDUfyjIYjeUbCMfgG2yAcmxts1+AbbK/DkXtG8kvU4BtDr8ORe0bCMfjG0OtwpG+m4UjfTMMR/9jBcS3rr9eu8/SaY4WjhCN9Mw1H+mYajuQZDUfyjIYjeUbCMfjG0OtwJM9oOJJnNBzJMxqOFY4SjuQZDUffPPPGOe51Pyos8/qNx16/SPomGjVJ30yjJumbarQkt+CbQ69E0jfZqEn6Zhs1Sd908xbJfXmSPOprkhWSIpK+CUdNkoyjIknGUZEk46hIknFEJINvEw1Ist7Ka5JkHBVJMo6KJBmnh2Sd1ifJeXlNskJSRJKMoyJJxlGRJOOoSJJxVCTJOCKSwTeMDiH5ZENqOWdDDjlnQ7I4Z1Nhc8oG93/OBj9/zibTxtnWRrMt1cbZdrWZNs42q820cbaj2kT+sqPaRI6xo9pEHrCj2mpVbSKf1lFtIufVUa2Vl8q01bSjWisvlWlDaEe1Vl4q07bNjmqtvFSmzZUd1Vp5qUxbIDuqtfJSmTYqdlRr5aUybSfsqNbKS2Xa9NdRrZWXyrQ1r6NaKy+VaQNdR7VWXirTNreOaq28VKbNaB3VWnmpTFvGOqq18lKZNnZ1VGvlpTJtv+qo1spLZdok1VGtlZfarLzUZuWlNisvlWm/WEe11apaKy+1WXmpTHvYOqq18lKZdpq1q820eayjWisvlWmLV0e1Vl4q00asjmqtvFSm7VId1Vp5qUybmjqqtfJSmbYedVRr5aUybRDqqNbKS2XaxtNRrZWXyrTZpqNaKy+VaUNMR7VOXmrPtGmlo1onL7Vn2ljSUa2Tl9pv1apaJy+1Z9qg0VGtk5faM22i6KjWyktl2ujQUa2Vl8q0GaGjWisvlWnDQEe1Vl4q06T+jmqtvFSmifcd1Vp5qUyT4zuqtfJSmaa7d1Rr5aUyTWDvqNbKS2Wakt5RrZWXspp7vlvNPd+t5p7vVnPPd6u557vV3PPdau75bjX3fLeae75bzT3freae75lmY7+5O2k/nueYGq9d6vTrtUudX3P03Xmn5ei7H0/LscJRwtF3756Wo++OPi1H343bWo6++7a1HH23bUs5ZpoiP5QjeUbDkTzTw3F/vPFyLK85kmc0HCscJRzJMxqO5JkejtsXx/U1R/KMhiN5RsORPCPhmGmTw1CO5BkNR/JMD8fl8Xnhsr7+vDDTXouhHCscJRzJMxqO5BkNR/KMhiN5RsORPCPhmGmbylCO5BkNR/KMhiN5RsOxwlHCkTyj4Uie0XAkz2g4kmc0HMkzEo6ZNhoN5Uie0XAkz2g4kmc0HCscJRzJMxqO5BkNR/KMhiN5RsORPCPhmGmr2FCO5BkNR/KMhiN5RsOxwlHCkTyj4Uie0XAkz2g4kmc0HMkzCo5Hps1+QznG9o/r7clxPY4Gxzv1x4u3+XW11ara2F5MXW1sx6SuNravUVcb2328Ve17T/vmhMoj+Ba6oWyC76wbyyZ2J3Msm9jdybFsEjlGOZsKm1M2idzo5xLb+ZmfHBP53KEcEznooRxtvbmYo62P13IMvlvxOhxt84GYo22WEHO0zR1ijhWOEo7kGQ1H8oyGI3lGw5E8o+FInpFwDL7f9DocyTMajuQZDUfyjIZjhaOEI3lGw5E8o+FIntFwJM9oOJJnJBwreUbDkTyj4Uie0XAkz2g44nt6ftnS2tB4BN9gexmOwTeGRuHY/KVV8I2h1+HIPaPhWOEo4UjfTMORvpmGI/6xg+Na1l+vXefpNUf8o4YjfTMJx+AbQ6/DkTyj4Uie0XAkz2g4VjhKOJJnNBzJMxqO5BkNR/KMhiN5RsIx+MbQT3J84xx3CF88lm+T5Nbji6RvolGT9M00apK+qUZNskJSRNI32ahJ+mYbNUnfdPMWyW1+vvM+vSbpm2/UJH0Tjphk8C2iVyJJxlGRJOOoSJJxVCQrJN8lebwmScZRkSTjqEiScU5/7RF8T+hYNuSQUzbB93mOZUNWOGeD+z9ng58/Z1MT7ZtpzqoPvsVSXW2mzUntajNtTmpXm8hfdlSbyDG2qt1vwXcgqqtN5Oo6qk3k0zqqzbSFsl1ttarWyEvdqzXyUvdqjbzUvVojL3Wv1spLZdoU2VGtlZfKtM2xo1orL5Vp42JHtVZeKtOmw45qrbxUpq2BHdVaealMG/g6qrXyUpm22XVUa+WlMm2G66jWyktl2rLWUa2Vl8q0sayjWisvlWn7V0e1Vl4q0yatjmqtvFSmrVQd1Vp5qUwbnjqqtfJSmbYldVRr5aUybR7qqNbKS2Xa4tNRrZWXqtWqWisvVa28VKbdTh3VWnmpauWlFisvlWkHVke1Vl4q0z6pjmqrVbVWXirTBqWOaq28VKZtRB3VWnmpTJt9Oqq18lKZtuR0VGvlpTJtnOmo1spLZdre0lGtlZfKtAmlo1orL5Vpq0hHtVZeKtN2jo5q2cP2Hzr2Idfp12uXOr/myB42DUf2sGk4sodNw5E9bBKOxjsKtBzZK63hyF5pDUf2Sms4VjhKOJJnNBzJMz0c98cbL8fymiN5RsORPKPhSJ6RcDTejPAOx+2L4/qaI3lGw5E8o+FIntFwrHCUcCTPaDiSZ3o4Lo/PC5f19eeFmfZaDOVIntFwJM8oOJZMWz6GciTPaDiSZzQcyTMajhWOEo7kGQ1H8oyGI3lGw5E8o+FInpFwzLRpZyhH8oyGI3lGw5E8o+FY4SjhSJ7RcCTPaDiSZzQcyTMajuQZCcdM266GciTPaDiSZzQcyTMajhWOEo7kGQ1H8oyGI3lGw5E8o+FInpFwzLRxbihH8oyGI3lGw5E8o+FY4SjhGNs/1qk+OC7b3uB4bI9f7R/b/Lra2C5PXW1sLyauNvheOXW1sX2NutrY7uOtat972jcnVJbgW+jGsqmwOWUTu5M5lk3s7uRYNokco5xNIn8pZ5PIjX4usZ2f+cEx+M6/63BM5KCHcrT15mKOtj5ezLHCUcLRNh+IOdpmCTFH29wh5mibUcQcyTMSjsH3bl6HI3lGw5E8o+FIntFwrHCUcCTPaDiSZzQcyTMajuQZDUfyjIRj8N231+FIntFwJM9oOJJnNBwrHCUcyTMajuQZDUfyjIYjeUbDkTwj4Rh8M/V1OJJnNBzJMxqO5BkNxwpHCUfyjIYjeUbDkTyj4Uie0XAkz0g4Bt9gG4TjUh+/yV7qCccKRwlH7pkejs1JJsE3hl6HI/eMguMUfGPodTjSN9NwpG+m4Yh/7OC4lvXXa9d5es2xwlHCkb6ZhiN9Mw1H8oyGI3lGw5E8I+EYfGPodTiSZzQcyTMajuQZDccKRwlH8oyGI3lGw5E8o+FIntFwJM9IOAbfGHodjr555o1zlPlZYanfqJfteMVjeawPmbbymrpv+hlJ3TcrjaReoT6Aum8OE1F/kvRNYmqSvllMTdI3jalJ+uYxMcngO0+vRJJMpiJJzlKRJDupSFZIikiScXpI1vX5zsu3V79OluUO/vHqUr+der99cScRjeFOfpJzl/46ccq0oTipQuS94Apl2gSdVCHyaXSFyL3RFSJPR1eoolBwhcj/0RWiUxBdIXoK0RWipxBdIXoKwRVa6ClEV4ieQnSF6ClEV4ieQnSFKgoFV4ieQnSF6ClEV4ieQnSF6ClEV4ieQnCFVnoK0RWipxBdIXoK0RWipxBdoYpCwRWipxBdIXoK0RWipxBdIXoK0RWipxBcoY2eQnSF6ClEV4ieQnSF6ClEV4g8NFSh5t7JaSMPBVdox8uNVai5C27Hy0VXCC8XXSG8XHSFKgoFV4jPh6IrRB4aqlB7j8FOHoquEJ8PRVeIz4eCK3TQU4iuED2F6ArRU4iuED2F6ApVFAquED2F6ArRU4iuED2F6ArRU9Ar9M47354vLrd9/Xrnb1PrD7oK0TWab/QV4mtEZyG+RvQW4mtEdyG+RhWNwmtEh2GwRvv+PPOxvdaIHkN8jegyxNeIPkN8jegzhNeo0GeIrxF9hvga0WcYrNHxta31tr/WiD5DfI0qGoXXiD5DfI3oM8TXiD5DfI3oM8TXiD5DHI3K688mJvoM8TWizxBfI/oMYzUq85dG9fV9NNFniK9RRaPwGtFniK8RfYb4GtFniK8RfYb4GtFn+EGNHtRnOgcjqNML6KG+1OVJfdkb1O/Pkuer9+kr30/3rP/kTr4fw53MLuc+TU8cdXn9lKlQH0CdXD2COkl5BHWy7wjqpNkR1MmneurL48XTVl5Sr+TTEdTJpyOok05HUCebjqBeoT6AOtl0BHWy6QjqZNMR1MmmI6iTTQdQX8imI6iTTbuob89vXCxHbVAvd2aPV5e5vuZOOh3DnXw6hnuF+xDuZNQx3EmpY7iTU8dwJ6mO4U5WHcJ9Ja2O4U5eHcOdvDqGO3l1DPcK9yHcyatjuJNXx3Anr47hTl4dw528OoT7Rl4dw528OoY7eXUMd/LqGO4V7kO4k1fHcCevjuFOXh3Dnbw6hjt5dQj3nbw6hjt5dQx38uoY7uTVMdwr3IdwJ6+O4U5eHcOdvDqGO3l1DHfy6hDuB3l1DHfy6hju5NUx3MmrY7hXuA/hTl4dw528OoY7eXUMd/LqGO7k1RHc6428OoY7eXUMd/LqGO7k1THcK9yHcCevjuFOXh3Dnbw6hjt5dQx38uoQ7oW8OoY7eXUMd/LqGO7k1THcK9yHcCevjuFOXh3Dnbw6hjt5dQx38uoQ7hN5dQx38uoY7uTVMdzJq2O4V7gP4U5eHcOdvDqGO3l1DHfy6hju5NUh3Gfy6hju5NUx3MmrY7iTV8dwr3Afwp28OoY7eXUMd/LqGO7k1THcyatDuFfy6hju5NUx3MmrY7iTV8dwr3Afwp28OoY7eXUMd/LqGO7k1THcyatDuC/k1THcyatjuJNXx3Anr47hXuE+hDt5dQx38uoY7uTVMdzJq2O4k1eHcF/Jq2O4k1fHcCevjuFOXh3DvcJ9CHfy6hju5NUx3MmrY7iTV8dwJ68O4b6RV8dwJ6+O4U5eHcOdvDqGe4X7EO7k1THcyatjuJNXx3Anr47hTl4dwn0nr47hTl4dw528OoY7eXUM9wr3IdzJq2O4k1fHcCevjuFOXh3Dnbw6hPtBXh3Dnbw6hjt5dQx38uoY7hXuQ7iTV8dwJ6+O4U5eHcOdvDqGO3l1BPflRl4dw528OoY7eXUMd/LqGO4V7kO4k1fHcCev/ukcTzZkynM25L5zNmSzUzaF/HTOhoxzzoYccs6GrHDOpsLmlA2e+5wNvvicDb74nE0iX3zs++PFx/a62kROt13tlMi7dlSbyI12VJvIX3ZUm8gxdlRbrapN5Oo6qk3k0zqqTeS8Oqq18lKTlZearbzUbOWlZisvNVt5qblaVWvlpWYrLzVbeanZykvNVl6qWnmpauWlqpWXqlZeqlaraq28VLXyUpm23XdUa+WlMm12b1ebaZ96R7VWXirT7vCOaq28VKY92R3VWnmpTDuhO6q18lKZ9h93VGvlpTLt+u2o1spLZdpr21GtlZfKtMO1o1orL5VpX2lHtVZeKtNuzo5qrbxUpj2UHdVaealMOxc7qrXyUpn2C3ZUa+WlMu3S66jWyktl2hvXUa2Vl8q0I62jWisvlWkfWEe1Vl4q0+6rjmqtvFSmPU8d1Vp5qUw7jTqqtfJSmfb3dFRr5aUy7arpqNbKS2Xay9JRrZWXyrSDpKNaKy+Vad9GR7VOXmrNtFuio1onL7Vm2qPQUa2Tl1pv1apaJy+1ZpqP31Gtk5daM82w76jWyktlmjPfUa2Vl8o0C76jWisvlWlee0e1Vl4q00z1jmqtvJTV3PPVau75ajX3fLWae75azT1freaer1Zzz1erueer1dzz1Wru+Wo193y1mnu+Ws09X63mnq9Wc89Xq7nnq9Xc89Vq7vlqNfd8tZp7vlrNPV+t5p6vVnPPV6u556vV3PPVau75ajX3fLWae75azT1freaer1Zzz1erueer1dzz1Wru+Wo193y1mnu+Ws09X63mnq9Wc89Xq7nnq9Xc89Vq7vlqNfd8tZp7vlrNPV+t5p6vVnPPV6u556vV3PPVau75ajX3fLWae75azT1freaer1Zzz1erueer1dzz1Wru+Wo193y1mnu+Ws09X63mnq9Wc89Xq7nnq9Xc89Vq7vlqNfd8tZp7vlrNPV+t5p6vVnPPV6u556vV3PPVau75ajX3fLWae75azT1freaer5lmY99PfXueejoa7/3OOUpdn++8fHt12Y5X77wfz3eeGu+81OnXa5c6v1YokUdIqdCWaQZ5UoUSebGkCiXyj0kVSuR5kypUUSi4QomyRVKFEvWWkyqUqB+eVCF6CtEVoqcwVqH98cbLsbxUKNMujqQK0VOIrhA9hegK0VMYq9D2pdD6WqGKQsEVoqcQXSF6CtEVoqcQXSF6CtEVoqcwVqHl8V2fZX35XZ8t006qpArRU4iuED2F6ArRU4iuUEWh4ArRU4iuED2F6ArRU4iuED2F6ArRUwiuUKbdjEkVoqcQXSF6CtEVoqcQXaGKQsEVoqcQXSF6CtEVoqcQXSF6CtEVoqcQXKFMO4qTKkRPIbpC9BSiK0RPIbpCFYWCK0RPIbpC9BSiK0RPIbpC9BSiK0RPIbhCCz2F6ArRU4iuED2F6ArRU4iuUEWh4ArRU4iuED2F6ArRUwiu0Oqbh6STFFff1KLl6JsttBx9E4CWY4WjhKOvm9Zy9PW8Wo6+zlTL0fczKS1H30+OpBw38oyGI3mmh2NzsvFGntFwJM9oOFY4SjiSZ3o4NqeFbuQZDUfyjIYjeUbDkTwj4biTZzQcyTOSzwt38oyGI3lGw7HCUcKRPKPhSJ7RcCTPaDiSZzQcyTMSjgd5RsORPKPhSJ7RcCTPaDhWOEo4kmc0HMkzGo7kGQ1H8oyGI3lGwXG/kWc0HMkzGo7kGQ1H8oyGY4WjhCN5RsORPKPhSJ7RcCTPaDiSZyQcC3lGw5E8o+FIntFwJM9oOFY4SjiSZzQcyTMajuQZDUfyjIYjeUbCcYrtH6dnAce83Rocj+3xq/1jm19XG9vlqautVtXGdkzqamP7GnW1sd3HW9W+97Q/9udbHydP8NiOYiyb2C5hKJs5didzLJvY3cmxbBI5RjmbRP5Szqa6snknsZ2f+ckxkc8dyjGRgx7K0dabizna+ngxR1vPr+UYfLv8dTjaZgkxR9vcIeZom1HEHCscJRzJMxqO5BkNR/KMhiN5RsORPCPhGHyz9XU4kmc0HMkzGo7kGQ3HCkcJR/KMhiN5RsORPKPhSJ7RcCTPSDgG30x9HY7kGQ1H8oyGI76n55ctrQ2Ne/ANtpfhGHxjaBSOzV9aBd8Yeh2O3DMajvTNNBwrHCUc6ZtpOOIfOziuZf312nWeXnPEP2o40jfTcKRvJuEYfGPodTiSZzQcyTMajuQZDccKRwlH8oyGI3lGw5E8o+FIntFw9M0zb5zjH2/3fOf5+yS59Uky+M7QK5H0zTRqkr6pRk3SN9eoSVZIikj6Zhs1Sd908xbJ9YvHH87xjaRvvlGT9E04apJkHA3JI/ge0SuRJOOoSJJxVCTJOG+T3F6TrJAUkSTjqEiScc5+7XEE3xM6lg055JwNyeKUTfAdnWPZ4P7P2eDnz9lk2pzUmlV/BN9iqa420+akdrWZNie1q03kLzuqTeQYO6pN5AHb1U6JXF1HtYl8Wke1mbZQtqu18lKptlC2q7XyUqm2ULartfJSmfZKdlRr5aUy7X7sqNbKS2Xaz9hRrZWXyrRDsaNaKy+VaR9hR7VWXirTbr+Oaq28VKY9eR3VWnmpTDvnOqq18lKZ9rd1VGvlpTLtQuuo1spLZdor1lGtlZfKtKOro1orL5Vp31VHtVZeKtPuqI5qrbxUpj1MHdVaealMO406qrXyUpn2A3VUa+WlMu3a6ajWykut1apaKy+VabdTR7VWXmq18lKrlZfKtAOro1orL5Vpn1RHtVZeKtNupo5qrbxUpj1HHdVaealMO4M6qrXyUpn273RUa+WlMu2y6ajWyktl2gvTUa2Vl8q0Y6WjWisvlWlfSUe1Vl4q0+aPjmqtvJTxtoJ39iHX6ddrlzq/5sgeNg1H9rBpOLKHTcORPWwajuyVFnA8bsYbCrQc2Sut4cheaQ1H9kprOFY4SjiSZ3o47o83Xo7lNUfyjIYjeUbDkTyj4Uie6eG4fXFcX3I03qKg5Uie0XAkz2g4kmc0HCscJRzJMz0cn8dY1u01R/KMhiN5RsORPKPhSJ6RcMy0P2QoR/KMhiN5RsORPKPhWOEo4Uie0XAkz2g4kmc0HMkzGo7kGQnHTDt8hnIkz2g4kmc0HMkzGo4VjhKO5BkNR/KMhiN5RsORPKPhSJ6RcMy0R2soR/KMhiN5RsORPKPhWOEo4Uie0XAkz2g4kmc0HMkzGo7kGQnHTLvshnIkz2g4kmc0HMkzGo6x/WO5PV583P+WBsdje/xq/9jm19XGdnnqamN7MXW1sR2TuNrge+XU1cZ2H29V+97TvjWh8s4mtqMYyya2SxjLpsLmlE3s7uRYNokco5xNIn8pZ5PIjX4usZ2f+ckxkc8dyTH4NsHrcLT15mKOtj5ezNHW84s5VjhKONpmCTFH29wh5mibUcQcyTMajuQZCcfgGz2vw5E8o+FIntFwJM9oOFY4SjiSZzQcyTMajuQZDUfyjIYjeUbCMfhW3etwJM9oOJJnNBzJMxqOFY4SjuQZDUfyjIJjCb7BNgjH5obGEnyD7XU4cs8ofmlVgm8MvQ5H7hkNR/pmGo70zTQc6ZtJOAbfGBqE41rWX69d5+k1R/yjhiN9Mw1H+mYajhWOEo7kGQ1H8oyGI3lGw5E8o+FInpFwDL4x9DocyTMajuQZDUffPPPGOf7xds93nvdv51i/SFZIikj6Zho1Sd9Uoybpm2vUJH2TjZqkb7YRkwy+PzQMyfWLxx/m6X4j6Ztv1CR9E46aJBlHRbJCUkSSjKMiScZRkSTjvE1ye02SjKMiScYRkQy+U3QIyScbUss5G3LIORuSxTmbCptTNrj/czb4+XM2mTYntWbVl+BbLNXVZtqc1Kw2+EZIdbWJ/GVHtYkcY0e1iTxgR7XVqtpEPq2j2kxbKNvVWnmpVFso29VaealUWyjb1Vp5qUx7JTuqtfJSmXY/dlRr5aUy7WfsqNbKS2XaodhRrZWXyrSPsKNaKy+VabdfR7VWXirTnryOaq28VKadcx3VWnmpTPvbOqq18lKZdqF1VGvlpTLtFeuo1spLZdrR1VGtlZfKtO+qo1orL5Vpd1RHtVZeKtMepo5qrbxUpp1GHdVaealM+4E6qrXyUpl27XRUa+WlDisvdTh5qSnTbqeOap281HRz8lLTzclLTbdqVa2Tl5oy7ZPqqNbJS02ZdjN1VGvlpTLtOeqo1spLZdoZ1FGtlZfKtH+no1orL5Vpl01HtVZeKtNemI5qrbxUph0rHdVaealM+0o6qrXyUpk2f3RUa+WljLcVvLMPuU6/XrvU+TVH9rBJOBpvKtByZA+bhiN72DQc2Sut4VjhKOHIXmkNR/ZKaziyV1rDkTyj4Uie6eG4P954OZaXHI23Emg5kmc0HMkzGo7kmR6O2xfH9TXHCkcJR/KMhiN5RsORPKPhSJ7RcCTP9HBcHp8XLuvrzwsz7bUYypE8o+FIntFwJM9oOFY4SjiSZzQcyTMajuQZDUfyjIYjeUbCMdNumaEcyTMajuQZDUfyjIZjhaOEI3lGw5E8o+FIntFwJM9oOJJnJBwz7XcaypE8o+FIntFwJM9oOFY4SjiSZzQcyTMajuQZDUfyjIYjeUbCMdOOtaEcyTMajuQZDUfyjIZjhaOEI3lGw5E8o+FInpFwDL5X7jY9znHc1r3BUfsL/+A76EaSie3xRpKJ7dpGkqmQOSET21mNJBPbK40kE9v9jCQTuz87kkzsjus4MnPwfYAjybh64NZ8mzn4nsGRZFw9cJtMhcwJGVcP3JrLMQffiziSjKsHbpNx9cBtMq4euEkm+B7HkWRcPXDrs4M5+H7IkWRcPXCbTIXMCRlXD9wm4+qB22RcPXCbjKsHbpNx9cBNMsH3b44kgwc+I4MHPiODBz4jUyFzQgYPfEYGD3xGBg98RgYPfEYGD3xCJvh+2ZFk8MBnZPDAZ2TwwGdkKmROyOCBz8jggc/I4IHPyOCBz8jggU/IBN9JOpIMHviMDB74jAwe+IxMhcwJGTzwGRk88BkZPPAZGTzwGRk88AmZ2HsD9215fG13346qJNP8TVzsTYBDyVTInJAJ7WeGkgntZ4aSCe1nhpIJ7WeGkgntZ0aSib3HbiiZ0D29oWTwwGdkXD1w85fssffBDSXj6oHbZFw9cJuMqwdu/io59l61oWRcPXCTTOzdZ0PJuHrgNhlXD9wm4+qBm58dxN4hNpSMqwduk3H1wG0yrh64TcbVA7fJuHrgJpnY+7KGknH1wG0yrh64TQYPfEamQuaEDB74jAwe+IwMHviMDB74jAwe+IRM7J1fQ8nggc/I4IHPyOCBz8hUyJyQwQOfkcEDn5HBA5+RwQOfkcEDvyZTY+/8GkoGD3xGBg98RgYPfEamQuaEDB74jAwe+IwMHviMDB74jAwe+IRM7J1fQ8nggc/I1B8no/zlWh2wZUl7/vXi598ufv794uc/rn3+ATt6tOcvFz//dPHzzxc//8Xv3yn2/dv6RWqdYt+/7fPHvn/b5499/7bPH/v+bf3qrc6x79/2+WPfv+3zx75/2+ePff+2zx/7/m2fP/b92+w/zLHv3/b5Y9+/7fPHvn/b5499/zbPX2Pfv+3zx75/2+ePff+2zx/7/m2fP/b92z7/xe/fevH7t178/q0Xv3/rxe/f5eL373Lx+3e5+P27XPz+HTDjXXv+i9+/y8Xv3+Xi9+9y8ft3ufj9u178/l0vfv+uF79/14vfvwPmS2vPf/H7d734/bte/P5dL37/rhe/f7eL37/bxe/f7eL373bx+1czp7Q8jjSVtSrP3/z+lWaa6MDz7xc//3Ht82vmZw48f7n4+aeLn3+++Pnrxc+/XPz8F79/99j3b/P7q3vs+7d9/tj3b/P8R+z7t33+2Pdv8/uTR+z7t33+2Pdv+/yx79/2+WPfv+3zx75/2+ePff82+w9H7Pu3ff7Y92/r/Mst9v3bPn/s+7d9/tj3b/v8se/f9vlj37/t88e+f9vnj33/ts9/7ft3uV37/l1uF79/y8Xv33Lx+7dc/P4tF79/NfOXBp7/4vdvufj9Wy5+/5aL37/l4vfvdPH7d7r4/Ttd/P6dLn7/auYvDTz/xe/f6eL373Tx+3e6+P07Xfz+nS9+/84Xv3/ni9+/88XvX838pYHnv/j9K5n/c6vL4/y346Y8f+v7V4tk/s/A80vm/4w8f7n4+aeLn3+++Pnrxc+/XPz868XPv138/Be/f2vs+7f1/dVliX3/ts8f+/5tnz/2/ds+f+z7t/X9yUUy/2fk+WPfv+3zx75/2+ePff+2zx/7/m2fP/b92+w/rLHv3/b5Y9+/7fPHvn/b5499/7bPH/v+bZ8/9v3bPn/s+7d9/tj3b/v8se/f9vkvfv9uF79/t4vfv9vF79/t4vfvdvH7d7v4/btd/P7dLn7/bhe/f7eL37/7xe/f/eL3737x+3e/+P0rmb808vwXv3/3i9+/+8Xv3/3i9+9+8fv3uPj9e1z8/j0ufv8eF79/JfOXRp7/4vfvcfH797jw/Xvb//3rn2/O++M8tRxfh5+2xx97/avJ9h8rf+2PTX/tj83v/7Fp+vdnv6jfH18FK+X2/Q8u//MP1n9/8lOirTz+wnLcvkQo9fb8g8df/IMnP57p+IPlr/7B6e0/eP+//n//8f/6L//xf/uv//m/3//MP/4f/+9//t//5b/8t3/+9X/+y/////yf/y/31/4/"},{"name":"unconstrained_is_consumable","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"set_reject_all","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"reject","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/83X2W7TQBQG4HGWkqZtSmLHseM4ieOlCxGCC5AQlBskXoAnQGK5YZFYxDvyVMw5M8d/gitXcxPV0sST4/PNnBk3qqZQXaUGuimVKntRRI3Ukb551F4r6elORzdvpDwJmbwONc7rmLabx6GSHtLopkdDdUsLVG+jP86eKSllTB/9girhgQal1HbE5fHFo5kcGu1BgSeF6qv9izKOuVZ1bFrXjMbDDMuOfTDEgEOTMzBdujdJv53slSSLOXnZ28mh8U6a9dJ1auo9pdbn7tB+1VtD06lRn++ER7SDZpJXtIP1jp1jx8b7O/YQ5Y31gO/0fWKSz22yz4ucUA/MNzlj02X6C2GhAVNKCEAD0MDS7wgLnTKlhCnoFHRq6Q+EhYZMKSEEDUFDS98jLHTGlBJmoDPQmaWfERYaMaWECDQCjSz9iLDQmCklxKAxaGzpGmGhc6aUMAedg84t/Ymw0IQpJSSgCWhi6ReEhS6YUsICdAG6MPcmCdyJ707idqLX9ARhoSlTSkhBU9C0OVtaz9ZC9GzfEBa6ZEoJS9Al6LI527LeQUfiu5PYnYTuJDkIuWPH9Pv5g7DQFVNKWIGuQFfN2Vb1r7iF6Nk+ICx0zZQS1qBr0LWljxEWmjGlhAw0A82ahWb1K3YkE3fiu5PAnUzdSehOZu4kOsh7mbuT5CDvxT/IWu7YMf27+Yqw0A1TStiAbkA3lv5GWGjOlBJy0Bw0bxaa12tzJL47ie9rYaE7md6HHdN/BZ8QFlowpYQCtAAtmrMV9ZocSeBOMncStxO9DU8RFloypYQStAQtm7OV9b+sFkL1e29xnrlhqHCIkVNLWX+MzYg9haviqar9qS4MLk1XntCB6QJJVzgXXR9x99rmP9IbQRlbjxO3FKLGFb8x32S5ZLalpF1iYvOgY4L0UGa4orveG+/FTln/Ffzcs6u9MYfDnqoPyh4vWpbfwzZV+8e+s2L3SdcOUtVvp3/r26lsFdWlZwUfeHOKRX+p/QNL3SAxSxAAAA==","debug_symbols":"5dzLSlthGIXhe8lYyr/W9x+9lVJKPJWARNFYKOK9N7bZicXQOJDK28yMfiZr6+CdPY+zi8uzh29fF8urm/vZ6efH2fXN+Xy1uFmuXz3O0ifFr+/e386Xz9+4X83vVrNTOdeT2eXy4vnLWp9OZleL68vZadhPJ6+uczhvrnOEt9ej7Dmu0fvmuOYUL4+/nDwPyvsHbT9iPagdGDRi+ojR+/ZWOe+5VUnTG4/drT32vW8e04pRym67c9qML+TxlTy+kcd38vgBHm+Rx5s8PsjjyZEyOVImR8rkSJkcKZMjFYk8nlzYeIfCKtWYruV0YP40Ph1415amP0lzefGedTM8U4cX6vBKHd6owzt1+IAOz4k6XNTh1ADloA6nljNTy5mp5czUcmZqOTO1nIVazkItZ6GWs1DLWajlLNRyFmo5C7WchVrOQi1npZazUstZqeWs1HJWajkrtZyVWs5KLWellrNSy9mo5WzUcjZqORu1nI1azkYtZ6OWs1HL2ajlbNRydmo5O7WcnVrOTi1np5azU8vZqeXs1HJ2ajk7tZyDWs5BLeeglnNQyzmo5RzUcg5qOQe1nINazkEtpxI1nUrUdipR46lEracSNZ9K1H6uPxS7nFpQJWpClbANFbahwjZU2IYK29D3QHI+aDm2ocI2VNiGCttQYRtqbEONbaixDTW2oe9h+HzQcmxDjW2osQ01tqHGNjSwDQ1sQ7FWjwLbUCwzJKwzJCw0JKw0JCw1JKw1JCw2JKw2JCw3JKw3JCw4JKw4JCw5JKw5JCw6JKw6JCw7JKw7JCw8JKw8JCw9JKw9JCw+JKw+JCw/JKw/JCxAJKxAJCxBJKxBJCxCJKxCJCxDJKxDJCxEJKxEJCxFJKxFJCxGJKxGJCxHJKxHJCxIJKxIJCxJJKxJJCxKJKxKJCxLJKxLJCxMJKxMJCxNJKxNJCxOJKxOJCxPJKxPJCxQJKxQJCxRJKxRJCxSJKxSJCxTJKxTZKxTZKxTZKxTZKxT5ERtqLFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOUWCdosA6RYF1igLrFEWiNjSwTlFgnaLAOkWBdYoC6xQF1ikKrFMUWKcosE5RYJ2iwDpFgXWKAusUBdYpCqxTFFinKLBOUWCdosA6RYF1igLrFMUbnKKuQ8vXJZ6uo/Y/PuX1dam5ba5LrXl7Pcqe4xja3Oa0O3XkaX779/OVdvPL3+eX3LbHJR047tXT/6rXll4ebx62H9PDjiN62DcoSv/Rw+qYHtbH9LBxTA+bj+lhyzE9bD2Oh12/+D6/W8zPri/v17/y/LOH5flqcbPcvFz9uP39k/XtTw=="},{"name":"consume","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"_set_authorized","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"approver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"},{"name":"authorize","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/+2ZW2/jRBTHJ2nSbZeSxE2auLm0bpts2tyzbdpduuUNxDtvvCBgYUHiInERgo/Ip2LOmTn+x3Xk1VkVq0JrybF95v+bcxk78Wn7ZsuYnbKxW8/4zV7tmIrZtocC7R8bObMnRbsXKqYgJqcr0c66ktvXdWwa0CDNXhz46cwWn5HQjW6R74GfxGyf2o/qykh4AX08qRpn2KYLP+Vun5Iw13bfG0gSTw0badujD6chtx/0MdI3hU/t8UMnfurFlUHRGU0FWMVp9twpo3/ALGiVURJUgVaBVj36M8yC1hglQQ1oDWjNo9/ALGjAKAkCoAHQwKO/wyzoPqMk2Ae6D3Tfoz/ALGidURLUgdaB1j36C8yCNhglQQNoA2jDHdNINRux3iKYBT1glAQHQA+AHnj0S5gFbTJKgibQJtCmR3+DWdAWoyRoAW0BbXn0W5gFDRklQQg0BBqmyxPG66hEDrIRG+BXMAt6yCgJDoEeAj1MezuMnwwlEmQjNsDvYRa0zSgJ2kDbQNtpb+34nsxArLdfYRa0wygJOkA7QDtpb5344clArLe/YRa0yygJukC7QLtpb934hspArLfXMAvaY5QEPaA9oL20t178vCmRmh4J9Ug1l1zqDx6YXZ8fYRb0iFESHAE9Anrk0b9gFvSYURIcAz0GepwO9DguRwZivX0Ns6ARoySIgEZAo7S3KL5tlUhDj9T0SKhHerkg71Cxbi5F3tcjVT0S5FKxdi65PNp77CgbOSF7B2/nNwwavJLLOzipzUDe0+2MJYPthF2dJF2dOjhypzJCr/+nEPXxlj/Y5tOB1z+zX0+kGBZYOCQT7Rxx6K4kXWKGA5GdwbEbKDojDYqHPh0j6n3WwroX8HXBZ3vjNDTNblybHdRmN9m5PEFOtqplk9y4UtyOccFO3DQ7fppoUyX9ou364HY3IaVsJBGSJLN3W1rT7LjfhPvx0nbq4qWqnLqmTopU6rM70y/zseRLe+acvOLyyywDVGyYrNgzhDe0E35uj+dYKxJfcJLndAbswmmG7nR9eYEEeqSuR9p6JMxGbBnewCzoiFESjICOgI7S3kbxF6cSaeiRph7p6ZG6HgkePH27PguYBR0zSoIx0DHQcdrbOPamRKp6pK5HglxyCfVILxfkLRWzd8GfMAs6YZQEE6AToJO0t0n8lCqRbjZiA5zBLOiUURJMgU6BTtPepvHSKpFzPRLokboeaeuRUI9c6JFWLuvS1CO9XNYlyCWXt1TMPjc/wSzojFESzIDOgM7S3mbx39OUSFOPBHqk8VgDC/VI+zFUzN4438Es6JxREsyBzoHO097mcU5KpK5HpnqkkY3YMixhFnTBKAkWQBdAF2lvi/inKgOhfqn4GfqOOwYNmg3pLha+D/Fssotdsqtl0tVzBy/cqYxQY/Mcoiv0LyvXxa68/tp3sTeui6X2mlrNa474E3cl6RJzMxDZJRy7gaIz0qB4uKJjZGe6XQvrXsDX0hbfofFbxrUpoTbLZE921l8f2XJaVx0OJdq4JEvveiNSzkYQ3yJuTJd+koVrO5e+7Sy7drNsXLsZIf3LTct+mUzteX99RO4kEl3FryxXa6vrNJe+4BuRQI/U9Uhbj4R65EKPtPRIQ4809Ugvl3UJckl/lIuX6v+oYmEuN0w+99g4l6eyq0cmuSzl++/k99/J//XqN3Op2FSPVHLJJXisN0yQyyPWfqwVm+WSSz2XO/kd0p8/+E8SNV9bb9A33DFoki2B8WrXLl66GdfbxRW7WiVd+Xbuyp3KyCvXCYroBfqPl65dfOn1H/l28da1i7dkop0jfu2uJF1ibgciu4FjN1B0RhoUDy/oGNnrL9bCuhcwt4uU7Z37nx/tZYS+isu0jTKtku1V1F8f2fKTrOLVKW9cnbifPS94go7LM3IY/kP7v2DEW1sFKwAA","debug_symbols":"5dztbpNHEMXxe8lnVD0zO7Mzy61UVZXyUkVCAUGoVCHuvabYSVCsmtOmTf7Npyqwa8YZqSccHv8+nb189cvHX3++uHz99sPZ8x8/nb15++L86uLt5e6rT2fbD5Z//uqHd+eXX37hw9X5+6uz59uzs1eXL3f//fzs7PXFm1dnz4f752d3zsXw2B+NMfz69Mojh+fo3h+esY3bh3969mWU+Y9GscrDKNZxYhQfdRjF88go9f2jfL3Q6oUlXvBNvWDqBVcvDPVCqBdSvTDVC+qmXd20q5se6qaHuumhbnqomx7qpoe66aFueqibHuqmh7rpUDcd6qZD3XSomw5106FuOtRNh7rpUDcd6qZT3XSqm05106luOtVNp7rpVDed6qZT3XSqm57qpqe66alueqqbnuqmp7rpqW56qpue6qanuulSN13qpkvddKmbLnXTpW661E2XuulSN13qplvddKubbnXTrW661U23uulWN93qplvddKubXuqml7rppW56qZte6qaXuumlbnqpm17qppe6ads2+YbJN1y+MeQbId9I+caUb8gNyiZXKJu8c5N3bvLOTd65yTs3eecm79zkneutmV6byb2ZycWZyc2ZydWZyd2ZyeWZye2ZyfWZyf2ZyQWayQ2ayRWayR2aySWayS2ayTWayT2ayUWayU2ayVWayV2ayWWayW2ayXWayX2ayYWayY2ayZWayZ2ayaWaya2aybWayb2aycWayc2aydWayd2ayeWaye2ayfWayf2ayQWbyQ2byRWbyR2bySWbyS2byTWbyT2byUWbyU2byVWbyV2byWWbyW2byXWbyX2byYWbyY2byZWbyZ2byaWbya2bybWbyb2bycWbyc2bydWbtf6Eg7xzuX0zuX4zuX8zuYAzuYEzuYIzuYMzuYQzuYWzpT/Woj/XIj/YIvdwLvdwLvdwLvdwLvdwLvdwLvdwLvdwLvdwbvrDTPLO5R7O5R7O5R7O5R7O5R7O5R7O5R7O9efX9AfY/sYTbPLO9WfY9IfY9KfY9MfY9OfY9AfZ5B7O5R7O5R7Oh/7YorxzuYdzuYdzuYdzuYdzuYdzuYdzuYdzuYdzuYfz0J9VlXcu93Au93Au93Au93Au93Au93Au93Au93Au93Au93Au93Au93Au93Au93Au93Au93Au93Au93Au93Au93A+9afS5Z3LPZzLPZzLPZzLPZzLPZzLPZzLPZzLPZzLPZyX/lEEeedyD+dyD+dyD+dyD+dyD+fHe7jR83Bp9Kpv7t39FNAah88jre7rs7t/gDtydvdPTfuzu1Lk+uzuR+Jjrxvr8Kmolbc+XbT70egwfaCnT/T0Ez19oadv8vTH22nM9Iae3tHTo9NqodNqodNqodNqodNqsdNqgacfGzlrx3YPWWvbHIeRzLcT8x//u9Ldc7lsf3Ju335P9pMP7OSBnTyxk0/s5IWdvLGTL+rktmEnxyaROXZybIYaNkMNm6GGzVDDZqhhM9SwGerYDHVshjo2Qx2boY7NUMdmqGMz1LEZ6tgMdWyGDmyGDmyGDmyGDmyGDmyGDmyGDmyGDmyGDmyGDmyGBjZDA5uhgc3QwGZoYDM0sBka2AwNbIYGNkMDm6GJzdDEZmhiMzSxGZrYDE1shiY2QxOboYnN0MRm6MRm6MRm6MRm6MRm6MRm6MRm6MRm6MRm6MRm6MRmaGEztLAZWtgMLWyGFjZDC5uhhc3QwmZoYTO0sBna2AxtbIY2NkMbm6H3Ye480OTYDG1shjY2QxuboY3N0IXN0IXN0IXN0IXN0PuQgB5ocmyGLmyGLmyGLmyGLmqGxkbN0MBqP7FRMzSwTlFs1AwNrFMUWKcosE5RYJ2iwDpFgXWKAusUBdYpCqxTFFinKLBOUWCdosA6RYF1igLrFAXWKQqsUxRYpyiwTlFgnaLAOkWBdYoC6xQF1ikKrFMUWKcosE5RYJ2iwDpFgXWKAusUBdYpCqxTFFinKLBOUWCdosA6RYF1igLrFAXWKQqsUxRYpyiwTlFgnaLAOkWBdYoC6xQF1ikKrFMUWKcosE5RYJ2iwDpFgXWKAusUBdYpCqxTFFinKLBOUWCdosA6RYF1igLrFAXWKQqsUxRYpyiwTlFgnaLAOkWBdYoC6xQF1ikKrFMUWKcosE5RYJ2iwDpFgXWKAusUBdYpCqxTFFinKLBOUWCdosA6RYF1igLrFAXWKQqsUxRYpyiwTlFgnaLAOkWBdYoC6xQl1ilKrFOUWKcosU5RbtQMTaxTlFinKLFOUWKdosQ6RYl1ihLrFCXWKUqsU5RYpyixTlFinaLEOkWJdYoS6xQl1ilKrFOUWKcosU5RYp2ixDpFiXWKEusUJdYpSqxTlFinKLFOUWKdosQ6RYl1ihLrFCXWKUqsU5RYpyixTlFinaLEOkWJdYoS6xQl1ilKrFOUWKcosU5RYp2ixDpFiXWKEusUJdYpSqxTlFinKLFOUWKdosQ6RYl1ihLrFCXWKUqsU5RYpyixTlFinaLEOkWJdYoS6xQl1ilKrFOUWKcosU5RYp2ixDpFiXWKEusUJdYpSqxTlFinKLFOUWKdosQ6RYl1ihLrFOVpp2hZnPgz1uj94dV9Ym7Lwwvbujnrvo69bqw4vPCuLr85Hdth+kRPP9HTF3r6Rk+/yNOf9ose9fSGnt7R0w/09OisXeisXeisXeisXeisXfeQtf/Oz/a1Hb4n5XnrNefXyee2YSc37OSOnXxgJw/s5ImdfGInL+zkjZ0cm6GGzVDDZqhhM9SwGXraOHq0k2Mz1LAZatgMNWyGGjZDHZuhjs1Qx2aoYzP0tHH0aCfHZqhjM9SxGerYDHVshg5shg5shg5shg5shp42jh7t5NgMHdgMHdgMHdgMHdgMDWyGBjZDA5uhgc3Q08bRo50cm6GBzdDAZmhgMzSwGZrYDE1shiY2QxOboaeNo0c7OTZDE5uhic3QxGZoYjN0YjN0YjN0YjN0YjP0tHH0aCfHZujEZujEZujEZujEZmhhM7SwGVrYDC1shp42jh7t5NgMLWyGFjZDC5uhhc3QxmZoYzO0sRna2Ay9D+PogSbHZmhjM7SxGdrYDG1shi5shi5shi5shi5sht6HXfRAk2MzdGEzdGEzdGEzFOsUFdYpKqxTVFinqLBOUW3UDC2sU1RYp6iwTlFhnaLCOkWFdYoK6xQV1ikqrFNUWKeosE5RYZ2iwjpFhXWKCusUFdYpKqxTVFinqLBOUWGdosI6RYV1igrrFBXWKSqsU1RYp6iwTlFhnaLCOkWFdYoK6xQV1ikqrFNUWKeosE5RYZ2iwjpFhXWKCusUFdYpKqxTVFinqLBOUWGdosI6RYV1igrrFBXWKSqsU1RYp6iwTlFhnaLCOkWFdYoK6xQV1ikqrFNUWKeosE5RYZ2iwjpFhXWKCusUFdYpKqxTVFinqLBOUWGdosI6RYV1igrrFBXWKSqsU1RYp6iwTlFhnaLCOkWFdYoK6xQV1ikqrFNUWKeosE5RYZ2iwjpFhXWKCusUFdYpKqxTVFinqLBOUWGdosI6RYV1igrrFDXWKWqsU9RYp6ixTlFv1AxtrFPUWKeosU5RY52ixjpFjXWKGusUNdYpaqxT1FinqLFOUWOdosY6RY11ihrrFDXWKWqsU9RYp6ixTlFjnaLGOkWNdYoa6xQ11ilqrFPUWKeosU5RY52ixjpFjXWKGusUNdYpaqxT1FinqLFOUWOdosY6RY11ihrrFDXWKWqsU9RYp6ixTlFjnaLGOkWNdYoa6xQ11ilqrFPUWKeosU5RY52ixjpFjXWKGusUNdYpaqxT1FinqLFOUWOdosY6RY11ihrrFDXWKWqsU9RYp6i/wykadmryYfMw+Zj9zZ9y93TOqP3pnPPmu7LyyOHd921/Nraboz7iML7/9+PbdjN+/vX4GXV9OLcTh3c/FRx2tfvfz3b78P7Njqf0ZuMpvdl8Sm92PqU3W0/pzfZTerPrCb3Z70Ck/kdv1p7Gm9198dv5+4vzX968+rC78uX3Pl6+uLp4e7n/8ur3d19/Z3f2Dw=="},{"name":"is_reject_all","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/83Z6W7bRhAH8NVhx4olirpM6rJli7RuO3HsFmibfCnQF+gDFL3RogfQA0VfsU/Vndkd/iUToTFBQIQArdXs/Di7SynmOompGXNSN/aYGn9QxATm2L5U6HxjpGUbVXtWAlORUEqdpKqpTzM1blFi/cr+OE2Ncye1B+qo0RUSU6HU4yNTcRWpnDlKuHlvz0Yqw3nm+ulo0A+XQ+wkQY+94Bf29blLfuaTT9OqC5pTsFOX03BNpn8jLLTJlBKaoE3Qpqe/ISy0xZQSWqAt0Jan3yIsNGBKCQFoABp4+hfCQttMKaEN2gZte/oTwkJDppQQgoagoae/Iyy0w5QSOqAd0I57zZNmMbHVZggL7TKlhC5oF7Sbr9bN5lZAbLU/ERbaY0oJPdAeaM/TrxAW2mdKCX3QPmjf0z8QFjpgSgkD0AHowNPvERZ6xpQSzkDPQM88/RlhoRFTSohAI9Aov7JRVk1JWnoS6EmvmNhl+BphoTFTSohBY9DY018QFjpkSglD0CHoMD/QdyYdPWnpSaQnzVLmEpYysCfui/0U/Iuw0BFTShiBjkBH+WqjbBkKiK32DcJCx0wpYQw6Bh3nq42zb62SdPSkpSeRnsSlkCdWzN6f7xAWOmFKCRPQCegkX22SLbaSdPUk0JOolCptPWmVMpe4FDIsJpcUb+F5+YGhwUOyPBVTtknlydlesW5wTLnU9LDUucMT15QeeiA/R9IMz92Xx9y89PlX/rl+XuHEOYXo5BE/d+9kuhSbp5J2gcKuo+qC1CkVZvQ6ozHsDevRgD+q+Nk+uByeY7q3tZGRTw/3EkeY0zQxR+bw4LvAWyKu5G9IzV+mwYOduH8G5IKNvX73mif1YnIwJJnM+af1vZyauzOPx0vHhRsvreHFETcb/m094XLm0u2+6rK8rshntC7Zil1hxZLDFZtjeIm94Jfuo1bzt5ySr3mSdKlrsGuXk7gmveZJoCehnvT1JComdhl+RFjogiklLEAXoIt8tUX2K0dJOnrS1ZNYT0I9Cd779O39eYGw0CVTSliCLkGX+WrLrJqSNPUk1JOglLlEehKXQp5YMfsp+AdhoSumlLACXYGu8tVW2bdUScbFxA7wBmGha6aUsAZdg67z1dbZrVWSVE8CPQn1pK8nkZ5c68mglPvS1ZO4lPsSlDKXJ1bMfm9+RVjohiklbEA3oJt8tU32t18l6epJoCedD3VgkZ70P4QVsx+cHxAWumVKCVvQLeg2X22bzUlJQj1Z60mnmNhleImw0B1TStiB7kB3+Wq77FdVAaEtR/UT7DteMzTYbMjugrLdLjZxV9zfxd5wqZvDUrcO71xTemhjc4ukl9i/3Lld7J3Pf+V3sfduF0vbzFd08og/du9kumTuU0l7gcKuo+qC1CkVaInvZvZK+8N6NGDexdJsX2O82JPV37onmy2qfp/HG7s9fJxtLYnc8lQ+pxaX8kfNXZzTblO/kqYRZLvH+htfn0/8X6ALuTxqzlxzRoxJw597hEPZHydm3CJQnVMz/o/O/wEpfgJCnxwAAA==","debug_symbols":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2b3U7bQBCF18GhBoOb2HGckEAIBaTehRSScMfLtM/d60p9haqss6Mclmm0UcdLVool5LG9O+ebsz+EyERqfSSvP5GJ2+Z8rN4f1ObFnGf/dzwI5po1yRkFwtkKhPMoEM5YkDNiOPU5NrFed3rNfVLr9fjuIXbWA30Ez9W2RLZqYgJ8eC1V6Wr2fAzJEVwZ8Ng8o7PGSc0zBEtNkXUbuEeFtuAe6RzBPdrBSCcxpgjX+5RskOXyvs4+XcOJyUXcKcT4bAzWxQ3V2Jav8bGRMXn1rqExqVcx+d42uRO4pjE4NbHgb44H1I7Mz6k1F2KIR9CW2pEfLWDVx7narJfTLf1iq18GbY6hn7230DWNtfaqa2J9btOeAPkb8HCm86byed+MTWx5l0JNGXgioz1f6fxn6u0RWdfXEGfAcy7Os1578nWux+4zsMvkfXrUXnUsr84srzJogwydBvyLQJdy03WH0ZbzYrHS2l0HL7oMT9ezF11GW9CLZ62dO3iRMzy5Zy9yRlvOi+U3rV04eFEwPIVnLwpGW86Lef0ZoOfgRY/h6Xn2osdoC66Rel6UDl6UDE/p2YuS0Rb04ofW7jt40Wd4+p696DPagl5819qVgxcVw1N59qJitAX3zvrzxcDBiwHDM/DsxYDRFvRirrWHDl4MGZ6hZy+GjLbgGqm1Lxy8uGB4Ljx7QXq7MvcCZK4CZC72gDmxYhntRb1/jhy8GDE8I89e4HcuuzCXe8CcWLGM9uJJa48dvBgzPGPPXpDersx5gMxFgMz9AJnLAJmrAJn3YT4nViyjvaz30EsHLy4ZnkvPXpDersx5gMyjAJmLPWBOrFhGe1l/N3fl4MUVw3Pl2QvS25V5ECBzdw+YEyuW0V4utPbEwYsJwzPx7AXp7co8DJC5CpB5FCBzESBzP0DmMkDmwxr0w5zvATO+e/S7UZ75c2rxkGfKYlQWYwpxBozU9kXJva+SWbWT1lTcj/X42POFrqeNas9XOu+XBmrSeW/l89Z/I9yZXPQO3y3j1b2JI+FxuoO8EejQ/RjiX9CW2pEftB8Qu36X68bE91v6Tax+GbS5gX63Vj+6prHW3v00cVNzy2Ved9RmLX8Fngb2wUd8J1eBV8pipGMCPNfyPA8N1TnDd/j+KNm1N7W8OrG8yqAN7tEftW8emA/M/2LGzxMncA956F7LqgX/v2EKOf4CARQXTpY1AAA=","debug_symbols":"ndpBattQGIXRvWgciu9v6T0pWymlOIlTDMYOsVMoJnuv3NIF9Mz0JN3ZNzq82/Cyf/r48f1wej1fhsevt+F4ft5dD+fTeroNmy81/3l7edud7i8u1937dXjctv4w7E8v61Ovz4fh9XDcr89Vn98e7qMFRtuNjCKjktFWRqOMJhk1GXUZSRFbKWKUIkYpYpQiRililCJGKWKUIkYpYpQiRilikiImKWKSIiYpYpIiJilikiImKWKSIiYpokkRTYpoUkSTIpoU0aSIJkU0KaJJEU2K6FJElyK6FNGliC5FdCmiSxFdiuhSRJciZililiJmKWKWImYpYpYiZililiJmKWKWIhYpYpEiFilikSIWKWKRIhYpYpEiFilikSKy2dAqtCpabWk10mqiVaNVp9VMK2oj1EaojVAboTZCbYTaCLURaiPURqiNojaK2ihqo6iNojaK2ihqo6gNAs2QaIZIM2SaIdQMqWaINUOuGYLNkGyGaDNkmyHcDOlmiDdDvhkCzpBwhogzZJwh5AwpZ4g5Q84Zgs6QdIaoM2SdIewMaWeIO0PeGQLPkHiGyDNkniH0DKlniD1D7hmCz5B8hugzZJ8h/AzpZ4g/Q/4ZAtCQgIYINGSgIQQNKWiIQUMOGoLQkISGKDRkoSEMDWloiENDHhoC0ZCIhkg0ZKIhFA2paIhFQy5a5KJFLlrkokUuWuSiRS5a5KJFLlrkokUuWuSiRS5a5KJFLlrkokUuWuSiRS5a5KJFLlrkokUuWuSiRS5a5KJFLlrkokUuWnbRk1y0yEWLXLTIRYtctMhFi1y0/ttF19PP3fth93Tc3+/23j9+nJ7/XfVdj9dfb3+/rP/+Bg=="}],"outputs":{"globals":{"storage":[{"fields":[{"name":"reject_all","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"approved_actions","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AuthRegistry::is_reject_all_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::is_reject_all_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"message_hash","type":{"kind":"field"}},{"name":"authorize","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::set_authorized_parameters"}}],"kind":"struct","path":"AuthRegistry::set_authorized_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"reject","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::set_reject_all_parameters"}}],"kind":"struct","path":"AuthRegistry::set_reject_all_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"message_hash","type":{"kind":"field"}}],"kind":"struct","path":"AuthRegistry::is_consumable_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::is_consumable_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"inner_hash","type":{"kind":"field"}}],"kind":"struct","path":"AuthRegistry::consume_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AuthRegistry::consume_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"approver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"message_hash","type":{"kind":"field"}},{"name":"authorize","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::_set_authorized_parameters"}}],"kind":"struct","path":"AuthRegistry::_set_authorized_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"approver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"message_hash","type":{"kind":"field"}},{"name":"authorize","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::set_authorized_private_parameters"}}],"kind":"struct","path":"AuthRegistry::set_authorized_private_abi"}]}},"file_map":{"23":{"path":"std/field/mod.nr","source":"mod bn254;\\nuse bn254::lt as bn254_lt;\\n\\nimpl Field {\\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\\n        crate::assert_constant(bit_size);\\n        self.__to_le_bits(bit_size)\\n    }\\n\\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\\n        crate::assert_constant(bit_size);\\n        self.__to_be_bits(bit_size)\\n    }\\n\\n    #[builtin(to_le_bits)]\\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\\n\\n    #[builtin(to_be_bits)]\\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\\n\\n    #[builtin(apply_range_constraint)]\\n    fn __assert_max_bit_size(self, bit_size: u32) {}\\n\\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\\n        crate::assert_constant(bit_size);\\n        assert(bit_size < modulus_num_bits() as u32);\\n        self.__assert_max_bit_size(bit_size);\\n    }\\n\\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\\n        self.to_le_radix(256, byte_size)\\n    }\\n\\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\\n        self.to_be_radix(256, byte_size)\\n    }\\n\\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\\n        crate::assert_constant(radix);\\n        crate::assert_constant(result_len);\\n        self.__to_le_radix(radix, result_len)\\n    }\\n\\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\\n        crate::assert_constant(radix);\\n        crate::assert_constant(result_len);\\n        self.__to_be_radix(radix, result_len)\\n    }\\n\\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\\n    // `_radix` must be less than 256\\n    #[builtin(to_le_radix)]\\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\\n\\n    #[builtin(to_be_radix)]\\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\\n\\n    // Returns self to the power of the given exponent value.\\n    // Caution: we assume the exponent fits into 32 bits\\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\\n    pub fn pow_32(self, exponent: Field) -> Field {\\n        let mut r: Field = 1;\\n        let b = exponent.to_le_bits(32);\\n\\n        for i in 1..33 {\\n            r *= r;\\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\\n        }\\n        r\\n    }\\n\\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\\n    pub fn sgn0(self) -> u1 {\\n        self as u1\\n    }\\n\\n    pub fn lt(self, another: Field) -> bool {\\n        if crate::compat::is_bn254() {\\n            bn254_lt(self, another)\\n        } else {\\n            lt_fallback(self, another)\\n        }\\n    }\\n}\\n\\n#[builtin(modulus_num_bits)]\\npub fn modulus_num_bits() -> u64 {}\\n\\n#[builtin(modulus_be_bits)]\\npub fn modulus_be_bits() -> [u1] {}\\n\\n#[builtin(modulus_le_bits)]\\npub fn modulus_le_bits() -> [u1] {}\\n\\n#[builtin(modulus_be_bytes)]\\npub fn modulus_be_bytes() -> [u8] {}\\n\\n#[builtin(modulus_le_bytes)]\\npub fn modulus_le_bytes() -> [u8] {}\\n// Convert a 32 byte array to a field element by modding\\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\\n    // Convert it to a field element\\n    let mut v = 1;\\n    let mut high = 0 as Field;\\n    let mut low = 0 as Field;\\n\\n    for i in 0..16 {\\n        high = high + (bytes32[15 - i] as Field) * v;\\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\\n        v = v * 256;\\n    }\\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\\n    low + high * v\\n}\\n\\nfn lt_fallback(x: Field, y: Field) -> bool {\\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\\n    let x_bytes = x.to_le_bytes(num_bytes);\\n    let y_bytes = y.to_le_bytes(num_bytes);\\n    let mut x_is_lt = false;\\n    let mut done = false;\\n    for i in 0..num_bytes {\\n        if (!done) {\\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\\n            let bytes_match = x_byte == y_byte;\\n            if !bytes_match {\\n                x_is_lt = x_byte < y_byte;\\n                done = true;\\n            }\\n        }\\n    }\\n    x_is_lt\\n}\\n\\n"},"54":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::protocol_types::{\\n    abis::function_selector::FunctionSelector, address::AztecAddress,\\n    constants::{\\n    GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER, GENERATOR_INDEX__AUTHWIT_NULLIFIER,\\n    CANONICAL_AUTH_REGISTRY_ADDRESS\\n},\\n    hash::pedersen_hash\\n};\\nuse dep::aztec::{prelude::Deserialize, context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\\n\\n/**\\n * Authenticaion witness helper library\\n *\\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties \\n * (e.g. protocols or other users) to execute an action on their behalf.\\n * \\n * This library provides helper functions to manage such witnesses.\\n * The authentication witness, is some \\"witness\\" (data) that authenticates a `message_hash`.\\n * The simplest example of an authentication witness, is a signature. The signature is the \\"evidence\\",\\n * that the signer has seen the message, agrees with it, and has allowed it.\\n * It does not need to be a signature. It could be any kind of \\"proof\\" that the message is allowed.\\n * Another proof could be knowing some kind of secret, or having some kind of \\"token\\" that allows the message.\\n *\\n * The `message_hash` is a hash of the following structure:\\n * hash(consumer, chain_id, version, inner_hash)\\n * - consumer: the address of the contract that is \\"consuming\\" the message,\\n * - chain_id: the chain id of the chain that the message is being consumed on,\\n * - version: the version of the chain that the message is being consumed on,\\n * - inner_hash: the hash of the \\"inner\\" message that is being consumed, this is the \\"actual\\" message or action.\\n *\\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be \\n * a hash of the \\"action\\" to approve, along with who made the call. As part of this library, we provide a few \\n * helper functions to deal with such messages.\\n *\\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\\n * This can be used to let some contract \\"allow\\" another contract to act on its behalf, as long as it can \\n * show that it is acting on behalf of the contract.\\n *\\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be \\n * derived as:\\n * inner_hash = hash(caller, \\"transfer\\", hash(to, amount))\\n * \\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\\n * the arguments for the transfer. \\n * \\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is \\n * allowed to transfer the tokens.\\n *\\n *\\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\\n * is executed on the user\'s device, so we can use `oracles` to \\"ask\\" the user (not contract) for information. In public\\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \\"registry\\"\\n * to store the messages that we have approved.\\n * \\n * A simple example would be a \\"token\\" that is being \\"pulled\\" from one account into another. We will first outline \\n * how this would look in private, and then in public later. \\n *\\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX). \\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract. \\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token` \\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to \\n * convince the `Token` contract that it is allowed to do so. \\n * \\n * This is where the authentication witness comes in! The `Token` contract computes a `message_hash` from the \\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to \\n * execute that call.\\n * \\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her \\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\\n * funds from `Alice`.\\n * \\n * To ensure that the same \\"approval\\" cannot be used multiple times, we also compute a `nullifier` for the\\n * authentication witness, and emit it from the `Token` contract (consumer).\\n * \\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts. \\n * \\n *\\n *  Person          Contract              Contract               Contract\\n *  Alice          Alice Account          Token                   DeFi\\n *   |                  |                  |                      |\\n *   | Defi.deposit(Token, 1000)           |                      |\\n *   |-----------------\x3e|                  |                      |\\n *   |                  | deposit(Token, 1000)                    |\\n *   |                  |----------------------------------------\x3e|\\n *   |                  |                  |                      |\\n *   |                  |                  | transfer(Alice, Defi, 1000)\\n *   |                  |                  |<---------------------|\\n *   |                  |                  |                      |\\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\\n *   |                  |<-----------------|                      |\\n *   |                  |                  |                      |\\n *   | Please give me AuthWit for DeFi     |                      |\\n *   | calling transfer(Alice, Defi, 1000) |                      |\\n *   |<-----------------|                  |                      |\\n *   |                  |                  |                      |\\n *   |                  |                  |                      |\\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\\n *   |-----------------\x3e|                  |                      |\\n *   |                  | AuthWit validity |                      |\\n *   |                  |-----------------\x3e|                      |\\n *   |                  |                  |                      |\\n *   |                  |       throw if invalid AuthWit          |\\n *   |                  |                  |                      |\\n *   |                  |       emit AuthWit nullifier            |\\n *   |                  |                  |                      |\\n *   |                  |       transfer(Alice, Defi, 1000)       |\\n *   |                  |                  |                      |\\n *   |                  |                  |                      |\\n *   |                  |                  | success              |\\n *   |                  |                  |---------------------\x3e|\\n *   |                  |                  |                      |\\n *   |                  |                  |                      |\\n *   |                  |                  |           deposit(Token, 1000)\\n *   |                  |                  |                      |\\n *   |                  |                  |                      |\\n *\\n *  \\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store \\n * the messages that we have approved. \\n * \\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\\n *\\n * The `Token` contract can then try to \\"spend\\" the approval by calling `consume` on the registry. If the message\\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\\n * registry, see `main.nr` in `auth_registry_contract`.\\n *\\n * Person          Contract              Contract            Contract               Contract\\n * Alice          Alice Account          Registry             Token                   DeFi\\n *   |                  |                    |                   |                      |\\n *   | Registry.set_authorized(..., true)    |                   |                      |\\n *   |-----------------\x3e|                    |                   |                      |\\n *   |                  | set_authorized(..., true)              |                      |\\n *   |                  |-------------------\x3e|                   |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |         set authorized to true         |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   |                      |\\n *   | Defi.deposit(Token, 1000)             |                   |                      |\\n *   |-----------------\x3e|                    |                   |                      |\\n *   |                  | deposit(Token, 1000)                   |                      |\\n *   |                  |--------------------------------------------------------------\x3e|\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\\n *   |                  |                    |                   |<---------------------|\\n *   |                  |                    |                   |                      |\\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\\n *   |                  |                    |<------------------|                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |          throw if invalid AuthWit      |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |           set authorized to false      |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |                    | AuthWit validity  |                      |\\n *   |                  |                    |------------------\x3e|                      |\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\\n *   |                  |                    |                   |<--------------------\x3e|\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   | success              |\\n *   |                  |                    |                   |---------------------\x3e|\\n *   |                  |                    |                   |                      |\\n *   |                  |                    |                   |     deposit(Token, 1000)\\n *   |                  |                    |                   |                      |\\n *\\n *\\n * --- FAQ ---\\n * Q:   Why are we using a success flag of `keccak256(\\"IS_VALID()\\")` instead of just returning a boolean?\\n * A:   We want to make sure that we don\'t accidentally return `true` if there is a collision in the function selector.\\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a colission and we return \\n *      a success flag.\\n * \\n * Q:   Why are we using static calls?\\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\\n *\\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be \\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the \\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\\n * \\n * Q:   Why is the chain id and the version part of the message hash?\\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\\n *      chain to avoid a case where the same message could be used across multiple chains. \\n */\\n\\nglobal IS_VALID_SELECTOR = 0xabf64ad4; // 4 first bytes of keccak256(\\"IS_VALID()\\")\\n\\n/** \\n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\\n * \\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\\n * \\n * @param on_behalf_of The address that have authorized the current call\\n */\\n// docs:start:assert_current_call_valid_authwit\\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\\n    let inner_hash = compute_inner_authwit_hash([context.msg_sender().to_field(), context.selector().to_field(), context.args_hash]);\\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\\n}\\n// docs:end:assert_current_call_valid_authwit\\n\\n/** \\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\\n * \\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\\n * \\n * @param on_behalf_of The address that have authorized the current call\\n * @param inner_hash The hash of the message to authorize  \\n */\\npub fn assert_inner_hash_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress, inner_hash: Field) {\\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\\n    let result: Field = context.static_call_private_function(\\n        on_behalf_of,\\n        FunctionSelector::from_signature(\\"verify_private_authwit(Field)\\"),\\n        [inner_hash]\\n    ).unpack_into();\\n    assert(result == IS_VALID_SELECTOR, \\"Message not authorized by account\\");\\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\\n    context.push_nullifier(nullifier, 0);\\n}\\n\\n/** \\n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\\n * \\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\\n * \\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\\n * \\n * @param on_behalf_of The address that have authorized the current call\\n */\\n// docs:start:assert_current_call_valid_authwit_public\\npub fn assert_current_call_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress) {\\n    let inner_hash = compute_inner_authwit_hash(\\n        [(*context).msg_sender().to_field(), (*context).selector().to_field(), (*context).get_args_hash()]\\n    );\\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\\n}\\n// docs:end:assert_current_call_valid_authwit_public\\n\\n/** \\n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\\n * \\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\\n *\\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\\n * \\n * @param on_behalf_of The address that have authorized the the `inner_hash`\\n */\\npub fn assert_inner_hash_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress, inner_hash: Field) {\\n    let result: Field = context.call_public_function(\\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\\n        FunctionSelector::from_signature(\\"consume((Field),Field)\\"),\\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\\n        GasOpts::default()\\n    ).deserialize_into();\\n    assert(result == IS_VALID_SELECTOR, \\"Message not authorized by account\\");\\n}\\n\\n/**\\n * Compute the `message_hash` from a function call to be used by an authentication witness \\n * \\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\\n * B to transfer T on its behalf.\\n * \\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\\n * @param chain_id The chain id of the chain that the message is being consumed on\\n * @param version The version of the chain that the message is being consumed on\\n * @param selector The function selector of the function that is being called\\n * @param args The arguments of the function that is being called\\n */\\n// docs:start:compute_authwit_message_hash_from_call\\npub fn compute_authwit_message_hash_from_call<N>(\\n    caller: AztecAddress,\\n    consumer: AztecAddress,\\n    chain_id: Field,\\n    version: Field,\\n    selector: FunctionSelector,\\n    args: [Field; N]\\n) -> Field {\\n    let args_hash = hash_args_array(args);\\n    let inner_hash = compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\\n}\\n// docs:end:compute_authwit_message_hash_from_call\\n\\n/**\\n * Computes the `inner_hash` of the authentication witness\\n * \\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\\n * that is not necessarily a call, but just some \\"bytes\\" or text.\\n * \\n * @param args The arguments to hash\\n */\\npub fn compute_inner_authwit_hash<N>(args: [Field; N]) -> Field {\\n    pedersen_hash(args, GENERATOR_INDEX__AUTHWIT_INNER)\\n}\\n\\n/** \\n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\\n * \\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\\n * \\n * @param on_behalf_of The address that have authorized the the `inner_hash`\\n * @param inner_hash The hash of the message to authorize\\n */\\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\\n    pedersen_hash(\\n        [on_behalf_of.to_field(), inner_hash],\\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER\\n    )\\n}\\n\\n/**\\n * Computes the `message_hash` for the authentication witness\\n * \\n * @param consumer The address of the contract that is consuming the message\\n * @param chain_id The chain id of the chain that the message is being consumed on\\n * @param version The version of the chain that the message is being consumed on\\n * @param inner_hash The hash of the \\"inner\\" message that is being consumed\\n */\\npub fn compute_authwit_message_hash(consumer: AztecAddress, chain_id: Field, version: Field, inner_hash: Field) -> Field {\\n    pedersen_hash(\\n        [\\n        consumer.to_field(),\\n        chain_id,\\n        version,\\n        inner_hash\\n    ],\\n        GENERATOR_INDEX__AUTHWIT_OUTER\\n    )\\n}\\n\\n/**\\n * Helper function to set the authorization status of a message hash\\n * \\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\\n * \\n * @param message_hash The hash of the message to authorize\\n * @param authorize True if the message should be authorized, false if it should be revoked\\n */\\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\\n    context.call_public_function(\\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\\n        FunctionSelector::from_signature(\\"set_authorized(Field,bool)\\"),\\n        [message_hash, authorize as Field].as_slice(),\\n        GasOpts::default()\\n    ).assert_empty();\\n}\\n\\n/**\\n * Helper function to reject all authwits\\n * \\n * Wraps a public call to the authentication registry to set the `reject_all` flag\\n *\\n * @param reject True if all authwits should be rejected, false otherwise \\n */\\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\\n    context.call_public_function(\\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\\n        FunctionSelector::from_signature(\\"set_reject_all(bool)\\"),\\n        [context.this_address().to_field(), reject as Field].as_slice(),\\n        GasOpts::default()\\n    ).assert_empty();\\n}\\n"},"88":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\\nuse crate::oracle::storage::{raw_storage_read, storage_read};\\n\\nstruct UnconstrainedContext {\\n    block_number: u32,\\n    contract_address: AztecAddress,\\n    version: Field,\\n    chain_id: Field,\\n}\\n\\nimpl UnconstrainedContext {\\n    unconstrained fn new() -> Self {\\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\\n        // not even be accessed. However any performance gains are minimal, and we\'d rather fail early if a user\\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\\n        // available.\\n        let block_number = block_number_oracle();\\n        let contract_address = contract_address_oracle();\\n        let chain_id = chain_id_oracle();\\n        let version = version_oracle();\\n        Self { block_number, contract_address, version, chain_id }\\n    }\\n\\n    fn block_number(self) -> u32 {\\n        self.block_number\\n    }\\n\\n    fn this_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n\\n    fn version(self) -> Field {\\n        self.version\\n    }\\n\\n    fn chain_id(self) -> Field {\\n        self.chain_id\\n    }\\n\\n    unconstrained fn raw_storage_read<N>(self: Self, storage_slot: Field) -> [Field; N] {\\n        storage_read(self.this_address(), storage_slot, self.block_number())\\n    }\\n\\n    unconstrained fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\\n        T::deserialize(self.raw_storage_read(storage_slot))\\n    }\\n}\\n\\n#[oracle(getContractAddress)]\\nunconstrained fn contract_address_oracle() -> AztecAddress {}\\n\\n#[oracle(getBlockNumber)]\\nunconstrained fn block_number_oracle() -> u32 {}\\n\\n#[oracle(getChainId)]\\nunconstrained fn chain_id_oracle() -> Field {}\\n\\n#[oracle(getVersion)]\\nunconstrained fn version_oracle() -> Field {}\\n"},"89":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\\nuse dep::protocol_types::traits::Deserialize;\\n\\nstruct PackedReturns {\\n  packed_returns: Field,\\n}\\n\\nimpl PackedReturns {\\n    pub fn new(packed_returns: Field) -> Self {\\n        PackedReturns { packed_returns }\\n    }\\n\\n    pub fn assert_empty(self) {\\n        assert_eq(self.packed_returns, 0);\\n    }\\n\\n    pub fn raw(self) -> Field {\\n        self.packed_returns\\n    }\\n\\n    pub fn unpack<N>(self) -> [Field; N] {\\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\\n        unpacked\\n    }\\n\\n    pub fn unpack_into<T, N>(self) -> T where T: Deserialize<N> {\\n        let unpacked: [Field; N] = self.unpack();\\n        Deserialize::deserialize(unpacked)\\n    }\\n}\\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\\n    address::AztecAddress, traits::Deserialize\\n};\\n\\nuse crate::context::{\\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\\n};\\n\\nuse crate::oracle::arguments::pack_arguments;\\nuse crate::hash::hash_args;\\n\\ntrait CallInterface<N, T, P, Env> {\\n    fn get_original(self) -> fn[Env](T) -> P;\\n\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\\n        self.original\\n    }\\n}\\n\\nstruct PrivateCallInterface<N, T, Env> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\\n    is_static: bool\\n}\\n\\nimpl<N, T, Env> PrivateCallInterface<N, T, Env> {\\n    pub fn call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\\n        assert(self.args_hash == pack_arguments(self.args));\\n        let returns = context.call_private_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            false,\\n            false\\n        );\\n        let unpacked: T = returns.unpack_into();\\n        unpacked\\n    }\\n\\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\\n        assert(self.args_hash == pack_arguments(self.args));\\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\\n        returns.unpack_into()\\n    }\\n\\n    pub fn delegate_call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\\n        assert(self.args_hash == pack_arguments(self.args));\\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\\n        returns.unpack_into()\\n    }\\n}\\n\\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\\n        self.original\\n    }\\n}\\n\\nstruct PrivateVoidCallInterface<N, Env> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\\n    is_static: bool\\n}\\n\\nimpl<N, Env> PrivateVoidCallInterface<N, Env> {\\n    pub fn call(self, context: &mut PrivateContext) {\\n        assert(self.args_hash == pack_arguments(self.args));\\n        context.call_private_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            false,\\n            false\\n        ).assert_empty();\\n    }\\n\\n    pub fn view(self, context: &mut PrivateContext) {\\n        assert(self.args_hash == pack_arguments(self.args));\\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\\n    }\\n\\n    pub fn delegate_call(self, context: &mut PrivateContext) {\\n        assert(self.args_hash == pack_arguments(self.args));\\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\\n    }\\n}\\n\\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\\n        self.original\\n    }\\n}\\n\\nstruct PrivateStaticCallInterface<N, T, Env> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\\n    is_static: bool\\n}\\n\\nimpl<N, T, Env> PrivateStaticCallInterface<N, T, Env> {\\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\\n        assert(self.args_hash == pack_arguments(self.args));\\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\\n        returns.unpack_into()\\n    }\\n}\\n\\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\\n        self.original\\n    }\\n}\\n\\nstruct PrivateStaticVoidCallInterface<N, Env> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\\n    is_static: bool\\n}\\n\\nimpl<N, Env> PrivateStaticVoidCallInterface<N, Env> {\\n    pub fn view(self, context: &mut PrivateContext) {\\n        assert(self.args_hash == pack_arguments(self.args));\\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\\n    }\\n}\\n\\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\\n        self.original\\n    }\\n}\\n\\nstruct PublicCallInterface<N, T, Env> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    gas_opts: GasOpts,\\n    original: fn[Env](PublicContextInputs) -> T,\\n    is_static: bool\\n}\\n\\nimpl<N, T, Env> PublicCallInterface<N, T, Env> {\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub fn call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\\n        returns.deserialize_into()\\n    }\\n\\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\\n        returns.deserialize_into()\\n    }\\n\\n    pub fn delegate_call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\\n        returns.deserialize_into()\\n    }\\n\\n    pub fn enqueue(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        assert(args_hash == pack_arguments(self.args));\\n        context.call_public_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/ false,\\n            /*delegate=*/ false\\n        )\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        assert(args_hash == pack_arguments(self.args));\\n        context.call_public_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/ true,\\n            /*delegate=*/ false\\n        )\\n    }\\n\\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        assert(args_hash == pack_arguments(self.args));\\n        context.call_public_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/ false,\\n            /*delegate=*/ true\\n        )\\n    }\\n}\\n\\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\\n        self.original\\n    }\\n}\\n\\nstruct PublicVoidCallInterface<N, Env> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    original: fn[Env](PublicContextInputs) -> (),\\n    is_static: bool,\\n    gas_opts: GasOpts\\n}\\n\\nimpl<N, Env> PublicVoidCallInterface<N, Env> {\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub fn call(self, context: &mut PublicContext) {\\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\\n        returns.assert_empty()\\n    }\\n\\n    pub fn view(self, context: &mut PublicContext) {\\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\\n        returns.assert_empty()\\n    }\\n\\n    pub fn delegate_call(self, context: &mut PublicContext) {\\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\\n        returns.assert_empty()\\n    }\\n\\n    pub fn enqueue(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        assert(args_hash == pack_arguments(self.args));\\n        context.call_public_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/ false,\\n            /*delegate=*/ false\\n        )\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        assert(args_hash == pack_arguments(self.args));\\n        context.call_public_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/ true,\\n            /*delegate=*/ false\\n        )\\n    }\\n\\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        assert(args_hash == pack_arguments(self.args));\\n        context.call_public_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/ false,\\n            /*delegate=*/ true\\n        )\\n    }\\n}\\n\\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\\n        self.original\\n    }\\n}\\n\\nstruct PublicStaticCallInterface<N, T, Env> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    original: fn[Env](PublicContextInputs) -> T,\\n    is_static: bool,\\n    gas_opts: GasOpts\\n}\\n\\nimpl<N, T, Env> PublicStaticCallInterface<N, T, Env> {\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\\n        let unpacked: T = returns.deserialize_into();\\n        unpacked\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        assert(args_hash == pack_arguments(self.args));\\n        context.call_public_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/ true,\\n            /*delegate=*/ false\\n        )\\n    }\\n}\\n\\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\\n        self.original\\n    }\\n}\\n\\nstruct PublicStaticVoidCallInterface<N, Env> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    original: fn[Env](PublicContextInputs) -> (),\\n    is_static: bool,\\n    gas_opts: GasOpts\\n}\\n\\nimpl<N, Env> PublicStaticVoidCallInterface<N, Env> {\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub fn view(self, context: &mut PublicContext) {\\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\\n        returns.assert_empty()\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        assert(args_hash == pack_arguments(self.args));\\n        context.call_public_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/ true,\\n            /*delegate=*/ false\\n        )\\n    }\\n}\\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\\n    oracle::{\\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\\n    call_private_function::call_private_function_internal, header::get_header_at,\\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\\n    enqueue_public_function_call::{\\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\\n    parse_public_call_stack_item_from_oracle\\n}\\n}\\n};\\nuse dep::protocol_types::{\\n    abis::{\\n    caller_context::CallerContext, function_selector::FunctionSelector,\\n    max_block_number::MaxBlockNumber,\\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\\n},\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\\n},\\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\\n};\\n\\n// When finished, one can call .finish() to convert back to the abi\\nstruct PrivateContext {\\n    // docs:start:private-context\\n    inputs: PrivateContextInputs,\\n    side_effect_counter: u32,\\n\\n    min_revertible_side_effect_counter: u32,\\n    is_fee_payer: bool,\\n\\n    args_hash: Field,\\n    return_hash: Field,\\n\\n    max_block_number: MaxBlockNumber,\\n\\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\\n\\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\\n\\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\\n    public_teardown_function_hash: Field,\\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\\n    // docs:end:private-context\\n\\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\\n    historical_header: Header,\\n\\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\\n\\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\\n    // fetching the same request multiple times.\\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\\n}\\n\\nimpl PrivateContext {\\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\\n        PrivateContext {\\n            inputs,\\n            side_effect_counter: inputs.start_side_effect_counter + 1,\\n            min_revertible_side_effect_counter: 0,\\n            is_fee_payer: false,\\n            args_hash,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            historical_header: inputs.historical_header,\\n            private_call_requests: BoundedVec::new(),\\n            public_call_stack_hashes: BoundedVec::new(),\\n            public_teardown_function_hash: 0,\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            note_encrypted_logs_hashes: BoundedVec::new(),\\n            encrypted_logs_hashes: BoundedVec::new(),\\n            unencrypted_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\\n        }\\n    }\\n\\n    fn msg_sender(self) -> AztecAddress {\\n        self.inputs.call_context.msg_sender\\n    }\\n\\n    fn this_address(self) -> AztecAddress {\\n        self.inputs.call_context.storage_contract_address\\n    }\\n\\n    fn chain_id(self) -> Field {\\n        self.inputs.tx_context.chain_id\\n    }\\n\\n    fn version(self) -> Field {\\n        self.inputs.tx_context.version\\n    }\\n\\n    fn selector(self) -> FunctionSelector {\\n        self.inputs.call_context.function_selector\\n    }\\n\\n    fn get_args_hash(self) -> Field {\\n        self.args_hash\\n    }\\n\\n    fn push_note_hash(&mut self, note_hash: Field) {\\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\\n    }\\n\\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\\n    // - consider creating a separate function with 1 arg for the zero note hash case.\\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\\n    }\\n\\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\\n    // included in).\\n    fn get_header(self) -> Header {\\n        self.historical_header\\n    }\\n\\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\\n    // of historical header.\\n    pub fn get_header_at(self, block_number: u32) -> Header {\\n        get_header_at(block_number, self)\\n    }\\n\\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\\n        pack_returns(returns_hasher.fields);\\n        self.return_hash = returns_hasher.hash();\\n    }\\n\\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\\n        PrivateCircuitPublicInputs {\\n            call_context: self.inputs.call_context,\\n            args_hash: self.args_hash,\\n            returns_hash: self.return_hash,\\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\\n            is_fee_payer: self.is_fee_payer,\\n            max_block_number: self.max_block_number,\\n            note_hash_read_requests: self.note_hash_read_requests.storage,\\n            nullifier_read_requests: self.nullifier_read_requests.storage,\\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\\n            note_hashes: self.note_hashes.storage,\\n            nullifiers: self.nullifiers.storage,\\n            private_call_requests: self.private_call_requests.storage,\\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\\n            public_teardown_function_hash: self.public_teardown_function_hash,\\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\\n            end_side_effect_counter: self.side_effect_counter,\\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\\n            historical_header: self.historical_header,\\n            tx_context: self.inputs.tx_context\\n        }\\n    }\\n\\n    pub fn set_as_fee_payer(&mut self) {\\n        dep::protocol_types::debug_log::debug_log_format(\\"Setting {0} as fee payer\\", [self.this_address().to_field()]);\\n        self.is_fee_payer = true;\\n    }\\n\\n    pub fn end_setup(&mut self) {\\n        // dep::protocol_types::debug_log::debug_log_format(\\n        //     \\"Ending setup at counter {0}\\",\\n        //     [self.side_effect_counter as Field]\\n        // );\\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\\n    }\\n\\n    // docs:start:max-block-number\\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\\n        // docs:end:max-block-number\\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\\n    }\\n\\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\\n        self.note_hash_read_requests.push(side_effect);\\n    }\\n\\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\\n        self.nullifier_read_requests.push(request);\\n    }\\n\\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\\n    }\\n\\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\\n    }\\n\\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\\n\\n        if cached_request.pk_m.hash() == pk_m_hash {\\n            // We get a match so the cached request is the latest one \\n            cached_request.sk_app\\n        } else {\\n            // We didn\'t get a match meaning the cached result is stale. We fetch new values from oracle and instruct\\n            // protocol circuits to validate them by storing the validation request in context.\\n            let request = get_key_validation_request(pk_m_hash, key_index);\\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\\n            // valid key request and not the one corresponding to pk_m_hash).\\n            assert(request.pk_m.hash() == pk_m_hash);\\n            self.key_validation_requests_and_generators.push(request_and_generator);\\n            self.last_key_validation_requests[key_index] = Option::some(request);\\n            request.sk_app\\n        }\\n    }\\n\\n    // docs:start:context_message_portal\\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\\n        // docs:end:context_message_portal\\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\\n        self.l2_to_l1_msgs.push(message);\\n    }\\n\\n    // docs:start:context_consume_l1_to_l2_message\\n    // docs:start:consume_l1_to_l2_message\\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\\n        // docs:end:context_consume_l1_to_l2_message\\n        let nullifier = process_l1_to_l2_message(\\n            self.historical_header.state.l1_to_l2_message_tree.root,\\n            self.this_address(),\\n            sender,\\n            self.chain_id(),\\n            self.version(),\\n            content,\\n            secret\\n        );\\n\\n        // Push nullifier (and the \\"commitment\\" corresponding to this can be \\"empty\\")\\n        self.push_nullifier(nullifier, 0)\\n    }\\n    // docs:end:consume_l1_to_l2_message\\n\\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\\n    // used in siloing later on e.g. \'handshaking\' contract w/ known address.\\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\\n        let counter = self.next_counter();\\n        let contract_address = self.this_address();\\n        let len = log.len() as Field + 4;\\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\\n        self.encrypted_logs_hashes.push(side_effect);\\n\\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\\n    }\\n\\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\\n        let counter = self.next_counter();\\n        let len = log.len() as Field + 4;\\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\\n        self.note_encrypted_logs_hashes.push(side_effect);\\n\\n        emit_encrypted_note_log(note_hash_counter, log, counter);\\n    }\\n\\n    pub fn call_private_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) -> PackedReturns {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\\n    }\\n\\n    pub fn static_call_private_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) -> PackedReturns {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\\n    }\\n\\n    pub fn delegate_call_private_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) -> PackedReturns {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\\n    }\\n\\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) -> PackedReturns {\\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\\n    }\\n\\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) -> PackedReturns {\\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\\n    }\\n\\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) -> PackedReturns {\\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\\n    }\\n\\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n        is_delegate_call: bool\\n    ) -> PackedReturns {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let start_side_effect_counter = self.side_effect_counter;\\n        let item = call_private_function_internal(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            start_side_effect_counter,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\\n        self.side_effect_counter = end_side_effect_counter + 1;\\n\\n        // TODO (fees) figure out why this crashes the prover and enable it\\n        // we need this in order to pay fees inside child call contexts\\n        // assert(\\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\\n        //     | (item.public_inputs.min_revertible_side_effect_counter\\n        //         > self.min_revertible_side_effect_counter)\\n        // );\\n\\n        // if item.public_inputs.min_revertible_side_effect_counter\\n        //     > self.min_revertible_side_effect_counter {\\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\\n        // }\\n\\n        assert(contract_address.eq(item.contract_address));\\n        assert(function_selector.eq(item.function_data.selector));\\n\\n        assert(args_hash == item.public_inputs.args_hash);\\n\\n        // Assert that the call context of the call generated by the oracle matches our request.\\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\\n\\n        if (is_delegate_call) {\\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\\n            assert(\\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\\n            );\\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\\n        } else {\\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\\n            assert(\\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\\n            );\\n        }\\n\\n        let mut caller_context = CallerContext::empty();\\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\\n        if is_delegate_call {\\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\\n        }\\n        self.private_call_requests.push(\\n            PrivateCallRequest {\\n            target: item.contract_address,\\n            call_context: item.public_inputs.call_context,\\n            function_data: item.function_data,\\n            args_hash: item.public_inputs.args_hash,\\n            returns_hash: item.public_inputs.returns_hash,\\n            caller_context,\\n            start_side_effect_counter,\\n            end_side_effect_counter\\n        }\\n        );\\n\\n        PackedReturns::new(item.public_inputs.returns_hash)\\n    }\\n\\n    pub fn call_public_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\\n    }\\n\\n    pub fn static_call_public_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\\n    }\\n\\n    pub fn delegate_call_public_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\\n    }\\n\\n    pub fn call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) {\\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\\n    }\\n\\n    pub fn static_call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) {\\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\\n    }\\n\\n    pub fn delegate_call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) {\\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\\n    }\\n\\n    pub fn call_public_function_with_packed_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n        is_delegate_call: bool\\n    ) {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let fields = enqueue_public_function_call_internal(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            self.side_effect_counter,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        let item = parse_public_call_stack_item_from_oracle(fields);\\n        self.validate_call_stack_item_from_oracle(\\n            item,\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        self.side_effect_counter = self.side_effect_counter + 1;\\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\\n    }\\n\\n    pub fn set_public_teardown_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\\n    }\\n\\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n        is_delegate_call: bool\\n    ) {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let fields = set_public_teardown_function_call_internal(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            self.side_effect_counter,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        let item = parse_public_call_stack_item_from_oracle(fields);\\n        self.validate_call_stack_item_from_oracle(\\n            item,\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        self.side_effect_counter = self.side_effect_counter + 1;\\n        self.public_teardown_function_hash = item.get_compressed().hash();\\n    }\\n\\n    fn validate_call_stack_item_from_oracle(\\n        self,\\n        item: PublicCallStackItem,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n        is_delegate_call: bool\\n    ) {\\n        assert(contract_address.eq(item.contract_address));\\n        assert(function_selector.eq(item.function_data.selector));\\n\\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\\n\\n        assert(args_hash == item.public_inputs.args_hash);\\n\\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\\n\\n        if (is_delegate_call) {\\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\\n            assert(\\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\\n            );\\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\\n        } else {\\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\\n            assert(\\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\\n            );\\n        }\\n    }\\n\\n    fn next_counter(&mut self) -> u32 {\\n        let counter = self.side_effect_counter;\\n        self.side_effect_counter += 1;\\n        counter\\n    }\\n}\\n\\nimpl Empty for PrivateContext {\\n    fn empty() -> Self {\\n        PrivateContext {\\n            inputs: PrivateContextInputs::empty(),\\n            side_effect_counter: 0 as u32,\\n            min_revertible_side_effect_counter: 0 as u32,\\n            is_fee_payer: false,\\n            args_hash: 0,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            private_call_requests: BoundedVec::new(),\\n            public_call_stack_hashes: BoundedVec::new(),\\n            public_teardown_function_hash: 0,\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            historical_header: Header::empty(),\\n            note_encrypted_logs_hashes: BoundedVec::new(),\\n            encrypted_logs_hashes: BoundedVec::new(),\\n            unencrypted_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\\n        }\\n    }\\n}\\n"},"95":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\\nuse crate::context::gas::GasOpts;\\n\\nstruct PublicContext {\\n    inputs: PublicContextInputs,\\n}\\n\\nimpl PublicContext {\\n    pub fn new(inputs: PublicContextInputs) -> Self {\\n        PublicContext { inputs }\\n    }\\n\\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\\n    }\\n\\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\\n        note_hash_exists(note_hash, leaf_index) == 1\\n    }\\n\\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\\n    }\\n\\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\\n    }\\n\\n    fn consume_l1_to_l2_message(\\n        &mut self,\\n        content: Field,\\n        secret: Field,\\n        sender: EthAddress,\\n        leaf_index: Field\\n    ) {\\n        let secret_hash = compute_secret_hash(secret);\\n        let message_hash = compute_message_hash(\\n            sender,\\n            self.chain_id(),\\n            /*recipient=*/ self.this_address(),\\n            self.version(),\\n            content,\\n            secret_hash\\n        );\\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\\n\\n        assert(\\n            !self.nullifier_exists(nullifier, self.this_address()), \\"L1-to-L2 message is already nullified\\"\\n        );\\n        assert(\\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \\"Tried to consume nonexistent L1-to-L2 message\\"\\n        );\\n\\n        // Push nullifier (and the \\"commitment\\" corresponding to this can be \\"empty\\")\\n        self.push_nullifier(nullifier, 0);\\n    }\\n\\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\\n        send_l2_to_l1_msg(recipient, content);\\n    }\\n\\n    fn call_public_function<RETURNS_COUNT>(\\n        self: &mut Self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field],\\n        gas_opts: GasOpts\\n    ) -> FunctionReturns<RETURNS_COUNT> {\\n        let results = call(\\n            gas_for_call(gas_opts),\\n            contract_address,\\n            args,\\n            function_selector.to_field()\\n        );\\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\\n        let success: u8 = results.1;\\n        assert(success == 1, \\"Nested call failed!\\");\\n\\n        FunctionReturns::new(data_to_return)\\n    }\\n\\n    fn static_call_public_function<RETURNS_COUNT>(\\n        self: &mut Self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field],\\n        gas_opts: GasOpts\\n    ) -> FunctionReturns<RETURNS_COUNT> {\\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\\n            gas_for_call(gas_opts),\\n            contract_address,\\n            args,\\n            function_selector.to_field()\\n        );\\n\\n        assert(success == 1, \\"Nested static call failed!\\");\\n        FunctionReturns::new(data_to_return)\\n    }\\n\\n    fn delegate_call_public_function<RETURNS_COUNT>(\\n        self: &mut Self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field]\\n    ) -> FunctionReturns<RETURNS_COUNT> {\\n        assert(false, \\"\'delegate_call_public_function\' not implemented!\\");\\n        FunctionReturns::new([0; RETURNS_COUNT])\\n    }\\n\\n    fn push_note_hash(&mut self, note_hash: Field) {\\n        emit_note_hash(note_hash);\\n    }\\n    fn push_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\\n        emit_nullifier(nullifier);\\n    }\\n\\n    fn this_address(self) -> AztecAddress {\\n        address()\\n    }\\n    pub fn storage_address(self) -> AztecAddress {\\n        storage_address()\\n    }\\n    fn msg_sender(self) -> AztecAddress {\\n        sender()\\n    }\\n    fn selector(self) -> FunctionSelector {\\n        FunctionSelector::from_u32(function_selector())\\n    }\\n    fn get_args_hash(self) -> Field {\\n        self.inputs.args_hash\\n    }\\n    fn transaction_fee(self) -> Field {\\n        transaction_fee()\\n    }\\n\\n    fn chain_id(self) -> Field {\\n        chain_id()\\n    }\\n    fn version(self) -> Field {\\n        version()\\n    }\\n    fn block_number(self) -> Field {\\n        block_number()\\n    }\\n    fn timestamp(self) -> u64 {\\n        timestamp()\\n    }\\n    pub fn fee_per_l2_gas(self) -> Field {\\n        fee_per_l2_gas()\\n    }\\n    pub fn fee_per_da_gas(self) -> Field {\\n        fee_per_da_gas()\\n    }\\n\\n    fn l2_gas_left(self) -> Field {\\n        l2_gas_left()\\n    }\\n    fn da_gas_left(self) -> Field {\\n        da_gas_left()\\n    }\\n\\n    fn raw_storage_read<N>(_self: Self, storage_slot: Field) -> [Field; N] {\\n        storage_read(storage_slot)\\n    }\\n\\n    fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\\n        T::deserialize(self.raw_storage_read(storage_slot))\\n    }\\n\\n    fn raw_storage_write<N>(_self: Self, storage_slot: Field, values: [Field; N]) {\\n        storage_write(storage_slot, values);\\n    }\\n\\n    fn storage_write<T, N>(self, storage_slot: Field, value: T) where T: Serialize<N> {\\n        self.raw_storage_write(storage_slot, value.serialize());\\n    }\\n}\\n\\n// Helper functions\\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\\n    // It\'s ok to use the max possible gas here, because the gas will be\\n    // capped by the gas left in the (STATIC)CALL instruction.\\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\\n    [\\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\\n    ]\\n}\\n\\n// Unconstrained opcode wrappers (do not use directly).\\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\\nunconstrained fn address() -> AztecAddress {\\n    address_opcode()\\n}\\nunconstrained fn storage_address() -> AztecAddress {\\n    storage_address_opcode()\\n}\\nunconstrained fn sender() -> AztecAddress {\\n    sender_opcode()\\n}\\nunconstrained fn portal() -> EthAddress {\\n    portal_opcode()\\n}\\nunconstrained fn function_selector() -> u32 {\\n    function_selector_opcode()\\n}\\nunconstrained fn transaction_fee() -> Field {\\n    transaction_fee_opcode()\\n}\\nunconstrained fn chain_id() -> Field {\\n    chain_id_opcode()\\n}\\nunconstrained fn version() -> Field {\\n    version_opcode()\\n}\\nunconstrained fn block_number() -> Field {\\n    block_number_opcode()\\n}\\nunconstrained fn timestamp() -> u64 {\\n    timestamp_opcode()\\n}\\nunconstrained fn fee_per_l2_gas() -> Field {\\n    fee_per_l2_gas_opcode()\\n}\\nunconstrained fn fee_per_da_gas() -> Field {\\n    fee_per_da_gas_opcode()\\n}\\nunconstrained fn l2_gas_left() -> Field {\\n    l2_gas_left_opcode()\\n}\\nunconstrained fn da_gas_left() -> Field {\\n    da_gas_left_opcode()\\n}\\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\\n    note_hash_exists_opcode(note_hash, leaf_index)\\n}\\nunconstrained fn emit_note_hash(note_hash: Field) {\\n    emit_note_hash_opcode(note_hash)\\n}\\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\\n    nullifier_exists_opcode(nullifier, address)\\n}\\nunconstrained fn emit_nullifier(nullifier: Field) {\\n    emit_nullifier_opcode(nullifier)\\n}\\nunconstrained fn emit_unencrypted_log(message: [Field]) {\\n    emit_unencrypted_log_opcode(message)\\n}\\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\\n}\\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\\n    send_l2_to_l1_msg_opcode(recipient, content)\\n}\\nunconstrained fn call<RET_SIZE>(\\n    gas: [Field; 2],\\n    address: AztecAddress,\\n    args: [Field],\\n    function_selector: Field\\n) -> ([Field; RET_SIZE], u8) {\\n    call_opcode(gas, address, args, function_selector)\\n}\\nunconstrained fn call_static<RET_SIZE>(\\n    gas: [Field; 2],\\n    address: AztecAddress,\\n    args: [Field],\\n    function_selector: Field\\n) -> ([Field; RET_SIZE], u8) {\\n    call_static_opcode(gas, address, args, function_selector)\\n}\\n\\nunconstrained fn storage_read<N>(storage_slot: Field) -> [Field; N] {\\n    storage_read_opcode(storage_slot, N)\\n}\\n\\nunconstrained fn storage_write<N>(storage_slot: Field, values: [Field; N]) {\\n    storage_write_opcode(storage_slot, values);\\n}\\n\\nimpl Empty for PublicContext {\\n    fn empty() -> Self {\\n        PublicContext::new(PublicContextInputs::empty())\\n    }\\n}\\n\\n// AVM oracles (opcodes) follow, do not use directly.\\n#[oracle(avmOpcodeAddress)]\\nunconstrained fn address_opcode() -> AztecAddress {}\\n\\n#[oracle(avmOpcodeStorageAddress)]\\nunconstrained fn storage_address_opcode() -> AztecAddress {}\\n\\n#[oracle(avmOpcodeSender)]\\nunconstrained fn sender_opcode() -> AztecAddress {}\\n\\n#[oracle(avmOpcodePortal)]\\nunconstrained fn portal_opcode() -> EthAddress {}\\n\\n#[oracle(avmOpcodeFunctionSelector)]\\nunconstrained fn function_selector_opcode() -> u32 {}\\n\\n#[oracle(avmOpcodeTransactionFee)]\\nunconstrained fn transaction_fee_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeChainId)]\\nunconstrained fn chain_id_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeVersion)]\\nunconstrained fn version_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeBlockNumber)]\\nunconstrained fn block_number_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeTimestamp)]\\nunconstrained fn timestamp_opcode() -> u64 {}\\n\\n#[oracle(avmOpcodeFeePerL2Gas)]\\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeFeePerDaGas)]\\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeL2GasLeft)]\\nunconstrained fn l2_gas_left_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeDaGasLeft)]\\nunconstrained fn da_gas_left_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeNoteHashExists)]\\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\\n\\n#[oracle(avmOpcodeEmitNoteHash)]\\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\\n\\n#[oracle(avmOpcodeNullifierExists)]\\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\\n\\n#[oracle(avmOpcodeEmitNullifier)]\\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\\n\\n#[oracle(avmOpcodeEmitUnencryptedLog)]\\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\\n\\n#[oracle(avmOpcodeL1ToL2MsgExists)]\\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\\n\\n#[oracle(avmOpcodeSendL2ToL1Msg)]\\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\\n\\n#[oracle(avmOpcodeCall)]\\nunconstrained fn call_opcode<RET_SIZE>(\\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\\n    address: AztecAddress,\\n    args: [Field],\\n    // TODO(5110): consider passing in calldata directly\\n    function_selector: Field\\n) -> ([Field; RET_SIZE], u8) {}\\n//    ^ return data      ^ success\\n\\n#[oracle(avmOpcodeStaticCall)]\\nunconstrained fn call_static_opcode<RET_SIZE>(\\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\\n    address: AztecAddress,\\n    args: [Field],\\n    // TODO(5110): consider passing in calldata directly\\n    function_selector: Field\\n) -> ([Field; RET_SIZE], u8) {}\\n//    ^ return data      ^ success\\n\\n#[oracle(avmOpcodeStorageRead)]\\nunconstrained fn storage_read_opcode<N>(storage_slot: Field, length: Field) -> [Field; N] {}\\n\\n#[oracle(avmOpcodeStorageWrite)]\\nunconstrained fn storage_write_opcode<N>(storage_slot: Field, values: [Field; N]) {}\\n\\nstruct FunctionReturns<N> {\\n    values: [Field; N]\\n}\\n\\nimpl<N> FunctionReturns<N> {\\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\\n        FunctionReturns { values }\\n    }\\n\\n    pub fn assert_empty(returns: FunctionReturns<0>) {\\n        assert(returns.values.len() == 0);\\n    }\\n\\n    pub fn raw(self) -> [Field; N] {\\n        self.values\\n    }\\n\\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\\n        Deserialize::deserialize(self.raw())\\n    }\\n}\\n"},"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\\n},\\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\\n};\\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\\n\\npub fn compute_secret_hash(secret: Field) -> Field {\\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\\n}\\n\\npub fn compute_unencrypted_log_hash<T, N, M>(\\n    contract_address: AztecAddress,\\n    log: T\\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\\n    // can\'t use N - not in scope error\\n    let n = message_bytes.len();\\n    let mut hash_bytes = [0; M];\\n    // Address is converted to 32 bytes in ts\\n    let address_bytes = contract_address.to_be_bytes_arr();\\n    for i in 0..32 {\\n        hash_bytes[i] = address_bytes[i];\\n    }\\n    let len_bytes = (n as Field).to_be_bytes(4);\\n    for i in 0..4 {\\n        hash_bytes[32 + i] = len_bytes[i];\\n    }\\n    for i in 0..n {\\n        hash_bytes[36 + i] = message_bytes[i];\\n    }\\n\\n    sha256_to_field(hash_bytes)\\n}\\n\\npub fn compute_message_hash(\\n    sender: EthAddress,\\n    chain_id: Field,\\n    recipient: AztecAddress,\\n    version: Field,\\n    content: Field,\\n    secret_hash: Field\\n) -> Field {\\n    let mut hash_bytes = [0 as u8; 192];\\n    let sender_bytes = sender.to_field().to_be_bytes(32);\\n    let chain_id_bytes = chain_id.to_be_bytes(32);\\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\\n    let version_bytes = version.to_be_bytes(32);\\n    let content_bytes = content.to_be_bytes(32);\\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\\n\\n    for i in 0..32 {\\n        hash_bytes[i] = sender_bytes[i];\\n        hash_bytes[i + 32] = chain_id_bytes[i];\\n        hash_bytes[i + 64] = recipient_bytes[i];\\n        hash_bytes[i + 96] = version_bytes[i];\\n        hash_bytes[i + 128] = content_bytes[i];\\n        hash_bytes[i + 160] = secret_hash_bytes[i];\\n    }\\n\\n    sha256_to_field(hash_bytes)\\n}\\n\\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\\n// in the L1 to L2 message tree\\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\\n    pedersen_hash(\\n        [message_hash, secret, leaf_index],\\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\\n    )\\n}\\n\\nstruct ArgsHasher {\\n    fields: [Field],\\n}\\n\\nimpl Hash for ArgsHasher {\\n    fn hash(self) -> Field {\\n        hash_args(self.fields)\\n    }\\n}\\n\\nimpl ArgsHasher {\\n    pub fn new() -> Self {\\n        Self { fields: [] }\\n    }\\n\\n    pub fn add(&mut self, field: Field) {\\n        self.fields = self.fields.push_back(field);\\n    }\\n\\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\\n        for i in 0..N {\\n            self.fields = self.fields.push_back(fields[i]);\\n        }\\n    }\\n}\\n\\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\\n    hash_args(args.as_slice())\\n}\\n\\npub fn hash_args(args: [Field]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        assert(args.len() <= MAX_ARGS_LENGTH, \\"Args length exceeds maximum\\");\\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\\n\\n        let mut current_chunk_index = 0;\\n        let mut index_inside_current_chunk = 0;\\n        for i in 0..args.len() {\\n            current_chunk_values[index_inside_current_chunk] = args[i];\\n            index_inside_current_chunk+=1;\\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\\n                current_chunk_index+=1;\\n                index_inside_current_chunk = 0;\\n            }\\n        }\\n        if index_inside_current_chunk > 0 {\\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\\n        }\\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\n#[test]\\nfn compute_var_args_hash() {\\n    let mut input = ArgsHasher::new();\\n    for i in 0..MAX_ARGS_LENGTH {\\n        input.add(i as Field);\\n    }\\n    let hash = input.hash();\\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\\n}\\n\\n#[test]\\nfn compute_unenc_log_hash_array() {\\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\\n    let log = [\\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\\n    ];\\n    let hash = compute_unencrypted_log_hash(contract_address, log);\\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\\n}\\n\\n#[test]\\nfn compute_unenc_log_hash_addr() {\\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\\n    let hash = compute_unencrypted_log_hash(contract_address, log);\\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\\n}\\n\\n#[test]\\nfn compute_unenc_log_hash_str() {\\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\\n    let log = \\"dummy\\";\\n    let hash = compute_unencrypted_log_hash(contract_address, log);\\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\\n}\\n\\n#[test]\\nfn compute_unenc_log_hash_longer_str() {\\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\\n    let log = \\"Hello this is a string\\";\\n    let hash = compute_unencrypted_log_hash(contract_address, log);\\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\\n}\\n"},"125":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\\nunconstrained fn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\\n\\n#[oracle(packArguments)]\\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\\n\\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\\n///   some point in the call. \\n/// - When the external call is made later, the simulator will know what the values unpack to.\\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \\n///   itself.\\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\\n    pack_arguments_array_oracle(args)\\n}\\n\\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\\n///   some point in the call. \\n/// - When the external call is made later, the simulator will know what the values unpack to.\\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \\n///   itself.\\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\\n    pack_arguments_oracle(args)\\n}\\n\\n"},"127":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"#[oracle(packReturns)]\\nunconstrained fn pack_returns_oracle<N>(_returns: [Field]) -> Field {}\\n\\nunconstrained pub fn pack_returns(returns: [Field]) {\\n    let _unused = pack_returns_oracle(returns);\\n}\\n\\n#[oracle(unpackReturns)]\\nunconstrained fn unpack_returns_oracle<N>(_return_hash: Field) -> [Field; N] {}\\n\\nunconstrained pub fn unpack_returns<N>(return_hash: Field) -> [Field; N] {\\n    unpack_returns_oracle(return_hash)\\n}\\n"},"132":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\\n\\n#[oracle(storageRead)]\\nunconstrained fn storage_read_oracle<N>(\\n    address: Field,\\n    storage_slot: Field,\\n    block_number: Field,\\n    length: Field\\n) -> [Field; N] {}\\n\\nunconstrained pub fn raw_storage_read<N>(\\n    address: AztecAddress,\\n    storage_slot: Field,\\n    block_number: u32\\n) -> [Field; N] {\\n    storage_read_oracle(address.to_field(), storage_slot, block_number as Field, N)\\n}\\n\\nunconstrained pub fn storage_read<T, N>(\\n    address: AztecAddress,\\n    storage_slot: Field,\\n    block_number: u32\\n) -> T where T: Deserialize<N> {\\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\\n}\\n\\nmod tests {\\n    use crate::oracle::storage::{raw_storage_read, storage_read};\\n    use dep::protocol_types::address::AztecAddress;\\n\\n    use std::test::OracleMock;\\n    use crate::test::mocks::mock_struct::MockStruct;\\n\\n    global address = AztecAddress::from_field(29);\\n    global slot = 7;\\n    global block_number = 17;\\n\\n    #[test]\\n    fn test_raw_storage_read() {\\n        let written = MockStruct { a: 13, b: 42 };\\n\\n        let _ = OracleMock::mock(\\"storageRead\\").returns(written.serialize());\\n\\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\\n        assert_eq(read[0], 13);\\n        assert_eq(read[1], 42);\\n    }\\n\\n    #[test]\\n    fn test_storage_read() {\\n        let written = MockStruct { a: 13, b: 42 };\\n\\n        let _ = OracleMock::mock(\\"storageRead\\").returns(written.serialize());\\n\\n        let read: MockStruct = storage_read(address, slot, block_number);\\n        assert_eq(read.a, 13);\\n        assert_eq(read.b, 42);\\n    }\\n}\\n"},"135":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\\n};\\n\\n#[oracle(callPrivateFunction)]\\nunconstrained fn call_private_function_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _start_side_effect_counter: u32,\\n    _is_static_call: bool,\\n    _is_delegate_call: bool\\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\\n\\nunconstrained pub fn call_private_function_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    start_side_effect_counter: u32,\\n    is_static_call: bool,\\n    is_delegate_call: bool\\n) -> PrivateCallStackItem {\\n    let fields = call_private_function_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        start_side_effect_counter,\\n        is_static_call,\\n        is_delegate_call\\n    );\\n\\n    PrivateCallStackItem::deserialize(fields)\\n}\\n"},"140":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{\\n    abis::{\\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\\n},\\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\\n    utils::reader::Reader,\\n    constants::{\\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\\n}\\n};\\n\\n#[oracle(enqueuePublicFunctionCall)]\\nunconstrained fn enqueue_public_function_call_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _side_effect_counter: u32,\\n    _is_static_call: bool,\\n    _is_delegate_call: bool\\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\\n\\nunconstrained pub fn enqueue_public_function_call_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    side_effect_counter: u32,\\n    is_static_call: bool,\\n    is_delegate_call: bool\\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\\n    enqueue_public_function_call_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        side_effect_counter,\\n        is_static_call,\\n        is_delegate_call\\n    )\\n}\\n\\n#[oracle(setPublicTeardownFunctionCall)]\\nunconstrained fn set_public_teardown_function_call_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _side_effect_counter: u32,\\n    _is_static_call: bool,\\n    _is_delegate_call: bool\\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\\n\\nunconstrained pub fn set_public_teardown_function_call_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    side_effect_counter: u32,\\n    is_static_call: bool,\\n    is_delegate_call: bool\\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\\n    set_public_teardown_function_call_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        side_effect_counter,\\n        is_static_call,\\n        is_delegate_call\\n    )\\n}\\n\\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\\n    let mut reader = Reader::new(fields);\\n\\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\\n    // WARNING: if updating, see comment in public_call_stack_item.ts\'s PublicCallStackItem.hash()\\n    let item = PublicCallStackItem {\\n        contract_address: AztecAddress::from_field(reader.read()),\\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\\n        public_inputs: PublicCircuitPublicInputs {\\n            call_context: reader.read_struct(CallContext::deserialize),\\n            start_side_effect_counter: reader.read_u32(),\\n            args_hash: reader.read(),\\n            returns_hash: 0,\\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\\n            end_side_effect_counter: 0,\\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\\n            historical_header: Header::empty(),\\n            global_variables: GlobalVariables::empty(),\\n            prover_address: AztecAddress::zero(),\\n            revert_code: 0,\\n            start_gas_left: Gas::empty(),\\n            end_gas_left: Gas::empty(),\\n            transaction_fee: 0\\n        },\\n        is_execution_request: true\\n    };\\n    reader.finish();\\n\\n    item\\n}\\n"},"144":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{hash::pedersen_hash, storage::map::derive_storage_slot_in_map, traits::ToField};\\nuse crate::state_vars::storage::Storage;\\n\\n// docs:start:map\\nstruct Map<K, V, Context> {\\n    context: Context,\\n    storage_slot: Field,\\n    state_var_constructor: fn(Context, Field) -> V,\\n}\\n// docs:end:map\\n\\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\\n\\nimpl<K, V, Context> Map<K, V, Context> {\\n    // docs:start:new\\n    pub fn new(\\n        context: Context,\\n        storage_slot: Field,\\n        state_var_constructor: fn(Context, Field) -> V\\n    ) -> Self {\\n        assert(storage_slot != 0, \\"Storage slot 0 not allowed. Storage slots must start from 1.\\");\\n        Map { context, storage_slot, state_var_constructor }\\n    }\\n    // docs:end:new\\n\\n    // docs:start:at\\n    pub fn at(self, key: K) -> V where K: ToField {\\n        // TODO(#1204): use a generator index for the storage slot\\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\\n\\n        let state_var_constructor = self.state_var_constructor;\\n        state_var_constructor(self.context, derived_storage_slot)\\n    }\\n    // docs:end:at\\n}\\n"},"146":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\\nuse crate::oracle::storage::storage_read;\\nuse dep::protocol_types::traits::{Deserialize, Serialize};\\nuse crate::state_vars::storage::Storage;\\n\\n// docs:start:public_mutable_struct\\nstruct PublicMutable<T, Context> {\\n    context: Context,\\n    storage_slot: Field,\\n}\\n// docs:end:public_mutable_struct\\n\\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\\n\\nimpl<T, Context> PublicMutable<T, Context> {\\n    // docs:start:public_mutable_struct_new\\n    pub fn new(\\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\\n        context: Context,\\n        storage_slot: Field\\n    ) -> Self {\\n        assert(storage_slot != 0, \\"Storage slot 0 not allowed. Storage slots must start from 1.\\");\\n        PublicMutable { context, storage_slot }\\n    }\\n    // docs:end:public_mutable_struct_new\\n}\\n\\nimpl<T> PublicMutable<T, &mut PublicContext> {\\n    // docs:start:public_mutable_struct_read\\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\\n        self.context.storage_read(self.storage_slot)\\n    }\\n    // docs:end:public_mutable_struct_read\\n\\n    // docs:start:public_mutable_struct_write\\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\\n        self.context.storage_write(self.storage_slot, value);\\n    }\\n    // docs:end:public_mutable_struct_write\\n}\\n\\nimpl<T> PublicMutable<T, UnconstrainedContext> {\\n    unconstrained pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\\n        self.context.storage_read(self.storage_slot)\\n    }\\n}\\n"},"167":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr","source":"use crate::{\\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\\n    constants::{GAS_LENGTH, FIXED_DA_GAS, FIXED_L2_GAS}, hash::pedersen_hash,\\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\\n    abis::gas_fees::GasFees\\n};\\nuse std::ops::{Add, Sub};\\n\\nstruct Gas {\\n    da_gas: u32,\\n    l2_gas: u32,\\n}\\n\\nimpl Gas {\\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\\n        Self { da_gas, l2_gas }\\n    }\\n\\n    pub fn tx_overhead() -> Self {\\n        Self { da_gas: FIXED_DA_GAS, l2_gas: FIXED_L2_GAS }\\n    }\\n\\n    pub fn compute_fee(self, fees: GasFees) -> Field {\\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\\n    }\\n\\n    pub fn is_empty(self) -> bool {\\n        (self.da_gas == 0) & (self.l2_gas == 0)\\n    }\\n\\n    pub fn within(self, limits: Gas) -> bool {\\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\\n    }\\n}\\n\\nimpl Add for Gas {\\n    fn add(self, other: Gas) -> Self {\\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\\n    }\\n}\\n\\nimpl Sub for Gas {\\n    fn sub(self, other: Gas) -> Self {\\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\\n    }\\n}\\n\\nimpl Serialize<GAS_LENGTH> for Gas {\\n    fn serialize(self) -> [Field; GAS_LENGTH] {\\n        [self.da_gas as Field, self.l2_gas as Field]\\n    }\\n}\\n\\nimpl Deserialize<GAS_LENGTH> for Gas {\\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\\n    }\\n}\\n\\nimpl Eq for Gas {\\n    fn eq(self, other : Gas) -> bool {\\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\\n    }\\n}\\n\\nimpl Empty for Gas {\\n    fn empty() -> Self {\\n        Gas::new(0, 0)\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = Gas::empty();\\n    let serialized = item.serialize();\\n    let deserialized = Gas::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n\\n"},"169":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr","source":"use crate::{\\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\\n    utils::{arrays::array_concat, reader::Reader}\\n};\\n\\nstruct NoteHash {\\n    value: Field,\\n    counter: u32,\\n}\\n\\nimpl Ordered for NoteHash {\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl Eq for NoteHash {\\n    fn eq(self, other: NoteHash) -> bool {\\n        (self.value == other.value)\\n            & (self.counter == other.counter) \\n    }\\n}\\n\\nimpl Empty for NoteHash {\\n    fn empty() -> Self {\\n        NoteHash {\\n            value: 0,\\n            counter: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\\n        [self.value, self.counter as Field]\\n    }\\n}\\n\\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\\n        Self {\\n            value: values[0],\\n            counter: values[1] as u32,\\n        }\\n    }\\n}\\n\\nimpl NoteHash {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNoteHash {\\n        ScopedNoteHash { note_hash: self, contract_address }\\n    }\\n}\\n\\nstruct ScopedNoteHash {\\n    note_hash: NoteHash,\\n    contract_address: AztecAddress,\\n}\\n\\nimpl Scoped<NoteHash> for ScopedNoteHash {\\n    fn inner(self) -> NoteHash {\\n        self.note_hash\\n    }\\n    fn contract_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n}\\n\\nimpl Ordered for ScopedNoteHash {\\n    fn counter(self) -> u32 {\\n        self.note_hash.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for ScopedNoteHash {\\n    fn value(self) -> Field {\\n        self.note_hash.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.note_hash.counter\\n    }\\n}\\n\\nimpl Eq for ScopedNoteHash {\\n    fn eq(self, other: ScopedNoteHash) -> bool {\\n        (self.note_hash == other.note_hash)\\n            & (self.contract_address == other.contract_address)\\n    }\\n}\\n\\nimpl Empty for ScopedNoteHash {\\n    fn empty() -> Self {\\n        ScopedNoteHash {\\n            note_hash: NoteHash::empty(),\\n            contract_address: AztecAddress::zero(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\\n        array_concat(self.note_hash.serialize(), [self.contract_address.to_field()])\\n    }\\n}\\n\\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\\n        let mut reader = Reader::new(values);\\n        let res = Self {\\n            note_hash: reader.read_struct(NoteHash::deserialize),\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n        };\\n        reader.finish();\\n        res\\n    }\\n}\\n\\nimpl Readable for ScopedNoteHash {\\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\\n        assert_eq(self.note_hash.value, read_request.value(), \\"Value of the note hash does not match read request\\");\\n        assert_eq(self.contract_address, read_request.contract_address, \\"Contract address of the note hash does not match read request\\");\\n        assert(\\n            read_request.counter() > self.note_hash.counter, \\"Read request counter must be greater than the counter of the note hash\\"\\n        );\\n    }\\n}\\n\\nimpl ScopedNoteHash {\\n    pub fn expose_to_public(self) -> NoteHash {\\n        // Hide the actual counter when exposing it to the public kernel.\\n        NoteHash { value: self.note_hash.value, counter: 0 }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = NoteHash::empty();\\n    let serialized = item.serialize();\\n    let deserialized = NoteHash::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n\\n#[test]\\nfn serialization_of_empty_scoped() {\\n    let item = ScopedNoteHash::empty();\\n    let serialized = item.serialize();\\n    let deserialized = ScopedNoteHash::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"170":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr","source":"use crate::{\\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\\n    abis::side_effect::Ordered, utils::reader::Reader\\n};\\n\\nstruct GasFees {\\n    fee_per_da_gas: Field,\\n    fee_per_l2_gas: Field,\\n}\\n\\nimpl GasFees {\\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\\n        Self { fee_per_da_gas, fee_per_l2_gas }\\n    }\\n\\n    pub fn default() -> Self {\\n        GasFees::new(1, 1)\\n    }\\n\\n    pub fn is_empty(self) -> bool {\\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\\n    }\\n}\\n\\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\\n    }\\n}\\n\\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\\n        GasFees::new(serialized[0], serialized[1])\\n    }\\n}\\n\\nimpl Eq for GasFees {\\n    fn eq(self, other : GasFees) -> bool {\\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\\n    }\\n}\\n\\nimpl Empty for GasFees {\\n    fn empty() -> Self {\\n        GasFees::new(0, 0)\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = GasFees::empty();\\n    let serialized = item.serialize();\\n    let deserialized = GasFees::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"172":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr","source":"use crate::{\\n    abis::{\\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\\n},\\n    constants::{\\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL, MAX_NULLIFIERS_PER_CALL,\\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\\n    MAX_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\\n},\\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\\n    transaction::tx_context::TxContext, utils::arrays::validate_array\\n};\\n\\nstruct PrivateCircuitPublicInputsArrayLengths {\\n    note_hash_read_requests: u32,\\n    nullifier_read_requests: u32,\\n    key_validation_requests_and_generators: u32,\\n    note_hashes: u32,\\n    nullifiers: u32,\\n    l2_to_l1_msgs: u32,\\n    private_call_requests: u32,\\n    public_call_stack_hashes: u32,\\n    note_encrypted_logs_hashes: u32,\\n    encrypted_logs_hashes: u32,\\n    unencrypted_logs_hashes: u32,\\n}\\n\\nimpl PrivateCircuitPublicInputsArrayLengths {\\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\\n        PrivateCircuitPublicInputsArrayLengths {\\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\\n            note_hashes: validate_array(public_inputs.note_hashes),\\n            nullifiers: validate_array(public_inputs.nullifiers),\\n            l2_to_l1_msgs: validate_array(public_inputs.l2_to_l1_msgs),\\n            private_call_requests: validate_array(public_inputs.private_call_requests),\\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\\n        }\\n    }\\n}\\n\\nstruct PrivateCircuitPublicInputs {\\n    call_context: CallContext,\\n\\n    args_hash: Field,\\n    returns_hash: Field,\\n\\n    min_revertible_side_effect_counter: u32,\\n    is_fee_payer: bool,\\n\\n    max_block_number: MaxBlockNumber,\\n\\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\\n\\n    note_hashes: [NoteHash; MAX_NOTE_HASHES_PER_CALL],\\n    nullifiers: [Nullifier; MAX_NULLIFIERS_PER_CALL],\\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\\n    public_teardown_function_hash: Field,\\n    l2_to_l1_msgs: [L2ToL1Message; MAX_L2_TO_L1_MSGS_PER_CALL],\\n\\n    start_side_effect_counter : u32,\\n    end_side_effect_counter : u32,\\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\\n\\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\\n    historical_header: Header,\\n\\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\\n    tx_context: TxContext,\\n}\\n\\nimpl Eq for PrivateCircuitPublicInputs {\\n    fn eq(self, other: Self) -> bool {\\n        self.call_context.eq(other.call_context) &\\n        self.args_hash.eq(other.args_hash) &\\n        (self.returns_hash == other.returns_hash) &\\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\\n        (self.is_fee_payer == other.is_fee_payer) &\\n        (self.max_block_number == other.max_block_number) &\\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\\n        (self.note_hashes == other.note_hashes) &\\n        (self.nullifiers == other.nullifiers) &\\n        (self.private_call_requests == other.private_call_requests) &\\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\\n        (self.l2_to_l1_msgs == other.l2_to_l1_msgs) &\\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\\n        self.historical_header.eq(other.historical_header) &\\n        self.tx_context.eq(other.tx_context)\\n    }\\n}\\n\\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\\n        fields.extend_from_array(self.call_context.serialize());\\n        fields.push(self.args_hash);\\n        fields.push(self.returns_hash);\\n\\n        fields.push(self.min_revertible_side_effect_counter as Field);\\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\\n\\n        fields.extend_from_array(self.max_block_number.serialize());\\n\\n        for i in 0..self.note_hash_read_requests.len() {\\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\\n        }\\n        for i in 0..self.nullifier_read_requests.len() {\\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\\n        }\\n        for i in 0..self.key_validation_requests_and_generators.len() {\\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\\n        }\\n        for i in 0..self.note_hashes.len() {\\n            fields.extend_from_array(self.note_hashes[i].serialize());\\n        }\\n        for i in 0..self.nullifiers.len() {\\n            fields.extend_from_array(self.nullifiers[i].serialize());\\n        }\\n        for i in 0..self.private_call_requests.len() {\\n            fields.extend_from_array(self.private_call_requests[i].serialize());\\n        }\\n        fields.extend_from_array(self.public_call_stack_hashes);\\n        fields.push(self.public_teardown_function_hash);\\n        for i in 0..self.l2_to_l1_msgs.len() {\\n            fields.extend_from_array(self.l2_to_l1_msgs[i].serialize());\\n        }\\n        fields.push(self.start_side_effect_counter as Field);\\n        fields.push(self.end_side_effect_counter as Field);\\n        for i in 0..self.note_encrypted_logs_hashes.len() {\\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\\n        }\\n        for i in 0..self.encrypted_logs_hashes.len() {\\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\\n        }\\n        for i in 0..self.unencrypted_logs_hashes.len() {\\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\\n        }\\n        fields.extend_from_array(self.historical_header.serialize());\\n        fields.extend_from_array(self.tx_context.serialize());\\n\\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\\n        let mut reader = Reader::new(serialized);\\n        let inputs = Self {\\n            call_context: reader.read_struct(CallContext::deserialize),\\n            args_hash: reader.read(),\\n            returns_hash: reader.read(),\\n            min_revertible_side_effect_counter: reader.read() as u32,\\n            is_fee_payer: reader.read() == 1,\\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\\n            note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL]),\\n            nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL]),\\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\\n            public_teardown_function_hash: reader.read(),\\n            l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL]),\\n            start_side_effect_counter: reader.read() as u32,\\n            end_side_effect_counter: reader.read() as u32,\\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\\n            historical_header: reader.read_struct(Header::deserialize),\\n            tx_context: reader.read_struct(TxContext::deserialize),\\n        };\\n\\n        reader.finish();\\n        inputs\\n    }\\n}\\n\\nimpl Hash for PrivateCircuitPublicInputs {\\n    fn hash(self) -> Field {\\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\\n    }\\n}\\n\\nimpl Empty for PrivateCircuitPublicInputs {\\n    fn empty() -> Self {\\n        PrivateCircuitPublicInputs {\\n            call_context: CallContext::empty(),\\n            args_hash: 0,\\n            returns_hash: 0,\\n            min_revertible_side_effect_counter: 0 as u32,\\n            is_fee_payer: false,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\\n            public_teardown_function_hash: 0,\\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\\n            start_side_effect_counter : 0 as u32,\\n            end_side_effect_counter : 0 as u32,\\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\\n            historical_header: Header::empty(),\\n            tx_context: TxContext::empty(),\\n        }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let pcpi = PrivateCircuitPublicInputs::empty();\\n    let serialized = pcpi.serialize();\\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\\n    assert(pcpi.eq(deserialized));\\n}\\n\\n#[test]\\nfn empty_hash() {\\n    let inputs = PrivateCircuitPublicInputs::empty();\\n    let hash = inputs.hash();\\n    // Value from private_circuit_public_inputs.test.ts \\"computes empty item hash\\" test\\n    let test_data_empty_hash = 0x15c9b0a92b9b541598e24c9f0b0b4b04b7f2408599751c45aa12de671fd9b363;\\n    assert_eq(hash, test_data_empty_hash);\\n}\\n"},"173":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item_compressed.nr","source":"use crate::abis::{call_context::CallContext, function_data::FunctionData, gas::Gas};\\nuse crate::address::AztecAddress;\\nuse crate::constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH};\\nuse crate::traits::{Hash, Empty, Serialize, Deserialize};\\nuse crate::utils::reader::Reader;\\n\\n/**\\n * A compressed version of the PublicCallStackItem struct used to compute the \\"hash\\"\\n * of a PublicCallStackItem.\\n * \\n * Historically, we have been zeroing most values in the PublicCallStackItem struct\\n * to compute the hash involved when adding a PublicCallStackItem to the PublicCallStack.\\n * \\n * This struct is used to store the values that we did not zero out, and allow us to hash\\n * only these, thereby skipping a lot of computation and saving us a lot of constraints\\n * \\n * Essentially this struct exists such that we don\'t have a `hash` function in the \\n * PublicCallStackItem struct that practically throws away some values of the struct\\n * without clearly indicating that it does so.\\n */\\nstruct PublicCallStackItemCompressed {\\n    contract_address: AztecAddress,\\n    call_context: CallContext,\\n    function_data: FunctionData,\\n    args_hash: Field,\\n    returns_hash: Field,\\n    revert_code: u8,\\n    start_gas_left: Gas,\\n    end_gas_left: Gas,\\n}\\n\\nimpl Eq for PublicCallStackItemCompressed {\\n    fn eq(self, other: PublicCallStackItemCompressed) -> bool {\\n        (self.contract_address == other.contract_address)\\n            & (self.call_context == other.call_context)\\n            & (self.function_data == other.function_data)\\n            & (self.args_hash == other.args_hash)\\n            & (self.returns_hash == other.returns_hash)\\n            & (self.revert_code == other.revert_code)\\n            & (self.start_gas_left == other.start_gas_left)\\n            & (self.end_gas_left == other.end_gas_left)\\n    }\\n}\\n\\nimpl Hash for PublicCallStackItemCompressed {\\n    fn hash(self) -> Field {\\n        std::hash::pedersen_hash_with_separator(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\\n    }\\n}\\n\\nimpl Empty for PublicCallStackItemCompressed {\\n    fn empty() -> Self {\\n        PublicCallStackItemCompressed {\\n            contract_address: AztecAddress::empty(),\\n            call_context: CallContext::empty(),\\n            function_data: FunctionData::empty(),\\n            args_hash: 0,\\n            returns_hash: 0,\\n            revert_code: 0,\\n            start_gas_left: Gas::empty(),\\n            end_gas_left: Gas::empty(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\\n    fn serialize(self) -> [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH] {\\n        let mut fields: BoundedVec<Field, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> = BoundedVec::new();\\n\\n        fields.push(self.contract_address.to_field());\\n        fields.extend_from_array(self.call_context.serialize());\\n        fields.extend_from_array(self.function_data.serialize());\\n        fields.push(self.args_hash);\\n        fields.push(self.returns_hash);\\n        fields.push(self.revert_code as Field);\\n        fields.extend_from_array(self.start_gas_left.serialize());\\n        fields.extend_from_array(self.end_gas_left.serialize());\\n\\n        assert_eq(fields.len(), PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH);\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\\n  fn deserialize(fields: [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH]) -> PublicCallStackItemCompressed {\\n    let mut reader = Reader::new(fields);\\n\\n    let item = PublicCallStackItemCompressed {\\n      contract_address: reader.read_struct(AztecAddress::deserialize),\\n      call_context: reader.read_struct(CallContext::deserialize),\\n      function_data: reader.read_struct(FunctionData::deserialize),\\n      args_hash: reader.read(),\\n      returns_hash: reader.read(),\\n      revert_code: reader.read() as u8,\\n      start_gas_left: reader.read_struct(Gas::deserialize),\\n      end_gas_left: reader.read_struct(Gas::deserialize),\\n    };\\n    reader.finish();\\n    item\\n  }\\n}\\n"},"175":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr","source":"use crate::{\\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\\n};\\n\\n// docs:start:global-variables\\nstruct GlobalVariables {\\n    chain_id : Field,\\n    version : Field,\\n    block_number : Field,\\n    timestamp : u64,\\n    coinbase : EthAddress,\\n    fee_recipient : AztecAddress,\\n    gas_fees : GasFees\\n}\\n// docs:end:global-variables\\n\\nimpl GlobalVariables {\\n    fn is_empty(self) -> bool {\\n        (self.chain_id == 0)\\n            & (self.version == 0)\\n            & (self.block_number == 0)\\n            & (self.timestamp == 0)\\n            & (self.coinbase.is_zero())\\n            & (self.fee_recipient.is_zero())\\n            & (self.gas_fees.is_empty())\\n    }\\n}\\n\\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\\n\\n        serialized.push(self.chain_id);\\n        serialized.push(self.version);\\n        serialized.push(self.block_number);\\n        serialized.push(self.timestamp as Field);\\n        serialized.push(self.coinbase.to_field());\\n        serialized.push(self.fee_recipient.to_field());\\n        serialized.extend_from_array(self.gas_fees.serialize());\\n\\n        serialized.storage\\n    }\\n}\\n\\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\\n        let mut reader = Reader::new(serialized);\\n        GlobalVariables {\\n            chain_id: reader.read(),\\n            version: reader.read(),\\n            block_number: reader.read(),\\n            timestamp: reader.read() as u64,\\n            coinbase: EthAddress::from_field(reader.read()),\\n            fee_recipient: AztecAddress::from_field(reader.read()),\\n            gas_fees: reader.read_struct(GasFees::deserialize)\\n        }\\n    }\\n}\\n\\nimpl Eq for GlobalVariables {\\n    fn eq(self, other : GlobalVariables) -> bool {\\n        (self.chain_id == other.chain_id) &\\n        (self.version == other.version) &\\n        (self.block_number == other.block_number) &\\n        (self.timestamp == other.timestamp) &\\n        (self.coinbase == other.coinbase) &\\n        (self.fee_recipient == other.fee_recipient) &\\n        (self.gas_fees == other.gas_fees) \\n    }\\n}\\n\\nimpl Empty for GlobalVariables {\\n    fn empty() -> Self {\\n        Self {\\n            chain_id: 0,\\n            version: 0,\\n            block_number: 0,\\n            timestamp: 0,\\n            coinbase: EthAddress::empty(),\\n            fee_recipient: AztecAddress::empty(),\\n            gas_fees: GasFees::empty()\\n        }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let vars = GlobalVariables::empty();\\n    let _serialized = vars.serialize();\\n    let _deserialized = GlobalVariables::deserialize(_serialized);\\n}\\n"},"176":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr","source":"use crate::{\\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\\n    utils::{arrays::array_concat, reader::Reader}\\n};\\n\\nstruct ReadRequest {\\n    value: Field,\\n    counter: u32,\\n}\\n\\nimpl Ordered for ReadRequest {\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl Eq for ReadRequest {\\n    fn eq(self, read_request: ReadRequest) -> bool {\\n        (self.value == read_request.value)\\n        & (self.counter == read_request.counter)\\n    }\\n}\\n\\nimpl Empty for ReadRequest {\\n    fn empty() -> Self {\\n        ReadRequest {\\n            value: 0,\\n            counter: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\\n        [self.value, self.counter as Field]\\n    }\\n}\\n\\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\\n        Self {\\n            value: values[0],\\n            counter: values[1] as u32,\\n        }\\n    }\\n}\\n\\nimpl ReadRequest {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\\n        ScopedReadRequest { read_request: self, contract_address }\\n    }\\n}\\n\\nstruct ScopedReadRequest {\\n    read_request: ReadRequest,\\n    contract_address: AztecAddress,\\n}\\n\\nimpl Scoped<ReadRequest> for ScopedReadRequest {\\n    fn inner(self) -> ReadRequest {\\n        self.read_request\\n    }\\n    fn contract_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n}\\n\\nimpl Eq for ScopedReadRequest {\\n    fn eq(self, other: ScopedReadRequest) -> bool {\\n        (self.read_request == other.read_request)\\n        & (self.contract_address.eq(other.contract_address))\\n    }\\n}\\n\\nimpl Empty for ScopedReadRequest {\\n    fn empty() -> Self {\\n        ScopedReadRequest {\\n            read_request: ReadRequest::empty(),\\n            contract_address: AztecAddress::empty(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\\n    }\\n}\\n\\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\\n        let mut reader = Reader::new(values);\\n        let res = Self {\\n            read_request: reader.read_struct(ReadRequest::deserialize),\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n        };\\n        reader.finish();\\n        res\\n    }\\n}\\n\\nimpl ScopedReadRequest {\\n    pub fn value(self) -> Field {\\n        self.read_request.value\\n    }\\n    pub fn counter(self) -> u32 {\\n        self.read_request.counter\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty_read() {\\n    let item = ReadRequest::empty();\\n    let serialized = item.serialize();\\n    let deserialized = ReadRequest::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n\\n#[test]\\nfn serialization_of_empty_scoped() {\\n    let item = ScopedReadRequest::empty();\\n    let serialized = item.serialize();\\n    let deserialized = ScopedReadRequest::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"179":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr","source":"use crate::{\\n    address::AztecAddress,\\n    abis::validation_requests::{\\n    key_validation_request::KeyValidationRequest,\\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\\n},\\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\\n    utils::{arrays::array_concat, reader::Reader}\\n};\\n\\nstruct KeyValidationRequestAndGenerator {\\n    request: KeyValidationRequest,\\n    sk_app_generator: Field,\\n}\\n\\nimpl Eq for KeyValidationRequestAndGenerator {\\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\\n    }\\n}\\n\\nimpl Empty for KeyValidationRequestAndGenerator {\\n    fn empty() -> Self {\\n        KeyValidationRequestAndGenerator {\\n            request: KeyValidationRequest::empty(),\\n            sk_app_generator: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\\n        array_concat(self.request.serialize(), [self.sk_app_generator])\\n    }\\n}\\n\\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\\n        let mut reader = Reader::new(fields);\\n        let res = Self {\\n            request: reader.read_struct(KeyValidationRequest::deserialize),\\n            sk_app_generator: reader.read(),\\n        };\\n        reader.finish();\\n        res\\n    }\\n}\\n\\nimpl KeyValidationRequestAndGenerator {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = KeyValidationRequestAndGenerator::empty();\\n    let serialized = item.serialize();\\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"180":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\\n\\nstruct KeyValidationRequest {\\n    pk_m: Point,\\n    sk_app: Field, // not a grumpkin scalar because it\'s output of poseidon2\\n}\\n\\nimpl Eq for KeyValidationRequest {\\n    fn eq(self, request: KeyValidationRequest) -> bool {\\n        (request.pk_m.eq(self.pk_m))\\n            & (request.sk_app.eq(self.sk_app))\\n    }\\n}\\n\\nimpl Empty for KeyValidationRequest {\\n    fn empty() -> Self {\\n        KeyValidationRequest {\\n            pk_m: Point::empty(),\\n            sk_app: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\\n        [\\n            self.pk_m.x,\\n            self.pk_m.y,\\n            self.pk_m.is_infinite as Field,\\n            self.sk_app,\\n        ]\\n    }\\n}\\n\\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\\n        Self {\\n            pk_m: Point::new(fields[0], fields[1], fields[2] as bool),\\n            sk_app: fields[3],\\n        }\\n    }\\n}\\n\\n"},"184":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr","source":"use crate::{\\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH},\\n    hash::compute_siloed_nullifier, traits::{Empty, Hash, Serialize, Deserialize},\\n    utils::{arrays::array_concat, reader::Reader}\\n};\\n\\nstruct Nullifier {\\n    value: Field,\\n    counter: u32,\\n    note_hash: Field,\\n}\\n\\nimpl Ordered for Nullifier {\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for Nullifier {\\n    fn value(self) -> Field {\\n        self.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl Eq for Nullifier {\\n    fn eq(self, other: Nullifier) -> bool {\\n        (self.value == other.value)\\n            & (self.counter == other.counter)\\n            & (self.note_hash == other.note_hash) \\n    }\\n}\\n\\nimpl Empty for Nullifier {\\n    fn empty() -> Self {\\n        Nullifier {\\n            value: 0,\\n            counter: 0,\\n            note_hash: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\\n        [self.value, self.counter as Field, self.note_hash]\\n    }\\n}\\n\\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\\n        Self {\\n            value: values[0],\\n            counter: values[1] as u32,\\n            note_hash: values[2],\\n        }\\n    }\\n}\\n\\nimpl Readable for Nullifier {\\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\\n        // Public kernels output Nullifier instead of ScopedNullifier.\\n        // The nullifier value has been siloed.\\n        let siloed_request_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\\n        assert_eq(self.value, siloed_request_value, \\"Value of the nullifier does not match read request\\");\\n        assert(\\n            read_request.counter() > self.counter, \\"Read request counter must be greater than the counter of the nullifier\\"\\n        );\\n    }\\n}\\n\\nimpl Nullifier {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\\n        ScopedNullifier { nullifier: self, contract_address }\\n    }\\n}\\n\\nstruct ScopedNullifier {\\n    nullifier: Nullifier,\\n    contract_address: AztecAddress,\\n}\\n\\nimpl Scoped<Nullifier> for ScopedNullifier {\\n    fn inner(self) -> Nullifier {\\n        self.nullifier\\n    }\\n    fn contract_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n}\\n\\nimpl Ordered for ScopedNullifier {\\n    fn counter(self) -> u32 {\\n        self.nullifier.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for ScopedNullifier {\\n    fn value(self) -> Field {\\n        self.nullifier.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.nullifier.counter\\n    }\\n}\\n\\nimpl Eq for ScopedNullifier {\\n    fn eq(self, other: ScopedNullifier) -> bool {\\n        (self.nullifier == other.nullifier)\\n            & (self.contract_address == other.contract_address) \\n    }\\n}\\n\\nimpl Empty for ScopedNullifier {\\n    fn empty() -> Self {\\n        ScopedNullifier {\\n            nullifier: Nullifier::empty(),\\n            contract_address: AztecAddress::empty(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\\n    }\\n}\\n\\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\\n        let mut reader = Reader::new(values);\\n        let res = Self {\\n            nullifier: reader.read_struct(Nullifier::deserialize),\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n        };\\n        reader.finish();\\n        res\\n    }\\n}\\n\\nimpl Readable for ScopedNullifier {\\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\\n        assert_eq(self.nullifier.value, read_request.value(), \\"Value of the nullifier does not match read request\\");\\n        assert_eq(self.contract_address, read_request.contract_address, \\"Contract address of the nullifier does not match read request\\");\\n        assert(\\n            read_request.counter() > self.nullifier.counter, \\"Read request counter must be greater than the counter of the nullifier\\"\\n        );\\n    }\\n}\\n\\nimpl ScopedNullifier {\\n    pub fn nullified_note_hash(self) -> Field {\\n        self.nullifier.note_hash\\n    }\\n\\n    pub fn expose_to_public(self) -> Nullifier {\\n        // Hide the actual counter and note hash when exposing it to the public kernel.\\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = Nullifier::empty();\\n    let serialized = item.serialize();\\n    let deserialized = Nullifier::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n\\n#[test]\\nfn serialization_of_empty_scoped() {\\n    let item = ScopedNullifier::empty();\\n    let serialized = item.serialize();\\n    let deserialized = ScopedNullifier::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"193":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\\n\\nglobal SELECTOR_SIZE = 4;\\n\\nstruct FunctionSelector {\\n    // 1st 4-bytes of abi-encoding of function.\\n    inner: u32,\\n}\\n\\nimpl Eq for FunctionSelector {\\n    fn eq(self, function_selector: FunctionSelector) -> bool {\\n        function_selector.inner == self.inner\\n    }\\n}\\n\\nimpl Serialize<1> for FunctionSelector {\\n    fn serialize(self: Self) -> [Field; 1] {\\n        [self.inner as Field]\\n    }\\n}\\n\\nimpl Deserialize<1> for FunctionSelector {\\n    fn deserialize(fields: [Field; 1]) -> Self {\\n        Self {\\n            inner: fields[0] as u32\\n        }\\n    }\\n}\\n\\nimpl FromField for FunctionSelector {\\n    fn from_field(field: Field) -> Self {\\n        Self { inner: field as u32 }\\n    }\\n}\\n\\nimpl ToField for FunctionSelector {\\n    fn to_field(self) -> Field {\\n        self.inner as Field\\n    }\\n}\\n\\nimpl Empty for FunctionSelector {\\n    fn empty() -> Self {\\n        Self { inner: 0 as u32 }\\n    }\\n}\\n\\nimpl FunctionSelector {\\n    pub fn from_u32(value: u32) -> Self {\\n        Self { inner: value }\\n    }\\n\\n    pub fn from_signature<N>(signature: str<N>) -> Self {\\n        let bytes = signature.as_bytes();\\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\\n\\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\\n        for i in 0..SELECTOR_SIZE {\\n            selector_be_bytes[i] = hash[i];\\n        }\\n\\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\\n    }\\n\\n    pub fn zero() -> Self {\\n        Self { inner: 0 }\\n    }\\n}\\n"},"194":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr","source":"use crate::{\\n    abis::{\\n    private_call_stack_item::PrivateCallStackItem, call_context::CallContext,\\n    function_data::FunctionData, caller_context::CallerContext,\\n    side_effect::{Ordered, RangeOrdered, Scoped}\\n},\\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\\n};\\n\\nstruct PrivateCallRequest {\\n    target: AztecAddress,\\n    call_context: CallContext,\\n    function_data: FunctionData,\\n    args_hash: Field,\\n    returns_hash: Field,\\n    caller_context: CallerContext,\\n    start_side_effect_counter: u32,\\n    end_side_effect_counter: u32,\\n}\\n\\nimpl Ordered for PrivateCallRequest {\\n    fn counter(self) -> u32 {\\n        self.start_side_effect_counter\\n    }\\n}\\n\\nimpl RangeOrdered for PrivateCallRequest {\\n    fn counter_start(self) -> u32 {\\n        self.start_side_effect_counter\\n    }\\n    fn counter_end(self) -> u32 {\\n        self.end_side_effect_counter\\n    }\\n}\\n\\nimpl Eq for PrivateCallRequest {\\n    fn eq(self, other: PrivateCallRequest) -> bool {\\n        (self.target == other.target) \\n            & (self.call_context == other.call_context) \\n            & (self.function_data == other.function_data) \\n            & (self.args_hash == other.args_hash) \\n            & (self.returns_hash == other.returns_hash)\\n            & (self.caller_context == other.caller_context)\\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\\n    }\\n}\\n\\nimpl Empty for PrivateCallRequest {\\n    fn empty() -> Self {\\n        PrivateCallRequest {\\n            target: AztecAddress::empty(),\\n            call_context: CallContext::empty(),\\n            function_data: FunctionData::empty(),\\n            args_hash: 0,\\n            returns_hash: 0,\\n            caller_context: CallerContext::empty(),\\n            start_side_effect_counter: 0,\\n            end_side_effect_counter: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\\n\\n        fields.push(self.target.to_field());\\n        fields.extend_from_array(self.call_context.serialize());\\n        fields.extend_from_array(self.function_data.serialize());\\n        fields.push(self.args_hash);\\n        fields.push(self.returns_hash);\\n        fields.extend_from_array(self.caller_context.serialize());\\n        fields.push(self.start_side_effect_counter as Field);\\n        fields.push(self.end_side_effect_counter as Field);\\n\\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\\n        let mut reader = Reader::new(fields);\\n        let item = PrivateCallRequest {\\n            target: reader.read_struct(AztecAddress::deserialize),\\n            call_context: reader.read_struct(CallContext::deserialize),\\n            function_data: reader.read_struct(FunctionData::deserialize),\\n            args_hash: reader.read(),\\n            returns_hash: reader.read(),\\n            caller_context: reader.read_struct(CallerContext::deserialize),\\n            start_side_effect_counter: reader.read_u32(),\\n            end_side_effect_counter: reader.read_u32(),\\n        };\\n        reader.finish();\\n        item\\n    }\\n}\\n\\nimpl PrivateCallRequest {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\\n        ScopedPrivateCallRequest { call_request: self, contract_address }\\n    }\\n\\n    pub fn matches_stack_item(self, stack_item: PrivateCallStackItem) -> bool {\\n        (self.target == stack_item.contract_address)\\n            & (self.call_context == stack_item.public_inputs.call_context)\\n            & (self.function_data == stack_item.function_data)\\n            & (self.args_hash == stack_item.public_inputs.args_hash)\\n            & (self.returns_hash == stack_item.public_inputs.returns_hash)\\n            & (self.start_side_effect_counter\\n                                == stack_item.public_inputs.start_side_effect_counter)\\n            & (self.end_side_effect_counter\\n                                    == stack_item.public_inputs.end_side_effect_counter)\\n    }\\n}\\n\\nstruct ScopedPrivateCallRequest {\\n    call_request: PrivateCallRequest,\\n    contract_address: AztecAddress,\\n}\\n\\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\\n    fn inner(self) -> PrivateCallRequest {\\n        self.call_request\\n    }\\n    fn contract_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n}\\n\\nimpl Ordered for ScopedPrivateCallRequest {\\n    fn counter(self) -> u32 {\\n        self.call_request.counter_start()\\n    }\\n}\\n\\nimpl RangeOrdered for ScopedPrivateCallRequest {\\n    fn counter_start(self) -> u32 {\\n        self.call_request.counter_start()\\n    }\\n    fn counter_end(self) -> u32 {\\n        self.call_request.counter_end()\\n    }\\n}\\n\\nimpl Eq for ScopedPrivateCallRequest {\\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\\n        (self.call_request == other.call_request)\\n            & (self.contract_address == other.contract_address)\\n    }\\n}\\n\\nimpl Empty for ScopedPrivateCallRequest {\\n    fn empty() -> Self {\\n        ScopedPrivateCallRequest {\\n            call_request: PrivateCallRequest::empty(),\\n            contract_address: AztecAddress::zero(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\\n\\n        fields.extend_from_array(self.call_request.serialize());\\n        fields.extend_from_array(self.contract_address.serialize());\\n\\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\\n        let mut reader = Reader::new(fields);\\n        let item = ScopedPrivateCallRequest {\\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n        };\\n        reader.finish();\\n        item\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = ScopedPrivateCallRequest::empty();\\n    let serialized = item.serialize();\\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"199":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr","source":"use crate::{\\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\\n    abis::gas_fees::GasFees,\\n    constants::{\\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\\n    DEFAULT_INCLUSION_FEE\\n},\\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\\n    utils::reader::Reader\\n};\\n\\nstruct GasSettings {\\n    gas_limits: Gas,\\n    teardown_gas_limits: Gas,\\n    max_fees_per_gas: GasFees,\\n    inclusion_fee: Field,\\n}\\n\\nimpl GasSettings {\\n    pub fn new(\\n        gas_limits: Gas,\\n        teardown_gas_limits: Gas,\\n        max_fees_per_gas: GasFees,\\n        inclusion_fee: Field\\n    ) -> Self {\\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\\n    }\\n\\n    pub fn default() -> Self {\\n        GasSettings::new(\\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\\n            DEFAULT_INCLUSION_FEE\\n        )\\n    }\\n}\\n\\nimpl Eq for GasSettings {\\n    fn eq(self, other: Self) -> bool {\\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\\n    }\\n}\\n\\nimpl Empty for GasSettings {\\n    fn empty() -> Self {\\n        GasSettings::new(\\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\\n        )\\n    }\\n}\\n\\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\\n\\n        serialized.extend_from_array(self.gas_limits.serialize());\\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\\n        serialized.push(self.inclusion_fee);\\n    \\n        serialized.storage\\n    }\\n}\\n\\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\\n        let mut reader = Reader::new(serialized);\\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = GasSettings::empty();\\n    let serialized = item.serialize();\\n    let deserialized = GasSettings::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"208":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr","source":"use crate::{\\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\\n    address::AztecAddress,\\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\\n};\\n\\nstruct PrivateCallStackItem {\\n    // This is the _actual_ contract address relating to where this function\'s code resides in the\\n    // contract tree. Regardless of whether this is a call or delegatecall, this\\n    // `contract_address` _does not change_. Amongst other things, it\'s used as a lookup for\\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\\n    contract_address: AztecAddress,\\n    function_data: FunctionData,\\n    public_inputs: PrivateCircuitPublicInputs,\\n}\\n\\nimpl Eq for PrivateCallStackItem {\\n    fn eq(self, other: Self) -> bool {\\n        self.contract_address.eq(other.contract_address) &\\n        self.function_data.eq(other.function_data) &\\n        self.public_inputs.eq(other.public_inputs)\\n    }\\n}\\n\\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\\n\\n        fields.push(self.contract_address.to_field());\\n        fields.extend_from_array(self.function_data.serialize());\\n        fields.extend_from_array(self.public_inputs.serialize());\\n\\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\\n        let mut reader = Reader::new(serialized);\\n\\n        let item = Self {\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n            function_data: reader.read_struct(FunctionData::deserialize),\\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\\n        };\\n\\n        reader.finish();\\n        item\\n    }\\n}\\n\\nimpl Hash for PrivateCallStackItem {\\n    fn hash(self) -> Field {\\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\\n    }\\n}\\n\\nimpl Empty for PrivateCallStackItem {\\n    fn empty() -> Self {\\n        PrivateCallStackItem {\\n            contract_address: AztecAddress::empty(),\\n            function_data: FunctionData::empty(),\\n            public_inputs: PrivateCircuitPublicInputs::empty(),\\n        }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = PrivateCallStackItem::empty();\\n    let serialized = item.serialize();\\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n\\n#[test]\\nfn empty_hash() {\\n    let mut item = PrivateCallStackItem::empty();\\n    item.function_data.is_private = true;\\n    let hash = item.hash();\\n\\n    // Value from private_call_stack_item.test.ts \\"computes empty item hash\\" test\\n    let test_data_empty_hash = 0x065f2831db9ac0db5e710bd3a865b5facd8cf83f1585e1af8fd1d6ce9c47f685;\\n    assert_eq(hash, test_data_empty_hash);\\n}\\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr","source":"use crate::address::AztecAddress;\\nuse crate::traits::{Empty, Serialize, Deserialize};\\nuse crate::constants::CALLER_CONTEXT_LENGTH;\\nuse crate::utils::reader::Reader;\\n\\nstruct CallerContext {\\n    msg_sender: AztecAddress,\\n    storage_contract_address: AztecAddress,\\n    is_static_call: bool,\\n}\\n\\nimpl Eq for CallerContext {\\n    fn eq(self, other: CallerContext) -> bool {\\n        other.msg_sender.eq(self.msg_sender)\\n            & other.storage_contract_address.eq(self.storage_contract_address)\\n            & other.is_static_call == self.is_static_call\\n    }\\n}\\n\\nimpl Empty for CallerContext {\\n    fn empty() -> Self {\\n        CallerContext {\\n            msg_sender: AztecAddress::zero(),\\n            storage_contract_address: AztecAddress::zero(),\\n            is_static_call: false,\\n        }\\n    }\\n}\\n\\nimpl CallerContext {\\n    pub fn is_empty(self) -> bool {\\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\\n    }\\n\\n    // Different to an empty context, a hidden context won\'t reveal the caller\'s msg_sender and storage_contract_address,\\n    // but will still propagate the is_static_call flag.\\n    pub fn is_hidden(self) -> bool {\\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\\n    }\\n}\\n\\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\\n\\n    fields.extend_from_array(self.msg_sender.serialize());\\n    fields.extend_from_array(self.storage_contract_address.serialize());\\n    fields.push(self.is_static_call as Field);\\n\\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\\n\\n    fields.storage\\n  }\\n}\\n\\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\\n    let mut reader = Reader::new(fields);\\n\\n    let item = CallerContext {\\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\\n      is_static_call: reader.read_bool(),\\n    };\\n    reader.finish();\\n    item\\n  }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = CallerContext::empty();\\n    let serialized = item.serialize();\\n    let deserialized = CallerContext::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"211":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr","source":"use crate::{\\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\\n    constants::{\\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\\n},\\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\\n};\\n\\nstruct LogHash {\\n    value: Field,\\n    counter: u32,\\n    length: Field,\\n}\\n\\nimpl Ordered for LogHash {\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for LogHash {\\n    fn value(self) -> Field {\\n        self.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl Eq for LogHash {\\n    fn eq(self, other: LogHash) -> bool {\\n        (self.value == other.value)\\n            & (self.counter == other.counter)\\n            & (self.length == other.length) \\n    }\\n}\\n\\nimpl Empty for LogHash {\\n    fn empty() -> Self {\\n        LogHash {\\n            value: 0,\\n            counter: 0,\\n            length: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\\n        [self.value, self.counter as Field, self.length]\\n    }\\n}\\n\\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\\n        Self {\\n            value: values[0],\\n            counter: values[1] as u32,\\n            length: values[2],\\n        }\\n    }\\n}\\n\\nimpl LogHash {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\\n        ScopedLogHash { log_hash: self, contract_address }\\n    }\\n}\\n\\nstruct ScopedLogHash {\\n    log_hash: LogHash,\\n    contract_address: AztecAddress,\\n}\\n\\nimpl Scoped<LogHash> for ScopedLogHash {\\n    fn inner(self) -> LogHash {\\n        self.log_hash\\n    }\\n    fn contract_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n}\\n\\nimpl Ordered for ScopedLogHash {\\n    fn counter(self) -> u32 {\\n        self.log_hash.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for ScopedLogHash {\\n    fn value(self) -> Field {\\n        self.log_hash.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.log_hash.counter\\n    }\\n}\\n\\nimpl Eq for ScopedLogHash {\\n    fn eq(self, other: ScopedLogHash) -> bool {\\n        (self.log_hash == other.log_hash)\\n            & (self.contract_address == other.contract_address) \\n    }\\n}\\n\\nimpl Empty for ScopedLogHash {\\n    fn empty() -> Self {\\n        ScopedLogHash {\\n            log_hash: LogHash::empty(),\\n            contract_address: AztecAddress::empty(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\\n    }\\n}\\n\\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\\n        let mut reader = Reader::new(values);\\n        let res = Self {\\n            log_hash: reader.read_struct(LogHash::deserialize),\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n        };\\n        reader.finish();\\n        res\\n    }\\n}\\n\\nimpl ScopedLogHash {\\n    pub fn expose_to_public(self) -> LogHash {\\n        // Hide the counter when exposing to public.\\n        // The log hash must already be siloed when we call this.\\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\\n    }\\n}\\n\\nstruct EncryptedLogHash {\\n    value: Field,\\n    counter: u32,\\n    length: Field,\\n    randomness: Field,\\n}\\n\\nimpl Ordered for EncryptedLogHash {\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for EncryptedLogHash {\\n    fn value(self) -> Field {\\n        self.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl Eq for EncryptedLogHash {\\n    fn eq(self, other: EncryptedLogHash) -> bool {\\n        (self.value == other.value)\\n            & (self.counter == other.counter)\\n            & (self.length == other.length) \\n            & (self.randomness == other.randomness) \\n    }\\n}\\n\\nimpl Empty for EncryptedLogHash {\\n    fn empty() -> Self {\\n        EncryptedLogHash {\\n            value: 0,\\n            counter: 0,\\n            length: 0,\\n            randomness: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\\n        [self.value, self.counter as Field, self.length, self.randomness]\\n    }\\n}\\n\\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\\n        Self {\\n            value: values[0],\\n            counter: values[1] as u32,\\n            length: values[2],\\n            randomness: values[3],\\n        }\\n    }\\n}\\n\\nimpl EncryptedLogHash {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\\n    }\\n}\\n\\nstruct ScopedEncryptedLogHash {\\n    log_hash: EncryptedLogHash,\\n    contract_address: AztecAddress,\\n}\\n\\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\\n    fn inner(self) -> EncryptedLogHash {\\n        self.log_hash\\n    }\\n    fn contract_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n}\\n\\nimpl ScopedEncryptedLogHash {\\n    pub fn expose_to_public(self) -> LogHash {\\n        // Hide the secret randomness and counter when exposing to public\\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\\n        // The log hash will already be silo\'d when we call this\\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\\n    }\\n}\\n\\nimpl Ordered for ScopedEncryptedLogHash {\\n    fn counter(self) -> u32 {\\n        self.log_hash.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\\n    fn value(self) -> Field {\\n        self.log_hash.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.log_hash.counter\\n    }\\n}\\n\\nimpl Eq for ScopedEncryptedLogHash {\\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\\n        (self.log_hash == other.log_hash)\\n            & (self.contract_address == other.contract_address) \\n    }\\n}\\n\\nimpl Empty for ScopedEncryptedLogHash {\\n    fn empty() -> Self {\\n        ScopedEncryptedLogHash {\\n            log_hash: EncryptedLogHash::empty(),\\n            contract_address: AztecAddress::empty(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\\n    }\\n}\\n\\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\\n        let mut reader = Reader::new(values);\\n        let res = Self {\\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n        };\\n        reader.finish();\\n        res\\n    }\\n}\\n\\nstruct NoteLogHash {\\n    value: Field,\\n    counter: u32,\\n    length: Field,\\n    note_hash_counter: u32,\\n}\\n\\nimpl NoteLogHash {\\n    pub fn expose_to_public(self) -> LogHash {\\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\\n        LogHash { value: self.value, counter: 0, length: self.length }\\n    }\\n}\\n\\nimpl Ordered for NoteLogHash {\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for NoteLogHash {\\n    fn value(self) -> Field {\\n        self.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl Eq for NoteLogHash {\\n    fn eq(self, other: NoteLogHash) -> bool {\\n        (self.value == other.value)\\n            & (self.counter == other.counter)\\n            & (self.length == other.length) \\n            & (self.note_hash_counter == other.note_hash_counter) \\n    }\\n}\\n\\nimpl Empty for NoteLogHash {\\n    fn empty() -> Self {\\n        NoteLogHash {\\n            value: 0,\\n            counter: 0,\\n            length: 0,\\n            note_hash_counter: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\\n    }\\n}\\n\\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\\n        Self {\\n            value: values[0],\\n            counter: values[1] as u32,\\n            length: values[2],\\n            note_hash_counter: values[3] as u32,\\n        }\\n    }\\n}\\n"},"215":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr","source":"struct AppendOnlyTreeSnapshot {\\n    root : Field,\\n    // TODO(Alvaro) change this to a u64\\n    next_available_leaf_index : u32\\n}\\n\\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\\n\\nimpl AppendOnlyTreeSnapshot {\\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\\n        [self.root, self.next_available_leaf_index as Field]\\n    }\\n\\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\\n    }\\n\\n    pub fn zero() -> Self {\\n        Self { root: 0, next_available_leaf_index: 0 }\\n    }\\n}\\n\\nimpl Eq for AppendOnlyTreeSnapshot {\\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\\n    }\\n}\\n"},"216":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\\n    abis::function_selector::FunctionSelector, address::AztecAddress,\\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\\n};\\n\\n// docs:start:call-context\\nstruct CallContext {\\n    msg_sender : AztecAddress,\\n    storage_contract_address : AztecAddress,\\n    function_selector : FunctionSelector,\\n\\n    is_delegate_call : bool,\\n    is_static_call : bool,\\n}\\n// docs:end:call-context\\n\\nimpl Eq for CallContext {\\n    fn eq(self, other: CallContext) -> bool {\\n        self.serialize() == other.serialize()\\n    }\\n}\\n\\nimpl Hash for CallContext {\\n    fn hash(self) -> Field {\\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\\n    }\\n}\\n\\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\\n\\n        serialized.push(self.msg_sender.to_field());\\n        serialized.push(self.storage_contract_address.to_field());\\n        serialized.push(self.function_selector.to_field());\\n        serialized.push(self.is_delegate_call as Field);\\n        serialized.push(self.is_static_call as Field);\\n    \\n        serialized.storage\\n    }\\n}\\n\\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\\n        let mut reader = Reader::new(serialized);\\n        CallContext {\\n            msg_sender: AztecAddress::from_field(reader.read()),\\n            storage_contract_address: AztecAddress::from_field(reader.read()),\\n            function_selector: FunctionSelector::from_field(reader.read()),\\n            is_delegate_call: reader.read() as bool,\\n            is_static_call: reader.read() as bool,\\n        }\\n    }\\n}\\n\\nimpl Empty for CallContext {\\n    fn empty() -> Self {\\n        CallContext {\\n            msg_sender: AztecAddress::empty(),\\n            storage_contract_address: AztecAddress::empty(),\\n            function_selector: FunctionSelector::empty(),\\n            is_delegate_call: false,\\n            is_static_call: false,\\n        }\\n    }\\n}\\n\\n#[test]\\nfn serialize_deserialize_of_empty() {\\n    let context = CallContext::empty();\\n    let serialized = context.serialize();\\n    let deserialized = CallContext::deserialize(serialized);\\n    assert(context.eq(deserialized));\\n}\\n\\n#[test]\\nfn test_eq() {\\n    let mut context1 = CallContext::empty();\\n    let mut context2 = CallContext::empty();\\n\\n    context1.is_delegate_call = true;\\n    context2.is_delegate_call = true;\\n\\n    let address: AztecAddress = AztecAddress::from_field(69420);\\n    context1.msg_sender = address;\\n    context2.msg_sender = address;\\n\\n    assert(context1.eq(context2));\\n}\\n\\n#[test(should_fail)]\\nfn not_eq_test_eq() {\\n    let mut context1 = CallContext::empty();\\n    let mut context2 = CallContext::empty();\\n\\n    context1.is_delegate_call = true;\\n    context2.is_delegate_call = false;\\n\\n    let address1: AztecAddress = AztecAddress::from_field(69420);\\n    let address2: AztecAddress = AztecAddress::from_field(42069);\\n\\n    context1.msg_sender = address1;\\n    context2.msg_sender = address2;\\n\\n    assert(context1.eq(context2));\\n}\\n\\n#[test]\\nfn hash_smoke() {\\n    let context = CallContext::empty();\\n    let _hashed = context.hash();\\n}\\n"},"217":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\\n\\nstruct MaxBlockNumber {\\n    _opt: Option<u32>\\n}\\n\\nimpl Empty for MaxBlockNumber {\\n    fn empty() -> Self {\\n        Self { _opt: Option::none() }\\n    }\\n}\\n\\nimpl Eq for MaxBlockNumber {\\n    fn eq(self, other: Self) -> bool {\\n        self._opt == other._opt\\n    }\\n}\\n\\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\\n        [self._opt._is_some as Field, self._opt._value as Field]\\n    }\\n}\\n\\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\\n        MaxBlockNumber {\\n            _opt: Option {\\n                _is_some: serialized[0] as bool,\\n                _value: serialized[1] as u32,\\n            }\\n        }\\n    }\\n}\\n\\nimpl MaxBlockNumber {\\n    pub fn new(max_block_number: u32) -> Self {\\n        Self { _opt: Option::some(max_block_number) }\\n    }\\n\\n    pub fn is_none(self) -> bool {\\n        self._opt.is_none()\\n    }\\n\\n    pub fn is_some(self) -> bool {\\n        self._opt.is_some()\\n    }\\n\\n    pub fn unwrap(self) -> u32 {\\n        self._opt.unwrap()\\n    }\\n\\n    pub fn unwrap_unchecked(self) -> u32 {\\n        self._opt.unwrap_unchecked()\\n    }\\n\\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\\n        if rhs.is_none() {\\n            lhs // lhs might also be none, but in that case both would be\\n        } else {\\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\\n        }\\n    }\\n\\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\\n        if lhs._opt.is_none() {\\n            MaxBlockNumber::new(rhs)\\n        } else {\\n            let lhs_value = lhs._opt.unwrap_unchecked();\\n\\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\\n        }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = MaxBlockNumber::empty();\\n    let serialized = item.serialize();\\n    let deserialized = MaxBlockNumber::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n\\n#[test]\\nfn zeroed_is_none() {\\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\\n    // and though we should eventually move everything to use `default`, it\'s good to check for now that both are\\n    // equivalent.\\n    let a = MaxBlockNumber::empty();\\n    assert(a.is_none());\\n}\\n\\n#[test]\\nfn serde_default() {\\n    let a = MaxBlockNumber::empty();\\n    let b = MaxBlockNumber::deserialize(a.serialize());\\n    assert(b.is_none());\\n}\\n\\n#[test]\\nfn serde_some() {\\n    let a = MaxBlockNumber::new(13);\\n    let b = MaxBlockNumber::deserialize(a.serialize());\\n    assert_eq(b.unwrap(), 13);\\n}\\n\\n#[test(should_fail)]\\nfn default_unwrap_panics() {\\n    let a = MaxBlockNumber::empty();\\n    let _ = a.unwrap();\\n}\\n\\n#[test]\\nfn min_default_default() {\\n    let a = MaxBlockNumber::empty();\\n    let b = MaxBlockNumber::empty();\\n\\n    assert(MaxBlockNumber::min(a, b).is_none());\\n}\\n\\n#[test]\\nfn min_default_some() {\\n    let a = MaxBlockNumber::empty();\\n    let b = MaxBlockNumber::new(13);\\n\\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\\n}\\n\\n#[test]\\nfn min_some_some() {\\n    let a = MaxBlockNumber::new(13);\\n    let b = MaxBlockNumber::new(42);\\n\\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\\n}\\n\\n#[test]\\nfn min_with_u32_default() {\\n    let a = MaxBlockNumber::empty();\\n    let b = 42;\\n\\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\\n}\\n\\n#[test]\\nfn min_with_u32_some() {\\n    let a = MaxBlockNumber::new(13);\\n    let b = 42;\\n    let c = 8;\\n\\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\\n}\\n"},"220":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr","source":"use crate::{\\n    abis::function_selector::FunctionSelector,\\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\\n    traits::{Serialize, Hash, Deserialize, Empty}\\n};\\n\\nstruct FunctionData {\\n    selector : FunctionSelector,\\n    is_private : bool,\\n}\\n\\nimpl Eq for FunctionData {\\n    fn eq(self, other: Self) -> bool {\\n        self.selector.eq(other.selector) &\\n        (self.is_private == other.is_private)\\n    }\\n}\\n\\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\\n    // A field is ~256 bits\\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\\n    // This method will simply return a bit packed Field instead of hashing\\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\\n        [\\n            self.selector.to_field(),\\n            self.is_private as Field,\\n        ]\\n    }\\n}\\n\\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\\n        Self {\\n            selector: FunctionSelector::from_field(serialized[0]),\\n            is_private: serialized[1] as bool,\\n        }\\n    }\\n}\\n\\nimpl Hash for FunctionData {\\n    fn hash(self) -> Field {\\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\\n    }\\n}\\n\\nimpl Empty for FunctionData {\\n    fn empty() -> Self {\\n        FunctionData {\\n            selector: FunctionSelector::empty(),\\n            is_private: false\\n        }\\n    }\\n\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let data = FunctionData::empty();\\n    let serialized = data.serialize();\\n    let deserialized = FunctionData::deserialize(serialized);\\n    assert(data.eq(deserialized));\\n}\\n\\n#[test]\\nfn empty_hash() {\\n    let data = FunctionData::empty();\\n    let hash = data.hash();\\n\\n    // Value from function_data.test.ts \\"computes empty function data hash\\" test\\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\\n    assert_eq(hash, test_data_empty_hash);\\n}\\n"},"227":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr","source":"use crate::{\\n    address::{AztecAddress, EthAddress},\\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\\n    utils::{arrays::array_concat, reader::Reader}\\n};\\n\\n// Note: Not to be confused with L2ToL1Msg in Solidity\\nstruct L2ToL1Message {\\n    recipient: EthAddress,\\n    content: Field,\\n    counter: u32,\\n}\\n\\nimpl Ordered for L2ToL1Message {\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl Empty for L2ToL1Message {\\n    fn empty() -> Self {\\n        Self {\\n            recipient: EthAddress::empty(),\\n            content: 0,\\n            counter: 0,\\n        }\\n    }\\n}\\n\\nimpl Eq for L2ToL1Message {\\n    fn eq(self, other: Self) -> bool {\\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\\n    }\\n}\\n\\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\\n        [self.recipient.to_field(), self.content, self.counter as Field]\\n    }\\n}\\n\\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\\n        Self {\\n            recipient: EthAddress::from_field(values[0]),\\n            content: values[1],\\n            counter: values[2] as u32,\\n        }\\n    }\\n}\\n\\nimpl L2ToL1Message {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\\n        ScopedL2ToL1Message { message: self, contract_address }\\n    }\\n}\\n\\nstruct ScopedL2ToL1Message {\\n    message: L2ToL1Message,\\n    contract_address: AztecAddress,\\n}\\n\\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\\n    fn inner(self) -> L2ToL1Message {\\n        self.message\\n    }\\n    fn contract_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n}\\n\\nimpl Ordered for ScopedL2ToL1Message {\\n    fn counter(self) -> u32 {\\n        self.message.counter\\n    }\\n}\\n\\nimpl Eq for ScopedL2ToL1Message {\\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\\n        (self.message == other.message)\\n            & (self.contract_address == other.contract_address) \\n    }\\n}\\n\\nimpl Empty for ScopedL2ToL1Message {\\n    fn empty() -> Self {\\n        ScopedL2ToL1Message {\\n            message: L2ToL1Message::empty(),\\n            contract_address: AztecAddress::empty(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\\n    }\\n}\\n\\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\\n        let mut reader = Reader::new(values);\\n        let res = Self {\\n            message: reader.read_struct(L2ToL1Message::deserialize),\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n        };\\n        reader.finish();\\n        res\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty_l2() {\\n    let item = L2ToL1Message::empty();\\n    let serialized = item.serialize();\\n    let deserialized = L2ToL1Message::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n\\n#[test]\\nfn serialization_of_empty_scoped_l2() {\\n    let item = ScopedL2ToL1Message::empty();\\n    let serialized = item.serialize();\\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"229":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\\n\\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\\n    pedersen_hash([storage_slot, key.to_field()], 0)\\n}\\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\\n\\nglobal BOOL_SERIALIZED_LEN: Field = 1;\\nglobal U8_SERIALIZED_LEN: Field = 1;\\nglobal U32_SERIALIZED_LEN: Field = 1;\\nglobal U64_SERIALIZED_LEN: Field = 1;\\nglobal U128_SERIALIZED_LEN: Field = 1;\\nglobal FIELD_SERIALIZED_LEN: Field = 1;\\n\\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\\n        fields[0] as bool\\n    }\\n}\\n\\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u8\\n    }\\n}\\n\\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u32\\n    }\\n}\\n\\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u64\\n    }\\n}\\n\\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\\n    fn serialize(self) -> [Field; 1] {\\n        [self.to_integer()]\\n    }\\n\\n}\\n\\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\\n        U128::from_integer(fields[0])\\n    }\\n}\\n\\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\\n        [self]\\n    }\\n}\\n\\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\\n        fields[0]\\n    }\\n}\\n"},"237":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr","source":"use crate::{\\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\\n    utils::arr_copy_slice\\n};\\n\\nstruct ContentCommitment {\\n  num_txs: Field,\\n  txs_effects_hash: Field,\\n  in_hash: Field,\\n  out_hash: Field,\\n}\\n\\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\\n\\n    fields.push(self.num_txs);\\n    fields.push(self.txs_effects_hash);\\n    fields.push(self.in_hash);\\n    fields.push(self.out_hash);\\n\\n    fields.storage\\n  }\\n}\\n\\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\\n    let num_txs = serialized[0];\\n\\n    let txs_effects_hash = serialized[1];\\n\\n    let in_hash = serialized[2];\\n\\n    let out_hash = serialized[3];\\n\\n    Self {\\n      num_txs,\\n      txs_effects_hash,\\n      in_hash,\\n      out_hash,\\n    }\\n  }\\n}\\n\\nimpl Empty for ContentCommitment {\\n  fn empty() -> Self {\\n    Self {\\n      num_txs: 0,\\n      txs_effects_hash: 0,\\n      in_hash: 0,\\n      out_hash: 0,\\n    }\\n  }\\n}\\n\\nimpl Eq for ContentCommitment {\\n  fn eq(self, other: Self) -> bool {\\n    (self.num_txs == other.num_txs)\\n      & (self.txs_effects_hash == other.txs_effects_hash)\\n      & (self.in_hash == other.in_hash)\\n      & (self.out_hash == other.out_hash)\\n  }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let empty = ContentCommitment::empty();\\n    let serialized = empty.serialize();\\n    let deserialized = ContentCommitment::deserialize(serialized);\\n\\n    assert(empty.eq(deserialized));\\n}\\n"},"239":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr","source":"use crate::{\\n    abis::{\\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\\n},\\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\\n    utils::arr_copy_slice, content_commitment::ContentCommitment\\n};\\n\\n// docs:start:header\\nstruct Header {\\n    last_archive: AppendOnlyTreeSnapshot,\\n    content_commitment: ContentCommitment,\\n    state: StateReference,\\n    global_variables: GlobalVariables,\\n    total_fees: Field\\n}\\n// docs:end:header\\n\\nimpl Eq for Header {\\n    fn eq(self, other: Self) -> bool {\\n        self.last_archive.eq(other.last_archive) &\\n        self.content_commitment.eq(other.content_commitment) &\\n        self.state.eq(other.state) &\\n        self.global_variables.eq(other.global_variables) &\\n        self.total_fees.eq(other.total_fees)\\n    }\\n}\\n\\nimpl Serialize<HEADER_LENGTH> for Header {\\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\\n\\n        fields.extend_from_array(self.last_archive.serialize());\\n        fields.extend_from_array(self.content_commitment.serialize());\\n        fields.extend_from_array(self.state.serialize());\\n        fields.extend_from_array(self.global_variables.serialize());\\n        fields.push(self.total_fees);\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<HEADER_LENGTH> for Header {\\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\\n        let mut offset = 0;\\n\\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\\n\\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\\n\\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\\n        offset = offset + STATE_REFERENCE_LENGTH;\\n\\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\\n\\n        let total_fees = serialized[offset];\\n\\n        Header {\\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\\n            state: StateReference::deserialize(state_fields),\\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\\n            total_fees\\n        }\\n    }\\n}\\n\\nimpl Empty for Header {\\n    fn empty() -> Self {\\n        Self {\\n            last_archive: AppendOnlyTreeSnapshot::zero(),\\n            content_commitment: ContentCommitment::empty(),\\n            state: StateReference::empty(),\\n            global_variables: GlobalVariables::empty(),\\n            total_fees: 0\\n        }\\n    }\\n}\\n\\nimpl Hash for Header {\\n    fn hash(self) -> Field {\\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let header = Header::empty();\\n    let serialized = header.serialize();\\n    let deserialized = Header::deserialize(serialized);\\n    assert(header.eq(deserialized));\\n}\\n\\n#[test]\\nfn hash_smoke() {\\n    let header = Header::empty();\\n    let _hashed = header.hash();\\n}\\n\\n#[test]\\nfn empty_hash_is_zero() {\\n    let header = Header::empty();\\n    let hash = header.hash();\\n\\n    // Value from new_contract_data.test.ts \\"computes empty hash\\" test\\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\\n    assert_eq(hash, test_data_empty_hash);\\n}\\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\\n    abis::{\\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\\n},\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\\n},\\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\\n    recursion::verification_key::VerificationKey, traits::is_empty,\\n    utils::field::field_from_bytes_32_trunc\\n};\\nuse std::hash::{pedersen_hash_with_separator, sha256};\\n\\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\\n    let sha256_hashed = sha256(bytes_to_hash);\\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\\n\\n    hash_in_a_field\\n}\\n\\npub fn private_functions_root_from_siblings(\\n    selector: FunctionSelector,\\n    vk_hash: Field,\\n    function_leaf_index: Field,\\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\\n) -> Field {\\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\\n    let function_leaf = function_leaf_preimage.hash();\\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\\n}\\n\\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\\n    // Hashing tx hash with note index in tx is guaranteed to be unique\\n    pedersen_hash(\\n        [\\n        tx_hash,\\n        note_index_in_tx as Field\\n    ],\\n        GENERATOR_INDEX__NOTE_HASH_NONCE\\n    )\\n}\\n\\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\\n    let inputs = [nonce, inner_note_hash];\\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\\n}\\n\\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\\n    pedersen_hash(\\n        [\\n        app.to_field(),\\n        unique_note_hash\\n    ],\\n        GENERATOR_INDEX__SILOED_NOTE_HASH\\n    )\\n}\\n\\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\\n    if note_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\\n    }\\n}\\n\\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\\n    pedersen_hash(\\n        [\\n        app.to_field(),\\n        nullifier\\n    ],\\n        GENERATOR_INDEX__OUTER_NULLIFIER\\n    )\\n}\\n\\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\\n    if nullifier.contract_address.is_zero() {\\n        nullifier.value() // Return value instead of 0 because the first nullifier\'s contract address is zero.\\n    } else {\\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\\n    }\\n}\\n\\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\\n    // NB: A unique separator will be needed for masked_contract_address\\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\\n    if randomness == 0 {\\n        // In some cases, we actually want to reveal the contract address we are siloing with:\\n        // e.g. \'handshaking\' contract w/ known address\\n        // An app providing randomness = 0 signals to not mask the address.\\n        masked_contract_address = address.to_field();\\n    }\\n    accumulate_sha256([masked_contract_address, log_hash])\\n}\\n\\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\\n    if log_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_encrypted_log_hash(\\n            log_hash.contract_address,\\n            log_hash.log_hash.randomness,\\n            log_hash.log_hash.value\\n        )\\n    }\\n}\\n\\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\\n    accumulate_sha256([address.to_field(), log_hash])\\n}\\n\\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\\n    if log_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\\n    }\\n}\\n\\npub fn merkle_hash(left: Field, right: Field) -> Field {\\n    pedersen_hash([left, right], 0)\\n}\\n\\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\\n    // Original cpp code\\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\\n    // The above cpp method is only ever called on verification key, so it has been special cased here\\n    let _hash_index = GENERATOR_INDEX__VK;\\n    0\\n}\\n\\npub fn compute_l2_to_l1_hash(\\n    contract_address: AztecAddress,\\n    recipient: EthAddress,\\n    content: Field,\\n    rollup_version_id: Field,\\n    chain_id: Field\\n) -> Field {\\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\\n\\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\\n    for i in 0..inputs.len() {\\n        // TODO are bytes be in fr.to_buffer() ?\\n        let item_bytes = inputs[i].to_be_bytes(32);\\n        for j in 0..32 {\\n            bytes.push(item_bytes[j]);\\n        }\\n    }\\n\\n    sha256_to_field(bytes.storage)\\n}\\n\\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\\n    if msg.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_l2_to_l1_hash(\\n            msg.contract_address,\\n            msg.message.recipient,\\n            msg.message.content,\\n            rollup_version_id,\\n            chain_id\\n        )\\n    }\\n}\\n\\n// Computes sha256 hash of 2 input hashes.\\n//\\n// NB: This method now takes in two 31 byte fields - it assumes that any input\\n// is the result of a sha_to_field hash and => is truncated\\n//\\n// TODO(Jan and David): This is used for the encrypted_log hashes.\\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\\n//\\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\\n    // This is a note about the cpp code, since it takes an array of Fields\\n    // instead of a U128.\\n    // 4 Field elements when converted to bytes will usually \\n    // occupy 4 * 32 = 128 bytes.\\n    // However, this function is making the assumption that each Field \\n    // only occupies 128 bits.\\n    //\\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\\n\\n    // Concatentate two fields into 32x2 = 64 bytes\\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\\n    let mut hash_input_flattened = [0; 64];\\n    for offset in 0..input.len() {\\n        let input_as_bytes = input[offset].to_be_bytes(32);\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n\\n    sha256_to_field(hash_input_flattened)\\n}\\n\\n// Computes the final logs hash for a tx.\\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\\n// to avoid doubling code, since we can\'t define the byte len to be 32*N directly. \\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n    // Ideally we would push to a slice then hash, but there is no sha_slice\\n    // Hardcode to 256 bytes for now\\n    let mut hash = sha256_to_field(hash_input_flattened);\\n    // Not having a 0 value hash for empty logs causes issues with empty txs\\n    // used for padding. Returning early is currently unsupported.\\n    // We always provide sorted logs here, so 0 being empty means all are empty.\\n    if is_empty(logs[0]) {\\n        hash = 0;\\n    }\\n    hash\\n}\\n\\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n    // Ideally we would push to a slice then hash, but there is no sha_slice\\n    // Hardcode to 256 bytes for now\\n    let mut hash = sha256_to_field(hash_input_flattened);\\n    // Not having a 0 value hash for empty logs causes issues with empty txs\\n    // used for padding. Returning early is currently unsupported.\\n    // We always provide sorted logs here, so 0 being empty means all are empty.\\n    if is_empty(logs[0]) {\\n        hash = 0;\\n    }\\n    hash\\n}\\n\\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\\n}\\n\\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\\n}\\n\\n#[test]\\nfn smoke_sha256_to_field() {\\n    let full_buffer = [\\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\\n    ];\\n    let result = sha256_to_field(full_buffer);\\n\\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\\n\\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\\n    let result_bytes = sha256(full_buffer);\\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\\n    assert(truncated_field == result);\\n    let mod_res = result + (result_bytes[31] as Field);\\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\\n}\\n\\n#[test]\\nfn compute_l2_l1_hash() {\\n    // All zeroes\\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\\n\\n    // Non-zero case\\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\\n}\\n"},"241":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr","source":"use crate::{\\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\\n    traits::{Deserialize, Empty, Serialize}\\n};\\n\\nstruct PartialStateReference {\\n    note_hash_tree: AppendOnlyTreeSnapshot,\\n    nullifier_tree: AppendOnlyTreeSnapshot,\\n    public_data_tree: AppendOnlyTreeSnapshot,\\n}\\n\\nimpl Eq for PartialStateReference {\\n    fn eq(self, other: PartialStateReference) -> bool {\\n        self.note_hash_tree.eq(other.note_hash_tree) &\\n        self.nullifier_tree.eq(other.nullifier_tree) &\\n        self.public_data_tree.eq(other.public_data_tree)\\n    }\\n}\\n\\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\\n        let serialized_public_data_tree = self.public_data_tree.serialize();\\n\\n        [\\n            serialized_note_hash_tree[0], \\n            serialized_note_hash_tree[1],\\n            serialized_nullifier_tree[0],\\n            serialized_nullifier_tree[1],\\n            serialized_public_data_tree[0],\\n            serialized_public_data_tree[1],\\n        ]\\n    }\\n}\\n\\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\\n        PartialStateReference {\\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\\n                [serialized[0], serialized[1]]\\n            ),\\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\\n                [serialized[2], serialized[3]]\\n            ),\\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\\n                [serialized[4], serialized[5]]\\n            ),\\n        }\\n    }\\n}\\n\\nimpl Empty for PartialStateReference {\\n    fn empty() -> Self {\\n        Self {\\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\\n        }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let partial = PartialStateReference::empty();\\n    let _serialized = partial.serialize();\\n    let _deserialized = PartialStateReference::deserialize(_serialized);\\n}\\n"},"243":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr","source":"use crate::{\\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\\n    abis::gas_settings::GasSettings\\n};\\n\\n// docs:start:tx-context\\nstruct TxContext {\\n    chain_id : Field,\\n    version : Field,\\n    gas_settings: GasSettings,\\n}\\n// docs:end:tx-context\\n\\nimpl TxContext {\\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\\n        TxContext { chain_id, version, gas_settings }\\n    }\\n}\\n\\nimpl Eq for TxContext {\\n    fn eq(self, other: Self) -> bool {\\n        (self.chain_id == other.chain_id) &\\n        (self.version == other.version) &\\n        (self.gas_settings.eq(other.gas_settings))\\n    }\\n}\\n\\nimpl Empty for TxContext {\\n    fn empty() -> Self {\\n        TxContext {\\n            chain_id: 0,\\n            version: 0,\\n            gas_settings: GasSettings::empty(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\\n\\n        fields.push(self.chain_id);\\n        fields.push(self.version);\\n        fields.extend_from_array(self.gas_settings.serialize());\\n\\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\\n        let mut reader = Reader::new(serialized);\\n\\n        let context = Self {\\n            chain_id: reader.read(),\\n            version: reader.read(),\\n            gas_settings: reader.read_struct(GasSettings::deserialize),\\n        };\\n\\n        reader.finish();\\n        context\\n    }\\n}\\n\\nimpl Hash for TxContext {\\n    fn hash(self) -> Field {\\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let context = TxContext::empty();\\n    let serialized = context.serialize();\\n    let deserialized = TxContext::deserialize(serialized);\\n    assert(context.eq(deserialized));\\n}\\n\\n#[test]\\nfn empty_hash() {\\n    let context = TxContext::empty();\\n    let hash = context.hash();\\n\\n    // Value from tx_context.test.ts \\"computes empty item hash\\" test\\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\\n    assert_eq(hash, test_data_empty_hash);\\n}\\n"},"249":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr","source":"use crate::{\\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\\n    utils::arr_copy_slice\\n};\\n\\nstruct StateReference {\\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\\n    partial: PartialStateReference,\\n}\\n\\nimpl Eq for StateReference {\\n    fn eq(self, other: StateReference) -> bool {\\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\\n        self.partial.eq(other.partial)\\n    }\\n}\\n\\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\\n\\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\\n        fields.extend_from_array(self.partial.serialize());\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\\n        let mut offset = 0;\\n\\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\\n\\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\\n\\n        StateReference {\\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\\n            partial: PartialStateReference::deserialize(partial_fields),\\n        }\\n    }\\n}\\n\\nimpl Empty for StateReference {\\n    fn empty() -> Self {\\n        Self {\\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\\n            partial: PartialStateReference::empty(),\\n        }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let state = StateReference::empty();\\n    let _serialized = state.serialize();\\n    let _deserialized = StateReference::deserialize(_serialized);\\n}\\n"},"263":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\\n    data: [Field; N],\\n    offset: u32,\\n}\\n\\nimpl<N> Reader<N> {\\n    pub fn new(data: [Field; N]) -> Self {\\n        Self { data, offset: 0 }\\n    }\\n\\n    pub fn read(&mut self) -> Field {\\n        let result = self.data[self.offset];\\n        self.offset += 1;\\n        result\\n    }\\n\\n    pub fn read_u32(&mut self) -> u32 {\\n        self.read() as u32\\n    }\\n\\n    pub fn read_bool(&mut self) -> bool {\\n        self.read() as bool\\n    }\\n\\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\\n        for i in 0..K {\\n            result[i] = self.data[self.offset + i];\\n        }\\n        self.offset += K;\\n        result\\n    }\\n\\n    // TODO(#4394)\\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\\n        let result = deserialise(self.read_array([0; K]));\\n        result\\n    }\\n\\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\\n        for i in 0..C {\\n            result[i] = self.read_struct(deserialise);\\n        }\\n        result\\n    }\\n\\n    pub fn finish(self) {\\n        assert(self.offset == self.data.len(), \\"Reader did not read all data\\");\\n    }\\n}\\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\\n// because there is no criteria for what we should not put in here.\\n// Reducing the size of this package would be welcome.\\n\\nmod arrays;\\nmod field;\\nmod reader;\\nmod uint256;\\n\\n// if predicate == true then return lhs, else return rhs\\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\\n    if predicate { lhs } else { rhs }\\n}\\n\\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\\n    let iterator_len = if N > M { M } else { N };\\n    for i in 0..iterator_len {\\n        dst[i] = src[i + offset];\\n    }\\n    dst\\n}\\n"},"289":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\\n};\\n\\nstruct EthAddress{\\n    inner : Field\\n}\\n\\nimpl Eq for EthAddress {\\n    fn eq(self, other : Self) -> bool {\\n        self.to_field() == other.to_field()\\n    }\\n}\\n\\nimpl Empty for EthAddress {\\n    fn empty() -> Self {\\n        Self {\\n            inner : 0\\n        }\\n    }\\n}\\n\\nimpl ToField for EthAddress {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\\n        [self.inner]\\n    }\\n}\\n\\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\\n        EthAddress::from_field(fields[0])\\n    }\\n}\\n\\nimpl EthAddress {\\n    pub fn zero() -> Self {\\n        Self { inner: 0 }\\n    }\\n\\n    pub fn from_field(field: Field) -> Self {\\n        field.assert_max_bit_size(160);\\n        Self { inner: field }\\n    }\\n\\n    pub fn is_zero(self) -> bool {\\n        self.inner == 0\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n\\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\\n        Self { inner: result }\\n    }\\n}\\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\\n};\\n\\n// Aztec address\\nstruct AztecAddress {\\n    inner : Field\\n}\\n\\nimpl Eq for AztecAddress {\\n    fn eq(self, other : Self) -> bool {\\n        self.to_field() == other.to_field()\\n    }\\n}\\n\\nimpl Empty for AztecAddress {\\n    fn empty() -> Self {\\n        Self {\\n            inner : 0\\n        }\\n    }\\n}\\n\\nimpl ToField for AztecAddress {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl FromField for AztecAddress {\\n    fn from_field(value: Field) -> AztecAddress {\\n        AztecAddress { inner: value }\\n    }\\n}\\n\\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\\n        [self.to_field()]\\n    }\\n}\\n\\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\\n        FromField::from_field(fields[0])\\n    }\\n}\\n\\nimpl AztecAddress {\\n    pub fn zero() -> Self {\\n        Self { inner: 0 }\\n    }\\n\\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\\n        AztecAddress::from_field(\\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\\n        )\\n    }\\n\\n    pub fn is_zero(self) -> bool {\\n        self.inner == 0\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n\\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\\n        Self { inner: result }\\n    }\\n}\\n\\n#[test]\\nfn compute_address_from_partial_and_pub_keys_hash() {\\n    let pub_keys_hash = PublicKeysHash::from_field(1);\\n    let partial_address = PartialAddress::from_field(2);\\n\\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\\n}\\n\\n#[test]\\nfn from_field_to_field() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(FromField::from_field(address.to_field()), address);\\n}\\n\\n#[test]\\nfn serde() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\\n}\\n"},"322":{"path":"/usr/src/noir-projects/noir-contracts/contracts/auth_registry_contract/src/main.nr","source":"contract AuthRegistry {\\n    use dep::aztec::{state_vars::{PublicMutable, Map}, protocol_types::address::AztecAddress};\\n    use dep::authwit::auth::{IS_VALID_SELECTOR, compute_authwit_message_hash, assert_current_call_valid_authwit};\\n\\n    #[aztec(storage)]\\n    struct Storage {\\n      reject_all: Map<AztecAddress, PublicMutable<bool>>,\\n      // on_behalf_of => authwit hash => authorized\\n      approved_actions: Map<AztecAddress, Map<Field, PublicMutable<bool>>>,\\n    }\\n\\n    /**\\n     * Updates the `authorized` value for `msg_sender` for `message_hash`.\\n     *\\n     * @param message_hash The message hash being authorized\\n     * @param authorize True if the caller is authorized to perform the message hash, false otherwise\\n     */\\n    #[aztec(public)]\\n    fn set_authorized(message_hash: Field, authorize: bool) {\\n        storage.approved_actions.at(context.msg_sender()).at(message_hash).write(authorize);\\n    }\\n\\n    /**\\n     * Updates the `reject_all` value for `msg_sender`.\\n     * \\n     * When `reject_all` is `true` any `consume` on `msg_sender` will revert.\\n     * \\n     * @param reject True if all actions should be rejected, false otherwise\\n     */\\n    #[aztec(public)]\\n    fn set_reject_all(reject: bool) {\\n        storage.reject_all.at(context.msg_sender()).write(reject);\\n    }\\n\\n    /**\\n     * Consumes an `inner_hash` on behalf of `on_behalf_of` if the caller is authorized to do so.\\n     * \\n     * Will revert even if the caller is authorized if `reject_all` is set to true for `on_behalf_of`.\\n     * This is to support \\"mass-revoke\\".\\n     *\\n     * @param on_behalf_of The address on whose behalf the action is being consumed\\n     * @param inner_hash The inner_hash of the authwit\\n     * @return `IS_VALID_SELECTOR` if the action was consumed, revert otherwise\\n     */\\n    #[aztec(public)]\\n    fn consume(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\\n        assert_eq(false, storage.reject_all.at(on_behalf_of).read(), \\"rejecting all\\");\\n\\n        let message_hash = compute_authwit_message_hash(\\n            context.msg_sender(),\\n            context.chain_id(),\\n            context.version(),\\n            inner_hash\\n        );\\n\\n        let authorized = storage.approved_actions.at(on_behalf_of).at(message_hash).read();\\n\\n        assert_eq(true, authorized, \\"unauthorized\\");\\n        storage.approved_actions.at(on_behalf_of).at(message_hash).write(false);\\n\\n        IS_VALID_SELECTOR\\n    }\\n\\n    /**\\n     * Updates a public authwit using a private authwit\\n     * \\n     * Useful for the case where you want someone else to insert a public authwit for you.\\n     * For example, if Alice wants Bob to insert an authwit in public, such that they can execute\\n     * a trade, Alice can create a private authwit, and Bob can call this function with it.\\n     *\\n     * @param approver The address of the approver (Alice in the example)\\n     * @param message_hash The message hash to authorize\\n     * @param authorize True if the message hash should be authorized, false otherwise\\n     */\\n    #[aztec(private)]\\n    fn set_authorized_private(approver: AztecAddress, message_hash: Field, authorize: bool) {\\n        assert_current_call_valid_authwit(&mut context, approver);\\n        AuthRegistry::at(context.this_address())._set_authorized(approver, message_hash, authorize).enqueue(&mut context);\\n    }\\n\\n    /**\\n     * Internal function to update the `authorized` value for `approver` for `messageHash`.\\n     * Used along with `set_authorized_private` to update the public authwit.\\n     * \\n     * @param approver The address of the approver\\n     * @param message_hash The message hash being authorized\\n     * @param authorize True if the caller is authorized to perform the message hash, false otherwise\\n     */\\n    #[aztec(public)]\\n    #[aztec(internal)]\\n    fn _set_authorized(approver: AztecAddress, message_hash: Field, authorize: bool) {\\n        storage.approved_actions.at(approver).at(message_hash).write(authorize);\\n    }\\n\\n    /**\\n     * Fetches the `reject_all` value for `on_behalf_of`.\\n     * \\n     * @param on_behalf_of The address to check\\n     * @return True if all actions are rejected, false otherwise\\n     */\\n    #[aztec(public)]\\n    #[aztec(view)]\\n    fn is_reject_all(on_behalf_of: AztecAddress) -> bool {\\n        storage.reject_all.at(on_behalf_of).read()\\n    }\\n\\n    /**\\n     * Fetches the `authorized` value for `on_behalf_of` for `message_hash`.\\n     * \\n     * @param on_behalf_of The address on whose behalf the action is being consumed\\n     * @param message_hash The message hash to check\\n     * @return True if the caller is authorized to perform the action, false otherwise\\n     */\\n    #[aztec(public)]\\n    #[aztec(view)]\\n    fn is_consumable(on_behalf_of: AztecAddress, message_hash: Field) -> bool {\\n        storage.approved_actions.at(on_behalf_of).at(message_hash).read()\\n    }\\n\\n    unconstrained fn unconstrained_is_consumable(on_behalf_of: AztecAddress, message_hash: Field) -> pub bool {\\n        storage.approved_actions.at(on_behalf_of).at(message_hash).read()\\n    }\\n}\\n"}}}'));const Nd=Nr.fromBigInt(18091885756106795278141309801070173692350235742979924147720536894670507925831n);class Gd{constructor(e){this.pxe=e}getAddress(){return this.getCompleteAddress().address}getContractInstance(e){return this.pxe.getContractInstance(e)}getContractClass(e){return this.pxe.getContractClass(e)}getContractArtifact(e){return this.pxe.getContractArtifact(e)}addCapsule(e){return this.pxe.addCapsule(e)}registerAccount(e,t){return this.pxe.registerAccount(e,t)}rotateNskM(e,t){return this.pxe.rotateNskM(e,t)}registerRecipient(e){return this.pxe.registerRecipient(e)}getRegisteredAccounts(){return this.pxe.getRegisteredAccounts()}getRegisteredAccount(e){return this.pxe.getRegisteredAccount(e)}getRecipients(){return this.pxe.getRecipients()}getRecipient(e){return this.pxe.getRecipient(e)}registerContract(e){return this.pxe.registerContract(e)}registerContractClass(e){return this.pxe.registerContractClass(e)}getContracts(){return this.pxe.getContracts()}proveTx(e,t){return this.pxe.proveTx(e,t)}simulateTx(e,t,n){return this.pxe.simulateTx(e,t,n)}sendTx(e){return this.pxe.sendTx(e)}getTxEffect(e){return this.pxe.getTxEffect(e)}getTxReceipt(e){return this.pxe.getTxReceipt(e)}getIncomingNotes(e){return this.pxe.getIncomingNotes(e)}getOutgoingNotes(e){return this.pxe.getOutgoingNotes(e)}getNoteNonces(e){return this.pxe.getNoteNonces(e)}getPublicStorageAt(e,t){return this.pxe.getPublicStorageAt(e,t)}addNote(e){return this.pxe.addNote(e)}addNullifiedNote(e){return this.pxe.addNullifiedNote(e)}getBlock(e){return this.pxe.getBlock(e)}simulateUnconstrained(e,t,n,s){return this.pxe.simulateUnconstrained(e,t,n,s)}getUnencryptedLogs(e){return this.pxe.getUnencryptedLogs(e)}getBlockNumber(){return this.pxe.getBlockNumber()}getNodeInfo(){return this.pxe.getNodeInfo()}isGlobalStateSynchronized(){return this.pxe.isGlobalStateSynchronized()}isAccountStateSynchronized(e){return this.pxe.isAccountStateSynchronized(e)}getSyncStatus(){return this.pxe.getSyncStatus()}getSyncStats(){return this.pxe.getSyncStats()}addAuthWitness(e){return this.pxe.addAuthWitness(e)}getAuthWitness(e){return this.pxe.getAuthWitness(e)}isContractClassPubliclyRegistered(e){return this.pxe.isContractClassPubliclyRegistered(e)}isContractPubliclyDeployed(e){return this.pxe.isContractPubliclyDeployed(e)}getPXEInfo(){return this.pxe.getPXEInfo()}getEvents(e,t,n,s,r=[this.getCompleteAddress().publicKeys.masterIncomingViewingPublicKey,this.getCompleteAddress().publicKeys.masterOutgoingViewingPublicKey]){return this.pxe.getEvents(e,t,n,s,r)}}var Ld,Od,Rd,Md,Bd,Yd,jd,Hd=r(8891).Buffer;class Id extends Gd{constructor(e,t){super(e),this.account=t}createTxExecutionRequest(e){return this.account.createTxExecutionRequest(e)}getChainId(){return this.account.getChainId()}getVersion(){return this.account.getVersion()}async createAuthWit(e){let t;t=Hd.isBuffer(e)?X.fromBuffer(e):e instanceof X?e:await this.getMessageHash(e);const n=await this.account.createAuthWit(t);return await this.pxe.addAuthWitness(n),n}async setPublicAuthWit(e,t){let n;return n=Hd.isBuffer(e)?X.fromBuffer(e):e instanceof X?e:await this.getMessageHash(e),new Gc(this,Nd,this.getSetAuthorizedAbi(),[n,t])}async getInnerHashAndConsumer(e){if("caller"in e&&"action"in e){const t=e.action instanceof Gc?e.action.request():e.action;return{innerHash:await gd(e.caller,t),consumer:t.to}}return Hd.isBuffer(e.innerHash)?{innerHash:X.fromBuffer(e.innerHash),consumer:e.consumer}:{innerHash:e.innerHash,consumer:e.consumer}}async getMessageHash(e){const t=this.getChainId(),n=this.getVersion();return await md(e,{chainId:t,version:n})}async lookupValidity(e,t){const{innerHash:n,consumer:s}=await this.getInnerHashAndConsumer(t),r=await this.getMessageHash(t),a={isValidInPrivate:!1,isValidInPublic:!1};return void 0!==await this.getAuthWitness(r)&&(a.isValidInPrivate=await new Gc(this,e,this.getLookupValidityAbi(),[s,n]).simulate()),a.isValidInPublic=await new Gc(this,Nd,this.getIsConsumableAbi(),[e,r]).simulate(),a}async rotateNullifierKeys(e=U.random()){await this.pxe.rotateNskM(this.getAddress(),e);const t=new Gc(this,Nr.fromBigInt(2153455745675440165069577621832684870696142028027528497509357256345838682961n),this.getRotateNpkMAbi(),[this.getAddress(),(await oi(e)).toNoirStruct(),X.ZERO]);await(await t.send()).wait()}getCompleteAddress(){return this.account.getCompleteAddress()}getAddress(){return this.getCompleteAddress().address}getSetAuthorizedAbi(){return{name:"set_authorized",isInitializer:!1,functionType:xr.PUBLIC,isInternal:!0,isStatic:!1,parameters:[{name:"message_hash",type:{kind:"field"},visibility:"private"},{name:"authorize",type:{kind:"boolean"},visibility:"private"}],returnTypes:[]}}getLookupValidityAbi(){return{name:"lookup_validity",isInitializer:!1,functionType:xr.UNCONSTRAINED,isInternal:!1,isStatic:!1,parameters:[{name:"message_hash",type:{kind:"field"},visibility:"private"}],returnTypes:[{kind:"boolean"}]}}getIsConsumableAbi(){return{name:"unconstrained_is_consumable",isInitializer:!1,functionType:xr.UNCONSTRAINED,isInternal:!1,isStatic:!1,parameters:[{name:"address",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},visibility:"private"},{name:"message_hash",type:{kind:"field"},visibility:"private"}],returnTypes:[{kind:"boolean"}]}}getRotateNpkMAbi(){return{name:"rotate_npk_m",isInitializer:!1,functionType:xr.PUBLIC,isInternal:!1,isStatic:!1,parameters:[{name:"address",type:{fields:[{name:"inner",type:{kind:"field"}}],kind:"struct",path:"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},visibility:"private"},{name:"new_npk_m",type:{fields:[{name:"x",type:{kind:"field"}},{name:"y",type:{kind:"field"}},{name:"is_infinite",type:{kind:"boolean"}}],kind:"struct",path:"std::embedded_curve_ops::EmbeddedCurvePoint"},visibility:"private"},{name:"nonce",type:{kind:"field"},visibility:"private"}],returnTypes:[]}}}class Xd extends Id{constructor(e,t,n,s){super(e,t),this.secretKey=n,this.salt=s}getSecretKey(){return this.secretKey}}class Ud{constructor(e,t){this.chainId=e,this.protocolVersion=t}async createTxExecutionRequest(e){const{calls:t,authWitnesses:n=[],packedArguments:s=[]}=e;if(t.length>1)throw new Error(`Expected a single call, got ${t.length}`);const r=t[0];if(r.type!==xr.PRIVATE)throw new Error("Public entrypoints are not allowed");const a=await xc.fromValues(r.args),i=e.fee?.gasSettings??ui.default(),o=new fi(this.chainId,this.protocolVersion,i);return Promise.resolve(new Cc(r.to,r.selector,a.hash,o,[...s,a],n))}}class Jd extends Gd{constructor(e,t){super(e),this.entrypoint=t}async createTxExecutionRequest(e){let t=this.entrypoint;if(!t){const{chainId:e,protocolVersion:n}=await this.pxe.getNodeInfo();t=new Ud(e,n)}return t.createTxExecutionRequest(e)}getChainId(){throw new Error("SignerlessWallet: Method getChainId not implemented.")}getVersion(){throw new Error("SignerlessWallet: Method getVersion not implemented.")}getPublicKeysHash(){throw new Error("SignerlessWallet: Method getPublicKeysHash not implemented.")}getCompleteAddress(){throw new Error("SignerlessWallet: Method getCompleteAddress not implemented.")}createAuthWit(e){throw new Error("SignerlessWallet: Method createAuthWit not implemented.")}rotateNullifierKeys(e){throw new Error("SignerlessWallet: Method rotateNullifierKeys not implemented.")}}class Dd{constructor(e){Ld.set(this,[]),Od.set(this,[]),Rd.set(this,X.random()),Md.set(this,void 0),P(this,Md,e,"f")}async init(e){for(const t of e)z(this,Ld,"f").push(await xc.fromValues(t.args));return P(this,Od,e.map(((e,t)=>({args_hash:z(this,Ld,"f")[t].hash,function_selector:e.selector.toField(),target_address:e.to.toField(),is_public:e.type==xr.PUBLIC,is_static:e.isStatic}))),"f"),this}get function_calls(){return z(this,Od,"f")}get nonce(){return z(this,Rd,"f")}get packedArguments(){return z(this,Ld,"f")}async hash(){return await Me(this.toFields(),z(this,Md,"f"))}functionCallsToFields(){return z(this,Od,"f").flatMap((e=>[e.args_hash,e.function_selector,e.target_address,new X(e.is_public),new X(e.is_static)]))}static async fromFunctionCalls(e){const t=new qd(0);return await t.init(e)}static async fromAppExecution(e){if(e.length>4)throw new Error(`Expected at most 4 function calls, got ${e.length}`);const t=oa(e,hc.empty(),4),n=new qd(nt.SIGNATURE_PAYLOAD);return await n.init(t)}static async fromFeeOptions(e,t){const n=await(t?.paymentMethod.getFunctionCalls(t?.gasSettings))??[],s=await(t?.paymentMethod.getFeePayer(t?.gasSettings)),r=!!s&&s.equals(e),a=oa(n,hc.empty(),2),i=new Kd(nt.FEE_PAYLOAD,r);return await i.init(a)}}Ld=new WeakMap,Od=new WeakMap,Rd=new WeakMap,Md=new WeakMap;class qd extends Dd{toFields(){return[...this.functionCallsToFields(),this.nonce]}}class Kd extends Dd{constructor(e,t){super(e),Bd.set(this,void 0),P(this,Bd,t,"f")}toFields(){return[...this.functionCallsToFields(),this.nonce,new X(z(this,Bd,"f"))]}get is_fee_payer(){return z(this,Bd,"f")}}Bd=new WeakMap;class Wd extends sd{constructor(e,t,n,s,r=[],a,i){super(t,n,s,((e,t)=>rd.at(e,s,t)),r,a),Yd.set(this,void 0),jd.set(this,void 0),P(this,Yd,e,"f"),P(this,jd,"string"==typeof i?function(e,t){const n=e.functions.find((e=>"string"==typeof t?e.name===t:t.equals(e.name,e.parameters)));if(!n)throw new Error(`Unknown function ${t}`);const s=function(e,t){if(t.debugSymbols&&e.fileMap)return{debugSymbols:JSON.parse(Tr(kr.from(t.debugSymbols,"base64"),{to:"string",raw:!0})).debug_infos[0],files:e.fileMap}}(e,n);return{...n,debug:s}}(s,i):i,"f")}async getInitializeFunctionCalls(e){const t=await super.getInitializeFunctionCalls(e);if(e.fee&&z(this,jd,"f")){const{address:n}=await this.getInstance(),s=await Dd.fromAppExecution([]),r=await Dd.fromFeeOptions(n,e?.fee);t.calls.push({name:z(this,jd,"f").name,to:n,args:Yr(z(this,jd,"f"),[s,r]),selector:Ur.fromNameAndParameters(z(this,jd,"f").name,z(this,jd,"f").parameters),type:z(this,jd,"f").functionType,isStatic:z(this,jd,"f").isStatic,returnTypes:z(this,jd,"f").returnTypes}),t.authWitnesses??(t.authWitnesses=[]),t.packedArguments??(t.packedArguments=[]),t.authWitnesses.push(await z(this,Yd,"f").createAuthWit(await s.hash())),t.authWitnesses.push(await z(this,Yd,"f").createAuthWit(await r.hash())),t.packedArguments.push(...s.packedArguments),t.packedArguments.push(...r.packedArguments)}return t}}Yd=new WeakMap,jd=new WeakMap;class Zd extends Fc{constructor(e,t,n){super(e,t),this.getWalletPromise=n}async getWallet(e){return(await this.wait(e)).wallet}async wait(e=Pc){const t=await super.wait(e),n=await this.getWalletPromise;return await wd(this.pxe,n.getCompleteAddress(),e),{...t,wallet:n}}}class Vd{constructor(e,t,n,s){this.pxe=e,this.secretKey=t,this.accountContract=n,this.salt=void 0!==s?new X(s):X.random()}async getPublicKeysHash(){return this.publicKeysHash||(this.publicKeysHash=await(await li(this.secretKey)).publicKeys.hash()),this.publicKeysHash}async getAccount(){const e=await this.pxe.getNodeInfo(),t=await this.getCompleteAddress();return this.accountContract.getInterface(t,e)}async getCompleteAddress(){if(!this.completeAddress){const e=await this.getInstance();this.completeAddress=await di.fromSecretKeyAndInstance(this.secretKey,e)}return this.completeAddress}async getInstance(){return this.instance||(this.instance=await po(this.accountContract.getContractArtifact(),{constructorArgs:await this.accountContract.getDeploymentArgs(),salt:this.salt,publicKeysHash:await this.getPublicKeysHash()})),this.instance}async getWallet(){const e=await this.getAccount();return new Xd(this.pxe,e,this.secretKey,this.salt)}async register(e=Pc){return await this.pxe.registerContract({artifact:this.accountContract.getContractArtifact(),instance:await this.getInstance()}),await this.pxe.registerAccount(this.secretKey,(await this.getCompleteAddress()).partialAddress),await wd(this.pxe,await this.getCompleteAddress(),e),await this.getWallet()}async getDeployMethod(){if(!this.deployMethod){if(!await this.isDeployable())throw new Error(`Account contract ${this.accountContract.getContractArtifact().name} does not require deployment.`);await this.pxe.registerAccount(this.secretKey,(await this.getCompleteAddress()).partialAddress);const{chainId:e,protocolVersion:t}=await this.pxe.getNodeInfo(),n=new Fd(e,t);await n.setAddress();const s=new Jd(this.pxe,n),r=await this.accountContract.getDeploymentArgs()??[];this.deployMethod=new Wd(this.accountContract.getAuthWitnessProvider(await this.getCompleteAddress()),await this.getPublicKeysHash(),s,this.accountContract.getContractArtifact(),r,"constructor","entrypoint")}return this.deployMethod}deploy(e){const t=this.getDeployMethod().then((t=>t.send({contractAddressSalt:this.salt,skipClassRegistration:e?.skipClassRegistration??!0,skipPublicDeployment:e?.skipPublicDeployment??!0,skipInitialization:e?.skipInitialization??!1,universalDeploy:!0,fee:e?.fee,estimateGas:e?.estimateGas}))).then((e=>e.getTxHash()));return new Zd(this.pxe,t,this.getWallet())}async waitSetup(e=Pc){return await this.isDeployable()?await(await this.deploy()).wait(e):await this.register(),await this.getWallet()}async isDeployable(){return void 0!==await this.accountContract.getDeploymentArgs()}}async function Qd(e){const t=new bo,n=await("function"==typeof e?e():e);return[t.ms(),n]}var $d=r(9868);function eu(e){if("string"!=typeof e||e.length<=7||"file://"!==e.substring(0,7))throw new TypeError("must pass in a file:// URI to convert to a file path");const t=decodeURI(e.substring(7)),n=t.indexOf("/");let s=t.substring(0,n),r=t.substring(n+1);return"localhost"===s&&(s=""),s&&(s=$d.sep+$d.sep+s),r=r.replace(/^(.+)\|/,"$1:"),"\\"===$d.sep&&(r=r.replace(/\//g,"\\")),/^.+:/.test(r)||(r=$d.sep+r),s+r}var tu=r(6027);let nu,su=256;function ru(e=11){if(!nu||su+e>512){nu="",su=0;for(let e=0;e<256;e++)nu+=(256+256*Math.random()|0).toString(16).substring(1)}return nu.substring(su,su+++e)}function au(e){const{batch:t,cacheTime:n=e.pollingInterval??4e3,ccipRead:s,key:r="base",name:a="Base Client",pollingInterval:i=4e3,type:o="base"}=e,l=e.chain,c=e.account?(0,tu.J)(e.account):void 0,{config:d,request:u,value:f}=e.transport({chain:l,pollingInterval:i}),h={account:c,batch:t,cacheTime:n,ccipRead:s,chain:l,key:r,name:a,pollingInterval:i,request:u,transport:{...d,...f},type:o,uid:ru()};return Object.assign(h,{extend:function e(t){return n=>{const s=n(t);for(const e in h)delete s[e];const r={...t,...s};return Object.assign(r,{extend:e(r)})}}(h)})}var iu=r(5261);async function ou(e){const t=await e.request({method:"eth_chainId"},{dedupe:!0});return(0,iu.ME)(t)}var lu=r(9042),cu=r(3608),du=r(9302);class uu extends du.C{constructor({docsPath:e}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join("\n"),{docsPath:e,docsSlug:"account",name:"AccountNotFoundError"})}}class fu extends du.C{constructor({docsPath:e,metaMessages:t,type:n}){super(`Account type "${n}" is not supported.`,{docsPath:e,metaMessages:t,name:"AccountTypeNotSupportedError"})}}var hu=r(3887),pu=r(5971),_u=r(2768);function mu(e){if(0===e||1===e)return e;if(27===e)return 0;if(28===e)return 1;throw new Error("Invalid yParityOrV value")}async function gu({hash:e,signature:t}){return function(e){const t=(0,pu.S)(`0x${e.substring(4)}`).substring(26);return(0,hu.o)(`0x${t}`)}(await async function({hash:e,signature:t}){const n=(0,_u.q)(e)?e:(0,lu.nj)(e),{secp256k1:s}=await Promise.resolve().then(r.bind(r,7550));return`0x${(()=>{if("object"==typeof t&&"r"in t&&"s"in t){const{r:e,s:n,v:r,yParity:a}=t,i=mu(Number(a??r));return new s.Signature((0,iu.uU)(e),(0,iu.uU)(n)).addRecoveryBit(i)}const e=(0,_u.q)(t)?t:(0,lu.nj)(t),n=mu((0,iu.ME)(`0x${e.slice(130)}`));return s.Signature.fromCompact(e.substring(2,130)).addRecoveryBit(n)})().recoverPublicKey(n.substring(2)).toHex(!1)}`}({hash:e,signature:t}))}var bu=r(7673),yu=r(3588),vu=r(9804);function wu(e,t="hex"){const n=Au(e),s=(0,vu.l)(new Uint8Array(n.length));return n.encode(s),"hex"===t?(0,lu.My)(s.bytes):s.bytes}function Au(e){return Array.isArray(e)?function(e){const t=e.reduce(((e,t)=>e+t.length),0),n=Eu(t);return{length:t<=55?1+t:1+n+t,encode(s){t<=55?s.pushByte(192+t):(s.pushByte(247+n),1===n?s.pushUint8(t):2===n?s.pushUint16(t):3===n?s.pushUint24(t):s.pushUint32(t));for(const{encode:t}of e)t(s)}}}(e.map((e=>Au(e)))):function(e){const t="string"==typeof e?(0,yu.aT)(e):e,n=Eu(t.length);return{length:1===t.length&&t[0]<128?1:t.length<=55?1+t.length:1+n+t.length,encode(e){1===t.length&&t[0]<128?e.pushBytes(t):t.length<=55?(e.pushByte(128+t.length),e.pushBytes(t)):(e.pushByte(183+n),1===n?e.pushUint8(t.length):2===n?e.pushUint16(t.length):3===n?e.pushUint24(t.length):e.pushUint32(t.length),e.pushBytes(t))}}}(e)}function Eu(e){if(e<256)return 1;if(e<65536)return 2;if(e<2**24)return 3;if(e<2**32)return 4;throw new du.C("Length is too large.")}function xu(e){const{chainId:t,contractAddress:n,nonce:s,to:r}=e,a=(0,pu.S)((0,bu.aP)(["0x05",wu([(0,lu.cK)(t),n,s?(0,lu.cK)(s):"0x"])]));return"bytes"===r?(0,yu.aT)(a):a}async function Su(e){const{authorization:t,signature:n}=e;return gu({hash:xu(t),signature:n??t})}var Tu=r(1893);function ku({chain:e,currentChainId:t}){if(!e)throw new Tu.jF;if(t!==e.id)throw new Tu.EH({chain:e,currentChainId:t})}var Cu=r(7426),zu=r(7740),Pu=r(3594),Fu=r(5979),Nu=r(2545);function Gu(e,t,n){const s=e[t.name];if("function"==typeof s)return s;const r=e[n];return"function"==typeof r?r:n=>t(e,n)}var Lu=r(7338),Ou=r(1892);class Ru extends du.C{constructor(){super("`baseFeeMultiplier` must be greater than 1.",{name:"BaseFeeScalarError"})}}class Mu extends du.C{constructor(){super("Chain does not support EIP-1559 fees.",{name:"Eip1559FeesNotSupportedError"})}}class Bu extends du.C{constructor({maxPriorityFeePerGas:e}){super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${(0,Ou.Q)(e)} gwei).`,{name:"MaxFeePerGasTooLowError"})}}class Yu extends du.C{constructor({blockHash:e,blockNumber:t}){let n="Block";e&&(n=`Block at hash "${e}"`),t&&(n=`Block at number "${t}"`),super(`${n} could not be found.`,{name:"BlockNotFoundError"})}}const ju={"0x0":"legacy","0x1":"eip2930","0x2":"eip1559","0x3":"eip4844","0x4":"eip7702"};function Hu(e){const t={...e,blockHash:e.blockHash?e.blockHash:null,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,chainId:e.chainId?(0,iu.ME)(e.chainId):void 0,gas:e.gas?BigInt(e.gas):void 0,gasPrice:e.gasPrice?BigInt(e.gasPrice):void 0,maxFeePerBlobGas:e.maxFeePerBlobGas?BigInt(e.maxFeePerBlobGas):void 0,maxFeePerGas:e.maxFeePerGas?BigInt(e.maxFeePerGas):void 0,maxPriorityFeePerGas:e.maxPriorityFeePerGas?BigInt(e.maxPriorityFeePerGas):void 0,nonce:e.nonce?(0,iu.ME)(e.nonce):void 0,to:e.to?e.to:null,transactionIndex:e.transactionIndex?Number(e.transactionIndex):null,type:e.type?ju[e.type]:void 0,typeHex:e.type?e.type:void 0,value:e.value?BigInt(e.value):void 0,v:e.v?BigInt(e.v):void 0};return e.authorizationList&&(t.authorizationList=e.authorizationList.map((e=>({contractAddress:e.address,r:e.r,s:e.s,chainId:Number(e.chainId),nonce:Number(e.nonce),...void 0!==e.yParity?{yParity:Number(e.yParity)}:{},...void 0!==e.v&&void 0===e.yParity?{v:Number(e.v)}:{}})))),t.yParity=(()=>{if(e.yParity)return Number(e.yParity);if("bigint"==typeof t.v){if(0n===t.v||27n===t.v)return 0;if(1n===t.v||28n===t.v)return 1;if(t.v>=35n)return t.v%2n===0n?1:0}})(),"legacy"===t.type&&(delete t.accessList,delete t.maxFeePerBlobGas,delete t.maxFeePerGas,delete t.maxPriorityFeePerGas,delete t.yParity),"eip2930"===t.type&&(delete t.maxFeePerBlobGas,delete t.maxFeePerGas,delete t.maxPriorityFeePerGas),"eip1559"===t.type&&delete t.maxFeePerBlobGas,t}function Iu(e){const t=e.transactions?.map((e=>"string"==typeof e?e:Hu(e)));return{...e,baseFeePerGas:e.baseFeePerGas?BigInt(e.baseFeePerGas):null,blobGasUsed:e.blobGasUsed?BigInt(e.blobGasUsed):void 0,difficulty:e.difficulty?BigInt(e.difficulty):void 0,excessBlobGas:e.excessBlobGas?BigInt(e.excessBlobGas):void 0,gasLimit:e.gasLimit?BigInt(e.gasLimit):void 0,gasUsed:e.gasUsed?BigInt(e.gasUsed):void 0,hash:e.hash?e.hash:null,logsBloom:e.logsBloom?e.logsBloom:null,nonce:e.nonce?e.nonce:null,number:e.number?BigInt(e.number):null,size:e.size?BigInt(e.size):void 0,timestamp:e.timestamp?BigInt(e.timestamp):void 0,transactions:t,totalDifficulty:e.totalDifficulty?BigInt(e.totalDifficulty):null}}async function Xu(e,{blockHash:t,blockNumber:n,blockTag:s,includeTransactions:r}={}){const a=s??"latest",i=r??!1,o=void 0!==n?(0,lu.cK)(n):void 0;let l=null;if(l=t?await e.request({method:"eth_getBlockByHash",params:[t,i]},{dedupe:!0}):await e.request({method:"eth_getBlockByNumber",params:[o||a,i]},{dedupe:Boolean(o)}),!l)throw new Yu({blockHash:t,blockNumber:n});return(e.chain?.formatters?.block?.format||Iu)(l)}async function Uu(e){const t=await e.request({method:"eth_gasPrice"});return BigInt(t)}async function Ju(e,t){const{block:n,chain:s=e.chain,request:r}=t||{};try{const t=s?.fees?.maxPriorityFeePerGas??s?.fees?.defaultPriorityFee;if("function"==typeof t){const s=n||await Gu(e,Xu,"getBlock")({}),a=await t({block:s,client:e,request:r});if(null===a)throw new Error;return a}if(void 0!==t)return t;const a=await e.request({method:"eth_maxPriorityFeePerGas"});return(0,iu.uU)(a)}catch{const[t,s]=await Promise.all([n?Promise.resolve(n):Gu(e,Xu,"getBlock")({}),Gu(e,Uu,"getGasPrice")({})]);if("bigint"!=typeof t.baseFeePerGas)throw new Mu;const r=s-t.baseFeePerGas;return r<0n?0n:r}}async function Du(e,t){const{block:n,chain:s=e.chain,request:r,type:a="eip1559"}=t||{},i=await(async()=>"function"==typeof s?.fees?.baseFeeMultiplier?s.fees.baseFeeMultiplier({block:n,client:e,request:r}):s?.fees?.baseFeeMultiplier??1.2)();if(i<1)throw new Ru;const o=10**(i.toString().split(".")[1]?.length??0),l=e=>e*BigInt(Math.ceil(i*o))/BigInt(o),c=n||await Gu(e,Xu,"getBlock")({});if("function"==typeof s?.fees?.estimateFeesPerGas){const t=await s.fees.estimateFeesPerGas({block:n,client:e,multiply:l,request:r,type:a});if(null!==t)return t}if("eip1559"===a){if("bigint"!=typeof c.baseFeePerGas)throw new Mu;const t="bigint"==typeof r?.maxPriorityFeePerGas?r.maxPriorityFeePerGas:await Ju(e,{block:c,chain:s,request:r}),n=l(c.baseFeePerGas);return{maxFeePerGas:r?.maxFeePerGas??n+t,maxPriorityFeePerGas:t}}return{gasPrice:r?.gasPrice??l(await Gu(e,Uu,"getGasPrice")({}))}}var qu=r(3538);class Ku extends du.C{constructor(e,{account:t,docsPath:n,chain:s,data:r,gas:a,gasPrice:i,maxFeePerGas:o,maxPriorityFeePerGas:l,nonce:c,to:d,value:u}){const f=(0,zu.aO)({from:t?.address,to:d,value:void 0!==u&&`${(0,qu.c)(u)} ${s?.nativeCurrency?.symbol||"ETH"}`,data:r,gas:a,gasPrice:void 0!==i&&`${(0,Ou.Q)(i)} gwei`,maxFeePerGas:void 0!==o&&`${(0,Ou.Q)(o)} gwei`,maxPriorityFeePerGas:void 0!==l&&`${(0,Ou.Q)(l)} gwei`,nonce:c});super(e.shortMessage,{cause:e,docsPath:n,metaMessages:[...e.metaMessages?[...e.metaMessages," "]:[],"Estimate Gas Arguments:",f].filter(Boolean),name:"EstimateGasExecutionError"}),Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.cause=e}}var Wu=r(6409);async function Zu(e,{address:t,blockNumber:n,blockTag:s="latest"}){const r=n?(0,lu.cK)(n):void 0,a=await e.request({method:"eth_getBalance",params:[t,r||s]});return BigInt(a)}async function Vu(e,t){const n=t.account??e.account,s=n?(0,tu.J)(n):void 0;try{const{accessList:r,authorizationList:a,blobs:i,blobVersionedHashes:o,blockNumber:l,blockTag:c,data:d,gas:u,gasPrice:f,maxFeePerBlobGas:h,maxFeePerGas:p,maxPriorityFeePerGas:_,nonce:m,value:g,stateOverride:b,...y}=await ff(e,{...t,parameters:"local"===s?.type?void 0:["blobVersionedHashes"]}),v=(l?(0,lu.cK)(l):void 0)||c,w=(0,Wu.yH)(b),A=await(async()=>y.to?y.to:a&&a.length>0?await Su({authorization:a[0]}).catch((()=>{throw new du.C("`to` is required. Could not infer from `authorizationList`")})):void 0)();(0,Lu.c)(t);const E=e.chain?.formatters?.transactionRequest?.format,x=(E||Nu.Bv)({...(0,Fu.o)(y,{format:E}),from:s?.address,accessList:r,authorizationList:a,blobs:i,blobVersionedHashes:o,data:d,gas:u,gasPrice:f,maxFeePerBlobGas:h,maxFeePerGas:p,maxPriorityFeePerGas:_,nonce:m,to:A,value:g});function S(t){const{block:n,request:s,rpcStateOverride:r}=t;return e.request({method:"eth_estimateGas",params:r?[s,n??"latest",r]:n?[s,n]:[s]})}let T=BigInt(await S({block:v,request:x,rpcStateOverride:w}));if(a){const k=await Zu(e,{address:x.from}),C=await Promise.all(a.map((async e=>{const{contractAddress:t}=e,n=await S({block:v,request:{authorizationList:void 0,data:d,from:s?.address,to:t,value:(0,lu.cK)(k)},rpcStateOverride:w}).catch((()=>100000n));return 2n*BigInt(n)})));T+=C.reduce(((e,t)=>e+t),0n)}return T}catch(z){throw function(e,{docsPath:t,...n}){const s=(()=>{const t=(0,Pu.l)(e,n);return t instanceof Cu.RM?e:t})();return new Ku(s,{docsPath:t,...n})}(z,{...t,account:s,chain:e.chain})}}async function Qu(e,{address:t,blockTag:n="latest",blockNumber:s}){const r=await e.request({method:"eth_getTransactionCount",params:[t,s?(0,lu.cK)(s):n]},{dedupe:Boolean(s)});return(0,iu.ME)(r)}function $u(e){const{kzg:t}=e,n=e.to??("string"==typeof e.blobs[0]?"hex":"bytes"),s="string"==typeof e.blobs[0]?e.blobs.map((e=>(0,yu.aT)(e))):e.blobs,r=[];for(const e of s)r.push(Uint8Array.from(t.blobToKzgCommitment(e)));return"bytes"===n?r:r.map((e=>(0,lu.My)(e)))}function ef(e){const{kzg:t}=e,n=e.to??("string"==typeof e.blobs[0]?"hex":"bytes"),s="string"==typeof e.blobs[0]?e.blobs.map((e=>(0,yu.aT)(e))):e.blobs,r="string"==typeof e.commitments[0]?e.commitments.map((e=>(0,yu.aT)(e))):e.commitments,a=[];for(let e=0;e<s.length;e++){const n=s[e],i=r[e];a.push(Uint8Array.from(t.computeBlobKzgProof(n,i)))}return"bytes"===n?a:a.map((e=>(0,lu.My)(e)))}var tf=r(1805);function nf(e){const{commitment:t,version:n=1}=e,s=e.to??("string"==typeof t?"hex":"bytes"),r=function(e){const t=(0,tf.s)((0,_u.q)(e,{strict:!1})?(0,yu.ZJ)(e):e);return t}(t);return r.set([n],0),"bytes"===s?r:(0,lu.My)(r)}const sf=32,rf=4096,af=sf*rf,of=6*af-1-1*rf*6;class lf extends du.C{constructor({maxSize:e,size:t}){super("Blob size is too large.",{metaMessages:[`Max: ${e} bytes`,`Given: ${t} bytes`],name:"BlobSizeTooLargeError"})}}class cf extends du.C{constructor(){super("Blob data must not be empty.",{name:"EmptyBlobError"})}}du.C,du.C;var df=r(6420);const uf=["blobVersionedHashes","chainId","fees","gas","nonce","type"];async function ff(e,t){const{account:n=e.account,blobs:s,chain:r,gas:a,kzg:i,nonce:o,nonceManager:l,parameters:c=uf,type:d}=t,u=n?(0,tu.J)(n):void 0,f={...t,...u?{from:u?.address}:{}};let h,p;async function _(){return h||(h=await Gu(e,Xu,"getBlock")({blockTag:"latest"}),h)}async function m(){if(p)return p;if(r)return r.id;if(void 0!==t.chainId)return t.chainId;const n=await Gu(e,ou,"getChainId")({});return p=n,p}if((c.includes("blobVersionedHashes")||c.includes("sidecars"))&&s&&i){const e=$u({blobs:s,kzg:i});if(c.includes("blobVersionedHashes")){const t=function(e){const{commitments:t,version:n}=e,s=e.to??("string"==typeof t[0]?"hex":"bytes"),r=[];for(const e of t)r.push(nf({commitment:e,to:s,version:n}));return r}({commitments:e,to:"hex"});f.blobVersionedHashes=t}if(c.includes("sidecars")){const t=function(e){const{data:t,kzg:n,to:s}=e,r=e.blobs??function(e){const t=e.to??("string"==typeof e.data?"hex":"bytes"),n="string"==typeof e.data?(0,yu.aT)(e.data):e.data,s=(0,df.E)(n);if(!s)throw new cf;if(s>of)throw new lf({maxSize:of,size:s});const r=[];let a=!0,i=0;for(;a;){const e=(0,vu.l)(new Uint8Array(af));let t=0;for(;t<rf;){const s=n.slice(i,i+(sf-1));if(e.pushByte(0),e.pushBytes(s),s.length<31){e.pushByte(128),a=!1;break}t++,i+=31}r.push(e)}return"bytes"===t?r.map((e=>e.bytes)):r.map((e=>(0,lu.My)(e.bytes)))}({data:t,to:s}),a=e.commitments??$u({blobs:r,kzg:n,to:s}),i=e.proofs??ef({blobs:r,commitments:a,kzg:n,to:s}),o=[];for(let e=0;e<r.length;e++)o.push({blob:r[e],commitment:a[e],proof:i[e]});return o}({blobs:s,commitments:e,proofs:ef({blobs:s,commitments:e,kzg:i}),to:"hex"});f.sidecars=t}}if(c.includes("chainId")&&(f.chainId=await m()),c.includes("nonce")&&void 0===o&&u)if(l){const t=await m();f.nonce=await l.consume({address:u.address,chainId:t,client:e})}else f.nonce=await Gu(e,Qu,"getTransactionCount")({address:u.address,blockTag:"pending"});if((c.includes("fees")||c.includes("type"))&&void 0===d)try{f.type=function(e){if(e.type)return e.type;if(void 0!==e.authorizationList)return"eip7702";if(void 0!==e.blobs||void 0!==e.blobVersionedHashes||void 0!==e.maxFeePerBlobGas||void 0!==e.sidecars)return"eip4844";if(void 0!==e.maxFeePerGas||void 0!==e.maxPriorityFeePerGas)return"eip1559";if(void 0!==e.gasPrice)return void 0!==e.accessList?"eip2930":"legacy";throw new zu.Vg({transaction:e})}(f)}catch{const e=await _();f.type="bigint"==typeof e?.baseFeePerGas?"eip1559":"legacy"}if(c.includes("fees"))if("legacy"!==f.type&&"eip2930"!==f.type){if(void 0===f.maxFeePerGas||void 0===f.maxPriorityFeePerGas){const n=await _(),{maxFeePerGas:s,maxPriorityFeePerGas:a}=await Du(e,{block:n,chain:r,request:f});if(void 0===t.maxPriorityFeePerGas&&t.maxFeePerGas&&t.maxFeePerGas<a)throw new Bu({maxPriorityFeePerGas:a});f.maxPriorityFeePerGas=a,f.maxFeePerGas=s}}else{if(void 0!==t.maxFeePerGas||void 0!==t.maxPriorityFeePerGas)throw new Mu;const n=await _(),{gasPrice:s}=await Du(e,{block:n,chain:r,request:f,type:"legacy"});f.gasPrice=s}return c.includes("gas")&&void 0===a&&(f.gas=await Gu(e,Vu,"estimateGas")({...f,account:u?{address:u.address,type:"json-rpc"}:void 0})),(0,Lu.c)(f),delete f.parameters,f}async function hf(e,{serializedTransaction:t}){return e.request({method:"eth_sendRawTransaction",params:[t]},{retryCount:0})}async function pf(e,t){const{account:n=e.account,chain:s=e.chain,accessList:r,authorizationList:a,blobs:i,data:o,gas:l,gasPrice:c,maxFeePerBlobGas:d,maxFeePerGas:u,maxPriorityFeePerGas:f,nonce:h,value:p,..._}=t;if(!n)throw new uu({docsPath:"/docs/actions/wallet/sendTransaction"});const m=(0,tu.J)(n);try{(0,Lu.c)(t);const n=await(async()=>t.to?t.to:a&&a.length>0?await Su({authorization:a[0]}).catch((()=>{throw new du.C("`to` is required. Could not infer from `authorizationList`.")})):void 0)();if("json-rpc"===m.type){let t;null!==s&&(t=await Gu(e,ou,"getChainId")({}),ku({currentChainId:t,chain:s}));const g=e.chain?.formatters?.transactionRequest?.format,b=(g||Nu.Bv)({...(0,Fu.o)(_,{format:g}),accessList:r,authorizationList:a,blobs:i,chainId:t,data:o,from:m.address,gas:l,gasPrice:c,maxFeePerBlobGas:d,maxFeePerGas:u,maxPriorityFeePerGas:f,nonce:h,to:n,value:p});return await e.request({method:"eth_sendTransaction",params:[b]},{retryCount:0})}if("local"===m.type){const t=await Gu(e,ff,"prepareTransactionRequest")({account:m,accessList:r,authorizationList:a,blobs:i,chain:s,data:o,gas:l,gasPrice:c,maxFeePerBlobGas:d,maxFeePerGas:u,maxPriorityFeePerGas:f,nonce:h,nonceManager:m.nonceManager,parameters:[...uf,"sidecars"],value:p,..._,to:n}),g=s?.serializers?.transaction,b=await m.signTransaction(t,{serializer:g});return await Gu(e,hf,"sendRawTransaction")({serializedTransaction:b})}if("smart"===m.type)throw new fu({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"});throw new fu({docsPath:"/docs/actions/wallet/sendTransaction",type:m.type})}catch(e){if(e instanceof fu)throw e;throw function(e,{docsPath:t,...n}){const s=(()=>{const t=(0,Pu.l)(e,n);return t instanceof Cu.RM?e:t})();return new zu.$s(s,{docsPath:t,...n})}(e,{...t,account:m,chain:t.chain||void 0})}}var _f=r(3686),mf=r(5372),gf=r(7283);const bf=/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,yf=/^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;var vf=r(1501);function wf(e){const{domain:t,message:n,primaryType:s,types:r}=e,a=(e,t)=>{for(const n of e){const{name:e,type:s}=n,i=t[e],o=s.match(yf);if(o&&("number"==typeof i||"bigint"==typeof i)){const[e,t,n]=o;(0,lu.cK)(i,{signed:"int"===t,size:Number.parseInt(n)/8})}if("address"===s&&"string"==typeof i&&!(0,gf.P)(i))throw new mf.M({address:i});const l=s.match(bf);if(l){const[e,t]=l;if(t&&(0,df.E)(i)!==Number.parseInt(t))throw new _f.BI({expectedSize:Number.parseInt(t),givenSize:(0,df.E)(i)})}const c=r[s];c&&a(c,i)}};r.EIP712Domain&&t&&a(r.EIP712Domain,t),"EIP712Domain"!==s&&a(r[s],n)}function Af({domain:e}){return["string"==typeof e?.name&&{name:"name",type:"string"},e?.version&&{name:"version",type:"string"},"number"==typeof e?.chainId&&{name:"chainId",type:"uint256"},e?.verifyingContract&&{name:"verifyingContract",type:"address"},e?.salt&&{name:"salt",type:"bytes32"}].filter(Boolean)}var Ef=r(2373),xf=r(3329),Sf=r(6809);class Tf extends du.C{constructor(e,{code:t,docsPath:n,metaMessages:s,name:r,shortMessage:a}){super(a,{cause:e,docsPath:n,metaMessages:s||e?.metaMessages,name:r||"RpcError"}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name=r||e.name,this.code=e instanceof Sf.J8?e.code:t??-1}}class kf extends Tf{constructor(e,t){super(e,t),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.data=t.data}}class Cf extends Tf{constructor(e){super(e,{code:Cf.code,name:"ParseRpcError",shortMessage:"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."})}}Object.defineProperty(Cf,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32700});class zf extends Tf{constructor(e){super(e,{code:zf.code,name:"InvalidRequestRpcError",shortMessage:"JSON is not a valid request object."})}}Object.defineProperty(zf,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32600});class Pf extends Tf{constructor(e,{method:t}={}){super(e,{code:Pf.code,name:"MethodNotFoundRpcError",shortMessage:`The method${t?` "${t}"`:""} does not exist / is not available.`})}}Object.defineProperty(Pf,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32601});class Ff extends Tf{constructor(e){super(e,{code:Ff.code,name:"InvalidParamsRpcError",shortMessage:["Invalid parameters were provided to the RPC method.","Double check you have provided the correct parameters."].join("\n")})}}Object.defineProperty(Ff,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32602});class Nf extends Tf{constructor(e){super(e,{code:Nf.code,name:"InternalRpcError",shortMessage:"An internal error was received."})}}Object.defineProperty(Nf,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32603});class Gf extends Tf{constructor(e){super(e,{code:Gf.code,name:"InvalidInputRpcError",shortMessage:["Missing or invalid parameters.","Double check you have provided the correct parameters."].join("\n")})}}Object.defineProperty(Gf,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32e3});class Lf extends Tf{constructor(e){super(e,{code:Lf.code,name:"ResourceNotFoundRpcError",shortMessage:"Requested resource not found."}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ResourceNotFoundRpcError"})}}Object.defineProperty(Lf,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32001});class Of extends Tf{constructor(e){super(e,{code:Of.code,name:"ResourceUnavailableRpcError",shortMessage:"Requested resource not available."})}}Object.defineProperty(Of,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32002});class Rf extends Tf{constructor(e){super(e,{code:Rf.code,name:"TransactionRejectedRpcError",shortMessage:"Transaction creation failed."})}}Object.defineProperty(Rf,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32003});class Mf extends Tf{constructor(e,{method:t}={}){super(e,{code:Mf.code,name:"MethodNotSupportedRpcError",shortMessage:`Method${t?` "${t}"`:""} is not implemented.`})}}Object.defineProperty(Mf,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32004});class Bf extends Tf{constructor(e){super(e,{code:Bf.code,name:"LimitExceededRpcError",shortMessage:"Request exceeds defined limit."})}}Object.defineProperty(Bf,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32005});class Yf extends Tf{constructor(e){super(e,{code:Yf.code,name:"JsonRpcVersionUnsupportedError",shortMessage:"Version of JSON-RPC protocol is not supported."})}}Object.defineProperty(Yf,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32006});class jf extends kf{constructor(e){super(e,{code:jf.code,name:"UserRejectedRequestError",shortMessage:"User rejected the request."})}}Object.defineProperty(jf,"code",{enumerable:!0,configurable:!0,writable:!0,value:4001});class Hf extends kf{constructor(e){super(e,{code:Hf.code,name:"UnauthorizedProviderError",shortMessage:"The requested method and/or account has not been authorized by the user."})}}Object.defineProperty(Hf,"code",{enumerable:!0,configurable:!0,writable:!0,value:4100});class If extends kf{constructor(e,{method:t}={}){super(e,{code:If.code,name:"UnsupportedProviderMethodError",shortMessage:`The Provider does not support the requested method${t?` " ${t}"`:""}.`})}}Object.defineProperty(If,"code",{enumerable:!0,configurable:!0,writable:!0,value:4200});class Xf extends kf{constructor(e){super(e,{code:Xf.code,name:"ProviderDisconnectedError",shortMessage:"The Provider is disconnected from all chains."})}}Object.defineProperty(Xf,"code",{enumerable:!0,configurable:!0,writable:!0,value:4900});class Uf extends kf{constructor(e){super(e,{code:Uf.code,name:"ChainDisconnectedError",shortMessage:"The Provider is not connected to the requested chain."})}}Object.defineProperty(Uf,"code",{enumerable:!0,configurable:!0,writable:!0,value:4901});class Jf extends kf{constructor(e){super(e,{code:Jf.code,name:"SwitchChainError",shortMessage:"An error occurred when attempting to switch chain."})}}Object.defineProperty(Jf,"code",{enumerable:!0,configurable:!0,writable:!0,value:4902});class Df extends Tf{constructor(e){super(e,{name:"UnknownRpcError",shortMessage:"An unknown RPC error occurred."})}}const qf=3;function Kf(e,{abi:t,address:n,args:s,docsPath:r,functionName:a,sender:i}){const{code:o,data:l,message:c,shortMessage:d}=e instanceof xf.$S?e:e instanceof du.C?e.walk((e=>"data"in e))||e.walk():{},u=e instanceof _f.O?new xf.rR({functionName:a}):[qf,Nf.code].includes(o)&&(l||c||d)?new xf.M({abi:t,data:"object"==typeof l?l.data:l,functionName:a,message:d??c}):e;return new xf.bG(u,{abi:t,args:s,contractAddress:n,docsPath:r,functionName:a,sender:i})}async function Wf(e,t){const{abi:n,account:s=e.account,address:r,args:a,dataSuffix:i,functionName:o,...l}=t;if(!s)throw new uu({docsPath:"/docs/contract/writeContract"});const c=(0,tu.J)(s),d=(0,Ef.p)({abi:n,args:a,functionName:o});try{return await Gu(e,pf,"sendTransaction")({data:`${d}${i?i.replace("0x",""):""}`,to:r,account:c,...l})}catch(e){throw Kf(e,{abi:n,address:r,args:a,docsPath:"/docs/contract/writeContract",functionName:o,sender:c.address})}}function Zf(e){return{addChain:t=>async function(e,{chain:t}){const{id:n,name:s,nativeCurrency:r,rpcUrls:a,blockExplorers:i}=t;await e.request({method:"wallet_addEthereumChain",params:[{chainId:(0,lu.cK)(n),chainName:s,nativeCurrency:r,rpcUrls:a.default.http,blockExplorerUrls:i?Object.values(i).map((({url:e})=>e)):void 0}]},{dedupe:!0,retryCount:0})}(e,t),deployContract:t=>function(e,t){const{abi:n,args:s,bytecode:r,...a}=t;return pf(e,{...a,data:(0,cu.m)({abi:n,args:s,bytecode:r})})}(e,t),getAddresses:()=>async function(e){return"local"===e.account?.type?[e.account.address]:(await e.request({method:"eth_accounts"},{dedupe:!0})).map((e=>(0,hu.o)(e)))}(e),getChainId:()=>ou(e),getPermissions:()=>async function(e){return await e.request({method:"wallet_getPermissions"},{dedupe:!0})}(e),prepareTransactionRequest:t=>ff(e,t),requestAddresses:()=>async function(e){return(await e.request({method:"eth_requestAccounts"},{dedupe:!0,retryCount:0})).map((e=>(0,hu.b)(e)))}(e),requestPermissions:t=>async function(e,t){return e.request({method:"wallet_requestPermissions",params:[t]},{retryCount:0})}(e,t),sendRawTransaction:t=>hf(e,t),sendTransaction:t=>pf(e,t),signMessage:t=>async function(e,{account:t=e.account,message:n}){if(!t)throw new uu({docsPath:"/docs/actions/wallet/signMessage"});const s=(0,tu.J)(t);if(s.signMessage)return s.signMessage({message:n});const r="string"==typeof n?(0,lu.i3)(n):n.raw instanceof Uint8Array?(0,lu.nj)(n.raw):n.raw;return e.request({method:"personal_sign",params:[r,s.address]},{retryCount:0})}(e,t),signTransaction:t=>async function(e,t){const{account:n=e.account,chain:s=e.chain,...r}=t;if(!n)throw new uu({docsPath:"/docs/actions/wallet/signTransaction"});const a=(0,tu.J)(n);(0,Lu.c)({account:a,...t});const i=await Gu(e,ou,"getChainId")({});null!==s&&ku({currentChainId:i,chain:s});const o=s?.formatters||e.chain?.formatters,l=o?.transactionRequest?.format||Nu.Bv;return a.signTransaction?a.signTransaction({...r,chainId:i},{serializer:e.chain?.serializers?.transaction}):await e.request({method:"eth_signTransaction",params:[{...l(r),chainId:(0,lu.cK)(i),from:a.address}]},{retryCount:0})}(e,t),signTypedData:t=>async function(e,t){const{account:n=e.account,domain:s,message:r,primaryType:a}=t;if(!n)throw new uu({docsPath:"/docs/actions/wallet/signTypedData"});const i=(0,tu.J)(n),o={EIP712Domain:Af({domain:s}),...t.types};if(wf({domain:s,message:r,primaryType:a,types:o}),i.signTypedData)return i.signTypedData({domain:s,message:r,primaryType:a,types:o});const l=function(e){const{domain:t,message:n,primaryType:s,types:r}=e,a=(e,t)=>{const n={...t};for(const t of e){const{name:e,type:s}=t;"address"===s&&(n[e]=n[e].toLowerCase())}return n},i=r.EIP712Domain&&t?a(r.EIP712Domain,t):{},o=(()=>{if("EIP712Domain"!==s)return a(r[s],n)})();return(0,vf.A)({domain:i,message:o,primaryType:s,types:r})}({domain:s,message:r,primaryType:a,types:o});return e.request({method:"eth_signTypedData_v4",params:[i.address,l]},{retryCount:0})}(e,t),switchChain:t=>async function(e,{id:t}){await e.request({method:"wallet_switchEthereumChain",params:[{chainId:(0,lu.cK)(t)}]},{retryCount:0})}(e,t),watchAsset:t=>async function(e,t){return await e.request({method:"wallet_watchAsset",params:t},{retryCount:0})}(e,t),writeContract:t=>Wf(e,t)}}class Vf extends du.C{constructor(){super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.",{docsPath:"/docs/clients/intro",name:"UrlRequiredError"})}}var Qf=r(3513);function $f(){return{current:0,take(){return this.current++},reset(){this.current=0}}}const eh=$f();const th=new(r(645).A)(8192);async function nh(e){return new Promise((t=>setTimeout(t,e)))}function sh(e,{delay:t=100,retryCount:n=2,shouldRetry:s=()=>!0}={}){return new Promise(((r,a)=>{const i=async({count:o=0}={})=>{try{const t=await e();r(t)}catch(e){if(o<n&&await s({count:o,error:e}))return(async({error:e})=>{const n="function"==typeof t?t({count:o,error:e}):t;n&&await nh(n),i({count:o+1})})({error:e});a(e)}};i()}))}function rh(e,t={}){return async(n,s={})=>{const{dedupe:r=!1,retryDelay:a=150,retryCount:i=3,uid:o}={...t,...s};return function(e,{enabled:t=!0,id:n}){if(!t||!n)return e();if(th.get(n))return th.get(n);const s=e().finally((()=>th.delete(n)));return th.set(n,s),s}((()=>sh((async()=>{try{return await e(n)}catch(e){const t=e;switch(t.code){case Cf.code:throw new Cf(t);case zf.code:throw new zf(t);case Pf.code:throw new Pf(t,{method:n.method});case Ff.code:throw new Ff(t);case Nf.code:throw new Nf(t);case Gf.code:throw new Gf(t);case Lf.code:throw new Lf(t);case Of.code:throw new Of(t);case Rf.code:throw new Rf(t);case Mf.code:throw new Mf(t,{method:n.method});case Bf.code:throw new Bf(t);case Yf.code:throw new Yf(t);case jf.code:throw new jf(t);case Hf.code:throw new Hf(t);case If.code:throw new If(t);case Xf.code:throw new Xf(t);case Uf.code:throw new Uf(t);case Jf.code:throw new Jf(t);case 5e3:throw new jf(t);default:if(e instanceof du.C)throw e;throw new Df(t)}}}),{delay:({count:e,error:t})=>{if(t&&t instanceof Sf.Ci){const e=t?.headers?.get("Retry-After");if(e?.match(/\d/))return 1e3*Number.parseInt(e)}return(1<<e)*a},retryCount:i,shouldRetry:({error:e})=>function(e){return"code"in e&&"number"==typeof e.code?-1===e.code||e.code===Bf.code||e.code===Nf.code:!(e instanceof Sf.Ci&&e.status)||(403===e.status||408===e.status||413===e.status||429===e.status||500===e.status||502===e.status||503===e.status||504===e.status)}(e)})),{enabled:r,id:r?(0,pu.S)((0,lu.i3)(`${o}.${(0,vf.A)(n)}`)):void 0})}}function ah(e,t={}){const{batch:n,fetchOptions:s,key:r="http",name:a="HTTP JSON-RPC",onFetchRequest:i,onFetchResponse:o,retryDelay:l}=t;return({chain:c,retryCount:d,timeout:u})=>{const{batchSize:f=1e3,wait:h=0}="object"==typeof n?n:{},p=t.retryCount??d,_=u??t.timeout??1e4,m=e||c?.rpcUrls.default.http[0];if(!m)throw new Vf;const g=function(e,t={}){return{async request(n){const{body:s,onRequest:r=t.onRequest,onResponse:a=t.onResponse,timeout:i=t.timeout??1e4}=n,o={...t.fetchOptions??{},...n.fetchOptions??{}},{headers:l,method:c,signal:d}=o;try{const t=await function(e,{errorInstance:t=new Error("timed out"),timeout:n,signal:s}){return new Promise(((r,a)=>{(async()=>{let i;try{const o=new AbortController;n>0&&(i=setTimeout((()=>{s?o.abort():a(t)}),n)),r(await e({signal:o?.signal||null}))}catch(e){"AbortError"===e?.name&&a(t),a(e)}finally{clearTimeout(i)}})()}))}((async({signal:t})=>{const n={...o,body:Array.isArray(s)?(0,vf.A)(s.map((e=>({jsonrpc:"2.0",id:e.id??eh.take(),...e})))):(0,vf.A)({jsonrpc:"2.0",id:s.id??eh.take(),...s}),headers:{"Content-Type":"application/json",...l},method:c||"POST",signal:d||(i>0?t:null)},a=new Request(e,n);return r&&await r(a),await fetch(e,n)}),{errorInstance:new Sf.MU({body:s,url:e}),timeout:i,signal:!0});let n;if(a&&await a(t),t.headers.get("Content-Type")?.startsWith("application/json"))n=await t.json();else{n=await t.text();try{n=JSON.parse(n||"{}")}catch(e){if(t.ok)throw e;n={error:n}}}if(!t.ok)throw new Sf.Ci({body:s,details:(0,vf.A)(n.error)||t.statusText,headers:t.headers,status:t.status,url:e});return n}catch(t){if(t instanceof Sf.Ci)throw t;if(t instanceof Sf.MU)throw t;throw new Sf.Ci({body:s,cause:t,url:e})}}}}(m,{fetchOptions:s,onRequest:i,onResponse:o,timeout:_});return function({key:e,name:t,request:n,retryCount:s=3,retryDelay:r=150,timeout:a,type:i},o){return{config:{key:e,name:t,request:n,retryCount:s,retryDelay:r,timeout:a,type:i},request:rh(n,{retryCount:s,retryDelay:r,uid:ru()}),value:o}}({key:r,name:a,async request({method:e,params:t}){const s={method:e,params:t},{schedule:r}=(0,Qf.u)({id:m,wait:h,shouldSplitBatch:e=>e.length>f,fn:e=>g.request({body:e}),sort:(e,t)=>e.id-t.id}),[{error:a,result:i}]=await(async e=>n?r(e):[await g.request({body:e})])(s);if(a)throw new Sf.J8({body:s,error:a,url:m});return i},retryCount:p,retryDelay:l,timeout:_,type:"http"},{fetchOptions:s,url:m})}}var ih=r(4153),oh=r(8902),lh=r(2987),ch=r(1577),dh=r(1919);function uh(e,t){if(!(e instanceof du.C))return!1;const n=e.walk((e=>e instanceof xf.M));return n instanceof xf.M&&("ResolverNotFound"===n.data?.errorName||"ResolverWildcardNotSupported"===n.data?.errorName||"ResolverNotContract"===n.data?.errorName||"ResolverError"===n.data?.errorName||"HttpError"===n.data?.errorName||!!n.reason?.includes("Wildcard on non-extended resolvers is not supported")||"reverse"===t&&n.reason===dh.fD[50])}function fh(e){if(66!==e.length)return null;if(0!==e.indexOf("["))return null;if(65!==e.indexOf("]"))return null;const t=`0x${e.slice(1,65)}`;return(0,_u.q)(t)?t:null}function hh(e){let t=new Uint8Array(32).fill(0);if(!e)return(0,lu.My)(t);const n=e.split(".");for(let e=n.length-1;e>=0;e-=1){const s=fh(n[e]),r=s?(0,yu.ZJ)(s):(0,pu.S)((0,yu.Af)(n[e]),"bytes");t=(0,pu.S)((0,bu.xW)([t,r]),"bytes")}return(0,lu.My)(t)}function ph(e){return`[${e.slice(2)}]`}function _h(e){const t=new Uint8Array(32).fill(0);return e?fh(e)||(0,pu.S)((0,yu.Af)(e)):(0,lu.My)(t)}function mh(e){const t=e.replace(/^\.|\.$/gm,"");if(0===t.length)return new Uint8Array(1);const n=new Uint8Array((0,yu.Af)(t).byteLength+2);let s=0;const r=t.split(".");for(let e=0;e<r.length;e++){let t=(0,yu.Af)(r[e]);t.byteLength>255&&(t=(0,yu.Af)(ph(_h(r[e])))),n[s]=t.length,n.set(t,s+1),s+=t.length+1}return n.byteLength!==s+1?n.slice(0,s+1):n}var gh=r(9047);async function bh(e,t){const{abi:n,address:s,args:r,functionName:a,...i}=t,o=(0,Ef.p)({abi:n,args:r,functionName:a});try{const{data:t}=await Gu(e,gh.T,"call")({...i,data:o,to:s});return(0,oh.e)({abi:n,args:r,functionName:a,data:t||"0x"})}catch(e){throw Kf(e,{abi:n,address:s,args:r,docsPath:"/docs/contract/readContract",functionName:a})}}class yh extends du.C{constructor({data:e}){super("Unable to extract image from metadata. The metadata may be malformed or invalid.",{metaMessages:["- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.","",`Provided data: ${JSON.stringify(e)}`],name:"EnsAvatarInvalidMetadataError"})}}class vh extends du.C{constructor({reason:e}){super(`ENS NFT avatar URI is invalid. ${e}`,{name:"EnsAvatarInvalidNftUriError"})}}class wh extends du.C{constructor({uri:e}){super(`Unable to resolve ENS avatar URI "${e}". The URI may be malformed, invalid, or does not respond with a valid image.`,{name:"EnsAvatarUriResolutionError"})}}class Ah extends du.C{constructor({namespace:e}){super(`ENS NFT avatar namespace "${e}" is not supported. Must be "erc721" or "erc1155".`,{name:"EnsAvatarUnsupportedNamespaceError"})}}const Eh=/(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/,xh=/^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/,Sh=/^data:([a-zA-Z\-/+]*);base64,([^"].*)/,Th=/^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;function kh(e,t){return e?e.endsWith("/")?e.slice(0,-1):e:t}function Ch({uri:e,gatewayUrls:t}){const n=Sh.test(e);if(n)return{uri:e,isOnChain:!0,isEncoded:n};const s=kh(t?.ipfs,"https://ipfs.io"),r=kh(t?.arweave,"https://arweave.net"),a=e.match(Eh),{protocol:i,subpath:o,target:l,subtarget:c=""}=a?.groups||{},d="ipns:/"===i||"ipns/"===o,u="ipfs:/"===i||"ipfs/"===o||xh.test(e);if(e.startsWith("http")&&!d&&!u){let n=e;return t?.arweave&&(n=e.replace(/https:\/\/arweave.net/g,t?.arweave)),{uri:n,isOnChain:!1,isEncoded:!1}}if((d||u)&&l)return{uri:`${s}/${d?"ipns":"ipfs"}/${l}${c}`,isOnChain:!1,isEncoded:!1};if("ar:/"===i&&l)return{uri:`${r}/${l}${c||""}`,isOnChain:!1,isEncoded:!1};let f=e.replace(Th,"");if(f.startsWith("<svg")&&(f=`data:image/svg+xml;base64,${btoa(f)}`),f.startsWith("data:")||f.startsWith("{"))return{uri:f,isOnChain:!0,isEncoded:!1};throw new wh({uri:e})}function zh(e){if("object"!=typeof e||!("image"in e)&&!("image_url"in e)&&!("image_data"in e))throw new yh({data:e});return e.image||e.image_url||e.image_data}async function Ph({gatewayUrls:e,uri:t}){const{uri:n,isOnChain:s}=Ch({uri:t,gatewayUrls:e});if(s)return n;const r=await async function(e){try{const t=await fetch(e,{method:"HEAD"});if(200===t.status){const e=t.headers.get("content-type");return e?.startsWith("image/")}return!1}catch(t){return("object"!=typeof t||void 0===t.response)&&!!globalThis.hasOwnProperty("Image")&&new Promise((t=>{const n=new Image;n.onload=()=>{t(!0)},n.onerror=()=>{t(!1)},n.src=e}))}}(n);if(r)return n;throw new wh({uri:t})}async function Fh(e,{blockNumber:t,blockTag:n,name:s,key:r,gatewayUrls:a,strict:i,universalResolverAddress:o}){let l=o;if(!l){if(!e.chain)throw new Error("client chain not configured. universalResolverAddress is required.");l=(0,lh.M)({blockNumber:t,chain:e.chain,contract:"ensUniversalResolver"})}try{const i={address:l,abi:ih.Ag,functionName:"resolve",args:[(0,lu.nj)(mh(s)),(0,Ef.p)({abi:ih.SJ,functionName:"text",args:[hh(s),r]})],blockNumber:t,blockTag:n},o=Gu(e,bh,"readContract"),c=a?await o({...i,args:[...i.args,a]}):await o(i);if("0x"===c[0])return null;const d=(0,oh.e)({abi:ih.SJ,functionName:"text",data:c[0]});return""===d?null:d}catch(e){if(i)throw e;if(uh(e,"resolve"))return null;throw e}}function Nh(e,{method:t}){const n={};return"fallback"===e.transport.type&&e.transport.onResponse?.((({method:e,response:s,status:r,transport:a})=>{"success"===r&&t===e&&(n[s]=a.request)})),t=>n[t]||e.request}class Gh extends du.C{constructor(e){super(`Filter type "${e}" is not supported.`,{name:"FilterTypeNotSupportedError"})}}var Lh=r(643),Oh=r(2729),Rh=r(113),Mh=r(3856);const Bh="/docs/contract/encodeEventTopics";function Yh(e){const{abi:t,eventName:n,args:s}=e;let r=t[0];if(n){const e=(0,Mh.iY)({abi:t,name:n});if(!e)throw new _f.M_(n,{docsPath:Bh});r=e}if("event"!==r.type)throw new _f.M_(void 0,{docsPath:Bh});const a=(0,Rh.B)(r),i=(0,Lh.h)(a);let o=[];if(s&&"inputs"in r){const e=r.inputs?.filter((e=>"indexed"in e&&e.indexed)),t=Array.isArray(s)?s:Object.values(s).length>0?e?.map((e=>s[e.name]))??[]:[];t.length>0&&(o=e?.map(((e,n)=>Array.isArray(t[n])?t[n].map(((s,r)=>jh({param:e,value:t[n][r]}))):t[n]?jh({param:e,value:t[n]}):null))??[])}return[i,...o]}function jh({param:e,value:t}){if("string"===e.type||"bytes"===e.type)return(0,pu.S)((0,yu.ZJ)(t));if("tuple"===e.type||e.type.match(/^(.*)\[(\d+)?\]$/))throw new Gh(e.type);return(0,Oh.h)([e],[t])}async function Hh(e,t){const{address:n,abi:s,args:r,eventName:a,fromBlock:i,strict:o,toBlock:l}=t,c=Nh(e,{method:"eth_newFilter"}),d=a?Yh({abi:s,args:r,eventName:a}):void 0,u=await e.request({method:"eth_newFilter",params:[{address:n,fromBlock:"bigint"==typeof i?(0,lu.cK)(i):i,toBlock:"bigint"==typeof l?(0,lu.cK)(l):l,topics:d}]});return{abi:s,args:r,eventName:a,id:u,request:c(u),strict:Boolean(o),type:"event"}}async function Ih(e,{address:t,args:n,event:s,events:r,fromBlock:a,strict:i,toBlock:o}={}){const l=r??(s?[s]:void 0),c=Nh(e,{method:"eth_newFilter"});let d=[];if(l){const e=l.flatMap((e=>Yh({abi:[e],eventName:e.name,args:n})));d=[e],s&&(d=d[0])}const u=await e.request({method:"eth_newFilter",params:[{address:t,fromBlock:"bigint"==typeof a?(0,lu.cK)(a):a,toBlock:"bigint"==typeof o?(0,lu.cK)(o):o,...d.length?{topics:d}:{}}]});return{abi:l,args:n,eventName:s?s.name:void 0,fromBlock:a,id:u,request:c(u),strict:Boolean(i),toBlock:o,type:"event"}}async function Xh(e){const t=Nh(e,{method:"eth_newPendingTransactionFilter"}),n=await e.request({method:"eth_newPendingTransactionFilter"});return{id:n,request:t(n),type:"transaction"}}async function Uh(e,t){const{abi:n,address:s,args:r,functionName:a,...i}=t,o=(0,Ef.p)({abi:n,args:r,functionName:a});try{return await Gu(e,Vu,"estimateGas")({data:o,to:s,...i})}catch(e){const t=i.account?(0,tu.J)(i.account):void 0;throw Kf(e,{abi:n,address:s,args:r,docsPath:"/docs/contract/estimateContractGas",functionName:a,sender:t?.address})}}const Jh=new Map,Dh=new Map;async function qh(e,{cacheTime:t=e.cacheTime}={}){const n=await async function(e,{cacheKey:t,cacheTime:n=Number.POSITIVE_INFINITY}){const s=function(e){const t=(e,t)=>({clear:()=>t.delete(e),get:()=>t.get(e),set:n=>t.set(e,n)}),n=t(e,Jh),s=t(e,Dh);return{clear:()=>{n.clear(),s.clear()},promise:n,response:s}}(t),r=s.response.get();if(r&&n>0&&(new Date).getTime()-r.created.getTime()<n)return r.data;let a=s.promise.get();a||(a=e(),s.promise.set(a));try{const e=await a;return s.response.set({created:new Date,data:e}),e}finally{s.promise.clear()}}((()=>e.request({method:"eth_blockNumber"})),{cacheKey:(s=e.uid,`blockNumber.${s}`),cacheTime:t});var s;return BigInt(n)}async function Kh(e,{address:t,blockNumber:n,blockTag:s="latest"}){const r=void 0!==n?(0,lu.cK)(n):void 0,a=await e.request({method:"eth_getCode",params:[t,r||s]},{dedupe:Boolean(r)});if("0x"!==a)return a}var Wh=r(6907),Zh=r(4112),Vh=r(9359);const Qh="/docs/contract/decodeEventLog";function $h(e){const{abi:t,data:n,strict:s,topics:r}=e,a=s??!0,[i,...o]=r;if(!i)throw new _f._z({docsPath:Qh});const l=1===t.length?t[0]:t.find((e=>"event"===e.type&&i===(0,Lh.h)((0,Rh.B)(e))));if(!l||!("name"in l)||"event"!==l.type)throw new _f.kE(i,{docsPath:Qh});const{name:c,inputs:d}=l,u=d?.some((e=>!("name"in e&&e.name)));let f=u?[]:{};const h=d.filter((e=>"indexed"in e&&e.indexed));for(let e=0;e<h.length;e++){const t=h[e],n=o[e];if(!n)throw new _f.l3({abiItem:l,param:t});f[u?e:t.name||e]=ep({param:t,value:n})}const p=d.filter((e=>!("indexed"in e&&e.indexed)));if(p.length>0)if(n&&"0x"!==n)try{const e=(0,Vh.n)(p,n);if(e)if(u)f=[...f,...e];else for(let t=0;t<p.length;t++)f[p[t].name]=e[t]}catch(e){if(a){if(e instanceof _f.Iy||e instanceof Zh.SK)throw new _f.fo({abiItem:l,data:n,params:p,size:(0,df.E)(n)});throw e}}else if(a)throw new _f.fo({abiItem:l,data:"0x",params:p,size:0});return{eventName:c,args:Object.values(f).length>0?f:void 0}}function ep({param:e,value:t}){return"string"===e.type||"bytes"===e.type||"tuple"===e.type||e.type.match(/^(.*)\[(\d+)?\]$/)?t:((0,Vh.n)([e],t)||[])[0]}function tp(e){const{abi:t,args:n,logs:s,strict:r=!0}=e,a=(()=>{if(e.eventName)return Array.isArray(e.eventName)?e.eventName:[e.eventName]})();return s.map((e=>{try{const s=t.find((t=>"event"===t.type&&e.topics[0]===(0,Lh.h)(t)));if(!s)return null;const i=$h({...e,abi:[s],strict:r});return a&&!a.includes(i.eventName)?null:function(e){const{args:t,inputs:n,matchArgs:s}=e;if(!s)return!0;if(!t)return!1;function r(e,t,n){try{return"address"===e.type?(0,Wh.h)(t,n):"string"===e.type||"bytes"===e.type?(0,pu.S)((0,yu.ZJ)(t))===n:t===n}catch{return!1}}return Array.isArray(t)&&Array.isArray(s)?s.every(((e,s)=>{if(null===e)return!0;const a=n[s];return!!a&&(Array.isArray(e)?e:[e]).some((e=>r(a,e,t[s])))})):"object"==typeof t&&!Array.isArray(t)&&"object"==typeof s&&!Array.isArray(s)&&Object.entries(s).every((([e,s])=>{if(null===s)return!0;const a=n.find((t=>t.name===e));return!!a&&(Array.isArray(s)?s:[s]).some((n=>r(a,n,t[e])))}))}({args:i.args,inputs:s.inputs,matchArgs:n})?{...i,...e}:null}catch(t){let n,s;if(t instanceof _f.kE)return null;if(t instanceof _f.fo||t instanceof _f.l3){if(r)return null;n=t.abiItem.name,s=t.abiItem.inputs?.some((e=>!("name"in e&&e.name)))}return{...e,args:s?[]:{},eventName:n}}})).filter(Boolean)}function np(e,{args:t,eventName:n}={}){return{...e,blockHash:e.blockHash?e.blockHash:null,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,logIndex:e.logIndex?Number(e.logIndex):null,transactionHash:e.transactionHash?e.transactionHash:null,transactionIndex:e.transactionIndex?Number(e.transactionIndex):null,...n?{args:t,eventName:n}:{}}}async function sp(e,{address:t,blockHash:n,fromBlock:s,toBlock:r,event:a,events:i,args:o,strict:l}={}){const c=l??!1,d=i??(a?[a]:void 0);let u,f=[];if(d){const e=d.flatMap((e=>Yh({abi:[e],eventName:e.name,args:i?void 0:o})));f=[e],a&&(f=f[0])}u=n?await e.request({method:"eth_getLogs",params:[{address:t,topics:f,blockHash:n}]}):await e.request({method:"eth_getLogs",params:[{address:t,topics:f,fromBlock:"bigint"==typeof s?(0,lu.cK)(s):s,toBlock:"bigint"==typeof r?(0,lu.cK)(r):r}]});const h=u.map((e=>np(e)));return d?tp({abi:d,args:o,logs:h,strict:c}):h}async function rp(e,t){const{abi:n,address:s,args:r,blockHash:a,eventName:i,fromBlock:o,toBlock:l,strict:c}=t,d=i?(0,Mh.iY)({abi:n,name:i}):void 0,u=d?void 0:n.filter((e=>"event"===e.type));return Gu(e,sp,"getLogs")({address:s,args:r,blockHash:a,event:d,events:u,fromBlock:o,toBlock:l,strict:c})}class ap extends du.C{constructor({address:e}){super(`No EIP-712 domain found on contract "${e}".`,{metaMessages:["Ensure that:",`- The contract is deployed at the address "${e}".`,"- `eip712Domain()` function exists on the contract.","- `eip712Domain()` function matches signature to ERC-5267 specification."],name:"Eip712DomainNotFoundError"})}}const ip=[{inputs:[],name:"eip712Domain",outputs:[{name:"fields",type:"bytes1"},{name:"name",type:"string"},{name:"version",type:"string"},{name:"chainId",type:"uint256"},{name:"verifyingContract",type:"address"},{name:"salt",type:"bytes32"},{name:"extensions",type:"uint256[]"}],stateMutability:"view",type:"function"}];async function op(e,{filter:t}){const n="strict"in t&&t.strict,s=await t.request({method:"eth_getFilterChanges",params:[t.id]});if("string"==typeof s[0])return s;const r=s.map((e=>np(e)));return"abi"in t&&t.abi?tp({abi:t.abi,logs:r,strict:n}):r}async function lp(e,{blockHash:t,blockNumber:n,blockTag:s,hash:r,index:a}){const i=s||"latest",o=void 0!==n?(0,lu.cK)(n):void 0;let l=null;if(r?l=await e.request({method:"eth_getTransactionByHash",params:[r]},{dedupe:!0}):t?l=await e.request({method:"eth_getTransactionByBlockHashAndIndex",params:[t,(0,lu.cK)(a)]},{dedupe:!0}):(o||i)&&(l=await e.request({method:"eth_getTransactionByBlockNumberAndIndex",params:[o||i,(0,lu.cK)(a)]},{dedupe:Boolean(o)})),!l)throw new zu.Kz({blockHash:t,blockNumber:n,blockTag:i,hash:r,index:a});return(e.chain?.formatters?.transaction?.format||Hu)(l)}const cp={"0x0":"reverted","0x1":"success"};function dp(e){const t={...e,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,contractAddress:e.contractAddress?e.contractAddress:null,cumulativeGasUsed:e.cumulativeGasUsed?BigInt(e.cumulativeGasUsed):null,effectiveGasPrice:e.effectiveGasPrice?BigInt(e.effectiveGasPrice):null,gasUsed:e.gasUsed?BigInt(e.gasUsed):null,logs:e.logs?e.logs.map((e=>np(e))):null,to:e.to?e.to:null,transactionIndex:e.transactionIndex?(0,iu.ME)(e.transactionIndex):null,status:e.status?cp[e.status]:null,type:e.type?ju[e.type]||e.type:null};return e.blobGasPrice&&(t.blobGasPrice=BigInt(e.blobGasPrice)),e.blobGasUsed&&(t.blobGasUsed=BigInt(e.blobGasUsed)),t}async function up(e,{hash:t}){const n=await e.request({method:"eth_getTransactionReceipt",params:[t]},{dedupe:!0});if(!n)throw new zu.Kc({hash:t});return(e.chain?.formatters?.transactionReceipt?.format||dp)(n)}async function fp(e,t){const{abi:n,address:s,args:r,dataSuffix:a,functionName:i,...o}=t,l=o.account?(0,tu.J)(o.account):e.account,c=(0,Ef.p)({abi:n,args:r,functionName:i});try{const{data:d}=await Gu(e,gh.T,"call")({batch:!1,data:`${c}${a?a.replace("0x",""):""}`,to:s,...o,account:l});return{result:(0,oh.e)({abi:n,args:r,functionName:i,data:d||"0x"}),request:{abi:n.filter((e=>"name"in e&&e.name===t.functionName)),address:s,args:r,dataSuffix:a,functionName:i,...o,account:l}}}catch(e){throw Kf(e,{abi:n,address:s,args:r,docsPath:"/docs/contract/simulateContract",functionName:i,sender:l?.address})}}async function hp(e,{filter:t}){return t.request({method:"eth_uninstallFilter",params:[t.id]})}function pp(e,t){return(0,pu.S)(function(e){const t="string"==typeof e?(0,lu.i3)(e):"string"==typeof e.raw?e.raw:(0,lu.My)(e.raw),n=(0,lu.i3)(`Ethereum Signed Message:\n${(0,df.E)(t)}`);return(0,bu.xW)([n,t])}(e),t)}var _p=r(9655),mp=r(4144);const gp="0x6492649264926492649264926492649264926492649264926492649264926492";var bp=r(5355),yp=r(7550);async function vp(e,t){const{address:n,factory:s,factoryData:r,hash:a,signature:i,...o}=t,l=(0,_u.q)(i)?i:"object"==typeof i&&"r"in i&&"s"in i?function({r:e,s:t,to:n="hex",v:s,yParity:r}){const a=(()=>{if(0===r||1===r)return r;if(s&&(27n===s||28n===s||s>=35n))return s%2n===0n?1:0;throw new Error("Invalid `v` or `yParity` value")})(),i=`0x${new yp.secp256k1.Signature((0,iu.uU)(e),(0,iu.uU)(t)).toCompactHex()}${0===a?"1b":"1c"}`;return"hex"===n?i:(0,yu.aT)(i)}(i):(0,lu.My)(i),c=await(async()=>s||r?function(e){return(0,bp.iN)(e,-32)===gp}(l)?l:function(e){const{address:t,data:n,signature:s,to:r="hex"}=e,a=(0,bu.aP)([(0,Oh.h)([{type:"address"},{type:"bytes"},{type:"bytes"}],[t,n,s]),gp]);return"hex"===r?a:(0,yu.aT)(a)}({address:s,data:r,signature:l}):l)();try{const{data:t}=await Gu(e,gh.T,"call")({data:(0,cu.m)({abi:ih._,args:[n,a,c],bytecode:_p.nP}),...o});return function(e,t){const n=(0,_u.q)(e)?(0,yu.ZJ)(e):e,s=(0,_u.q)(t)?(0,yu.ZJ)(t):t;return(0,mp.ex)(n,s)}(t??"0x0","0x1")}catch(e){try{if((0,Wh.h)((0,hu.b)(n),await gu({hash:a,signature:i})))return!0}catch{}if(e instanceof xf.zX)return!1;throw e}}function wp(e){const{domain:t={},message:n,primaryType:s}=e,r={EIP712Domain:Af({domain:t}),...e.types};wf({domain:t,message:n,primaryType:s,types:r});const a=["0x1901"];return t&&a.push(function({domain:e,types:t}){return Ap({data:e,primaryType:"EIP712Domain",types:t})}({domain:t,types:r})),"EIP712Domain"!==s&&a.push(Ap({data:n,primaryType:s,types:r})),(0,pu.S)((0,bu.xW)(a))}function Ap({data:e,primaryType:t,types:n}){const s=Ep({data:e,primaryType:t,types:n});return(0,pu.S)(s)}function Ep({data:e,primaryType:t,types:n}){const s=[{type:"bytes32"}],r=[xp({primaryType:t,types:n})];for(const a of n[t]){const[t,i]=Tp({types:n,name:a.name,type:a.type,value:e[a.name]});s.push(t),r.push(i)}return(0,Oh.h)(s,r)}function xp({primaryType:e,types:t}){const n=(0,lu.nj)(function({primaryType:e,types:t}){let n="";const s=Sp({primaryType:e,types:t});s.delete(e);const r=[e,...Array.from(s).sort()];for(const e of r)n+=`${e}(${t[e].map((({name:e,type:t})=>`${t} ${e}`)).join(",")})`;return n}({primaryType:e,types:t}));return(0,pu.S)(n)}function Sp({primaryType:e,types:t},n=new Set){const s=e.match(/^\w*/u),r=s?.[0];if(n.has(r)||void 0===t[r])return n;n.add(r);for(const e of t[r])Sp({primaryType:e.type,types:t},n);return n}function Tp({types:e,name:t,type:n,value:s}){if(void 0!==e[n])return[{type:"bytes32"},(0,pu.S)(Ep({data:s,primaryType:n,types:e}))];if("bytes"===n)return s="0x"+((s.length%2?"0":"")+s.slice(2)),[{type:"bytes32"},(0,pu.S)(s)];if("string"===n)return[{type:"bytes32"},(0,pu.S)((0,lu.nj)(s))];if(n.lastIndexOf("]")===n.length-1){const r=n.slice(0,n.lastIndexOf("[")),a=s.map((n=>Tp({name:t,type:r,types:e,value:n})));return[{type:"bytes32"},(0,pu.S)((0,Oh.h)(a.map((([e])=>e)),a.map((([,e])=>e))))]}return[{type:n},s]}const kp=new Map,Cp=new Map;let zp=0;function Pp(e,t,n){const s=++zp,r=()=>kp.get(e)||[],a=()=>{const t=Cp.get(e);1===r().length&&t&&t(),(()=>{const t=r();kp.set(e,t.filter((e=>e.id!==s)))})()},i=r();if(kp.set(e,[...i,{id:s,fns:t}]),i&&i.length>0)return a;const o={};for(const e in t)o[e]=(...t)=>{const n=r();if(0!==n.length)for(const s of n)s.fns[e]?.(...t)};const l=n(o);return"function"==typeof l&&Cp.set(e,l),a}function Fp(e,{emitOnBegin:t,initialWaitTime:n,interval:s}){let r=!0;const a=()=>r=!1;return(async()=>{let i;t&&(i=await e({unpoll:a}));const o=await(n?.(i))??s;await nh(o);const l=async()=>{r&&(await e({unpoll:a}),await nh(s),l())};l()})(),a}function Np(e,{emitOnBegin:t=!1,emitMissed:n=!1,onBlockNumber:s,onError:r,poll:a,pollingInterval:i=e.pollingInterval}){let o;return(void 0!==a?!a:"webSocket"===e.transport.type||"fallback"===e.transport.type&&"webSocket"===e.transport.transports[0].config.type)?Pp((0,vf.A)(["watchBlockNumber",e.uid,t,n]),{onBlockNumber:s,onError:r},(t=>{let n=!0,s=()=>n=!1;return(async()=>{try{const r=(()=>{if("fallback"===e.transport.type){const t=e.transport.transports.find((e=>"webSocket"===e.config.type));return t?t.value:e.transport}return e.transport})(),{unsubscribe:a}=await r.subscribe({params:["newHeads"],onData(e){if(!n)return;const s=(0,iu.uU)(e.result?.number);t.onBlockNumber(s,o),o=s},onError(e){t.onError?.(e)}});s=a,n||s()}catch(e){r?.(e)}})(),()=>s()})):Pp((0,vf.A)(["watchBlockNumber",e.uid,t,n,i]),{onBlockNumber:s,onError:r},(s=>Fp((async()=>{try{const t=await Gu(e,qh,"getBlockNumber")({cacheTime:0});if(o){if(t===o)return;if(t-o>1&&n)for(let e=o+1n;e<t;e++)s.onBlockNumber(e,o),o=e}(!o||t>o)&&(s.onBlockNumber(t,o),o=t)}catch(e){s.onError?.(e)}}),{emitOnBegin:t,interval:i})))}function Gp(e,t){const{abi:n,address:s,args:r,batch:a=!0,eventName:i,fromBlock:o,onError:l,onLogs:c,poll:d,pollingInterval:u=e.pollingInterval,strict:f}=t;return(void 0!==d?d:"bigint"==typeof o||"webSocket"!==e.transport.type&&("fallback"!==e.transport.type||"webSocket"!==e.transport.transports[0].config.type))?(()=>{const t=f??!1;return Pp((0,vf.A)(["watchContractEvent",s,r,a,e.uid,i,u,t,o]),{onLogs:c,onError:l},(l=>{let c,d;void 0!==o&&(c=o-1n);let f=!1;const h=Fp((async()=>{if(f)try{let o;if(d)o=await Gu(e,op,"getFilterChanges")({filter:d});else{const a=await Gu(e,qh,"getBlockNumber")({});o=c&&c<a?await Gu(e,rp,"getContractEvents")({abi:n,address:s,args:r,eventName:i,fromBlock:c+1n,toBlock:a,strict:t}):[],c=a}if(0===o.length)return;if(a)l.onLogs(o);else for(const e of o)l.onLogs([e])}catch(e){d&&e instanceof Gf&&(f=!1),l.onError?.(e)}else{try{d=await Gu(e,Hh,"createContractEventFilter")({abi:n,address:s,args:r,eventName:i,strict:t,fromBlock:o})}catch{}f=!0}}),{emitOnBegin:!0,interval:u});return async()=>{d&&await Gu(e,hp,"uninstallFilter")({filter:d}),h()}}))})():(()=>{const t=f??!1,o=(0,vf.A)(["watchContractEvent",s,r,a,e.uid,i,u,t]);let d=!0,h=()=>d=!1;return Pp(o,{onLogs:c,onError:l},(t=>((async()=>{try{const a=(()=>{if("fallback"===e.transport.type){const t=e.transport.transports.find((e=>"webSocket"===e.config.type));return t?t.value:e.transport}return e.transport})(),o=i?Yh({abi:n,eventName:i,args:r}):[],{unsubscribe:l}=await a.subscribe({params:["logs",{address:s,topics:o}],onData(e){if(!d)return;const s=e.result;try{const{eventName:e,args:r}=$h({abi:n,data:s.data,topics:s.topics,strict:f}),a=np(s,{args:r,eventName:e});t.onLogs([a])}catch(e){let n,r;if(e instanceof _f.fo||e instanceof _f.l3){if(f)return;n=e.abiItem.name,r=e.abiItem.inputs?.some((e=>!("name"in e&&e.name)))}const a=np(s,{args:r?[]:{},eventName:n});t.onLogs([a])}},onError(e){t.onError?.(e)}});h=l,d||h()}catch(e){l?.(e)}})(),()=>h())))})()}const Lp=/^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/,Op=/(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;function Rp(e){return{call:t=>(0,gh.T)(e,t),createBlockFilter:()=>async function(e){const t=Nh(e,{method:"eth_newBlockFilter"}),n=await e.request({method:"eth_newBlockFilter"});return{id:n,request:t(n),type:"block"}}(e),createContractEventFilter:t=>Hh(e,t),createEventFilter:t=>Ih(e,t),createPendingTransactionFilter:()=>Xh(e),estimateContractGas:t=>Uh(e,t),estimateGas:t=>Vu(e,t),getBalance:t=>Zu(e,t),getBlobBaseFee:()=>async function(e){const t=await e.request({method:"eth_blobBaseFee"});return BigInt(t)}(e),getBlock:t=>Xu(e,t),getBlockNumber:t=>qh(e,t),getBlockTransactionCount:t=>async function(e,{blockHash:t,blockNumber:n,blockTag:s="latest"}={}){const r=void 0!==n?(0,lu.cK)(n):void 0;let a;return a=t?await e.request({method:"eth_getBlockTransactionCountByHash",params:[t]},{dedupe:!0}):await e.request({method:"eth_getBlockTransactionCountByNumber",params:[r||s]},{dedupe:Boolean(r)}),(0,iu.ME)(a)}(e,t),getBytecode:t=>Kh(e,t),getChainId:()=>ou(e),getCode:t=>Kh(e,t),getContractEvents:t=>rp(e,t),getEip712Domain:t=>async function(e,t){const{address:n,factory:s,factoryData:r}=t;try{const[t,a,i,o,l,c,d]=await Gu(e,bh,"readContract")({abi:ip,address:n,functionName:"eip712Domain",factory:s,factoryData:r});return{domain:{name:a,version:i,chainId:Number(o),verifyingContract:l,salt:c},extensions:d,fields:t}}catch(e){const t=e;if("ContractFunctionExecutionError"===t.name&&"ContractFunctionZeroDataError"===t.cause.name)throw new ap({address:n});throw t}}(e,t),getEnsAddress:t=>async function(e,{blockNumber:t,blockTag:n,coinType:s,name:r,gatewayUrls:a,strict:i,universalResolverAddress:o}){let l=o;if(!l){if(!e.chain)throw new Error("client chain not configured. universalResolverAddress is required.");l=(0,lh.M)({blockNumber:t,chain:e.chain,contract:"ensUniversalResolver"})}try{const i=(0,Ef.p)({abi:ih.Rm,functionName:"addr",...null!=s?{args:[hh(r),BigInt(s)]}:{args:[hh(r)]}}),o={address:l,abi:ih.Ag,functionName:"resolve",args:[(0,lu.nj)(mh(r)),i],blockNumber:t,blockTag:n},c=Gu(e,bh,"readContract"),d=a?await c({...o,args:[...o.args,a]}):await c(o);if("0x"===d[0])return null;const u=(0,oh.e)({abi:ih.Rm,args:null!=s?[hh(r),BigInt(s)]:void 0,functionName:"addr",data:d[0]});return"0x"===u||"0x00"===(0,ch.B)(u)?null:u}catch(e){if(i)throw e;if(uh(e,"resolve"))return null;throw e}}(e,t),getEnsAvatar:t=>async function(e,{blockNumber:t,blockTag:n,assetGatewayUrls:s,name:r,gatewayUrls:a,strict:i,universalResolverAddress:o}){const l=await Gu(e,Fh,"getEnsText")({blockNumber:t,blockTag:n,key:"avatar",name:r,universalResolverAddress:o,gatewayUrls:a,strict:i});if(!l)return null;try{return await async function(e,{gatewayUrls:t,record:n}){return/eip155:/i.test(n)?async function(e,{gatewayUrls:t,record:n}){const s=function(e){let t=e;t.startsWith("did:nft:")&&(t=t.replace("did:nft:","").replace(/_/g,"/"));const[n,s,r]=t.split("/"),[a,i]=n.split(":"),[o,l]=s.split(":");if(!a||"eip155"!==a.toLowerCase())throw new vh({reason:"Only EIP-155 supported"});if(!i)throw new vh({reason:"Chain ID not found"});if(!l)throw new vh({reason:"Contract address not found"});if(!r)throw new vh({reason:"Token ID not found"});if(!o)throw new vh({reason:"ERC namespace not found"});return{chainID:Number.parseInt(i),namespace:o.toLowerCase(),contractAddress:l,tokenID:r}}(n),r=await async function(e,{nft:t}){if("erc721"===t.namespace)return bh(e,{address:t.contractAddress,abi:[{name:"tokenURI",type:"function",stateMutability:"view",inputs:[{name:"tokenId",type:"uint256"}],outputs:[{name:"",type:"string"}]}],functionName:"tokenURI",args:[BigInt(t.tokenID)]});if("erc1155"===t.namespace)return bh(e,{address:t.contractAddress,abi:[{name:"uri",type:"function",stateMutability:"view",inputs:[{name:"_id",type:"uint256"}],outputs:[{name:"",type:"string"}]}],functionName:"uri",args:[BigInt(t.tokenID)]});throw new Ah({namespace:t.namespace})}(e,{nft:s}),{uri:a,isOnChain:i,isEncoded:o}=Ch({uri:r,gatewayUrls:t});if(i&&(a.includes("data:application/json;base64,")||a.startsWith("{"))){const e=o?atob(a.replace("data:application/json;base64,","")):a;return Ph({uri:zh(JSON.parse(e)),gatewayUrls:t})}let l=s.tokenID;return"erc1155"===s.namespace&&(l=l.replace("0x","").padStart(64,"0")),async function({gatewayUrls:e,uri:t}){try{const n=await fetch(t).then((e=>e.json()));return await Ph({gatewayUrls:e,uri:zh(n)})}catch{throw new wh({uri:t})}}({gatewayUrls:t,uri:a.replace(/(?:0x)?{id}/,l)})}(e,{gatewayUrls:t,record:n}):Ph({uri:n,gatewayUrls:t})}(e,{record:l,gatewayUrls:s})}catch{return null}}(e,t),getEnsName:t=>async function(e,{address:t,blockNumber:n,blockTag:s,gatewayUrls:r,strict:a,universalResolverAddress:i}){let o=i;if(!o){if(!e.chain)throw new Error("client chain not configured. universalResolverAddress is required.");o=(0,lh.M)({blockNumber:n,chain:e.chain,contract:"ensUniversalResolver"})}const l=`${t.toLowerCase().substring(2)}.addr.reverse`;try{const a={address:o,abi:ih.oX,functionName:"reverse",args:[(0,lu.nj)(mh(l))],blockNumber:n,blockTag:s},i=Gu(e,bh,"readContract"),[c,d]=r?await i({...a,args:[...a.args,r]}):await i(a);return t.toLowerCase()!==d.toLowerCase()?null:c}catch(e){if(a)throw e;if(uh(e,"reverse"))return null;throw e}}(e,t),getEnsResolver:t=>async function(e,{blockNumber:t,blockTag:n,name:s,universalResolverAddress:r}){let a=r;if(!a){if(!e.chain)throw new Error("client chain not configured. universalResolverAddress is required.");a=(0,lh.M)({blockNumber:t,chain:e.chain,contract:"ensUniversalResolver"})}const[i]=await Gu(e,bh,"readContract")({address:a,abi:[{inputs:[{type:"bytes"}],name:"findResolver",outputs:[{type:"address"},{type:"bytes32"}],stateMutability:"view",type:"function"}],functionName:"findResolver",args:[(0,lu.nj)(mh(s))],blockNumber:t,blockTag:n});return i}(e,t),getEnsText:t=>Fh(e,t),getFeeHistory:t=>async function(e,{blockCount:t,blockNumber:n,blockTag:s="latest",rewardPercentiles:r}){const a=n?(0,lu.cK)(n):void 0;return{baseFeePerGas:(i=await e.request({method:"eth_feeHistory",params:[(0,lu.cK)(t),a||s,r]},{dedupe:Boolean(a)})).baseFeePerGas.map((e=>BigInt(e))),gasUsedRatio:i.gasUsedRatio,oldestBlock:BigInt(i.oldestBlock),reward:i.reward?.map((e=>e.map((e=>BigInt(e)))))};var i}(e,t),estimateFeesPerGas:t=>async function(e,t){return Du(e,t)}(e,t),getFilterChanges:e=>op(0,e),getFilterLogs:e=>async function(e,{filter:t}){const n=t.strict??!1,s=(await t.request({method:"eth_getFilterLogs",params:[t.id]})).map((e=>np(e)));return t.abi?tp({abi:t.abi,logs:s,strict:n}):s}(0,e),getGasPrice:()=>Uu(e),getLogs:t=>sp(e,t),getProof:t=>async function(e,{address:t,blockNumber:n,blockTag:s,storageKeys:r}){const a=s??"latest",i=void 0!==n?(0,lu.cK)(n):void 0;return o=await e.request({method:"eth_getProof",params:[t,r,i||a]}),{...o,balance:o.balance?BigInt(o.balance):void 0,nonce:o.nonce?(0,iu.ME)(o.nonce):void 0,storageProof:o.storageProof?(l=o.storageProof,l.map((e=>({...e,value:BigInt(e.value)})))):void 0};var o,l}(e,t),estimateMaxPriorityFeePerGas:t=>async function(e,t){return Ju(e,t)}(e,t),getStorageAt:t=>async function(e,{address:t,blockNumber:n,blockTag:s="latest",slot:r}){const a=void 0!==n?(0,lu.cK)(n):void 0;return await e.request({method:"eth_getStorageAt",params:[t,r,a||s]})}(e,t),getTransaction:t=>lp(e,t),getTransactionConfirmations:t=>async function(e,{hash:t,transactionReceipt:n}){const[s,r]=await Promise.all([Gu(e,qh,"getBlockNumber")({}),t?Gu(e,lp,"getTransaction")({hash:t}):void 0]),a=n?.blockNumber||r?.blockNumber;return a?s-a+1n:0n}(e,t),getTransactionCount:t=>Qu(e,t),getTransactionReceipt:t=>up(e,t),multicall:t=>async function(e,t){const{allowFailure:n=!0,batchSize:s,blockNumber:r,blockTag:a,multicallAddress:i,stateOverride:o}=t,l=t.contracts,c=s??("object"==typeof e.batch?.multicall&&e.batch.multicall.batchSize||1024);let d=i;if(!d){if(!e.chain)throw new Error("client chain not configured. multicallAddress is required.");d=(0,lh.M)({blockNumber:r,chain:e.chain,contract:"multicall3"})}const u=[[]];let f=0,h=0;for(let e=0;e<l.length;e++){const{abi:t,address:s,args:r,functionName:a}=l[e];try{const e=(0,Ef.p)({abi:t,args:r,functionName:a});h+=(e.length-2)/2,c>0&&h>c&&u[f].length>0&&(f++,h=(e.length-2)/2,u[f]=[]),u[f]=[...u[f],{allowFailure:!0,callData:e,target:s}]}catch(e){const i=Kf(e,{abi:t,address:s,args:r,docsPath:"/docs/contract/multicall",functionName:a});if(!n)throw i;u[f]=[...u[f],{allowFailure:!0,callData:"0x",target:s}]}}const p=await Promise.allSettled(u.map((t=>Gu(e,bh,"readContract")({abi:ih.v2,address:d,args:[t],blockNumber:r,blockTag:a,functionName:"aggregate3",stateOverride:o})))),_=[];for(let e=0;e<p.length;e++){const t=p[e];if("rejected"===t.status){if(!n)throw t.reason;for(let n=0;n<u[e].length;n++)_.push({status:"failure",error:t.reason,result:void 0});continue}const s=t.value;for(let t=0;t<s.length;t++){const{returnData:r,success:a}=s[t],{callData:i}=u[e][t],{abi:o,address:c,functionName:d,args:f}=l[_.length];try{if("0x"===i)throw new _f.O;if(!a)throw new xf.$S({data:r});const e=(0,oh.e)({abi:o,args:f,data:r,functionName:d});_.push(n?{result:e,status:"success"}:e)}catch(e){const t=Kf(e,{abi:o,address:c,args:f,docsPath:"/docs/contract/multicall",functionName:d});if(!n)throw t;_.push({error:t,result:void 0,status:"failure"})}}}if(_.length!==l.length)throw new du.C("multicall results mismatch");return _}(e,t),prepareTransactionRequest:t=>ff(e,t),readContract:t=>bh(e,t),sendRawTransaction:t=>hf(e,t),simulateContract:t=>fp(e,t),verifyMessage:t=>async function(e,{address:t,message:n,factory:s,factoryData:r,signature:a,...i}){return vp(e,{address:t,factory:s,factoryData:r,hash:pp(n),signature:a,...i})}(e,t),verifySiweMessage:t=>async function(e,t){const{address:n,domain:s,message:r,nonce:a,scheme:i,signature:o,time:l=new Date,...c}=t,d=function(e){const{scheme:t,statement:n,...s}=e.match(Lp)?.groups??{},{chainId:r,expirationTime:a,issuedAt:i,notBefore:o,requestId:l,...c}=e.match(Op)?.groups??{},d=e.split("Resources:")[1]?.split("\n- ").slice(1);return{...s,...c,...r?{chainId:Number(r)}:{},...a?{expirationTime:new Date(a)}:{},...i?{issuedAt:new Date(i)}:{},...o?{notBefore:new Date(o)}:{},...l?{requestId:l}:{},...d?{resources:d}:{},...t?{scheme:t}:{},...n?{statement:n}:{}}}(r);if(!d.address)return!1;const u=function(e){const{address:t,domain:n,message:s,nonce:r,scheme:a,time:i=new Date}=e;if(n&&s.domain!==n)return!1;if(r&&s.nonce!==r)return!1;if(a&&s.scheme!==a)return!1;if(s.expirationTime&&i>=s.expirationTime)return!1;if(s.notBefore&&i<s.notBefore)return!1;try{if(!s.address)return!1;if(t&&!(0,Wh.h)(s.address,t))return!1}catch{return!1}return!0}({address:n,domain:s,message:d,nonce:a,scheme:i,time:l});if(!u)return!1;const f=pp(r);return vp(e,{address:d.address,hash:f,signature:o,...c})}(e,t),verifyTypedData:t=>async function(e,t){const{address:n,factory:s,factoryData:r,signature:a,message:i,primaryType:o,types:l,domain:c,...d}=t;return vp(e,{address:n,factory:s,factoryData:r,hash:wp({message:i,primaryType:o,types:l,domain:c}),signature:a,...d})}(e,t),uninstallFilter:e=>hp(0,e),waitForTransactionReceipt:t=>async function(e,{confirmations:t=1,hash:n,onReplaced:s,pollingInterval:r=e.pollingInterval,retryCount:a=6,retryDelay:i=({count:e})=>200*(1<<e),timeout:o=18e4}){const l=(0,vf.A)(["waitForTransactionReceipt",e.uid,n]);let c,d,u,f=!1;return new Promise(((h,p)=>{o&&setTimeout((()=>p(new zu.WA({hash:n}))),o);const _=Pp(l,{onReplaced:s,resolve:h,reject:p},(s=>{const o=Gu(e,Np,"watchBlockNumber")({emitMissed:!0,emitOnBegin:!0,poll:!0,pollingInterval:r,async onBlockNumber(r){const l=e=>{o(),e(),_()};let h=r;if(!f)try{if(u){if(t>1&&(!u.blockNumber||h-u.blockNumber+1n<t))return;return void l((()=>s.resolve(u)))}if(c||(f=!0,await sh((async()=>{c=await Gu(e,lp,"getTransaction")({hash:n}),c.blockNumber&&(h=c.blockNumber)}),{delay:i,retryCount:a}),f=!1),u=await Gu(e,up,"getTransactionReceipt")({hash:n}),t>1&&(!u.blockNumber||h-u.blockNumber+1n<t))return;l((()=>s.resolve(u)))}catch(n){if(n instanceof zu.Kz||n instanceof zu.Kc){if(!c)return void(f=!1);try{d=c,f=!0;const n=await sh((()=>Gu(e,Xu,"getBlock")({blockNumber:h,includeTransactions:!0})),{delay:i,retryCount:a,shouldRetry:({error:e})=>e instanceof Yu});f=!1;const r=n.transactions.find((({from:e,nonce:t})=>e===d.from&&t===d.nonce));if(!r)return;if(u=await Gu(e,up,"getTransactionReceipt")({hash:r.hash}),t>1&&(!u.blockNumber||h-u.blockNumber+1n<t))return;let o="replaced";r.to===d.to&&r.value===d.value?o="repriced":r.from===r.to&&0n===r.value&&(o="cancelled"),l((()=>{s.onReplaced?.({reason:o,replacedTransaction:d,transaction:r,transactionReceipt:u}),s.resolve(u)}))}catch(e){l((()=>s.reject(e)))}}else l((()=>s.reject(n)))}}})}))}))}(e,t),watchBlocks:t=>function(e,{blockTag:t="latest",emitMissed:n=!1,emitOnBegin:s=!1,onBlock:r,onError:a,includeTransactions:i,poll:o,pollingInterval:l=e.pollingInterval}){const c=void 0!==o?o:"webSocket"!==e.transport.type&&("fallback"!==e.transport.type||"webSocket"!==e.transport.transports[0].config.type),d=i??!1;let u;return c?Pp((0,vf.A)(["watchBlocks",e.uid,t,n,s,d,l]),{onBlock:r,onError:a},(r=>Fp((async()=>{try{const s=await Gu(e,Xu,"getBlock")({blockTag:t,includeTransactions:d});if(s.number&&u?.number){if(s.number===u.number)return;if(s.number-u.number>1&&n)for(let t=u?.number+1n;t<s.number;t++){const n=await Gu(e,Xu,"getBlock")({blockNumber:t,includeTransactions:d});r.onBlock(n,u),u=n}}(!u?.number||"pending"===t&&!s?.number||s.number&&s.number>u.number)&&(r.onBlock(s,u),u=s)}catch(e){r.onError?.(e)}}),{emitOnBegin:s,interval:l}))):(()=>{let n=!0,i=!0,o=()=>n=!1;return(async()=>{try{s&&Gu(e,Xu,"getBlock")({blockTag:t,includeTransactions:d}).then((e=>{n&&i&&(r(e,void 0),i=!1)}));const l=(()=>{if("fallback"===e.transport.type){const t=e.transport.transports.find((e=>"webSocket"===e.config.type));return t?t.value:e.transport}return e.transport})(),{unsubscribe:c}=await l.subscribe({params:["newHeads"],onData(t){if(!n)return;const s=(e.chain?.formatters?.block?.format||Iu)(t.result);r(s,u),i=!1,u=s},onError(e){a?.(e)}});o=c,n||o()}catch(e){a?.(e)}})(),()=>o()})()}(e,t),watchBlockNumber:t=>Np(e,t),watchContractEvent:t=>Gp(e,t),watchEvent:t=>function(e,{address:t,args:n,batch:s=!0,event:r,events:a,fromBlock:i,onError:o,onLogs:l,poll:c,pollingInterval:d=e.pollingInterval,strict:u}){const f=void 0!==c?c:"bigint"==typeof i||"webSocket"!==e.transport.type&&("fallback"!==e.transport.type||"webSocket"!==e.transport.transports[0].config.type),h=u??!1;return f?Pp((0,vf.A)(["watchEvent",t,n,s,e.uid,r,d,i]),{onLogs:l,onError:o},(o=>{let l,c;void 0!==i&&(l=i-1n);let u=!1;const f=Fp((async()=>{if(u)try{let i;if(c)i=await Gu(e,op,"getFilterChanges")({filter:c});else{const s=await Gu(e,qh,"getBlockNumber")({});i=l&&l!==s?await Gu(e,sp,"getLogs")({address:t,args:n,event:r,events:a,fromBlock:l+1n,toBlock:s}):[],l=s}if(0===i.length)return;if(s)o.onLogs(i);else for(const e of i)o.onLogs([e])}catch(e){c&&e instanceof Gf&&(u=!1),o.onError?.(e)}else{try{c=await Gu(e,Ih,"createEventFilter")({address:t,args:n,event:r,events:a,strict:h,fromBlock:i})}catch{}u=!0}}),{emitOnBegin:!0,interval:d});return async()=>{c&&await Gu(e,hp,"uninstallFilter")({filter:c}),f()}})):(()=>{let s=!0,i=()=>s=!1;return(async()=>{try{const c=(()=>{if("fallback"===e.transport.type){const t=e.transport.transports.find((e=>"webSocket"===e.config.type));return t?t.value:e.transport}return e.transport})(),d=a??(r?[r]:void 0);let f=[];if(d){const e=d.flatMap((e=>Yh({abi:[e],eventName:e.name,args:n})));f=[e],r&&(f=f[0])}const{unsubscribe:p}=await c.subscribe({params:["logs",{address:t,topics:f}],onData(e){if(!s)return;const t=e.result;try{const{eventName:e,args:n}=$h({abi:d??[],data:t.data,topics:t.topics,strict:h}),s=np(t,{args:n,eventName:e});l([s])}catch(e){let n,s;if(e instanceof _f.fo||e instanceof _f.l3){if(u)return;n=e.abiItem.name,s=e.abiItem.inputs?.some((e=>!("name"in e&&e.name)))}const r=np(t,{args:s?[]:{},eventName:n});l([r])}},onError(e){o?.(e)}});i=p,s||i()}catch(e){o?.(e)}})(),()=>i()})()}(e,t),watchPendingTransactions:t=>function(e,{batch:t=!0,onError:n,onTransactions:s,poll:r,pollingInterval:a=e.pollingInterval}){return(void 0!==r?r:"webSocket"!==e.transport.type)?Pp((0,vf.A)(["watchPendingTransactions",e.uid,t,a]),{onTransactions:s,onError:n},(n=>{let s;const r=Fp((async()=>{try{if(!s)try{return void(s=await Gu(e,Xh,"createPendingTransactionFilter")({}))}catch(e){throw r(),e}const a=await Gu(e,op,"getFilterChanges")({filter:s});if(0===a.length)return;if(t)n.onTransactions(a);else for(const e of a)n.onTransactions([e])}catch(e){n.onError?.(e)}}),{emitOnBegin:!0,interval:a});return async()=>{s&&await Gu(e,hp,"uninstallFilter")({filter:s}),r()}})):(()=>{let t=!0,r=()=>t=!1;return(async()=>{try{const{unsubscribe:a}=await e.transport.subscribe({params:["newPendingTransactions"],onData(e){if(!t)return;const n=e.result;s([n])},onError(e){n?.(e)}});r=a,t||r()}catch(e){n?.(e)}})(),()=>r()})()}(e,t)}}function Mp({abi:e,address:t,client:n}){const s=n,[r,a]=s?"public"in s&&"wallet"in s?[s.public,s.wallet]:"public"in s?[s.public,void 0]:"wallet"in s?[void 0,s.wallet]:[s,s]:[void 0,void 0],i=null!=r,o=null!=a,l={};let c=!1,d=!1,u=!1;for(const t of e)if("function"===t.type?"view"===t.stateMutability||"pure"===t.stateMutability?c=!0:d=!0:"event"===t.type&&(u=!0),c&&d&&u)break;return i&&(c&&(l.read=new Proxy({},{get:(n,s)=>(...n)=>{const{args:a,options:i}=Bp(n);return Gu(r,bh,"readContract")({abi:e,address:t,functionName:s,args:a,...i})}})),d&&(l.simulate=new Proxy({},{get:(n,s)=>(...n)=>{const{args:a,options:i}=Bp(n);return Gu(r,fp,"simulateContract")({abi:e,address:t,functionName:s,args:a,...i})}})),u&&(l.createEventFilter=new Proxy({},{get:(n,s)=>(...n)=>{const a=e.find((e=>"event"===e.type&&e.name===s)),{args:i,options:o}=Yp(n,a);return Gu(r,Hh,"createContractEventFilter")({abi:e,address:t,eventName:s,args:i,...o})}}),l.getEvents=new Proxy({},{get:(n,s)=>(...n)=>{const a=e.find((e=>"event"===e.type&&e.name===s)),{args:i,options:o}=Yp(n,a);return Gu(r,rp,"getContractEvents")({abi:e,address:t,eventName:s,args:i,...o})}}),l.watchEvent=new Proxy({},{get:(n,s)=>(...n)=>{const a=e.find((e=>"event"===e.type&&e.name===s)),{args:i,options:o}=Yp(n,a);return Gu(r,Gp,"watchContractEvent")({abi:e,address:t,eventName:s,args:i,...o})}}))),o&&d&&(l.write=new Proxy({},{get:(n,s)=>(...n)=>{const{args:r,options:i}=Bp(n);return Gu(a,Wf,"writeContract")({abi:e,address:t,functionName:s,args:r,...i})}})),(i||o)&&d&&(l.estimateGas=new Proxy({},{get:(n,s)=>(...n)=>{const{args:i,options:o}=Bp(n);return Gu(r??a,Uh,"estimateContractGas")({abi:e,address:t,functionName:s,args:i,...o,account:o.account??a.account})}})),l.address=t,l.abi=e,l}function Bp(e){const t=e.length&&Array.isArray(e[0]);return{args:t?e[0]:[],options:(t?e[1]:e[0])??{}}}function Yp(e,t){let n=!1;return Array.isArray(e[0])?n=!0:1===e.length?n=t.inputs.some((e=>e.indexed)):2===e.length&&(n=!0),{args:n?e[0]:void 0,options:(n?e[1]:e[0])??{}}}const jp=async(e,t,n,s,r,a)=>{s.debug("Deploying contracts...");const i=function(e){const{key:t="wallet",name:n="Wallet Client",transport:s}=e;return au({...e,key:t,name:n,transport:s,type:"walletClient"}).extend(Zf)}({account:t,chain:n,transport:ah(e)}),o=function(e){const{key:t="public",name:n="Public Client"}=e;return au({...e,key:t,name:n,type:"publicClient"}).extend(Rp)}({chain:n,transport:ah(e)}),l=await Hp(i,o,r.registry.contractAbi,r.registry.contractBytecode);s.info(`Deployed Registry at ${l}`);const c=await Hp(i,o,r.availabilityOracle.contractAbi,r.availabilityOracle.contractBytecode);s.info(`Deployed AvailabilityOracle at ${c}`);const d=await Hp(i,o,r.gasToken.contractAbi,r.gasToken.contractBytecode);s.info(`Deployed Gas Token at ${d}`);const u=await Hp(i,o,r.rollup.contractAbi,r.rollup.contractBytecode,[(0,hu.b)(l.toString()),(0,hu.b)(c.toString()),(0,hu.b)(d.toString()),a.vkTreeRoot.toString()]);let f,h;s.info(`Deployed Rollup at ${u}`);{const e=Mp({address:(0,hu.b)(u.toString()),abi:r.rollup.contractAbi,client:o});f=da.fromString(await e.read.INBOX([]))}s.info(`Inbox available at ${f}`);{const e=Mp({address:(0,hu.b)(u.toString()),abi:r.rollup.contractAbi,client:o});h=da.fromString(await e.read.OUTBOX([]))}s.info(`Outbox available at ${h}`);const p=Mp({address:(0,hu.b)(l.toString()),abi:r.registry.contractAbi,client:i});await p.write.upgrade([(0,hu.b)(u.toString()),(0,hu.b)(f.toString()),(0,hu.b)(h.toString())],{account:t});const _=await Hp(i,o,r.gasPortal.contractAbi,r.gasPortal.contractBytecode);s.info(`Deployed Gas Portal at ${_}`);const m=Mp({address:_.toString(),abi:r.gasPortal.contractAbi,client:i});await o.waitForTransactionReceipt({hash:await m.write.initialize([l.toString(),d.toString(),a.l2GasTokenAddress.toString()])}),s.info(`Initialized Gas Portal at ${_} to bridge between L1 ${d} to L2 ${a.l2GasTokenAddress}`);const g=Mp({address:d.toString(),abi:r.gasToken.contractAbi,client:i}),b=await g.write.mint([u.toString(),100000000000000000000n],{});return await o.waitForTransactionReceipt({hash:b}),s.info("Funded rollup contract with gas tokens"),{walletClient:i,publicClient:o,l1ContractAddresses:{availabilityOracleAddress:c,rollupAddress:u,registryAddress:l,inboxAddress:f,outboxAddress:h,gasTokenAddress:d,gasPortalAddress:_}}};async function Hp(e,t,n,s,r=[]){const a=await e.deployContract({abi:n,bytecode:s,args:r}),i=await t.waitForTransactionReceipt({hash:a,pollingInterval:100});if(!i.contractAddress)throw new Error(`No contract address found in receipt: ${JSON.stringify(i,((e,t)=>"bigint"==typeof t?String(t):t))}`);return da.fromString(i.contractAddress)}Dc(JSON.parse('{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"GasToken","functions":[{"name":"claim_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"set_portal","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/72WzW7TQBSFx0nTRKR14tAkzv+fx2mpWIKQkNiz5glAIIEELBAs4FF4B16kD8GeNRLbMufOz4njNpKlqiNNM75zvnvuzLjyZKquVMt0pWbKNURUrI7NT4T+QvmRGdRMj2IV+ZDGJKiadjJVlxGER2vz58ET5S0y1VDFBlVDvGSqUVYg47FVSM9Qn0Tb2muaUrS0tvXxmta25lLjqZkF3Qk1p8cyPMHQ9HiF+RSjpxHrqFsfkcUaEzHsbGVwbe3Vfm0aVFYBcWwU13sNplYB71Pm2LFWHavooNdCOjzGe48qPJ4WuWZThi23io4s8hwjLrK8+WitOJCtBleLRJLkMUa3Jnn+86pW3Kc2d7570wl2iyfYkRNsF08Qw4THlpjek2KeYXTbsfXk2HrwsAvpuoV0bNYNUt1UUlIsqcfXKMlU9Mr8PqQTxGe6ZoPqjNiZ1SR2KOh7hj3aFxSCPtE+0b5DXzPs0YGgEAyIDogOHPqFYY8OBYVgSHRIdOjQdwx7NBUUgpRoSjR16FuGPToSFIIR0RHRkUNfMuzRsaAQjImOiY4d+olhj04EhWBCdEJ0Yn8rI8btG8MenQoKwZTolOjUoV8Z9uhMUAhmRGdEZ+VCZ+EVOIAYtzcMe3QuKARzonOic4d+ZNijC0EhWBBdEF2UC12Et+YAYtyWDHt0KSgES6JLosuy2zJsS0VkXh0ZVEeG97KW9DBiNvs7wx5dCQrBiuiK6KrstgrncwAxbh8Y9uhaUAjWRNdE1w79zLBHN4JCsCG6IbopF7oJbhWR6b249Ksj8zsvzGz2D4Y9mgkKQUY0I5qV3bLwpldE0sOIfPb/8SOeCaj45a6Hi4lp2n/OTcajnWuKFitdtMpVyJhzBqvOKTrnZeDC3kgunP6R2TsoLiMRXiKELhX/tU9+uWAutZdtaWwnajaISe+Au9sF/i//7JS1V7BchJLionTYmy73Ru/dubgmXboU/v4Frb3PZTyQrkuTSLGZfXfCXc1qtCtHn0eOiIoXwjwUp1lcXiwuyXZnfFqItmKNY91S7vYydzuYi7V2k40NRukV+n+JxmtyCw0AAA==","debug_symbols":"7ZztahpREIbvxd+h7DtzPnMrpRTzVYRgQmIKJeTeq9U1EW2lQR5djv+izjrzTng4sjzs6+jm9urlx/fJ9O7heXT59XV0/3A9nk0epvNXr6Pui7o/7z4/jqeLN55n46fZ6NLl3cXodnqz+DOlt4vR3eT+dnRpNbxdbFUre1pVK5duXa1Qd1RH97Cqjp7qurrGXcWq3heb9hSX2OVVcYnBPxZ/u1hktYayhoayxoaypoay5oayloayVj6r6jpr7v49fi79N+fF5/0YpS6nt27Q02vQ09ugp/dBTx8GPX0c9PTptKdPvp4+bUy/XVu9/9764dDZXZtjWX9veK/11VLyeSnbSznxs/UoS/ETP/SOs5QTP42Os5QTP+SOs5QTPzuPs5TzkbxjKecjecdSynkp20s5/07ZXkrYf2shby5leZl97jL/3GXhc5f95RAp/a0iN9/7D7fUr0+ucLI3uEJuKGtpKGttJ2vsGsqqhrIan/U/Dl7VsD7Ta/xwK8xX50j0gc8fBj5/HPj8aeDz54HPf4jfC+5azx/SxvzLJhVokjqiiYgmRjRxokkgmkSiSSKaZKIJQXwiiM8E8ZkgPhPEZ4L4TBCfCeIzQXwmiM8E8ZkgvhDEF4L4QhBfCOILQXwhiC8E8YUgvhDEF4L4ShBfCeIrQXwliK8E8ZUgvhLEV4L4ShBfCeLVdUgXIV0M6eJIl4B0iUiXhHTJSJeCdEHYF8K+EPaFsC+EfSHsC2FfCPtC2BfCvhD2DWHfEPYNYd8Q9g1h3xD2DWHfEPYNYd8Q9h1h3xH2HWHfEfYdYd8R9h1h3xH2HWHfEfYDwn5A2A8I+wFhPyDsB4T9gLAfEPYDwn5A2I8I+xFhPyLsR4T9iLAfEfYjwn5E2Ed0PSG+nhBhT4ixJ0TZE+LsCZH2hFh7QrQ9Id6eEHFPiLknRN0T4u4JkfeE2HtC9D0h/p4QgU+IwSdE4RPi8AmR+IRYfEI0PiEenxCRT4jJJ0TlE+LyCZH5hNh8QnQ+IT6fEKFPiNEnROkT4vQJkfqEWH1CtD4hXp8hXp8hXp8hXp8hXp91AekSkS4J6ZKRLgXpgrCPeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH12EK8vdv0DtRRT2OiyXR2T+ierxpTen6i1+1GBIa+LY7enuCTrHwNW0uaDvVZhc0thS0tha0NhD+J8DiasWgrrLYUNLYWNLYVt6UdFbOlHxUH06Zj7Z0UrWTrhsLWhsAeRyQcTVi2FtZbCekthQ0thY0thU0thcxth5y9+jp8m46v72+f5JYvPXqbXs8nDdPVy9utx+cm89jc="},{"name":"deploy","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"artifact_hash","type":{"kind":"field"},"visibility":"private"},{"name":"private_functions_root","type":{"kind":"field"},"visibility":"private"},{"name":"public_bytecode_commitment","type":{"kind":"field"},"visibility":"private"},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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viNtnz3S86/Zv+WvuXDL8L9m/J6/pnzPXzN9z18T3/PXzN/z1yzf89es3/PXAJ4CZYj56EDsQ+XBNI7Hp8fxS1u57MNxqJ3wUDF896HW7enjtvHnR/g7vxX0PP547+OXex9/uvfx497Hn+99/OXex1/vffzt3sffb338+d637nzvW3e+96073/vWne996873vnXne9+6871v3fnet+5871t3ufetu9z71l3ufesu9751l3vfugv1c38+VlnMcX586ud+9fgr9ZNnPvb1zMt6enzqJ0/9+NRPnvrxqZ889eNT+/368an9fv341M/96rfRK/Vzv358ar9fPf5G7ffrx6e+devHp75168envnXrx6e+devHp75168envnXrx7/3rbvd+9bd7n3r7t9/674zO2Zcnh8ex/XLLw+9fiVmH+9eQLl7AdPdC4i7FzDfvYDl7gWsPAU8j7TxHQlxV47jsXJ5XKJypHEsL+m+vBdcylO6aRgYDzV+96GQXwBMQ7n38ad7Hz/uffz53sdf7n389d7H3+59/P3Wxx+Hex//3rfueO9bd7z3rTve+9Yd733rjve+dcd737rjvW/d8d63brn3rVvufeuWe9+65d63LmIaRc/j3/vWLfe+dcu9b91y71u33PvWnaif+7XfEp4m6ud+/fjUT57ab0pOE/WTp3586idP/fjUT57q8YPa79ePT+3368enfu7XfuFnCurnfv34ce/jU/v9+vGpb9368alv3frxqW/d+vGpb93q8WfqW7d+fOpbt378e9+6871vXcgUkI7H//5b951fLxy216+DDV9+ye7162DzcvcC1rsXsN29gP3mBSzD3QsY715A4S7gSO6PAsafCjj7yceGli9Dacf9uDOWSanYUCqW2w389Mvh5/8dcruBhgK43UBDAdxuoKEAbjdQL2DldgMNBXC7gYYCuN1A/R2blfuGbyiA+9ZuKIDoJn4eiehufR4Jclt+Wef4ZYvrxQtqx17JcY7TI218R9q/+0jQ3yaBTL/pePzx3scv9z7+dO/jx72PP9/7+Mu9j7/e+/jbvY9/71t3v/etu9/71t3vfevu9751IVNvOh7/3rfufu9bd7/3rbvf+9bdb33rxnDrWzeGW9+6Mdz61o3h1rduDLe+dWO49a0bw61v3RhufevGcOtbN4Z737oj9XO/9sJfjNTP/frxqZ88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tis1VCvlpTJtEmqoVspLZdqa01CtlJfKtCGmoVopL5VpG0pDtVJeKtPmj4ZqpbxUpi0XDdVKealMGx0aqpXyUpm2FzRUK+WlMk3qb6hWyktlmnjfUK2Ul8o0lb6hWikvlWlyfEO1Ul4q03T3hmqlvFSmCewN1Up5qUxT0huqlfJSUnPPV6m556vU3PNVau75KjX3fJWae75KzT1fpeaer1Jzz1epueer1NzzVWru+So193yVmnu+Ss09X6Xmnq9Sc89Xqbnnm9Tc801q7vkmNfd8k5p7vg0hVa2Sl9qk5p5vUnPPN6m555vU3PNNau75JjX3fJOae75JzT3fpOaeb1Jzzzepueeb1NzzTWru+SY193yTmnu+Sc0936Tmnm9Sc883qbnnm9Tc801q7vkmNfd8k5p7vknNPd+k5p5vUnPPN6m555vU3PNNau75JjX3fJOae75JzT3fpOaeb1Jzzzepueeb1NzzTWru+SY193yTmnu+Sc0936Tmnm9Sc883qbnnm9Tc801q7vkmNfd8k5p7vknNPd+k5p5vUnPPN6m555vU3PNNau75JjX3fJOae75JzT3fpOaeb1Jzzzepueeb1NzzTWru+SY193yTmnu+Sc0936Tmnm9Sc883qbnnm9Tc801q7vkmNfd8k5p7vknNPd+k5p5vUnPPN6m555vU3PNNau75JjX3fJOae75JzT3fpOaeb1Jzzzepueeb1NzzTWru+SY193yTmnu+Sc0936Tmnm9Sc883qbnnm9Tc801q7vkmNfd8l5p7vkvNPd+l5p7vUnPP9yGkqlXyUrvU3PNdau75LjX3fJeae75LzT3fpeae71Jzz3epuee71NzzXWru+S4193yXmnu+S80936Xmnu9Sc893qbnnu9Tc811q7vkuNfd8l5p7vkvNPd+l5p7vUnPPd6m557vU3PNdau75LjX3fJeae75LzT3fpeae71Jzz3epuee71NzzXWru+S4193yXmnu+S80936Xmnu9Sc893qbnnu9Tc811q7vkuNfd8l5p7vkvNPd+l5p7vUnPPd6m557vU3PNdau75LjX3fJeae75LzT3fpeae71Jzz3epuee71NzzXWru+S4193yXmnu+S80936Xmnu9Sc893qbnnu9Tc811q7vkuNfd8l5p7vkvNPd+l5p7vUnPPd6m557vU3PNdau75LjX3fJeae75LzT3fpeae71Jzz3epuee71NzzXWru+S4193yXmnu+S80936Xmnu9Sc893qbnnu9Tc811q7vkuNfd8l5p7vkvNPd+V5p6vg9Lc80e1Ql7qUa2Ql3pUK+SlHtWGVLVCXupRrZCXelQr5KUe1Qp5qUe1Ul5Kae75o1opL6U09/xRrZSXUpp7/qhWykspzT1/VCvlpZTmnj+qlfJSSnPPH9VKeSmlueePaqW8lNLc80e1Ul5Kae75o1opL6U09/xRrZSXUpp7/qhWykspzT1/VCvlpZTmnj+qlfJSSnPPH9VKeSmlueePaqW8lNLc80e1Ul5Kae75o1opL6U09/xRrZSXUpp7/qhWykspzT1/VCvlpZTmnj+qlfJSSnPPH9VKeSmlueePaqW8lNLc80e1Ul5Kae75o1opL6U09/xRrZSXUpp7/qhWykspzT1/VCvlpZTmnj+qlfJSSnPPH9VKeSmlueePaqW8lNLc80e1Ul5Kae75o1opL6U09/xRrZSXUpp7/qhWykspzT1/VCvlpZTmnj+qlfJSSnPPH9VKeSmlueePaqW8lNLc80e1Ul5Kae75o1opL6U09/xRrZSXUpp7/qhWykspzT1/VCvlpZTmnj+qVfJSo9Tc81Fq7vkoNfd8lJp7/qhFqlolLzVKzT0fpeaej1Jzz0epueej1NzzUWru+Sg193yUmns+Ss09H6Xmno9Sc89Hqbnno9Tc81Fq7vkoNfd8lJp7PkrNPR+l5p6PUnPPR6m556PU3PNRau75KDX3fJSaez5KzT0fpeaej1Jzz0epueej1NzzUWru+Sg193yUmns+Ss09H6Xmno9Sc89Hqbnno9Tc81Fq7vkoNfd8lJp7PkrNPR+l5p6PUnPPR6m556PU3PNRau75KDX3fJSaez5KzT0fpeaej1Jzz0epueej1NzzUWru+Sg193yUmns+Ss09H6Xmno9Sc89Hqbnno9Tc81Fq7vkoNfd8lJp7PkrNPR+l5p6PUnPPR6m556PU3PNRau75KDX3fJSaez5KzT0fpeaej1Jzz0epueej1NzzUWru+Sg193yUmns+Ss09H6Xmno9Sc8/HTLOxH6cejlOXvfKz3znHNE3zjw9P0za+zrHHX/zJZSjPD5dh/cpuP/vJ23785FL5yXOUH5+dYzrXPpH7sPZvap/Ii1n7N7UPay+rfSKfbu3f1D5RarH2b2qfKMNZ+ze1T5Rorf2b2if6rsTav6V9ybSZxNq/qb37errau6+XVfvtCWPe53Pt3dfT1T6svaz27uvpau++Xlbt15f2y7n27uvpau++nq727uvJap9pS561f1N79/V0tXdfL6v28/P3dOdlPdfefT1d7cPay2rvvp6u9u7r6Wrvvp6u9u7r6Wrvvp6s9pk2Nlv7N7V3X09Xe/f1dLV3X09X+7D2stq7r6ervft6utq7r6ervft6utq7ryer/eS+nq727uvpau++nq727uvpah/WXlZ79/V0tXdfT1d79/V0tXdfT1d79/VktQ/39XS1d19PV3v39XS1d19PV/uw9rLau6+nq737errau6+nq737errau68nq/3svp6u9s73XbV//ISnROO+T0jtq3sz5rD2sto73+tq73yvq73zva72zve62jvfy2q/ON/rau/f29HV3r+3o6u9+3q62oe1T6p9dTfi4r6ervbu6+lq776ervbu62XVvrojbXFfT1b71X09Xe3d19PV3n09Xe3d19PVPqx9Uu2rv6e7uq+nq737errau6+nq737errau68nq/3mvp6u9u7r6Wrvvp6u9u7r6Wof1l5We/f1dLV3X09Xe/f1dLV3X09Xe/f1ZLXf3dfT1d59PV3t3dfT1d59PV3tw9rLau++nq727uvpau++nq727uvpau++nqr20+C+nq727uvpau++nq727uvpah/WXlZ79/V0tXdfT1d79/V0tXdfT1d79/VktR/d19PV3n09Xe3d19PV3vkerz1yu8U0OoWzK+SszK6QEy27Qs6d5AoVp0N2hZzh2BVy0mJXyL/nwK5QWCFyhdxTYFfIPYW+CtV2nE3FPQV2hdxTYFfIPQVyhSb3FPoqVNvBM03uKbAr5J4Cu0LuKbArFFaIXCH3FNgVck+hr0LV3/WZ3FNgV8g9BXaF3FMgVyjcU2BXyD0FdoXcU2BXyD0FdoXCCpEr5J4Cu0LuKbAr5J4Cu0LuKbAr5J4CuUKzewrsCrmnwK6QewrsCrmnwK5QWCFyhdxTYFfIPQV2hdxTYFfIPQV2hdxTIFdocU+BXSH3FNgVck+BXSH3FNgVCitErpB7CuwKuafArpB7CuwKuafArpB7CuQKre4psCvkngK7Qu4psCvkngK7QmGFyBVyHmpRaNyePKZSFqRC1RmNq/MQu0LO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Op4fMv+n5/nHm5+/3Pz8083PHzc//3zz8y83P/968/Pf/P4N7vu39vur88x9/9bPz33/1s/Pff/Wz899/9Z+f3KGzP/peX7u+7d+fu77t35+7vu3fn7u+7d+fu77t9p/WLjv3/r5ue/f+vm579/6+bnv3/r5ue/f+vm579/6+bnv3/r5ue/f+vm579/6+W9+/643v3/Xm9+/683v3/Xm9+968/t3vfn9u978/l1vfv+uN79/15vfv9vN79/t5vfvdvP7d7v5/QuZv9Tz/De/f7eb37/bze/f7eb373bz+3e/+f273/z+3W9+/+43v38h85d6nv/m9+9+8/t3v+/9W7b1365eH9+ev/c0jsP+On6Z//kH938r5y/ebsNzkvW+x09lH39u+80/t//enzt/wbPhz42/+efKb/656Tf/HOABNu7L868Z922p/ANcxuXHh5ep/Pkf1R9nmgnPtBCeaSU80/bZMx1/z/49fw/iBbOmv2f8pr+nfNPfM33T3xPf9PfM3/T3LN/096zf9Pd8e0Afx+PT47h+sS2PP3mcamc8FffLTOu6Hp+dTp/93C8zNZyfOkw3nJ86TDecP25+fuow3XB+6jDdcH7qMN1wfupmdsP5qZvZ9fNzv8zUcP6b37/cLzM1nP/m9y/3y0wN57/5/cv9MlPD+W9+/3K/zNRw/pvfv9wvMzWc/+b3L/fLTA3nv/n9y/0yU8P57ztM4p/nv+8wiX+c/8Yvc/zz/Pf9ZZZ/nv++v8zyz/NTP38azn/fX2b55/nv+8ss/zw/9fO//t0198scDeen9v/183O/zNFwfur7t+H81Pdvw/mp79+G81Pfvw3np75/G85Pff82nP/m9y/3yxwN57/5/dvhZY7LnsKfPzuOy/PD47h++W2jL79B0+F1DnQF5fYVTLevIG5fwXz7CpbbV7DyVHCcaSM807evIBnH8lIvtteny6He9P2LrZtORb0upKr1xL2uuuH81OtCGs4fNz8/9bqQhvNTr+tqOD/1uq6G81Ov62o4P/W6rvr5uddVN5z/5vcv97rqhvPf/P7lXlfdcP6b37/c66obzn/z+5d7XXXD+W9+/3Kvq244/83vX+511Q3nv/n9y72uuuH8N79/uddVN5z/5vcv97rqhvPf/P4lX5dc+w3jiXxdcv381M+f6m9YThP186fh/NTPn4bzUz9/6ucP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PMk1CDzJNQg8yTUG/EJyDQJPcg0CT3INAk9yDQLfAB8DnuQaBJ7kGgSe5BoEnuQaBJ7k+i/v4wVnJV1+gEMC/ACHlPYBDknqA5wGnGM4JJIPcEgNH+Dg7D/AwX1/gINDPoaz4ZA/wCnkkPdte714PRi3kOftGbeQi+0Zt3mNW8hp9oxbyDv2jFvIDfaMW8jf9YxbyLF1jLsX8mA943q5qt3LVe1ermpvXuN6uardy1XtXq5q93JVu5WrWh9Wrmp9WLmq9WHlqtaHlataH81rXCtXtT6sXNX6sHJV68PKVa0PL1c1eLmqSnfse8b1clWVbrb3jNu8xvVyVZWugveM6+WqKl3A7hnXy1VVuvbcM66Xq6p02bhnXC9XVemKb8+4Xq6q0sXannG9XFWl66w943q5qkqXSHvG9XJVla5u9ozr5aoqXZjsGdfLVVW6ptgzrperqnQ5sGdcL1dV6Upez7herqrSRbiecb1cVaXrZz3jermqSpe+esb1clWVrlr1jOvlqipdcOoZ18tVVbpW1DOul6uqdJmnZ1wvV1XpCk3PuF6uqtLFlZ5xvVxVpesiPeN6uapKlzR6xvVyVZWuRvSM6+WqKl1I6BnXy1VVugbQM66Xq6q0Vb9nXC9XVWnzfc+4Xq6q0nb6nnG9XFWlDfI943q5qkpb3nvG9XJVlTax94zr5aq8dquvXrvVV6/d6qvXbvXVa7f66rVbffXarb567VZfvXarr1671Vev3eqr12711Wu3+uq1W3312q2+eu1WX712q69eu9U3r93qm9du9c1rt/rmtVt9ezSvca1c1ea1W33z2q2+ee1W37x2q29eu9U3r93qm9du9c1rt/rmtVt989qtvnntVt+8dqtvXrvVN6/d6pvXbvXNa7f65rVbffParb557VbfvHarb1671Tev3eqb1271zWu3+ua1W33z2q2+ee1W37x2q29eu9U3r93qm9du9c1rt/rmtVt989qtvnntVt+8dqtvXrvVN6/d6pvXbvXNa7f65rVbffParb557VbfvHarb1671Tev3eqb1271zWu3+ua1W33z2q2+ee1W37x2q29eu9U3r93qm9du9c1rt/rmtVt989qtvnntVt+8dqtvXrvVN6/d6pvXbvXNa7f65rVbffParb557VbfvHarb1671Tev3eqb1271zWu3+ua1W33z2q2+ee1W37x2q29eu9U3r93qm9du9c1rt/rmtVt989qtvnntVt+8dqtvXrvVN6/d6pvXbvXNa7f65rVbffParb557VbfvHarb1671Tev3eq712713Wu3+u61W3332q2+P5rXuFauavfarb577VbfvXar71671Xev3eq712713Wu3+u61W3332q2+e+1W3712q+9eu9V3r93qu9du9d1rt/rutVt999qtvnvtVt+9dqvvXrvVd6/d6rvXbvXda7f67rVbfffarb577VbfvXar71671Xev3eq712713Wu3+u61W3332q2+e+1W3712q+9eu9V3r93qu9du9d1rt/rutVt999qtvnvtVt+9dqvvXrvVd6/d6rvXbvXda7f67rVbfffarb577VbfvXar71671Xev3eq712713Wu3+u61W3332q2+e+1W3712q+9eu9V3r93qu9du9d1rt/rutVt999qtvnvtVt+9dqvvXrvVd6/d6rvXbvXda7f67rVbfffarb577VbfvXar71671Xev3eq712713Wu3+u61W3332q2+e+1W3712q+9eu9V3r93qu9du9d1rt/rutVt999qtvnvtVt+9dqvvXrvVd6/d6rvVbvX1YbVb/WtcJ1f1Na6Tq/oa18lVfY3bvMZ1clVf4zq5qq9xnVzV17hOruprXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXCtXNXjtVh+8dqsPXrvVB6/d6l/DeI1r5aoGr93qg9du9cFr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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2b3U7bQBCF18GhBoOb2HGckEAIBaTehRSScMfLtM/d60p9haqss6Mclmm0UcdLVool5LG9O+ebsz+EyERqfSSvP5GJ2+Z8rN4f1ObFnGf/dzwI5po1yRkFwtkKhPMoEM5YkDNiOPU5NrFed3rNfVLr9fjuIXbWA30Ez9W2RLZqYgJ8eC1V6Wr2fAzJEVwZ8Ng8o7PGSc0zBEtNkXUbuEeFtuAe6RzBPdrBSCcxpgjX+5RskOXyvs4+XcOJyUXcKcT4bAzWxQ3V2Jav8bGRMXn1rqExqVcx+d42uRO4pjE4NbHgb44H1I7Mz6k1F2KIR9CW2pEfLWDVx7narJfTLf1iq18GbY6hn7230DWNtfaqa2J9btOeAPkb8HCm86byed+MTWx5l0JNGXgioz1f6fxn6u0RWdfXEGfAcy7Os1578nWux+4zsMvkfXrUXnUsr84srzJogwydBvyLQJdy03WH0ZbzYrHS2l0HL7oMT9ezF11GW9CLZ62dO3iRMzy5Zy9yRlvOi+U3rV04eFEwPIVnLwpGW86Lef0ZoOfgRY/h6Xn2osdoC66Rel6UDl6UDE/p2YuS0Rb04ofW7jt40Wd4+p696DPagl5819qVgxcVw1N59qJitAX3zvrzxcDBiwHDM/DsxYDRFvRirrWHDl4MGZ6hZy+GjLbgGqm1Lxy8uGB4Ljx7QXq7MvcCZK4CZC72gDmxYhntRb1/jhy8GDE8I89e4HcuuzCXe8CcWLGM9uJJa48dvBgzPGPPXpDersx5gMxFgMz9AJnLAJmrAJn3YT4nViyjvaz30EsHLy4ZnkvPXpDersx5gMyjAJmLPWBOrFhGe1l/N3fl4MUVw3Pl2QvS25V5ECBzdw+YEyuW0V4utPbEwYsJwzPx7AXp7co8DJC5CpB5FCBzESBzP0DmMkDmwxr0w5zvATO+e/S7UZ75c2rxkGfKYlQWYwpxBozU9kXJva+SWbWT1lTcj/X42POFrqeNas9XOu+XBmrSeW/l89Z/I9yZXPQO3y3j1b2JI+FxuoO8EejQ/RjiX9CW2pEftB8Qu36X68bE91v6Tax+GbS5gX63Vj+6prHW3v00cVNzy2Ved9RmLX8Fngb2wUd8J1eBV8pipGMCPNfyPA8N1TnDd/j+KNm1N7W8OrG8yqAN7tEftW8emA/M/2LGzxMncA956F7LqgX/v2EKOf4CARQXTpY1AAA=","debug_symbols":"ndpRattAGIXRveg5FN/foxkpWymlOIlTDMEJsVMoJnuv3dIF9LxpJN237+kwl+lp//Dx4/vh+Px6mu6/XqaX18fd+fB6vJ4u0+ZLLX/ent52x9uL03n3fp7ut33cTfvj0/Vp1Ofd9Hx42U/3tbbPb3e30Qqj7UZGkVHJaCujJqNZRl1GQ0ZSxFaKaFJEkyKaFNGkiCZFNCmiSRFNimhSRJMiZililiJmKWKWImYpYpYiZililiJmKWKWIroU0aWILkV0KaJLEV2K6FJElyK6FNGliCFFDCliSBFDihhSxJAihhQxpIghRQwpYpEiFilikSIWKWKRIhYpYpEiFilikSIWKWKVIlYpYpUiVililSJWKWKVIlYpYpUiVikimw2tQqui1ZZWjVYzrTqtBq0WWlEboTZCbYTaCLURaiPURqiNUBuhNkJtFLVR1EZRG0VtFLVR1EZRG0VtEGiGRDNEmiHTDKFmSDVDrBlyzRBshmQzRJsh2wzhZkg3Q7wZ8s0QcIaEM0ScIeMMIWdIOUPMGXLOEHSGpDNEnSHrDGFnSDtD3BnyzhB4hsQzRJ4h8wyhZ0g9Q+wZcs8QfIbkM0SfIfsM4WdIP0P8GfLPEICGBDREoCEDDSFoSEFDDBpy0BCEhiQ0RKEhCw1haEhDQxwa8tAQiIZENESiIRMNoWhIRUMsGnLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0bKLnuSiRS5a5KJFLlrkokUuWuSi9d8uej393L0fdg8v+9vd3tvHj+Pjv6u+1+P519vfL9d/fwM="},{"name":"mint_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/+2aWW/jNhDH5StOE6/XSRPftyXbm/jKOnZ3m6YPfS7Qh770sQV6Ar3Q8zv26/S5aDkzHP7lKPGCi1YIijWgiBr+fxxyKIkaImGQC4LDfGB+ncD+zNVhUA4OzClDx/uBlkwha45MOcioKaJKorKRlQU5LpEwzyXjISgMzZ/jTaDOuPmgYI6DMCj8fednzEVRFOkoclEvDwfUwAmVthntc5l6Le2Voc44L0XrycodR60IcOj6pleFkILDIz6KVG0qc7Z4RH9EQ+29FaIGnoKYx2PxdCxHzrqiZkpR1laU0GBJNEdSpHMSye9Hdrqkg3lyk49pqL0nyf7S76n09ykdBS6W7GU5lBCeFPhcthNSESfvmePMRewUETvbjdjb6N6ZafBjcz4X8akVV3mQ51QCVhXNmRQZ/QVmRWuMkqAGtAa0ZtEfYFa0zigJ6kDrQOsW/QlmRRuMkqABtAG0YdHPYFa0ySgJmkCbQJsW/QpmRVuMkqAFtAW0ZdEvYFa0zSgJ2kDbQNsW7cOsaIdREnSAdoB2LPozzIp2GSVBF2gXaNei38KsaI9REvSA9oD25JxEav5I1R9p70fMmFYwK9pnlAR9oH2g/aS3vvO2BzHevodZ0QGjJBgAHQAdJL0NXAQ9kao/0vZHGv5INxXkFREz8/M7zIoOGSXBEOgQ6DDpbeie4j2I8fY5zIqOGCXBCOgI6MiiC5gVDRklQQg0BBomOxq6KfZEzv2Rqj9S80fq/kjDH2n6I61U5qXjj3RTmZdqKmN5RcTMc/MdzIpGjJIgAhoBjSz6K8yKjhklwRjoGOg42dGxG5snUvVH2o+1Yw1/pP4YImbugi9hVnTCKAkmQCdAJ0lvEzcmT6Tmj4T+SHs/YsJwBbOiU0ZJMAU6BTpNepu6JWsPQktv5iPkM7cMBkhiNGshNT+MwoacjunvGbt6tuvqQuCpFLWGEqYLiGbIi+YHXJxb/cIEghTLDAuXZKKDe/yhXOlwiVlGKruEY6nIipEq1cOMzn3T0gexbt3pMKfcNNpb9Be5XvnBXK8yydr8kRPGGHzgUlZCLngon1BpG8vSc9I4yy4iG8mgVHZZaeX+bYSyKAgtyzZCxV6Ko093Hck2ArdXhjrjvBBY4UmmikOxqoOiYHlbG9vBsC2o6yK3ULQtVALXvN2pUIz0BexsxLpULDhRAfdpe2cuSg/OxUUYr8lZ5yS6dC/LS8gv8XhcPoRUU0Fa/ki4HzHP048wKzpzT8cs9lQCnSW9zdyYPJF2Kl5qqXSs4Y8MU0FeYyyD/Yi5cb6BWdE5o/weBToHOk96m7sp3YMYb1/DrOiC0bmsC4ougC6S3hYuHJ5IbT9iOvgbzIrKKkOCJdAl0GXS29I96J5I3R8Z+yNdf6Tmjwz2I1SdDfDe7zB4z/fJcuf7ZLn7fbJiV6tdV1cCL6WoNXS/XEG0xvpxLav3tdVv7PfJVr5PtmSig9fav+RKh0vMNlLZcziWiqwYqVI9rOncNy39GevWnQ6775MONrxXLjYFxGZ15/skjNfk7MK6clNyfO+UrKzre5H8fgT9W7oN+ZVtZCnrO13SdntettlJdSJPm36erd3QrjC09e7QnofxmpyNFAfTba1cQ34tmjWCnkSq/kjNH6n7Iw1/pOmPtPyRtj/S8Ue6qcxLNZXh91Lx0v8fRayRyg2Tzj02SOWpHPojo1Sm8s07+c07+b+e/U4qEQv9kSiVsVQf6w1TTeURqz/WiI1TGUstlTv5NYY/+deXJFpKcz3kDbcMBrspQWDVki6upcV4urhhV5tdV7HkbIsaSky2EL1A/vFS0sWXVv+uTRdvJF28IRMd3OO2XOlwibmJVPYOHEtFVoxUqR5e0Llvrk9j3brTYU4XabS3WfyDmaRauq1LQSjet9mdf3CDtZzYYM1bkUSRvGwg3yC/p/ieTTXZo/NqRA7rf9DxD/Dv8iGuJwAA","debug_symbols":"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"},{"name":"claim","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"_increase_public_balance","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"check_balance","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"fee_limit","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"balance_of_public","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/83YW2/rRBAH8E3itA1NHCd2mmvbtLFzT3NOKYgjKI8g8cojD4i7kLiJixBfkS8FO7M7+09qHVcrHVnHUmpnPD/P7tppM01VTamzQOntUtmNIipUJ3pXodfHSo70QVW/KqGqSCijk6SqmU1TNT6ixOBW/zjPlHFntffoRI2ukKoKpZ7UVcVUpHKqnvLhB/rVyGQ4p+Y8bQ36YXKInaU4oy/4id6/Y5JPbfJ5VjVBdQ52bnIa5pDpXwgLbTKlhCZoE7Rp6S8IC20xpYQWaAu0Zek3CAsNmVJCCBqChpb+ibDQNlNKaIO2QduW/oiw0IgpJUSgEWhk6a8IC+0wpYQOaAe0Y/Z50iwmutoUYaFdppTQBe2Cdi39GmGhMVNKiEFj0NjSrxAWmjClhAQ0AU0s/QlhoT2mlNAD7YH28svTc9U8SdOftIqJntN3CAu9YEoJF6AXoBeWfomw0D5TSuiD9kH7+YH23QNWQHS17xEWOmBKCQPQAeggX23gBlhAdLXfEBY6ZEoJQ9Ah6DBfbeh+x3iSrj9J/Enbn7T8SaeUKrE/aZYyl6iUgT1z9/UT/Q/CQkdMKWEEOgId5auN3DJ4kq4/6ZUysJY/if1JUgp5ZsX0U/AtwkLHTClhDDoGHeerjd1iFxBd7Q+EhU6YUsIEdAI6yVebuC8+niQupUrbn7RKmUtSChkWkxuKX+K7/yuGCl/45Rs+ZatMugB9xUBhu+RSl8elrgyemEM5Q83FFZKm6CFuTvjwxubf2h5lVuHEGYXoxSMemXcyXYrNMkm7RmFzomqCdFIqTGmvf1Sig2E9GfD7FTvbVyaH55gdtGkycm7dMKc65nSZqro63vgucHvHlewNqdnLNHiwE/MBlQs2Ds6bfZ4ExeRoSDKZqw+Dg5yauTNPx0vbtRkvreF1nQ8b9m2Qcjl1YzrJQJbXFPmI1sWt2C1WLD1esRmGl+oLfm4etZq95ZQ850nSpeZgc5OTmkPa50noT6Jiogf4O8JCF0wpYQG6AF3kqy3cb44Coqv9gLDQJVNKWIIuQZf5akv3J8iTdPzJ2J8k/iTyJ+Ebn76+Py8QFrpiSgkr0BXoKl9t5ap5kqY/ifxJWMpcYn+SlEKeWTH9FPyNsNA1U0pYg65B1/lqa/cp9SSjYqIHeIew0A1TStiAbkA3+Wobd2s9SeZPQn8S+ZO5P4n9ycKf9Eq5L2N/kpRyX8JS5vLMiunPzc8IC90ypYQt6BZ0m6+2df9r8iRjfxL6k87bOrDYn8zf1hXrlzKXyJ9s3vj09efmJcJCd0wpYQe6A93lq+3cn6gCQi1H9TP0HY8MFZoN6S4o23SxqbniYRd7x6XujkvtDd6ZQzlDjc0eSS/Rv9ybLvbe5r9ru9gH08U+UIhePOJPzTuZLpmHTNJeoLA5UTVBOikVaInvp/pKjwfDejJg7mJpto8YL3qy4LU92XRRtX0eN3YH+MS1lkT2PBVq2fZcym41c3FO22d2JVUjdN2jvlX1/55sZEwG0eCUD6f2rSn0xXGh0DS+lBYiu+KqBLaSTT8YoNobQMPa82MwlUFWHd+bsIyIMhrunyDTTFR1RoeDf+n1P22FxfXTHQAA","debug_symbols":"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"}],"outputs":{"globals":{"storage":[{"fields":[{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"portal_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::mint_public_parameters"}}],"kind":"struct","path":"GasToken::mint_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::_increase_public_balance_parameters"}}],"kind":"struct","path":"GasToken::_increase_public_balance_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::claim_parameters"}}],"kind":"struct","path":"GasToken::claim_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"GasToken::balance_of_public_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::balance_of_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"GasToken::set_portal_parameters"}}],"kind":"struct","path":"GasToken::set_portal_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"fee_limit","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::check_balance_parameters"}}],"kind":"struct","path":"GasToken::check_balance_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"artifact_hash","type":{"kind":"field"}},{"name":"private_functions_root","type":{"kind":"field"}},{"name":"public_bytecode_commitment","type":{"kind":"field"}},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"GasToken::deploy_parameters"}}],"kind":"struct","path":"GasToken::deploy_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"leaf_index","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::claim_public_parameters"}}],"kind":"struct","path":"GasToken::claim_public_abi"}]}},"file_map":{"4":{"path":"std/cmp.nr","source":"// docs:start:eq-trait\\ntrait Eq {\\n    fn eq(self, other: Self) -> bool;\\n}\\n// docs:end:eq-trait\\n\\nimpl Eq for Field { fn eq(self, other: Field) -> bool { self == other } }\\n\\nimpl Eq for u64 { fn eq(self, other: u64) -> bool { self == other } }\\nimpl Eq for u32 { fn eq(self, other: u32) -> bool { self == other } }\\nimpl Eq for u8 { fn eq(self, other: u8) -> bool { self == other } }\\nimpl Eq for u1 { fn eq(self, other: u1) -> bool { self == other } }\\n\\nimpl Eq for i8 { fn eq(self, other: i8) -> bool { self == other } }\\nimpl Eq for i32 { fn eq(self, other: i32) -> bool { self == other } }\\nimpl Eq for i64 { fn eq(self, other: i64) -> bool { self == other } }\\n\\nimpl Eq for () { fn eq(_self: Self, _other: ()) -> bool { true } }\\nimpl Eq for bool { fn eq(self, other: bool) -> bool { self == other } }\\n\\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\\n    fn eq(self, other: [T; N]) -> bool {\\n        let mut result = true;\\n        for i in 0 .. self.len() {\\n            result &= self[i].eq(other[i]);\\n        }\\n        result\\n    }\\n}\\n\\nimpl<T> Eq for [T] where T: Eq {\\n    fn eq(self, other: [T]) -> bool {\\n        let mut result = self.len() == other.len();\\n        for i in 0 .. self.len() {\\n            result &= self[i].eq(other[i]);\\n        }\\n        result\\n    }\\n}\\n\\nimpl<let N: u32> Eq for str<N> {\\n    fn eq(self, other: str<N>) -> bool {\\n        let self_bytes = self.as_bytes();\\n        let other_bytes = other.as_bytes();\\n        self_bytes == other_bytes\\n    }\\n}\\n\\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\\n    fn eq(self, other: (A, B)) -> bool {\\n        self.0.eq(other.0) & self.1.eq(other.1)\\n    }\\n}\\n\\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\\n    fn eq(self, other: (A, B, C)) -> bool {\\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\\n    }\\n}\\n\\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\\n    fn eq(self, other: (A, B, C, D)) -> bool {\\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\\n    }\\n}\\n\\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3) & self.4.eq(other.4)\\n    }\\n}\\n\\nimpl Eq for Ordering {\\n    fn eq(self, other: Ordering) -> bool {\\n        self.result == other.result\\n    }\\n}\\n\\n// Noir doesn\'t have enums yet so we emulate (Lt | Eq | Gt) with a struct\\n// that has 3 public functions for constructing the struct.\\nstruct Ordering {\\n    result: Field,\\n}\\n\\nimpl Ordering {\\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\\n    // into the compiler, do not change these without also updating\\n    // the compiler itself!\\n    pub fn less() -> Ordering {\\n        Ordering { result: 0 }\\n    }\\n\\n    pub fn equal() -> Ordering {\\n        Ordering { result: 1 }\\n    }\\n\\n    pub fn greater() -> Ordering {\\n        Ordering { result: 2 }\\n    }\\n}\\n\\n// docs:start:ord-trait\\ntrait Ord {\\n    fn cmp(self, other: Self) -> Ordering;\\n}\\n// docs:end:ord-trait\\n\\n// Note: Field deliberately does not implement Ord\\n\\nimpl Ord for u64 {\\n    fn cmp(self, other: u64) -> Ordering {\\n        if self < other {\\n            Ordering::less()\\n        } else if self > other {\\n            Ordering::greater()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl Ord for u32 {\\n    fn cmp(self, other: u32) -> Ordering {\\n        if self < other {\\n            Ordering::less()\\n        } else if self > other {\\n            Ordering::greater()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl Ord for u8 {\\n    fn cmp(self, other: u8) -> Ordering {\\n        if self < other {\\n            Ordering::less()\\n        } else if self > other {\\n            Ordering::greater()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl Ord for i8 {\\n    fn cmp(self, other: i8) -> Ordering {\\n        if self < other {\\n            Ordering::less()\\n        } else if self > other {\\n            Ordering::greater()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl Ord for i32 {\\n    fn cmp(self, other: i32) -> Ordering {\\n        if self < other {\\n            Ordering::less()\\n        } else if self > other {\\n            Ordering::greater()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl Ord for i64 {\\n    fn cmp(self, other: i64) -> Ordering {\\n        if self < other {\\n            Ordering::less()\\n        } else if self > other {\\n            Ordering::greater()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n\\nimpl Ord for () {\\n    fn cmp(_self: Self, _other: ()) -> Ordering {\\n        Ordering::equal()\\n    }\\n}\\n\\nimpl Ord for bool {\\n    fn cmp(self, other: bool) -> Ordering {\\n        if self {\\n            if other {\\n                Ordering::equal()\\n            } else {\\n                Ordering::greater()\\n            }\\n        } else {\\n            if other {\\n                Ordering::less()\\n            } else {\\n                Ordering::equal()\\n            }\\n        }\\n    }\\n}\\n\\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\\n    // The first non-equal element of both arrays determines\\n    // the ordering for the whole array.\\n    fn cmp(self, other: [T; N]) -> Ordering {\\n        let mut result = Ordering::equal();\\n        for i in 0 .. self.len() {\\n            if result == Ordering::equal() {\\n                let result_i = self[i].cmp(other[i]);\\n\\n                if result_i == Ordering::less() {\\n                    result = result_i;\\n                } else if result_i == Ordering::greater() {\\n                    result = result_i;\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n\\nimpl<T> Ord for [T] where T: Ord {\\n    // The first non-equal element of both arrays determines\\n    // the ordering for the whole array.\\n    fn cmp(self, other: [T]) -> Ordering {\\n        let mut result = self.len().cmp(other.len());\\n        for i in 0 .. self.len() {\\n            if result == Ordering::equal() {\\n                let result_i = self[i].cmp(other[i]);\\n\\n                if result_i == Ordering::less() {\\n                    result = result_i;\\n                } else if result_i == Ordering::greater() {\\n                    result = result_i;\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n\\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\\n    fn cmp(self, other: (A, B)) -> Ordering {\\n        let result = self.0.cmp(other.0);\\n\\n        if result != Ordering::equal() {\\n            result\\n        } else {\\n            self.1.cmp(other.1)\\n        }\\n    }\\n}\\n\\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\\n    fn cmp(self, other: (A, B, C)) -> Ordering {\\n        let mut result = self.0.cmp(other.0);\\n\\n        if result == Ordering::equal() {\\n            result = self.1.cmp(other.1);\\n        }\\n\\n        if result == Ordering::equal() {\\n            result = self.2.cmp(other.2);\\n        }\\n\\n        result\\n    }\\n}\\n\\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\\n        let mut result = self.0.cmp(other.0);\\n\\n        if result == Ordering::equal() {\\n            result = self.1.cmp(other.1);\\n        }\\n\\n        if result == Ordering::equal() {\\n            result = self.2.cmp(other.2);\\n        }\\n\\n        if result == Ordering::equal() {\\n            result = self.3.cmp(other.3);\\n        }\\n\\n        result\\n    }\\n}\\n\\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\\n        let mut result = self.0.cmp(other.0);\\n\\n        if result == Ordering::equal() {\\n            result = self.1.cmp(other.1);\\n        }\\n\\n        if result == Ordering::equal() {\\n            result = self.2.cmp(other.2);\\n        }\\n\\n        if result == Ordering::equal() {\\n            result = self.3.cmp(other.3);\\n        }\\n\\n        if result == Ordering::equal() {\\n            result = self.4.cmp(other.4);\\n        }\\n\\n        result\\n    }\\n}\\n\\n// Compares and returns the maximum of two values.\\n//\\n// Returns the second argument if the comparison determines them to be equal.\\n//\\n// # Examples\\n//\\n// ```\\n// use std::cmp;\\n//\\n// assert_eq(cmp::max(1, 2), 2);\\n// assert_eq(cmp::max(2, 2), 2);\\n// ```\\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\\n    if v1 > v2 { v1 } else { v2 }\\n}\\n\\n// Compares and returns the minimum of two values.\\n//\\n// Returns the first argument if the comparison determines them to be equal.\\n//\\n// # Examples\\n//\\n// ```\\n// use std::cmp;\\n//\\n// assert_eq(cmp::min(1, 2), 1);\\n// assert_eq(cmp::min(2, 2), 2);\\n// ```\\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\\n    if v1 > v2 { v2 } else { v1 }\\n}\\n\\nmod cmp_tests {\\n    use crate::cmp::{min, max};\\n\\n    #[test]\\n    fn sanity_check_min() {\\n        assert_eq(min(0 as u64, 1 as u64), 0);\\n        assert_eq(min(0 as u64, 0 as u64), 0);\\n        assert_eq(min(1 as u64, 1 as u64), 1);\\n        assert_eq(min(255 as u8, 0 as u8), 0);\\n    }\\n\\n    #[test]\\n    fn sanity_check_max() {\\n        assert_eq(max(0 as u64, 1 as u64), 1);\\n        assert_eq(max(0 as u64, 0 as u64), 0);\\n        assert_eq(max(1 as u64, 1 as u64), 1);\\n        assert_eq(max(255 as u8, 0 as u8), 255);\\n    }\\n}\\n"},"22":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\\n\\n// The low and high decomposition of the field modulus\\nglobal PLO: Field = 53438638232309528389504892708671455233;\\nglobal PHI: Field = 64323764613183177041862057485226039389;\\n\\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\\n\\n// Decomposes a single field into two 16 byte fields.\\nfn compute_decomposition(x: Field) -> (Field, Field) {\\n    let x_bytes = x.to_le_bytes(32);\\n\\n    let mut low: Field = 0;\\n    let mut high: Field = 0;\\n\\n    let mut offset = 1;\\n    for i in 0..16 {\\n        low += (x_bytes[i] as Field) * offset;\\n        high += (x_bytes[i + 16] as Field) * offset;\\n        offset *= 256;\\n    }\\n\\n    (low, high)\\n}\\n\\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\\n    compute_decomposition(x)\\n}\\n\\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\\n    let x_bytes = x.to_le_radix(256, num_bytes);\\n    let y_bytes = y.to_le_radix(256, num_bytes);\\n    let mut x_is_lt = false;\\n    let mut done = false;\\n    for i in 0..num_bytes {\\n        if (!done) {\\n            let x_byte = x_bytes[num_bytes - 1 - i];\\n            let y_byte = y_bytes[num_bytes - 1 - i];\\n            let bytes_match = x_byte == y_byte;\\n            if !bytes_match {\\n                x_is_lt = x_byte < y_byte;\\n                done = true;\\n            }\\n        }\\n    }\\n    x_is_lt\\n}\\n\\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\\n    if x == y {\\n        true\\n    } else {\\n        compute_lt(x, y, num_bytes)\\n    }\\n}\\n\\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\\n    compute_lt(x, y, 32)\\n}\\n\\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\\n    compute_lte(x, y, 16)\\n}\\n\\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\\n    let (alo, ahi) = a;\\n    let (blo, bhi) = b;\\n    let borrow = lte_16_hint(alo, blo);\\n\\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\\n    let rhi = ahi - bhi - (borrow as Field);\\n\\n    rlo.assert_max_bit_size(128);\\n    rhi.assert_max_bit_size(128);\\n}\\n\\n/// Decompose a single field into two 16 byte fields.\\npub fn decompose(x: Field) -> (Field, Field) {\\n    if is_unconstrained() {\\n        compute_decomposition(x)\\n    } else {\\n        // Take hints of the decomposition\\n        let (xlo, xhi) = decompose_hint(x);\\n\\n        // Range check the limbs\\n        xlo.assert_max_bit_size(128);\\n        xhi.assert_max_bit_size(128);\\n\\n        // Check that the decomposition is correct\\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\\n\\n        // Assert that the decomposition of P is greater than the decomposition of x\\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\\n        (xlo, xhi)\\n    }\\n}\\n\\npub fn assert_gt(a: Field, b: Field) {\\n    if is_unconstrained() {\\n        assert(compute_lt(b, a, 32));\\n    } else {\\n        // Decompose a and b\\n        let a_limbs = decompose(a);\\n        let b_limbs = decompose(b);\\n\\n        // Assert that a_limbs is greater than b_limbs\\n        assert_gt_limbs(a_limbs, b_limbs)\\n    }\\n}\\n\\npub fn assert_lt(a: Field, b: Field) {\\n    assert_gt(b, a);\\n}\\n\\npub fn gt(a: Field, b: Field) -> bool {\\n    if is_unconstrained() {\\n        compute_lt(b, a, 32)\\n    } else if a == b {\\n        false\\n    } else  {\\n        // Take a hint of the comparison and verify it\\n        if lt_32_hint(a, b) {\\n            assert_gt(b, a);\\n            false\\n        } else {\\n            assert_gt(a, b);\\n            true\\n        }\\n    }\\n}\\n\\npub fn lt(a: Field, b: Field) -> bool {\\n    gt(b, a)\\n}\\n\\nmod tests {\\n    // TODO: Allow imports from \\"super\\"\\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\\n\\n    #[test]\\n    fn check_decompose() {\\n        assert_eq(decompose(TWO_POW_128), (0, 1));\\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_decompose_unconstrained() {\\n        assert_eq(decompose(TWO_POW_128), (0, 1));\\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\\n    }\\n\\n    #[test]\\n    fn check_compute_lt() {\\n        assert(compute_lt(0, 1, 16));\\n        assert(compute_lt(0, 0x100, 16));\\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\\n        assert(!compute_lt(0, TWO_POW_128, 16));\\n    }\\n\\n    #[test]\\n    fn check_compute_lte() {\\n        assert(compute_lte(0, 1, 16));\\n        assert(compute_lte(0, 0x100, 16));\\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\\n        assert(!compute_lte(0, TWO_POW_128, 16));\\n\\n        assert(compute_lte(0, 0, 16));\\n        assert(compute_lte(0x100, 0x100, 16));\\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\\n    }\\n\\n    #[test]\\n    fn check_assert_gt() {\\n        assert_gt(1, 0);\\n        assert_gt(0x100, 0);\\n        assert_gt((0 - 1), (0 - 2));\\n        assert_gt(TWO_POW_128, 0);\\n        assert_gt(0 - 1, 0);\\n    }\\n\\n    #[test]\\n    unconstrained fn check_assert_gt_unconstrained() {\\n        assert_gt(1, 0);\\n        assert_gt(0x100, 0);\\n        assert_gt((0 - 1), (0 - 2));\\n        assert_gt(TWO_POW_128, 0);\\n        assert_gt(0 - 1, 0);\\n    }\\n\\n    #[test]\\n    fn check_gt() {\\n        assert(gt(1, 0));\\n        assert(gt(0x100, 0));\\n        assert(gt((0 - 1), (0 - 2)));\\n        assert(gt(TWO_POW_128, 0));\\n        assert(!gt(0, 0));\\n        assert(!gt(0, 0x100));\\n        assert(gt(0 - 1, 0 - 2));\\n        assert(!gt(0 - 2, 0 - 1));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_gt_unconstrained() {\\n        assert(gt(1, 0));\\n        assert(gt(0x100, 0));\\n        assert(gt((0 - 1), (0 - 2)));\\n        assert(gt(TWO_POW_128, 0));\\n        assert(!gt(0, 0));\\n        assert(!gt(0, 0x100));\\n        assert(gt(0 - 1, 0 - 2));\\n        assert(!gt(0 - 2, 0 - 1));\\n    }\\n\\n    #[test]\\n    fn check_plo_phi() {\\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\\n        let p_bytes = crate::field::modulus_le_bytes();\\n        let mut p_low: Field = 0;\\n        let mut p_high: Field = 0;\\n\\n        let mut offset = 1;\\n        for i in 0..16 {\\n            p_low += (p_bytes[i] as Field) * offset;\\n            p_high += (p_bytes[i + 16] as Field) * offset;\\n            offset *= 256;\\n        }\\n        assert_eq(p_low, PLO);\\n        assert_eq(p_high, PHI);\\n    }\\n}\\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\\nuse bn254::lt as bn254_lt;\\n\\nimpl Field {\\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\\n        crate::assert_constant(bit_size);\\n        self.__to_le_bits(bit_size)\\n    }\\n\\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\\n        crate::assert_constant(bit_size);\\n        self.__to_be_bits(bit_size)\\n    }\\n\\n    #[builtin(to_le_bits)]\\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\\n\\n    #[builtin(to_be_bits)]\\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\\n\\n    #[builtin(apply_range_constraint)]\\n    fn __assert_max_bit_size(self, bit_size: u32) {}\\n\\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\\n        crate::assert_constant(bit_size);\\n        assert(bit_size < modulus_num_bits() as u32);\\n        self.__assert_max_bit_size(bit_size);\\n    }\\n\\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\\n        self.to_le_radix(256, byte_size)\\n    }\\n\\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\\n        self.to_be_radix(256, byte_size)\\n    }\\n\\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\\n        crate::assert_constant(radix);\\n        crate::assert_constant(result_len);\\n        self.__to_le_radix(radix, result_len)\\n    }\\n\\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\\n        crate::assert_constant(radix);\\n        crate::assert_constant(result_len);\\n        self.__to_be_radix(radix, result_len)\\n    }\\n\\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\\n    // `_radix` must be less than 256\\n    #[builtin(to_le_radix)]\\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\\n\\n    #[builtin(to_be_radix)]\\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\\n\\n    // Returns self to the power of the given exponent value.\\n    // Caution: we assume the exponent fits into 32 bits\\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\\n    pub fn pow_32(self, exponent: Field) -> Field {\\n        let mut r: Field = 1;\\n        let b = exponent.to_le_bits(32);\\n\\n        for i in 1..33 {\\n            r *= r;\\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\\n        }\\n        r\\n    }\\n\\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\\n    pub fn sgn0(self) -> u1 {\\n        self as u1\\n    }\\n\\n    pub fn lt(self, another: Field) -> bool {\\n        if crate::compat::is_bn254() {\\n            bn254_lt(self, another)\\n        } else {\\n            lt_fallback(self, another)\\n        }\\n    }\\n}\\n\\n#[builtin(modulus_num_bits)]\\npub fn modulus_num_bits() -> u64 {}\\n\\n#[builtin(modulus_be_bits)]\\npub fn modulus_be_bits() -> [u1] {}\\n\\n#[builtin(modulus_le_bits)]\\npub fn modulus_le_bits() -> [u1] {}\\n\\n#[builtin(modulus_be_bytes)]\\npub fn modulus_be_bytes() -> [u8] {}\\n\\n#[builtin(modulus_le_bytes)]\\npub fn modulus_le_bytes() -> [u8] {}\\n// Convert a 32 byte array to a field element by modding\\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\\n    // Convert it to a field element\\n    let mut v = 1;\\n    let mut high = 0 as Field;\\n    let mut low = 0 as Field;\\n\\n    for i in 0..16 {\\n        high = high + (bytes32[15 - i] as Field) * v;\\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\\n        v = v * 256;\\n    }\\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\\n    low + high * v\\n}\\n\\nfn lt_fallback(x: Field, y: Field) -> bool {\\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\\n    let x_bytes = x.to_le_bytes(num_bytes);\\n    let y_bytes = y.to_le_bytes(num_bytes);\\n    let mut x_is_lt = false;\\n    let mut done = false;\\n    for i in 0..num_bytes {\\n        if (!done) {\\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\\n            let bytes_match = x_byte == y_byte;\\n            if !bytes_match {\\n                x_is_lt = x_byte < y_byte;\\n                done = true;\\n            }\\n        }\\n    }\\n    x_is_lt\\n}\\n\\n"},"25":{"path":"std/hash/mod.nr","source":"mod poseidon;\\nmod mimc;\\nmod poseidon2;\\n\\nuse crate::default::Default;\\nuse crate::uint128::U128;\\nuse crate::sha256::{digest, sha256_var};\\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\\n\\n#[foreign(sha256)]\\n// docs:start:sha256\\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\\n// docs:end:sha256\\n{}\\n\\n#[foreign(blake2s)]\\n// docs:start:blake2s\\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\\n// docs:end:blake2s\\n{}\\n\\n#[foreign(blake3)]\\n// docs:start:blake3\\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\\n// docs:end:blake3\\n{}\\n\\n#[no_predicates]\\n// docs:start:pedersen_commitment\\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\\n    // docs:end:pedersen_commitment\\n    let value = pedersen_commitment_with_separator(input, 0);\\n    if (value.x == 0) & (value.y == 0) {\\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\\n    } else {\\n        EmbeddedCurvePoint { x: value.x, y: value.y, is_infinite: false }\\n    }\\n}\\n\\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\\n    for i in 0..N {\\n        points[i] = EmbeddedCurveScalar::from_field(input[i]);\\n    }\\n    let generators = derive_generators(\\"DEFAULT_DOMAIN_SEPARATOR\\".as_bytes(), separator);\\n    let values = multi_scalar_mul(generators, points);\\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: values[2] as bool }\\n}\\n\\n#[no_predicates]\\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\\n    let values = __pedersen_commitment_with_separator(input, separator);\\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\\n}\\n\\n// docs:start:pedersen_hash\\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\\n// docs:end:pedersen_hash\\n{\\n    pedersen_hash_with_separator(input, 0)\\n}\\n\\n#[field(bn254)]\\nfn derive_generators<let N: u32, let M: u32>(\\n    domain_separator_bytes: [u8; M],\\n    starting_index: u32\\n) -> [EmbeddedCurvePoint; N] {\\n    crate::assert_constant(domain_separator_bytes);\\n    crate::assert_constant(starting_index);\\n    __derive_generators(domain_separator_bytes, starting_index)\\n}\\n\\n#[builtin(derive_pedersen_generators)]\\n#[field(bn254)]\\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\\n\\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\\n    let v1 = pedersen_commitment_with_separator(input, separator);\\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\\"pedersen_hash_length\\".as_bytes(), 0);\\n    multi_scalar_mul(\\n        [length_generator[0], v1],\\n        [EmbeddedCurveScalar { lo: N as Field, hi: 0 }, EmbeddedCurveScalar { lo: 1, hi: 0 }]\\n    )[0]\\n}\\n\\n#[foreign(pedersen_hash)]\\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\\n\\n#[foreign(pedersen_commitment)]\\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\\n\\npub fn hash_to_field(inputs: [Field]) -> Field {\\n    let mut sum = 0;\\n\\n    for input in inputs {\\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\\n    }\\n\\n    sum\\n}\\n\\n#[foreign(keccak256)]\\n// docs:start:keccak256\\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\\n// docs:end:keccak256\\n{}\\n\\n#[foreign(poseidon2_permutation)]\\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\\n\\n#[foreign(sha256_compression)]\\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\\n\\n// Generic hashing support. \\n// Partially ported and impacted by rust.\\n\\n// Hash trait shall be implemented per type.\\ntrait Hash{\\n    fn hash<H>(self, state: &mut H) where H: Hasher;\\n}\\n\\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\\n// TODO: consider making the types generic here ([u8], [Field], etc.)\\ntrait Hasher{\\n    fn finish(self) -> Field;\\n    \\n    fn write(&mut self, input: Field);\\n}\\n\\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\\ntrait BuildHasher<H> where H: Hasher{\\n    fn build_hasher(self) -> H;\\n}\\n\\nstruct BuildHasherDefault<H>;\\n\\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\\nwhere \\n    H: Hasher + Default\\n{\\n    fn build_hasher(_self: Self) -> H{\\n        H::default()\\n    }\\n}\\n\\nimpl<H> Default for BuildHasherDefault<H>\\nwhere \\n    H: Hasher + Default\\n{\\n    fn default() -> Self{\\n        BuildHasherDefault{}\\n    }    \\n}\\n\\nimpl Hash for Field {\\n    fn hash<H>(self, state: &mut H) where H: Hasher{\\n        H::write(state, self);\\n    }\\n}\\n\\nimpl Hash for u8 {\\n    fn hash<H>(self, state: &mut H) where H: Hasher{\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for u32 {\\n    fn hash<H>(self, state: &mut H) where H: Hasher{\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for u64 {\\n    fn hash<H>(self, state: &mut H) where H: Hasher{\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for i8 {\\n    fn hash<H>(self, state: &mut H) where H: Hasher{\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for i32 {\\n    fn hash<H>(self, state: &mut H) where H: Hasher{\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for i64 {\\n    fn hash<H>(self, state: &mut H) where H: Hasher{\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for bool {\\n    fn hash<H>(self, state: &mut H) where H: Hasher{\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for () {\\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\\n}\\n\\nimpl Hash for U128 {\\n    fn hash<H>(self, state: &mut H) where H: Hasher{\\n        H::write(state, self.lo as Field);\\n        H::write(state, self.hi as Field);\\n    }\\n}\\n\\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\\n    fn hash<H>(self, state: &mut H) where H: Hasher{\\n        for elem in self {\\n            elem.hash(state);\\n        }\\n    }\\n}\\n\\nimpl<T> Hash for [T] where T: Hash {\\n    fn hash<H>(self, state: &mut H) where H: Hasher{\\n        self.len().hash(state);\\n        for elem in self {\\n            elem.hash(state);\\n        }\\n    }\\n}\\n\\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\\n    fn hash<H>(self, state: &mut H) where H: Hasher{\\n        self.0.hash(state);\\n        self.1.hash(state);\\n    }\\n}\\n\\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\\n    fn hash<H>(self, state: &mut H) where H: Hasher{\\n        self.0.hash(state);\\n        self.1.hash(state);\\n        self.2.hash(state);\\n    }\\n}\\n\\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\\n    fn hash<H>(self, state: &mut H) where H: Hasher{\\n        self.0.hash(state);\\n        self.1.hash(state);\\n        self.2.hash(state);\\n        self.3.hash(state);\\n    }\\n}\\n\\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\\n    fn hash<H>(self, state: &mut H) where H: Hasher{\\n        self.0.hash(state);\\n        self.1.hash(state);\\n        self.2.hash(state);\\n        self.3.hash(state);\\n        self.4.hash(state);\\n    }\\n}\\n\\n#[test]\\nfn assert_pedersen_noir() {\\n    // TODO: make this a fuzzer test once fuzzer supports curve-specific blackbox functions.\\n    let input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\\n    assert_eq(pedersen_hash_with_separator(input, 4), pedersen_hash_with_separator_noir(input, 4));\\n    assert_eq(pedersen_commitment_with_separator(input, 4), pedersen_commitment_with_separator_noir(input, 4));\\n}\\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\\nuse crate::default::Default;\\n\\nglobal RATE: u32 = 3;\\n\\nstruct Poseidon2 {\\n    cache: [Field;3],\\n    state: [Field;4],\\n    cache_size: u32,\\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2 {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        if message_size == N {\\n            Poseidon2::hash_internal(input, N, false)\\n        } else {\\n            Poseidon2::hash_internal(input, message_size, true)\\n        }\\n    }\\n\\n    fn new(iv: Field) -> Poseidon2 {\\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) -> [Field; RATE] {\\n        // zero-pad the cache\\n        for i in 0..RATE {\\n            if i >= self.cache_size {\\n                self.cache[i] = 0;\\n            }\\n        }\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            self.state[i] += self.cache[i];\\n        }\\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\\n        // return `RATE` number of field elements from the sponge state.\\n        let mut result = [0; RATE];\\n        for i in 0..RATE {\\n            result[i] = self.state[i];\\n        }\\n        result\\n    }\\n\\n    fn absorb(&mut self, input: Field) {\\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            let _ = self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        } else if self.squeeze_mode {\\n            // If we\'re in squeeze mode, switch to absorb mode and add the input into the cache.\\n            // N.B. I don\'t think this code path can be reached?!\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n            self.squeeze_mode = false;\\n        }\\n    }\\n\\n    fn squeeze(&mut self) -> Field {\\n        if self.squeeze_mode & (self.cache_size == 0) {\\n            // If we\'re in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\\n            // Switch to absorb mode.\\n            self.squeeze_mode = false;\\n            self.cache_size = 0;\\n        }\\n        if !self.squeeze_mode {\\n            // If we\'re in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\\n            // matched\\n            let new_output_elements = self.perform_duplex();\\n            self.squeeze_mode = true;\\n            for i in 0..RATE {\\n                self.cache[i] = new_output_elements[i];\\n            }\\n            self.cache_size = RATE;\\n        }\\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\\n        let result = self.cache[0];\\n        for i in 1..RATE {\\n            if i < self.cache_size {\\n                self.cache[i - 1] = self.cache[i];\\n            }\\n        }\\n        self.cache_size -= 1;\\n        self.cache[self.cache_size] = 0;\\n        result\\n    }\\n\\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\\n        let two_pow_64 = 18446744073709551616;\\n        let iv : Field = (in_len as Field) * two_pow_64;\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n\\nstruct Poseidon2Hasher{\\n    _state: [Field],\\n}\\n\\nimpl Hasher for Poseidon2Hasher {\\n    fn finish(self) -> Field {\\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..self._state.len() {\\n            sponge.absorb(self._state[i]);\\n        }\\n        sponge.squeeze()\\n    }\\n\\n    fn write(&mut self, input: Field){\\n        self._state = self._state.push_back(input);\\n    }\\n}\\n\\nimpl Default for Poseidon2Hasher {\\n    fn default() -> Self {\\n        Poseidon2Hasher {\\n            _state: &[],\\n        }\\n    }\\n}\\n"},"32":{"path":"std/merkle.nr","source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don\'t want it)\\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\\n// XXX: In the future we can add an arity parameter\\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\\n    let n = hash_path.len();\\n    let index_bits = index.to_le_bits(n as u32);\\n    let mut current = leaf;\\n    for i in 0..n {\\n        let path_bit = index_bits[i] as bool;\\n        let (hash_left, hash_right) = if path_bit {\\n            (hash_path[i], current)\\n        } else {\\n            (current, hash_path[i])\\n        };\\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\\n    }\\n    current\\n}\\n"},"47":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\\nuse crate::cmp::{Eq, Ord, Ordering};\\nuse crate::println;\\n\\nglobal pow64 : Field = 18446744073709551616; //2^64;\\nglobal pow63 : Field = 9223372036854775808; // 2^63;\\nstruct U128 {\\n    lo: Field,\\n    hi: Field,\\n}\\n\\nimpl U128 {\\n\\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\\n        assert(crate::field::modulus_num_bits() as u32 > 128);\\n        U128 { lo: lo as Field, hi: hi as Field }\\n    }\\n\\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\\n        U128::from_u64s_le(lo, hi)\\n    }\\n\\n    pub fn zero() -> U128 {\\n        U128 { lo: 0, hi: 0 }\\n    }\\n\\n    pub fn one() -> U128 {\\n        U128 { lo: 1, hi: 0 }\\n    }\\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\\n        let mut lo = 0;\\n        let mut base = 1;\\n        for i in 0..8 {\\n            lo += (bytes[i] as Field)*base;\\n            base *= 256;\\n        }\\n        let mut hi = 0;\\n        base = 1;\\n        for i in 8..16 {\\n            hi += (bytes[i] as Field)*base;\\n            base *= 256;\\n        }\\n        U128 { lo, hi }\\n    }\\n\\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\\n        let lo = self.lo.to_be_bytes(8);\\n        let hi = self.hi.to_be_bytes(8);\\n        let mut bytes = [0; 16];\\n        for i in 0..8 {\\n            bytes[i] = hi[i];\\n            bytes[i+8] = lo[i];\\n        }\\n        bytes\\n    }\\n\\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\\n        let lo = self.lo.to_le_bytes(8);\\n        let hi = self.hi.to_le_bytes(8);\\n        let mut bytes = [0; 16];\\n        for i in 0..8 {\\n            bytes[i] = lo[i];\\n            bytes[i+8] = hi[i];\\n        }\\n        bytes\\n    }\\n\\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\\n        let N = N as u32;\\n        let bytes = hex.as_bytes();\\n        // string must starts with \\"0x\\"\\n        assert((bytes[0] == 48) & (bytes[1] == 120), \\"Invalid hexadecimal string\\");\\n        assert(N < 35, \\"Input does not fit into a U128\\");\\n\\n        let mut lo = 0;\\n        let mut hi = 0;\\n        let mut base = 1;\\n        if N <= 18 {\\n            for i in 0..N - 2 {\\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\\n                base = base*16;\\n            }\\n        } else {\\n            for i in 0..16 {\\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\\n                base = base*16;\\n            }\\n            base = 1;\\n            for i in 17..N - 1 {\\n                hi += U128::decode_ascii(bytes[N-i])*base;\\n                base = base*16;\\n            }\\n        }\\n        U128 { lo: lo as Field, hi: hi as Field }\\n    }\\n\\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\\n        ((ascii >= 65) & (ascii <= 90)) // Between \'A\' and \'Z\'\\n    }\\n\\n    fn decode_ascii(ascii: u8) -> Field {\\n        if ascii < 58 {\\n            ascii - 48\\n        } else {\\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\\n            assert(ascii >= 97); // enforce >= \'a\'\\n            assert(ascii <= 102); // enforce <= \'f\'\\n            ascii - 87\\n        } as Field\\n    }\\n\\n    // TODO: Replace with a faster version. \\n    // A circuit that uses this function can be slow to compute\\n    // (we\'re doing up to 127 calls to compute the quotient)\\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\\n        if b == U128::zero() {\\n            // Return 0,0 to avoid eternal loop\\n            (U128::zero(), U128::zero())\\n        } else if self < b {\\n            (U128::zero(), self)\\n        } else if self == b {\\n            (U128::one(), U128::zero())\\n        } else {\\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\\n                // The result of multiplication by 2 would overflow\\n                (U128::zero(), self)\\n            } else {\\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\\n            };\\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\\n            if r < b {\\n                (q_mul_2, r)\\n            } else {\\n                (q_mul_2 + U128::one(), r - b)\\n            }\\n        }\\n    }\\n\\n    pub fn from_integer<T>(i: T) -> U128 {\\n        let f = crate::as_field(i);\\n        // Reject values which would overflow a u128\\n        f.assert_max_bit_size(128);\\n        let lo = f as u64 as Field;\\n        let hi = (f - lo) / pow64;\\n        U128 { lo, hi }\\n    }\\n\\n    pub fn to_integer<T>(self) -> T {\\n        crate::from_field(self.lo + self.hi * pow64)\\n    }\\n\\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\\n        let low = self.lo * b.lo;\\n        let lo = low as u64 as Field;\\n        let carry = (low - lo) / pow64;\\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\\n        let hi = high as u64 as Field;\\n        U128 { lo, hi }\\n    }\\n}\\n\\nimpl Add for U128 {\\n    fn add(self: Self, b: U128) -> U128 {\\n        let low = self.lo + b.lo;\\n        let lo = low as u64 as Field;\\n        let carry = (low - lo) / pow64;  \\n        let high = self.hi + b.hi + carry;\\n        let hi = high as u64 as Field;\\n        assert(hi == high, \\"attempt to add with overflow\\");\\n        U128 {\\n            lo,\\n            hi,\\n        }\\n    }\\n}\\n\\nimpl Sub for U128 {\\n    fn sub(self: Self, b: U128) -> U128 {\\n        let low = pow64 + self.lo - b.lo;\\n        let lo = low as u64 as Field;\\n        let borrow = (low == lo) as Field;\\n        let high = self.hi - b.hi - borrow;\\n        let hi = high as u64 as Field;\\n        assert(hi == high, \\"attempt to subtract with underflow\\");\\n        U128 {\\n            lo,\\n            hi,\\n        }\\n    }\\n}\\n\\nimpl Mul for U128 {\\n    fn mul(self: Self, b: U128) -> U128 {\\n        assert(self.hi*b.hi == 0, \\"attempt to multiply with overflow\\");\\n        let low = self.lo*b.lo;\\n        let lo = low as u64 as Field;\\n        let carry = (low - lo) / pow64;\\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\\n        } else {\\n            self.lo*b.hi + self.hi*b.lo + carry\\n        };\\n        let hi = high as u64 as Field;\\n        assert(hi == high, \\"attempt to multiply with overflow\\");\\n        U128 {\\n            lo,\\n            hi,\\n        }\\n    }\\n}\\n\\nimpl Div for U128 {\\n    fn div(self: Self, b: U128) -> U128 {\\n        let (q,r) = self.unconstrained_div(b);\\n        let a = b * q + r;\\n        assert_eq(self, a);\\n        assert(r < b);\\n        q\\n    }\\n}\\n\\nimpl Rem for U128 {\\n    fn rem(self: Self, b: U128) -> U128 {\\n        let (q,r) = self.unconstrained_div(b);\\n        let a = b * q + r;\\n        assert_eq(self, a);\\n        assert(r < b);\\n        r\\n    }\\n}\\n\\nimpl Eq for U128 {\\n    fn eq(self: Self, b: U128) -> bool {\\n        (self.lo == b.lo) & (self.hi == b.hi)\\n    }\\n}\\n\\nimpl Ord for U128 {\\n    fn cmp(self, other: Self) -> Ordering {\\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\\n        \\n        if hi_ordering == Ordering::equal() {\\n            lo_ordering\\n        } else {\\n            hi_ordering\\n        }\\n    }\\n}\\n\\nimpl Not for U128 { \\n    fn not(self) -> U128 {\\n        U128 {\\n            lo: (!(self.lo as u64)) as Field,\\n            hi: (!(self.hi as u64)) as Field\\n        }\\n    }\\n}\\n\\nimpl BitOr for U128 { \\n    fn bitor(self, other: U128) -> U128 {\\n        U128 {\\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\\n        }\\n    }\\n}\\n\\nimpl BitAnd for U128 {\\n    fn bitand(self, other: U128) -> U128 { \\n        U128 {\\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\\n        }\\n    }\\n}\\n\\nimpl BitXor for U128 {\\n    fn bitxor(self, other: U128) -> U128 { \\n        U128 {\\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\\n        }\\n    }\\n}\\n\\nimpl Shl for U128 { \\n    fn shl(self, other: u8) -> U128 { \\n        assert(other < 128, \\"attempt to shift left with overflow\\");\\n        let exp_bits = (other as Field).to_be_bits(7);\\n\\n        let mut r: Field = 2;\\n        let mut y: Field = 1;\\n        for i in 1..8 {\\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\\n            r *= r;\\n        }\\n        self.wrapping_mul(U128::from_integer(y))\\n    } \\n}\\n\\nimpl Shr for U128 { \\n    fn shr(self, other: u8) -> U128 { \\n        assert(other < 128, \\"attempt to shift right with overflow\\");\\n        let exp_bits = (other as Field).to_be_bits(7);\\n\\n        let mut r: Field = 2;\\n        let mut y: Field = 1;\\n        for i in 1..8 {\\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\\n            r *= r;\\n        }\\n        self / U128::from_integer(y)\\n    } \\n}\\n\\nmod tests {\\n    use crate::uint128::{U128, pow64, pow63};\\n\\n    #[test]\\n    fn test_not(lo: u64, hi: u64) {\\n        let num = U128::from_u64s_le(lo, hi);\\n        let not_num = num.not();\\n\\n        assert_eq(not_num.hi, (hi.not() as Field));\\n        assert_eq(not_num.lo, (lo.not() as Field));\\n\\n        let not_not_num = not_num.not();\\n        assert_eq(num, not_not_num);\\n    }\\n    #[test]\\n    fn test_construction() {\\n        // Check little-endian u64 is inversed with big-endian u64 construction\\n        let a = U128::from_u64s_le(2, 1);\\n        let b = U128::from_u64s_be(1, 2);\\n        assert_eq(a, b);\\n        // Check byte construction is equivalent\\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\\n        assert_eq(c, d);\\n    }\\n    #[test]\\n    fn test_byte_decomposition() {\\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\\n        // Get big-endian and little-endian byte decompostions\\n        let le_bytes_a= a.to_le_bytes();\\n        let be_bytes_a= a.to_be_bytes();\\n\\n        // Check equivalence\\n        for i in 0..16 {\\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\\n        }\\n        // Reconstruct U128 from byte decomposition\\n        let b= U128::from_le_bytes(le_bytes_a);\\n        // Check that it\'s the same element\\n        assert_eq(a, b);\\n    }\\n    #[test]\\n    fn test_hex_constuction() {\\n        let a = U128::from_u64s_le(0x1, 0x2);\\n        let b = U128::from_hex(\\"0x20000000000000001\\");\\n        assert_eq(a, b);\\n\\n        let c= U128::from_hex(\\"0xffffffffffffffffffffffffffffffff\\");\\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\\n        assert_eq(c, d);\\n\\n        let e= U128::from_hex(\\"0x00000000000000000000000000000000\\");\\n        let f= U128::from_u64s_le(0, 0);\\n        assert_eq(e, f);\\n    }\\n\\n    // Ascii decode tests\\n\\n    #[test]\\n    fn test_ascii_decode_correct_range() {\\n        // \'0\'..\'9\' range\\n        for i in 0..10 {\\n            let decoded= U128::decode_ascii(48 + i);\\n            assert_eq(decoded, i as Field);\\n        }\\n        // \'A\'..\'F\' range\\n        for i in 0..6 {\\n            let decoded = U128::decode_ascii(65 + i);\\n            assert_eq(decoded, (i + 10) as Field);\\n        }\\n        // \'a\'..\'f\' range\\n        for i in 0..6 {\\n            let decoded = U128::decode_ascii(97 + i);\\n            assert_eq(decoded, (i + 10) as Field);\\n        }\\n    }\\n\\n    #[test(should_fail)]\\n    fn test_ascii_decode_range_less_than_48_fails_0() {\\n        crate::println(U128::decode_ascii(0));\\n    }\\n    #[test(should_fail)]\\n    fn test_ascii_decode_range_less_than_48_fails_1() {\\n        crate::println(U128::decode_ascii(47));\\n    }\\n\\n    #[test(should_fail)]\\n    fn test_ascii_decode_range_58_64_fails_0() {\\n        let _ = U128::decode_ascii(58);\\n    }\\n    #[test(should_fail)]\\n    fn test_ascii_decode_range_58_64_fails_1() {\\n        let _ = U128::decode_ascii(64);\\n    }\\n    #[test(should_fail)]\\n    fn test_ascii_decode_range_71_96_fails_0() {\\n        let _ = U128::decode_ascii(71);\\n    }\\n    #[test(should_fail)]\\n    fn test_ascii_decode_range_71_96_fails_1() {\\n        let _ = U128::decode_ascii(96);\\n    }\\n    #[test(should_fail)]\\n    fn test_ascii_decode_range_greater_than_102_fails() {\\n        let _ = U128::decode_ascii(103);\\n    }\\n\\n    #[test(should_fail)]\\n    fn test_ascii_decode_regression() {\\n        // This code will actually fail because of ascii_decode,\\n        // but in the past it was possible to create a value > (1<<128)\\n        let a = U128::from_hex(\\"0x~fffffffffffffffffffffffffffffff\\");\\n        let b:Field= a.to_integer();\\n        let c= b.to_le_bytes(17);\\n        assert(c[16] != 0);\\n    }\\n\\n    #[test]\\n    fn test_unconstrained_div() {\\n        // Test the potential overflow case\\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\\n        let c= U128::one();\\n        let d= U128::from_u64s_le(0x0, 0x1);\\n        let (q,r) = a.unconstrained_div(b);\\n        assert_eq(q, c);\\n        assert_eq(r, d);\\n\\n        let a = U128::from_u64s_le(2, 0);\\n        let b = U128::one();\\n        // Check the case where a is a multiple of b\\n        let (c,d ) = a.unconstrained_div(b);\\n        assert_eq((c, d), (a, U128::zero()));\\n\\n        // Check where b is a multiple of a\\n        let (c,d) = b.unconstrained_div(a);\\n        assert_eq((c, d), (U128::zero(), b));\\n\\n        // Dividing by zero returns 0,0\\n        let a = U128::from_u64s_le(0x1, 0x0);\\n        let b = U128::zero();\\n        let (c,d)= a.unconstrained_div(b);\\n        assert_eq((c, d), (U128::zero(), U128::zero()));\\n\\n        // Dividing 1<<127 by 1<<127 (special case)\\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\\n        let (c,d )= a.unconstrained_div(b);\\n        assert_eq((c, d), (U128::one(), U128::zero()));\\n    }\\n\\n    #[test]\\n    fn integer_conversions() {\\n        // Maximum\\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\\n        let a = U128::from_integer(start);\\n        let end = a.to_integer();\\n        assert_eq(start, end);\\n\\n        // Minimum\\n        let start:Field = 0x0;\\n        let a = U128::from_integer(start);\\n        let end = a.to_integer();\\n        assert_eq(start, end);\\n\\n        // Low limb\\n        let start:Field = 0xffffffffffffffff;\\n        let a = U128::from_integer(start);\\n        let end = a.to_integer();\\n        assert_eq(start, end);\\n\\n        // High limb\\n        let start:Field = 0xffffffffffffffff0000000000000000;\\n        let a = U128::from_integer(start);\\n        let end = a.to_integer();\\n        assert_eq(start, end);\\n    }\\n\\n    #[test]\\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\\n        let a = U128::from_integer(start);\\n        let end = a.to_integer();\\n        assert_eq(start, end);\\n    }\\n\\n    #[test]\\n    fn test_wrapping_mul() {\\n        // 1*0==0\\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\\n\\n        // 0*1==0\\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\\n\\n        // 1*1==1\\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\\n\\n        // 0 * ( 1 << 64 ) ==  0\\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\\n\\n        // ( 1 << 64 ) * 0 == 0\\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\\n\\n        // 1 * ( 1 << 64 ) == 1 << 64\\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\\n\\n        // ( 1 << 64 ) * 1 == 1 << 64\\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\\n\\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\\n        // -1 * -1 == 1\\n        assert_eq(\\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\\n        );\\n    }\\n}\\n"},"80":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\\n    header::Header, utils::field::full_field_less_than\\n};\\nuse std::merkle::compute_merkle_root;\\n\\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\\n\\ntrait PublicStorageHistoricalRead {\\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\\n}\\n\\nimpl PublicStorageHistoricalRead for Header { \\n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\\n        let public_value_leaf_slot = pedersen_hash(\\n            [contract_address.to_field(), storage_slot],\\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\\n        );\\n\\n        // 2) Get the membership witness of the slot\\n        let witness = get_public_data_witness(\\n            self.global_variables.block_number as u32,\\n            public_value_leaf_slot\\n        );\\n\\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\\n        let preimage = witness.leaf_preimage;\\n\\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\\n        // 1. The value is the same as the one in the witness\\n        // 2. The value was never initialized and is zero\\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\\n\\n        let value = if is_in_range {\\n            0\\n        } else {\\n            assert_eq(preimage.slot, public_value_leaf_slot, \\"Public data slot doesn\'t match witness\\");\\n            preimage.value\\n        };\\n\\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\\n        // but also the metadata (slot, next index and next slot).\\n        assert(\\n            self.state.partial.public_data_tree.root\\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \\"Proving public value inclusion failed\\"\\n        );\\n\\n        value\\n    }\\n}\\n"},"86":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/messaging.nr","source":"use crate::{\\n    hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier},\\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness\\n};\\n\\nuse std::merkle::compute_merkle_root;\\nuse dep::protocol_types::{constants::L1_TO_L2_MSG_TREE_HEIGHT, address::{AztecAddress, EthAddress}, utils::arr_copy_slice};\\n\\npub fn process_l1_to_l2_message(\\n    l1_to_l2_root: Field,\\n    storage_contract_address: AztecAddress,\\n    portal_contract_address: EthAddress,\\n    chain_id: Field,\\n    version: Field,\\n    content: Field,\\n    secret: Field\\n) -> Field {\\n    let secret_hash = compute_secret_hash(secret);\\n    let message_hash = compute_message_hash(\\n        portal_contract_address,\\n        chain_id,\\n        storage_contract_address,\\n        version,\\n        content,\\n        secret_hash\\n    );\\n\\n    let returned_message = get_l1_to_l2_membership_witness(storage_contract_address, message_hash, secret);\\n    let leaf_index = returned_message[0];\\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\\n\\n    // Check that the message is in the tree\\n    // This is implicitly checking that the values of the message are correct\\n    let root = compute_merkle_root(message_hash, leaf_index, sibling_path);\\n    assert(root == l1_to_l2_root, \\"Message not in state\\");\\n\\n    compute_message_nullifier(message_hash, secret, leaf_index)\\n}\\n"},"89":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\\nuse dep::protocol_types::traits::Deserialize;\\n\\nstruct PackedReturns {\\n  packed_returns: Field,\\n}\\n\\nimpl PackedReturns {\\n    pub fn new(packed_returns: Field) -> Self {\\n        PackedReturns { packed_returns }\\n    }\\n\\n    pub fn assert_empty(self) {\\n        assert_eq(self.packed_returns, 0);\\n    }\\n\\n    pub fn raw(self) -> Field {\\n        self.packed_returns\\n    }\\n\\n    pub fn unpack<N>(self) -> [Field; N] {\\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\\n        unpacked\\n    }\\n\\n    pub fn unpack_into<T, N>(self) -> T where T: Deserialize<N> {\\n        let unpacked: [Field; N] = self.unpack();\\n        Deserialize::deserialize(unpacked)\\n    }\\n}\\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\\n    address::AztecAddress, traits::Deserialize\\n};\\n\\nuse crate::context::{\\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\\n};\\n\\nuse crate::oracle::arguments::pack_arguments;\\nuse crate::hash::hash_args;\\n\\ntrait CallInterface<N, T, P, Env> {\\n    fn get_original(self) -> fn[Env](T) -> P;\\n\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\\n        self.original\\n    }\\n}\\n\\nstruct PrivateCallInterface<N, T, Env> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\\n    is_static: bool\\n}\\n\\nimpl<N, T, Env> PrivateCallInterface<N, T, Env> {\\n    pub fn call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\\n        assert(self.args_hash == pack_arguments(self.args));\\n        let returns = context.call_private_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            false,\\n            false\\n        );\\n        let unpacked: T = returns.unpack_into();\\n        unpacked\\n    }\\n\\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\\n        assert(self.args_hash == pack_arguments(self.args));\\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\\n        returns.unpack_into()\\n    }\\n\\n    pub fn delegate_call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\\n        assert(self.args_hash == pack_arguments(self.args));\\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\\n        returns.unpack_into()\\n    }\\n}\\n\\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\\n        self.original\\n    }\\n}\\n\\nstruct PrivateVoidCallInterface<N, Env> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\\n    is_static: bool\\n}\\n\\nimpl<N, Env> PrivateVoidCallInterface<N, Env> {\\n    pub fn call(self, context: &mut PrivateContext) {\\n        assert(self.args_hash == pack_arguments(self.args));\\n        context.call_private_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            false,\\n            false\\n        ).assert_empty();\\n    }\\n\\n    pub fn view(self, context: &mut PrivateContext) {\\n        assert(self.args_hash == pack_arguments(self.args));\\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\\n    }\\n\\n    pub fn delegate_call(self, context: &mut PrivateContext) {\\n        assert(self.args_hash == pack_arguments(self.args));\\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\\n    }\\n}\\n\\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\\n        self.original\\n    }\\n}\\n\\nstruct PrivateStaticCallInterface<N, T, Env> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\\n    is_static: bool\\n}\\n\\nimpl<N, T, Env> PrivateStaticCallInterface<N, T, Env> {\\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\\n        assert(self.args_hash == pack_arguments(self.args));\\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\\n        returns.unpack_into()\\n    }\\n}\\n\\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\\n        self.original\\n    }\\n}\\n\\nstruct PrivateStaticVoidCallInterface<N, Env> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args_hash: Field,\\n    args: [Field],\\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\\n    is_static: bool\\n}\\n\\nimpl<N, Env> PrivateStaticVoidCallInterface<N, Env> {\\n    pub fn view(self, context: &mut PrivateContext) {\\n        assert(self.args_hash == pack_arguments(self.args));\\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\\n    }\\n}\\n\\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\\n        self.original\\n    }\\n}\\n\\nstruct PublicCallInterface<N, T, Env> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    gas_opts: GasOpts,\\n    original: fn[Env](PublicContextInputs) -> T,\\n    is_static: bool\\n}\\n\\nimpl<N, T, Env> PublicCallInterface<N, T, Env> {\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub fn call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\\n        returns.deserialize_into()\\n    }\\n\\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\\n        returns.deserialize_into()\\n    }\\n\\n    pub fn delegate_call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\\n        returns.deserialize_into()\\n    }\\n\\n    pub fn enqueue(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        assert(args_hash == pack_arguments(self.args));\\n        context.call_public_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/ false,\\n            /*delegate=*/ false\\n        )\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        assert(args_hash == pack_arguments(self.args));\\n        context.call_public_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/ true,\\n            /*delegate=*/ false\\n        )\\n    }\\n\\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        assert(args_hash == pack_arguments(self.args));\\n        context.call_public_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/ false,\\n            /*delegate=*/ true\\n        )\\n    }\\n}\\n\\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\\n        self.original\\n    }\\n}\\n\\nstruct PublicVoidCallInterface<N, Env> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    original: fn[Env](PublicContextInputs) -> (),\\n    is_static: bool,\\n    gas_opts: GasOpts\\n}\\n\\nimpl<N, Env> PublicVoidCallInterface<N, Env> {\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub fn call(self, context: &mut PublicContext) {\\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\\n        returns.assert_empty()\\n    }\\n\\n    pub fn view(self, context: &mut PublicContext) {\\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\\n        returns.assert_empty()\\n    }\\n\\n    pub fn delegate_call(self, context: &mut PublicContext) {\\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\\n        returns.assert_empty()\\n    }\\n\\n    pub fn enqueue(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        assert(args_hash == pack_arguments(self.args));\\n        context.call_public_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/ false,\\n            /*delegate=*/ false\\n        )\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        assert(args_hash == pack_arguments(self.args));\\n        context.call_public_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/ true,\\n            /*delegate=*/ false\\n        )\\n    }\\n\\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        assert(args_hash == pack_arguments(self.args));\\n        context.call_public_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/ false,\\n            /*delegate=*/ true\\n        )\\n    }\\n}\\n\\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\\n        self.original\\n    }\\n}\\n\\nstruct PublicStaticCallInterface<N, T, Env> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    original: fn[Env](PublicContextInputs) -> T,\\n    is_static: bool,\\n    gas_opts: GasOpts\\n}\\n\\nimpl<N, T, Env> PublicStaticCallInterface<N, T, Env> {\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\\n        let unpacked: T = returns.deserialize_into();\\n        unpacked\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        assert(args_hash == pack_arguments(self.args));\\n        context.call_public_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/ true,\\n            /*delegate=*/ false\\n        )\\n    }\\n}\\n\\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\\n        self.original\\n    }\\n}\\n\\nstruct PublicStaticVoidCallInterface<N, Env> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    original: fn[Env](PublicContextInputs) -> (),\\n    is_static: bool,\\n    gas_opts: GasOpts\\n}\\n\\nimpl<N, Env> PublicStaticVoidCallInterface<N, Env> {\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub fn view(self, context: &mut PublicContext) {\\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\\n        returns.assert_empty()\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        assert(args_hash == pack_arguments(self.args));\\n        context.call_public_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/ true,\\n            /*delegate=*/ false\\n        )\\n    }\\n}\\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\\n    oracle::{\\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\\n    call_private_function::call_private_function_internal, header::get_header_at,\\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\\n    enqueue_public_function_call::{\\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\\n    parse_public_call_stack_item_from_oracle\\n}\\n}\\n};\\nuse dep::protocol_types::{\\n    abis::{\\n    caller_context::CallerContext, function_selector::FunctionSelector,\\n    max_block_number::MaxBlockNumber,\\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\\n},\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\\n},\\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\\n};\\n\\n// When finished, one can call .finish() to convert back to the abi\\nstruct PrivateContext {\\n    // docs:start:private-context\\n    inputs: PrivateContextInputs,\\n    side_effect_counter: u32,\\n\\n    min_revertible_side_effect_counter: u32,\\n    is_fee_payer: bool,\\n\\n    args_hash: Field,\\n    return_hash: Field,\\n\\n    max_block_number: MaxBlockNumber,\\n\\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\\n\\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\\n\\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\\n    public_teardown_function_hash: Field,\\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\\n    // docs:end:private-context\\n\\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\\n    historical_header: Header,\\n\\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\\n\\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\\n    // fetching the same request multiple times.\\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\\n}\\n\\nimpl PrivateContext {\\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\\n        PrivateContext {\\n            inputs,\\n            side_effect_counter: inputs.start_side_effect_counter + 1,\\n            min_revertible_side_effect_counter: 0,\\n            is_fee_payer: false,\\n            args_hash,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            historical_header: inputs.historical_header,\\n            private_call_requests: BoundedVec::new(),\\n            public_call_stack_hashes: BoundedVec::new(),\\n            public_teardown_function_hash: 0,\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            note_encrypted_logs_hashes: BoundedVec::new(),\\n            encrypted_logs_hashes: BoundedVec::new(),\\n            unencrypted_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\\n        }\\n    }\\n\\n    fn msg_sender(self) -> AztecAddress {\\n        self.inputs.call_context.msg_sender\\n    }\\n\\n    fn this_address(self) -> AztecAddress {\\n        self.inputs.call_context.storage_contract_address\\n    }\\n\\n    fn chain_id(self) -> Field {\\n        self.inputs.tx_context.chain_id\\n    }\\n\\n    fn version(self) -> Field {\\n        self.inputs.tx_context.version\\n    }\\n\\n    fn selector(self) -> FunctionSelector {\\n        self.inputs.call_context.function_selector\\n    }\\n\\n    fn get_args_hash(self) -> Field {\\n        self.args_hash\\n    }\\n\\n    fn push_note_hash(&mut self, note_hash: Field) {\\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\\n    }\\n\\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\\n    // - consider creating a separate function with 1 arg for the zero note hash case.\\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\\n    }\\n\\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\\n    // included in).\\n    fn get_header(self) -> Header {\\n        self.historical_header\\n    }\\n\\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\\n    // of historical header.\\n    pub fn get_header_at(self, block_number: u32) -> Header {\\n        get_header_at(block_number, self)\\n    }\\n\\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\\n        pack_returns(returns_hasher.fields);\\n        self.return_hash = returns_hasher.hash();\\n    }\\n\\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\\n        PrivateCircuitPublicInputs {\\n            call_context: self.inputs.call_context,\\n            args_hash: self.args_hash,\\n            returns_hash: self.return_hash,\\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\\n            is_fee_payer: self.is_fee_payer,\\n            max_block_number: self.max_block_number,\\n            note_hash_read_requests: self.note_hash_read_requests.storage,\\n            nullifier_read_requests: self.nullifier_read_requests.storage,\\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\\n            note_hashes: self.note_hashes.storage,\\n            nullifiers: self.nullifiers.storage,\\n            private_call_requests: self.private_call_requests.storage,\\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\\n            public_teardown_function_hash: self.public_teardown_function_hash,\\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\\n            end_side_effect_counter: self.side_effect_counter,\\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\\n            historical_header: self.historical_header,\\n            tx_context: self.inputs.tx_context\\n        }\\n    }\\n\\n    pub fn set_as_fee_payer(&mut self) {\\n        dep::protocol_types::debug_log::debug_log_format(\\"Setting {0} as fee payer\\", [self.this_address().to_field()]);\\n        self.is_fee_payer = true;\\n    }\\n\\n    pub fn end_setup(&mut self) {\\n        // dep::protocol_types::debug_log::debug_log_format(\\n        //     \\"Ending setup at counter {0}\\",\\n        //     [self.side_effect_counter as Field]\\n        // );\\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\\n    }\\n\\n    // docs:start:max-block-number\\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\\n        // docs:end:max-block-number\\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\\n    }\\n\\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\\n        self.note_hash_read_requests.push(side_effect);\\n    }\\n\\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\\n        self.nullifier_read_requests.push(request);\\n    }\\n\\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\\n    }\\n\\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\\n    }\\n\\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\\n\\n        if cached_request.pk_m.hash() == pk_m_hash {\\n            // We get a match so the cached request is the latest one \\n            cached_request.sk_app\\n        } else {\\n            // We didn\'t get a match meaning the cached result is stale. We fetch new values from oracle and instruct\\n            // protocol circuits to validate them by storing the validation request in context.\\n            let request = get_key_validation_request(pk_m_hash, key_index);\\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\\n            // valid key request and not the one corresponding to pk_m_hash).\\n            assert(request.pk_m.hash() == pk_m_hash);\\n            self.key_validation_requests_and_generators.push(request_and_generator);\\n            self.last_key_validation_requests[key_index] = Option::some(request);\\n            request.sk_app\\n        }\\n    }\\n\\n    // docs:start:context_message_portal\\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\\n        // docs:end:context_message_portal\\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\\n        self.l2_to_l1_msgs.push(message);\\n    }\\n\\n    // docs:start:context_consume_l1_to_l2_message\\n    // docs:start:consume_l1_to_l2_message\\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\\n        // docs:end:context_consume_l1_to_l2_message\\n        let nullifier = process_l1_to_l2_message(\\n            self.historical_header.state.l1_to_l2_message_tree.root,\\n            self.this_address(),\\n            sender,\\n            self.chain_id(),\\n            self.version(),\\n            content,\\n            secret\\n        );\\n\\n        // Push nullifier (and the \\"commitment\\" corresponding to this can be \\"empty\\")\\n        self.push_nullifier(nullifier, 0)\\n    }\\n    // docs:end:consume_l1_to_l2_message\\n\\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\\n    // used in siloing later on e.g. \'handshaking\' contract w/ known address.\\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\\n        let counter = self.next_counter();\\n        let contract_address = self.this_address();\\n        let len = log.len() as Field + 4;\\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\\n        self.encrypted_logs_hashes.push(side_effect);\\n\\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\\n    }\\n\\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\\n        let counter = self.next_counter();\\n        let len = log.len() as Field + 4;\\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\\n        self.note_encrypted_logs_hashes.push(side_effect);\\n\\n        emit_encrypted_note_log(note_hash_counter, log, counter);\\n    }\\n\\n    pub fn call_private_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) -> PackedReturns {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\\n    }\\n\\n    pub fn static_call_private_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) -> PackedReturns {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\\n    }\\n\\n    pub fn delegate_call_private_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) -> PackedReturns {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\\n    }\\n\\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) -> PackedReturns {\\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\\n    }\\n\\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) -> PackedReturns {\\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\\n    }\\n\\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) -> PackedReturns {\\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\\n    }\\n\\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n        is_delegate_call: bool\\n    ) -> PackedReturns {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let start_side_effect_counter = self.side_effect_counter;\\n        let item = call_private_function_internal(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            start_side_effect_counter,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\\n        self.side_effect_counter = end_side_effect_counter + 1;\\n\\n        // TODO (fees) figure out why this crashes the prover and enable it\\n        // we need this in order to pay fees inside child call contexts\\n        // assert(\\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\\n        //     | (item.public_inputs.min_revertible_side_effect_counter\\n        //         > self.min_revertible_side_effect_counter)\\n        // );\\n\\n        // if item.public_inputs.min_revertible_side_effect_counter\\n        //     > self.min_revertible_side_effect_counter {\\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\\n        // }\\n\\n        assert(contract_address.eq(item.contract_address));\\n        assert(function_selector.eq(item.function_data.selector));\\n\\n        assert(args_hash == item.public_inputs.args_hash);\\n\\n        // Assert that the call context of the call generated by the oracle matches our request.\\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\\n\\n        if (is_delegate_call) {\\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\\n            assert(\\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\\n            );\\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\\n        } else {\\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\\n            assert(\\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\\n            );\\n        }\\n\\n        let mut caller_context = CallerContext::empty();\\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\\n        if is_delegate_call {\\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\\n        }\\n        self.private_call_requests.push(\\n            PrivateCallRequest {\\n            target: item.contract_address,\\n            call_context: item.public_inputs.call_context,\\n            function_data: item.function_data,\\n            args_hash: item.public_inputs.args_hash,\\n            returns_hash: item.public_inputs.returns_hash,\\n            caller_context,\\n            start_side_effect_counter,\\n            end_side_effect_counter\\n        }\\n        );\\n\\n        PackedReturns::new(item.public_inputs.returns_hash)\\n    }\\n\\n    pub fn call_public_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\\n    }\\n\\n    pub fn static_call_public_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\\n    }\\n\\n    pub fn delegate_call_public_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\\n    }\\n\\n    pub fn call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) {\\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\\n    }\\n\\n    pub fn static_call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) {\\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\\n    }\\n\\n    pub fn delegate_call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector\\n    ) {\\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\\n    }\\n\\n    pub fn call_public_function_with_packed_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n        is_delegate_call: bool\\n    ) {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let fields = enqueue_public_function_call_internal(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            self.side_effect_counter,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        let item = parse_public_call_stack_item_from_oracle(fields);\\n        self.validate_call_stack_item_from_oracle(\\n            item,\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        self.side_effect_counter = self.side_effect_counter + 1;\\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\\n    }\\n\\n    pub fn set_public_teardown_function<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT]\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        assert(args_hash == arguments::pack_arguments_array(args));\\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\\n    }\\n\\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n        is_delegate_call: bool\\n    ) {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let fields = set_public_teardown_function_call_internal(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            self.side_effect_counter,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        let item = parse_public_call_stack_item_from_oracle(fields);\\n        self.validate_call_stack_item_from_oracle(\\n            item,\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            is_static_call,\\n            is_delegate_call\\n        );\\n\\n        self.side_effect_counter = self.side_effect_counter + 1;\\n        self.public_teardown_function_hash = item.get_compressed().hash();\\n    }\\n\\n    fn validate_call_stack_item_from_oracle(\\n        self,\\n        item: PublicCallStackItem,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n        is_delegate_call: bool\\n    ) {\\n        assert(contract_address.eq(item.contract_address));\\n        assert(function_selector.eq(item.function_data.selector));\\n\\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\\n\\n        assert(args_hash == item.public_inputs.args_hash);\\n\\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\\n\\n        if (is_delegate_call) {\\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\\n            assert(\\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\\n            );\\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\\n        } else {\\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\\n            assert(\\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\\n            );\\n        }\\n    }\\n\\n    fn next_counter(&mut self) -> u32 {\\n        let counter = self.side_effect_counter;\\n        self.side_effect_counter += 1;\\n        counter\\n    }\\n}\\n\\nimpl Empty for PrivateContext {\\n    fn empty() -> Self {\\n        PrivateContext {\\n            inputs: PrivateContextInputs::empty(),\\n            side_effect_counter: 0 as u32,\\n            min_revertible_side_effect_counter: 0 as u32,\\n            is_fee_payer: false,\\n            args_hash: 0,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            private_call_requests: BoundedVec::new(),\\n            public_call_stack_hashes: BoundedVec::new(),\\n            public_teardown_function_hash: 0,\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            historical_header: Header::empty(),\\n            note_encrypted_logs_hashes: BoundedVec::new(),\\n            encrypted_logs_hashes: BoundedVec::new(),\\n            unencrypted_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\\n        }\\n    }\\n}\\n"},"95":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\\nuse crate::context::gas::GasOpts;\\n\\nstruct PublicContext {\\n    inputs: PublicContextInputs,\\n}\\n\\nimpl PublicContext {\\n    pub fn new(inputs: PublicContextInputs) -> Self {\\n        PublicContext { inputs }\\n    }\\n\\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\\n    }\\n\\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\\n        note_hash_exists(note_hash, leaf_index) == 1\\n    }\\n\\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\\n    }\\n\\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\\n    }\\n\\n    fn consume_l1_to_l2_message(\\n        &mut self,\\n        content: Field,\\n        secret: Field,\\n        sender: EthAddress,\\n        leaf_index: Field\\n    ) {\\n        let secret_hash = compute_secret_hash(secret);\\n        let message_hash = compute_message_hash(\\n            sender,\\n            self.chain_id(),\\n            /*recipient=*/ self.this_address(),\\n            self.version(),\\n            content,\\n            secret_hash\\n        );\\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\\n\\n        assert(\\n            !self.nullifier_exists(nullifier, self.this_address()), \\"L1-to-L2 message is already nullified\\"\\n        );\\n        assert(\\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \\"Tried to consume nonexistent L1-to-L2 message\\"\\n        );\\n\\n        // Push nullifier (and the \\"commitment\\" corresponding to this can be \\"empty\\")\\n        self.push_nullifier(nullifier, 0);\\n    }\\n\\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\\n        send_l2_to_l1_msg(recipient, content);\\n    }\\n\\n    fn call_public_function<RETURNS_COUNT>(\\n        self: &mut Self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field],\\n        gas_opts: GasOpts\\n    ) -> FunctionReturns<RETURNS_COUNT> {\\n        let results = call(\\n            gas_for_call(gas_opts),\\n            contract_address,\\n            args,\\n            function_selector.to_field()\\n        );\\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\\n        let success: u8 = results.1;\\n        assert(success == 1, \\"Nested call failed!\\");\\n\\n        FunctionReturns::new(data_to_return)\\n    }\\n\\n    fn static_call_public_function<RETURNS_COUNT>(\\n        self: &mut Self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field],\\n        gas_opts: GasOpts\\n    ) -> FunctionReturns<RETURNS_COUNT> {\\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\\n            gas_for_call(gas_opts),\\n            contract_address,\\n            args,\\n            function_selector.to_field()\\n        );\\n\\n        assert(success == 1, \\"Nested static call failed!\\");\\n        FunctionReturns::new(data_to_return)\\n    }\\n\\n    fn delegate_call_public_function<RETURNS_COUNT>(\\n        self: &mut Self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field]\\n    ) -> FunctionReturns<RETURNS_COUNT> {\\n        assert(false, \\"\'delegate_call_public_function\' not implemented!\\");\\n        FunctionReturns::new([0; RETURNS_COUNT])\\n    }\\n\\n    fn push_note_hash(&mut self, note_hash: Field) {\\n        emit_note_hash(note_hash);\\n    }\\n    fn push_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\\n        emit_nullifier(nullifier);\\n    }\\n\\n    fn this_address(self) -> AztecAddress {\\n        address()\\n    }\\n    pub fn storage_address(self) -> AztecAddress {\\n        storage_address()\\n    }\\n    fn msg_sender(self) -> AztecAddress {\\n        sender()\\n    }\\n    fn selector(self) -> FunctionSelector {\\n        FunctionSelector::from_u32(function_selector())\\n    }\\n    fn get_args_hash(self) -> Field {\\n        self.inputs.args_hash\\n    }\\n    fn transaction_fee(self) -> Field {\\n        transaction_fee()\\n    }\\n\\n    fn chain_id(self) -> Field {\\n        chain_id()\\n    }\\n    fn version(self) -> Field {\\n        version()\\n    }\\n    fn block_number(self) -> Field {\\n        block_number()\\n    }\\n    fn timestamp(self) -> u64 {\\n        timestamp()\\n    }\\n    pub fn fee_per_l2_gas(self) -> Field {\\n        fee_per_l2_gas()\\n    }\\n    pub fn fee_per_da_gas(self) -> Field {\\n        fee_per_da_gas()\\n    }\\n\\n    fn l2_gas_left(self) -> Field {\\n        l2_gas_left()\\n    }\\n    fn da_gas_left(self) -> Field {\\n        da_gas_left()\\n    }\\n\\n    fn raw_storage_read<N>(_self: Self, storage_slot: Field) -> [Field; N] {\\n        storage_read(storage_slot)\\n    }\\n\\n    fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\\n        T::deserialize(self.raw_storage_read(storage_slot))\\n    }\\n\\n    fn raw_storage_write<N>(_self: Self, storage_slot: Field, values: [Field; N]) {\\n        storage_write(storage_slot, values);\\n    }\\n\\n    fn storage_write<T, N>(self, storage_slot: Field, value: T) where T: Serialize<N> {\\n        self.raw_storage_write(storage_slot, value.serialize());\\n    }\\n}\\n\\n// Helper functions\\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\\n    // It\'s ok to use the max possible gas here, because the gas will be\\n    // capped by the gas left in the (STATIC)CALL instruction.\\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\\n    [\\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\\n    ]\\n}\\n\\n// Unconstrained opcode wrappers (do not use directly).\\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\\nunconstrained fn address() -> AztecAddress {\\n    address_opcode()\\n}\\nunconstrained fn storage_address() -> AztecAddress {\\n    storage_address_opcode()\\n}\\nunconstrained fn sender() -> AztecAddress {\\n    sender_opcode()\\n}\\nunconstrained fn portal() -> EthAddress {\\n    portal_opcode()\\n}\\nunconstrained fn function_selector() -> u32 {\\n    function_selector_opcode()\\n}\\nunconstrained fn transaction_fee() -> Field {\\n    transaction_fee_opcode()\\n}\\nunconstrained fn chain_id() -> Field {\\n    chain_id_opcode()\\n}\\nunconstrained fn version() -> Field {\\n    version_opcode()\\n}\\nunconstrained fn block_number() -> Field {\\n    block_number_opcode()\\n}\\nunconstrained fn timestamp() -> u64 {\\n    timestamp_opcode()\\n}\\nunconstrained fn fee_per_l2_gas() -> Field {\\n    fee_per_l2_gas_opcode()\\n}\\nunconstrained fn fee_per_da_gas() -> Field {\\n    fee_per_da_gas_opcode()\\n}\\nunconstrained fn l2_gas_left() -> Field {\\n    l2_gas_left_opcode()\\n}\\nunconstrained fn da_gas_left() -> Field {\\n    da_gas_left_opcode()\\n}\\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\\n    note_hash_exists_opcode(note_hash, leaf_index)\\n}\\nunconstrained fn emit_note_hash(note_hash: Field) {\\n    emit_note_hash_opcode(note_hash)\\n}\\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\\n    nullifier_exists_opcode(nullifier, address)\\n}\\nunconstrained fn emit_nullifier(nullifier: Field) {\\n    emit_nullifier_opcode(nullifier)\\n}\\nunconstrained fn emit_unencrypted_log(message: [Field]) {\\n    emit_unencrypted_log_opcode(message)\\n}\\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\\n}\\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\\n    send_l2_to_l1_msg_opcode(recipient, content)\\n}\\nunconstrained fn call<RET_SIZE>(\\n    gas: [Field; 2],\\n    address: AztecAddress,\\n    args: [Field],\\n    function_selector: Field\\n) -> ([Field; RET_SIZE], u8) {\\n    call_opcode(gas, address, args, function_selector)\\n}\\nunconstrained fn call_static<RET_SIZE>(\\n    gas: [Field; 2],\\n    address: AztecAddress,\\n    args: [Field],\\n    function_selector: Field\\n) -> ([Field; RET_SIZE], u8) {\\n    call_static_opcode(gas, address, args, function_selector)\\n}\\n\\nunconstrained fn storage_read<N>(storage_slot: Field) -> [Field; N] {\\n    storage_read_opcode(storage_slot, N)\\n}\\n\\nunconstrained fn storage_write<N>(storage_slot: Field, values: [Field; N]) {\\n    storage_write_opcode(storage_slot, values);\\n}\\n\\nimpl Empty for PublicContext {\\n    fn empty() -> Self {\\n        PublicContext::new(PublicContextInputs::empty())\\n    }\\n}\\n\\n// AVM oracles (opcodes) follow, do not use directly.\\n#[oracle(avmOpcodeAddress)]\\nunconstrained fn address_opcode() -> AztecAddress {}\\n\\n#[oracle(avmOpcodeStorageAddress)]\\nunconstrained fn storage_address_opcode() -> AztecAddress {}\\n\\n#[oracle(avmOpcodeSender)]\\nunconstrained fn sender_opcode() -> AztecAddress {}\\n\\n#[oracle(avmOpcodePortal)]\\nunconstrained fn portal_opcode() -> EthAddress {}\\n\\n#[oracle(avmOpcodeFunctionSelector)]\\nunconstrained fn function_selector_opcode() -> u32 {}\\n\\n#[oracle(avmOpcodeTransactionFee)]\\nunconstrained fn transaction_fee_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeChainId)]\\nunconstrained fn chain_id_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeVersion)]\\nunconstrained fn version_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeBlockNumber)]\\nunconstrained fn block_number_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeTimestamp)]\\nunconstrained fn timestamp_opcode() -> u64 {}\\n\\n#[oracle(avmOpcodeFeePerL2Gas)]\\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeFeePerDaGas)]\\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeL2GasLeft)]\\nunconstrained fn l2_gas_left_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeDaGasLeft)]\\nunconstrained fn da_gas_left_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeNoteHashExists)]\\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\\n\\n#[oracle(avmOpcodeEmitNoteHash)]\\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\\n\\n#[oracle(avmOpcodeNullifierExists)]\\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\\n\\n#[oracle(avmOpcodeEmitNullifier)]\\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\\n\\n#[oracle(avmOpcodeEmitUnencryptedLog)]\\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\\n\\n#[oracle(avmOpcodeL1ToL2MsgExists)]\\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\\n\\n#[oracle(avmOpcodeSendL2ToL1Msg)]\\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\\n\\n#[oracle(avmOpcodeCall)]\\nunconstrained fn call_opcode<RET_SIZE>(\\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\\n    address: AztecAddress,\\n    args: [Field],\\n    // TODO(5110): consider passing in calldata directly\\n    function_selector: Field\\n) -> ([Field; RET_SIZE], u8) {}\\n//    ^ return data      ^ success\\n\\n#[oracle(avmOpcodeStaticCall)]\\nunconstrained fn call_static_opcode<RET_SIZE>(\\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\\n    address: AztecAddress,\\n    args: [Field],\\n    // TODO(5110): consider passing in calldata directly\\n    function_selector: Field\\n) -> ([Field; RET_SIZE], u8) {}\\n//    ^ return data      ^ success\\n\\n#[oracle(avmOpcodeStorageRead)]\\nunconstrained fn storage_read_opcode<N>(storage_slot: Field, length: Field) -> [Field; N] {}\\n\\n#[oracle(avmOpcodeStorageWrite)]\\nunconstrained fn storage_write_opcode<N>(storage_slot: Field, values: [Field; N]) {}\\n\\nstruct FunctionReturns<N> {\\n    values: [Field; N]\\n}\\n\\nimpl<N> FunctionReturns<N> {\\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\\n        FunctionReturns { values }\\n    }\\n\\n    pub fn assert_empty(returns: FunctionReturns<0>) {\\n        assert(returns.values.len() == 0);\\n    }\\n\\n    pub fn raw(self) -> [Field; N] {\\n        self.values\\n    }\\n\\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\\n        Deserialize::deserialize(self.raw())\\n    }\\n}\\n"},"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\\n},\\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\\n};\\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\\n\\npub fn compute_secret_hash(secret: Field) -> Field {\\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\\n}\\n\\npub fn compute_unencrypted_log_hash<T, N, M>(\\n    contract_address: AztecAddress,\\n    log: T\\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\\n    // can\'t use N - not in scope error\\n    let n = message_bytes.len();\\n    let mut hash_bytes = [0; M];\\n    // Address is converted to 32 bytes in ts\\n    let address_bytes = contract_address.to_be_bytes_arr();\\n    for i in 0..32 {\\n        hash_bytes[i] = address_bytes[i];\\n    }\\n    let len_bytes = (n as Field).to_be_bytes(4);\\n    for i in 0..4 {\\n        hash_bytes[32 + i] = len_bytes[i];\\n    }\\n    for i in 0..n {\\n        hash_bytes[36 + i] = message_bytes[i];\\n    }\\n\\n    sha256_to_field(hash_bytes)\\n}\\n\\npub fn compute_message_hash(\\n    sender: EthAddress,\\n    chain_id: Field,\\n    recipient: AztecAddress,\\n    version: Field,\\n    content: Field,\\n    secret_hash: Field\\n) -> Field {\\n    let mut hash_bytes = [0 as u8; 192];\\n    let sender_bytes = sender.to_field().to_be_bytes(32);\\n    let chain_id_bytes = chain_id.to_be_bytes(32);\\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\\n    let version_bytes = version.to_be_bytes(32);\\n    let content_bytes = content.to_be_bytes(32);\\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\\n\\n    for i in 0..32 {\\n        hash_bytes[i] = sender_bytes[i];\\n        hash_bytes[i + 32] = chain_id_bytes[i];\\n        hash_bytes[i + 64] = recipient_bytes[i];\\n        hash_bytes[i + 96] = version_bytes[i];\\n        hash_bytes[i + 128] = content_bytes[i];\\n        hash_bytes[i + 160] = secret_hash_bytes[i];\\n    }\\n\\n    sha256_to_field(hash_bytes)\\n}\\n\\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\\n// in the L1 to L2 message tree\\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\\n    pedersen_hash(\\n        [message_hash, secret, leaf_index],\\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\\n    )\\n}\\n\\nstruct ArgsHasher {\\n    fields: [Field],\\n}\\n\\nimpl Hash for ArgsHasher {\\n    fn hash(self) -> Field {\\n        hash_args(self.fields)\\n    }\\n}\\n\\nimpl ArgsHasher {\\n    pub fn new() -> Self {\\n        Self { fields: [] }\\n    }\\n\\n    pub fn add(&mut self, field: Field) {\\n        self.fields = self.fields.push_back(field);\\n    }\\n\\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\\n        for i in 0..N {\\n            self.fields = self.fields.push_back(fields[i]);\\n        }\\n    }\\n}\\n\\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\\n    hash_args(args.as_slice())\\n}\\n\\npub fn hash_args(args: [Field]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        assert(args.len() <= MAX_ARGS_LENGTH, \\"Args length exceeds maximum\\");\\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\\n\\n        let mut current_chunk_index = 0;\\n        let mut index_inside_current_chunk = 0;\\n        for i in 0..args.len() {\\n            current_chunk_values[index_inside_current_chunk] = args[i];\\n            index_inside_current_chunk+=1;\\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\\n                current_chunk_index+=1;\\n                index_inside_current_chunk = 0;\\n            }\\n        }\\n        if index_inside_current_chunk > 0 {\\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\\n        }\\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\n#[test]\\nfn compute_var_args_hash() {\\n    let mut input = ArgsHasher::new();\\n    for i in 0..MAX_ARGS_LENGTH {\\n        input.add(i as Field);\\n    }\\n    let hash = input.hash();\\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\\n}\\n\\n#[test]\\nfn compute_unenc_log_hash_array() {\\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\\n    let log = [\\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\\n    ];\\n    let hash = compute_unencrypted_log_hash(contract_address, log);\\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\\n}\\n\\n#[test]\\nfn compute_unenc_log_hash_addr() {\\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\\n    let hash = compute_unencrypted_log_hash(contract_address, log);\\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\\n}\\n\\n#[test]\\nfn compute_unenc_log_hash_str() {\\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\\n    let log = \\"dummy\\";\\n    let hash = compute_unencrypted_log_hash(contract_address, log);\\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\\n}\\n\\n#[test]\\nfn compute_unenc_log_hash_longer_str() {\\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\\n    let log = \\"Hello this is a string\\";\\n    let hash = compute_unencrypted_log_hash(contract_address, log);\\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\\n}\\n"},"125":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\\nunconstrained fn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\\n\\n#[oracle(packArguments)]\\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\\n\\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\\n///   some point in the call. \\n/// - When the external call is made later, the simulator will know what the values unpack to.\\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \\n///   itself.\\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\\n    pack_arguments_array_oracle(args)\\n}\\n\\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\\n///   some point in the call. \\n/// - When the external call is made later, the simulator will know what the values unpack to.\\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \\n///   itself.\\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\\n    pack_arguments_oracle(args)\\n}\\n\\n"},"128":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\\n    utils::arr_copy_slice\\n};\\n\\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\\nglobal PUBLIC_DATA_WITNESS: Field = 45;\\n\\nstruct PublicDataWitness {\\n    index: Field,\\n    leaf_preimage: PublicDataTreeLeafPreimage,\\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\\n}\\n\\n#[oracle(getPublicDataTreeWitness)]\\nunconstrained fn get_public_data_witness_oracle(\\n    _block_number: u32,\\n    _leaf_slot: Field\\n) -> [Field; PUBLIC_DATA_WITNESS] {}\\n\\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\\n    PublicDataWitness {\\n        index: fields[0],\\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\\n    }\\n}\\n"},"135":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\\n};\\n\\n#[oracle(callPrivateFunction)]\\nunconstrained fn call_private_function_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _start_side_effect_counter: u32,\\n    _is_static_call: bool,\\n    _is_delegate_call: bool\\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\\n\\nunconstrained pub fn call_private_function_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    start_side_effect_counter: u32,\\n    is_static_call: bool,\\n    is_delegate_call: bool\\n) -> PrivateCallStackItem {\\n    let fields = call_private_function_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        start_side_effect_counter,\\n        is_static_call,\\n        is_delegate_call\\n    );\\n\\n    PrivateCallStackItem::deserialize(fields)\\n}\\n"},"139":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\\n};\\n\\n#[oracle(getContractInstance)]\\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\\n\\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\\n#[oracle(avmOpcodeGetContractInstance)]\\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\\n\\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\\n    get_contract_instance_oracle(address)\\n}\\n\\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\\n    get_contract_instance_oracle_avm(address)\\n}\\n\\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\\n    assert(instance.to_address().eq(address));\\n    instance\\n}\\n\\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\\n    let found = reader.read();\\n    if found == 0 {\\n        Option::none()\\n    } else {\\n        Option::some(reader.read_struct(ContractInstance::deserialize))\\n    }\\n}\\n"},"140":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{\\n    abis::{\\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\\n},\\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\\n    utils::reader::Reader,\\n    constants::{\\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\\n}\\n};\\n\\n#[oracle(enqueuePublicFunctionCall)]\\nunconstrained fn enqueue_public_function_call_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _side_effect_counter: u32,\\n    _is_static_call: bool,\\n    _is_delegate_call: bool\\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\\n\\nunconstrained pub fn enqueue_public_function_call_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    side_effect_counter: u32,\\n    is_static_call: bool,\\n    is_delegate_call: bool\\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\\n    enqueue_public_function_call_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        side_effect_counter,\\n        is_static_call,\\n        is_delegate_call\\n    )\\n}\\n\\n#[oracle(setPublicTeardownFunctionCall)]\\nunconstrained fn set_public_teardown_function_call_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _side_effect_counter: u32,\\n    _is_static_call: bool,\\n    _is_delegate_call: bool\\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\\n\\nunconstrained pub fn set_public_teardown_function_call_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    side_effect_counter: u32,\\n    is_static_call: bool,\\n    is_delegate_call: bool\\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\\n    set_public_teardown_function_call_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        side_effect_counter,\\n        is_static_call,\\n        is_delegate_call\\n    )\\n}\\n\\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\\n    let mut reader = Reader::new(fields);\\n\\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\\n    // WARNING: if updating, see comment in public_call_stack_item.ts\'s PublicCallStackItem.hash()\\n    let item = PublicCallStackItem {\\n        contract_address: AztecAddress::from_field(reader.read()),\\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\\n        public_inputs: PublicCircuitPublicInputs {\\n            call_context: reader.read_struct(CallContext::deserialize),\\n            start_side_effect_counter: reader.read_u32(),\\n            args_hash: reader.read(),\\n            returns_hash: 0,\\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\\n            end_side_effect_counter: 0,\\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\\n            historical_header: Header::empty(),\\n            global_variables: GlobalVariables::empty(),\\n            prover_address: AztecAddress::zero(),\\n            revert_code: 0,\\n            start_gas_left: Gas::empty(),\\n            end_gas_left: Gas::empty(),\\n            transaction_fee: 0\\n        },\\n        is_execution_request: true\\n    };\\n    reader.finish();\\n\\n    item\\n}\\n"},"143":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr","source":"use dep::protocol_types::{address::AztecAddress};\\n\\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\\n\\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\\n#[oracle(getL1ToL2MembershipWitness)]\\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\\n    _contract_address: AztecAddress,\\n    _message_hash: Field,\\n    _secret: Field\\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {}\\n\\nunconstrained pub fn get_l1_to_l2_membership_witness(\\n    contract_address: AztecAddress,\\n    message_hash: Field,\\n    secret: Field\\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {\\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\\n}\\n"},"144":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{hash::pedersen_hash, storage::map::derive_storage_slot_in_map, traits::ToField};\\nuse crate::state_vars::storage::Storage;\\n\\n// docs:start:map\\nstruct Map<K, V, Context> {\\n    context: Context,\\n    storage_slot: Field,\\n    state_var_constructor: fn(Context, Field) -> V,\\n}\\n// docs:end:map\\n\\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\\n\\nimpl<K, V, Context> Map<K, V, Context> {\\n    // docs:start:new\\n    pub fn new(\\n        context: Context,\\n        storage_slot: Field,\\n        state_var_constructor: fn(Context, Field) -> V\\n    ) -> Self {\\n        assert(storage_slot != 0, \\"Storage slot 0 not allowed. Storage slots must start from 1.\\");\\n        Map { context, storage_slot, state_var_constructor }\\n    }\\n    // docs:end:new\\n\\n    // docs:start:at\\n    pub fn at(self, key: K) -> V where K: ToField {\\n        // TODO(#1204): use a generator index for the storage slot\\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\\n\\n        let state_var_constructor = self.state_var_constructor;\\n        state_var_constructor(self.context, derived_storage_slot)\\n    }\\n    // docs:end:at\\n}\\n"},"146":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\\nuse crate::oracle::storage::storage_read;\\nuse dep::protocol_types::traits::{Deserialize, Serialize};\\nuse crate::state_vars::storage::Storage;\\n\\n// docs:start:public_mutable_struct\\nstruct PublicMutable<T, Context> {\\n    context: Context,\\n    storage_slot: Field,\\n}\\n// docs:end:public_mutable_struct\\n\\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\\n\\nimpl<T, Context> PublicMutable<T, Context> {\\n    // docs:start:public_mutable_struct_new\\n    pub fn new(\\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\\n        context: Context,\\n        storage_slot: Field\\n    ) -> Self {\\n        assert(storage_slot != 0, \\"Storage slot 0 not allowed. Storage slots must start from 1.\\");\\n        PublicMutable { context, storage_slot }\\n    }\\n    // docs:end:public_mutable_struct_new\\n}\\n\\nimpl<T> PublicMutable<T, &mut PublicContext> {\\n    // docs:start:public_mutable_struct_read\\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\\n        self.context.storage_read(self.storage_slot)\\n    }\\n    // docs:end:public_mutable_struct_read\\n\\n    // docs:start:public_mutable_struct_write\\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\\n        self.context.storage_write(self.storage_slot, value);\\n    }\\n    // docs:end:public_mutable_struct_write\\n}\\n\\nimpl<T> PublicMutable<T, UnconstrainedContext> {\\n    unconstrained pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\\n        self.context.storage_read(self.storage_slot)\\n    }\\n}\\n"},"149":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr","source":"use crate::{\\n    context::{PrivateContext, PublicContext, UnconstrainedContext}, oracle::storage::storage_read,\\n    state_vars::storage::Storage\\n};\\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\\n\\n// Just like PublicImmutable but with the ability to read from private functions.\\nstruct SharedImmutable<T, Context>{\\n    context: Context,\\n    storage_slot: Field,\\n}\\n\\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\\n\\nimpl<T, Context> SharedImmutable<T, Context> {\\n    pub fn new(\\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\\n        context: Context,\\n        storage_slot: Field\\n    ) -> Self {\\n        assert(storage_slot != 0, \\"Storage slot 0 not allowed. Storage slots must start from 1.\\");\\n        Self { context, storage_slot }\\n    }\\n}\\n\\nimpl<T> SharedImmutable<T, &mut PublicContext> {\\n    // Intended to be only called once. \\n    pub fn initialize<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\\n        let init_field: Field = self.context.storage_read(initialization_slot);\\n        assert(init_field == 0, \\"SharedImmutable already initialized\\");\\n\\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\\n        self.context.storage_write(initialization_slot, 0xdead);\\n        self.context.storage_write(self.storage_slot, value);\\n    }\\n\\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\\n        self.context.storage_read(self.storage_slot)\\n    }\\n}\\n\\nimpl<T> SharedImmutable<T, UnconstrainedContext> {\\n    unconstrained pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\\n        self.context.storage_read(self.storage_slot)\\n    }\\n}\\n\\nimpl<T> SharedImmutable<T, &mut PrivateContext> {\\n    pub fn read_private<T_SERIALIZED_LEN>(self) -> T  where T: Deserialize<T_SERIALIZED_LEN> {\\n        let header = self.context.get_header();\\n        let mut fields = [0; T_SERIALIZED_LEN];\\n\\n        for i in 0..fields.len() {\\n            fields[i] =\\n                header.public_storage_historical_read(\\n                    self.storage_slot + i as Field,\\n                    (*self.context).this_address()\\n                );\\n        }\\n        T::deserialize(fields)\\n    }\\n}\\n"},"167":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr","source":"use crate::{\\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\\n    constants::{GAS_LENGTH, FIXED_DA_GAS, FIXED_L2_GAS}, hash::pedersen_hash,\\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\\n    abis::gas_fees::GasFees\\n};\\nuse std::ops::{Add, Sub};\\n\\nstruct Gas {\\n    da_gas: u32,\\n    l2_gas: u32,\\n}\\n\\nimpl Gas {\\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\\n        Self { da_gas, l2_gas }\\n    }\\n\\n    pub fn tx_overhead() -> Self {\\n        Self { da_gas: FIXED_DA_GAS, l2_gas: FIXED_L2_GAS }\\n    }\\n\\n    pub fn compute_fee(self, fees: GasFees) -> Field {\\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\\n    }\\n\\n    pub fn is_empty(self) -> bool {\\n        (self.da_gas == 0) & (self.l2_gas == 0)\\n    }\\n\\n    pub fn within(self, limits: Gas) -> bool {\\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\\n    }\\n}\\n\\nimpl Add for Gas {\\n    fn add(self, other: Gas) -> Self {\\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\\n    }\\n}\\n\\nimpl Sub for Gas {\\n    fn sub(self, other: Gas) -> Self {\\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\\n    }\\n}\\n\\nimpl Serialize<GAS_LENGTH> for Gas {\\n    fn serialize(self) -> [Field; GAS_LENGTH] {\\n        [self.da_gas as Field, self.l2_gas as Field]\\n    }\\n}\\n\\nimpl Deserialize<GAS_LENGTH> for Gas {\\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\\n    }\\n}\\n\\nimpl Eq for Gas {\\n    fn eq(self, other : Gas) -> bool {\\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\\n    }\\n}\\n\\nimpl Empty for Gas {\\n    fn empty() -> Self {\\n        Gas::new(0, 0)\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = Gas::empty();\\n    let serialized = item.serialize();\\n    let deserialized = Gas::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n\\n"},"169":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr","source":"use crate::{\\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\\n    utils::{arrays::array_concat, reader::Reader}\\n};\\n\\nstruct NoteHash {\\n    value: Field,\\n    counter: u32,\\n}\\n\\nimpl Ordered for NoteHash {\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl Eq for NoteHash {\\n    fn eq(self, other: NoteHash) -> bool {\\n        (self.value == other.value)\\n            & (self.counter == other.counter) \\n    }\\n}\\n\\nimpl Empty for NoteHash {\\n    fn empty() -> Self {\\n        NoteHash {\\n            value: 0,\\n            counter: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\\n        [self.value, self.counter as Field]\\n    }\\n}\\n\\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\\n        Self {\\n            value: values[0],\\n            counter: values[1] as u32,\\n        }\\n    }\\n}\\n\\nimpl NoteHash {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNoteHash {\\n        ScopedNoteHash { note_hash: self, contract_address }\\n    }\\n}\\n\\nstruct ScopedNoteHash {\\n    note_hash: NoteHash,\\n    contract_address: AztecAddress,\\n}\\n\\nimpl Scoped<NoteHash> for ScopedNoteHash {\\n    fn inner(self) -> NoteHash {\\n        self.note_hash\\n    }\\n    fn contract_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n}\\n\\nimpl Ordered for ScopedNoteHash {\\n    fn counter(self) -> u32 {\\n        self.note_hash.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for ScopedNoteHash {\\n    fn value(self) -> Field {\\n        self.note_hash.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.note_hash.counter\\n    }\\n}\\n\\nimpl Eq for ScopedNoteHash {\\n    fn eq(self, other: ScopedNoteHash) -> bool {\\n        (self.note_hash == other.note_hash)\\n            & (self.contract_address == other.contract_address)\\n    }\\n}\\n\\nimpl Empty for ScopedNoteHash {\\n    fn empty() -> Self {\\n        ScopedNoteHash {\\n            note_hash: NoteHash::empty(),\\n            contract_address: AztecAddress::zero(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\\n        array_concat(self.note_hash.serialize(), [self.contract_address.to_field()])\\n    }\\n}\\n\\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\\n        let mut reader = Reader::new(values);\\n        let res = Self {\\n            note_hash: reader.read_struct(NoteHash::deserialize),\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n        };\\n        reader.finish();\\n        res\\n    }\\n}\\n\\nimpl Readable for ScopedNoteHash {\\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\\n        assert_eq(self.note_hash.value, read_request.value(), \\"Value of the note hash does not match read request\\");\\n        assert_eq(self.contract_address, read_request.contract_address, \\"Contract address of the note hash does not match read request\\");\\n        assert(\\n            read_request.counter() > self.note_hash.counter, \\"Read request counter must be greater than the counter of the note hash\\"\\n        );\\n    }\\n}\\n\\nimpl ScopedNoteHash {\\n    pub fn expose_to_public(self) -> NoteHash {\\n        // Hide the actual counter when exposing it to the public kernel.\\n        NoteHash { value: self.note_hash.value, counter: 0 }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = NoteHash::empty();\\n    let serialized = item.serialize();\\n    let deserialized = NoteHash::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n\\n#[test]\\nfn serialization_of_empty_scoped() {\\n    let item = ScopedNoteHash::empty();\\n    let serialized = item.serialize();\\n    let deserialized = ScopedNoteHash::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"170":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr","source":"use crate::{\\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\\n    abis::side_effect::Ordered, utils::reader::Reader\\n};\\n\\nstruct GasFees {\\n    fee_per_da_gas: Field,\\n    fee_per_l2_gas: Field,\\n}\\n\\nimpl GasFees {\\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\\n        Self { fee_per_da_gas, fee_per_l2_gas }\\n    }\\n\\n    pub fn default() -> Self {\\n        GasFees::new(1, 1)\\n    }\\n\\n    pub fn is_empty(self) -> bool {\\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\\n    }\\n}\\n\\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\\n    }\\n}\\n\\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\\n        GasFees::new(serialized[0], serialized[1])\\n    }\\n}\\n\\nimpl Eq for GasFees {\\n    fn eq(self, other : GasFees) -> bool {\\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\\n    }\\n}\\n\\nimpl Empty for GasFees {\\n    fn empty() -> Self {\\n        GasFees::new(0, 0)\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = GasFees::empty();\\n    let serialized = item.serialize();\\n    let deserialized = GasFees::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"172":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr","source":"use crate::{\\n    abis::{\\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\\n},\\n    constants::{\\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL, MAX_NULLIFIERS_PER_CALL,\\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\\n    MAX_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\\n},\\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\\n    transaction::tx_context::TxContext, utils::arrays::validate_array\\n};\\n\\nstruct PrivateCircuitPublicInputsArrayLengths {\\n    note_hash_read_requests: u32,\\n    nullifier_read_requests: u32,\\n    key_validation_requests_and_generators: u32,\\n    note_hashes: u32,\\n    nullifiers: u32,\\n    l2_to_l1_msgs: u32,\\n    private_call_requests: u32,\\n    public_call_stack_hashes: u32,\\n    note_encrypted_logs_hashes: u32,\\n    encrypted_logs_hashes: u32,\\n    unencrypted_logs_hashes: u32,\\n}\\n\\nimpl PrivateCircuitPublicInputsArrayLengths {\\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\\n        PrivateCircuitPublicInputsArrayLengths {\\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\\n            note_hashes: validate_array(public_inputs.note_hashes),\\n            nullifiers: validate_array(public_inputs.nullifiers),\\n            l2_to_l1_msgs: validate_array(public_inputs.l2_to_l1_msgs),\\n            private_call_requests: validate_array(public_inputs.private_call_requests),\\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\\n        }\\n    }\\n}\\n\\nstruct PrivateCircuitPublicInputs {\\n    call_context: CallContext,\\n\\n    args_hash: Field,\\n    returns_hash: Field,\\n\\n    min_revertible_side_effect_counter: u32,\\n    is_fee_payer: bool,\\n\\n    max_block_number: MaxBlockNumber,\\n\\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\\n\\n    note_hashes: [NoteHash; MAX_NOTE_HASHES_PER_CALL],\\n    nullifiers: [Nullifier; MAX_NULLIFIERS_PER_CALL],\\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\\n    public_teardown_function_hash: Field,\\n    l2_to_l1_msgs: [L2ToL1Message; MAX_L2_TO_L1_MSGS_PER_CALL],\\n\\n    start_side_effect_counter : u32,\\n    end_side_effect_counter : u32,\\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\\n\\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\\n    historical_header: Header,\\n\\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\\n    tx_context: TxContext,\\n}\\n\\nimpl Eq for PrivateCircuitPublicInputs {\\n    fn eq(self, other: Self) -> bool {\\n        self.call_context.eq(other.call_context) &\\n        self.args_hash.eq(other.args_hash) &\\n        (self.returns_hash == other.returns_hash) &\\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\\n        (self.is_fee_payer == other.is_fee_payer) &\\n        (self.max_block_number == other.max_block_number) &\\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\\n        (self.note_hashes == other.note_hashes) &\\n        (self.nullifiers == other.nullifiers) &\\n        (self.private_call_requests == other.private_call_requests) &\\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\\n        (self.l2_to_l1_msgs == other.l2_to_l1_msgs) &\\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\\n        self.historical_header.eq(other.historical_header) &\\n        self.tx_context.eq(other.tx_context)\\n    }\\n}\\n\\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\\n        fields.extend_from_array(self.call_context.serialize());\\n        fields.push(self.args_hash);\\n        fields.push(self.returns_hash);\\n\\n        fields.push(self.min_revertible_side_effect_counter as Field);\\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\\n\\n        fields.extend_from_array(self.max_block_number.serialize());\\n\\n        for i in 0..self.note_hash_read_requests.len() {\\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\\n        }\\n        for i in 0..self.nullifier_read_requests.len() {\\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\\n        }\\n        for i in 0..self.key_validation_requests_and_generators.len() {\\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\\n        }\\n        for i in 0..self.note_hashes.len() {\\n            fields.extend_from_array(self.note_hashes[i].serialize());\\n        }\\n        for i in 0..self.nullifiers.len() {\\n            fields.extend_from_array(self.nullifiers[i].serialize());\\n        }\\n        for i in 0..self.private_call_requests.len() {\\n            fields.extend_from_array(self.private_call_requests[i].serialize());\\n        }\\n        fields.extend_from_array(self.public_call_stack_hashes);\\n        fields.push(self.public_teardown_function_hash);\\n        for i in 0..self.l2_to_l1_msgs.len() {\\n            fields.extend_from_array(self.l2_to_l1_msgs[i].serialize());\\n        }\\n        fields.push(self.start_side_effect_counter as Field);\\n        fields.push(self.end_side_effect_counter as Field);\\n        for i in 0..self.note_encrypted_logs_hashes.len() {\\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\\n        }\\n        for i in 0..self.encrypted_logs_hashes.len() {\\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\\n        }\\n        for i in 0..self.unencrypted_logs_hashes.len() {\\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\\n        }\\n        fields.extend_from_array(self.historical_header.serialize());\\n        fields.extend_from_array(self.tx_context.serialize());\\n\\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\\n        let mut reader = Reader::new(serialized);\\n        let inputs = Self {\\n            call_context: reader.read_struct(CallContext::deserialize),\\n            args_hash: reader.read(),\\n            returns_hash: reader.read(),\\n            min_revertible_side_effect_counter: reader.read() as u32,\\n            is_fee_payer: reader.read() == 1,\\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\\n            note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL]),\\n            nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL]),\\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\\n            public_teardown_function_hash: reader.read(),\\n            l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL]),\\n            start_side_effect_counter: reader.read() as u32,\\n            end_side_effect_counter: reader.read() as u32,\\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\\n            historical_header: reader.read_struct(Header::deserialize),\\n            tx_context: reader.read_struct(TxContext::deserialize),\\n        };\\n\\n        reader.finish();\\n        inputs\\n    }\\n}\\n\\nimpl Hash for PrivateCircuitPublicInputs {\\n    fn hash(self) -> Field {\\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\\n    }\\n}\\n\\nimpl Empty for PrivateCircuitPublicInputs {\\n    fn empty() -> Self {\\n        PrivateCircuitPublicInputs {\\n            call_context: CallContext::empty(),\\n            args_hash: 0,\\n            returns_hash: 0,\\n            min_revertible_side_effect_counter: 0 as u32,\\n            is_fee_payer: false,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\\n            public_teardown_function_hash: 0,\\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\\n            start_side_effect_counter : 0 as u32,\\n            end_side_effect_counter : 0 as u32,\\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\\n            historical_header: Header::empty(),\\n            tx_context: TxContext::empty(),\\n        }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let pcpi = PrivateCircuitPublicInputs::empty();\\n    let serialized = pcpi.serialize();\\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\\n    assert(pcpi.eq(deserialized));\\n}\\n\\n#[test]\\nfn empty_hash() {\\n    let inputs = PrivateCircuitPublicInputs::empty();\\n    let hash = inputs.hash();\\n    // Value from private_circuit_public_inputs.test.ts \\"computes empty item hash\\" test\\n    let test_data_empty_hash = 0x15c9b0a92b9b541598e24c9f0b0b4b04b7f2408599751c45aa12de671fd9b363;\\n    assert_eq(hash, test_data_empty_hash);\\n}\\n"},"173":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item_compressed.nr","source":"use crate::abis::{call_context::CallContext, function_data::FunctionData, gas::Gas};\\nuse crate::address::AztecAddress;\\nuse crate::constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH};\\nuse crate::traits::{Hash, Empty, Serialize, Deserialize};\\nuse crate::utils::reader::Reader;\\n\\n/**\\n * A compressed version of the PublicCallStackItem struct used to compute the \\"hash\\"\\n * of a PublicCallStackItem.\\n * \\n * Historically, we have been zeroing most values in the PublicCallStackItem struct\\n * to compute the hash involved when adding a PublicCallStackItem to the PublicCallStack.\\n * \\n * This struct is used to store the values that we did not zero out, and allow us to hash\\n * only these, thereby skipping a lot of computation and saving us a lot of constraints\\n * \\n * Essentially this struct exists such that we don\'t have a `hash` function in the \\n * PublicCallStackItem struct that practically throws away some values of the struct\\n * without clearly indicating that it does so.\\n */\\nstruct PublicCallStackItemCompressed {\\n    contract_address: AztecAddress,\\n    call_context: CallContext,\\n    function_data: FunctionData,\\n    args_hash: Field,\\n    returns_hash: Field,\\n    revert_code: u8,\\n    start_gas_left: Gas,\\n    end_gas_left: Gas,\\n}\\n\\nimpl Eq for PublicCallStackItemCompressed {\\n    fn eq(self, other: PublicCallStackItemCompressed) -> bool {\\n        (self.contract_address == other.contract_address)\\n            & (self.call_context == other.call_context)\\n            & (self.function_data == other.function_data)\\n            & (self.args_hash == other.args_hash)\\n            & (self.returns_hash == other.returns_hash)\\n            & (self.revert_code == other.revert_code)\\n            & (self.start_gas_left == other.start_gas_left)\\n            & (self.end_gas_left == other.end_gas_left)\\n    }\\n}\\n\\nimpl Hash for PublicCallStackItemCompressed {\\n    fn hash(self) -> Field {\\n        std::hash::pedersen_hash_with_separator(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\\n    }\\n}\\n\\nimpl Empty for PublicCallStackItemCompressed {\\n    fn empty() -> Self {\\n        PublicCallStackItemCompressed {\\n            contract_address: AztecAddress::empty(),\\n            call_context: CallContext::empty(),\\n            function_data: FunctionData::empty(),\\n            args_hash: 0,\\n            returns_hash: 0,\\n            revert_code: 0,\\n            start_gas_left: Gas::empty(),\\n            end_gas_left: Gas::empty(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\\n    fn serialize(self) -> [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH] {\\n        let mut fields: BoundedVec<Field, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> = BoundedVec::new();\\n\\n        fields.push(self.contract_address.to_field());\\n        fields.extend_from_array(self.call_context.serialize());\\n        fields.extend_from_array(self.function_data.serialize());\\n        fields.push(self.args_hash);\\n        fields.push(self.returns_hash);\\n        fields.push(self.revert_code as Field);\\n        fields.extend_from_array(self.start_gas_left.serialize());\\n        fields.extend_from_array(self.end_gas_left.serialize());\\n\\n        assert_eq(fields.len(), PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH);\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\\n  fn deserialize(fields: [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH]) -> PublicCallStackItemCompressed {\\n    let mut reader = Reader::new(fields);\\n\\n    let item = PublicCallStackItemCompressed {\\n      contract_address: reader.read_struct(AztecAddress::deserialize),\\n      call_context: reader.read_struct(CallContext::deserialize),\\n      function_data: reader.read_struct(FunctionData::deserialize),\\n      args_hash: reader.read(),\\n      returns_hash: reader.read(),\\n      revert_code: reader.read() as u8,\\n      start_gas_left: reader.read_struct(Gas::deserialize),\\n      end_gas_left: reader.read_struct(Gas::deserialize),\\n    };\\n    reader.finish();\\n    item\\n  }\\n}\\n"},"175":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr","source":"use crate::{\\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\\n};\\n\\n// docs:start:global-variables\\nstruct GlobalVariables {\\n    chain_id : Field,\\n    version : Field,\\n    block_number : Field,\\n    timestamp : u64,\\n    coinbase : EthAddress,\\n    fee_recipient : AztecAddress,\\n    gas_fees : GasFees\\n}\\n// docs:end:global-variables\\n\\nimpl GlobalVariables {\\n    fn is_empty(self) -> bool {\\n        (self.chain_id == 0)\\n            & (self.version == 0)\\n            & (self.block_number == 0)\\n            & (self.timestamp == 0)\\n            & (self.coinbase.is_zero())\\n            & (self.fee_recipient.is_zero())\\n            & (self.gas_fees.is_empty())\\n    }\\n}\\n\\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\\n\\n        serialized.push(self.chain_id);\\n        serialized.push(self.version);\\n        serialized.push(self.block_number);\\n        serialized.push(self.timestamp as Field);\\n        serialized.push(self.coinbase.to_field());\\n        serialized.push(self.fee_recipient.to_field());\\n        serialized.extend_from_array(self.gas_fees.serialize());\\n\\n        serialized.storage\\n    }\\n}\\n\\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\\n        let mut reader = Reader::new(serialized);\\n        GlobalVariables {\\n            chain_id: reader.read(),\\n            version: reader.read(),\\n            block_number: reader.read(),\\n            timestamp: reader.read() as u64,\\n            coinbase: EthAddress::from_field(reader.read()),\\n            fee_recipient: AztecAddress::from_field(reader.read()),\\n            gas_fees: reader.read_struct(GasFees::deserialize)\\n        }\\n    }\\n}\\n\\nimpl Eq for GlobalVariables {\\n    fn eq(self, other : GlobalVariables) -> bool {\\n        (self.chain_id == other.chain_id) &\\n        (self.version == other.version) &\\n        (self.block_number == other.block_number) &\\n        (self.timestamp == other.timestamp) &\\n        (self.coinbase == other.coinbase) &\\n        (self.fee_recipient == other.fee_recipient) &\\n        (self.gas_fees == other.gas_fees) \\n    }\\n}\\n\\nimpl Empty for GlobalVariables {\\n    fn empty() -> Self {\\n        Self {\\n            chain_id: 0,\\n            version: 0,\\n            block_number: 0,\\n            timestamp: 0,\\n            coinbase: EthAddress::empty(),\\n            fee_recipient: AztecAddress::empty(),\\n            gas_fees: GasFees::empty()\\n        }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let vars = GlobalVariables::empty();\\n    let _serialized = vars.serialize();\\n    let _deserialized = GlobalVariables::deserialize(_serialized);\\n}\\n"},"176":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr","source":"use crate::{\\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\\n    utils::{arrays::array_concat, reader::Reader}\\n};\\n\\nstruct ReadRequest {\\n    value: Field,\\n    counter: u32,\\n}\\n\\nimpl Ordered for ReadRequest {\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl Eq for ReadRequest {\\n    fn eq(self, read_request: ReadRequest) -> bool {\\n        (self.value == read_request.value)\\n        & (self.counter == read_request.counter)\\n    }\\n}\\n\\nimpl Empty for ReadRequest {\\n    fn empty() -> Self {\\n        ReadRequest {\\n            value: 0,\\n            counter: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\\n        [self.value, self.counter as Field]\\n    }\\n}\\n\\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\\n        Self {\\n            value: values[0],\\n            counter: values[1] as u32,\\n        }\\n    }\\n}\\n\\nimpl ReadRequest {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\\n        ScopedReadRequest { read_request: self, contract_address }\\n    }\\n}\\n\\nstruct ScopedReadRequest {\\n    read_request: ReadRequest,\\n    contract_address: AztecAddress,\\n}\\n\\nimpl Scoped<ReadRequest> for ScopedReadRequest {\\n    fn inner(self) -> ReadRequest {\\n        self.read_request\\n    }\\n    fn contract_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n}\\n\\nimpl Eq for ScopedReadRequest {\\n    fn eq(self, other: ScopedReadRequest) -> bool {\\n        (self.read_request == other.read_request)\\n        & (self.contract_address.eq(other.contract_address))\\n    }\\n}\\n\\nimpl Empty for ScopedReadRequest {\\n    fn empty() -> Self {\\n        ScopedReadRequest {\\n            read_request: ReadRequest::empty(),\\n            contract_address: AztecAddress::empty(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\\n    }\\n}\\n\\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\\n        let mut reader = Reader::new(values);\\n        let res = Self {\\n            read_request: reader.read_struct(ReadRequest::deserialize),\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n        };\\n        reader.finish();\\n        res\\n    }\\n}\\n\\nimpl ScopedReadRequest {\\n    pub fn value(self) -> Field {\\n        self.read_request.value\\n    }\\n    pub fn counter(self) -> u32 {\\n        self.read_request.counter\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty_read() {\\n    let item = ReadRequest::empty();\\n    let serialized = item.serialize();\\n    let deserialized = ReadRequest::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n\\n#[test]\\nfn serialization_of_empty_scoped() {\\n    let item = ScopedReadRequest::empty();\\n    let serialized = item.serialize();\\n    let deserialized = ScopedReadRequest::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"179":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr","source":"use crate::{\\n    address::AztecAddress,\\n    abis::validation_requests::{\\n    key_validation_request::KeyValidationRequest,\\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\\n},\\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\\n    utils::{arrays::array_concat, reader::Reader}\\n};\\n\\nstruct KeyValidationRequestAndGenerator {\\n    request: KeyValidationRequest,\\n    sk_app_generator: Field,\\n}\\n\\nimpl Eq for KeyValidationRequestAndGenerator {\\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\\n    }\\n}\\n\\nimpl Empty for KeyValidationRequestAndGenerator {\\n    fn empty() -> Self {\\n        KeyValidationRequestAndGenerator {\\n            request: KeyValidationRequest::empty(),\\n            sk_app_generator: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\\n        array_concat(self.request.serialize(), [self.sk_app_generator])\\n    }\\n}\\n\\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\\n        let mut reader = Reader::new(fields);\\n        let res = Self {\\n            request: reader.read_struct(KeyValidationRequest::deserialize),\\n            sk_app_generator: reader.read(),\\n        };\\n        reader.finish();\\n        res\\n    }\\n}\\n\\nimpl KeyValidationRequestAndGenerator {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = KeyValidationRequestAndGenerator::empty();\\n    let serialized = item.serialize();\\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"180":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\\n\\nstruct KeyValidationRequest {\\n    pk_m: Point,\\n    sk_app: Field, // not a grumpkin scalar because it\'s output of poseidon2\\n}\\n\\nimpl Eq for KeyValidationRequest {\\n    fn eq(self, request: KeyValidationRequest) -> bool {\\n        (request.pk_m.eq(self.pk_m))\\n            & (request.sk_app.eq(self.sk_app))\\n    }\\n}\\n\\nimpl Empty for KeyValidationRequest {\\n    fn empty() -> Self {\\n        KeyValidationRequest {\\n            pk_m: Point::empty(),\\n            sk_app: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\\n        [\\n            self.pk_m.x,\\n            self.pk_m.y,\\n            self.pk_m.is_infinite as Field,\\n            self.sk_app,\\n        ]\\n    }\\n}\\n\\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\\n        Self {\\n            pk_m: Point::new(fields[0], fields[1], fields[2] as bool),\\n            sk_app: fields[3],\\n        }\\n    }\\n}\\n\\n"},"184":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr","source":"use crate::{\\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH},\\n    hash::compute_siloed_nullifier, traits::{Empty, Hash, Serialize, Deserialize},\\n    utils::{arrays::array_concat, reader::Reader}\\n};\\n\\nstruct Nullifier {\\n    value: Field,\\n    counter: u32,\\n    note_hash: Field,\\n}\\n\\nimpl Ordered for Nullifier {\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for Nullifier {\\n    fn value(self) -> Field {\\n        self.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl Eq for Nullifier {\\n    fn eq(self, other: Nullifier) -> bool {\\n        (self.value == other.value)\\n            & (self.counter == other.counter)\\n            & (self.note_hash == other.note_hash) \\n    }\\n}\\n\\nimpl Empty for Nullifier {\\n    fn empty() -> Self {\\n        Nullifier {\\n            value: 0,\\n            counter: 0,\\n            note_hash: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\\n        [self.value, self.counter as Field, self.note_hash]\\n    }\\n}\\n\\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\\n        Self {\\n            value: values[0],\\n            counter: values[1] as u32,\\n            note_hash: values[2],\\n        }\\n    }\\n}\\n\\nimpl Readable for Nullifier {\\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\\n        // Public kernels output Nullifier instead of ScopedNullifier.\\n        // The nullifier value has been siloed.\\n        let siloed_request_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\\n        assert_eq(self.value, siloed_request_value, \\"Value of the nullifier does not match read request\\");\\n        assert(\\n            read_request.counter() > self.counter, \\"Read request counter must be greater than the counter of the nullifier\\"\\n        );\\n    }\\n}\\n\\nimpl Nullifier {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\\n        ScopedNullifier { nullifier: self, contract_address }\\n    }\\n}\\n\\nstruct ScopedNullifier {\\n    nullifier: Nullifier,\\n    contract_address: AztecAddress,\\n}\\n\\nimpl Scoped<Nullifier> for ScopedNullifier {\\n    fn inner(self) -> Nullifier {\\n        self.nullifier\\n    }\\n    fn contract_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n}\\n\\nimpl Ordered for ScopedNullifier {\\n    fn counter(self) -> u32 {\\n        self.nullifier.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for ScopedNullifier {\\n    fn value(self) -> Field {\\n        self.nullifier.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.nullifier.counter\\n    }\\n}\\n\\nimpl Eq for ScopedNullifier {\\n    fn eq(self, other: ScopedNullifier) -> bool {\\n        (self.nullifier == other.nullifier)\\n            & (self.contract_address == other.contract_address) \\n    }\\n}\\n\\nimpl Empty for ScopedNullifier {\\n    fn empty() -> Self {\\n        ScopedNullifier {\\n            nullifier: Nullifier::empty(),\\n            contract_address: AztecAddress::empty(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\\n    }\\n}\\n\\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\\n        let mut reader = Reader::new(values);\\n        let res = Self {\\n            nullifier: reader.read_struct(Nullifier::deserialize),\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n        };\\n        reader.finish();\\n        res\\n    }\\n}\\n\\nimpl Readable for ScopedNullifier {\\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\\n        assert_eq(self.nullifier.value, read_request.value(), \\"Value of the nullifier does not match read request\\");\\n        assert_eq(self.contract_address, read_request.contract_address, \\"Contract address of the nullifier does not match read request\\");\\n        assert(\\n            read_request.counter() > self.nullifier.counter, \\"Read request counter must be greater than the counter of the nullifier\\"\\n        );\\n    }\\n}\\n\\nimpl ScopedNullifier {\\n    pub fn nullified_note_hash(self) -> Field {\\n        self.nullifier.note_hash\\n    }\\n\\n    pub fn expose_to_public(self) -> Nullifier {\\n        // Hide the actual counter and note hash when exposing it to the public kernel.\\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = Nullifier::empty();\\n    let serialized = item.serialize();\\n    let deserialized = Nullifier::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n\\n#[test]\\nfn serialization_of_empty_scoped() {\\n    let item = ScopedNullifier::empty();\\n    let serialized = item.serialize();\\n    let deserialized = ScopedNullifier::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"193":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\\n\\nglobal SELECTOR_SIZE = 4;\\n\\nstruct FunctionSelector {\\n    // 1st 4-bytes of abi-encoding of function.\\n    inner: u32,\\n}\\n\\nimpl Eq for FunctionSelector {\\n    fn eq(self, function_selector: FunctionSelector) -> bool {\\n        function_selector.inner == self.inner\\n    }\\n}\\n\\nimpl Serialize<1> for FunctionSelector {\\n    fn serialize(self: Self) -> [Field; 1] {\\n        [self.inner as Field]\\n    }\\n}\\n\\nimpl Deserialize<1> for FunctionSelector {\\n    fn deserialize(fields: [Field; 1]) -> Self {\\n        Self {\\n            inner: fields[0] as u32\\n        }\\n    }\\n}\\n\\nimpl FromField for FunctionSelector {\\n    fn from_field(field: Field) -> Self {\\n        Self { inner: field as u32 }\\n    }\\n}\\n\\nimpl ToField for FunctionSelector {\\n    fn to_field(self) -> Field {\\n        self.inner as Field\\n    }\\n}\\n\\nimpl Empty for FunctionSelector {\\n    fn empty() -> Self {\\n        Self { inner: 0 as u32 }\\n    }\\n}\\n\\nimpl FunctionSelector {\\n    pub fn from_u32(value: u32) -> Self {\\n        Self { inner: value }\\n    }\\n\\n    pub fn from_signature<N>(signature: str<N>) -> Self {\\n        let bytes = signature.as_bytes();\\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\\n\\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\\n        for i in 0..SELECTOR_SIZE {\\n            selector_be_bytes[i] = hash[i];\\n        }\\n\\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\\n    }\\n\\n    pub fn zero() -> Self {\\n        Self { inner: 0 }\\n    }\\n}\\n"},"194":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr","source":"use crate::{\\n    abis::{\\n    private_call_stack_item::PrivateCallStackItem, call_context::CallContext,\\n    function_data::FunctionData, caller_context::CallerContext,\\n    side_effect::{Ordered, RangeOrdered, Scoped}\\n},\\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\\n};\\n\\nstruct PrivateCallRequest {\\n    target: AztecAddress,\\n    call_context: CallContext,\\n    function_data: FunctionData,\\n    args_hash: Field,\\n    returns_hash: Field,\\n    caller_context: CallerContext,\\n    start_side_effect_counter: u32,\\n    end_side_effect_counter: u32,\\n}\\n\\nimpl Ordered for PrivateCallRequest {\\n    fn counter(self) -> u32 {\\n        self.start_side_effect_counter\\n    }\\n}\\n\\nimpl RangeOrdered for PrivateCallRequest {\\n    fn counter_start(self) -> u32 {\\n        self.start_side_effect_counter\\n    }\\n    fn counter_end(self) -> u32 {\\n        self.end_side_effect_counter\\n    }\\n}\\n\\nimpl Eq for PrivateCallRequest {\\n    fn eq(self, other: PrivateCallRequest) -> bool {\\n        (self.target == other.target) \\n            & (self.call_context == other.call_context) \\n            & (self.function_data == other.function_data) \\n            & (self.args_hash == other.args_hash) \\n            & (self.returns_hash == other.returns_hash)\\n            & (self.caller_context == other.caller_context)\\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\\n    }\\n}\\n\\nimpl Empty for PrivateCallRequest {\\n    fn empty() -> Self {\\n        PrivateCallRequest {\\n            target: AztecAddress::empty(),\\n            call_context: CallContext::empty(),\\n            function_data: FunctionData::empty(),\\n            args_hash: 0,\\n            returns_hash: 0,\\n            caller_context: CallerContext::empty(),\\n            start_side_effect_counter: 0,\\n            end_side_effect_counter: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\\n\\n        fields.push(self.target.to_field());\\n        fields.extend_from_array(self.call_context.serialize());\\n        fields.extend_from_array(self.function_data.serialize());\\n        fields.push(self.args_hash);\\n        fields.push(self.returns_hash);\\n        fields.extend_from_array(self.caller_context.serialize());\\n        fields.push(self.start_side_effect_counter as Field);\\n        fields.push(self.end_side_effect_counter as Field);\\n\\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\\n        let mut reader = Reader::new(fields);\\n        let item = PrivateCallRequest {\\n            target: reader.read_struct(AztecAddress::deserialize),\\n            call_context: reader.read_struct(CallContext::deserialize),\\n            function_data: reader.read_struct(FunctionData::deserialize),\\n            args_hash: reader.read(),\\n            returns_hash: reader.read(),\\n            caller_context: reader.read_struct(CallerContext::deserialize),\\n            start_side_effect_counter: reader.read_u32(),\\n            end_side_effect_counter: reader.read_u32(),\\n        };\\n        reader.finish();\\n        item\\n    }\\n}\\n\\nimpl PrivateCallRequest {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\\n        ScopedPrivateCallRequest { call_request: self, contract_address }\\n    }\\n\\n    pub fn matches_stack_item(self, stack_item: PrivateCallStackItem) -> bool {\\n        (self.target == stack_item.contract_address)\\n            & (self.call_context == stack_item.public_inputs.call_context)\\n            & (self.function_data == stack_item.function_data)\\n            & (self.args_hash == stack_item.public_inputs.args_hash)\\n            & (self.returns_hash == stack_item.public_inputs.returns_hash)\\n            & (self.start_side_effect_counter\\n                                == stack_item.public_inputs.start_side_effect_counter)\\n            & (self.end_side_effect_counter\\n                                    == stack_item.public_inputs.end_side_effect_counter)\\n    }\\n}\\n\\nstruct ScopedPrivateCallRequest {\\n    call_request: PrivateCallRequest,\\n    contract_address: AztecAddress,\\n}\\n\\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\\n    fn inner(self) -> PrivateCallRequest {\\n        self.call_request\\n    }\\n    fn contract_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n}\\n\\nimpl Ordered for ScopedPrivateCallRequest {\\n    fn counter(self) -> u32 {\\n        self.call_request.counter_start()\\n    }\\n}\\n\\nimpl RangeOrdered for ScopedPrivateCallRequest {\\n    fn counter_start(self) -> u32 {\\n        self.call_request.counter_start()\\n    }\\n    fn counter_end(self) -> u32 {\\n        self.call_request.counter_end()\\n    }\\n}\\n\\nimpl Eq for ScopedPrivateCallRequest {\\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\\n        (self.call_request == other.call_request)\\n            & (self.contract_address == other.contract_address)\\n    }\\n}\\n\\nimpl Empty for ScopedPrivateCallRequest {\\n    fn empty() -> Self {\\n        ScopedPrivateCallRequest {\\n            call_request: PrivateCallRequest::empty(),\\n            contract_address: AztecAddress::zero(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\\n\\n        fields.extend_from_array(self.call_request.serialize());\\n        fields.extend_from_array(self.contract_address.serialize());\\n\\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\\n        let mut reader = Reader::new(fields);\\n        let item = ScopedPrivateCallRequest {\\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n        };\\n        reader.finish();\\n        item\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = ScopedPrivateCallRequest::empty();\\n    let serialized = item.serialize();\\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"199":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr","source":"use crate::{\\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\\n    abis::gas_fees::GasFees,\\n    constants::{\\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\\n    DEFAULT_INCLUSION_FEE\\n},\\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\\n    utils::reader::Reader\\n};\\n\\nstruct GasSettings {\\n    gas_limits: Gas,\\n    teardown_gas_limits: Gas,\\n    max_fees_per_gas: GasFees,\\n    inclusion_fee: Field,\\n}\\n\\nimpl GasSettings {\\n    pub fn new(\\n        gas_limits: Gas,\\n        teardown_gas_limits: Gas,\\n        max_fees_per_gas: GasFees,\\n        inclusion_fee: Field\\n    ) -> Self {\\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\\n    }\\n\\n    pub fn default() -> Self {\\n        GasSettings::new(\\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\\n            DEFAULT_INCLUSION_FEE\\n        )\\n    }\\n}\\n\\nimpl Eq for GasSettings {\\n    fn eq(self, other: Self) -> bool {\\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\\n    }\\n}\\n\\nimpl Empty for GasSettings {\\n    fn empty() -> Self {\\n        GasSettings::new(\\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\\n        )\\n    }\\n}\\n\\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\\n\\n        serialized.extend_from_array(self.gas_limits.serialize());\\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\\n        serialized.push(self.inclusion_fee);\\n    \\n        serialized.storage\\n    }\\n}\\n\\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\\n        let mut reader = Reader::new(serialized);\\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = GasSettings::empty();\\n    let serialized = item.serialize();\\n    let deserialized = GasSettings::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"208":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr","source":"use crate::{\\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\\n    address::AztecAddress,\\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\\n};\\n\\nstruct PrivateCallStackItem {\\n    // This is the _actual_ contract address relating to where this function\'s code resides in the\\n    // contract tree. Regardless of whether this is a call or delegatecall, this\\n    // `contract_address` _does not change_. Amongst other things, it\'s used as a lookup for\\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\\n    contract_address: AztecAddress,\\n    function_data: FunctionData,\\n    public_inputs: PrivateCircuitPublicInputs,\\n}\\n\\nimpl Eq for PrivateCallStackItem {\\n    fn eq(self, other: Self) -> bool {\\n        self.contract_address.eq(other.contract_address) &\\n        self.function_data.eq(other.function_data) &\\n        self.public_inputs.eq(other.public_inputs)\\n    }\\n}\\n\\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\\n\\n        fields.push(self.contract_address.to_field());\\n        fields.extend_from_array(self.function_data.serialize());\\n        fields.extend_from_array(self.public_inputs.serialize());\\n\\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\\n        let mut reader = Reader::new(serialized);\\n\\n        let item = Self {\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n            function_data: reader.read_struct(FunctionData::deserialize),\\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\\n        };\\n\\n        reader.finish();\\n        item\\n    }\\n}\\n\\nimpl Hash for PrivateCallStackItem {\\n    fn hash(self) -> Field {\\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\\n    }\\n}\\n\\nimpl Empty for PrivateCallStackItem {\\n    fn empty() -> Self {\\n        PrivateCallStackItem {\\n            contract_address: AztecAddress::empty(),\\n            function_data: FunctionData::empty(),\\n            public_inputs: PrivateCircuitPublicInputs::empty(),\\n        }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = PrivateCallStackItem::empty();\\n    let serialized = item.serialize();\\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n\\n#[test]\\nfn empty_hash() {\\n    let mut item = PrivateCallStackItem::empty();\\n    item.function_data.is_private = true;\\n    let hash = item.hash();\\n\\n    // Value from private_call_stack_item.test.ts \\"computes empty item hash\\" test\\n    let test_data_empty_hash = 0x065f2831db9ac0db5e710bd3a865b5facd8cf83f1585e1af8fd1d6ce9c47f685;\\n    assert_eq(hash, test_data_empty_hash);\\n}\\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr","source":"use crate::address::AztecAddress;\\nuse crate::traits::{Empty, Serialize, Deserialize};\\nuse crate::constants::CALLER_CONTEXT_LENGTH;\\nuse crate::utils::reader::Reader;\\n\\nstruct CallerContext {\\n    msg_sender: AztecAddress,\\n    storage_contract_address: AztecAddress,\\n    is_static_call: bool,\\n}\\n\\nimpl Eq for CallerContext {\\n    fn eq(self, other: CallerContext) -> bool {\\n        other.msg_sender.eq(self.msg_sender)\\n            & other.storage_contract_address.eq(self.storage_contract_address)\\n            & other.is_static_call == self.is_static_call\\n    }\\n}\\n\\nimpl Empty for CallerContext {\\n    fn empty() -> Self {\\n        CallerContext {\\n            msg_sender: AztecAddress::zero(),\\n            storage_contract_address: AztecAddress::zero(),\\n            is_static_call: false,\\n        }\\n    }\\n}\\n\\nimpl CallerContext {\\n    pub fn is_empty(self) -> bool {\\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\\n    }\\n\\n    // Different to an empty context, a hidden context won\'t reveal the caller\'s msg_sender and storage_contract_address,\\n    // but will still propagate the is_static_call flag.\\n    pub fn is_hidden(self) -> bool {\\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\\n    }\\n}\\n\\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\\n\\n    fields.extend_from_array(self.msg_sender.serialize());\\n    fields.extend_from_array(self.storage_contract_address.serialize());\\n    fields.push(self.is_static_call as Field);\\n\\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\\n\\n    fields.storage\\n  }\\n}\\n\\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\\n    let mut reader = Reader::new(fields);\\n\\n    let item = CallerContext {\\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\\n      is_static_call: reader.read_bool(),\\n    };\\n    reader.finish();\\n    item\\n  }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = CallerContext::empty();\\n    let serialized = item.serialize();\\n    let deserialized = CallerContext::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"211":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr","source":"use crate::{\\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\\n    constants::{\\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\\n},\\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\\n};\\n\\nstruct LogHash {\\n    value: Field,\\n    counter: u32,\\n    length: Field,\\n}\\n\\nimpl Ordered for LogHash {\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for LogHash {\\n    fn value(self) -> Field {\\n        self.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl Eq for LogHash {\\n    fn eq(self, other: LogHash) -> bool {\\n        (self.value == other.value)\\n            & (self.counter == other.counter)\\n            & (self.length == other.length) \\n    }\\n}\\n\\nimpl Empty for LogHash {\\n    fn empty() -> Self {\\n        LogHash {\\n            value: 0,\\n            counter: 0,\\n            length: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\\n        [self.value, self.counter as Field, self.length]\\n    }\\n}\\n\\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\\n        Self {\\n            value: values[0],\\n            counter: values[1] as u32,\\n            length: values[2],\\n        }\\n    }\\n}\\n\\nimpl LogHash {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\\n        ScopedLogHash { log_hash: self, contract_address }\\n    }\\n}\\n\\nstruct ScopedLogHash {\\n    log_hash: LogHash,\\n    contract_address: AztecAddress,\\n}\\n\\nimpl Scoped<LogHash> for ScopedLogHash {\\n    fn inner(self) -> LogHash {\\n        self.log_hash\\n    }\\n    fn contract_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n}\\n\\nimpl Ordered for ScopedLogHash {\\n    fn counter(self) -> u32 {\\n        self.log_hash.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for ScopedLogHash {\\n    fn value(self) -> Field {\\n        self.log_hash.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.log_hash.counter\\n    }\\n}\\n\\nimpl Eq for ScopedLogHash {\\n    fn eq(self, other: ScopedLogHash) -> bool {\\n        (self.log_hash == other.log_hash)\\n            & (self.contract_address == other.contract_address) \\n    }\\n}\\n\\nimpl Empty for ScopedLogHash {\\n    fn empty() -> Self {\\n        ScopedLogHash {\\n            log_hash: LogHash::empty(),\\n            contract_address: AztecAddress::empty(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\\n    }\\n}\\n\\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\\n        let mut reader = Reader::new(values);\\n        let res = Self {\\n            log_hash: reader.read_struct(LogHash::deserialize),\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n        };\\n        reader.finish();\\n        res\\n    }\\n}\\n\\nimpl ScopedLogHash {\\n    pub fn expose_to_public(self) -> LogHash {\\n        // Hide the counter when exposing to public.\\n        // The log hash must already be siloed when we call this.\\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\\n    }\\n}\\n\\nstruct EncryptedLogHash {\\n    value: Field,\\n    counter: u32,\\n    length: Field,\\n    randomness: Field,\\n}\\n\\nimpl Ordered for EncryptedLogHash {\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for EncryptedLogHash {\\n    fn value(self) -> Field {\\n        self.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl Eq for EncryptedLogHash {\\n    fn eq(self, other: EncryptedLogHash) -> bool {\\n        (self.value == other.value)\\n            & (self.counter == other.counter)\\n            & (self.length == other.length) \\n            & (self.randomness == other.randomness) \\n    }\\n}\\n\\nimpl Empty for EncryptedLogHash {\\n    fn empty() -> Self {\\n        EncryptedLogHash {\\n            value: 0,\\n            counter: 0,\\n            length: 0,\\n            randomness: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\\n        [self.value, self.counter as Field, self.length, self.randomness]\\n    }\\n}\\n\\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\\n        Self {\\n            value: values[0],\\n            counter: values[1] as u32,\\n            length: values[2],\\n            randomness: values[3],\\n        }\\n    }\\n}\\n\\nimpl EncryptedLogHash {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\\n    }\\n}\\n\\nstruct ScopedEncryptedLogHash {\\n    log_hash: EncryptedLogHash,\\n    contract_address: AztecAddress,\\n}\\n\\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\\n    fn inner(self) -> EncryptedLogHash {\\n        self.log_hash\\n    }\\n    fn contract_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n}\\n\\nimpl ScopedEncryptedLogHash {\\n    pub fn expose_to_public(self) -> LogHash {\\n        // Hide the secret randomness and counter when exposing to public\\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\\n        // The log hash will already be silo\'d when we call this\\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\\n    }\\n}\\n\\nimpl Ordered for ScopedEncryptedLogHash {\\n    fn counter(self) -> u32 {\\n        self.log_hash.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\\n    fn value(self) -> Field {\\n        self.log_hash.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.log_hash.counter\\n    }\\n}\\n\\nimpl Eq for ScopedEncryptedLogHash {\\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\\n        (self.log_hash == other.log_hash)\\n            & (self.contract_address == other.contract_address) \\n    }\\n}\\n\\nimpl Empty for ScopedEncryptedLogHash {\\n    fn empty() -> Self {\\n        ScopedEncryptedLogHash {\\n            log_hash: EncryptedLogHash::empty(),\\n            contract_address: AztecAddress::empty(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\\n    }\\n}\\n\\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\\n        let mut reader = Reader::new(values);\\n        let res = Self {\\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n        };\\n        reader.finish();\\n        res\\n    }\\n}\\n\\nstruct NoteLogHash {\\n    value: Field,\\n    counter: u32,\\n    length: Field,\\n    note_hash_counter: u32,\\n}\\n\\nimpl NoteLogHash {\\n    pub fn expose_to_public(self) -> LogHash {\\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\\n        LogHash { value: self.value, counter: 0, length: self.length }\\n    }\\n}\\n\\nimpl Ordered for NoteLogHash {\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl OrderedValue<Field> for NoteLogHash {\\n    fn value(self) -> Field {\\n        self.value\\n    }\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl Eq for NoteLogHash {\\n    fn eq(self, other: NoteLogHash) -> bool {\\n        (self.value == other.value)\\n            & (self.counter == other.counter)\\n            & (self.length == other.length) \\n            & (self.note_hash_counter == other.note_hash_counter) \\n    }\\n}\\n\\nimpl Empty for NoteLogHash {\\n    fn empty() -> Self {\\n        NoteLogHash {\\n            value: 0,\\n            counter: 0,\\n            length: 0,\\n            note_hash_counter: 0,\\n        }\\n    }\\n}\\n\\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\\n    }\\n}\\n\\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\\n        Self {\\n            value: values[0],\\n            counter: values[1] as u32,\\n            length: values[2],\\n            note_hash_counter: values[3] as u32,\\n        }\\n    }\\n}\\n"},"215":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr","source":"struct AppendOnlyTreeSnapshot {\\n    root : Field,\\n    // TODO(Alvaro) change this to a u64\\n    next_available_leaf_index : u32\\n}\\n\\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\\n\\nimpl AppendOnlyTreeSnapshot {\\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\\n        [self.root, self.next_available_leaf_index as Field]\\n    }\\n\\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\\n    }\\n\\n    pub fn zero() -> Self {\\n        Self { root: 0, next_available_leaf_index: 0 }\\n    }\\n}\\n\\nimpl Eq for AppendOnlyTreeSnapshot {\\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\\n    }\\n}\\n"},"216":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\\n    abis::function_selector::FunctionSelector, address::AztecAddress,\\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\\n};\\n\\n// docs:start:call-context\\nstruct CallContext {\\n    msg_sender : AztecAddress,\\n    storage_contract_address : AztecAddress,\\n    function_selector : FunctionSelector,\\n\\n    is_delegate_call : bool,\\n    is_static_call : bool,\\n}\\n// docs:end:call-context\\n\\nimpl Eq for CallContext {\\n    fn eq(self, other: CallContext) -> bool {\\n        self.serialize() == other.serialize()\\n    }\\n}\\n\\nimpl Hash for CallContext {\\n    fn hash(self) -> Field {\\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\\n    }\\n}\\n\\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\\n\\n        serialized.push(self.msg_sender.to_field());\\n        serialized.push(self.storage_contract_address.to_field());\\n        serialized.push(self.function_selector.to_field());\\n        serialized.push(self.is_delegate_call as Field);\\n        serialized.push(self.is_static_call as Field);\\n    \\n        serialized.storage\\n    }\\n}\\n\\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\\n        let mut reader = Reader::new(serialized);\\n        CallContext {\\n            msg_sender: AztecAddress::from_field(reader.read()),\\n            storage_contract_address: AztecAddress::from_field(reader.read()),\\n            function_selector: FunctionSelector::from_field(reader.read()),\\n            is_delegate_call: reader.read() as bool,\\n            is_static_call: reader.read() as bool,\\n        }\\n    }\\n}\\n\\nimpl Empty for CallContext {\\n    fn empty() -> Self {\\n        CallContext {\\n            msg_sender: AztecAddress::empty(),\\n            storage_contract_address: AztecAddress::empty(),\\n            function_selector: FunctionSelector::empty(),\\n            is_delegate_call: false,\\n            is_static_call: false,\\n        }\\n    }\\n}\\n\\n#[test]\\nfn serialize_deserialize_of_empty() {\\n    let context = CallContext::empty();\\n    let serialized = context.serialize();\\n    let deserialized = CallContext::deserialize(serialized);\\n    assert(context.eq(deserialized));\\n}\\n\\n#[test]\\nfn test_eq() {\\n    let mut context1 = CallContext::empty();\\n    let mut context2 = CallContext::empty();\\n\\n    context1.is_delegate_call = true;\\n    context2.is_delegate_call = true;\\n\\n    let address: AztecAddress = AztecAddress::from_field(69420);\\n    context1.msg_sender = address;\\n    context2.msg_sender = address;\\n\\n    assert(context1.eq(context2));\\n}\\n\\n#[test(should_fail)]\\nfn not_eq_test_eq() {\\n    let mut context1 = CallContext::empty();\\n    let mut context2 = CallContext::empty();\\n\\n    context1.is_delegate_call = true;\\n    context2.is_delegate_call = false;\\n\\n    let address1: AztecAddress = AztecAddress::from_field(69420);\\n    let address2: AztecAddress = AztecAddress::from_field(42069);\\n\\n    context1.msg_sender = address1;\\n    context2.msg_sender = address2;\\n\\n    assert(context1.eq(context2));\\n}\\n\\n#[test]\\nfn hash_smoke() {\\n    let context = CallContext::empty();\\n    let _hashed = context.hash();\\n}\\n"},"217":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\\n\\nstruct MaxBlockNumber {\\n    _opt: Option<u32>\\n}\\n\\nimpl Empty for MaxBlockNumber {\\n    fn empty() -> Self {\\n        Self { _opt: Option::none() }\\n    }\\n}\\n\\nimpl Eq for MaxBlockNumber {\\n    fn eq(self, other: Self) -> bool {\\n        self._opt == other._opt\\n    }\\n}\\n\\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\\n        [self._opt._is_some as Field, self._opt._value as Field]\\n    }\\n}\\n\\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\\n        MaxBlockNumber {\\n            _opt: Option {\\n                _is_some: serialized[0] as bool,\\n                _value: serialized[1] as u32,\\n            }\\n        }\\n    }\\n}\\n\\nimpl MaxBlockNumber {\\n    pub fn new(max_block_number: u32) -> Self {\\n        Self { _opt: Option::some(max_block_number) }\\n    }\\n\\n    pub fn is_none(self) -> bool {\\n        self._opt.is_none()\\n    }\\n\\n    pub fn is_some(self) -> bool {\\n        self._opt.is_some()\\n    }\\n\\n    pub fn unwrap(self) -> u32 {\\n        self._opt.unwrap()\\n    }\\n\\n    pub fn unwrap_unchecked(self) -> u32 {\\n        self._opt.unwrap_unchecked()\\n    }\\n\\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\\n        if rhs.is_none() {\\n            lhs // lhs might also be none, but in that case both would be\\n        } else {\\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\\n        }\\n    }\\n\\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\\n        if lhs._opt.is_none() {\\n            MaxBlockNumber::new(rhs)\\n        } else {\\n            let lhs_value = lhs._opt.unwrap_unchecked();\\n\\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\\n        }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let item = MaxBlockNumber::empty();\\n    let serialized = item.serialize();\\n    let deserialized = MaxBlockNumber::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n\\n#[test]\\nfn zeroed_is_none() {\\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\\n    // and though we should eventually move everything to use `default`, it\'s good to check for now that both are\\n    // equivalent.\\n    let a = MaxBlockNumber::empty();\\n    assert(a.is_none());\\n}\\n\\n#[test]\\nfn serde_default() {\\n    let a = MaxBlockNumber::empty();\\n    let b = MaxBlockNumber::deserialize(a.serialize());\\n    assert(b.is_none());\\n}\\n\\n#[test]\\nfn serde_some() {\\n    let a = MaxBlockNumber::new(13);\\n    let b = MaxBlockNumber::deserialize(a.serialize());\\n    assert_eq(b.unwrap(), 13);\\n}\\n\\n#[test(should_fail)]\\nfn default_unwrap_panics() {\\n    let a = MaxBlockNumber::empty();\\n    let _ = a.unwrap();\\n}\\n\\n#[test]\\nfn min_default_default() {\\n    let a = MaxBlockNumber::empty();\\n    let b = MaxBlockNumber::empty();\\n\\n    assert(MaxBlockNumber::min(a, b).is_none());\\n}\\n\\n#[test]\\nfn min_default_some() {\\n    let a = MaxBlockNumber::empty();\\n    let b = MaxBlockNumber::new(13);\\n\\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\\n}\\n\\n#[test]\\nfn min_some_some() {\\n    let a = MaxBlockNumber::new(13);\\n    let b = MaxBlockNumber::new(42);\\n\\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\\n}\\n\\n#[test]\\nfn min_with_u32_default() {\\n    let a = MaxBlockNumber::empty();\\n    let b = 42;\\n\\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\\n}\\n\\n#[test]\\nfn min_with_u32_some() {\\n    let a = MaxBlockNumber::new(13);\\n    let b = 42;\\n    let c = 8;\\n\\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\\n}\\n"},"220":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr","source":"use crate::{\\n    abis::function_selector::FunctionSelector,\\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\\n    traits::{Serialize, Hash, Deserialize, Empty}\\n};\\n\\nstruct FunctionData {\\n    selector : FunctionSelector,\\n    is_private : bool,\\n}\\n\\nimpl Eq for FunctionData {\\n    fn eq(self, other: Self) -> bool {\\n        self.selector.eq(other.selector) &\\n        (self.is_private == other.is_private)\\n    }\\n}\\n\\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\\n    // A field is ~256 bits\\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\\n    // This method will simply return a bit packed Field instead of hashing\\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\\n        [\\n            self.selector.to_field(),\\n            self.is_private as Field,\\n        ]\\n    }\\n}\\n\\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\\n        Self {\\n            selector: FunctionSelector::from_field(serialized[0]),\\n            is_private: serialized[1] as bool,\\n        }\\n    }\\n}\\n\\nimpl Hash for FunctionData {\\n    fn hash(self) -> Field {\\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\\n    }\\n}\\n\\nimpl Empty for FunctionData {\\n    fn empty() -> Self {\\n        FunctionData {\\n            selector: FunctionSelector::empty(),\\n            is_private: false\\n        }\\n    }\\n\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let data = FunctionData::empty();\\n    let serialized = data.serialize();\\n    let deserialized = FunctionData::deserialize(serialized);\\n    assert(data.eq(deserialized));\\n}\\n\\n#[test]\\nfn empty_hash() {\\n    let data = FunctionData::empty();\\n    let hash = data.hash();\\n\\n    // Value from function_data.test.ts \\"computes empty function data hash\\" test\\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\\n    assert_eq(hash, test_data_empty_hash);\\n}\\n"},"227":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr","source":"use crate::{\\n    address::{AztecAddress, EthAddress},\\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\\n    utils::{arrays::array_concat, reader::Reader}\\n};\\n\\n// Note: Not to be confused with L2ToL1Msg in Solidity\\nstruct L2ToL1Message {\\n    recipient: EthAddress,\\n    content: Field,\\n    counter: u32,\\n}\\n\\nimpl Ordered for L2ToL1Message {\\n    fn counter(self) -> u32 {\\n        self.counter\\n    }\\n}\\n\\nimpl Empty for L2ToL1Message {\\n    fn empty() -> Self {\\n        Self {\\n            recipient: EthAddress::empty(),\\n            content: 0,\\n            counter: 0,\\n        }\\n    }\\n}\\n\\nimpl Eq for L2ToL1Message {\\n    fn eq(self, other: Self) -> bool {\\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\\n    }\\n}\\n\\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\\n        [self.recipient.to_field(), self.content, self.counter as Field]\\n    }\\n}\\n\\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\\n        Self {\\n            recipient: EthAddress::from_field(values[0]),\\n            content: values[1],\\n            counter: values[2] as u32,\\n        }\\n    }\\n}\\n\\nimpl L2ToL1Message {\\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\\n        ScopedL2ToL1Message { message: self, contract_address }\\n    }\\n}\\n\\nstruct ScopedL2ToL1Message {\\n    message: L2ToL1Message,\\n    contract_address: AztecAddress,\\n}\\n\\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\\n    fn inner(self) -> L2ToL1Message {\\n        self.message\\n    }\\n    fn contract_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n}\\n\\nimpl Ordered for ScopedL2ToL1Message {\\n    fn counter(self) -> u32 {\\n        self.message.counter\\n    }\\n}\\n\\nimpl Eq for ScopedL2ToL1Message {\\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\\n        (self.message == other.message)\\n            & (self.contract_address == other.contract_address) \\n    }\\n}\\n\\nimpl Empty for ScopedL2ToL1Message {\\n    fn empty() -> Self {\\n        ScopedL2ToL1Message {\\n            message: L2ToL1Message::empty(),\\n            contract_address: AztecAddress::empty(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\\n    }\\n}\\n\\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\\n        let mut reader = Reader::new(values);\\n        let res = Self {\\n            message: reader.read_struct(L2ToL1Message::deserialize),\\n            contract_address: reader.read_struct(AztecAddress::deserialize),\\n        };\\n        reader.finish();\\n        res\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty_l2() {\\n    let item = L2ToL1Message::empty();\\n    let serialized = item.serialize();\\n    let deserialized = L2ToL1Message::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n\\n#[test]\\nfn serialization_of_empty_scoped_l2() {\\n    let item = ScopedL2ToL1Message::empty();\\n    let serialized = item.serialize();\\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\\n    assert(item.eq(deserialized));\\n}\\n"},"229":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\\n\\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\\n    pedersen_hash([storage_slot, key.to_field()], 0)\\n}\\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\\n\\nglobal BOOL_SERIALIZED_LEN: Field = 1;\\nglobal U8_SERIALIZED_LEN: Field = 1;\\nglobal U32_SERIALIZED_LEN: Field = 1;\\nglobal U64_SERIALIZED_LEN: Field = 1;\\nglobal U128_SERIALIZED_LEN: Field = 1;\\nglobal FIELD_SERIALIZED_LEN: Field = 1;\\n\\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\\n        fields[0] as bool\\n    }\\n}\\n\\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u8\\n    }\\n}\\n\\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u32\\n    }\\n}\\n\\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u64\\n    }\\n}\\n\\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\\n    fn serialize(self) -> [Field; 1] {\\n        [self.to_integer()]\\n    }\\n\\n}\\n\\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\\n        U128::from_integer(fields[0])\\n    }\\n}\\n\\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\\n        [self]\\n    }\\n}\\n\\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\\n        fields[0]\\n    }\\n}\\n"},"235":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\\n\\n// Trait: is_empty\\n//\\n// The general is_empty trait checks if a data type is is empty,\\n// and it defines empty for the basic data types as 0.\\n//\\n// If a Field is equal to zero, then it is regarded as zero.\\n// We will go with this definition for now, however it can be problematic \\n// if a value can actually be zero. In a future refactor, we can \\n// use the optional type for safety. Doing it now would lead to a worse devex\\n// and would make it harder to sync up with the cpp code.\\n// Preferred over Default trait to convey intent, as default doesn\'t necessarily mean empty.\\ntrait Empty {\\n    fn empty() -> Self;\\n}\\n\\nimpl Empty for Field { fn empty() -> Self {0} }\\n\\nimpl Empty for u1 { fn empty() -> Self {0} }\\nimpl Empty for u8 { fn empty() -> Self {0} }\\nimpl Empty for u32 { fn empty() -> Self {0} }\\nimpl Empty for u64 { fn empty() -> Self {0} }\\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\\n\\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\\n    item.eq(T::empty())\\n}\\n\\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\\n    array.all(|elem| is_empty(elem))\\n}\\n\\ntrait Hash {\\n    fn hash(self) -> Field;\\n}\\n\\ntrait ToField {\\n    fn to_field(self) -> Field;\\n}\\n\\nimpl ToField for Field {\\n    fn to_field(self) -> Field {\\n        self\\n    }\\n}\\n\\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\\nimpl ToField for U128 {\\n    fn to_field(self) -> Field {\\n        self.to_integer()\\n    }\\n}\\nimpl<N> ToField for str<N> {\\n    fn to_field(self) -> Field {\\n        assert(N < 32, \\"String doesn\'t fit in a field, consider using Serialize instead\\");\\n        field_from_bytes(self.as_bytes(), true)\\n    }\\n}\\n\\ntrait FromField {\\n    fn from_field(value: Field) -> Self;\\n}\\n\\nimpl FromField for Field {\\n    fn from_field(value: Field) -> Self {\\n        value\\n    }\\n}\\n\\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\\nimpl FromField for U128 {\\n    fn from_field(value: Field) -> Self {\\n        U128::from_integer(value)\\n    }\\n}\\n\\n// docs:start:serialize\\ntrait Serialize<N> {\\n    fn serialize(self) -> [Field; N];\\n}\\n// docs:end:serialize\\n\\nimpl<N> Serialize<N> for [Field; N] {\\n    fn serialize(self) -> [Field; N] {\\n        self\\n    }\\n}\\nimpl<N> Serialize<N> for str<N> {\\n    fn serialize(self) -> [Field; N] {\\n        let mut result = [0; N];\\n        let bytes: [u8; N] = self.as_bytes();\\n        for i in 0..N {\\n            result[i] = field_from_bytes([bytes[i];1], true);\\n        }\\n        result\\n    }\\n}\\n\\n// docs:start:deserialize\\ntrait Deserialize<N> {\\n    fn deserialize(fields: [Field; N]) -> Self;\\n}\\n// docs:end:deserialize\\n\\nimpl<N> Deserialize<N> for [Field; N] {\\n    fn deserialize(fields: [Field; N]) -> Self {\\n        fields\\n    }\\n}\\n"},"236":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"// Utility function to console.log data in the acir simulator\\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \\"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\\"`\\n\\n#[oracle(debugLog)]\\nunconstrained fn debug_log_oracle<M, N>(_msg: str<M>, args: [Field]) {}\\n\\n/// NOTE: call this with a str<N> msg of form\\n/// \\"some string with {0} and {1} ... {N}\\"\\n/// and an array of N field which will be formatted\\n/// into the string in the simulator.\\n/// Example:\\n/// debug_log_format(\\"get_2(slot:{0}) =>\\\\n\\\\t0:{1}\\\\n\\\\t1:{2}\\", [storage_slot, note0_hash, note1_hash]);\\n/// debug_log_format(\\"whole array: {}\\", [e1, e2, e3, e4]);\\nunconstrained pub fn debug_log_format<M, N>(msg: str<M>, args: [Field; N]) {\\n    debug_log_oracle(msg, args.as_slice());\\n}\\n\\n/// NOTE: call this with a str<N> msg of length > 1\\n/// Example:\\n/// `debug_log(\\"blah blah this is a debug string\\");`\\nunconstrained pub fn debug_log<N>(msg: str<N>) {\\n    debug_log_format(msg, []);\\n}\\n"},"237":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr","source":"use crate::{\\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\\n    utils::arr_copy_slice\\n};\\n\\nstruct ContentCommitment {\\n  num_txs: Field,\\n  txs_effects_hash: Field,\\n  in_hash: Field,\\n  out_hash: Field,\\n}\\n\\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\\n\\n    fields.push(self.num_txs);\\n    fields.push(self.txs_effects_hash);\\n    fields.push(self.in_hash);\\n    fields.push(self.out_hash);\\n\\n    fields.storage\\n  }\\n}\\n\\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\\n    let num_txs = serialized[0];\\n\\n    let txs_effects_hash = serialized[1];\\n\\n    let in_hash = serialized[2];\\n\\n    let out_hash = serialized[3];\\n\\n    Self {\\n      num_txs,\\n      txs_effects_hash,\\n      in_hash,\\n      out_hash,\\n    }\\n  }\\n}\\n\\nimpl Empty for ContentCommitment {\\n  fn empty() -> Self {\\n    Self {\\n      num_txs: 0,\\n      txs_effects_hash: 0,\\n      in_hash: 0,\\n      out_hash: 0,\\n    }\\n  }\\n}\\n\\nimpl Eq for ContentCommitment {\\n  fn eq(self, other: Self) -> bool {\\n    (self.num_txs == other.num_txs)\\n      & (self.txs_effects_hash == other.txs_effects_hash)\\n      & (self.in_hash == other.in_hash)\\n      & (self.out_hash == other.out_hash)\\n  }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let empty = ContentCommitment::empty();\\n    let serialized = empty.serialize();\\n    let deserialized = ContentCommitment::deserialize(serialized);\\n\\n    assert(empty.eq(deserialized));\\n}\\n"},"238":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\\n\\nstruct PublicDataTreeLeafPreimage {\\n    slot : Field,\\n    value: Field,\\n    next_slot :Field,\\n    next_index : u32,\\n}\\n\\nimpl Empty for PublicDataTreeLeafPreimage {\\n    fn empty() -> Self {\\n        Self {\\n            slot: 0,\\n            value: 0,\\n            next_slot: 0,\\n            next_index: 0,\\n        }\\n    }\\n}\\n\\nimpl Hash for PublicDataTreeLeafPreimage {\\n    fn hash(self) -> Field {\\n        if self.is_empty() {\\n            0\\n        } else {\\n            std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\\n        }\\n    }\\n}\\n\\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\\n    fn get_key(self) -> Field {\\n        self.slot\\n    }\\n\\n    fn get_next_key(self) -> Field {\\n        self.next_slot\\n    }\\n\\n    fn as_leaf(self) -> Field {\\n        self.hash()\\n    }\\n}\\n\\nimpl PublicDataTreeLeafPreimage {\\n    pub fn is_empty(self) -> bool {\\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\\n    }\\n}\\n"},"239":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr","source":"use crate::{\\n    abis::{\\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\\n},\\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\\n    utils::arr_copy_slice, content_commitment::ContentCommitment\\n};\\n\\n// docs:start:header\\nstruct Header {\\n    last_archive: AppendOnlyTreeSnapshot,\\n    content_commitment: ContentCommitment,\\n    state: StateReference,\\n    global_variables: GlobalVariables,\\n    total_fees: Field\\n}\\n// docs:end:header\\n\\nimpl Eq for Header {\\n    fn eq(self, other: Self) -> bool {\\n        self.last_archive.eq(other.last_archive) &\\n        self.content_commitment.eq(other.content_commitment) &\\n        self.state.eq(other.state) &\\n        self.global_variables.eq(other.global_variables) &\\n        self.total_fees.eq(other.total_fees)\\n    }\\n}\\n\\nimpl Serialize<HEADER_LENGTH> for Header {\\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\\n\\n        fields.extend_from_array(self.last_archive.serialize());\\n        fields.extend_from_array(self.content_commitment.serialize());\\n        fields.extend_from_array(self.state.serialize());\\n        fields.extend_from_array(self.global_variables.serialize());\\n        fields.push(self.total_fees);\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<HEADER_LENGTH> for Header {\\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\\n        let mut offset = 0;\\n\\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\\n\\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\\n\\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\\n        offset = offset + STATE_REFERENCE_LENGTH;\\n\\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\\n\\n        let total_fees = serialized[offset];\\n\\n        Header {\\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\\n            state: StateReference::deserialize(state_fields),\\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\\n            total_fees\\n        }\\n    }\\n}\\n\\nimpl Empty for Header {\\n    fn empty() -> Self {\\n        Self {\\n            last_archive: AppendOnlyTreeSnapshot::zero(),\\n            content_commitment: ContentCommitment::empty(),\\n            state: StateReference::empty(),\\n            global_variables: GlobalVariables::empty(),\\n            total_fees: 0\\n        }\\n    }\\n}\\n\\nimpl Hash for Header {\\n    fn hash(self) -> Field {\\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let header = Header::empty();\\n    let serialized = header.serialize();\\n    let deserialized = Header::deserialize(serialized);\\n    assert(header.eq(deserialized));\\n}\\n\\n#[test]\\nfn hash_smoke() {\\n    let header = Header::empty();\\n    let _hashed = header.hash();\\n}\\n\\n#[test]\\nfn empty_hash_is_zero() {\\n    let header = Header::empty();\\n    let hash = header.hash();\\n\\n    // Value from new_contract_data.test.ts \\"computes empty hash\\" test\\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\\n    assert_eq(hash, test_data_empty_hash);\\n}\\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\\n    abis::{\\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\\n},\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\\n},\\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\\n    recursion::verification_key::VerificationKey, traits::is_empty,\\n    utils::field::field_from_bytes_32_trunc\\n};\\nuse std::hash::{pedersen_hash_with_separator, sha256};\\n\\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\\n    let sha256_hashed = sha256(bytes_to_hash);\\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\\n\\n    hash_in_a_field\\n}\\n\\npub fn private_functions_root_from_siblings(\\n    selector: FunctionSelector,\\n    vk_hash: Field,\\n    function_leaf_index: Field,\\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\\n) -> Field {\\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\\n    let function_leaf = function_leaf_preimage.hash();\\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\\n}\\n\\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\\n    // Hashing tx hash with note index in tx is guaranteed to be unique\\n    pedersen_hash(\\n        [\\n        tx_hash,\\n        note_index_in_tx as Field\\n    ],\\n        GENERATOR_INDEX__NOTE_HASH_NONCE\\n    )\\n}\\n\\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\\n    let inputs = [nonce, inner_note_hash];\\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\\n}\\n\\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\\n    pedersen_hash(\\n        [\\n        app.to_field(),\\n        unique_note_hash\\n    ],\\n        GENERATOR_INDEX__SILOED_NOTE_HASH\\n    )\\n}\\n\\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\\n    if note_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\\n    }\\n}\\n\\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\\n    pedersen_hash(\\n        [\\n        app.to_field(),\\n        nullifier\\n    ],\\n        GENERATOR_INDEX__OUTER_NULLIFIER\\n    )\\n}\\n\\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\\n    if nullifier.contract_address.is_zero() {\\n        nullifier.value() // Return value instead of 0 because the first nullifier\'s contract address is zero.\\n    } else {\\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\\n    }\\n}\\n\\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\\n    // NB: A unique separator will be needed for masked_contract_address\\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\\n    if randomness == 0 {\\n        // In some cases, we actually want to reveal the contract address we are siloing with:\\n        // e.g. \'handshaking\' contract w/ known address\\n        // An app providing randomness = 0 signals to not mask the address.\\n        masked_contract_address = address.to_field();\\n    }\\n    accumulate_sha256([masked_contract_address, log_hash])\\n}\\n\\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\\n    if log_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_encrypted_log_hash(\\n            log_hash.contract_address,\\n            log_hash.log_hash.randomness,\\n            log_hash.log_hash.value\\n        )\\n    }\\n}\\n\\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\\n    accumulate_sha256([address.to_field(), log_hash])\\n}\\n\\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\\n    if log_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\\n    }\\n}\\n\\npub fn merkle_hash(left: Field, right: Field) -> Field {\\n    pedersen_hash([left, right], 0)\\n}\\n\\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\\n    // Original cpp code\\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\\n    // The above cpp method is only ever called on verification key, so it has been special cased here\\n    let _hash_index = GENERATOR_INDEX__VK;\\n    0\\n}\\n\\npub fn compute_l2_to_l1_hash(\\n    contract_address: AztecAddress,\\n    recipient: EthAddress,\\n    content: Field,\\n    rollup_version_id: Field,\\n    chain_id: Field\\n) -> Field {\\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\\n\\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\\n    for i in 0..inputs.len() {\\n        // TODO are bytes be in fr.to_buffer() ?\\n        let item_bytes = inputs[i].to_be_bytes(32);\\n        for j in 0..32 {\\n            bytes.push(item_bytes[j]);\\n        }\\n    }\\n\\n    sha256_to_field(bytes.storage)\\n}\\n\\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\\n    if msg.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_l2_to_l1_hash(\\n            msg.contract_address,\\n            msg.message.recipient,\\n            msg.message.content,\\n            rollup_version_id,\\n            chain_id\\n        )\\n    }\\n}\\n\\n// Computes sha256 hash of 2 input hashes.\\n//\\n// NB: This method now takes in two 31 byte fields - it assumes that any input\\n// is the result of a sha_to_field hash and => is truncated\\n//\\n// TODO(Jan and David): This is used for the encrypted_log hashes.\\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\\n//\\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\\n    // This is a note about the cpp code, since it takes an array of Fields\\n    // instead of a U128.\\n    // 4 Field elements when converted to bytes will usually \\n    // occupy 4 * 32 = 128 bytes.\\n    // However, this function is making the assumption that each Field \\n    // only occupies 128 bits.\\n    //\\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\\n\\n    // Concatentate two fields into 32x2 = 64 bytes\\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\\n    let mut hash_input_flattened = [0; 64];\\n    for offset in 0..input.len() {\\n        let input_as_bytes = input[offset].to_be_bytes(32);\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n\\n    sha256_to_field(hash_input_flattened)\\n}\\n\\n// Computes the final logs hash for a tx.\\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\\n// to avoid doubling code, since we can\'t define the byte len to be 32*N directly. \\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n    // Ideally we would push to a slice then hash, but there is no sha_slice\\n    // Hardcode to 256 bytes for now\\n    let mut hash = sha256_to_field(hash_input_flattened);\\n    // Not having a 0 value hash for empty logs causes issues with empty txs\\n    // used for padding. Returning early is currently unsupported.\\n    // We always provide sorted logs here, so 0 being empty means all are empty.\\n    if is_empty(logs[0]) {\\n        hash = 0;\\n    }\\n    hash\\n}\\n\\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n    // Ideally we would push to a slice then hash, but there is no sha_slice\\n    // Hardcode to 256 bytes for now\\n    let mut hash = sha256_to_field(hash_input_flattened);\\n    // Not having a 0 value hash for empty logs causes issues with empty txs\\n    // used for padding. Returning early is currently unsupported.\\n    // We always provide sorted logs here, so 0 being empty means all are empty.\\n    if is_empty(logs[0]) {\\n        hash = 0;\\n    }\\n    hash\\n}\\n\\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\\n}\\n\\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\\n}\\n\\n#[test]\\nfn smoke_sha256_to_field() {\\n    let full_buffer = [\\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\\n    ];\\n    let result = sha256_to_field(full_buffer);\\n\\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\\n\\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\\n    let result_bytes = sha256(full_buffer);\\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\\n    assert(truncated_field == result);\\n    let mod_res = result + (result_bytes[31] as Field);\\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\\n}\\n\\n#[test]\\nfn compute_l2_l1_hash() {\\n    // All zeroes\\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\\n\\n    // Non-zero case\\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\\n}\\n"},"241":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr","source":"use crate::{\\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\\n    traits::{Deserialize, Empty, Serialize}\\n};\\n\\nstruct PartialStateReference {\\n    note_hash_tree: AppendOnlyTreeSnapshot,\\n    nullifier_tree: AppendOnlyTreeSnapshot,\\n    public_data_tree: AppendOnlyTreeSnapshot,\\n}\\n\\nimpl Eq for PartialStateReference {\\n    fn eq(self, other: PartialStateReference) -> bool {\\n        self.note_hash_tree.eq(other.note_hash_tree) &\\n        self.nullifier_tree.eq(other.nullifier_tree) &\\n        self.public_data_tree.eq(other.public_data_tree)\\n    }\\n}\\n\\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\\n        let serialized_public_data_tree = self.public_data_tree.serialize();\\n\\n        [\\n            serialized_note_hash_tree[0], \\n            serialized_note_hash_tree[1],\\n            serialized_nullifier_tree[0],\\n            serialized_nullifier_tree[1],\\n            serialized_public_data_tree[0],\\n            serialized_public_data_tree[1],\\n        ]\\n    }\\n}\\n\\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\\n        PartialStateReference {\\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\\n                [serialized[0], serialized[1]]\\n            ),\\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\\n                [serialized[2], serialized[3]]\\n            ),\\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\\n                [serialized[4], serialized[5]]\\n            ),\\n        }\\n    }\\n}\\n\\nimpl Empty for PartialStateReference {\\n    fn empty() -> Self {\\n        Self {\\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\\n        }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let partial = PartialStateReference::empty();\\n    let _serialized = partial.serialize();\\n    let _deserialized = PartialStateReference::deserialize(_serialized);\\n}\\n"},"243":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr","source":"use crate::{\\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\\n    abis::gas_settings::GasSettings\\n};\\n\\n// docs:start:tx-context\\nstruct TxContext {\\n    chain_id : Field,\\n    version : Field,\\n    gas_settings: GasSettings,\\n}\\n// docs:end:tx-context\\n\\nimpl TxContext {\\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\\n        TxContext { chain_id, version, gas_settings }\\n    }\\n}\\n\\nimpl Eq for TxContext {\\n    fn eq(self, other: Self) -> bool {\\n        (self.chain_id == other.chain_id) &\\n        (self.version == other.version) &\\n        (self.gas_settings.eq(other.gas_settings))\\n    }\\n}\\n\\nimpl Empty for TxContext {\\n    fn empty() -> Self {\\n        TxContext {\\n            chain_id: 0,\\n            version: 0,\\n            gas_settings: GasSettings::empty(),\\n        }\\n    }\\n}\\n\\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\\n\\n        fields.push(self.chain_id);\\n        fields.push(self.version);\\n        fields.extend_from_array(self.gas_settings.serialize());\\n\\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\\n        let mut reader = Reader::new(serialized);\\n\\n        let context = Self {\\n            chain_id: reader.read(),\\n            version: reader.read(),\\n            gas_settings: reader.read_struct(GasSettings::deserialize),\\n        };\\n\\n        reader.finish();\\n        context\\n    }\\n}\\n\\nimpl Hash for TxContext {\\n    fn hash(self) -> Field {\\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let context = TxContext::empty();\\n    let serialized = context.serialize();\\n    let deserialized = TxContext::deserialize(serialized);\\n    assert(context.eq(deserialized));\\n}\\n\\n#[test]\\nfn empty_hash() {\\n    let context = TxContext::empty();\\n    let hash = context.hash();\\n\\n    // Value from tx_context.test.ts \\"computes empty item hash\\" test\\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\\n    assert_eq(hash, test_data_empty_hash);\\n}\\n"},"247":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\\n    address::{\\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\\n    public_keys_hash::PublicKeysHash\\n},\\n    contract_class_id::ContractClassId,\\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\\n    traits::{Deserialize, Hash, Serialize}\\n};\\n\\nstruct ContractInstance {\\n    salt : Field,\\n    deployer: AztecAddress,\\n    contract_class_id : ContractClassId,\\n    initialization_hash : Field,\\n    public_keys_hash : PublicKeysHash,\\n}\\n\\nimpl Eq for ContractInstance {\\n    fn eq(self, other: Self) -> bool {\\n        self.public_keys_hash.eq(other.public_keys_hash) &\\n        self.initialization_hash.eq(other.initialization_hash) &\\n        self.contract_class_id.eq(other.contract_class_id) &\\n        self.salt.eq(other.salt)\\n    }\\n}\\n\\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\\n        [\\n            self.salt,\\n            self.deployer.to_field(),\\n            self.contract_class_id.to_field(),\\n            self.initialization_hash,\\n            self.public_keys_hash.to_field()\\n        ]\\n    }\\n}\\n\\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\\n        Self {\\n            salt: serialized[0],\\n            deployer: AztecAddress::from_field(serialized[1]),\\n            contract_class_id: ContractClassId::from_field(serialized[2]),\\n            initialization_hash: serialized[3],\\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\\n        }\\n    }\\n}\\n\\nimpl Hash for ContractInstance {\\n    fn hash(self) -> Field {\\n        self.to_address().to_field()\\n    }\\n}\\n\\nimpl ContractInstance {\\n    fn to_address(self) -> AztecAddress {\\n        AztecAddress::compute(\\n            self.public_keys_hash,\\n            PartialAddress::compute(\\n                self.contract_class_id,\\n                self.salt,\\n                self.initialization_hash,\\n                self.deployer\\n            )\\n        )\\n    }\\n}\\n"},"248":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_class_id.nr","source":"use crate::constants::GENERATOR_INDEX__CONTRACT_LEAF;\\nuse crate::traits::{ToField, FromField, Hash, Serialize, Deserialize};\\n\\nstruct ContractClassId {\\n  inner: Field\\n}\\n\\nimpl Eq for ContractClassId {\\n    fn eq(self, other: ContractClassId) -> bool {\\n        other.inner == self.inner\\n    }\\n}\\n\\nimpl ToField for ContractClassId {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl FromField for ContractClassId {\\n    fn from_field(value: Field) -> Self {\\n        Self { inner: value }\\n    }\\n}\\n\\nimpl Serialize<1> for ContractClassId {\\n    fn serialize(self: Self) -> [Field; 1] {\\n        [self.inner]\\n    }\\n}\\n\\nimpl Deserialize<1> for ContractClassId {\\n  fn deserialize(fields: [Field; 1]) -> Self {\\n        Self { inner: fields[0] }\\n    }\\n}\\n\\nimpl ContractClassId {\\n    pub fn compute(\\n        artifact_hash: Field,\\n        private_functions_root: Field,\\n        public_bytecode_commitment: Field\\n    ) -> Self {\\n        let hash = std::hash::pedersen_hash_with_separator(\\n            [\\n            artifact_hash,\\n            private_functions_root,\\n            public_bytecode_commitment\\n        ],\\n            GENERATOR_INDEX__CONTRACT_LEAF\\n        ); // TODO(@spalladino): Update generator index\\n\\n        ContractClassId::from_field(hash)\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n"},"249":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr","source":"use crate::{\\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\\n    utils::arr_copy_slice\\n};\\n\\nstruct StateReference {\\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\\n    partial: PartialStateReference,\\n}\\n\\nimpl Eq for StateReference {\\n    fn eq(self, other: StateReference) -> bool {\\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\\n        self.partial.eq(other.partial)\\n    }\\n}\\n\\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\\n\\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\\n        fields.extend_from_array(self.partial.serialize());\\n\\n        fields.storage\\n    }\\n}\\n\\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\\n        let mut offset = 0;\\n\\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\\n\\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\\n\\n        StateReference {\\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\\n            partial: PartialStateReference::deserialize(partial_fields),\\n        }\\n    }\\n}\\n\\nimpl Empty for StateReference {\\n    fn empty() -> Self {\\n        Self {\\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\\n            partial: PartialStateReference::empty(),\\n        }\\n    }\\n}\\n\\n#[test]\\nfn serialization_of_empty() {\\n    let state = StateReference::empty();\\n    let _serialized = state.serialize();\\n    let _deserialized = StateReference::deserialize(_serialized);\\n}\\n"},"263":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\\n    data: [Field; N],\\n    offset: u32,\\n}\\n\\nimpl<N> Reader<N> {\\n    pub fn new(data: [Field; N]) -> Self {\\n        Self { data, offset: 0 }\\n    }\\n\\n    pub fn read(&mut self) -> Field {\\n        let result = self.data[self.offset];\\n        self.offset += 1;\\n        result\\n    }\\n\\n    pub fn read_u32(&mut self) -> u32 {\\n        self.read() as u32\\n    }\\n\\n    pub fn read_bool(&mut self) -> bool {\\n        self.read() as bool\\n    }\\n\\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\\n        for i in 0..K {\\n            result[i] = self.data[self.offset + i];\\n        }\\n        self.offset += K;\\n        result\\n    }\\n\\n    // TODO(#4394)\\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\\n        let result = deserialise(self.read_array([0; K]));\\n        result\\n    }\\n\\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\\n        for i in 0..C {\\n            result[i] = self.read_struct(deserialise);\\n        }\\n        result\\n    }\\n\\n    pub fn finish(self) {\\n        assert(self.offset == self.data.len(), \\"Reader did not read all data\\");\\n    }\\n}\\n"},"273":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\\n    assert(bytes.len() < 32, \\"field_from_bytes: N must be less than 32\\");\\n    let mut as_field = 0;\\n    let mut offset = 1;\\n    for i in 0..N {\\n        let mut index = i;\\n        if big_endian {\\n            index = N - i - 1;\\n        }\\n        as_field += (bytes[index] as Field) * offset;\\n        offset *= 256;\\n    }\\n\\n    as_field\\n}\\n\\n// Convert a 32 byte array to a field element by truncating the final byte\\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\\n    // Convert it to a field element\\n    let mut v = 1;\\n    let mut high = 0 as Field;\\n    let mut low = 0 as Field;\\n\\n    for i in 0..15 {\\n        // covers bytes 16..30 (31 is truncated and ignored)\\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\\n        v = v * 256;\\n        // covers bytes 0..14\\n        high = high + (bytes32[14 - i] as Field) * v;\\n    }\\n    // covers byte 15\\n    low = low + (bytes32[15] as Field) * v;\\n\\n    low + high * v\\n}\\n\\n// TODO to radix returns u8, so we cannot use bigger radixes. It\'d be ideal to use a radix of the maximum range-constrained integer noir supports\\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\\n    lhs.lt(rhs)\\n}\\n\\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\\n    rhs.lt(lhs)\\n}\\n\\n#[test]\\nunconstrained fn bytes_field_test() {\\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\\n    let inputs = [\\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\\n    ];\\n    let field = field_from_bytes(inputs, true);\\n    let return_bytes = field.to_be_bytes(31);\\n    for i in 0..31 {\\n        assert_eq(inputs[i], return_bytes[i]);\\n    }\\n    // 32 bytes - we remove the final byte, and check it matches the field\\n    let inputs2 = [\\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\\n    ];\\n    let field2 = field_from_bytes_32_trunc(inputs2);\\n    let return_bytes2 = field.to_be_bytes(31);\\n\\n    for i in 0..31 {\\n        assert_eq(return_bytes2[i], return_bytes[i]);\\n    }\\n    assert_eq(field2, field);\\n}\\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\\n// because there is no criteria for what we should not put in here.\\n// Reducing the size of this package would be welcome.\\n\\nmod arrays;\\nmod field;\\nmod reader;\\nmod uint256;\\n\\n// if predicate == true then return lhs, else return rhs\\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\\n    if predicate { lhs } else { rhs }\\n}\\n\\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\\n    let iterator_len = if N > M { M } else { N };\\n    for i in 0..iterator_len {\\n        dst[i] = src[i + offset];\\n    }\\n    dst\\n}\\n"},"289":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\\n};\\n\\nstruct EthAddress{\\n    inner : Field\\n}\\n\\nimpl Eq for EthAddress {\\n    fn eq(self, other : Self) -> bool {\\n        self.to_field() == other.to_field()\\n    }\\n}\\n\\nimpl Empty for EthAddress {\\n    fn empty() -> Self {\\n        Self {\\n            inner : 0\\n        }\\n    }\\n}\\n\\nimpl ToField for EthAddress {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\\n        [self.inner]\\n    }\\n}\\n\\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\\n        EthAddress::from_field(fields[0])\\n    }\\n}\\n\\nimpl EthAddress {\\n    pub fn zero() -> Self {\\n        Self { inner: 0 }\\n    }\\n\\n    pub fn from_field(field: Field) -> Self {\\n        field.assert_max_bit_size(160);\\n        Self { inner: field }\\n    }\\n\\n    pub fn is_zero(self) -> bool {\\n        self.inner == 0\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n\\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\\n        Self { inner: result }\\n    }\\n}\\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\\n};\\n\\n// Aztec address\\nstruct AztecAddress {\\n    inner : Field\\n}\\n\\nimpl Eq for AztecAddress {\\n    fn eq(self, other : Self) -> bool {\\n        self.to_field() == other.to_field()\\n    }\\n}\\n\\nimpl Empty for AztecAddress {\\n    fn empty() -> Self {\\n        Self {\\n            inner : 0\\n        }\\n    }\\n}\\n\\nimpl ToField for AztecAddress {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl FromField for AztecAddress {\\n    fn from_field(value: Field) -> AztecAddress {\\n        AztecAddress { inner: value }\\n    }\\n}\\n\\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\\n        [self.to_field()]\\n    }\\n}\\n\\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\\n        FromField::from_field(fields[0])\\n    }\\n}\\n\\nimpl AztecAddress {\\n    pub fn zero() -> Self {\\n        Self { inner: 0 }\\n    }\\n\\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\\n        AztecAddress::from_field(\\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\\n        )\\n    }\\n\\n    pub fn is_zero(self) -> bool {\\n        self.inner == 0\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n\\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\\n        Self { inner: result }\\n    }\\n}\\n\\n#[test]\\nfn compute_address_from_partial_and_pub_keys_hash() {\\n    let pub_keys_hash = PublicKeysHash::from_field(1);\\n    let partial_address = PartialAddress::from_field(2);\\n\\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\\n}\\n\\n#[test]\\nfn from_field_to_field() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(FromField::from_field(address.to_field()), address);\\n}\\n\\n#[test]\\nfn serde() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\\n}\\n"},"292":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\\n    address::{\\n    eth_address::EthAddress, salted_initialization_hash::SaltedInitializationHash,\\n    aztec_address::AztecAddress\\n},\\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\\n    hash::pedersen_hash, traits::{ToField, FromField, Serialize, Deserialize}\\n};\\n\\nglobal PARTIAL_ADDRESS_LENGTH = 1;\\n\\n// Partial address\\nstruct PartialAddress {\\n    inner : Field\\n}\\n\\nimpl ToField for PartialAddress {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\\n        [self.to_field()]\\n    }\\n}\\n\\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\\n       PartialAddress { inner: fields[0] }\\n    }\\n}\\n\\nimpl PartialAddress {\\n    pub fn from_field(field: Field) -> Self {\\n        Self { inner: field }\\n    }\\n\\n    pub fn compute(\\n        contract_class_id: ContractClassId,\\n        salt: Field,\\n        initialization_hash: Field,\\n        deployer: AztecAddress\\n    ) -> Self {\\n        PartialAddress::compute_from_salted_initialization_hash(\\n            contract_class_id,\\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\\n        )\\n    }\\n\\n    pub fn compute_from_salted_initialization_hash(\\n        contract_class_id: ContractClassId,\\n        salted_initialization_hash: SaltedInitializationHash\\n    ) -> Self {\\n        PartialAddress::from_field(\\n            pedersen_hash(\\n                [\\n            contract_class_id.to_field(),\\n            salted_initialization_hash.to_field()\\n        ],\\n                GENERATOR_INDEX__PARTIAL_ADDRESS\\n            )\\n        )\\n    }\\n\\n    pub fn to_field(self) -> Field {\\n        self.inner\\n    }\\n\\n    pub fn is_zero(self) -> bool {\\n        self.to_field() == 0\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n"},"293":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\\n    address::{eth_address::EthAddress, aztec_address::AztecAddress},\\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, traits::ToField\\n};\\n\\n// Salted initialization hash. Used in the computation of a partial address.\\nstruct SaltedInitializationHash {\\n    inner: Field\\n}\\n\\nimpl ToField for SaltedInitializationHash {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl SaltedInitializationHash {\\n    pub fn from_field(field: Field) -> Self {\\n        Self { inner: field }\\n    }\\n\\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\\n        SaltedInitializationHash::from_field(\\n            pedersen_hash(\\n                [\\n            salt,\\n            initialization_hash,\\n            deployer.to_field()\\n        ],\\n                GENERATOR_INDEX__PARTIAL_ADDRESS\\n            )\\n        )\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n"},"294":{"path":"/usr/src/noir-projects/noir-contracts/contracts/gas_token_contract/src/main.nr","source":"mod lib;\\n\\ncontract GasToken {\\n    use dep::aztec::{\\n        protocol_types::{\\n        contract_class_id::ContractClassId, abis::function_selector::FunctionSelector,\\n        address::{AztecAddress, EthAddress},\\n        constants::{DEPLOYER_CONTRACT_ADDRESS, REGISTERER_CONTRACT_ADDRESS}\\n    },\\n        state_vars::{SharedImmutable, PublicMutable, Map},\\n        oracle::get_contract_instance::get_contract_instance, deploy::deploy_contract\\n    };\\n\\n    use dep::deployer::ContractInstanceDeployer;\\n    use dep::registerer::ContractClassRegisterer;\\n\\n    use crate::lib::{calculate_fee, get_bridge_gas_msg_hash};\\n\\n    #[aztec(storage)]\\n    struct Storage {\\n        // This map is accessed directly by protocol circuits to check balances for fee payment.\\n        // Do not change this storage layout unless you also update the base rollup circuits.\\n        balances: Map<AztecAddress, PublicMutable<U128>>,\\n        portal_address: SharedImmutable<EthAddress>,\\n    }\\n\\n    // Not flagged as initializer to reduce cost of checking init nullifier in all functions.\\n    // This function should be called as entrypoint to initialize the contract by minting itself funds.\\n    #[aztec(private)]\\n    fn deploy(\\n        artifact_hash: Field,\\n        private_functions_root: Field,\\n        public_bytecode_commitment: Field,\\n        portal_address: EthAddress\\n    ) {\\n        // Validate contract class parameters are correct\\n        let self = context.this_address();\\n        let instance = get_contract_instance(self);\\n        let contract_class_id = ContractClassId::compute(\\n            artifact_hash,\\n            private_functions_root,\\n            public_bytecode_commitment\\n        );\\n        assert(\\n            instance.contract_class_id == contract_class_id, \\"Invalid contract class id computed for gas token\\"\\n        );\\n\\n        // Increase self balance and set as fee payer, and end setup\\n        let deploy_fees = 20000000000;\\n        GasToken::at(self)._increase_public_balance(self, deploy_fees).enqueue(&mut context);\\n        context.set_as_fee_payer();\\n        context.end_setup();\\n\\n        // Register class and publicly deploy contract\\n        let _register = ContractClassRegisterer::at(AztecAddress::from_field(REGISTERER_CONTRACT_ADDRESS)).register(\\n            artifact_hash,\\n            private_functions_root,\\n            public_bytecode_commitment\\n        ).call(&mut context);\\n        let _deploy = ContractInstanceDeployer::at(AztecAddress::from_field(DEPLOYER_CONTRACT_ADDRESS)).deploy(\\n            instance.salt,\\n            instance.contract_class_id,\\n            instance.initialization_hash,\\n            instance.public_keys_hash,\\n            true\\n        ).call(&mut context);\\n\\n        // Enqueue call to set the portal address\\n        GasToken::at(self).set_portal(portal_address).enqueue(&mut context);\\n    }\\n\\n    // We purposefully not set this function as an initializer so we do not bind\\n    // the contract to a specific L1 portal address, since the gas token address\\n    // is a hardcoded constant in the rollup circuits.\\n    #[aztec(public)]\\n    fn set_portal(portal_address: EthAddress) {\\n        assert(storage.portal_address.read_public().is_zero());\\n        storage.portal_address.initialize(portal_address);\\n    }\\n\\n    #[aztec(private)]\\n    fn claim(to: AztecAddress, amount: Field, secret: Field) {\\n        let content_hash = get_bridge_gas_msg_hash(to, amount);\\n        let portal_address = storage.portal_address.read_private();\\n        assert(!portal_address.is_zero());\\n\\n        // Consume message and emit nullifier\\n        context.consume_l1_to_l2_message(content_hash, secret, portal_address);\\n\\n        // TODO(palla/gas) Emit an unencrypted log to announce which L1 to L2 message has been claimed\\n        // Otherwise, we cannot trace L1 deposits to their corresponding claims on L2\\n\\n        GasToken::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\\n    }\\n\\n    #[aztec(public)]\\n    #[aztec(internal)]\\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\\n        let new_balance = storage.balances.at(to).read().add(U128::from_integer(amount));\\n        storage.balances.at(to).write(new_balance);\\n    }\\n\\n    // TODO(palla/gas) Remove this function and use the private claim flow only\\n    #[aztec(public)]\\n    fn claim_public(to: AztecAddress, amount: Field, secret: Field, leaf_index: Field) {\\n        let content_hash = get_bridge_gas_msg_hash(to, amount);\\n        let portal_address = storage.portal_address.read_public();\\n        assert(!portal_address.is_zero());\\n\\n        // Consume message and emit nullifier\\n        context.consume_l1_to_l2_message(content_hash, secret, portal_address, leaf_index);\\n\\n        let new_balance = storage.balances.at(to).read() + U128::from_integer(amount);\\n        storage.balances.at(to).write(new_balance);\\n    }\\n\\n    // TODO(@just-mitch): remove this function before mainnet deployment\\n    // convenience function for testing\\n    // the true canonical gas token contract will not have this function\\n    #[aztec(public)]\\n    fn mint_public(to: AztecAddress, amount: Field) {\\n        let amount = U128::from_integer(amount);\\n        let new_balance = storage.balances.at(to).read().add(amount);\\n\\n        storage.balances.at(to).write(new_balance);\\n    }\\n\\n    #[aztec(public)]\\n    #[aztec(view)]\\n    fn check_balance(fee_limit: Field) {\\n        let fee_limit = U128::from_integer(fee_limit);\\n        assert(storage.balances.at(context.msg_sender()).read() >= fee_limit, \\"Balance too low\\");\\n    }\\n\\n    // utility function for testing\\n    #[aztec(public)]\\n    #[aztec(view)]\\n    fn balance_of_public(owner: AztecAddress) -> pub Field {\\n        storage.balances.at(owner).read().to_field()\\n    }\\n}\\n"},"295":{"path":"/usr/src/noir-projects/noir-contracts/contracts/gas_token_contract/src/lib.nr","source":"use dep::aztec::prelude::{AztecAddress, EthAddress};\\nuse dep::aztec::context::PublicContext;\\nuse dep::aztec::protocol_types::hash::sha256_to_field;\\n\\npub fn calculate_fee<TPublicContext>(context: PublicContext) -> Field {\\n    context.transaction_fee()\\n}\\n\\npub fn get_bridge_gas_msg_hash(owner: AztecAddress, amount: Field) -> Field {\\n    let mut hash_bytes = [0; 68];\\n    let recipient_bytes = owner.to_field().to_be_bytes(32);\\n    let amount_bytes = amount.to_be_bytes(32);\\n\\n    for i in 0..32 {\\n        hash_bytes[i + 4] = recipient_bytes[i];\\n        hash_bytes[i + 36] = amount_bytes[i];\\n    }\\n\\n    // Function selector: 0x3e87b9be keccak256(\'mint_public(bytes32,uint256)\')\\n    hash_bytes[0] = 0x3e;\\n    hash_bytes[1] = 0x87;\\n    hash_bytes[2] = 0xb9;\\n    hash_bytes[3] = 0xbe;\\n\\n    let content_hash = sha256_to_field(hash_bytes);\\n    content_hash\\n}\\n"},"296":{"path":"/usr/src/noir-projects/noir-contracts/contracts/contract_instance_deployer_contract/src/main.nr","source":"contract ContractInstanceDeployer {\\n    use dep::aztec::protocol_types::{\\n        address::{AztecAddress, EthAddress, PublicKeysHash, PartialAddress},\\n        contract_class_id::ContractClassId, constants::DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE,\\n        traits::Serialize, abis::log_hash::LogHash\\n    };\\n    use dep::aztec::{\\n        context::PrivateContext, hash::compute_unencrypted_log_hash,\\n        oracle::logs::emit_unencrypted_log_private_internal\\n    };\\n\\n    #[aztec(event)]\\n    struct ContractInstanceDeployed {\\n        DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE: Field,\\n        address: AztecAddress,\\n        version: u8,\\n        salt: Field, \\n        contract_class_id: ContractClassId, \\n        initialization_hash: Field, \\n        public_keys_hash: PublicKeysHash, \\n        deployer: AztecAddress,\\n    }\\n\\n    #[aztec(private)]\\n    fn deploy(\\n        salt: Field,\\n        contract_class_id: ContractClassId,\\n        initialization_hash: Field,\\n        public_keys_hash: PublicKeysHash,\\n        universal_deploy: bool\\n    ) {\\n        // TODO(@spalladino): assert nullifier_exists silo(contract_class_id, ContractClassRegisterer)\\n\\n        let deployer = if universal_deploy {\\n            AztecAddress::zero()\\n        } else {\\n            context.msg_sender()\\n        };\\n\\n        let partial_address = PartialAddress::compute(contract_class_id, salt, initialization_hash, deployer);\\n\\n        let address = AztecAddress::compute(public_keys_hash, partial_address);\\n\\n        // Emit the address as a nullifier to be able to prove that this instance has been (not) deployed\\n        context.push_nullifier(address.to_field(), 0);\\n\\n        // Broadcast the event\\n        let event = ContractInstanceDeployed {\\n            DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE,\\n            contract_class_id,\\n            address,\\n            public_keys_hash,\\n            initialization_hash,\\n            salt,\\n            deployer,\\n            version: 1\\n        };\\n\\n        let payload = event.serialize();\\n        dep::aztec::oracle::debug_log::debug_log_format(\\"ContractInstanceDeployed: {}\\", payload);\\n\\n        let contract_address = context.this_address();\\n        let counter = context.next_counter();\\n\\n        // @todo This is very inefficient, we are doing a lot of back and forth conversions.\\n        let log_slice = payload.to_be_bytes_arr();\\n        let log_hash = compute_unencrypted_log_hash(contract_address, payload);\\n        // 40 = addr (32) + raw log len (4) + processed log len (4)\\n        let len = 40 + log_slice.len().to_field();\\n        let side_effect = LogHash { value: log_hash, counter, length: len };\\n        context.unencrypted_logs_hashes.push(side_effect);\\n\\n        let _void = emit_unencrypted_log_private_internal(contract_address, payload, counter);\\n    }\\n}\\n"},"301":{"path":"/usr/src/noir-projects/noir-contracts/contracts/contract_class_registerer_contract/src/main.nr","source":"mod events;\\nmod capsule;\\n\\ncontract ContractClassRegisterer {\\n    use dep::aztec::prelude::{AztecAddress, EthAddress, FunctionSelector};\\n    use dep::aztec::protocol_types::{\\n        contract_class_id::ContractClassId,\\n        constants::{\\n        ARTIFACT_FUNCTION_TREE_MAX_HEIGHT, FUNCTION_TREE_HEIGHT,\\n        MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS,\\n        MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS,\\n        MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS, REGISTERER_CONTRACT_CLASS_REGISTERED_MAGIC_VALUE\\n    },\\n        traits::Serialize, abis::log_hash::LogHash\\n    };\\n\\n    use dep::aztec::{context::PrivateContext, oracle::logs::emit_contract_class_unencrypted_log_private_internal};\\n\\n    use crate::events::{\\n        class_registered::ContractClassRegistered,\\n        private_function_broadcasted::{ClassPrivateFunctionBroadcasted, PrivateFunction, InnerPrivateFunction},\\n        unconstrained_function_broadcasted::{ClassUnconstrainedFunctionBroadcasted, UnconstrainedFunction, InnerUnconstrainedFunction}\\n    };\\n\\n    // docs:start:import_pop_capsule\\n    use crate::capsule::pop_capsule;\\n    // docs:end:import_pop_capsule\\n\\n    #[aztec(private)]\\n    fn register(artifact_hash: Field, private_functions_root: Field, public_bytecode_commitment: Field) {\\n        // TODO: Validate public_bytecode_commitment is the correct commitment of packed_public_bytecode\\n        // TODO: Validate packed_public_bytecode is legit public bytecode\\n\\n        // docs:start:pop_capsule\\n        let packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS] = pop_capsule();\\n        // docs:end:pop_capsule\\n\\n        // Compute contract class id from preimage\\n        let contract_class_id = ContractClassId::compute(\\n            artifact_hash,\\n            private_functions_root,\\n            public_bytecode_commitment\\n        );\\n\\n        // Emit the contract class id as a nullifier to be able to prove that this class has been (not) registered\\n        let event = ContractClassRegistered { contract_class_id, version: 1, artifact_hash, private_functions_root, packed_public_bytecode };\\n        context.push_nullifier(contract_class_id.to_field(), 0);\\n\\n        // Broadcast class info including public bytecode\\n        dep::aztec::oracle::debug_log::debug_log_format(\\n            \\"ContractClassRegistered: {}\\",\\n            [\\n            contract_class_id.to_field(),\\n            artifact_hash,\\n            private_functions_root,\\n            public_bytecode_commitment\\n        ]\\n        );\\n        emit_contract_class_unencrypted_log(&mut context, event.serialize());\\n    }\\n\\n    #[aztec(private)]\\n    fn broadcast_private_function(\\n        contract_class_id: ContractClassId,\\n        artifact_metadata_hash: Field,\\n        unconstrained_functions_artifact_tree_root: Field,\\n        private_function_tree_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\\n        private_function_tree_leaf_index: Field,\\n        artifact_function_tree_sibling_path: [Field; ARTIFACT_FUNCTION_TREE_MAX_HEIGHT],\\n        artifact_function_tree_leaf_index: Field,\\n        function_data: InnerPrivateFunction\\n    ) {\\n        let private_bytecode: [Field; MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS] = pop_capsule();\\n\\n        let event = ClassPrivateFunctionBroadcasted {\\n            contract_class_id,\\n            artifact_metadata_hash,\\n            unconstrained_functions_artifact_tree_root,\\n            private_function_tree_sibling_path,\\n            private_function_tree_leaf_index,\\n            artifact_function_tree_sibling_path,\\n            artifact_function_tree_leaf_index,\\n            function: PrivateFunction {\\n                selector: function_data.selector,\\n                metadata_hash: function_data.metadata_hash,\\n                vk_hash: function_data.vk_hash,\\n                bytecode: private_bytecode\\n            }\\n        };\\n        dep::aztec::oracle::debug_log::debug_log_format(\\n            \\"ClassPrivateFunctionBroadcasted: {}\\",\\n            [\\n            contract_class_id.to_field(),\\n            artifact_metadata_hash,\\n            unconstrained_functions_artifact_tree_root,\\n            function_data.selector.to_field(),\\n            function_data.vk_hash,\\n            function_data.metadata_hash\\n        ]\\n        );\\n        emit_contract_class_unencrypted_log(&mut context, event.serialize());\\n    }\\n\\n    #[aztec(private)]\\n    fn broadcast_unconstrained_function(\\n        contract_class_id: ContractClassId,\\n        artifact_metadata_hash: Field,\\n        private_functions_artifact_tree_root: Field,\\n        artifact_function_tree_sibling_path: [Field; ARTIFACT_FUNCTION_TREE_MAX_HEIGHT],\\n        artifact_function_tree_leaf_index: Field,\\n        function_data: InnerUnconstrainedFunction\\n    ) {\\n        let unconstrained_bytecode: [Field; MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS] = pop_capsule();\\n        let event = ClassUnconstrainedFunctionBroadcasted {\\n            contract_class_id,\\n            artifact_metadata_hash,\\n            private_functions_artifact_tree_root,\\n            artifact_function_tree_sibling_path,\\n            artifact_function_tree_leaf_index,\\n            function: UnconstrainedFunction {\\n                selector: function_data.selector,\\n                metadata_hash: function_data.metadata_hash,\\n                bytecode: unconstrained_bytecode\\n            }\\n        };\\n        dep::aztec::oracle::debug_log::debug_log_format(\\n            \\"ClassUnconstrainedFunctionBroadcasted: {}\\",\\n            [\\n            contract_class_id.to_field(),\\n            artifact_metadata_hash,\\n            private_functions_artifact_tree_root,\\n            function_data.selector.to_field(),\\n            function_data.metadata_hash\\n        ]\\n        );\\n        emit_contract_class_unencrypted_log(&mut context, event.serialize());\\n    }\\n\\n    // This fn exists separately from emit_unencrypted_log because sha hashing the preimage\\n    // is too large to compile (16,200 fields, 518,400 bytes) => the oracle hashes it\\n    // It is ONLY used with contract_class_registerer_contract since we already assert correctness:\\n    // - Contract class -> we will commit to the packed bytecode (currently a TODO)\\n    // - Private function -> we provide a membership proof\\n    // - Unconstrained function -> we provide a membership proof\\n    // Ordinary logs are not protected by the above so this fn shouldn\'t be called by anything else\\n    #[contract_library_method]\\n    pub fn emit_contract_class_unencrypted_log<N>(context: &mut PrivateContext, log: [Field; N]) {\\n        let contract_address = context.this_address();\\n        let counter = context.next_counter();\\n        let log_hash = emit_contract_class_unencrypted_log_private_internal(contract_address, log, counter);\\n        // 40 = addr (32) + raw log len (4) + processed log len (4)\\n        let len = 40 + N * 32;\\n        let side_effect = LogHash { value: log_hash, counter, length: len };\\n        context.unencrypted_logs_hashes.push(side_effect);\\n    }\\n}\\n"}}}'));const Ip=Nr.fromBigInt(3159976153131520272419617514531889581796079438158800470341967144801191524489n);class Xp{constructor(e){this.sender=e}getAsset(){return Ip}getFunctionCalls(){return Promise.resolve([])}getFeePayer(){return Promise.resolve(this.sender)}}class Up{constructor(e,t,n,s=X.random()){this.asset=e,this.paymentContract=t,this.wallet=n,this.rebateSecret=s}getAsset(){return this.asset}getFeePayer(){return Promise.resolve(this.paymentContract)}async getFunctionCalls(e){const t=X.random(),n=e.getFeeLimit();await this.wallet.createAuthWit({caller:this.paymentContract,action:{name:"unshield",args:[this.wallet.getCompleteAddress().address,this.paymentContract,n,t],selector:Ur.fromSignature("unshield((Field),(Field),Field,Field)"),type:xr.PRIVATE,isStatic:!1,to:this.asset,returnTypes:[]}});const s=await Vi(this.rebateSecret);return[{name:"fee_entrypoint_private",to:this.paymentContract,selector:Ur.fromSignature("fee_entrypoint_private(Field,(Field),Field,Field)"),type:xr.PRIVATE,isStatic:!1,args:[n,this.asset,s,t],returnTypes:[]}]}}class Jp{constructor(e,t,n){this.asset=e,this.paymentContract=t,this.wallet=n}getAsset(){return this.asset}getFeePayer(){return Promise.resolve(this.paymentContract)}async getFunctionCalls(e){const t=X.random(),n=e.getFeeLimit();return Promise.resolve([(await this.wallet.setPublicAuthWit({caller:this.paymentContract,action:{name:"transfer_public",args:[this.wallet.getAddress(),this.paymentContract,n,t],selector:Ur.fromSignature("transfer_public((Field),(Field),Field,Field)"),type:xr.PUBLIC,isStatic:!1,to:this.asset,returnTypes:[]}},!0)).request(),{name:"fee_entrypoint_public",to:this.paymentContract,selector:Ur.fromSignature("fee_entrypoint_public(Field,(Field),Field)"),type:xr.PRIVATE,isStatic:!1,args:[n,this.asset,t],returnTypes:[]}])}}class Dp extends Xp{constructor(e,t,n){super(e),this.claimAmount=t,this.claimSecret=n}getFunctionCalls(){return Promise.resolve([{to:Ip,name:"claim",selector:Ur.fromSignature("claim((Field),Field,Field)"),isStatic:!1,args:[this.sender,new X(this.claimAmount),this.claimSecret],returnTypes:[],type:xr.PRIVATE}])}}class qp{constructor(){}getAsset(){return Nr.ZERO}getFunctionCalls(){return Promise.resolve([])}getFeePayer(){return Promise.resolve(Nr.ZERO)}}async function Kp(){await async function(){await ue.initSingleton()}()}var Wp=a.j,Zp=a.FY,Vp=a.sL,Qp=a.e$,$p=a.wC,e_=a.D2,t_=a.nB,n_=a.eb,s_=a.fH,r_=a.QM,a_=a.NZ,i_=a.eH,o_=a.F9,l_=a.b$,c_=a.pF,d_=a.qu,u_=a.f2,f_=a.Qs,h_=a.bX,p_=a.lT,__=a.V7,m_=a.st,g_=a.be,b_=a.Iy,y_=a.Bx,v_=a.gn,w_=a.Fq,A_=a.Fr,E_=a.R6,x_=a.Y5,S_=a.Hq,T_=a.K,k_=a.KA,C_=a.H2,z_=a.Rx,P_=a.CU,F_=a.kb,N_=a.W2,G_=a.W4,L_=a.on,O_=a.XL,R_=a.GQ,M_=a.Yj,B_=a.w2,Y_=a.Ze,j_=a.Tu,H_=a.nv,I_=a.L7,X_=a.QZ,U_=a.tZ,J_=a.bR,D_=a.nq,q_=a.Fx,K_=a.mR,W_=a.n_,Z_=a.gO,V_=a.RV,Q_=a.JK,$_=a.Tx,em=a.Us,tm=a.jD,nm=a.xr,sm=a.tb,rm=a.MD,am=a.ir,im=a.aK,om=a.FP,lm=a.uI,cm=a.y5,dm=a.qN,um=a.dP,fm=a.yV,hm=a.V4,pm=a.mW,_m=a.dB,mm=a.v_,gm=a.Oe,bm=a.Cd,ym=a.GB,vm=a.p2,wm=a.vk,Am=a.hu,Em=a.m9,xm=a.cg,Sm=a.fz,Tm=a.vK,km=a.DU,Cm=a.bx,zm=a.hU,Pm=a.$q,Fm=a.aP,Nm=a.L5,Gm=a.v6,Lm=a.sc,Om=a.yy,Rm=a.Zx,Mm=a.Dg,Bm=a.cI,Ym=a.VJ,jm=a.id;export{Wp as AccountManager,Zp as AccountWallet,Vp as AccountWalletWithSecretKey,Qp as AuthWitness,$p as AztecAddress,e_ as BatchCall,t_ as Body,n_ as CheatCodes,s_ as Comparator,r_ as CompleteAddress,a_ as Contract,i_ as ContractBase,o_ as ContractDeployer,l_ as ContractFunctionInteraction,c_ as DeployMethod,d_ as DeploySentTx,u_ as EncryptedL2BlockL2Logs,f_ as EncryptedLogHeader,h_ as EncryptedLogOutgoingBody,p_ as EncryptedNoteL2BlockL2Logs,__ as EncryptedNoteLogIncomingBody,m_ as EthAddress,g_ as EthCheatCodes,b_ as EventSelector,y_ as EventType,v_ as ExtendedNote,w_ as Fq,A_ as Fr,E_ as FunctionCall,x_ as FunctionSelector,S_ as GlobalVariables,T_ as Grumpkin,k_ as GrumpkinScalar,C_ as INITIAL_L2_BLOCK_NUM,z_ as L1Actor,P_ as L1EventPayload,F_ as L1NotePayload,N_ as L1ToL2Message,G_ as L2Actor,L_ as L2Block,O_ as L2BlockL2Logs,R_ as LogId,M_ as LogType,B_ as MerkleTreeId,Y_ as NativeFeePaymentMethod,j_ as NativeFeePaymentMethodWithClaim,H_ as NoFeePaymentMethod,I_ as Note,X_ as NoteSelector,U_ as PackedValues,J_ as Point,D_ as PrivateFeePaymentMethod,q_ as PublicFeePaymentMethod,K_ as Schnorr,W_ as SentTx,Z_ as SiblingPath,V_ as SignerlessWallet,Q_ as TaggedLog,$_ as Tx,em as TxExecutionRequest,tm as TxHash,nm as TxReceipt,sm as TxStatus,rm as UnencryptedL2BlockL2Logs,am as UnencryptedL2Log,im as computeAppNullifierSecretKey,om as computeAuthWitMessageHash,lm as computeInnerAuthWitHash,cm as computeInnerAuthWitHashFromAction,dm as computeSecretHash,um as contractArtifactFromBuffer,fm as contractArtifactToBuffer,hm as createAztecNodeClient,pm as createDebugLogger,_m as createPXEClient,mm as deployL1Contract,gm as deployL1Contracts,bm as deriveKeys,ym as deriveMasterIncomingViewingSecretKey,vm as deriveMasterNullifierSecretKey,wm as elapsed,Am as encodeArguments,Em as fileURLToPath,xm as generatePublicKey,Sm as getContractClassFromArtifact,Tm as getContractInstanceFromDeployParams,km as initAztecJs,Cm as loadContractArtifact,zm as makeFetch,Pm as merkleTreeIds,Fm as onLog,Nm as retry,Gm as retryUntil,Lm as sha256,Om as sleep,Rm as to2Fields,Mm as toBigInt,Bm as toBigIntBE,Ym as waitForAccountSynch,jm as waitForPXE};