{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"KeyRegistry","functions":[{"name":"rotate_npk_m","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"new_npk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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/aWaIS4n57+d/XLyW+MjU/l5aCxfqaz7uXe3574ui+NzD47PPTo+9+T43LPjcy+Oz311fO5+e9O6NMfn7rivBsd9NTjuq8FxXw2O+2pw3FeD474aHPfV4LivBsd9NTjuq9FxX42O+2p03Fej474aHffV6LivRsd9NTruq9FxX42O+2py3FeT476aHPfV5LivJsd9NTnuq8lxX02O+2py3FeT476aHffV7LivZsd9NTvuq9lxX82O+2p23Fez476aHffV7LivFsd9tTjuq8VxXy2O+2px3FeL475aHPfV4rivFsd9tTjuq6vjvro67qur4766Ou6rq+O+ujruq6vjvro67qur4766Ou6r1XFfrY77anXcV6vjvlod99XquK9Wx321Ou6r1XFfrY77anPcV5vjvtoc99XmuK9esQ/I7Nwd99XmuK82x321Oe6rzXFf7Y77anfcV7vjvtod99UrNheZnbvjvtod91XHO4vW7rivOt63VB3vW6qO9y1Vx/uWquN9S3Xx21er431L1fG+pep431J1vG+pOt63VB3vW6qO9y1Vx/uWquN9S9XxvqXqeN9SdbxvqTret1Qd71uqjvctVcf7lqrjfUvV8b6l6njfUnW8b6k63rdUHe9bqo73LVXH+5aq431L1fG+pep431J1vG+pOt63VB3vW6qO9y1Vx/uWquN9S9XxvqXqeN9SdbxvqTret1Qd71uqjvctVcf7lqrjfUvV8b6l6njfUnW8b6k63rdUHe9bqo73LVXH+5aq431L1fG+pep431J1vG+pOt63VB3vW6qO9y1Vx/uWquN9S9XxvqXqeN9SdbxvqTret1Qd71uqjvctVcf7lqrjfUvV8b6l6njfUnW8b6k63rdUHe9bqo73LVXH+5aq431L1fG+pep431J1vG+pOt63VB3vW6qO9y1Vx/uWquN9S9XxvqXqeN9SdbxvqTret1Qd71uqjvctVcf7lqrjfUvV8b6l6njfUnW8b6k63rdUHe9bqo73LTXH+5aa431LzfG+peZ431Jb/PbV5njfUnO8b6k53rfUHO9bao73LTXH+5aa431LzfG+peZ431JzvG+pOd631BzvW2qO9y01x/uWmuN9S83xvqXmeN9Sc7xvqTnet9Qc71tqjvctNcf7lprjfUvN8b6l5njfUnO8b6k53rfUHO9bao73LTXH+5aa431LzfG+peZ431JzvG+pOd631BzvW2qO9y01x/uWmuN9S83xvqXmeN9Sc7xvqTnet9Qc71tqjvctNcf7lprjfUvN8b6l5njfUnO8b6k53rfUHO9bao73LTXH+5aa431LzfG+peZ431JzvG+pOd631BzvW2qO9y01x/uWmuN9S83xvqXmeN9Sc7xvqTnet9Qc71tqjvctNcf7lprjfUvN8b6l5njfUnO8b6k53rfUHO9bao73LTXH+5aa431LzfG+peZ431JzvG+pOd631BzvW2qO9y01x/uW2ot9S7WE/dxbPfkrPbWfB/evf+PwzEPZzj3057Ex9qPfm3vefnEp6Xl03s8+uj775Prss+uzL67PfnV99s312XfHZ99f7DDycvaeu1VfPHervnjuVn3x3K364rlb9cVzt+ovNhp5OfsLeq2RN+lL93vuYXF87sHxuUfH554cn3t2fO7F8bmvjs+9Oj53x301OO6r0XFfjY77anTcV6Pjvhod99XouK9Gx301Ou6r0XFfjY77anLcV5Pjvpoc99XkuK8mx301Oe6ryXFfTY77anLcV5Pjvpod99XsuK9mx301O+6r2XFfzY77anbcV7Pjvpod99XsuK8Wx321OO6rxXFfLY77anHcV4vjvloc99XiuK8Wx321OO6rq+O+ujruq6vjvro67qur4766Ou6rq+O+ujruq6vjvro67qvVcV+tjvtqddxXq+O+Wh331eq4r1bHfbU67qvVcV+tjvtqc9xXm+O+2hz31ea4rzbHfbU57qvNcV9tjvtqc9xXm+O+2h331e64r3bHfbU77qtXbDMyO3fHfbU77qvdcV/tjvtq99tXw7L4bayPk/fbWR8n77e1Pk7eb299nLzf5vo4eb/d9XHyftvr4+T99tfHyfttsI+T99xhHa9eepy85w7rePnS4+Q9d1jH65ceJ++5wzpewPQ4ec8d1vEKpsfJe+6wjpcwPU7ec4d1vIbpcfKeO6zjRUyPk/fcYR2vYnqcvOcO63gZ0+PkPXdYx+uYHifvucM6Xsj0OHnPHdbxSqbHyXvusI6XMj1O3nOHdbyW6XHynjus48VMj5P33GEdr2Z6nLznDut4OdPj5D13WMfrmR4n77nDOl7Q9Dh5zx3W8Yqmx8l77rCOlzQ9Tt5zh3W8pulx8p47rONFTY+T99xhHa9qepy85w7reFnT4896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nvURdp71EXae9RF2nvURdp71EXae9RF2nvURdp71EXae9RF2nvURdp71EXae9RF2nvURdp71EXae9RF2nvURdp71EXae9RF2nvURdp71EXae9RF2nvURdp71EXae9RF2nvURdp71EXae9RF2nvURdp71EXae9RF2nvURdp71EXae9RF2nvURdp71EXae9RF2nvURdp71EXae9RF2nvURdp71EXae9RF2nvURdp71EXae9RF2nvURdp71EXae9RF2nvURdp71EXae9RF2nvURdp71EXae9RF2nvURdp71EXae9RF2nvURdp71EXae9RF2nvURdp71EXae9RF2nvURdp71EXae9RF2nnUHO89S2395Xo6L0O/YbxSh37HfKEK/Y79RhH7HfqMI/Y79RhH6Hfu8CAc7z94oQr9jv1GEfsd+o4gROraDnWdvFDFCx3aw8+yNIkbo2A52nr1RhP+OXRYHO8/eKMJ/x34U4b9jP4rw37EfRfjv2I8i/HfsRxH+O/ajCP8d+1GE/479KGKEju1g59kbRYzQsR3sPHujiBE6toOdZ28UMULHdrDz7I0iRujYDnaevVHECB3bwc6zN4rw3bEf/9v/+0//81/+6b/86z//++Nnfvw//9ef/+tf/uXf/vzzf/3L//c//vr/eRz7/wM="},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2b3U7bQBCF18GhBoOb2HGckEAIBaTehRSScMfLtM/d60p9haqss6Mclmm0UcdLVool5LG9O+ebsz+EyERqfSSvP5GJ2+Z8rN4f1ObFnGf/dzwI5po1yRkFwtkKhPMoEM5YkDNiOPU5NrFed3rNfVLr9fjuIXbWA30Ez9W2RLZqYgJ8eC1V6Wr2fAzJEVwZ8Ng8o7PGSc0zBEtNkXUbuEeFtuAe6RzBPdrBSCcxpgjX+5RskOXyvs4+XcOJyUXcKcT4bAzWxQ3V2Jav8bGRMXn1rqExqVcx+d42uRO4pjE4NbHgb44H1I7Mz6k1F2KIR9CW2pEfLWDVx7narJfTLf1iq18GbY6hn7230DWNtfaqa2J9btOeAPkb8HCm86byed+MTWx5l0JNGXgioz1f6fxn6u0RWdfXEGfAcy7Os1578nWux+4zsMvkfXrUXnUsr84srzJogwydBvyLQJdy03WH0ZbzYrHS2l0HL7oMT9ezF11GW9CLZ62dO3iRMzy5Zy9yRlvOi+U3rV04eFEwPIVnLwpGW86Lef0ZoOfgRY/h6Xn2osdoC66Rel6UDl6UDE/p2YuS0Rb04ofW7jt40Wd4+p696DPagl5819qVgxcVw1N59qJitAX3zvrzxcDBiwHDM/DsxYDRFvRirrWHDl4MGZ6hZy+GjLbgGqm1Lxy8uGB4Ljx7QXq7MvcCZK4CZC72gDmxYhntRb1/jhy8GDE8I89e4HcuuzCXe8CcWLGM9uJJa48dvBgzPGPPXpDersx5gMxFgMz9AJnLAJmrAJn3YT4nViyjvaz30EsHLy4ZnkvPXpDersx5gMyjAJmLPWBOrFhGe1l/N3fl4MUVw3Pl2QvS25V5ECBzdw+YEyuW0V4utPbEwYsJwzPx7AXp7co8DJC5CpB5FCBzESBzP0DmMkDmwxr0w5zvATO+e/S7UZ75c2rxkGfKYlQWYwpxBozU9kXJva+SWbWT1lTcj/X42POFrqeNas9XOu+XBmrSeW/l89Z/I9yZXPQO3y3j1b2JI+FxuoO8EejQ/RjiX9CW2pEftB8Qu36X68bE91v6Tax+GbS5gX63Vj+6prHW3v00cVNzy2Ved9RmLX8Fngb2wUd8J1eBV8pipGMCPNfyPA8N1TnDd/j+KNm1N7W8OrG8yqAN7tEftW8emA/M/2LGzxMncA956F7LqgX/v2EKOf4CARQXTpY1AAA=","debug_symbols":"ndpBahtBFEXRvfTYBL2v7qpqbyWEINtyEBjZWHIgCO89UkIWkDNTVevN7uhQl+lp//Dx4/vh+Px6mu6/XqaX18fd+fB6vJ4u0+ZLjT+3p7fd8XZxOu/ez9P9tvW7aX98uv7q9Xk3PR9e9rfbfH67u41WGG03MoqMSkZbGc0yWmTUZNRlJEVspYhZipiliFmKmKWIWYqYpYhZipiliFmKmKWIRYpYpIhFilikiEWKWKSIRYpYpIhFilikiCZFNCmiSRFNimhSRJMimhTRpIgmRTQpoksRXYroUkSXIroU0aWILkV0KaJLEV2KGFLEkCKGFDGkiCFFDCliSBFDihhSxJAiVililSJWKWKVIlYpYpUiVililSJWKWKVIrLZ0Cq0KlptaTXTaqFVo1Wn1aAVtRFqI9RGqI1QG6E2Qm2E2gi1EWoj1EZRG0VtFLVR1EZRG0VtFLVR1AaBZkg0Q6QZMs0QaoZUM8SaIdcMwWZINkO0GbLNEG6GdDPEmyHfDAFnSDhDxBkyzhByhpQzxJwh5wxBZ0g6Q9QZss4Qdoa0M8SdIe8MgWdIPEPkGTLPEHqG1DPEniH3DMFnSD5D9BmyzxB+hvQzxJ8h/wwBaEhAQwQaMtAQgoYUNMSgIQcNQWhIQkMUGrLQEIaGNDTEoSEPDYFoSERDJBoy0RCKhlQ0xKIhFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhcte+hJLlrkokUuWuSiRS5a5KJFLlr/7aLX08/d+2H38LK/ve29ffw4Pv576ns9nn+9/f1y/e9v"},{"name":"register_npk_and_ivpk","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"partial_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::partial_address::PartialAddress"},"visibility":"private"},{"name":"keys","type":{"fields":[{"name":"npk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"ivpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"ovpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"tpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"aztec::keys::public_keys::PublicKeys"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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tydU8LYNKrM+euqECt62RQUX16JiUGlQwcW1qODiWlRwcS0qk7q49Fi1l2LcWmQmdXLnZGZ9BM8LZCZ1dC+QmbSxfIHMpH73BTIGmSdkpj21rR5kcuve4qyP+TgnM+uzElJaDjIpri0ys34Cn5OZ9RP4nMykzcMLZCZtH14gM2kD8QKZWf3MOZlZ/cwpmTJrC3FOZtYW4pwMHvgZGTzwMzI2K5njB6dUm2Sm9cCnZKb1wKdkpvXAp2Sm9cCnZGb1wLYcZCy1Or1Zn47xAplZnd45mVmd3jkZg8wTMrM6vXMyszq9czKzOr1zMrM6vXMyOL02mTLrgxheIIMHfkYGD/yMDB74GRmDzBMyeOBnZPDAz8jggZ+RwQM/I4MHfkJm1ucUvEAGD/yMDB74GRk88DMyBpknZPDAz8jggZ+RwQM/I4MHfkYGD/yEzKzPKXiBDB74GRk88DMyeOBnZAwyT8jggZ+RwQM/I4MHfkYGD/yMDB74CZlZnxTzAhk88DMyeOBnZPDAz8gYZJ6QwQM/I9P2wFvY/13czH4js//D7d1/WN79h/XNf/jkSRUv/MPw7j+M7/7D9O4/tHf/YX73H777zrF33zn27jvH3n3n5HffOfndd05+952T333n5HffOfndd05+952T333n5HffOfndd8767jtnffeds777zlnffees775z1nffOeu775z13XfO+u47Z333nbO9+87Z3n3nbO++c7Z33znbu++c7d13zvbuO2d7952zvfvO2d5955R33znl3XdOefedU95955R33znl3XdOefedU95955R33znl3XdOffedU99959R33zn13XdOffedU99959R33zn13XdOffedU99859Rlefcfhnf/YXz3H6Z3/6G9+w/zu/9wffcfbu/+w/LuP3z3nRPefeeEd9854d13Tnj3nRPefeeEd9854d13Tnj3nRPefeeEd9858d13Tnz3nRPffefEd9858d13Tnz3nRPffefEd9858d13Tnz3nZPefeekd9856d13Tnr3nZPefeekd98573bI9d0Oub7bIdd3O+T6bodc3+2Q67sdcn23Q67vdsj13Q65vtsh13c75Ppuh1zf7ZDrux1yfbdDru92yPXdDrm+2yHXdzvk+m6HXN/tkOu7HXJ9t0Ou73bI9d0Oub7bIdd3O+T6bodc3+2Q67sdcn23Q67vdsj13Q65vtsh13c75Ppuh1zf7ZDrux1yfbdDru92yPXdDrm+2yHXdzvk+m6HXN/tkOu7HXJ9t0Ou73bI9d0Oub7bIdd3O+T6bodc3+2Q67sdcn23Q67vdsj13Q65vtsh13c75Ppuh1zf7ZDrux1yfbNDjsubHfLXPwzv/sP47j9M7/5De/cf5nf/4fruP9ze/Yfl3X/47jsnvPvOCe++c8K775zw7jsnvPvOCe++c8K775zw7jsnvPvOCe++c+K775z47jsnvvvOie++c+K775z47jsnvvvOie++c+K775z47jsnvfvOSe++c9K775z07jsnvfvOSe++c9K775z07jsnvfvOSe++c+zdd469+86xd9859u47x95959i77xx7951j775z7N13jr37zsnvvnPyu++c/O47J7/7zsnvvnPyu++c/O47J7/7zsnvvnPyu++c9d13zvruO2d9952zvvvOWd9956zvvnPWd98567vvnPXdd8767jtne/eds737ztnefeds775ztnffOdu775wnHXJJYf+HZd1++4eNvy1L5deLv2q+47Xhn1/4x2tDXn69Nnz7C7cYa+vnWt2f4/51Y+7bX7jZclz+Nvbll7Evvw59+U/uLQxz+WHsy09jX76Nffl57Msf+9gqYx9bZexjq4x9bNWxj6069rH15CbvMJc/9qlbO5y64SvZ79cU4nIywH75y8lPjXk7riF/x7I+Lj6PfPHryBe/jXzxZeSLr+NefFiWkS8+jHzxceSLTyNf/MAnbFgGPmHDMvAJG5aBT9iwDHzChmXkEzaMfMKGkU/YMPIJG0Y+YcPIJ2wY+YQNI5+wYeQTNox8woaRT9g48gkbRz5h48gnbBz5hI0jn7Bx5BM2jnzCxpFP2DjyCRtHPmHTyCdsGvmETSOfsGnkEzaNfMKmkU/YNPIJm0Y+YdPIJ2wa+YS1kU9YG/mEtZFPWBv5hLWRT1gb+YS1kU9YG/mEtZFPWBv5hM0jn7B55BM2j3zC5pFP2DzyCZtHPmHzyCdsHvmEzSOfsHnkE3Yd+YRdRz5h15FP2HXkE3Yd+YRdRz5h15FP2HXkE3Yd+YRdRz5ht5FP2G3kE3Yb+YTdRj5ht5FP2G3kE3Yb+YTdRj5ht5FP2G3kE7aMfMKWkU/YMvIJW0Y+YXvsefK7+JFP2DLyCVtGPmHLyCdsGfmErSOfsHXkE7aOfMLWkU/YkXc6hZF3OoWRdzqFkXc6hZF3OoWRdzrFkXc6xZF3OsWRdzrFkXc6xWXgEzaOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY680ymOvNMpjrzTKY280ymNvNMpjbzTKY280yktA5+waeSdTmnknU5p5J1OaeSdTmnknU5p5J1OaeSdTmnknU5p5J1OaeSdTmnknU5p5J1OaeSdTmnknU5p5J1OaeSdTmnknU5p5J1OaeSdTmnknU5p5J1OaeSdTmnknU5p5J1OaeSdTmnknU5p5J1OaeSdTmnknU5p5J1OaeSdTmnknU5p5J1OaeSdTmnknU5p5J1OaeSdTmnknU5p5J1OaeSdTmnknU5p5J1OaeSdTmnknU5p5J1OaeSdTmnknU5p5J1OaeSdTmnknU5p5J1OaeSdTmnknU5p5J1OaeSdTmnknU5p5J1OaeSdTmnknU5p5J1OaeSdTmnknU5p5J1OaeSdTmnknU5p5J1OaeSdTmnknU5p5J1O6clOp7rsvyPWtJ78mprKrxfX77+keekh7z841MdrY6ytn2vV9h+cc3q82h6Xn8e+/HXsy9/Gvvwy9uXXoS//yYqkYS4/jn35aezLH/vYKmMfW2XsY6uMfWyVsY+tMvax9WRp0jCX3+HUdQsrNY588Wnki7eRLz6PfPHryBe/jXzxZeSLr+NevC3LyBc/8Alry8AnrC0Dn7C2DHzC2jLwCWvLwCes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I+90KiPvdCoj73QqI+90KiPvdCoj73QqI+90KiPvdCoj73QqI+90KiPvdCoj73QqI+90KiPvdCoj73QqI+90KiPvdCoj73QqI+90KiPvdCoj73QqI+90KiPvdCoj73QqI+90KiPvdCoj73QqI+90KiPvdCoj73QqI+90KiPvdCoj73QqI+90KiPvdCoj73QqI+90KiPvdCoj73QqI+90KiPvdKoj73SqI+90qiPvdKoj73Sqy8AnbB15p1MdeadTHXmnUx15p1MdeadTHXmnUx15p1MdeadTHXmnUx15p1MdeadTHXmnUx15p1MdeadTHXmnUx15p1MdeadTHXmnUx15p1MdeadTHXmnUx15p1MdeadTHXmnUx15p1MdeadTHXmnUx15p1MdeadTHXmnUx15p1MdeadTHXmnUx15p1MdeadTHXmnUx15p1MdeadTHXmnUx15p1MdeadTHXmnUx15p1MdeadTHXmnUx15p1MdeadTbe90SouF4+K3cvJrvqzprxfX77+keekh7xcf6uO1MdbWz7Vq+w/OOT1ebY/LT2Nfvo19+Xnsy1/Hvvxt7MuvQ19+e0nSOJcfxr78sY+tdexjax372FrHPrbWsY+tdexjq700aZzL73DquoWVbRn54sPIFx9Hvvg08sXbyBefR774deSL30a++DLyxY98wpaRT9gy8glbRj5hy8gnbBn5hC0jn7Bl5BO2jHzClpFP2DLyCVtHPmHryCdsHfmErSOfsHXkE7aOfMLWkU/YOvIJW0c+Yeu4J2xalnFP2K+LH/eE/br4cU/Yr4sf94T9uvhxT9ivix/3hP26+HFP2H++lzjyxY97wn5d/MgnbBj5hA0jn7Bh5BM2jHzChpFP2DDyCRtGPmHDyCdsGPmEDSOfsHHkEzaOfMLGkU/YOPIJG0c+YePIJ2wc+YSNI5+wceQTNo58wqaRT9g08gmbRj5h08gnbBr5hE0jn7Bp5BM2jXzCppFP2DTyCWsjn7A28glrI5+wNvIJayOfsDbyCWsjn7A28glrI5+wNvIJm0c+YfPIJ2we+YTNI5+wPVYm+V38yCdsHvmEzSOfsHnkEzaPfMKuI5+w68gn7DryCbuOfML22O7kd/Ejn7DryCfsOvIJu458wg680+nrykY+YQfe6fR1ZSOfsAPvdPq6spFP2IF3On1d2cgn7MA7nf65spEv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UzYBNk/ZRNg8ZZNg85SNweYpm6zOJtSDze/Nc6umznbU1Ou3C8n1mHedbN5tsnnlfVfneetc80Z579h5Xnk/+JN5t2W/7K//WZvzynu8zvPK+7bO89pk897KX70w76381Qvz3spfbbke865bc95b+asX5r2VvzqfN93KX70w77381fm89/JX5/Pey1+dz2u3mjdtj3nLb/P++epoab/saPnxo2M62q50LzfWm869vFtvOn/Z6e2/plzza+olv8aWa35NuObXxGt+Tbrm19g1vyZf82vWa37NNZ8Cds2ngPX4FNjC/up1S/nsEz+tx8eyLWef+KnU42sZNXX4WkZeZhs4zDZwnG3gNNvANtvAebaB19kG3mYbuEw28Dqb8VhnMx7rbMZjnc14rLMZj3U247E6GA8Lj4Htv541oH7fFF032DxlU2DzlE2FzTM22wKbp2yCOpsf3I2qMe0vrtG+37l9zBsnmzdNNq9NNm+ebF5579h5Xnk/+KN54/KYt/w275+vtnistrUUHq/+B9QfL96Ou3BbfVxzTAdHee84Bsci76UG4Xgv3+XH8V5+zo/jvXzijzim4ztslix/57jDMeA8h3MvB9oZzr3s6s/gbHbAKUsLzsTeNm3pAae24MgXeo5w6q1caCrHHRNbllYKrLdyiy/MeytX98K8t3JfqaRj3pCa89pk897KI6USj3m/P6Do27y3altemPdWh/XpvGG51eez2dHC2lab897q8/mFeW/1+Wx2PN7Bytac91afz/l4cc3W1vdWsTSHx+M71tCc91afz+fzhlvlo/x4aGHelua8t/p8zsf37eoaS3PeW30+vzDvvT6f6+MhnGltznurz+f1eAZS3Zb2f7+3agJfmPdW+Whd62Pe5n+/Xf5yfFvzMW8923lg2/GzbTt7StfXz9v/i1zLtztp9TFA7D1A/W2A/deka36NXfNrenxql1gPab4vY2mqHmPYo2uMObfeij2+fL4tx39625Kas/f4Hvcrv6Zc82vqJb+mxxd1t+VIt1tIZx90JeTjC7Khnu0vCTXuTV+o+fdX7yNsSiPsF1UUL6oKXlSPrzf98OGTMT6+A7ieHeO9n6ARenwPaayB42wDp9kGttkGzrMNvM428DbbwGW2getkA9fZjEedzXjU2YxHj2+1jDXwbMajzmY86mzGozoYj+X4uk389j3pJ838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"},{"name":"register_ovpk_and_tpk","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"partial_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::partial_address::PartialAddress"},"visibility":"private"},{"name":"keys","type":{"fields":[{"name":"npk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"ivpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"ovpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"tpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"aztec::keys::public_keys::PublicKeys"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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bVCZ9dFTJ1Twti0quLgWFYNKgwourkUFF9eigotrUZnUxaXHqr0U49YiM6mTOycz6yN4XiAzqaN7gcykjeULZCb1uy+QMcg8ITPtqW31IJNb9xZnfczHOZlZn5WQ0nKQSXFtkZn1E/iczKyfwOdkJm0eXiAzafvwAplJG4gXyMzqZ87JzOpnTsmUWVuIczKzthDnZPDAz8jggZ+RsVnJHD84pdokM60HPiUzrQc+JTOtBz4lM60HPiUzqwe25SBjqdXpzfp0jBfIzOr0zsnM6vTOyRhknpCZ1emdk5nV6Z2TmdXpnZOZ1emdk8HptcmUWR/E8AIZPPAzMnjgZ2TwwM/IGGSekMEDPyODB35GBg/8jAwe+BkZPPATMrM+p+AFMnjgZ2TwwM/I4IGfkTHIPCGDB35GBg/8jAwe+BkZPPAzMnjgJ2RmfU7BC2TwwM/I4IGfkcEDPyNjkHlCBg/8jAwe+BkZPPAzMnjgZ2TwwE/IzPqkmBfI4IGfkcEDPyODB35GxiDzhAwe+BmZtgfO67HRJ9f4E5n9H27v/sPy7j+sb/7DJ0+qeOEfhnf/YXz3H6Z3/6G9+w/zu//w3XeOvfvOsXffOfbuOye/+87J775z8rvvnPzuOye/+87J775z8rvvnPzuOye/+87J775z1nffOeu775z13XfO+u47Z333nbO++85Z333nrO++c9Z33znru++c7d13zvbuO2d7952zvfvO2d5952zvvnO2d98527vvnO3dd8727junvPvOKe++c8q775zy7junvPvOKe++c8q775zy7junvPvOKe++c+q775z67junvvvOqe++c+q775z67junvvvOqe++c+q775z65junLsu7/zC8+w/ju/8wvfsP7d1/mN/9h+u7/3B79x+Wd//hu++c8O47J7z7zgnvvnPCu++c8O47J7z7zgnvvnPCu++c8O47J7z7zonvvnPiu++c+O47J777zonvvnPiu++c+O47J777zonvvnPiu++c9O47J737zknvvnPSu++c9O47J737znm3Q67vdsj13Q65vtsh13c75Ppuh1zf7ZDrux1yfbdDru92yPXdDrm+2yHXdzvk+m6HXN/tkOu7HXJ9t0Ou73bI9d0Oub7bIdd3O+T6bodc3+2Q67sdcn23Q67vdsj13Q65vtsh13c75Ppuh1zf7ZDrux1yfbdDru92yPXdDrm+2yHXdzvk+m6HXN/tkOu7HXJ9t0Ou73bI9d0Oub7bIdd3O+T6bodc3+2Q67sdcn23Q67vdsj13Q65vtsh13c75Ppuh1zf7ZDrux1yfbdDru92yPXdDrm+2yHXdzvk+m6HXN/tkOubHXJc3uyQv/5hePcfxnf/YXr3H9q7/zC/+w/Xd//h9u4/LO/+w3ffOeHdd054950T3n3nhHffOeHdd054950T3n3nhHffOeHdd054950T333nxHffOfHdd058950T333nxHffOfHdd058950T333nxHffOendd056952T3n3npHffOendd056952T3n3npHffOendd056951j775z7N13jr37zrF33zn27jvH3n3n2LvvHHv3nWPvvnPs3XdOfvedk9995+R33zn53XdOfvedk9995+R33zn53XdOfvedk99956zvvnPWd98567vvnPXdd8767jtnffeds777zlnffees775z1nffOdu775zt3XfO9u47Z3v3nbO9+87Z3n3nPOmQ17Ls/3D7/hdga+sv0b5uf/948VfNd7w2mLX+ai3vP/ir2jteG2Nt/Vyr++V/3Zj79hduthyXv419+WXsy69DX/6TewvDXH4Y+/LT2JdvY19+Hvvyxz62ytjHVhn72CpjH1t17GOrjn1sPbnJO8zlj33q1g6nbvhK9vs1hbicDLD/4OXkp8a8hR8vjfk7lvVx8Xnki19Hvvht5IsvI198Hffiw7KMfPFh5IuPI198GvniBz5hwzLwCRuWgU/YsAx8woZl4BM2LCOfsGHkEzaMfMKGkU/YMPIJG0Y+YcPIJ2wY+YQNI5+wYeQTNox8wsaRT9g48gkbRz5h48gnbBz5hI0jn7Bx5BM2jnzCxpFP2DjyCZtGPmHTyCdsGvmETSOfsGnkEzaNfMKmkU/YNPIJm0Y+YdPIJ6yNfMLayCesjXzC2sgnrI18wtrIJ6yNfMLayCesjXzC2sgnbB75hM0jn7B55BM2j3zC5pFP2DzyCZtHPmHzyCdsHvmEzSOfsOvIJ+w68gm7jnzCriOfsOvIJ+w68gm7jnzCriOfsOvIJ+w68gm7jXzCbiOfsNvIJ+w28gm7jXzCbiOfsNvIJ+w28gm7jXzCbiOfsGXkE7aMfMKWkU/YMvIJ22PPk9/Fj3zClpFP2DLyCVtGPmHLyCdsHfmErSOfsHXkE7aOfMKOvNMpjLzTKYy80ymMvNMpjLzTKYy80ymOvNMpjrzTKY680ymOvNMpLgOfsHHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OceSdTnHknU5x5J1OaeSdTmnknU5p5J1OaeSdTmkZ+IRNI+90SiPvdEoj73RKI+90SiPvdEoj73RKI+90SiPvdEoj73RKI+90SiPvdEoj73RKI+90SiPvdEoj73RKI+90SiPvdEoj73RKI+90SiPvdEoj73RKI+90SiPvdEoj73RKI+90SiPvdEoj73RKI+90SiPvdEoj73RKI+90SiPvdEoj73RKI+90SiPvdEoj73RKI+90SiPvdEoj73RKI+90SiPvdEoj73RKI+90SiPvdEoj73RKI+90SiPvdEoj73RKI+90SiPvdEoj73RKI+90SiPvdEoj73RKI+90SiPvdEoj73RKI+90SiPvdEoj73RKI+90SiPvdEoj73RKI+90SiPvdEoj73RKI+90SiPvdEoj73RKT3Y6bTkcF//tH7Z/TU3lx4vr91/SvPSQ94sP9fHaGGvr51q1/QfnnB6vtsfl57Evfx378rexL7+Mffl16Mt/siJpmMuPY19+Gvvyxz62ytjHVhn72CpjH1tl7GOrjH1sPVmaNMzldzh13cJKjSNffBr54m3ki88jX/w68sVvI198Gfni67gXb8sy8sUPfMLaMvAJa8vAJ6wtA5+wtgx8wtoy8Alry8An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xY98wg680+nr4kc+YQfe6fR18SOfsAPvdPq6+JFP2IF3On1d/Mgn7MA7nb4ufuQTduCdTl8XP/IJO/BOp6+LH/mEHXin09fFj3zCDrzT6eviRz5hB97p9HXxA5+wYeSdTmHknU5h5J1OYeSdTmEZ+IQNI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdAoj73QKI+90CiPvdIoj73SKI+90iiPvdIoj73SKy8AnbBx5p1MceadTHHmnUxx5p1MceadTHHmnUxx5p1MceadTHHmnUxx5p1MceadTHHmnUxx5p1MceadTHHmnUxx5p1MceadTHHmnUxx5p1MceadTHHmnUxx5p1MceadTHHmnUxx5p1MceadTHHmnUxx5p1MceadTHHmnUxx5p1MceadTHHmnUxx5p1MceadTHHmnU3yy06mm7bj4Gk5+zbrm8uPV61riT7/m11eXr6Lrx6tLzGevTlvZf3YqsZy8ulq1H6+uOafj1V8aHQPH2QZOsw1ssw2cZxt4nW3gbbaBy2wD18kGfrKn68YDz+a08mxOK8/mtPJsTivP5rTy9U4rHLn5a+B08uqc0j5CTms9Xl1z68Wh7iE7f902//2LS172GUu29P3FO5sCm6dsKmyesVkX2DxlE2DzlE2EzVM2SZ1NqAebbTkZd807yLKu3y4k12Nem2zePNm88r6r87zbZPPKe8fO88r7wT+Zd1v222pf/1lb827yHq/zvPK+rfO88l6s87y38lcvzGuTzXsrf7Xlesy7bs15b+WvXpj3Vv7qhXlv5a9emPde/up03nIvf3U+77381fm89/JXx2V/zVt+mvfXV0dL+2VHy48fHdPRdpV7ubHedAw6v6Hzl53e/mvWa37Nds2vKdf8mnrJr6nLNb8mXPNr4jW/Jl3za+yaX3PNp0C95lOg9vgU2MIektft6+Py5BM/rcfHsi1nn/ip1ONrGTV1+FpGLbMNXOcaOC3LbAOH2QaOsw2cZhvYZhs4zzbwOtvAkxmPtMxmPMJsxiPMZjzCbMYjzGY8goPxsPAY2P71rAF1+6ZoChk2T9mssHnKZoPNUzYFNk/ZVHU2f3A3qsa0v7hG+37n9pg3LpPNGyabN042b5psXptsXnk/+EfzxuUxb/lp3l9fbV/3Tn+82r7O8OPV/4D65cXbcRduq49rjungKO8dB+Eo76UG4Xgv3+XGMd3Lz/lxvJdP/COO6RjSkuXvHHc49zKVneHcy4F2hmMTw9nsgFOWFpyJvW3a0gNObcGRL/Q84dzKhaZy3DGxZWmlwHQrt3g+r93K1b0w763cVyrpmDek5ry3MlQvzHsrj5RKPOaNsTnvrdqWF+a91WF9Pm++1eez2dHC2lab897q8/mFeW/1+WxWjnlLs2XPt/p8zseLa7a2vnaveQ998xqa897q8/mFeW+Vj3LYjnm3pn9eb/X5nI/v29U1lua8t/p8fmHee30+1+P9vKa1Oe+tPp/X7Sh/tnb+XW/VBL4w763y0brWx7zN//12+cvxbc3HvPVs54FteZ/Xvv7h7yf4+nn7hazl2520x9fkuvxN+k8D1J8G2H9NuObXxGt+TY9P7RLrIc33ZSxN1WMMe3SNMefGW9F6fPl8W47/6W1Las1uPb7H/cqvWa/5Nds1v6b0+DVHut1COvugKyEfX5AN9Wx/SajxeAxezT+/+scIMSuNsF/UqnhRm+JF9XgHBsvHRZWzv675ujX2+A7genaM936ChvX4HtJQA/f4wtBYA4fZBo6zDZxmG9hmGzjPNvA628DbbAPPZjxsNuNhsxkPm8142GzGo8ezu8caeDbjYQ7GYzm+bhO/fU/6STO/2n4leV0fjUf7z7/NHns+ttN2Kx90vn73o2p9bOc129TphOVB56T1z3bcp8l5OXlx+bozuaNcf74jsrMpsHnKpsLmGZu8wOYpmwCbp2wibJ6ySbB5ysZg85RNhs1TNvLO2JENvvg5G3zxczb44qdsVnzxczb44uds8MXP2eCLn7Mx2Dxlc70vTo8/+kinzyzrvaLY1nW2gbfZBi6zDVwnG3hbZhs4zDZwnG3gNNvANtvAsxmPbTbjsc1mPLbZjEeZzXiU2YxHceiYjmd417SejfBn3xLa4j5v2XLr73etpHvNm455t9Cc1yabN0827zrZvNtk85bJ5q1zzVuXyeYNk817L391fEe9lJia897MX8XHvNac1yab92b+6nTem/mr03lv5a/KcSGlNPftWb2Vvyp25N9S2p/Pt/JXp/Pm5Vb+qi77jy41rs15b+Wvvs+bSnPeW/mrb+/nmmpz3lv5qxfmtcnmvZW/emHeW/mr7/OW2Jz3Zv7qdN67+qtn897VXz2ZN9zJX33ZjXX/0Uv6ed7Gj7b9xTk//sb8eLRTDneyYn+IZj2e7L5ZC82dXFtdjv+V1GVNJ2jsq1L48Wr7eou04BhwnsO5kz/6UzjlDI68mXL74n8O8sbLkY28SXNkI2/o/NhEefPnyEbe/Tmykbd/jmzkCz5HNgabp2zkjbEjm+t9sT2ebGa2nrzaluM+hy22nP7ss2/15rjNNnCZbeA62cAOTztwHjjMNnCcbeA028A228B5toFnMx5pNuORZjMeNpvxsNmMh81mPByedmDr0RV81X8nr07h+JvYFMrZq4M9nmVo8edH5+0D22wD59kGXmcbeJtt4DLbwHWygR2eH+A8cJht4DjbwLM5LYed/M4Dz+a08mxOK8/mtPJsTivP5rTW2ZzWOpvTWmdzWutsTsthy7vzwLM5rXU2p7XO5rTW2ZzWOpvT2mZzWttsTsthsfdfHfj4q9av/9yaA9/sHD4duNzsLV33x5KHvCzNgW8WHs4HvtdbOodwDBxqc+B7WcsXBr6XtXxh4HtZyxcGvpe1PB+4Dmwt9xEGPln3EeTPyrrvfEwxnn55bH08jeD7X2n98+Wxxs/ejoUE4eGcUvOl6+MytrD8/sVr2l+7pvT9pTtz+a7vhswN5pczl7elN2Qu74xvyFzenN+QuXw+uCFz+YhyO+brIp+SbshcPtbdkDk59Hrm5NDrmRvMuzNf95+7FmsxJ4dez5wcej1zcuj1zMmh1zMnh17OPJCJrmdOJrqeOZnoeuYG88uZk4muZ04mup45meh65mSi65mTiS5nHrk3dz1zcuj1zMmh1zMnh17P3GB+OXNy6PXMyaHXMyeHXs+cHHo9c3Lo5cwTOfR65uTQ65mTQ69nTg69nrnB/HLm5NDrmZNDr2dODr2eOTn0eubk0MuZGzn0eubk0OuZk0OvZ04OvZ65wfxy5uTQ65mTia5nTia6njmZ6HLm+g8FvCFzMtH1zMlE1zMnE13P3GB+OXMy0fXMuTd3PXNy6PXMyaHXMyeHXs5c/5Gp6sx3kITLTiBJjJ1AEgM7gTRA9gFJYOsEkhTWCSTRqhNI8lInkISgPiD1H1E8CkiSTSeQJJtOIEk2nUAaIPuAJNl0Akmy6QSSZNMJJMmmE0iSTR+QhWTTCSTJphNIkk0nkCSbTiDxkS+B3NIDpLUeTFfwkX1AVk7tV0BaPH6wxZ8flfhHL96pc8R7UMcPeFDHPHhQN6g7UKdw9aCOq/agjgX3oE7v60Gdkvh66ttCNvWgTjb1oE429aBONvWgblB3oE429aBONvWgTjb1oE429aBONnWgHsimHtTJph7UyaYe1MmmHtQN6g7UyaYe1Mmm3anHWPZrjmmJLepkUw/qZNO/QH0ND+qtT5iIX+9PPceyU8+xtqjj1z2o49c9qBvUHajj1z2o49c9qOPXPajj1z2ocy/JgXriXpIHdbKpB3WyqQd1sqkHdYO6A3VSkgd1UpIHdVKSA3WeYv8XqJftuINX6smLky37VSRr3trmoff6EuFJ5SUyJFKXiDsx8hIRSOQlIr3IS0TUkZeIu0fqEmVuNclLRLsgLxHtgrxEtAvyEhkSqUuE6faVqISdXQmtWxE8nF5cIB4u7CxQPf4yrJa1JRDtnLhAfMT5ChSWZf8zv7AEa0jEQ231JaJVkJeIVkFeIloFeYkMidQlIhPJS0QqkpeI7yzIS0R9Ki8R7YK6RDxYWl8i2gVviVbbJQqhdSuPh2HrS0S7IC+RIZG6RLQL8hLRLshLRLsgLxHtgrxEtAvqElXaBXmJaBfkJaJdkJeIdkFeIkMidYloF+Qlol2Ql4h2QV4i2gV5iWgXxCUqC+2CvES0C/IS0S44SxTDIVEMuSUR7YK8RIZE6hLRLshLRLsgLxHtgrxEtAvyEtEuqEsUaBfkJSK6yktEdJWXyJBIXSKiq7xERFd5iYiu8hIRXeUlIrqqSxSJrvIScWNcXiLaBXmJaBfkJTIkUpeIdkFeItoFeYloF+Qlol1Qlyhhur0lsodEVloSYbrlJcIueEu0pkOiLbYkwi7IS4RdkJeImxHqEhk3I+Ql4maEvETkInmJyEXyEhkSqUvEzQh5iWgX5CWiXZCXiHZBXiLaBXWJMu2CvES0C/IS0S7IS0S7IC+RIZG6RLQLV0q0U6cw8KBOB+BBnVjvQZ2k7kB9JXx7UCdPe1AnIntQJ/V6UDeoO1Anm3pQJ5t6UCebelAnm3pQJ5s6UN/Iph7UDerdqde8vzjWNbSo4xw9qHOa/gXqZTmotz9hOE0dqBdOUw/qNL0e1Gl6PajT9HpQN6g7UMeve1Cn6fWgTtPrQZ1s6kGdbNqd+ravutpa6+IqufRq4mTSq4mTR68mTha9mrhB/GLiZNCriZM/ryZO9ryaOLnzauJkzmuJ14XMeTVxMufVxElAVxM3iF9MnAR0NXES0NXESUBXEycBdSeeHo8N+rrmrUWdFORAPZCEPKiThjyocxfOgzo51IO6Qd2BOs7xL1C3elxzTi3qOEcH6pHTtD/1tBzUU1xb1DlNPahzmnpQp931oE7D60GdlteDOn7dgzp+3YF6oun1oE7T60GdbOpBnWzqQd2g3p/68YNTqk3qZFMP6mRTD+pkUw/qZFMP6mTT/tRtOahbat1LMlKSB3VSkgd1UpIHdYO6A3VSkgd1UpIHdVKSB3VSkgd1UpID9cwdPA/qZFMP6mRTD+pkUw/qBnUH6mRTD+pkUw/qZFMP6mRTD+pkUwfqK9nUgzrZ1IM62dSDOtnUg7pB3YE62dSDOtnUgzrZ1IM62dSDOtnUgfpGNvWgTjb1oE429aBONvWgblB3oE429aBONvWgTjb1oE429aBONnWgXsimHtTJph7UyaYe1MmmHtQN6g7UyaYe1K/PpmkrB/V0Rj2vYdcof+dYc+vFth0vzsvJi8sa9+so67Z8f/HOZoPNUzYFNk/ZVNg8Y1MX2DxlE2DzlE2EzVM2CTZP2RhsnrLJsHnKpumLbVnCbr6XnE/YfF3z/lvWtZxNW2LYvXqJ+TSNbGX/2anEcpp0qh3cvz0R6J80sg+8zTZwmW3gOtXAX4Mtsw0cZhs4zjZwmm1gm23gPNvAczmtr8Hmclpfg83ltL4Gm81phdmcVpjNaYXrnVaoy2Pgs2Yhp7SPkNNaT7qCUNP+4hhOXlzysvchJVv6pSv4YmOwecomw+YpmxU2T9lssHnKpsDmKZuqzibUg83PzXOrps521NTrtwvJdZ83LpPNGyabV953dZ43TTavTTavvB/8k3m347K//rM255X3eJ3nlfdtneeV92Kd572VvzqfN93KX70w76381ZbrMe+6Nee9lb96Yd5b+asX5rXJ5r2Xvzqf917+6nzee/mr83nv5a+Or1Z+zVt+mvfXV0dL+2VHy48fHdPRdqV7ubHOdOxe3q03nb/s9PZfE6/5NemaX2PX/Jp8za9Zr/k12zW/plzza+olvyYv1/yaaz4F8jWfArnHp8AW9levW8pnn/hpPT6Wv87jk1enUo+vZdTU4WsZ2WYbOM828DrbwNtsA5fZBq6TDbwusw0cZhs4zjawzTbwbMZjnc14rLMZj3U247HOZjw2B+Nh4TGw/etZA+r3TdEtwOYpmwibp2wSbJ6yMdg8ZZPV2fzB3aga0/7iGu37ndvHvOtk826TzVsmm7fONW+R946d55X3g380b1we85af5v311RaP1baWwuPV/4D65cXbcRduq49rjungKO8dB+FocOzC8V6+y4/jvfycH8d7+cQ/4piO77BZsvyd4w7nXqayM5x7OdC+cOq97OqfwdnsgFOWFpyJvW3a0gNObcGRL/Q84did4KRy3DH5GqGVAuut3OIL897K1b0w763cVyrpmDek5ry3MlQvzHsrj5RKPOb9/oCiY96w3KpteWHeWx3WL8x7q89ns6OFta02573V5/ML897q89nseLyDla05760+n/Px4pqtqW+4VSzN4fH4jjU0573V5/ML89q95j0eWpi3pTnvrT6f8/F9u7rG0pz3Vp/PL8x7r8/n+ngIZ1pb88ZbfT6vxzOQ6tbMvyHeqgl8Yd5b5aN1rY95m//77fKX49uaj3nr2c4D2/Lxs7ezp3R9/bz9f5Fr+XYnrT4GWHsPUH8aYP812zW/plzza3p8apdYD2m+L2Npqh5j2KNrjN9+9re3Yo8vn2/L8T+9bUnN2Xt8j/uVXxOv+TXpml9jPX7NkW63kM4+6ErIxxdkQz3bXxJq3Ju+UPPPr/4xQglKI+wXFRUvKileVI934J89fDLGx3cA17NjvPcTNEKP7yGNNfA628DbbAOX2Qaukw3c41s1Yw0cZhs4zjZwmm3g2YxHnc141NmMR53NeNTJjEdcJjMecZnMeMTFwXgsx9dt4rfvST9p5lfbO4y8ro/Go/3n32aPPR/babuVDzpfv/tRtT6288YlqdMJy4POSeuf7bhPk/Ny8uLydWdyR7n+fEdkZ2Owecomw+YpmxU2T9lssHnKpsDmKZsKm2dswgKbp2wCbJ6ykXfGjmzwxc/ZGGyessEXP2eDL37OBl/8nA2++DkbfPFTNhFf/JzN9b44Pf7oI50+s6z3iuIY42wDp9kGttkGzrMNvM428DbbwGW2getkA6dltoFnMx5pNuPR49nvYw08m/FIsxmPNJvxSA4d0/EM75rWsxH+7FtCW9znLVtu/f1uTPVe86Zj3q21PyPaMtm8YbJ542TzpsnmtcnmzZPNu0427zbZvPfyV8d31EuJqTnvzfxVfMxrrXnzzfzV6bw381en897MX53Oeyt/VY4LKaW5by9mu9e8R/4tpfn5nG/lr16Y91b+qi77jy41rs15b+Wvvs+bmn1OvpW/+vZ+rqk2572Vvzqfd72Vv3ph3lv5qxfmvZW/+j5vic15b+avTue1yea9q796Nu+d/NWX3Vj3H72kn+dt/GjbX5zz42/Mj0c7xfVOVuwP0azHk903a6G5k2ury/G/krqs6QSNWd1BWg6hAWe7k+XpDudO/uhP4ZQzOPJmyu+L/5u88XJkY7B5ykbe0DmykTd/jmzk3Z8jG3n758hGvuDzY1PknbEjG3lj7Mjmel9sjyebma0nr/66kuW4EltOf/bpt3pLmm1gm23gPNvA62wDb7MNXGYbuE42sMPTDpwHDrMNPJvxqDbbwLMZjzqb8aizGY86m/FweNqBrUdXkOPZI09TOP4mNoVy9upgj2cZWvz50Xn/NnByeNqB88BhtoHjbAOn2Qa22QbOsw28zjbwNtvAZbaBZ3NaYTanFWZzWmE2pxVmc1oOe+6dB57NaYXZnFaYzWmF2ZxWmM1pxdmcVpzNacXZnFaczWk5rG53Hng2pxVnc1pxNqeVbnYOH3/V+vWfW3Pgm53D5wPf7C1d98eSh7wszYFvFh5OB7Z7vaVzCMfAoTYHvpe1fGHge1nLFwa22Qa+l7V8YeCBreU+wsAn6z6C/FlZ952PX4XC6ZfH1sfTCL7/ldY/Xx5r/OztWEgQHs4pNV+6Pi5jC8vvX7ym/bVrSt9fujOX7/ruxzzLx5wbMpe3pTdkLu+Mb8hc3pzfkLnB/HLm8hHlhszlU9INmcvHuhsyJ4dez5wcejnzlRzan/m6/9y1WIs5OfR65uTQ65mTQ69nbjC/nDk59HrmZKLrmZOJrmdOJrqc+UYmup45meh65mSi65mTia5nbjC/nDmZ6Hrm3Ju7njk59Hrm5NDrmZNDL2deyKHXMyeHXs+cHHo9c3Lo9cwN5pczJ4dez5wcej1zcuj1zMmh1zMnh17OvJJDr2dODr2eOTn0eubk0OuZG8wvZ04OvZ45OfR65uTQ65mTQ69nTg69mrnpP3buhszJodczJxNdz9xgfjlzMtH1zMlE1zMnE13PnEx0PXMy0eXM9R8QeUPmZKLrmXNv7nrm5NDrmRvML2dODr2eOTn0Q+Y7SMJlJ5Akxk4giYF9QOo/knYUkAS2TiBJYZ1AEq06gTRA9gFJCOoEkmTTCSTJphNIkk0nkCSbPiD1H/I9CkiSTSeQJJtOIEk2nUAaIPuAJNl0Akmy6QSSZNMJJMmmE0iSTR+Qho98CeSWHiAttUDiIzuB5NR+BeTXTcL9B3/dnUlvv3inzhHvQR0/4EEd8+BAPdOhelCncPWgjqv2oI4F96BuUHegTknsQZ1s6kGdbOpBnWzqQZ1s6kB9JZt6UCebelAnm3pQJ5t6UDeoO1Anm3pQJ5t6UCebelAnm3pQJ5s6UN/Iph7UyaYe1Mmm3anHWPZrjmmJLepkUw/qBvX+1NfwoN78hMGv96eeY9mp51hb1PHrHtTx6w7UC37dgzp+3YM6ft2DOn7dg7pB3YE695I8qHMvyYM62dSDOtnUgzrZ1IF6JZt6UCcleVAnJXlQN6g7UMc59qdetuMOXqknL0627FeRrHlrm4fe60uEJxWXKC8YWHmJuBMjLxGBRF4i0ou8RIZE6hJx90heIm41yUtEuyAvEe2CvES0C+oSBdoFeYkMiVwlKmFnV0JtCYTl1haIhws7C1SPvwyrZW0JRDsnLhAfcb4ChQfqsARrSUSrIC8RrYK8RLQK8hLRKqhLxMOD9SUiE8lLRCqSl4jvLMhLZEikLhHtgrxEtAvyEtEueEu02i5RCK1beTwMW18i2gV1iYx2QV4i2gV5iWgX5CWiXZCXyJBIXSLaBXmJaBfkJaJdkJeIdkFeItoFdYky7YK8RLQL8hLRLshLRLsgL5EhkbpEtAvyEtEuyEtEuyAvEe2Cs0QxHBLFkFsS0S6oS7TSLshLRLsgLxHtgrxEtAvyEhkSqUtEuyAvEe2CvEREV3mJiK7qEm1EV3mJiK7yEhFd5SUiuspLZEikLhHRVV4ioqu8RNwYl5eIdkFeItoFdYkK7YK8RLQL8hLRLshLRLsgL5EhkbpEmG5viewhkZWWRJhudYkqdsFbojUdEm2xJRF2QV4iQyJ1ibgZIS8RNyPkJeJmhLxE5CJ5ichF4hKtCzcj5CXiZoS8RLQL8hLRLshLZEikLhHtgrxEtAvyEtEuyEtEuyAvEe2CukSBdkFeItqFKyXaqVMYeFCnA/CgblB3oE5S96BO+PagTp72oE5E9qBO6nWgHgmyHtTJph7UyaYe1MmmHtQN6g7UyaYe1MmmDtQTzrE/9Zr3F8f6D7FfqeMcPahzmv4F6mU5qLc/YThNPahzmnpQp+n1oE7T60GdpteBuuHXPajj1z2o0/R6UKfp9aBuUHegTjbtTn3bV11tuUWcXHo1cTLp1cTJo1cTJ4teTDyTQ68mTga9mjj582riZM+riRvELyZO5ryaOJnzauJkzquJk4AuJr6SgK4mTgK6mjgJ6GriJKCriRvEexNPj8cGfV3z1qJOCvKgThLyoE4a8qDOXTgP6uRQB+obWdSDukG9P3WrxzXn1ne2NpyjB3VO0/7U03JQT3FtUec0daBeOE09qNPuelCn4fWgTsvrQd2g7kAdv+5BnabXgzpNrwd1sqkHdbKpA/VKNv0L1I8fnFJtUiebelAnm3pQJ5t6UDeoO1Anm/anbstB3VLrXlIlJXlQJyV5UCclXU99W0hJHtRJSR7USUke1ElJHtQN6g7USUke1LmD50GdbOpBnWzqQZ1s6kA9kE09qJNNPaiTTT2ok009qBvUHaiTTT2ok009qJNNPaiTTT2ok00dqEeyqQd1sqkHdbKpB3WyqQd1g7oDdbKpB3WyqQd1sqkHdbKpB3WyqQP1RDb1oE429aBONvWgTjb1oG5Qd6BONvWgTjb1oE429aBONvWgTjZ1oG5kUw/qZFMP6tdn07SVg3o6o57XsGuUv3OsufVi244X5+XkxWWN+3WUdVu+v3hnk2DzlI3B5imbDJunbFbYPGWzweYpmwKbp2wqbJ6xyQtsnrIJsHnK5okvXvNh1L879Sabr2vef8u6lrNpSwy7Vy8xn6aRrew/O5VYTpNOtYP7tycC/ZNG9oHTbAPbbAPn2QZeZxt4m23gMtvAdbKB12W2gcNsA8/mtNbZnNZqsw08m9NaZ3Na62xOa73eaYW6PAY+axZySvsIOa31pCsINe0vjuHkxSUv+w23ki01uoJtgc1TNgE2T9lE2Dxlk2DzlI3B5imbrM4m1IPNz81zq6bOdtTU67cLyfWYd51s3m2yeeV9V+d561zzFnnv2HleeT/4J/Nux63Sr/+szXnlPV7neeV9W+d5bbJ5b+WvXpj3Vv7qhXlv5a++7pcd865bc95b+asX5r2Vvzqft97KX70w77381fm89/JX5/Pey1+dz2u3mjdtj3nLT/P++upoab/saPnxo2M62q56LzfWm869vFtvOn/Z6e2/plzza+oVv6YsyzW/Jlzza+I1vyZd82vsml+Tr/k16zW/Zrvm15Rrfk2PT4Et7CF53VI++8RP6/GxbMvZJ34q9fhaRk2ffy2jhGW2gcNsA8fZBk6zDWyzDZxnG3idbeBttoHLZAPH2YxHnM14xNmMR5zNeMTZjEeczXhEB+Nh4TGw/etZA+r2TdESN9g8ZVNg85RNhc0zNmmBzVM2QZ3NH9yNqjHtL67Rvt+5fcwbJ5s3TTavTTZvnmxeee/YeV55P/hH88blMW/5ad5fX23xWG1rKTxe/Q+oX168HXfhtvq45pgOjvLecQyOJu+lBuF4L9/lx/Fefs6P47184h9xTMd32CxZ/s5xh2PAeQ7nXg60M5x72dU/g7PZAacsLTgTe9u0pQec2oIjX+g5wsm3cqGpHHdMbFlaKTDfyi2+MO+tXN0L897KfaWSjnlDas5rk817K4+USjzm/f6Aom/z3qpteWHeWx3W5/Out/p8NjtaWNtqc95bfT6/MO+tPp/Njsc7WGm27OutPp/z8eKara3vrWJpDo/Hd/xzqY15b/X5fD7vdqt8lB8PLcxb0z9vt/p8zsf37eoaS3PeW30+vzDvvT6f6+MhnGltznurz+f1eAZS3dr5d7tVE/jCvLfKR+taH/O2/vdbu/zl+Ha8et3q2c6Df54jtv/s7ewpXV8/b/9f5Fq+3UmrjwFi7wHqTwPsvyZd82vsml/T41O7xHpI830ZS1P1GMMeXWP89pS4b2/FHl8+35bjf3rbkpqz9/ge9yu/plzza+olv6bHF3W35Ui3W0hnH3Ql5OMLsqGe7S8JNe5NX6j551fvI2xKI+wXVRQvqgpeVI+vN/3hwydjfHwHcD07xns/QaP2+B7SWAPH2QZOsw1ssw2cZxt4nW3gbbaBy2wD18kGzrMZjzyb8cizGY8e32oZa+DZjEeezXjk2YxHdjAey/F1m/jte9JPmvnV9g4jr+uj8Wj/+bfZY8/Hdtpu5YPO1+9+DPnYzltzVacTlgedk9Y/23GfJufl5MXl687kjnL9+Y7IDzbrApunbAJsnrKJsHnKJsHmKRuDzVM2GTZP2aywecpmg81TNvLO2JENvvgpmw1f/JwNvvg5G3zxczb44udsDDZP2eCLn7PBFz9nc70vTo8/+kinzyzrvaK4bmW2getkA5dltoHDbAPH2QZOsw1ssw2cZxt4nW3g2YxHmc141NmMR53NeNTZjEedzXj0eP77n3YFxzO8a1rPRvizbwltcZ+3bLn597s132vedMy7hea862TzbpPNWyabt840b16WZbJ5w2TzxsnmTZPNa7ea9/iOeikxNee9mb+Kj3mtOe/N/NXpvDfzV6fz3sxfnc57K39VjgsppbVvLy/hVv6q2JF/S2l+Podb+asX5r2Vv6rL/qNLjWtz3lv5q+/zptKc1276fq6pNue9lb96Yd5b+asX5r2Vv3ph3lv5q+/zltic92b+6mzeeFd/9Wzeu/qrZ/PeyV992Y11/9FL+nnexo+2/cU5P0bcH+30heZOVuwP0azHk903a6GxW6E5/ldSlzWdoDGrO0jLIbTg3MnydIdzJ3/0p3DKGRx5M+X1xf8vNvLGy49NkjdpjmzkDZ0jG3nz58hG3v05sjHYPGUjX/A5spF3xo5s5I2xI5vrfbE9nmxmtp682pbjPocttpz+7JNv9X4NXCcb2OFpB84Dh9kGjrMNnGYb2GYbOM828DrbwNtsA89mPPJsxiPPZjzybMYjz2Y8HJ524Dywg/FYj64gx7NHnqZw/E1sCuXs1cEezzK0+POj8/aB19kG3mYbuMw2cJ1sYIenEjgPHGYbOM42cJptYJtt4Nmc1jqb01pnc1rrbE5rnc1pbbM5rW02p7XN5rS22ZyWw+5454Fnc1rbbE5rm81pbbM5rW02p1Vmc1plNqdVZnNaZTanVW52Dh9/1fr1n1tz4Judw6cD15u9pev+WPKQl6U5sM028L3e0jmEY+BQmwPfy1q+MPC9rOXpwGG5l7V8YeB7WcsXBh7YWu4jDHyy7iPIn5V13/mYYjz98tj6eBrB97/S+ufLY42fvR0LCb7P2Hzp+riMLSy/f/Ga9teuKX1/6c5cvuu7IXP5mHND5vK29IbM5Z3xDZnLm/P7MQ/y+eCGzOUjyg2Zy6ekGzKXj3U3ZG4wv5w5OfR65uTQ/szX/eeuxVrMyaHXMyeHXs+cHHo580gOvZ45OfR65mSi65kbzC9nTia6njmZ6HrmZKLrmZOJrmdOJrqceSITXc+cTHQ9c+7NXc+cHHo9c4P55czJodczJ4dez5wcej1zcuj1zMmhlzM3cuj1zMmh1zMnh17PnBx6PXOD+eXMyaHXMyeHXs+cHHo9c3Lo9czJoZczz+TQ65mTQ69nTg69njk59HrmBvPLmZNDr2dODr2eOTn0euZkosuZ6z8O74bMyUTXMycTXc+cTHQ9c4P55czJRNczJxNdz5xMdD1z7s1dz5wcejlz/YeF3pA5OfR65uTQD5nvIAmXnUAaIPuAJAZ2Akm26wSSwNYJJCmsE0iiVR+Q+o/8HQUkIagTSJJNJ5Akm04gDZB9QJJsOoEk2XQCSbLpBJJk0wkkyaYPyEqy6QSSZNMJJMmmE0iSTSeQBsg+IEk2nUDiI18CuaUHSGs9mK7iI7uAjAun9isgLR4/2OLPj0r8oxfv1DniPagb1B2oYx48qNOhelCncPWgjqv2oI4Fd6Ae6H09qFMSe1Anm3pQJ5t6UDeoO1Anm3pQJ5t6UCebelAnm3pQJ5s6UI9kUw/qZFMP6mRTD+pkUw/qBnUH6mRTD+pkUw/qZFMP6mTT7tS/oO7XHNMSW9TJpg7UE9n0L1Bfw4N66xMm4df7U8+x7NRzrC3qBnUH6vh1D+r4dQ/q+HUP6vh1D+r4dQfqhl/3oM69JA/q3EvyoE429aBuUHegTjb1oE429aBOSvKgTkpyoJ5JSR7UcY79qZftuINX6smL0xfrfUBr3trmoff6EuFJ5SXCwMpLxJ0YeYkIJPISkV7UJVqJOvIScfdIXiJuNclLRLsgL5EhkbpEtAvyEtEuqEvE8+adJSphZ1dC61YED6dXF4h+zlegevxlWC1rSyDaOW2BePSss0BhWfY/8wtLsJZEtAryEtEqyEtkSKQuEa2CvES0CvISkYnkJSIVyUvEdxbUJeIhzfoS0S7IS0S7IC8R7YK3RKvtEoXQupXHw7D1JaJdkJeIdkFeItoFeYloF+Qlol0QlygttAvyEtEuyEtEuyAvEe2CvESGROoS0S7IS0S7IC8R7YK8RLQL8hLRLqhLFGgX5CWiXZCXiHZBXiLaBXmJDIl8JYrhkCiG3JKIdkFeItoFeYloF+Qlol2Ql4h2QV2iSLsgLxHtgrxEtAvyEhkSqUtEdJWXiOgqLxHRVV4ioqu8RERXdYkS0VVeIqKrvEREV3mJuDEuL5EhkbpEtAvyEtEuyEtEuyAvEe2CvES0C+oSGe2CvESGRM4S2UMiKy2JMN3yEmEXvCVa0yHRFlsSYRfUJcrYBXmJuBkhLxE3I+Ql4maEvESGROoSkYvkJeJmhLxE3IyQl4h2QV4i2gV1iVbaBXmJaBfkJaJdkJeIdkFeIkMidYloF+Qlol2Ql4h24UqJduoUBh7U6QAcqG/Eeg/qJHUP6oRvD+rkaQ/qBnUH6qReD+oEWQ/qZFMP6mRTD+pkUwfqhWzqQZ1s6kGdbOpBHefYn3rN+4tj/YfYr9Rxjg7UK6fpX6BeloN68xOmcpp6UOc09aBO0+tB3aDuQJ2m14M6ft2DOn7dgzpNrwd1mt7rqdtCNvWgTjbtTn3bV11tuUWcXHo1cTLp1cQN4hcTJ4teTZwcejVxMujVxMmfVxMne15MPJA7ryZO5ryaOJnzauJkzquJk4CuJk4Cupo4Cehq4iSgq4mTgC4mHklA3Ymnx2ODvq55a1EnBXlQJwl5UCcNeVA3qDtQJ4d6UCeLOlBPOMe/QN3qcc259Z2thHP0oM5p2p96Wg7qKa4t6pymHtQ5TT2o0+56UKfh9aBOy+tAnafJu1DHr3tQp+n1oE7T60HdoO5AnWzqQZ1s+heoHz84pdqkTjb1oE429aBONnWgnsmmHtTJpv2pf+Hbr9lS615SJiV5UDeoO1AnJXlQJyV5UCcleVAnJXlQJyU5UF9JSR7USUke1LmD50GdbOpB3aDuQJ1s6kGdbOpBnWzqQZ1s6kGdbOpAfSObelAnm3pQJ5t6UCebelA3qDtQJ5t6UCebelAnm3pQJ5t6UCebOlAvZFMP6mRTD+pkUw/qZFMP6gZ1B+pkUw/qZFMP6mRTD+pkUw/qZFMH6pVs6kGdbOpBnWzqQZ1s6kHdoO5AnWzqQZ1s6kGdbOpB/fpsmrZyUE9n1PMado3yd441t15s2/HivJy8uKxxv46ybsv3F+9sKmyesMnLApunbAJsnrKJsHnKJsHmKRuDzVM2GTZP2aywecpmg81TNm1fHOL2MOr1hM3XNe+/ZV3L2bQlht2rl5hP08hW9p+dSiynSafawf3bE4H+SSP7wHWygcMy28BhtoHjbAOn2Qa22QbOsw28zjbwNtvAszmtMJvTirM5rTib04qzOa04m9OK1zutUJfHwGfNQk5pHyGntZ50BaGm/cUxnLy4fPUk+3VkS42uIK6wecpmg81TNgU2T9lU2DxjkxbYPGUT1NmEerD5uXlu1dTZjpp6/XYhuR7zxsnmTZPNa5PNmyebV947dp5X3g/+ybzbEvYfvS21Oa+8x+s8r7xv6zuvyXuxzvPeyl+9MO+t/NUL897KX225HvOuW3Nem2zeW/mrF+a9lb96Yd57+avzee/lr87nvZe/Op0338tfpe0xb/lp3l9fHS3tlx0tP350TEfble/lxnrTuZd3603nLzu9/dfYNb8mX/Nr1mt+zXbNrynX/Jp6ya9Zl2t+Tbjm18Rrfs01nwLrNZ8Ca49PgS3sIXndUj77xE/r8bFsy9knfir1+FpGTR2+lrGusw28zTZwmW3gOtnA2zLbwGG2geNsA6fZBrbZBp7NeGyzGY9tNuOxzWY8ymzGo8xmPIqD8bDwGNj+9awB9fumaEmwecrGYPOUTYbNUzYrbJ6y2dTZ/MHdqBrT/uIa7fud28e8ZbJ561zz1mWyecNk88p7x87zyvvBP5o3Lo95y0/z/vpqi8dqW0vh8ep/QP3y4u24C7fVxzXHdHA0OHbhKO+lBuF4L9/lx/Fefs6P47184h9xTMd32CxZ/s7x3+Csy71MZWc493KgneHcy67+GZzNDjhlacGZ2NumLT3g1BYc+ULPE86tXGgqxx0TW5ZGClyXW7nFF+a9lat7Yd5bua9U0jFvSK15w60M1Qvz3sojpRKPeb8/oOjbvDbZvLc6rF+Y91afz2ZHC2tbbc57q8/n83njrT6fzY7HO1jZmvPe6vM5Hy+u2dr63iqW5vB4fMc/l9qY91afzy/Me6t8lB8PLcxb0z/HW30+5+P7dnWNpTVvutXn8wvz3uvzuR7v5zWtzXlv9fm8Hs9Aqls7/6ZbNYEvzGu3mnetj3mb//vt8pfj2/EEsHWrZzsPbMv7vLadPaXr6+ftF7KWb3fS6mOA0nuA+tMA+6+pl/yaLn+T/sKv6fGpXWI9pPm+jKWpeoxhj64x5tx6K/b48vm2HP/T25bUnL3H97hf+TV2za/J1/yatcevOdLtFtLZB10J+fiCbKhn+0tCjXvTF2r++dU/RqhJaYT9okzxorLiRfV4B/7ZwydjfHwHcD07xns/QWPt8T2ksQYusw1c5xp46/FtnbEGDrMNHGcbOM02sM02cJ5t4MmMx7ZMZjy2ZTbjEWYzHmE24xFmMx5hNuPR45tLfzrwcnzdJn77nvSTZn61/Uq+CtZH49H+82+zx56P7bTdygedr9/9qFof23m3kNXphOVB56T1z3bcp8l5OXlx+bozuaNcf74jsrNZYfOUzQabp2wKbJ6yqbB5xiYusHnKJsDmKZsIm6dsEmyesjHYPGWDL37OBl/8nA2++DkbfPFzNvjip2wSvvg5G3zxczb44udsrvfF6fFHH+n0mWW9VxRvPb6gPdbAebaB19kG3mYbuMw2cJ1sYFtmGzjMNnCcbWCbbeDZjIfNZjxsNuNhsxkPm814ZIeO6XiGd03r2Qh/9i2hr1s7e/zfcuvvd7cc7jVvOubdQnPeONm8abJ5bbJ582TzrpPNu002b5ls3jrXvOu9/NXxHfVSYmrOezN/FR/zWnPem/mr03lv5q9O57XJ5r2VvyrHhZTS3Le3rbfyV8WO/FtK+/P5Vv7qhXlv5a/qsv/oUuPanPdW/ur7vKnZ52y38lff3s811ea8t/JXL8x7K3/1wry38lcvzGt3nbfE5rw381en897VXz2b967+6tm8d/JXX3Zj3X/0kn6et/GjbX9xzo+/MT8e7bRtd7Jif4hmPZ7svlkDTbmTa6vL8b+SuqzpBI1Z3UFaDqEF506WpzucO/mjP4VTzuCYOhy/L/4XeePlyEbepDmykTd0jmzkzZ8jG3n358emyts/RzbyBZ8jG3ln7MhG3hg7srHL2djjyWZm68mrbTnuc9hiy+nPPv1Wb82zDbzONvA228BltoHrXAMXh6cdOA8cZhs4zjZwmm3gyYxHWSYzHmWZzHiUZTLjUZbZjEeYzXg4PO3A1qMryPHskacpHH8Tm0I5e3Wwx7MMLf786Lx94DjbwGm2gW22gfNsA6+zDbzNNnCZbeA62cAOm/6dB57NacXZnFaczWk5bM93Hng2pxVnc1pxNqcVZ3NacTanlWZzWmk2p5Vmc1ppNqflsLrdeeDZnFaazWml2ZxWms1ppdmclt3sHD7+qvXrP7fmwDc7h88Hvtlbuu6PJQ95WVoD55uFh/OB7/WWziEcA4faHNhmG/he1vKFge9lLV8Y+F7W8oWBB7aW+wgDn6w/Rljlz8q673xMMZ5+eWx9PI3g+19p/fPlscbP3tbHkI8Zmy9dH5exheX3L17T/to1pe8v3ZnLd303ZC4fc27IXN6W3pC5wfxy5vLm/IbM5fPBDZnLR5QbMpdPSTdkLh/r7sd8I4dez5wcej1zcmh/5uv+c9diLebk0OuZG8wvZ04OvZ45OfR65uTQ65mTiS5nXshE1zMnE13PnEx0PXMy0fXMDeaXMycTXc+cTHQ9czLR9cy5N3c9c3Lo5cwrOfR65uTQ65mTQ69nTg69nrnB/HLm5NDrmZNDr2dODr2eOTn0eubk0KuZ14Ucej1zcuj1zMmh1zMnh17P3GB+OXNy6PXMyaHXMyeHXs+cHHo9c3Lo5cwDOfR65uTQ65mTQ69nTg69njmZ6HrmZKLrmZOJrmdOJrqeOZnocub6j0a8IXMy0fXMyUTXMycTXc/cYH45c3Lo9czJodczJ4dez5wc+iHzHSThsg9I/Ue8jgKSGNgJJNmuE0gCWyeQBsg+IIlWnUCSlzqBJAR1Akmy6QSSZNMHpJFsOoEk2XQCSbLpBJJk0wmkAbIPSJJNJ5Akm04gSTadQJJsOoEk2fQBmUk2nUCSbDqBNEC+AnJLD5CWWiDxkZ1Acmq/AtLi8YMt/vyoxD968U6dI96B+oof8KCOefCgTofqQZ3C1YO6Qd2BOhbcgzq9rwd1SmIP6mRTD+pkUwfqG9nUgzrZ1IM62dSDOtnUg7pB3YE62dSDOtnUgzrZ1IM62dSDOtnUgXohm3pQJ5t6UCebelAnm3pQN6j3ph5j2a85piW2qJNNPaiTTf8C9TU8qDc/YfDr/annWHbqOdYG9Ypf96COX/egjl/3oI5f96BuUHegjl/3oI5f96DOvSQP6txL8qBONr2c+rosZFMP6mRTD+pkUw/qBnUH6qQkD+qkJA/qOMf+1Mt23MEr9eTFyZb9KpI1bm2vCw+915cITyovEQZWXiLuxMhLZEikLhHpRV4ioo68RNw9kpeIW03yEtEuqEsUaRfkJaJdkJeIdkFeIky3r0Ql7OxKaN2K4OH04gLxcGFngerxl2G1rC2BDIG0BeIjzlegsCz7n/mFrzK7JRGtgrxEtArqEvEgXn2JaBXkJaJVkJeITCQvkSGRukR8Z0FeIupTeYloF+Qlol2Ql4h2wVui1XaJQmjdyuNh2PoS0S7IS0S7IC8R7YK8RIZE6hLRLshLRLsgLxHtgrxEtAvyEtEuqEu00i7IS0S7IC8R7YK8RLQL8hIZEqlLRLsgLxHtgrxEtAvyEtEuyEtEu6Au0Ua74CxRDIdEMeSWRLQL8hLRLshLRLsgL5EhkbpEtAvyEtEuyEtEuyAvEe2CukSF6CovEdFVXiKiq7xERFd5iQyJ1CUiuspLRHSVl4joKi8R0VVeIm6Mq0tUaRfkJaJdkJeIdkFeItoFeYkMidQlol2Ql4h2QVyisGC6vSWyh0RWWhJhuuUlMiRylmhNh0RbbEmEXZCXCLsgLxE3I+Ql4maEvETcjFCXKJCL5CUiF8lLxM0IeYm4GSEvkSGRukS0C/IS0S7IS0S7IC8R7YK8RLQL6hJF2gV5iWgX5CWiXZCXiHbhSol26gZ1B+p0AB7UifUe1EnqHtQJ3x7UydMO1BMR2YM6qdeDOkHWgzrZ1IO6Qd2BOtnUgzrZ1IM62dSDOtnUgbrhHPtTr3l/caz/EPuVOs7Rgzqn6V+gXpaDevsThtPUgzqnqQd1ml4H6pmm14M6Ta8Hdfy6B3X8ugd1g7oDdZpeD+pkUw/qZNPu1Ld91dXWWheXyaVXEyeTXkx8JY9eTZwsejVxcujVxMmgVxM3iF9MnOx5NXFy59XEyZxXEydzXk2czHkx8Y0EdDVxEtDVxElAVxM3iF9MnAR0NXESUHfi6fHYoK9r3lrUSUEe1ElCHtRJQw7UC3fhPKiTQz2ok0U9qOMc/wJ1q8c159Z3tgrO0YF65TTtTz0tB/UU1xZ1TlMP6pymHtRpdz2oG9QdqNPyelDHr3tQx697UKfp9aBO03s99biQTT2ok009qJNN/wL14wenVJvUyaYe1A3qDtTJph7UyaYe1Mmm/anbclC3lFrUSUkO1AMpyYM6KcmDOinJgzopyYO6Qd2BOinJgzopyYM6KcmDOnfwPKiTTR2oR7KpB3WyqQd1sqkHdbKpB3WDugN1sqkHdbKpB3WyqQd1sqkHdbKpA/VENvWgTjb1oE429aBONvWgblB3oE429aBONvWgTjb1oE429aBONnWgbmRTD+pkUw/qZFMP6mRTD+oGdQfqZFMP6mRTD+pkUw/qZFMP6mRTB+qZbOpBnWzqQZ1s6kGdbOpB3S6nnrZyUE9n1PMado3yd441t15s2/HivJy8uKxxv46ybsv3F+9sMmyesllh85TNBpunbApsnrKpsHnGZl1g85RNgM1TNhE2T9kk2Dxlw92D/mnk7LlEceXuwV+gvoXjmuvSok6j6kB9o1H1oE6j6kGdRtWDOo2qB3WDugN1/LoHdfy6B3W+7eNBnW/7eFAnmzpQL2RTD+pk0/7UU9wn/PrP3KJONvWgTjb1oG5Qd6BONvWgTjb1oE429aBONvWgTjZ1oF7Jph7UyaZ/g/rj+dAWW9TJph7UyaYe1A3qDtTJph7UyaYe1Mmmf4H68qAeW0/lrmRTD+pk0+upp4Vs6kGdbOpBnWzqQZ1s6kHdoO5AnWzqQZ1s6kGdbOpBnWzqQZ1s6kA9kE09qJNNPaiTTT2ok009qBvUHaiTTT2ok009qJNNPaiTTT2ok00dqEeyqQd1sqkHdbKpB3WyqQd1g7oDdbKpB3WyqQd1sqkHdbKpB3WyqQP1RDb1oE429aBONvWgTjb1oG5Qd6BONvWgTjb1oE429aBOSnKgbqQkD+qkJA/qpCQP6qQkD+o4x+7UY837i2P9h9iv1HGOHtS5q+FBHb/uQD3j1z2o49c9qOPXPajj1z2oG9QdqHNXw4M62dSDOtnUgzrZ9C9Qr/sPTksoLepkUwfqK9nUgzrZ1IM62dSDOtnUg7pBvT/1shzOsaYWdbKpB3WyqQd1sqkHdbKpB3WyqQP1jWzqQZ1s6kGdbOpBnWzqQd2g7kCdbOpBnWzqQZ1s6kGdbOpBnWzqQL2QTT2ok009qJNNPaiTTT2oG9QdqJNNPaiTTT2ok009qJNNPaiTTR2oV7KpB3WyqQd1sqkHdbKpB3WDugN1sqkHdbKpB3WyqQd1sqkHdbLp9dRtIZt6UCebelAnm3pQJ5t6UDeoO1Anm3pQJ5t6UCebelAnm3pQJ5s6UA/49f7Uy7Zfcyz15MUhmv148dd/lpZEmHt5iQyJ1CUiNshLRMaQl4hAIi8R6UVeIqKOukSRe3byEnGDT14i2gVvibZ8SFSaEtEuyEtkSKQuEe2CvES0C/IS0S7IS0S74C3Rmg6JttiSiHZBXaJEuyAvEe2CvES0C/IS0S7IS2RIpC4R7YK8RLQL8hLRLshLRLsgLxHtgrpERrsgLxHtgrxEtAvyEtEuyEtkSKQuEe2CvES0C/IS0S7IS0S7IC8R7YK6RJl2QV4i2gV5iWgX5CWiXZCXyJBIXSLaBXmJaBfkJaJdkJeIdkFeItoFdYlW2gV5iWgX5CWiXZCXiHZBXiJDInWJaBfkJaJdkJeIXOQrUS37a2tZGwJtpCJxgchE4gKRiMQFIg+JC2QIpC0QWUhcIJKQuEDcZRUXiHus4gLRJGgLVGgSxAWiSRAXiCZBXCCaBHGBDIG0BaJJEBeIJsFXoLAs4ceLwxKsJRFdgrxEtAnyEtEnqEtUaRTkJaJTkJeIVkFeInoFeYkMidQloluQl4h2QV4i2gVviUI5JEqhJRHtgrxEtAviEuWFdkFeItoFeYloF+Qlol0QMt1tiQyJtHNRXmgX5CWiXZCXiHZBXiLaBXmJaBfUJQq0C/IS0S7IS0S7IC8R7YK8RIZE6hLRLshLRLsgLxHtgrxEtAvyEtEuqEsUaRfkJaJdkJeIdkFeItoFeYkMidQlol2Ql4h2QV4i2gV5iWgX5CWiXVCXKNEuyEtEuyAvEe2CvES0C/ISGRKpS0S7IC8R7YK8RLQL8hLRLshLRLugLpHRLshLRLsgLxHtgrxEtAvyEhkSqUtEuyAvEe2CvES0C/IS0S7IS0S7oC5RJhf5SlTCzq6E2hKIVOQsUNp/cMlbSyBDIG2BSETiAuHkxAXCx2kLtHKPSFwg7hCJC0QOEheIHCQukCGQtkDkIHGBuC8kLhB3hcQFokkQF4gmQVugjSbBWaDjIkpp3Q/aCKriAhFUxQUyBNIWiKAqLhBBVVwggqq4QARVcYEIqtoCFYKquEDc8hYXiCZBXCCaBHGBDIG0BaJJEBeIJkFcIJoEcYFoEsQFoknQFqjSJIgLRJMgLhBNgrhANAniAhkCaQtEkyAuEE2CuEA0CeIC0SSIC0STIC3QutAkiAtEkyAuEE2CuEA0CeICGQJpC0STIC4QTYK4QDQJ4gLRJIgLRJOgLVCgSRAXiCZBXCCaBHGBDIG0BSKoigtEUBUXiKAqLhBBVVugiM1+RaCvl+7P+UnbFlogscOdQOKKXgJZFtsvo4TYAol76QQSl9EJJG6gE0jq5T4gEzVwJ5D4yNfsT10eIE+8e4hr+vHiL45N6phOD+p8RcuDukHdgTppzIM60c2DOjnPgzqh0IM6CdKBuhE3PaiTTT2ok009qJNNPagb1B2ok009qJNNPaiTTT2ok009qJNNHahnsqkHdbKpB3WyqQd1sqkHdYO6A3WyqQd1sqkHdbKpB3WyqQd1sml/6qmWnbrF1t+ErGRTD+pk079AfbMH9dYnzGpQ70796270Tv3rFmmLOn7dgzp+3YM6ft2DOn79L1Av+1WELSwt6vh1B+obft2DOn7dgzr3kv4C9UcPs4VWNt3w6/2pl3X/waGUtUUdD9OdegzLvhElhmAt6ngYB+oFD+NBHQ/jQR0P40Gd78N4UDeoO1DHr3tQp1/3oE6/7kGdbOpBnWzqQL2STT2ok009qJNNPaiTTT2oG9QdqJNNPaiTTT2ok009qJNNPaiTTa+nvi1kUw/qZFMP6mRTD+pkUw/qBnUH6mRTD+pkUw/qZFMP6mTTv0A920E95xZ1sqkD9UA29aBONvWgTjb1oE429aBuUHegTjb1oE429aBONvWgTjb1oE42daAeyaYe1MmmHtQN6r2pn+7M2CJ+3YM6ft2DOn69P/VyXEUo1rqXFPHrHtTx6w7UE37dgzp+3YM695I8qHMvyYO6Qd2BOtnUgzrZ1IM62dSDOtnUgzrZ1IG6kU09qJNNPaiTTT2ok009qBvUHaiTTT2ok009qJNNPaiTTT2ok00dqGeyqQd1sqkHdbKpB3WyqQd1g7oDdbKpB3Wy6V+gfvL0wS2TTT2ok009qJNNHaivZFMP6mRTD+pkUw/qZFMP6gZ1B+pkUw/qZFMP6mRTD+pkUw/qZFMH6hvZ1IM62dSDOtnUgzp+vT/1fOxCCnnLJz/Zlv0qkqXUkghzLy8RSUBeImKDvERkDHWJCoFEXiLSi7xERB15ibhnJy+RIZG6RLQL8hLRLshLRLsgLxHtgrpEFdPtK1EJO7sSaksgLLe4QPRzvgLVss9XWzfzykI7Jy4QH3G+AoXleDR2WFqPxi6LIZG6RLQK8hLRKshLRKsgLxGtgrxEZCJ1iQKpSF4ivrMgLxH1qbxEtAvyEhkSqUtEu+At0Xq8OITUkoh2QV4i2gV5iWgX5CWiXVCXKNIuyEtEuyAvEe2CvES0C/ISGRKpS0S7IC8R7YK8RLQL8hLRLshLRLugLlGiXZCXiHZBXiLaBXmJaBfkJTIkUpeIdkFeItoFZ4liOF4cQ25JRLsgLxHtgrxEtAvqEhntgrxEtAvyEtEuyEtEuyAvkSGRukREV3mJiK7yEhFd5SUiuqpLlImu8hIRXeUlIrrKS0R0lZfIkEhdIm6My0tEuyAvEe2CvES0C/IS0S6oS7TSLshLRLsgLxHtgrxEmG5viewhkZWWRJhudYk27IK3RGs6JNpiSyLsgrxE2AV5ibgZIS+RIZG6RNyMkJeIXCQvEblIXiJuRshLxM0IdYkK7YK8RLQL8hLRLshLRLsgL5Eh0YUS7dQpDP4C9VJ36uvSfK/TAXhQJ9Z7UCepe1AnfDtQr+RpD+pEZA/qpF4P6gRZD+oGdQfqZFMP6mRTD+pkUw/qZFMP6mTT66nXhWzqQZ1s6kGdbOpBnWzqQd2g7kCdbOpBnWzqQZ1s6kGdbOpBnWzqQD2QTT2ok009qJNNPaiTTT2oG9QdqJNN+1NfLR7ULbWok009qJNNPaiTTT2ok00dqEeyqQd1sqkHdbKpB3WyqQd1g7oDdbKpB3WyqQd1sqkHdVJSd+oxHHsEvv6zsUegJlKSB3VSkgd1UpIHdVKSB3WDugN1UpIHdVKSB3VSkgd17uB5UCebOlA3sqkHdbKpB3WyqQd1sqkHdYO6A3WyqQd1sqkHdbKpB3WyqQd1sqkD9Uw29aBONvWgTjb1oG5Q/4z6DpLg0wkkWaYTSOJJJ5Akjj4gV4xV9yP+D5+zZceLo5WWRLgweYm4nSAvkSGRukT4dXmJSALyEpEx5CUivchLxM0VdYk27sTIS0S74C3Rlg+JSlMi2gV5iWgX5CUyJFKXiHZBXiLaBXmJaBe8JVrTIdHW2ia80S7IS0S7oC5RoV2Ql4h2QV4i2gV5iWgX5CUyJFKXiHZBXiLaBXmJaBfkJaJdkJeIdkFdokq7IC8R7YK8RLQL8hLRLshLZEikLhHtgrxEtAvyEtEuyEtEuyAvEe2CtkTbstAuyEtEuyAvEe2CvES0C/ISGRKpS0S7IC8R7YK8RLQL8hLRLshLRLugLlGgXZCXiHZBXiLaBXmJaBfkJTIkUpeIdkFeInKRr0S17PPVsrYEIhVpCxTJROICkYjEBSIPiQtEGhIXyBBIWyCSkLhA3GUVF4h7rOIC0SSIC0SToC1QokkQF4gmQVwgmgRxgWgSxAUyBNIWiCbBV6CwLGF/8RKsJRFdgrxEtAnyEtEnyEtEo6AukdEpyEtEqyAvEb2CvEQ0C/ISGRKpS0S7IC8R7YK3RKEcEqXQkoh2QV4i2gV5iWgX1CXKtAvyEtEuyEtEuyBkutsS0S6o56JsSKQuEe2CvES0C/IS0S7IS0S7IC8R7YK6RCvtgrxEtAvyEtEuyEtEuyAvkSGRukS0C/IS0S7IS0S7IC8R7YK8RLQL6hJttAvyEtEuyEtEuyAvEe2CvESGROoS0S7IS0S7IC8R7YK8RLQL8hLRLqhLVGgX5CWiXZCXiHZBXiLaBXmJDInUJaJdkJeIdkFeItoFeYloF+Qlol1Ql6jSLshLRLsgLxHtgrxEtAvyEhkSqUtEuyAvEe2CvES0C/IS0S6IS/T1f0UiV4lK2NmVUFsCkYqcBUr7FZe8tQQiE4kLZAikLRBOTlwgfJy4QNwj0hYocIdIXCBykLhA5CBxgchB4gIZAmkLxH0hcYG4KyQuEE2CuEA0CeIC0SQ4C3RcRCmt+0GRoCouEEFVXCCCqrhAhkDaAhFUxQUiqIoLRFAVF4igKi4QQVVboMQtb3GBaBLEBaJJEBeIJkFcIEMgbYFoEsQFokkQF4gmQVwgmgRxgWgStAUymgRxgWgSxAWiSRAXiCZBXCBDIG2BaBLEBaJJEBeIJkFcIJoEcYFoErQFyjQJ4gLRJIgLRJMgLhBNgrhAhkDaAtEkiAtEkyAuEE2CuEA0CeIC0SRoC7TSJIgLRJMgLhBBVVwgQyBtgQiq4gIRVMUFIqhqC7TJ2+wDeQrl7NVfN4jrgWb5Wc59YHnb2ntg+RtKvQeW9729B7bZBpb3ZX80cD6eUPX1n6U5sLzP6T2wvG/oPbB8Ydx7YPkCtvPA5V5O6+sHHgOn5qd0uZfTemHgezmtFwa+l9N6YWCbbeCbOa3zgW/mtM4HvpnTOh/4Zk7rfOCbOa3TgetsTqvO5rTqbE6rzua0qs028N06rfDIw7U58N06rdOB79ZpnQ58t07rdOC7dVonA8flZk7rfOCbOa3zgW/mtM4HvpnTOh/YZht4MqcVl8mcVlwmc1pxmcxpxWU2pxVmc1phNqcVZnNa+s+z7z2wzTbwbE5L//nlvQeezWnpP1+798CzOa04m9PSf+B174Fnc1r6D2TuPbDNNvBsTkv/Aby9B57Naek/ILb3wLM5Lf0HmPYeeDanpf+Azd4Dz+a09B9f92d/e2j7n0t//efWHPhe5/ALA9/rHH5h4Hudw+cD6z/+q/fAN9sBsG7HwN/2QXwf+GY7AM4HvtkOgPOBbbaB79V4vDDwzZzW+cA3c1rnA9/MaZ0PfDOndTqw/uNReg88m9PSf3xH74Fnc1r6j5foPfBsTkv/8Qe9B57Naemv5+898GxOS399fO+BZ3Na62xOS3+fe++B7V4D53IMvFpz4Js5rfOBb+a0zge+mdM6H/hmTut84Js5rdOB77ZB/Hzgmzmt84Fv5rTOB76Z0zof2GYbeDandbMN4i8MPJvTutkG8RcGns1p3WyD+AsDz+a0brZB/IWBZ3NaN9sg/sLAszmtm20Qf2Hg2ZzWzTaIvzDwbE7rZhvEXxh4Nqd1sw3iLww8m9O62QbxFwaezWndbIP4CwPP5rRutkH8hYEnc1rpZhvEXxh4MqeVbrZB/IWB2+fwsuZj4O/PA3cYWOKZ5xaPH2wxpd+/OEWrxzXnn168U1+h3p/6Fo5rrkuLeoX69dSfLIOG+t+lHqDuQD1C3YF6groDdYO6A3X8ugd1/LoH9Q3qDtQL1B2ok00dqEeyqQd1sml/6l/v5f2av0rHFnWyqQd1sqkHdYO6A3WyqQd1sqkHdbKpB3WyqQd1sqkD9UQ29aBONv0b1I/vwySLLepkUw/qZFMP6gZ1B+pkUw/qZFMP6mTTv0B9eVCPa4s62dSDOtnUgbqRTT2ok009qJNNPaiTTT2oG9QdqJNNPaiTTT2ok009qJNNPaiTTR2oZ7KpB3WyqQd1sqkHdbKpB3WDugN1sqkHdbKpB3WyqQd1sqkHdbKpA/WVbOpBnWzqQZ1s6kGdbOpB3aDuQJ1s6kGdbOpBnWzqQZ1s6kGdbOpAfSObelAnm3pQJ5t6UCebelA3qDtQJ5t6UCebelAnm3pQJyU5UC+kJA/qpCQP6qQkD+qkJA/qOMfu1GPN+4tj/YfYr9Rxjh7UuavhQR2/7kC94tc9qOPXPajj1z2o49c9qBvUHahzV8ODOtnUgzrZ1IM62fQvUK/7D05LKC3qZNPrqdtCNvWgTjb1oE429aBONvWgblDvT70sh3OsqUWdbOpBnWzqQZ1s6kGdbOpBnWzqQD2QTT2ok009qJNNPaiTTT2oG9QdqJNNPaiTTT2ok009qJNNPaiTTR2oR7KpB3WyqQd1sqkHdbKpB3WDugN1sqkHdbKpB3WyqQd1sqkHdbKpA/VENvWgTjb1oE429aBONvWgblB3oE429aBONvWgTjb1oE429aBONnWgbmRTD+pkUw/qZFMP6mRTD+oGdQfqZFMP6mRTD+pkUw/qZFMP6mRTB+oZv96fetn2a46lnrw4RLMfL/76z9Zak4y5l5fIkEhdImKDvERkDHmJCCTyEpFe5CUi6qhLtHLPTl4ibvDJS0S74C3Rlg+JSlMi2gV5iQyJ1CWiXZCXiHZBXiLaBXmJaBe8JVrTIdEWWxLRLqhLtNEuyEtEuyAvEe2CvES0C/ISGRKpS0S7IC8R7YK8RLQL8hLRLshLRLugLlGhXZCXiHZBXiLaBXmJaBfkJTIkUpeIdkFeItoFeYloF+Qlol2Ql4h2QV2iSrsgLxHtgrxEtAvyEtEuyEtkSKQuEe2CvES0C/IS0S7IS0S7IC8R7YK4RHmhXZCXiHZBXiLaBXmJaBfkJTIkUpeIdkFeItoFeYnIRb4S1bK/tpa1IVAgFYkLRCYSF4hEJC4QeUhcIEMgbYHIQuICkYTEBeIuq7hA3GMVF4gmQVugSJMgLhBNgrhANAniAtEkiAtkCKQtEE2CuEA0Cb4ChWUJP14clmAtiegS5CWiTZCXiD5BXaJEoyAvEZ2CvES0CvIS0SvIS2RIpC4R3YK8RLQL8hLRLnhLFMohUQotiWgX5CWiXVCXyGgX5CWiXZCXiHZBXiLaBSHT3ZbIkEg8FxntgrxEtAvyEtEuyEtEuyAvEe2CukSZdkFeItoFeYloF+Qlol2Ql8iQSF0i2gV5iWgX5CWiXZCXiHZBXiLaBXWJVtoFeYloF+Qlol2Ql4h2QV4iQyJ1iWgX5CWiXZCXiHZBXiLaBXmJaBfUJdpoF+Qlol2Ql4h2QV4i2gV5iQyJ1CWiXZCXiHZBXiLaBXmJaBfkJaJdUJeo0C7IS0S7IC8R7YK8RLQL8hIZEqlLRLsgLxHtgrxEtAvyEtEuyEtEu6AuUSUX+UpUws6uhNoSiFTkLFDaf3DJW0sgQyBtgUhE4gLh5MQFwsdJC7Qu3CMSF4g7ROICkYPEBSIHiQtkCKQtEDlIXCDuC4kLxF0hcYFoEsQFoknQFijQJDgLdFxEKbUlEEFVXCCCqrhAhkDaAhFUxQUiqIoLRFAVF4igKi4QQVVboEhQFReIW97iAtEkiAtEkyAukCGQtkA0CeIC0SSIC0STIC4QTYK4QDQJ2gIlmgRxgWgSxAWiSRAXiCZBXCBDIG2BaBLEBaJJEBeIJkFcIJoEcYFoErQFMpoEcYFoEsQFokkQF4gmQVwgQyBtgWgSxAWiSRAXiCZBXCCaBHGBaBK0Bco0CeIC0SSIC0STIC6QIZC2QARVcYEIquICEVTFBSKoagu0YrNfEejrpftzftK2hRZI7HAnkLiil0CWxfbLKCG2QOJeOoHEZXQCiRvoBJJ6uQ/IjRq4E0h85Gv2py4PkCfePcQ1/XhxiFuTOqbTgzpf0fKgblB3oE4a86BOdPOgTs7zoE4o9KBOgnSgXoibHtTJph7UyaYe1MmmHtQN6g7UyaYe1MmmHtTJph7UyaYe1MmmDtQr2dSDOtnUgzrZ1IM62dSDukHdgTrZ1IM62dSDOtnUgzrZ1IM62bQ/9VTLTt1i429CtoVs6kGdbPoXqG/2oB5b1A3q3amvtl/z13+mFnX8ugd1/LoHdfy6B3X8+l+gXvarCFtYWtTx6w7UA37dgzp+3YM695L+AvVHD/P1tm5Rx6/3p17W/QeHUtYWdTxMd+oxLPtGlBiCtajjYRyoRzyMB3U8jAd1PIwHdb4P40HdoO5AHb/uQZ1+3YM6/boHdbKpB3WyqQP1RDb1oE429aBONvWgTjb1oG5Qd6BONvWgTjb1oE429aBONvWgTjZ1oG5kUw/qZFMP6mRTD+pkUw/qBnUH6mRTD+pkUw/qZFMP6mTTv0A920E95xZ1sqkD9Uw29aBONvWgTjb1oE429aBuUHegTjb1oE429aBONvWgTjb1oE42daC+kk09qJNNPagb1HtTP9+ZseLXPajj1z2o49f7Uy/HVYRirXtJK37dgzp+3YH6hl/3oI5f96DOvSQP6txL8qBuUHegTjb1oE429aBONvWgTjb1oE42daBeyKYe1MmmHtTJph7UyaYe1A3qDtTJph7UyaYe1MmmHtTJph7UyaYO1CvZ1IM62dSDOtnUgzrZ1IO6Qd2BOtnUgzrZ9C9QP3v6YCWbelAnm3pQJ5teT70sZFMP6mRTD+pkUw/qZFMP6gZ1B+pkUw/qZFMP6mRTD+pkUw/qZFMH6oFs6kGdbOpBnWzqQR2/3p96PnYhhbzlk5/8xXr/yZZSSyLMvbxEJAF5iYgN8hKRMdQligQSeYlIL/ISEXXkJeKenbxEhkTqEtEuyEtEuyAvEe2CvES0C+oSJUy3r0Rf9xp+vPar6WkJhOUWF4h+zlegWvb5avNmntHOiQvER5yvQGE5Ho0dltajsYsZEqlLRKsgLxGtgrxEtAryEtEqyEtEJlKXKJOK5CXiOwvyElGfyktEuyAvkSGRukS0C94SrceLQ2jdysu0C/IS0S7IS0S7IC8R7YK6RCvtgrxEtAvyEtEuyEtEuyAvkSGRukS0C/IS0S7IS0S7IC8R7YK8RLQL6hJttAvyEtEuyEtEuyAvEe2CvESGROoS0S7IS0S74CxRDMeLY8gtiWgX5CWiXZCXiHZBXaJCuyAvEe2CvES0C/IS0S7IS2RIpC4R0VVeIqKrvEREV3mJiK7qElWiq7xERFd5iYiu8hIRXeUlMiRSl4gb4/IS0S7IS0S7IC8R7YK8RLQL4hLVhXZBXiLaBXmJaBfkJcJ0e0tkD4mstCTCdKtLFLAL3hKt6ZBoiy2JsAvyEmEX5CXiZoS8RIZE6hJxM0JeInKRvETkInmJuBkhLxE3I9QlirQL8hLRLshLRLsgLxHtgrxEhkQXSrRTpzD4C9RL3amvS/O9TgfgQZ1Y70GdpO5BnfDtQD2Rpz2oE5E9qJN6PagTZD2oG9QdqJNNPaiTTT2ok009qJNNPaiTTR2oG9nUgzrZ1IM62dSDOtnUg7pB3YE62dSDOtnUgzrZ1IM62dSDOtnUgXomm3pQJ5t6UCebelAnm3pQN6g7UCeb9qe+WjyoW2pRJ5t6UCebelAnm3pQJ5s6UF/Jph7UyaYe1MmmHtTJph7UDeoO1MmmHtTJph7UyaYe1ElJ3anHcOwR+PrP1h6BjZTkQZ2U5EGdlORBnZTkQd2g7kCdlORBnZTkQZ2U5EGdO3ge1MmmDtQL2dSDOtnUgzrZ1IM62dSDukHdgTrZ1IM62dSDOtnUgzrZ1IM62dSBeiWbelAnm3pQJ5t6UDeof0Z9B0nw6QSSLNMJJPGkE0gSRw+QZVkwVt2P+D98zpYdL45WWhLhwuQl4naCvESGROoS4dflJSIJyEtExpCXiPQiLxE3V9QlCtyJkZeIdsFboi0fEpWmRLQL8hLRLshLZEikLhHtgrxEtAvyEtEueEu0pkOiLbYkol2Ql4h2QV2iSLsgLxHtgrxEtAvyEtEuyEtkSKQuEe2CvES0C/IS0S7IS0S7IC8R7YK6RIl2QV4i2gV5iWgX5CWiXZCXyJBIXSLaBXmJaBfkJaJdkJeIdkFeItoFdYmMdkFeItoFeYloF+Qlol2Ql8iQSF0i2gV5iWgX5CWiXZCXiHZBXiLaBXWJMu2CvES0C/IS0S7IS0S7IC+RIZG6RLQL8hKRi3wlqmWfr5a1JRCpSFuglUwkLhCJSFwg8pC4QKQhcYEMgbQFIgmJC8RdVnGBuMcqLhBNgrhANAnaAm00CeIC0SSIC0STIC4QTYK4QIZA2gLRJPgKFJYl7C9egrUkokuQl4g2QV4i+gR5iWgU1CUqdAryEtEqyEtEryAvEc2CvESGROoS0S7IS0S74C1RKIdEKbQkol2Ql4h2QV4i2gV1iSrtgrxEtAvyEtEuCJnutkS0C+q5qBoSqUtEuyAvEe2CvES0C/IS0S7IS0S7IC7R1wuQSF0i2gV5iWgX5CWiXZCXyJBIXSLaBXmJaBfkJaJdkJeIdkFeItoFdYkC7YK8RLQL8hLRLshLRLsgL5EhkbpEtAvyEtEuyEtEuyAvEe2CvES0C+oSRdoFeYloF+Qlol2Ql4h2QV4iQyJ1iWgX5CWiXZCXiHZBXiLaBXmJaBfUJUq0C/IS0S7IS0S7IC8R7YK8RIZE6hLRLshLRLsgLxHtgrxEtAvqEhm5yFeiEnZ2JdSWQKQiZ4HSfsUlby2ByETiAhkCaQuEkxMXCB8nLhD3iLQFytwhEheIHCQuEDlIXCBykLhAhkDaAnFfSFwg7gqJC0STIC4QTYK4QDQJzgIdF1FK637QSlAVF4igKi4QQVVcIEMgbYEIquICEVTFBSKoigtEUBUXiKCqLdDGLW9xgWgSxAWiSRAXiCZBXCBDIG2BaBLEBaJJEBeIJkFcIJoEcYFoErQFKjQJ4gLRJIgLRJMgLhBNgrhAhkDaAtEkiAtEkyAuEE2CuEA0CeIC0SRoC1RpEsQFokkQF4gmQVwgmgRxgQyBtAWiSRAXiCZBXCCaBHGBaBLEBaJJkBYoLjQJ4gLRJIgLRFAVF8gQSFsggqq4QARVcYEIqtoCBXmbfSBPoZy9OlitB5rlZzn3geVta++B5W8o9R5Y3vf2HthmG1jel/3RwPl4QtXXf5bmwPI+p/fA8r6h98DyhXHvgeUL2M4Dx3s5ra8feAycmp/S8V5O64WB7+W0Xhj4Xk7rhYFttoFv5rTOB76Z0zof+GZO63zgmzmt84Fv5rROB06zOa00m9NKszmtNJvTSjbbwHfrtMIjD9fmwHfrtE4HvlundTrw3Tqt04Hv1mmdDWw3c1rnA9/MaZ0PfDOndT7wzZzW+cA228CzOS2bzWnZbE7LZnNaNpvTyrM5rTyb08qzOS3959n3HthmG3g2p6X//PLeA8/mtPSfr9174Nmc1jqb09J/4HXvgWdzWvoPZO49sM028GxOS/8BvL0Hns1p6T8gtvfAszkt/QeY9h54Nqel/4DN3gPP5rT0H1/3Z397aPufS3/959Yc+F7n8AsD3+scfmHge53D5wPrP/6r98A32wGwbsfA3/ZBfB/4ZjsAzge+2Q6A84FttoHv1Xi8MPDNnNb5wDdzWucD38xpnQ98M6d1OrD+41F6Dzyb09J/fEfvgWdzWvqPl+g98GxOS//xB70Hns1p6a/n7z3wZE4r6a+P7z3wZE4rLZM5raS/z733wHavgXM5Bl6tOfDNnNb5wDdzWucD38xpnQ98M6d1PvDNnNbpwHfbIH4+8M2c1vnAN3Na5wPfzGmdD2yzDTyb07rZBvEXBp7Nad1sg/gLA8/mtG62QfyFgWdzWjfbIP7CwLM5rZttEH9h4Nmc1s02iL8w8GxO62YbxF8YeDandbMN4i8MPJvTutkG8RcGns1p3WyD+AsDz+a0brZB/IWBZ3NaN9sg/sLAszmtm20Qf2Hg2ZzWzTaIvzDwk3N42f+W3pacXQeWeOa5xeMHW0zp9y/+6s3qcc35pxfv1Feo96e+heOa69KiXqF+PfVny6Ch/lepB6g7UI9Qd6CeoO5A3aDuQB2/7kEdv+5BfYO6A/UCdQfqZFMH6ivZ1IM62bQ/9RT3Cb/+M7eok009qJNNPagb1B2ok009qJNNPaiTTT2ok009qJNNHahvZFMP6mTTv0H9+D5MstiiTjb1oE429aBuUHegTjb1oE429aBONv0L1JcH9bi2qJNNPaiTTR2oF7KpB3WyqQd1sqkHdbKpB3WDugN1sqkHdbKpB3WyqQd1sqkHdbKpA/VKNvWgTjb1oE429aBONvWgblB3oE429aBONvWgTjb1oE429aBONr2eui1kUw/qZFMP6mRTD+pkUw/qBnUH6mRTD+pkUw/qZFMP6mRTD+pkUwfqgWzqQZ1s6kGdbOpBnWzqQd2g7kCdbOpBnWzqQZ1s6kGdlORAPZKSPKiTkjyok5I8qJOSPKjjHLtTjzXvL471H2K/Usc5elDnroYHdfy6A/WEX/egjl/3oI5f96COX/egblB3oM5dDQ/qZFMP6mRTD+pk079Ave4/OC2htKiTTR2oG9nUgzrZ1IM62dSDOtnUg7pBvT/1shzOsaYWdbKpB3WyqQd1sqkHdbKpB3WyqQP1TDb1oE429aBONvWgTjb1oG5Qd6BONvWgTjb1oE429aBONvWgTjZ1oL6STT2ok009qJNNPaiTTT2oG9QdqJNNPaiTTT2ok009qJNNPaiTTR2ob2RTD+pkUw/qZFMP6mRTD+oGdQfqZFMP6mRTD+pkUw/qZFMP6mRTB+qFbOpBnWzqQZ1s6kGdbOpB3aDuQJ1s6kGdbOpBnWzqQZ1s6kGdbOpAveLX+1Mv237NsdSTF4do9uPFX//ZWmtSMffyEhkSqUtEbJCXiIwhLxGBRF4i0ou8REQdcYnywj07eYm4wScvEe2Ct0RbPiQqTYloF+QlMiRSl4h2QV4i2gV5iWgX5CWiXfCWaE2HRFtsSUS7oC5RoF2Ql4h2QV4i2gV5iWgX5CUyJFKXiHZBXiLaBXmJaBfkJaJdkJeIdkFdoki7IC8R7YK8RLQL8hLRLshLZEikLhHtgrxEtAvyEtEuyEtEuyAvEe2CukSJdkFeItoFeYloF+Qlol2Ql8iQSF0i2gV5iWgX5CWiXZCXiHZBXiLaBXWJjHZBXiLaBXmJaBfkJaJdkJfIkEhdItoFeYloF+QlIhf5SlTL/tpa1oZAmVQkLhCZSFwgEpG4QOQhcYEMgbQFIguJC0QSEheIu6ziAnGPVVwgmgRtgVaaBHGBaBLEBaJJEBeIJkFcIEMgbYFoEsQFoknwFSg8UIclWEsiugR5iWgT5CWiT1CXaKNRkJeITkFeIloFeYnoFeQlMiRSl4huQV4i2gV5iWgXvCUK5ZAohZZEtAvyEtEuqEtUaBfkJaJdkJeIdkFeItoFIdPdlsiQSDwXFdoFeYloF+Qlol2Ql4h2QV4i2gV1iSrtgrxEtAvyEtEuyEtEuyAvkSGRukS0C/IS0S7IS0S7IC8R7YK8RLQL4hKtC+2CvES0C/IS0S7IS0S7IC+RIZG6RLQL8hLRLshLRLsgLxHtgrxEtAvqEgXaBXmJaBfkJaJdkJeIdkFeIkMidYloF+Qlol2Ql4h2QV4i2gV5iWgX1CWKtAvyEtEuyEtEuyAvEe2CvESGROoS0S7IS0S7IC8R7YK8RLQL8hLRLqhLlMhFvhKVsLMrobYEIhU5C5T2H1zy1hLIEEhbIBKRuEA4OXGB8HHaAhn3iMQF4g6RuEDkIHGByEHiAhkCaQtEDhIXiPtC4gJxV0hcIJoEcYFoErQFyjQJzgIdF1FK635QJqiKC0RQFRfIEEhbIIKquEAEVXGBCKriAhFUxQUiqGoLtBJUxQXilre4QDQJ4gLRJIgLZAikLRBNgrhANAniAtEkiAtEkyAuEE2CtkAbTYK4QDQJ4gLRJIgLRJMgLpAhkLZANAniAtEkiAtEkyAuEE2CuEA0CdoCFZoEcYFoEsQFokkQF4gmQVwgQyBtgWgSxAWiSRAXiCZBXCCaBHGBaBK0Bao0CeIC0SSIC0STIC6QIZC2QARVcYEIquICEVTFBSKoSgu0LdjsVwT6eukOJG1baIHEDncCiSt6CWRZbL+MEmILJO6lE0hcRieQuIFOIKmX+4AM1MCdQOIjX7M/dXmAPPHuIa7px4tD3JrUMZ0e1PmKlgd1g7oDddKYB3Wimwd1cp4HdUKhB3USpAP1SNz0oE429aBONvWgTjb1oG5Qd6BONvWgTjb1oE429aBONvWgTjZ1oJ7Iph7UyaYe1MmmHtTJph7UDeoO1MmmHtTJph7UyaYe1MmmHtTJpv2pp1p26hZbfxNiZFMP6mTTv0B9swf11ieMGdS7U19tv+av/0wt6vh1D+r4dQ/q+HUP6vj1v0C97FcRtrC0qOPXHahn/LoHdfy6B3XuJf0F6o8eZgutbJrx6/2pl3X/waGUtUUdD9OdegwHvRiCtajjYRyor3gYD+p4GA/qeBgP6nwfxoO6Qd2BOn7dgzr9ugd1+nUP6mRTD+pkUwfqG9nUgzrZ1IM62dSDOtnUg7pB3YE62dSDOtnUgzrZ1IM62dSDOtnUgXohm3pQJ5t6UCebelAnm3pQN6g7UCebelAnm3pQJ5t6UCeb/gXq2Q7q3+k9qJNNHahXsqkHdbKpB3WyqQd1sqkHdYO6A3WyqQd1sqkHdbKpB3WyqQd1sun11MtCNvWgTjb1oG5Q7039dGdGWfDrHtTx6x7U8ev9qZfjKkIxa1HHr3tQx687UA/4dQ/q+HUP6txL8qDOvSQP6gZ1B+pkUw/qZFMP6mRTD+pkUw/qZFMH6pFs6kGdbOpBnWzqQZ1s6kHdoO5AnWzqQZ1s6kGdbOpBnWzqQZ1s6kA9kU09qJNNPaiTTT2ok009qBvUHaiTTT2ok03/AvWTpw+WRDb1oE429aBONnWgbmRTD+pkUw/qZFMP6mRTD+oGdQfqZFMP6mRTD+pkUw/qZFMP6mRTB+qZbOpBnWzqQZ1s6kEdv96fej52IYW85ZOfbMt+FclSakmEuZeXiCQgLxGxQV4iMoa6RCuBRF4i0ou8REQdeYm4ZycvkSGRukS0C/IS0S7IS0S7IC8R7YK6RBum21eiEnZ2JdSWQFhucYHo53wFqmWfrzZv5hXaOXGB+IjzFSg8UIel9WjsUgyJ1CWiVZCXiFZBXiJaBXmJaBXkJSITqUtUSUXyEvGdBXmJqE/lJaJdkJfIkEhdItoFb4nW48UhtG7lVdoFeYloF+Qlol2Ql4h2QVyiutAuyEtEuyAvEe2CvES0C/ISGRKpS0S7IC8R7YK8RLQL8hLRLshLRLugLlGgXZCXiHZBXiLaBXmJaBfkJTIkUpeIdkFeItoFZ4liOF4cQ25JRLsgLxHtgrxEtAvqEkXaBXmJaBfkJaJdkJeIdkFeIkMidYmIrvISEV3lJSK6yktEdFWXKBFd5SUiuspLRHSVl4joKi+RIZG6RNwYl5eIdkFeItoFeYloF+Qlol1Ql8hoF+Qlol2Ql4h2QV4iTLe3RPaQyEpLIky3ukQZu+At0ZoOibbYkgi7IC8RdkFeIm5GyEtkSKQuETcj5CUiF8lLRC6Sl4ibEfIScTNCXaKVdkFeItoFeYloF+Qlol2Ql8iQ6EKJduoUBn+Beqk79XVpvtfpADyoE+s9qJPUPagTvh2ob+RpD+pEZA/qpF4P6gRZD+oGdQfqZFMP6mRTD+pkUw/qZFMP6mRTB+qFbOpBnWzqQZ1s6kGdbOpB3aDuQJ1s6kGdbOpBnWzqQZ1s6kGdbOpAvZJNPaiTTT2ok009qJNNPagb1B2ok037U18tHtQttaiTTT2ok009qJNNPaiTTS+nXpeFbOpBnWzqQZ1s6kGdbOpB3aDuQJ1s6kGdbOpBnWzqQZ2U1J16DMcega//zA3qgZTkQZ2U5EGdlORBnZTkQd2g7kCdlORBnZTkQZ2U5EGdO3ge1MmmDtQj2dSDOtnUgzrZ1IM62dSDukHdgTrZ1IM62dSDOtnUgzrZ1IM62dSBeiKbelAnm3pQJ5t6UDeof0Z9B0nw6QSSLNMJJPGkE0gSRx+QhrHqfsT/4XO27HhxtNKSCBcmLxG3E+QlMiRSlwi/Li8RSUBeIjKGvESkF3mJuLmiLlHmToy8RLQL3hJt+ZCoNCWiXZCXiHZBXiJDInWJaBfkJaJdkJeIdsFbojUdEm2xJRHtgrxEtAvqEq20C/IS0S7IS0S7IC8R7YK8RIZE6hLRLshLRLsgLxHtgrxEtAvyEtEuqEu00S7IS0S7IC8R7YK8RLQL8hIZEqlLRLsgLxHtgrxEtAvyEtEuyEtEu6AuUaFdkJeIdkFeItoFeYloF+QlMiRSl4h2QV4i2gV5iWgX5CWiXZCXiHZBXaJKuyAvEe2CvES0C/IS0S7IS2RIpC4R7YK8ROQiX4lq2eerZW0JRCqSFigsZCJxgUhE4gKRh8QFIg2JC2QIpC0QSUhcIO6yigvEPVZxgWgSxAWiSdAWKNAkiAtEkyAuEE2CuEA0CeICGQJpC0ST4CtQeKD+urVgLYnoEuQlok2Ql4g+QV4iGgV1iSKdgrxEtAryEtEryEtEsyAvkSGRukS0C/IS0S54SxTKIVEKLYloF+Qlol2Ql4h2QV2iRLsgLxHtgrxEtAtCprstEe2Cei5KhkTqEtEuyEtEuyAvEe2CvES0C/IS0S6oS2S0C/IS0S7IS0S7IC8R7YK8RIZE6hLRLshLRLsgLxHtgrxEtAvyEtEuqEuUaRfkJaJdkJeIdkFeItoFeYkMidQlol2Ql4h2QV4i2gV5iWgX5CWiXVCXaKVdkJeIdkFeItoFeYloF+QlMiRSl4h2QV4i2gV5iWgX5CWiXZCXiHZBXaKNdkFeItoFeYloF+Qlol2Ql8iQSF0i2gV5iWgX5CWiXZCXiHZBXaJCLvKVqISdXQm1JRCpyFmgtF9xyVtLIDKRuECGQNoC4eTEBcLHiQvEPSJtgSp3iMQFIgeJC0QOEheIHCQukCGQtkDcFxIXiLtC4gLRJIgLRJMgLhBNgrNAx0WU0rgfFBeCqrhABFVxgQiq4gIZAmkLRFAVF4igKi4QQVVcIIKquEAEVW2BAre8xQWiSRAXiCZBXCCaBHGBDIG0BaJJEBeIJkFcIJoEcYFoEsQFoknQFijSJIgLRJMgLhBNgrhANAniAhkCaQtEkyAuEE2CuEA0CeIC0SSIC0SToC1QokkQF4gmQVwgmgRxgWgSxAUyBNIWiCZBXCCaBHGBaBLEBaJJEBeIJkFbIKNJEBeIJkFcIIKquECGQNoCEVTFBSKoigtEUNUWKMvb7AN5CuXs1cFqPdAsP8u5DyxvW3sPLH9DqffA8r6398A228DyvuyPBs7HE6q+/rM0B5b3Ob0HlvcNvQeWL4x7DyxfwHYeeL2X0/r6gcfAqfkpvd7Lab0w8L2c1gsD38tpvTCwzTbwzZzW+cA3c1rnA9/MaZ0PfDOndT7wzZzW6cDbbE5rm81pbbM5rW02p7XZbAPfrdMKjzxcmwPfrdM6HfhundbpwHfrtE4HvlundTZwuZnTOh/4Zk7rfOCbOa3zgW/mtM4HttkGns1pldmcVpnNaZXZnFaZzWnV2ZxWnc1p1dmclv7z7HsPbLMNPJvT0n9+ee+BZ3Na+s/X7j3wZE4rLZM5raT/wOveA0/mtJL+A5l7D2yzDTyZ00r6D+DtPfBkTivpPyC298CzOS39B5j2Hng2p6X/gM3eA8/mtPQfX/dnf3to+59Lf/3n1hz4XufwCwPf6xx+YeB7ncPnA+s//qv3wDfbAbBux8Df9kF8H/hmOwDOB77ZDoDzgW22ge/VeLww8M2c1vnAN3Na5wPfzGmdD3wzp3U6sP7jUXoPPJvT0n98R++BZ3Na+o+X6D3wbE5L//EHvQeezWnpr+fvPfBsTkt/fXzvgWdzWjab09Lf5957YLvXwLkcA6/WHPhmTut84Js5rfOBb+a0zge+mdM6H/hmTut04LttED8f+GZO63zgmzmt84Fv5rTOB7bZBp7Nad1sg/gLA8/mtG62QfyFgWdzWjfbIP7CwLM5rZttEH9h4Nmc1s02iL8w8GxO62YbxF8YeDandbMN4i8MPJvTutkG8RcGns1p3WyD+AsDz+a0brZB/IWBZ3NaN9sg/sLAszmtm20Qf2Hg2ZzWzTaIvzDwbE7rZhvEXxi4eQ6nr/9x77+m1uA6sMQzzy0eP9hiSr9/cYpWj2vOP714p75CvT/1LRzXXJcW9Qr166m3l0FD/S9TD1B3oB6h7kA9Qd2BukHdgTp+3YM6ft2D+gZ1B+oF6g7UyabXU7eFbOpBnWzan3qK+4Rf/5lb1MmmHtTJph7UDeoO1MmmHtTJph7UyaYe1MmmHtTJpg7UA9nUgzrZ9G9QP74Pkyy2qJNNPaiTTT2oG9QdqJNNPaiTTT2ok03/AvXlQT2uLepkUw/qZFMH6pFs6kGdbOpBnWzqQZ1s6kHdoO5AnWzqQZ1s6kGdbOpBnWzqQZ1s6kA9kU09qJNNPaiTTT2ok009qBvUHaiTTT2ok009qJNNPaiTTT2ok00dqBvZ1IM62dSDOtnUgzrZ1IO6Qd2BOtnUgzrZ1IM62dSDOtnUgzrZ1IF6Jpt6UCebelAnm3pQJ5t6UDeoO1Anm3pQJ5t6UCebelAnJTlQX0lJHtRJSR7USUke1ElJHtRxjt2px5r3F8e6hhZ1nKMHde5qeFDHrztQ3/DrHtTx6x7U8ese1PHrHtQN6g7UuavhQZ1s6kGdbOpBnWz6F6jX/QenJZQWdbKpA/VCNvWgTjb1oE429aBONvWgblDvT70sh3OsqUWdbOpBnWzqQZ1s6kGdbOpBnWzqQL2STT2ok009qJNNPaiTTT2oG9QdqJNNPaiTTT2ok009qJNNPaiTTa+nnheyqQd1sqkHdbKpB3WyqQd1g7oDdbKpB3WyqQd1sqkHdbKpB3WyqQP1QDb1oE429aBONvWgTjb1oG5Qd6BONvWgTjb1oE429aBONvWgTjZ1oB7Jph7UyaYe1MmmHtTJph7UDeoO1MmmHtTJph7UyaYe1MmmHtTJpg7UE369P/Wy7dccSz15cYhmP1789Z+lJRHmXl4iQyJ1iYgN8hKRMeQlIpDIS0R6kZeIqKMukXHPTl4ibvDJS0S74C3Rlg+JSlMi2gV5iQyJ1CWiXZCXiHZBXiLaBXmJaBe8JVrTIdEWWxLRLqhLlGkX5CWiXZCXiHZBXiLaBXmJDInUJaJdkJeIdkFeItoFeYloF+Qlol1Ql2ilXZCXiHZBXiLaBXmJaBfkJTIkUpeIdkFeItoFeYloF+Qlol2Ql4h2QV2ijXZBXiLaBXmJaBfkJaJdkJfIkEhdItoFeYloF+Qlol2Ql4h2QV4i2gV1iQrtgrxEtAvyEtEuyEtEuyAvkSGRukS0C/IS0S7IS0Qu8pWolv21tawNgSqpSFwgMpG4QCQicYHIQ+ICGQJpC0QWEheIJCQuEHdZxQXiHqu4QDQJ0gKtC02CuEA0CeIC0SSIC0STIC6QIZC2QDQJ4gLRJPgKFJYl/HhxWIK1JKJLkJeINkFeIvoEdYkCjYK8RHQK8hLRKshLRK8gL5EhkbpEdAvyEtEuyEtEu+AtUSiHRCm0JKJdkJeIdkFdoki7IC8R7YK8RLQL8hLRLgiZ7rZEhkTiuSjSLshLRLsgLxHtgrxEtAvyEtEuqEuUaBfkJaJdkJeIdkFeItoFeYkMidQlol2Ql4h2QV4i2gV5iWgX5CWiXVCXyGgX5CWiXZCXiHZBXiLaBXmJDInUJaJdkJeIdkFeItoFeYloF+Qlol1QlyjTLshLRLsgLxHtgrxEtAvyEhkSqUtEuyAvEe2CvES0C/IS0S7IS0S7oC7RSrsgLxHtgrxEtAvyEtEuyEtkSKQuEe2CvES0C/IS0S7IS0S7IC8R7YK6RBu5yFeiEnZ2JdSWQKQiZ4EO0iVvLYEMgbQFIhGJC4STExcIH6ctUOEekbhA3CESF4gcJC4QOUhcIEMgbYHIQeICcV9IXCDuCokLRJMgLhBNgrZAlSbBWaDjIkpp3Q+qBFVxgQiq4gIZAmkLRFAVF4igKi4QQVVcIIKquEAEVWmBtoWgKi4Qt7zFBaJJEBeIJkFcIEMgbYFoEsQFokkQF4gmQVwgmgRxgWgStAUKNAniAtEkiAtEkyAuEE2CuECGQNoC0SSIC0STIC4QTYK4QDQJ4gLRJGgLFGkSxAWiSRAXiCZBXCCaBHGBDIG0BaJJEBeIJkFcIJoEcYFoEsQFoknQFijRJIgLRJMgLhBNgrhAhkDaAhFUxQUiqIoLRFAVF4igqi2QYbNfEejrpftzftK2hRZI7HAnkLiil0CWxfbLKCG2QOJeOoHEZXQCiRvoBJJ6uQ/ITA3cCSQ+8jX7U5cHyBPvHuKafrw4xK1JHdPpQZ2vaHlQN6g7UCeNeVAnunlQJ+d5UCcUelAnQTpQX4mbHtTJph7UyaYe1MmmHtQN6g7UyaYe1MmmHtTJph7UyaYe1MmmDtQ3sqkHdbKpB3WyqQd1sqkHdYO6A3WyqQd1sqkHdbKpB3WyqQd1sml/6qmWnbrF1t+EFLKpB3Wy6V+gvtmDeusTphjUu1Nfbb/mr/9MLer4dQ/q+HUP6vh1D+r49b9AvexXEbawtKjj1x2oV/y6B3X8ugd17iX9BeqPHmYLrWxa8ev9qZd1/8GhlLVFHQ/TnXoMy74RJYZgLep4mOuplwUP40EdD+NBHQ/jQZ3vw3hQN6g7UMeve1CnX/egTr/uQZ1s6kGdbOpAPZBNPaiTTT2ok009qJNNPagb1B2ok009qJNNPaiTTT2ok009qJNNHahHsqkHdbKpB3WyqQd1sqkHdYO6A3WyqQd1sqkHdbKpB3Wy6V+gnu2gnnOLOtnUgXoim3pQJ5t6UCebelAnm3pQN6g7UCebelAnm3pQJ5t6UCebelAnmzpQN7KpB3WyqQd1g/rlOzOK4dc9qOPXPajj1/tTL8dVhK+P8BZ1/LoHdfy6A/WMX/egjl/3oM69JA/q3EvyoG5Qd6BONvWgTjb1oE429aBONvWgTjZ1oL6STT2ok009qJNNPaiTTT2oG9QdqJNNPaiTTT2ok009qJNNPaiTTR2ob2RTD+pkUw/qZFMP6mRTD+oGdQfqZFMP6mTTv0D95OmDZSObelAnm3pQJ5s6UC9kUw/qZFMP6mRTD+pkUw/qBnUH6mRTD+pkUw/qZFMP6mRTD+pkUwfqlWzqQZ1s6kGdbOpBHb/en3o+diGFvOWTn2zLfhXJUmpJhLmXl4gkIC8RsUFeIjKGuER1IZDIS0R6kZeIqCMvEffs5CUyJFKXiHZBXiLaBXmJaBfkJaJdUJcoYLp9JSphZ1dCbQmE5RYXiH7OV6Ba9vlq62ZejbRz4gLxEecrUFiOR2OHpfVo7BoNidQlolWQl4hWQV4iWgV5iWgV5CUiE6lLlEhF8hLxnQV5iahP5SWiXZCXyJBIXSLaBW+J1uPFIbRu5SXaBXmJaBfkJaJdkJeIdkFdIqNdkJeIdkFeItoFeYloF+QlMiRSl4h2QV4i2gV5iWgX5CWiXZCXiHZBXaJMuyAvEe2CvES0C/IS0S7IS2RIpC4R7YK8RLQLzhLFcLw4htySiHZBXiLaBXmJaBfUJVppF+Qlol2Ql4h2QV4i2gV5iQyJ1CUiuspLRHSVl4joKi8R0VVdoo3oKi8R0VVeIqKrvEREV3mJDInUJeLGuLxEtAvyEtEuyEtEuyAvEe2CukSFdkFeItoFeYloF+QlwnR7S2QPiay0JMJ0q0tUsQveEq3pkGiLLYmwC/ISYRfkJeJmhLxEhkTqEnEzQl4icpG8ROQieYm4GSEvETcjtCUKy9f/h0byGtEv6GtEwaCvEQ2DvkaGRhdqdGCnNvgL2Evdsa9L+91OFeCCnXjvgp3I7oKdGO6BPZCsXbATll2wk39dsBNpXbAb2D2wk1JdsJNSXbCTUl2wk1JdsJNSPbBHUqoLdlKqC3ZSqgt2UqoLdgO7B3ZSqgt2UqoLdlKqC3ZSqgt2UqoH9kRKdcFOSnXBTkp1wU5KdcFuYPfATkrtj321eGC31MROSnXBTkp1wU5KdcFOSvXAbqRUF+ykVBfspFQX7KRUF+wGdg/spFQX7KRUF+ykVBfsxKXu2GM4dg58/Wdz50AmLrlgJy65YCcuuWAnLrlgN7B7YCcuuWAnLrlgJy65YOemngt2UqoH9pWU6oKdlOqCnZTqgp2U6oLdwO6BnZTqgp2U6oKdlOqCnZTqgp2U6oF9I6W6YCelumAnpbpgN7B/hv0gSQLqRZJQ04skOaUXSaJHJ5IFf9X9oP/DJ3bZ8eJopakRZkxfI+4v6GtkaCSvEb5dXyMSgb5GZA19jUgx+hpxt0Veo8qtGX2N6Bm8NdryoVFpa0TPoK8RPYO+RoZG8hrRM+hrRM+grxE9g7dGazo02pqLiCs9g75G9AzqGn2phEbyGtEz6GtEz6CvET2DvkaGRvIa0TPoa0TPoK8RPYO+RvQM+hrRM8hrFOgZ9DWiZ9DXiJ5BXyN6Bn2NDI3kNaJn0NeInkFfI3oGfY3oGfQ1omeQ1yjSM+hrRM+grxE9g75G9Az6GhkayWtEz6CvET2Dvkb0DPoa0TPoa0TPIK9RomfQ14ieQV8jegZ9jegZ9DUyNJLXiJ5BXyPyka9Gtezz1bI2FSIdiStkZCN1hUhG6gqRi9QVIhWpK2QoJK4QiUhdIe67qivEXVd1hegU1BWiUxBXKNMpqCtEp6CuEJ2CukJ0CuoKGQqJK0Sn4KtQWJawv/jLWjc1olXQ14heQV8jmgV9jegW5DVaaRf0NaJf0NeIhkFfIzoGfY0MjeQ1omfQ14iewVujUA6NUmhqRM+grxE9g75G9AzyGm30DPoa0TPoa0TPIOS9n2hEzyCfjzZDI3mN6Bn0NaJn0NeInkFfI3oGfY3oGeQ1KvQM+hrRM+hrRM+grxE9g75GhkbyGtEz6GtEz6CvET2Dvkb0DPoa0TPIa1TpGfQ1omfQ14ieQV8jegZ9jQyN5DWiZ9DXiJ5BXyN6Bn2N6Bn0NaJnUNcoLvQM+hrRM+hrRM+grxE9g75GhkbyGtEz6GtEz6CvET2Dvkb0DPoa0TPIaxToGfQ1omfQ14ieQV8jegZ9jQyN5DWiZ9DXiJ5BXyN6Bn2N6BnkNYrkI1+NStjZlVCbCpGOnBU6SJe8NRUiG6krZCgkrhB+Tl0h3Jy6QtwzElcoccdIXSHykLpC5CF1hchD6goZCokrxH0idYW4S6SuEJ2CukJ0CuoK0Sk4K3RcRCnN+0NGYlVXiMSqrhCJVV0hQyFxhUis6gqRWNUVIrGqK0RiVVeIxCquUOYuuLpCdAr/b3t3uOu6VYRh+JZie5I43E1B/KiECoKCxN2TCuLTIg9rtvpSWWvef7s66Vbm8Wn9fSuK5+pXyDOFq18hzxSufoXCK3TxK+SZwtWvkGcKV79Cnilc/Qp5pnD1K+SZwsWv0MMzhatfIc8Urn6FPFO4+hXyTOHqVyi8Qhe/Qp4pXP0KeaZw9SvkmcLVr5BnCle/Qp4pXPwKPT1TuPoV8kzh6lfIM4WrXyHPFK5+hcIrdPEr5JnC1a+QZwpXv0KeKVz9CnmmcPUr5JnCxa/Q7pnC1a+QZwpXv0I21qtfofAKXfwK2VivfoVsrFe/QjbWi1+h1+XT9mG+Lfvo1Uu8XofN7ZfX85j48ukVn/jynzDhE18+/+ITR7uJL5/PvjTx/dhy9f5xP5/48nkHn/jy+QGf+PInyPjElz+RhSfebnNlrvcvPCbebucTz5W5KhPPlbkqE8+VuSoTR7uJJ8tchYkny1yFiSfLXIWJJ8tchYkny1zjiZd2mWtpl7mWdplraZe5lmg38WznXMu3fvw6n3i2c67xxLOdc40nnu2cazzxbOdcw4nXyTJXYeLJMldh4skyV2HiyTJXYeJoN3G7zLW2y1xru8y1tstca7vMtbXLXFu7zLW1y1xbu8x1/f3z+MTtMtf196PjE7fLXNff341P3C5zRbvMdf2N2vjE7TLX9Tc+4xNHu4nbZa7rb/jFJ26Xua6/gRafuF3muv6GVHzidpnr+hs88YnbZa7rb8f72vcW4/N96/ePz/OJ57ofVyae635cmXiu+3Fh4utvF8Mnnuw5Ao/nMfHPnirxi4kne45AYeLJniNQmDjaTTzXGUhl4skyV2HiyTJXYeLJMldh4sky13ji629fwSdul7muvx0En7hd5rr+9gp84naZ6/rbFfCJ22Wu6z/9H5+4Xea6/tPp8YnbZa69Xea6/vPi8Yljronv+zHxI84nnixzFSaeLHMVJp4scxUmnixzFSaeLHONJ57tGeWFiSfLXIWJJ8tchYkny1yFiaPdxO0y12TPKK9M3C5zTfaM8srE3TJXTPaM8srE3TJXTPaM8srE3TJX3KLdxN0yV0z2jPLKxN0yV0z2jPLKxO0y12TPKK9M3C5zTfaM8srE7TLXZM8or0zcLnNN9ozyysTtMtdkzyivTNwuc032jPLKxO0y12TPKK9MfH4/jtdnhu0ej8HES/xsk+X6beL1dTrx/2s3+vvv6+cXx7pt//vF2xqfvcHbev/Fiw+aR1ea53LQ/PQ+T2he0iQ0yWOVpXnTLNJkNKs0Gc0mTUYT0mQ0bXPNmMZck9I8pclodmkyGtNwRhOm4ZSmaxre1s+Jx/vH+ylN1zRcoOmahgs0IU1G0zUNF2i6puECTdc0XKDpmoYLNF3T8Jjm3jUNF2j6puHjc6gt1lOavml4SNM3DQ9pQpqMpm8aHtL0TcNDmrZp+PaNZn2c0rRNw2Oatml4SPNom4bHNG3T8JimbRoe07RNw2OakCajaZuGxzRt0/CYxjSc0piGUxrTcEbzNA2nNKbhlMY0nNKYhlOakCajMQ2nNKbhlMY0nNKYhlMa03BGs5uGUxrTcEpjGk5pTMMpTUiT0ZiGUxrTcEpjGk5pTMMpjWk4o3mZhlMa03BKYxpOaUzDKU1Ik9GYhlMa03BKYxpOaYx8Cc39ZuRLaYx8KY2RL6Ux8qU0TW/e6+v+efH6eiynNE1v3hWapkdZFZqmuaZAszTNNRWaprmmQtM011RomuaaCk1Ik9E0Pcqq0JiGUxrTcErTNg2/Pr94uy37KU3bNDykWdum4TFN2zQ8pmmbhsc0bdPwmCa60uy34+b92k5p2qbhMU3bNDymaZuGxzRt0/CYpm0aHtJ0XZ1VoWmbhsc0bdPwmKZtGh7ThDQZjWk4pTENpzSm4ZTGNJzSmIYzmq6rsyo0puGUxjSc0piGU5qQJqMxDac0puGUxjSc0piGUxrTcEbTdXVWhcY0nNKYhlMa03BKE9JkNKbhlMY0nNKYhlMa03BKYxrOaLquzqrQmIZTGtNwSmMaTmlCmozGNJzSmIZTGtNwSmMaTmlMwxlN1yVI6/5cPzT7a/DiZY34DLjG6TeEum5Mwh1DR8Sxa7yiHbtmMdqxa3CjHbumPNqxaySEHbsum8Idux690o72mYrj8xhw3c8d7TOMY+iIONpnGEf7DONon2Ec7TMVx8d2OD7XU0f7DOLYdV0Y7mifYRztM4yjfYZxDB0RR/sM42ifYRztM4yjfYZxtM8Qjo+uu/BwR/sM42ifYRztM4xj6Ig42mcYR/sM42ifYRztM4yjfQZxbLsDk3a0zzCO9hnG0T7DOIaOiKN9hnG0zzCO9hnG0T7DONpnEMe2W0xpR/sM42ifYRztM4xj6Ig42mcYR/sM42h+HDu+9s9rX/vjTLHt1k9W0exIKJocCUVzI6EYKgKKZkZC0cRIKHr+TSh6+k0o2l0AxbY7WllFuwuhaHchFO0uhGKoCCjaXQhFu0vhtPt2Wz4D3pY4dbS9MI72F8bRBoM4tt2sSzvaYhhHewzjaJNhHENHxNE2wzjaZxhH+0zFcdkPx205dbTPMI72GcSx7W5k2tE+wzjaZxhH+8wXc0/iGDoS+bHt8mfa0T7DONpnGEf7DONon0Ecn/YZxtE+wzjaZxhH+wzjGDoijvYZxtE+wzjaZxhH+wzjaJ9BHN22DjnaZxhH+wzjaJ9hHENHxNE+wzjaZxhH+wzjaJ9hHO0ziKPb1iFH+wzjaJ9hHO0zjGPoiDjaZxhH+wzjaJ9hHO0zjKN9hnB8um0dcrTPMI72GcbRPsM4ho6Io32GcbTPMI72GcbRPsM42mcQR7dbFxz3Y759eZ0qmh4LitvnF+/356liqAgomhwJRe/ThKJ3aUDRDcKIoieOhKJ5kVA0LxKKoSKgaF4kFD1nJBQ9ZSQU7S6Eot0FUHR/dUXxeBP7fnq+6OZlRNHUTSiGioCiqZtQNHUTiqZuQtHUTSiaugFFNy8jin5iQCjaXQhFuwuhGCoCinYXQtHuQijaXQhFuwuhaHcBFN24jCjaXQhFuwuhaHchFENFQNHuQijaXQhFuwuhaHchFO0ugKLblRFFuwuhaHchFO0uhGKoCCjaXQhFuwuhaHchFO0uhKLdBVB0kzKiaHchFO0uhGKoCCiauglFUzehaOomFE3dgOJEG1bfL/08J3F7J7jTaedJJJVp57nnbfstPm96X9bTaee5N1WmneceUpl2nv/XV6ad5ySkMO1EuwUr0050vy1MO9H9tjDtPJ8yVqaNVtO2ylIT7Y+rTNsqS020i2087T7Rpq/KtJ3SxT7R1qzKtJ3SxfsFrabtlC72ibY5VabtlC72iTYjVabtdFKzLxNlqfex07dpBx+iLOtj+7zn9XlOM9PHKDDNTJ+5wDQTRTqaJqTJaCYKizTNRMmSppkohtI0E2VWmmaigAvTTLTPC6cxDac0puGUxjSc0oQ0GY1pOKUxDac0puGUxjSc0piGM5qJNkThNKbhlMY0nNKYhlOakCajMQ2nNKbhlMY0nNJ0TcPba/+851iXU5quaXhMM9Hmpi/SPOMbzel/UBOtwPkazSM+X9t9/7id0oQ0GU3XXFOg6ZprCjRdc81j/7yL5bncTmm65poCTddcM6aZaKsLTtP1lO/xrUM9l9M0PNHOi6/R7I/PL172/XFK0/QOtS63z9NL1mWJU5qmd6gKTdM7VIFmomf34zRN71AVmqafQ1Vomp7XVGhCmoym6XlNhabpeU2FxjSc0piGUxrTcEYz0dPgcRrTcEpjGk5pTMMpTUiT0ZiGUxrTcEpjGk5pTMMpjWk4o9lNwymNaTilMQ2nNKbhlCakyWhMwymNaTilaZuG73HQ3O+nNG3T8JimbRoe0sy0d4OmaZuGxzRt0/CYpm0aHtOENBlN2zQ8pmmbhsc0puGUxjSc0piGE5rXTHtiaJq239gdfbPldQtpMpq239gd03T9xu5+vItljzil6fqN3QJN12/sFmi6fmN3TNN2Z0uBpus3dgs0XZ/LV6DpmoYLNCFNRtM1DRdoTMMpjWk4pTENpzSm4Yym7c6WAo1pOKUxDac0puGUJqTJaEzDKY1pOKUxDac0puGUxjSc0bTd2VKgMQ2nNKbhlMY0nNKENBlN2zQ8ejzqq+3OlgJN2zQ8pmmbhsc0bdPwkKbtzpYCTds0PKZpm4bHNG3T8JgmpMloTMMpjWk4pTENpzSm4ZTGNJzRtN30U6AxDac00ZTmfnyLbrk/74PfHLfPu9hi204du4Yg2rFrYqIdu8Yr2rFrFqMduwY32LHrtizcsWskpB27nqbSjl2PXmnH0BFxtM8wjvYZxtE+gzh2XaL0Jcf9mG9fXqeKph5C0W49Vnzt6+cdn5/gdl0fwip23RnxJcXldjz0fbmdPvT91XXBBO4YOiKO9hjG0R7DONpjGEezI+NoekQcu+7mwB09n2Ac7TOMo32GcQwdC46P48XLcnp+23X5CO5on2Ec7TOMo32GcbTPAI7vG7p9hnG0zzCO9hnG0T7DOIaOiKN9hnG0zzCO9hnG0T7DONpnEMe2W5VoR/sM42ifYRztM4xj6Ig42mcKjutyvHhd7qeO9hnG0T7DONpnGEf7DOLYdi8W7WifYRztM4yjfYZxNIczjuZwxtEczjiawxlHczji2HYjF+1oDmcczeGMozmccQwdEUf7DONon2Ec7TOMo32GcbTPII5td6rRjvYZxtHcU3GMb46xnzqaexhH7zMVx8d2OD7XM8e224poR+8zjKPnZoyj52aMY+iIOJofGUfzI+PouRnj6LkZ42ifQRzdywU52mcYR/sM42if+W/Hgya60uyvz3t+3M7/1rRtHWOatkViTNO2G4xp2sb9MU3bBD+kebYN5WOatjl7TNM2Oo9p2qbhMU1Ik9GYhlMa03BKYxpOaUzDKY1pOKPZTcMpjWk4pTENpzSm4ZQmpMloTMMpjWk4pTENpzSm4ZTGNJzR9F3YOaYxDac0puGUxjSc0kRTmkesB01spzRd03CBpmsaLtB0TcMFmq5puEDTNQ0PaZa26x4LNF3TcIGmaxou0HRNwwWakCajMQ2nNKbhlKZp5FuX4zsK7x/vpzRNI1+BputGvApN08hXoWka+So0TSNfhSakyWiaRr4KTdPIV6FpegBaoTENpzSm4Yym6z61Co1pOKUxDac0puGUJqTJaEzDKY1pOKUxDac0puGUxjSc0XTdalahMQ2nNC0i3zFttJq2RTA7pm2RtY5pW8Snz7RuuPkdsQljccMN5OiTOhlHn9TJOIaOiKObBxhHNw8wjm4eYBzdPMA4unkAcXSTWsnxeQy47ueO9hnG0T7DONpnGMfQEXG0zzCO9hliM8viJjXI0T7DONpnEEc3qUGO9hnG0T7DONpnGMfQEXG0zzCO9hnG0T7DONpnGEf7DOLYdwkd7GifYRztM4yjfYZxDB0RR/sM42ifYRztM4yjfYZxtM8gjn3XCMKO9hnG0T7DONpnGMfQEXG0zzCO9hnG0T7DONpnGEf7DOLYdxEk7GifYRztM4yjfYZxDB0RR/Pj2PG1f5bdvPbHqaLpkVA0O/56xbXt0kRW0dxIKJoaCUUzI6EYKgKKnn8Tip5+E4p2F0LR7kIo2l0Axa7bP2FFuwuhaHchFO0uhGKoOD7tvt2Wz4tvS5w62l4YR/sL42iDYRztMIyjLQZx7Lq3FXe0yTCOdhnG0TbDOIaOiKN9puK47Ifjtpw62mcYR/sM42ifYRztM4hj1827uKN95ou5J3G0zyD5scdu5N/AMXREHO0zjKN9hnG0zzCO9hnG0T6DOLptHXK0zzCO9hnG0T7DOIaOiKN9hnG0zzCO9hnG0T7DONpnEEe3rUOO9hnG0T7DONpnGMfQEXG0zzCO9hnG0T7DONpnGEf7DOLotnXI0T7DONpnGEf7DOMYOiKO9hnG0T7DONpnGEf7DONon0Ec3bYOOdpnGEf7DONon2EcQ0fE0T7DONpnGEf7DOLoduuC437Mty+vU0XTY0Fx+7zj/f48VTQ7EoomR0LR+zSh6F2aUPTMkVD0xBFQdHswomheJBTNi4SieZFQDBUBRU8ZCUW7C6FodyEU7S4FxeNN7PvZ+eLm5mVE0dRNKJq6CUVTN6EYKgKKpm5C0dRNKJq6CUVTN6HoJwaAopuXEUW7C6FodyEU7S6EYqgIKNpdCEW7C6FodyEU7S6Eot0FUHTbMqJodyEU7S6Eot2FUAwVAUW7C6FodyEU7S6Eot2FULS7AIpuVkYU7S6Eot2FULS7EIqhIqBodyEU7S6Eot2FULS7EIp2F0DRLcqIoqmbUDR1E4qhIqBo6iYUTd2/RvH9D//47q/ff/f7P/3xb+9/4ac/+/sPf/jx+z//8J9//PGff/n3n7xf+y8="}],"outputs":{"globals":{"storage":[{"fields":[{"name":"npk_m_x_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"npk_m_y_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"ivpk_m_x_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"ivpk_m_y_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"ovpk_m_x_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"ovpk_m_y_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"tpk_m_x_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"tpk_m_y_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"new_npk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"KeyRegistry::rotate_npk_m_parameters"}}],"kind":"struct","path":"KeyRegistry::rotate_npk_m_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"partial_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::partial_address::PartialAddress"}},{"name":"keys","type":{"fields":[{"name":"npk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"ivpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"ovpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"tpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"aztec::keys::public_keys::PublicKeys"}}],"kind":"struct","path":"KeyRegistry::register_ovpk_and_tpk_parameters"}}],"kind":"struct","path":"KeyRegistry::register_ovpk_and_tpk_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"partial_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::partial_address::PartialAddress"}},{"name":"keys","type":{"fields":[{"name":"npk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"ivpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"ovpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"tpk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"aztec::keys::public_keys::PublicKeys"}}],"kind":"struct","path":"KeyRegistry::register_npk_and_ivpk_parameters"}}],"kind":"struct","path":"KeyRegistry::register_npk_and_ivpk_abi"}]}},"file_map":{"144":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{hash::pedersen_hash, storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"155":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_delay_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initally equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation \n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the \n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a \n// reduced delay, invalidating prior private reads.\nstruct ScheduledDelayChange<INITIAL_DELAY> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option, \n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pre: Option<u32>,\n    post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numeric value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\nimpl<INITIAL_DELAY> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior contraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This \n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is \n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in \n            //                             which to scheduled value change\n\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY)\n            )\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Serialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn serialize(self) -> [Field; 1] {\n        // We pack all three u32 values into a single U128, which is made up of two u64 limbs.\n        // Low limb: [ pre_inner: u32 | post_inner: u32 ]\n        // High limb: [ empty | pre_is_some: u8 |  post_is_some: u8 | block_of_change: u32 ]\n\n        let lo = ((self.pre.unwrap_unchecked() as u64) * (1 << 32))\n            + (self.post.unwrap_unchecked() as u64);\n\n        let hi = (self.pre.is_some() as u64) * (1 << 33) \n            + (self.post.is_some() as u64 * (1 << 32)) \n            + self.block_of_change as u64;\n\n        let packed = U128::from_u64s_le(lo, hi);\n\n        [packed.to_integer()]\n    }\n}\n\nimpl<INITIAL_DELAY> Deserialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn deserialize(input: [Field; 1]) -> Self {\n        let packed = U128::from_integer(input[0]);\n\n        // We use division and modulo to clear the bits that correspond to other values when unpacking.\n\n        let pre_is_some = ((packed.hi as u64) / (1 << 33)) as bool;\n        let pre_inner = ((packed.lo as u64) / (1 << 32)) as u32;\n\n        let post_is_some = (((packed.hi as u64) / (1 << 32)) % (1 << 1)) as bool;\n        let post_inner = ((packed.lo as u64) % (1 << 32)) as u32;\n\n        let block_of_change = ((packed.hi as u64) % (1 << 32)) as u32;\n\n        Self {\n            pre: if pre_is_some { Option::some(pre_inner) } else { Option::none() },\n            post: if post_is_some { Option::some(post_inner) } else { Option::none() },\n            block_of_change,\n            _dummy: [0; INITIAL_DELAY],\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"159":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_value_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\nstruct ScheduledValueChange<T> {\n    pre: T,\n    post: T,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Serialize<3> for ScheduledValueChange<T> {\n    fn serialize(self) -> [Field; 3] where T: ToField {\n        [self.pre.to_field(), self.post.to_field(), self.block_of_change.to_field()]\n    }\n}\n\nimpl<T> Deserialize<3> for ScheduledValueChange<T> {\n  fn deserialize(input: [Field; 3]) -> Self  where T: FromField {\n    Self {\n        pre: FromField::from_field(input[0]),\n        post: FromField::from_field(input[1]),\n        block_of_change: FromField::from_field(input[2]),\n    }\n  }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>  {\n    fn eq(self, other: Self) -> bool where T: Eq {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"160":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable.nr","source":"use dep::protocol_types::{\n    hash::{pedersen_hash, poseidon2_hash}, header::Header, address::AztecAddress,\n    traits::{FromField, ToField}\n};\n\nuse crate::context::{PrivateContext, PublicContext};\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{scheduled_value_change::ScheduledValueChange, scheduled_delay_change::ScheduledDelayChange}\n};\nuse crate::oracle::storage::storage_read;\nuse dep::std::unsafe::zeroed;\n\nmod test;\n\nstruct SharedMutable<T, INITIAL_DELAY, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Serialize<N> trait, and allocate N storage slots to\n// this state variable. This is incorrect, since what we actually store is:\n//  - a ScheduledValueChange<T>, which requires 1 + 2 * M storage slots, where M is the serialization length of T\n//  - a ScheduledDelayChange, which requires another storage slot\n//\n// TODO https://github.com/AztecProtocol/aztec-packages/issues/5736: change the storage allocation scheme so that we\n// can actually use it here\nimpl<T, INITIAL_DELAY, Context> Storage<T> for SharedMutable<T, INITIAL_DELAY, Context> {}\n\n// TODO: extract into a utils module once  we can do arithmetic on generics, i.e. https://github.com/noir-lang/noir/issues/4784\nfn concat_arrays<N, M, O>(arr_n: [Field; N], arr_m: [Field; M]) -> [Field; O] {\n    assert_eq(N + M, O);\n    let mut out: [Field; O] = [0; O];\n    for i in 0..N {\n        out[i] = arr_n[i];\n    }\n    for i in 0..M {\n        out[N+i] = arr_m[i];\n    }\n    out\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, INITIAL_DELAY, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    fn hash_scheduled_data(\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) -> Field where T: ToField {\n        // TODO(#5491 and https://github.com/noir-lang/noir/issues/4784): update this so that we don't need to rely on\n        // ScheduledValueChange serializing to 3 and ScheduledDelayChange serializing to 1\n        let concatenated: [Field; 4] = concat_arrays(value_change.serialize(), delay_change.serialize());\n        poseidon2_hash(concatenated)\n    }\n\n    // Since we can't rely on the native storage allocation scheme, we hash the storage slot to get a unique location in\n    // which we can safely store as much data as we need.\n    // See https://github.com/AztecProtocol/aztec-packages/issues/5492 and\n    // https://github.com/AztecProtocol/aztec-packages/issues/5736\n    // We store three things in public storage:\n    //  - a ScheduledValueChange\n    //  - a ScheduledDelaChange\n    //  - the hash of both of these (via `hash_scheduled_data`)\n    fn get_value_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 0], 0)\n    }\n\n    fn get_delay_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 1], 0)\n    }\n\n    fn get_hash_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 2], 0)\n    }\n\n    // It may seem odd that we take a header and address instead of reading from e.g. a PrivateContext, but this lets us\n    // reuse this function in SharedMutablePrivateGetter.\n    fn historical_read_from_public_storage(\n        self,\n        header: Header,\n        address: AztecAddress\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) where T: FromField + ToField + Eq {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for both the ScheduledValueChange and\n        // ScheduledDelayChange, but that'd require one full sibling path per storage slot (since due to kernel siloing\n        // the storage is not contiguous), and in the best case in which T is a single field that'd be 4 slots.\n        // Instead, we get an oracle to provide us the correct values for both the value and delay changes, and instead\n        // prove inclusion of their hash, which is both a much smaller proof (a single slot), and also independent of\n        // the size of T.\n        let (value_change_hint, delay_change_hint) = get_public_storage_hints(address, self.storage_slot, historical_block_number);\n\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let hash = header.public_storage_historical_read(self.get_hash_storage_slot(), address);\n\n        // @todo This is written strangely to bypass a formatting issue with the if that is breaking ci.\n        let (a, b, c) = if hash != 0 {\n            let a = SharedMutable::hash_scheduled_data(value_change_hint, delay_change_hint);\n            (a, value_change_hint, delay_change_hint)\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized, meaning no value or delay change was ever\n            // scheduled. Therefore, the hints must then correspond to uninitialized scheduled changes.\n            let b = ScheduledValueChange::deserialize(zeroed());\n            let c = ScheduledDelayChange::deserialize(zeroed());\n            (hash, b, c)\n        };\n\n        assert_eq(hash, a, \"Hint values do not match hash\");\n        assert_eq(value_change_hint, b, \"Non-zero value change for zero hash\");\n        assert_eq(delay_change_hint, c, \"Non-zero delay change for zero hash\");\n\n        (value_change_hint, delay_change_hint, historical_block_number)\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PublicContext> {\n    pub fn schedule_value_change(self, new_value: T) where T: ToField {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) where T: ToField {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value_in_public(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay_in_public(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value_in_public(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay_in_public(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        self.context.storage_read(self.get_delay_change_storage_slot())\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) where T: ToField {\n        // Whenever we write to public storage, we write both the value change and delay change as well as the hash of\n        // them both. This guarantees that the hash is always kept up to date.\n        // While this makes for more costly writes, it also makes private proofs much simpler because they only need to\n        // produce a historical proof for the hash, which results in a single inclusion proof (as opposed to 4 in the\n        // best case scenario in which T is a single field). Private shared mutable reads are assumed to be much more\n        // frequent than public writes, so this tradeoff makes sense.\n        self.context.storage_write(self.get_value_change_storage_slot(), value_change);\n        self.context.storage_write(self.get_delay_change_storage_slot(), delay_change);\n        self.context.storage_write(\n            self.get_hash_storage_slot(),\n            SharedMutable::hash_scheduled_data(value_change, delay_change)\n        );\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext> {\n    pub fn get_current_value_in_private(self) -> T where T: FromField + ToField + Eq {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n\n        let (value_change, delay_change, historical_block_number) = self.historical_read_from_public_storage(self.context.get_header(), self.context.this_address());\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n}\n\nunconstrained fn get_public_storage_hints<T, INITIAL_DELAY>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>) {\n    // This function cannot be part of the &mut PrivateContext impl because that'd mean that by passing `self` we'd also\n    // be passing a mutable reference to an unconstrained function, which is not allowed. We therefore create a dummy\n    // state variable here so that we can access the methods to compute storage slots. This will all be removed in the\n    // future once we do proper storage slot allocation (#5492).\n    let dummy = SharedMutable::new((), storage_slot);\n\n    (\n        storage_read(address, dummy.get_value_change_storage_slot(), block_number), storage_read(address, dummy.get_delay_change_storage_slot(), block_number)\n    )\n}\n"},"193":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"21":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    fn new(x: Field, y: Field, is_infinite: bool) -> Self {\n        Self { x, y, is_infinite }\n    }\n\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n// Scalar represented as low and high limbs\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    pub fn derive_public_key(self) -> EmbeddedCurvePoint {\n        let public_key = fixed_base_scalar_mul(self.lo, self.hi);\n        EmbeddedCurvePoint { x: public_key[0], y: public_key[1], is_infinite: false }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, key: EmbeddedCurveScalar) -> bool {\n        (key.hi == self.hi) & (key.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n#[foreign(multi_scalar_mul)]\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> [Field; 3]\n// docs:end:multi_scalar_mul\n{}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(\n    scalar_low: Field,\n    scalar_high: Field\n) -> [Field; 3]\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    let scalar = EmbeddedCurveScalar { lo: scalar_low, hi: scalar_high };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n"},"229":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"235":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<N> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<N> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<N> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<N> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"273":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"361":{"path":"/usr/src/noir-projects/noir-contracts/contracts/key_registry_contract/src/main.nr","source":"contract KeyRegistry {\n    use dep::authwit::auth::assert_current_call_valid_authwit_public;\n\n    use dep::aztec::{\n        keys::PublicKeys, state_vars::{SharedMutable, Map},\n        protocol_types::{point::Point, address::{AztecAddress, PartialAddress}}\n    };\n\n    global KEY_ROTATION_DELAY = 5;\n\n    #[aztec(storage)]\n  struct Storage {\n    // The following stores a hash of individual master public keys\n    // If you change slots of vars below, you must update the slots in `SharedMutablePrivateGetter` in aztec-nr/keys.\n    // We store x and y coordinates in individual shared mutables as shared mutable currently supports only 1 field\n    npk_m_x_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n    npk_m_y_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n\n    ivpk_m_x_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n    ivpk_m_y_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n    \n    ovpk_m_x_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n    ovpk_m_y_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n    \n    tpk_m_x_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n    tpk_m_y_registry: Map<AztecAddress, SharedMutable<Field, KEY_ROTATION_DELAY>>,\n  }\n\n    #[aztec(public)]\n  fn rotate_npk_m(address: AztecAddress, new_npk_m: Point, nonce: Field) {\n        // TODO: (#6137)\n        if (!address.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, address);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let npk_m_x_registry = storage.npk_m_x_registry.at(address);\n        let npk_m_y_registry = storage.npk_m_y_registry.at(address);\n        npk_m_x_registry.schedule_value_change(new_npk_m.x);\n        npk_m_y_registry.schedule_value_change(new_npk_m.y);\n    }\n\n    // We need to have two separate register functions because a single one would produce too many storage writes, since\n    // each SharedMutable.schedule_value_change call results in 5 writes (pre, post, block_of_change, delay and hash),\n    // totaling 40 writes, while the kernels only accept up to 32 writes.\n    // Once SharedMutable accepts multi-field values, we can have a single state variable hold all keys, and that way\n    // also have a single block of change, hash, and delay.\n    // TODO (#5491): make this be a single function with a single schedule call.\n\n    #[aztec(public)]\n  fn register_npk_and_ivpk(address: AztecAddress, partial_address: PartialAddress, keys: PublicKeys) {\n        let computed_address = AztecAddress::compute(keys.hash(), partial_address);\n\n        assert(computed_address.eq(address), \"Computed address does not match supplied address\");\n\n        let npk_m_x_registry = storage.npk_m_x_registry.at(address);\n        let npk_m_y_registry = storage.npk_m_y_registry.at(address);\n        let ivpk_m_x_registry = storage.ivpk_m_x_registry.at(address);\n        let ivpk_m_y_registry = storage.ivpk_m_y_registry.at(address);\n\n        npk_m_x_registry.schedule_value_change(keys.npk_m.x);\n        npk_m_y_registry.schedule_value_change(keys.npk_m.y);\n        ivpk_m_x_registry.schedule_value_change(keys.ivpk_m.x);\n        ivpk_m_y_registry.schedule_value_change(keys.ivpk_m.y);\n    }\n\n    #[aztec(public)]\n  fn register_ovpk_and_tpk(address: AztecAddress, partial_address: PartialAddress, keys: PublicKeys) {\n        let computed_address = AztecAddress::compute(keys.hash(), partial_address);\n\n        assert(computed_address.eq(address), \"Computed address does not match supplied address\");\n\n        let ovpk_m_x_registry = storage.ovpk_m_x_registry.at(address);\n        let ovpk_m_y_registry = storage.ovpk_m_y_registry.at(address);\n        let tpk_m_x_registry = storage.tpk_m_x_registry.at(address);\n        let tpk_m_y_registry = storage.tpk_m_y_registry.at(address);\n\n        ovpk_m_x_registry.schedule_value_change(keys.ovpk_m.x);\n        ovpk_m_y_registry.schedule_value_change(keys.ovpk_m.y);\n        tpk_m_x_registry.schedule_value_change(keys.tpk_m.x);\n        tpk_m_y_registry.schedule_value_change(keys.tpk_m.y);\n    }\n}\n"},"47":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"54":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n    GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER, GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    CANONICAL_AUTH_REGISTRY_ADDRESS\n},\n    hash::pedersen_hash\n};\nuse dep::aztec::{prelude::Deserialize, context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties \n * (e.g. protocols or other users) to execute an action on their behalf.\n * \n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be \n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few \n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can \n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be \n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n * \n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer. \n * \n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is \n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n * \n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline \n * how this would look in private, and then in public later. \n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX). \n * `Alice` would make a `deposit` transaction, that she is executing using her account contract. \n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token` \n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to \n * convince the `Token` contract that it is allowed to do so. \n * \n * This is where the authentication witness comes in! The `Token` contract computes a `message_hash` from the \n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to \n * execute that call.\n * \n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her \n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n * \n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n * \n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts. \n * \n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *  \n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store \n * the messages that we have approved. \n * \n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `keccak256(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a colission and we return \n *      a success flag.\n * \n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be \n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the \n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n * \n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains. \n */\n\nglobal IS_VALID_SELECTOR = 0xabf64ad4; // 4 first bytes of keccak256(\"IS_VALID()\")\n\n/** \n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n * \n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([context.msg_sender().to_field(), context.selector().to_field(), context.args_hash]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/** \n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n * \n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n * \n * @param on_behalf_of The address that have authorized the current call\n * @param inner_hash The hash of the message to authorize  \n */\npub fn assert_inner_hash_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context.static_call_private_function(\n        on_behalf_of,\n        FunctionSelector::from_signature(\"verify_private_authwit(Field)\"),\n        [inner_hash]\n    ).unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier, 0);\n}\n\n/** \n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n * \n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n * \n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub fn assert_current_call_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash(\n        [(*context).msg_sender().to_field(), (*context).selector().to_field(), (*context).get_args_hash()]\n    );\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/** \n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n * \n * @param on_behalf_of The address that have authorized the the `inner_hash`\n */\npub fn assert_inner_hash_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    let result: Field = context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"consume((Field),Field)\"),\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default()\n    ).deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness \n * \n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n * \n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<N>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N]\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash = compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n * \n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n * \n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<N>(args: [Field; N]) -> Field {\n    pedersen_hash(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/** \n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n * \n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n * \n * @param on_behalf_of The address that have authorized the the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    pedersen_hash(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n * \n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(consumer: AztecAddress, chain_id: Field, version: Field, inner_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        consumer.to_field(),\n        chain_id,\n        version,\n        inner_hash\n    ],\n        GENERATOR_INDEX__AUTHWIT_OUTER\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n * \n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n * \n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"set_authorized(Field,bool)\"),\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n * \n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise \n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"set_reject_all(bool)\"),\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n"},"66":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr","source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH, hash::poseidon2_hash,\n    point::Point, traits::{Deserialize, Serialize, Empty, is_empty}\n};\nuse crate::keys::constants::{NUM_KEY_TYPES, NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX};\n\nglobal PUBLIC_KEYS_LENGTH = 12;\n\nstruct PublicKeys {\n    npk_m: Point,\n    ivpk_m: Point,\n    ovpk_m: Point,\n    tpk_m: Point,\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m : Point::empty(),\n            ivpk_m : Point::empty(),\n            ovpk_m : Point::empty(),\n            tpk_m : Point::empty()\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        ( self.npk_m == other.npk_m ) &\n        ( self.ivpk_m == other.ivpk_m ) &\n        ( self.ovpk_m == other.ovpk_m ) &\n        ( self.tpk_m == other.tpk_m )\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash(\n                [\n                self.npk_m.x,\n                self.npk_m.y,\n                self.npk_m.is_infinite as Field,\n                self.ivpk_m.x,\n                self.ivpk_m.y,\n                self.ivpk_m.is_infinite as Field,\n                self.ovpk_m.x,\n                self.ovpk_m.y,\n                self.ovpk_m.is_infinite as Field,\n                self.tpk_m.x,\n                self.tpk_m.y,\n                self.tpk_m.is_infinite as Field,\n                GENERATOR_INDEX__PUBLIC_KEYS_HASH\n            ]\n            )\n        }\n        )\n    }\n\n    pub fn get_key_by_index(self, index: Field) -> Point {\n        assert(index as u8 < NUM_KEY_TYPES, \"Invalid key index\");\n        if index == NULLIFIER_INDEX {\n            self.npk_m\n        } else if index == INCOMING_INDEX {\n            self.ivpk_m\n        } else if index == OUTGOING_INDEX {\n            self.ovpk_m\n        } else {\n            self.tpk_m\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.x,\n            self.npk_m.y,\n            self.npk_m.is_infinite as Field,\n            self.ivpk_m.x,\n            self.ivpk_m.y,\n            self.ivpk_m.is_infinite as Field,\n            self.ovpk_m.x,\n            self.ovpk_m.y,\n            self.ovpk_m.is_infinite as Field,\n            self.tpk_m.x,\n            self.tpk_m.y,\n            self.tpk_m.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: Point::new(serialized[0], serialized[1], serialized[2] as bool),\n            ivpk_m: Point::new(serialized[3], serialized[4], serialized[5] as bool),\n            ovpk_m: Point::new(serialized[6], serialized[7], serialized[8] as bool),\n            tpk_m: Point::new(serialized[9], serialized[10], serialized[11] as bool)\n        }\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: Point { x: 1, y: 2, is_infinite: false },\n        ivpk_m: Point { x: 3, y: 4, is_infinite: false },\n        ovpk_m: Point { x: 5, y: 6, is_infinite: false },\n        tpk_m: Point { x: 7, y: 8, is_infinite: false }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x146f68c0e0ba4067d61a3304bbfdec0797d5df1357db6c01247c48bfb345c7d7;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nfn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nfn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: Point { x: 1, y: 2, is_infinite: false },\n        ivpk_m: Point { x: 3, y: 4, is_infinite: false },\n        ovpk_m: Point { x: 5, y: 6, is_infinite: false },\n        tpk_m: Point { x: 7, y: 8, is_infinite: false }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.x, deserialized.npk_m.x);\n    assert_eq(keys.npk_m.y, deserialized.npk_m.y);\n    assert_eq(keys.ivpk_m.x, deserialized.ivpk_m.x);\n    assert_eq(keys.ivpk_m.y, deserialized.ivpk_m.y);\n    assert_eq(keys.ovpk_m.x, deserialized.ovpk_m.x);\n    assert_eq(keys.ovpk_m.y, deserialized.ovpk_m.y);\n    assert_eq(keys.tpk_m.x, deserialized.tpk_m.x);\n    assert_eq(keys.tpk_m.y, deserialized.tpk_m.y);\n}\n"},"95":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn block_number(self) -> Field {\n        block_number()\n    }\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<N>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<N>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, N>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N)\n}\n\nunconstrained fn storage_write<N>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<N>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<N>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}