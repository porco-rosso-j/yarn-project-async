{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"AuthRegistry","functions":[{"name":"is_consumable","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/+2aWU8jRxDH2xchju1hbGxsbMCA72MwxrAoWfYxT3mLFClPUW5FyiHlUJSvmE+VrqquqRkGzapWmxZa7UiD29X/X9fRY3tKw8iUjNmvGHucGHeUrcU0zJ59KcD5yvDIDor2LDRMgU1jmASqOHYyU8IRCMs4sh5M5cL+qY0NrbBfvoWJMqw1MgWAPqgYZGFoz70RDnf2rI45sH2ah6MKf0gD2IcjmbELfmpfPyLxvhPXxkUymppgNdJUaYjoX2JmtI4oCOqC1gWtO/RXMTPaQBQEDUEbgjYc+q2YGQ0QBUEgaCBo4NA/xczoAaIgOBD0QNADh/4kZkZDREEQChoKGjr0NzEz2kQUBE1Bm4I26TWL1PMR620oZkZbiIKgJWhL0FbWWyvOLQex3v4QM6OHiILgUNBDQQ8d+pWYGW0jCoK2oG1B29lA2/HWK5FQj9T1SEuP1PIRW7lfxMxoB1EQdATtCNpx6NdiZvQIURAcCXok6JFDvxEzo11EQdAVtCto16E/i5nRHqIg6AnaE7Tn0O/FzOgxoiA4FvRY0ONsZY/jT4ASaeiRjh6pe8kl9BJYNx+xW/qPmBntIwqCvqB9QftZb/24DErkSI/0vATW0CMdPdL1grymYvYq+E7MjA4QBcFA0IGgg6y3QVxsJdLSI4Ee6XjxcqBHGl5y6XpBjvORc7DX5T75FkEjN8d8NwxqM+Y7Zrti2chxgq5O0q5OCR7QkGfgRvxUREO53z7fw+G501+4+/nLAgovwQQnRlyld5wu2C7HLDsTxzRRJCNMsochvA4hhkRYjwK+K7hsb0mDOca1KUltTtI9xJ7kdDIyFZM+YJUBNkXoyW1IyS1TxWAH9DXAC1YT8/SaRcr5SCokTub0k3JCU6KdeRwvHGcUL9TwrILDqntbHqE7c05dV5nLS05eQl3iil1IxUbpil1KeCO74Od0qZXcloN4gknCUhPBJqQZ0RBes0igR8J8xAb4u5gZnSIKgqmgU0GnWW/T+JsjB7HefhQzozNEQTATdCboLOttFv/0KJGmHmnpka4eCfVI8NbTt/uzETOjc0RBMBd0Lug8620ee1MidT0S6pHASy4dPdL1grymYvYq+FvMjC4QBcFC0IWgi6y3RfwpVSL9fMQGGImZ0SWiIFgKuhR0mfW2jLdWiYz1SKBHQj0y0SMdPTLVIz0v+9LSI10v+xJ4yeUNKtbWIzUvuQTP9YIJvHzEJs+hYvaL9gcxM7pCFAQrQVeCrrLeVnFOSiTUI2090sxHbBmuxczoGlEQrAVdC7rOelvHP1E5CLQcxY+l73hA0Eizwd0FqKmLHdGKyS42QldR2tUVwWsa8gw0Nlciupb+ZUtd7Nbpb1wXu6MuFtrMGzgx4hf0jtMFZjdm2UYc00SRjDDJHqDE26FdKRnWo4Cxi4VsH6Txi+LalKU2kUn1ZInOPCJRmauDoVSf3JLIuX4SqeQjEt86bkwjt8ia2s7ItZ0Vajcrrt2sSvqbp7Z9k07tapSc4SsJRNfxrcp1YndJs3EFfxIJ9EioRyZ6pKNHpnqkp0eaeqSlR7pe9iXwkv7Mi5f6O1SxjpcLxs81NvfyqezrkYWXrXz/nfz+O/n/3v2Wl4q19UjNSy7Bc71gAi8fsclzrdjSSy6hlyv5DdJfvfWfJGgZSl9K3/CAoEm3BMapqV3c0IrJdnGLrrZpV66du6Yhz7ykTpBFt9J/3FG7eOf0L1y7eE/t4j2Y4MSIv6B3nC4w92OW7cQxTRTJCJPsAR7u3g3t+88SYT0KGNvFDbWLjx8FYstFjwJhqpJI+6lHxjfprms75fa6YFLPKm/24meVgOwwWfgPiB0G4w5+bA0y6ZKjRtwXVl85/3jKv5eSqRE/ttzSEDYuQiRyZwJB05gntzgCoHgJw+6/cP4H0PaWlvIqAAA=","debug_symbols":"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"},{"name":"set_authorized","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"},{"name":"authorize","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/+2Z227bRhCGV8faUeIkNilK1ImSSMmS6ti+aC/auFcF+gC96mXRJrnJAcgBecc8VXZmdviToaBgg4QwghCgSM7+38zsLCl5zNS0jDlqG7tNjNvs1ZE5MV17aND+h9Eze9K0e+PENNQkOnLSYl1L9qKOTRkNkvdm5twZsZGwnTnUdBb24+QXo0k9pI9uatTlcaZZ/mTYSNsxfYiG/B6lGElNx5Q38nKHszZ3ZG+JN3bTy5puoAeHPdEcyykdq0j3MFJKSSdz9/d2QUP+7lbzpe2e5HuP9o6Ecpe2NBTO3O/wkYbuUwUlyGO7n+YVe4CKnZYr9hDpnVqHf9vjmYgfOHHAkzyjM2CBaE7llNG3MCsaMkqCEGgINHToK5gV7TNKgj7QPtC+Q1/DrGjEKAkioBHQyKH/wqzogFESDIAOgA4c+gxmRYeMkmAIdAh06NAnMCsaM0qCGGgMNHZoArOiI0ZJMAI6Ajpy6BuYFR0zSoIx0DHQsUOfw6zohFESTIBOgE7kWEVCfyTwR+LDiJ3TFcyKThklwRToFOi0Gm2aRzuA2GgvYVZ0xigJZkBnQGfVaLO8gp5I4I/E/kjkj4xrQT5TMbs+72FWNGGUBAnQBGhSjZbkT/EBxEb7H2ZF54ySYA50DnTu0EcwK7pglAQLoAugi2qii3yJPZEzfyTwR0J/pO+PRP7IwB8Z1rIuI39kXMu6BLXM5TMVs8/NC5gVXTJKgiXQJdClQ9/BrGjKKAlSoCnQtJpoms/NEwn8kfi2Jhb5I/3bUDF7FzyFWdGMURJkQDOgWTVals/JEwn9kYU/Eh9GbBmuYVZ0xSgJVkBXQFfVaKv8J+sAQsONv9DP3DBo0MRo10Jqji9satoG25pDrcuhzgVeyamOUMN0DtEWfdGuy6c7p//ZFoIUFw0WXpCJds74T7nS6RJzkalsg8Ay0BQjDWqELR0T6+m3QlqfJPxrw832Bg3lOq9NF7VZl3u9k7Q40hKtVIdT6e1dkrULvRdpH0aQ3ypveNfOyaqT+6J2ttfR7pnb2Damv9m37Jvy1M7T4ojeSSTa5n+6bAurK5qNK/heJPBHQn+k749E/sjAHxn6I7E/MvJHxrWsS1DL9Ce1RJl+RxWLarlh6rnHZrU8lYk/Mq9lKX98J//4Tv7Wqz+qpWILf2RZy1yC23rDBLU8Yv3bWrG0lrmEtdzJXzD97Kv/JNFw8yn6hhsGTbklME4t7eJGPBbbxR2H2pVDuXZuK6c68lg6QRU9Qv9xKe3ipdNfuXbxWtpFaqHp7cMVZ/yfXOl0ibnOVHaBwDLQFCMNagT6j/BlYj39U0jrk4S5XaTZ3si7RHrNWHhfucvL1EGZduX2qp0WR1rOyS5fnd7e1cn72fOGI+i4XlLAwQfaPwJpU8mGhB4AAA==","debug_symbols":"5dzBblzHEYbRd+FaCLqqq/re9qsEQSDbciBAoAxLDhAIfvdQMYeUYSKzEBLzmDsNWZr5L7X4xM35dPP9m29//sff397+8P7DzTd//XTz7v13rz++fX979+rTzfhL1H+++uHH17efv/Dh4+ufPt58c/Z4dfPm9vu7Px3jl1c3P7x99+bmm5n5y6vf3dbMuj+uOfPhevcTx2ue5/3xqjG/PP7bq89z+sk5mQ9z4sqcPS8fsM/z4TaqnriNh8eM/XibuZ9639qXx9zdj8uzxv305U4/3OmnO32z03O409OdPt3p5U53k5RuktJNUrpJSjdJ003SDHe6W9P51TWNseZlT+S4Mv4y/drvU73j8hvS+O0P5NfZbc5e5uzDnH2aszc5u4Y5O8zZac42c1NlzjYrWWYly6xkmZUss5JtVrLNSrZZyTYr2WYl26xkm5Vss5JtVrLNSi6zksus5DIrucxKLrOSy6zkMiu5zEous5LLrORhVvIwK3mYlTzMSh5mJQ+zkodZycOs5GFW8jAreZqVPM1KnmYlT7OSp1nJ06zkaVbyNCt5mpU8zUpus5LbrOQ2K7nNSm6zktus5DYruc1KbrOS26xkDDOTMcxOxjBDGcMsZQwzlTHMVt59KLrbrGUMM5cx0F4G2stAexloLwPtZaC9DLSXgfYy0F4G2stAe5loLxPtZaK9TLSXXy/g/EG70V4m2stEe5loLxPt5UR7OdFeTrSXKHMTE+0l6vMECvQEKvQESvQEavQEivQEqvQEyvQE6vQECvUEKvUESvUEavUEivUEqvUEyvUE6vUECvYEKvYESvYEavYEivYEqvYEyvYE6vYECvcEKvcESvcEavcEivcEqvcEyvcE6vcECvgEKvgESvgEavgEivgEqvgEyvgE6vgECvkEKvkESvkEavkEivkEqvkEyvkE6vkECvoEKvoESvoEavoEivoEqvoEyvoE6voECvsEKvsESvsEavsEivsEqvsEyvsE6vsk6vsk6vsk6vsk6vvkMHuZqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO+TqO8zUd9nor7PRH2fifo+c5i9nKjvM1HfZ6K+z0R9n4n6PhP1fSbq+0zU95mo7zNR32eivs9EfZ+J+j4T9X0m6vtM1PeZqO8zUd9nor7PRH2fifo+E/V95lXf5zyvfMKe5/3tPs8rq6Mvu2M/3mbup963dl3euHs+Xte4bD/h7dvdftX6ec7bA96e8PYJby94e8PbF7wd7uqEuzrhrhbc1YK7Wl/d1f/N/92PcfmJHNlfvOe67J7o7kJ3N7p7obsPdPeJ7t7m7h7o7kB3o71stJdXbaDnuhvtZaO9bLSXjfay0V4utJcL7eVCe7nQXl61gZ7rbrSXC+3lQnu50F4utJcH2ssD7eWB9vJAe3nVBnquu9FeHmgvD7SXB9rLA+3lifbyRHt5or080V5etYGe6260lyfayxPt5Yn28kR7udFebrSXG+3lRnt51QZ6rrvRXm60lxvt5UZ7uc1e1jB7WcPsZQ2zlzXMXtYwe1nD7GUNs5c1zF7WMHtZA+1loL0MtJeB9jLQXl61gZ7rbrSXgfYy0F4G2stAe5loLxPtZaK9TLSXV22g57ob7WWivUy0l4n2MtFeTrSXE+3lRHs50V5+vf/zB+1GeznRXk60lxPt5UR7WWgvC+0l6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vsU6vs06vs06vs06vs06vv0MHvZqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO/TqO+zUN9nob7PQn2fhfo+a5i9XKjvs1DfZ6G+z0J9n4X6Pgv1fRbq+yzU91mo77Ou+T579LXdM9Zl91znbz7j99e96ri/7rXq4Xr3E8dzx/1tjcfTnHUZ3//v8TEex/d/H991PBz3uHJ8rrz8O53rGF8e3z/qejmPerycRz1fzqPuF/Oo14yjP9Ojxst51Hw5jzpfzqPWS3jUuxf/fP3T29ffvnvz4e6vfP7ez7fffXz7/vb+5cd//fjrd+5u/w0="},{"name":"set_authorized_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"approver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"},{"name":"authorize","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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5Lw6qrXyUoeVlzqsvNRRraq18lKHlZc6rLzUYeWlDicvtd2cvNR2c/JS283JS203Jy+13apVtU5ears5eant5uSltpuTl9puVl4q07b7jmqtvFSmze4d1Vp5qUxbzDuqtfJSmTZ2d1Rr5aUybafuqNbKS2XaxNxRrZWXyrR1uKNaKy+VacNuR7VWXirTNtmOaq28VKbNqR3VWnmpTFtCO6q18lKZNmJ2VGvlpTJtf+yo1spLZdp02FGtlZfKtNWvo1orL5Vpg11HtVZeKtO2to5qrbxUps1kHdVaealMW7g6qrXyUpk2TnVUa+WlMm1X6qjWyktl2iTUUa2Vl8q0NaejWisvlWlDTEe1Vl4q0zaUjmqtvFSmzR8d1Vp5qUxbLjqqtfJSmTY6dFRr5aUybS/oqNbKS2Wa1N9RrZWXyjTxvqNaKy+VaSp9R7VWXirT5PiOaq28VKbp7h3VWnmpTBPYO6q18lKZpqR3VGvlpazmnm9Wc883q7nnm9Xc881q7vlmNfd8s5p7vlnNPd+s5p5vVnPPN6u555vV3PPNau75ZjX3fLOae75ZzT3frOaeb1Zzz3eruee71dzz3Wru+W4193y/VatqnbzUbjX3fLeae75bzT3freae71Zzz3eruee71dzz3Wru+W4193y3mnu+W809363mnu9Wc893q7nnu9Xc891q7vluNfd8t5p7vlvNPd+t5p7vVnPPd6u557vV3PPdau75bjX3fLeae75bzT3freae71Zzz3eruee71dzz3Wru+W4193y3mnu+W809363mnu9Wc893q7nnu9Xc891q7vluNfd8t5p7vlvNPd+t5p7vVnPPd6u557vV3PPdau75bjX3fLeae75bzT3freae71Zzz3eruee71dzz3Wru+W4193y3mnu+W809363mnu9Wc893q7nnu9Xc891q7vluNfd8t5p7vlvNPd+t5p7vVnPPd6u557vV3PPdau75bjX3fLeae75bzT3freae71Zzz3eruee71dzz3Wru+W4193y3mnu+W809363mnu9Wc893q7nnu9Xc891q7vluNfd8t5p7vlvNPd+t5p7vVnPPd6u554fV3PPDau75YTX3/LCae37cqlW1Tl7qsJp7fljNPT+s5p4fVnPPD6u554fV3PPDau75YTX3/LCae35YzT0/rOaeH1Zzzw+rueeH1dzzw2ru+WE19/ywmnt+WM09P6zmnh9Wc88Pq7nnh9Xc88Nq7vlhNff8sJp7fljNPT+s5p4fVnPPD6u554fV3PPDau75YTX3/LCae35YzT0/rOaeH1Zzzw+rueeH1dzzw2ru+WE19/ywmnt+WM09P6zmnh9Wc88Pq7nnh9Xc88Nq7vlhNff8sJp7fljNPT+s5p4fVnPPD6u554fV3PPDau75YTX3/LCae35YzT0/rOaeH1Zzzw+rueeH1dzzw2ru+WE19/ywmnt+WM09P6zmnh9Wc88Pq7nnh9Xc88Nq7vlhNff8sJp7fljNPT+s5p4fVnPPD6u554fV3PPDau75YTX3/LCae35YzT0/rOaeH1Zzzw+rueeH1dzzw2ru+WE19/ywmnt+WM09P6zmnh9Wc88Pq7nnh9Pc8+3mNPf8Xq2Rl7pXa+Sl7tUaeal7tdWqWiMvda/WyEvdqzXyUvdqjbzUvVorL+U09/xerZWXcpp7fq/Wyks5zT2/V2vlpZzmnt+rtfJSTnPP79VaeSmnuef3aq28lNPc83u1Vl7Kae75vVorL+U09/xerZWXcpp7fq/Wyks5zT2/V2vlpZzmnt+rtfJSTnPP79VaeSmnuef3aq28lNPc83u1Vl7Kae75vVorL+U09/xerZWXcpp7fq/Wyks5zT2/V2vlpZzmnt+rtfJSTnPP79VaeSmnuef3aq28lNPc83u1Vl7Kae75vVorL+U09/xerZWXcpp7fq/Wyks5zT2/V2vlpZzmnt+rtfJSTnPP79VaeSmnuef3aq28lNPc83u1Vl7Kae75vVorL+U09/xerZWXcpp7fq/Wyks5zT2/V2vlpZzmnt+rtfJSTnPP79VaeSmnuef3aq28lNPc83u1Vl7Kae75vVorL+U09/xerZWXcpp7fq/Wyks5zT2/V2vlpZzmnt+rtfJSTnPP79U6ealiNfe8WM09L1Zzz4vV3PN7LVbVOnmpYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3vFjNPS9Wc8+L1dzzYjX3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ff7Y92/r/Mst9v3bPn/s+7d9/tj3b/v8se/f9vlj37/t88e+f9vnj33/ts9/7ft3uV37/l1uF79/y8Xv33Lx+7dc/P4tF79/NfOXBp7/4vdvufj9Wy5+/5aL37/l4vfvdPH7d7r4/Ttd/P6dLn7/auYvDTz/xe/f6eL373Tx+3e6+P07Xfz+nS9+/84Xv3/ni9+/88XvX838pYHnv/j9K5n/c6vL4/y346Y8f+v7V4tk/s/A80vm/4w8f7n4+aeLn3+++Pnrxc+/XPz868XPv138/Be/f2vs+7f1/dVliX3/ts8f+/5tnz/2/ds+f+z7t/X9yUUy/2fk+WPfv+3zx75/2+ePff+2zx/7/m2fP/b92+w/rLHv3/b5Y9+/7fPHvn/b5499/7bPH/v+bZ8/9v3bPn/s+7d9/tj3b/v8se/f9vkvfv9uF79/t4vfv9vF79/t4vfvdvH7d7v4/btd/P7dLn7/bhe/f7eL37/7xe/f/eL3737x+3e/+P0rmb808vwXv3/3i9+/+8Xv3/3i9+9+8fv3uPj9e1z8/j0ufv8eF79/JfOXRp7/4vfvcfH797jw/Xvb//3rn2/O++M8tRxfh5+2xx97/avJ9h8rf+2PTX/tj83v/7Fp+vdnv6jfH18FK+X2/Q8u//MP1n9/8lOirTz+wnLcvkQo9fb8g8df/IMnP57p+IPlr/7B6e0/eP+//n//8f/6L//xf/uv//m/3//MP/4f/+9//t//5b/8t3/+9X/+y/////yf/y/31/4/"},{"name":"unconstrained_is_consumable","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"set_reject_all","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"reject","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/83X2W7TQBQG4HGWkqZtSmLHseM4ieOlCxGCC5AQlBskXoAnQGK5YZFYxDvyVMw5M8d/gitXcxPV0sST4/PNnBk3qqZQXaUGuimVKntRRI3Ukb551F4r6elORzdvpDwJmbwONc7rmLabx6GSHtLopkdDdUsLVG+jP86eKSllTB/9girhgQal1HbE5fHFo5kcGu1BgSeF6qv9izKOuVZ1bFrXjMbDDMuOfTDEgEOTMzBdujdJv53slSSLOXnZ28mh8U6a9dJ1auo9pdbn7tB+1VtD06lRn++ER7SDZpJXtIP1jp1jx8b7O/YQ5Y31gO/0fWKSz22yz4ucUA/MNzlj02X6C2GhAVNKCEAD0MDS7wgLnTKlhCnoFHRq6Q+EhYZMKSEEDUFDS98jLHTGlBJmoDPQmaWfERYaMaWECDQCjSz9iLDQmCklxKAxaGzpGmGhc6aUMAedg84t/Ymw0IQpJSSgCWhi6ReEhS6YUsICdAG6MPcmCdyJ707idqLX9ARhoSlTSkhBU9C0OVtaz9ZC9GzfEBa6ZEoJS9Al6LI527LeQUfiu5PYnYTuJDkIuWPH9Pv5g7DQFVNKWIGuQFfN2Vb1r7iF6Nk+ICx0zZQS1qBr0LWljxEWmjGlhAw0A82ahWb1K3YkE3fiu5PAnUzdSehOZu4kOsh7mbuT5CDvxT/IWu7YMf27+Yqw0A1TStiAbkA3lv5GWGjOlBJy0Bw0bxaa12tzJL47ie9rYaE7md6HHdN/BZ8QFlowpYQCtAAtmrMV9ZocSeBOMncStxO9DU8RFloypYQStAQtm7OV9b+sFkL1e29xnrlhqHCIkVNLWX+MzYg9haviqar9qS4MLk1XntCB6QJJVzgXXR9x99rmP9IbQRlbjxO3FKLGFb8x32S5ZLalpF1iYvOgY4L0UGa4orveG+/FTln/Ffzcs6u9MYfDnqoPyh4vWpbfwzZV+8e+s2L3SdcOUtVvp3/r26lsFdWlZwUfeHOKRX+p/QNL3SAxSxAAAA==","debug_symbols":"5dzLSlthGIXhe8lYyr/W9x+9lVJKPJWARNFYKOK9N7bZicXQOJDK28yMfiZr6+CdPY+zi8uzh29fF8urm/vZ6efH2fXN+Xy1uFmuXz3O0ifFr+/e386Xz9+4X83vVrNTOdeT2eXy4vnLWp9OZleL68vZadhPJ6+uczhvrnOEt9ej7Dmu0fvmuOYUL4+/nDwPyvsHbT9iPagdGDRi+ojR+/ZWOe+5VUnTG4/drT32vW8e04pRym67c9qML+TxlTy+kcd38vgBHm+Rx5s8PsjjyZEyOVImR8rkSJkcKZMjFYk8nlzYeIfCKtWYruV0YP40Ph1415amP0lzefGedTM8U4cX6vBKHd6owzt1+IAOz4k6XNTh1ADloA6nljNTy5mp5czUcmZqOTO1nIVazkItZ6GWs1DLWajlLNRyFmo5C7WchVrOQi1npZazUstZqeWs1HJWajkrtZyVWs5KLWellrNSy9mo5WzUcjZqORu1nI1azkYtZ6OWs1HL2ajlbNRydmo5O7WcnVrOTi1np5azU8vZqeXs1HJ2ajk7tZyDWs5BLeeglnNQyzmo5RzUcg5qOQe1nINazkEtpxI1nUrUdipR46lEracSNZ9K1H6uPxS7nFpQJWpClbANFbahwjZU2IYK29D3QHI+aDm2ocI2VNiGCttQYRtqbEONbaixDTW2oe9h+HzQcmxDjW2osQ01tqHGNjSwDQ1sQ7FWjwLbUCwzJKwzJCw0JKw0JCw1JKw1JCw2JKw2JCw3JKw3JCw4JKw4JCw5JKw5JCw6JKw6JCw7JKw7JCw8JKw8JCw9JKw9JCw+JKw+JCw/JKw/JCxAJKxAJCxBJKxBJCxCJKxCJCxDJKxDJCxEJKxEJCxFJKxFJCxGJKxGJCxHJKxHJCxIJKxIJCxJJKxJJCxKJKxKJCxLJKxLJCxMJKxMJCxNJKxNJCxOJKxOJCxPJKxPJCxQJKxQJCxRJKxRJCxSJKxSJCxTJKxTZKxTZKxTZKxTZKxT5ERtqLFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOkbFOUWCdosA6RYF1igLrFEWiNjSwTlFgnaLAOkWBdYoC6xQF1ikKrFMUWKcosE5RYJ2iwDpFgXWKAusUBdYpCqxTFFinKLBOUWCdosA6RYF1igLrFMUbnKKuQ8vXJZ6uo/Y/PuX1dam5ba5LrXl7Pcqe4xja3Oa0O3XkaX779/OVdvPL3+eX3LbHJR047tXT/6rXll4ebx62H9PDjiN62DcoSv/Rw+qYHtbH9LBxTA+bj+lhyzE9bD2Oh12/+D6/W8zPri/v17/y/LOH5flqcbPcvFz9uP39k/XtTw=="},{"name":"consume","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"_set_authorized","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"approver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"},{"name":"authorize","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/+2ZW2/jRBTHJ2nSbZeSxE2auLm0bpts2tyzbdpduuUNxDtvvCBgYUHiInERgo/Ip2LOmTn+x3Xk1VkVq0JrybF95v+bcxk78Wn7ZsuYnbKxW8/4zV7tmIrZtocC7R8bObMnRbsXKqYgJqcr0c66ktvXdWwa0CDNXhz46cwWn5HQjW6R74GfxGyf2o/qykh4AX08qRpn2KYLP+Vun5Iw13bfG0gSTw0badujD6chtx/0MdI3hU/t8UMnfurFlUHRGU0FWMVp9twpo3/ALGiVURJUgVaBVj36M8yC1hglQQ1oDWjNo9/ALGjAKAkCoAHQwKO/wyzoPqMk2Ae6D3Tfoz/ALGidURLUgdaB1j36C8yCNhglQQNoA2jDHdNINRux3iKYBT1glAQHQA+AHnj0S5gFbTJKgibQJtCmR3+DWdAWoyRoAW0BbXn0W5gFDRklQQg0BBqmyxPG66hEDrIRG+BXMAt6yCgJDoEeAj1MezuMnwwlEmQjNsDvYRa0zSgJ2kDbQNtpb+34nsxArLdfYRa0wygJOkA7QDtpb5344clArLe/YRa0yygJukC7QLtpb934hspArLfXMAvaY5QEPaA9oL20t178vCmRmh4J9Ug1l1zqDx6YXZ8fYRb0iFESHAE9Anrk0b9gFvSYURIcAz0GepwO9DguRwZivX0Ns6ARoySIgEZAo7S3KL5tlUhDj9T0SKhHerkg71Cxbi5F3tcjVT0S5FKxdi65PNp77CgbOSF7B2/nNwwavJLLOzipzUDe0+2MJYPthF2dJF2dOjhypzJCr/+nEPXxlj/Y5tOB1z+zX0+kGBZYOCQT7Rxx6K4kXWKGA5GdwbEbKDojDYqHPh0j6n3WwroX8HXBZ3vjNDTNblybHdRmN9m5PEFOtqplk9y4UtyOccFO3DQ7fppoUyX9ou364HY3IaVsJBGSJLN3W1rT7LjfhPvx0nbq4qWqnLqmTopU6rM70y/zseRLe+acvOLyyywDVGyYrNgzhDe0E35uj+dYKxJfcJLndAbswmmG7nR9eYEEeqSuR9p6JMxGbBnewCzoiFESjICOgI7S3kbxF6cSaeiRph7p6ZG6HgkePH27PguYBR0zSoIx0DHQcdrbOPamRKp6pK5HglxyCfVILxfkLRWzd8GfMAs6YZQEE6AToJO0t0n8lCqRbjZiA5zBLOiUURJMgU6BTtPepvHSKpFzPRLokboeaeuRUI9c6JFWLuvS1CO9XNYlyCWXt1TMPjc/wSzojFESzIDOgM7S3mbx39OUSFOPBHqk8VgDC/VI+zFUzN4438Es6JxREsyBzoHO097mcU5KpK5HpnqkkY3YMixhFnTBKAkWQBdAF2lvi/inKgOhfqn4GfqOOwYNmg3pLha+D/Fssotdsqtl0tVzBy/cqYxQY/Mcoiv0LyvXxa68/tp3sTeui6X2mlrNa474E3cl6RJzMxDZJRy7gaIz0qB4uKJjZGe6XQvrXsDX0hbfofFbxrUpoTbLZE921l8f2XJaVx0OJdq4JEvveiNSzkYQ3yJuTJd+koVrO5e+7Sy7drNsXLsZIf3LTct+mUzteX99RO4kEl3FryxXa6vrNJe+4BuRQI/U9Uhbj4R65EKPtPRIQ4809Ugvl3UJckl/lIuX6v+oYmEuN0w+99g4l6eyq0cmuSzl++/k99/J//XqN3Op2FSPVHLJJXisN0yQyyPWfqwVm+WSSz2XO/kd0p8/+E8SNV9bb9A33DFoki2B8WrXLl66GdfbxRW7WiVd+Xbuyp3KyCvXCYroBfqPl65dfOn1H/l28da1i7dkop0jfu2uJF1ibgciu4FjN1B0RhoUDy/oGNnrL9bCuhcwt4uU7Z37nx/tZYS+isu0jTKtku1V1F8f2fKTrOLVKW9cnbifPS94go7LM3IY/kP7v2DEW1sFKwAA","debug_symbols":"5dztbpNHEMXxe8lnVD0zO7Mzy61UVZXyUkVCAUGoVCHuvabYSVCsmtOmTf7Npyqwa8YZqSccHv8+nb189cvHX3++uHz99sPZ8x8/nb15++L86uLt5e6rT2fbD5Z//uqHd+eXX37hw9X5+6uz59uzs1eXL3f//fzs7PXFm1dnz4f752d3zsXw2B+NMfz69Mojh+fo3h+esY3bh3969mWU+Y9GscrDKNZxYhQfdRjF88go9f2jfL3Q6oUlXvBNvWDqBVcvDPVCqBdSvTDVC+qmXd20q5se6qaHuumhbnqomx7qpoe66aFueqibHuqmh7rpUDcd6qZD3XSomw5106FuOtRNh7rpUDcd6qZT3XSqm05106luOtVNp7rpVDed6qZT3XSqm57qpqe66alueqqbnuqmp7rpqW56qpue6qanuulSN13qpkvddKmbLnXTpW661E2XuulSN13qplvddKubbnXTrW661U23uulWN93qplvddKubXuqml7rppW56qZte6qaXuumlbnqpm17qppe6ads2+YbJN1y+MeQbId9I+caUb8gNyiZXKJu8c5N3bvLOTd65yTs3eecm79zkneutmV6byb2ZycWZyc2ZydWZyd2ZyeWZye2ZyfWZyf2ZyQWayQ2ayRWayR2aySWayS2ayTWayT2ayUWayU2ayVWayV2ayWWayW2ayXWayX2ayYWayY2ayZWayZ2ayaWaya2aybWayb2aycWayc2aydWayd2ayeWaye2ayfWayf2ayQWbyQ2byRWbyR2bySWbyS2byTWbyT2byUWbyU2byVWbyV2byWWbyW2byXWbyX2byYWbyY2byZWbyZ2byaWbya2bybWbyb2bycWbyc2bydWbtf6Eg7xzuX0zuX4zuX8zuYAzuYEzuYIzuYMzuYQzuYWzpT/Woj/XIj/YIvdwLvdwLvdwLvdwLvdwLvdwLvdwLvdwLvdwbvrDTPLO5R7O5R7O5R7O5R7O5R7O5R7O5R7O9efX9AfY/sYTbPLO9WfY9IfY9KfY9MfY9OfY9AfZ5B7O5R7O5R7Oh/7YorxzuYdzuYdzuYdzuYdzuYdzuYdzuYdzuYdzuYfz0J9VlXcu93Au93Au93Au93Au93Au93Au93Au93Au93Au93Au93Au93Au93Au93Au93Au93Au93Au93Au93Au93A+9afS5Z3LPZzLPZzL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"},{"name":"is_reject_all","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/83Z6W7bRhAH8NVhx4olirpM6rJli7RuO3HsFmibfCnQF+gDFL3RogfQA0VfsU/Vndkd/iUToTFBQIQArdXs/Di7SynmOompGXNSN/aYGn9QxATm2L5U6HxjpGUbVXtWAlORUEqdpKqpTzM1blFi/cr+OE2Ncye1B+qo0RUSU6HU4yNTcRWpnDlKuHlvz0Yqw3nm+ulo0A+XQ+wkQY+94Bf29blLfuaTT9OqC5pTsFOX03BNpn8jLLTJlBKaoE3Qpqe/ISy0xZQSWqAt0Jan3yIsNGBKCQFoABp4+hfCQttMKaEN2gZte/oTwkJDppQQgoagoae/Iyy0w5QSOqAd0I57zZNmMbHVZggL7TKlhC5oF7Sbr9bN5lZAbLU/ERbaY0oJPdAeaM/TrxAW2mdKCX3QPmjf0z8QFjpgSgkD0AHowNPvERZ6xpQSzkDPQM88/RlhoRFTSohAI9Aov7JRVk1JWnoS6EmvmNhl+BphoTFTSohBY9DY018QFjpkSglD0CHoMD/QdyYdPWnpSaQnzVLmEpYysCfui/0U/Iuw0BFTShiBjkBH+WqjbBkKiK32DcJCx0wpYQw6Bh3nq42zb62SdPSkpSeRnsSlkCdWzN6f7xAWOmFKCRPQCegkX22SLbaSdPUk0JOolCptPWmVMpe4FDIsJpcUb+F5+YGhwUOyPBVTtknlydlesW5wTLnU9LDUucMT15QeeiA/R9IMz92Xx9y89PlX/rl+XuHEOYXo5BE/d+9kuhSbp5J2gcKuo+qC1CkVZvQ6ozHsDevRgD+q+Nk+uByeY7q3tZGRTw/3EkeY0zQxR+bw4LvAWyKu5G9IzV+mwYOduH8G5IKNvX73mif1YnIwJJnM+af1vZyauzOPx0vHhRsvreHFETcb/m094XLm0u2+6rK8rshntC7Zil1hxZLDFZtjeIm94Jfuo1bzt5ySr3mSdKlrsGuXk7gmveZJoCehnvT1JComdhl+RFjogiklLEAXoIt8tUX2K0dJOnrS1ZNYT0I9Cd779O39eYGw0CVTSliCLkGX+WrLrJqSNPUk1JOglLlEehKXQp5YMfsp+AdhoSumlLACXYGu8tVW2bdUScbFxA7wBmGha6aUsAZdg67z1dbZrVWSVE8CPQn1pK8nkZ5c68mglPvS1ZO4lPsSlDKXJ1bMfm9+RVjohiklbEA3oJt8tU32t18l6epJoCedD3VgkZ70P4QVsx+cHxAWumVKCVvQLeg2X22bzUlJQj1Z60mnmNhleImw0B1TStiB7kB3+Wq77FdVAaEtR/UT7DteMzTYbMjugrLdLjZxV9zfxd5wqZvDUrcO71xTemhjc4ukl9i/3Lld7J3Pf+V3sfduF0vbzFd08og/du9kumTuU0l7gcKuo+qC1CkVaInvZvZK+8N6NGDexdJsX2O82JPV37onmy2qfp/HG7s9fJxtLYnc8lQ+pxaX8kfNXZzTblO/kqYRZLvH+htfn0/8X6ALuTxqzlxzRoxJw597hEPZHydm3CJQnVMz/o/O/wEpfgJCnxwAAA==","debug_symbols":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2b3U7bQBCF18GhBoOb2HGckEAIBaTehRSScMfLtM/d60p9haqss6Mclmm0UcdLVool5LG9O+ebsz+EyERqfSSvP5GJ2+Z8rN4f1ObFnGf/dzwI5po1yRkFwtkKhPMoEM5YkDNiOPU5NrFed3rNfVLr9fjuIXbWA30Ez9W2RLZqYgJ8eC1V6Wr2fAzJEVwZ8Ng8o7PGSc0zBEtNkXUbuEeFtuAe6RzBPdrBSCcxpgjX+5RskOXyvs4+XcOJyUXcKcT4bAzWxQ3V2Jav8bGRMXn1rqExqVcx+d42uRO4pjE4NbHgb44H1I7Mz6k1F2KIR9CW2pEfLWDVx7narJfTLf1iq18GbY6hn7230DWNtfaqa2J9btOeAPkb8HCm86byed+MTWx5l0JNGXgioz1f6fxn6u0RWdfXEGfAcy7Os1578nWux+4zsMvkfXrUXnUsr84srzJogwydBvyLQJdy03WH0ZbzYrHS2l0HL7oMT9ezF11GW9CLZ62dO3iRMzy5Zy9yRlvOi+U3rV04eFEwPIVnLwpGW86Lef0ZoOfgRY/h6Xn2osdoC66Rel6UDl6UDE/p2YuS0Rb04ofW7jt40Wd4+p696DPagl5819qVgxcVw1N59qJitAX3zvrzxcDBiwHDM/DsxYDRFvRirrWHDl4MGZ6hZy+GjLbgGqm1Lxy8uGB4Ljx7QXq7MvcCZK4CZC72gDmxYhntRb1/jhy8GDE8I89e4HcuuzCXe8CcWLGM9uJJa48dvBgzPGPPXpDersx5gMxFgMz9AJnLAJmrAJn3YT4nViyjvaz30EsHLy4ZnkvPXpDersx5gMyjAJmLPWBOrFhGe1l/N3fl4MUVw3Pl2QvS25V5ECBzdw+YEyuW0V4utPbEwYsJwzPx7AXp7co8DJC5CpB5FCBzESBzP0DmMkDmwxr0w5zvATO+e/S7UZ75c2rxkGfKYlQWYwpxBozU9kXJva+SWbWT1lTcj/X42POFrqeNas9XOu+XBmrSeW/l89Z/I9yZXPQO3y3j1b2JI+FxuoO8EejQ/RjiX9CW2pEftB8Qu36X68bE91v6Tax+GbS5gX63Vj+6prHW3v00cVNzy2Ved9RmLX8Fngb2wUd8J1eBV8pipGMCPNfyPA8N1TnDd/j+KNm1N7W8OrG8yqAN7tEftW8emA/M/2LGzxMncA956F7LqgX/v2EKOf4CARQXTpY1AAA=","debug_symbols":"ndpBattQGIXRvWgciu9v6T0pWymlOIlTDMYOsVMoJnuv3NIF9Mz0JN3ZNzq82/Cyf/r48f1wej1fhsevt+F4ft5dD+fTeroNmy81/3l7edud7i8u1937dXjctv4w7E8v61Ovz4fh9XDcr89Vn98e7qMFRtuNjCKjktFWRqOMJhk1GXUZSRFbKWKUIkYpYpQiRililCJGKWKUIkYpYpQiRilikiImKWKSIiYpYpIiJilikiImKWKSIiYpokkRTYpoUkSTIpoU0aSIJkU0KaJJEU2K6FJElyK6FNGliC5FdCmiSxFdiuhSRJciZililiJmKWKWImYpYpYiZililiJmKWKWIhYpYpEiFilikSIWKWKRIhYpYpEiFilikSKy2dAqtCpabWk10mqiVaNVp9VMK2oj1EaojVAboTZCbYTaCLURaiPURqiNojaK2ihqo6iNojaK2ihqo6gNAs2QaIZIM2SaIdQMqWaINUOuGYLNkGyGaDNkmyHcDOlmiDdDvhkCzpBwhogzZJwh5AwpZ4g5Q84Zgs6QdIaoM2SdIewMaWeIO0PeGQLPkHiGyDNkniH0DKlniD1D7hmCz5B8hugzZJ8h/AzpZ4g/Q/4ZAtCQgIYINGSgIQQNKWiIQUMOGoLQkISGKDRkoSEMDWloiENDHhoC0ZCIhkg0ZKIhFA2paIhFQy5a5KJFLlrkokUuWuSiRS5a5KJFLlrkokUuWuSiRS5a5KJFLlrkokUuWuSiRS5a5KJFLlrkokUuWuSiRS5a5KJFLlrkokUuWnbRk1y0yEWLXLTIRYtctMhFi1y0/ttF19PP3fth93Tc3+/23j9+nJ7/XfVdj9dfb3+/rP/+Bg=="}],"outputs":{"globals":{"storage":[{"fields":[{"name":"reject_all","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"approved_actions","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AuthRegistry::is_reject_all_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::is_reject_all_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"message_hash","type":{"kind":"field"}},{"name":"authorize","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::set_authorized_parameters"}}],"kind":"struct","path":"AuthRegistry::set_authorized_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"reject","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::set_reject_all_parameters"}}],"kind":"struct","path":"AuthRegistry::set_reject_all_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"message_hash","type":{"kind":"field"}}],"kind":"struct","path":"AuthRegistry::is_consumable_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::is_consumable_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"inner_hash","type":{"kind":"field"}}],"kind":"struct","path":"AuthRegistry::consume_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AuthRegistry::consume_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"approver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"message_hash","type":{"kind":"field"}},{"name":"authorize","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::_set_authorized_parameters"}}],"kind":"struct","path":"AuthRegistry::_set_authorized_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"approver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"message_hash","type":{"kind":"field"}},{"name":"authorize","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::set_authorized_private_parameters"}}],"kind":"struct","path":"AuthRegistry::set_authorized_private_abi"}]}},"file_map":{"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"125":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"127":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle<N>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<N>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<N>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n"},"132":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<N>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field\n) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number as Field, N)\n}\n\nunconstrained pub fn storage_read<T, N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"135":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n"},"140":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{\n    abis::{\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\n    utils::reader::Reader,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n}\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\n    let mut reader = Reader::new(fields);\n\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n    // WARNING: if updating, see comment in public_call_stack_item.ts's PublicCallStackItem.hash()\n    let item = PublicCallStackItem {\n        contract_address: AztecAddress::from_field(reader.read()),\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\n        public_inputs: PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            args_hash: reader.read(),\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            end_side_effect_counter: 0,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0\n        },\n        is_execution_request: true\n    };\n    reader.finish();\n\n    item\n}\n"},"144":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{hash::pedersen_hash, storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"146":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UnconstrainedContext> {\n    unconstrained pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"167":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{GAS_LENGTH, FIXED_DA_GAS, FIXED_L2_GAS}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\n    abis::gas_fees::GasFees\n};\nuse std::ops::{Add, Sub};\n\nstruct Gas {\n    da_gas: u32,\n    l2_gas: u32,\n}\n\nimpl Gas {\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\n        Self { da_gas, l2_gas }\n    }\n\n    pub fn tx_overhead() -> Self {\n        Self { da_gas: FIXED_DA_GAS, l2_gas: FIXED_L2_GAS }\n    }\n\n    pub fn compute_fee(self, fees: GasFees) -> Field {\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.da_gas == 0) & (self.l2_gas == 0)\n    }\n\n    pub fn within(self, limits: Gas) -> bool {\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\n    }\n}\n\nimpl Add for Gas {\n    fn add(self, other: Gas) -> Self {\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\n    }\n}\n\nimpl Sub for Gas {\n    fn sub(self, other: Gas) -> Self {\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\n    }\n}\n\nimpl Serialize<GAS_LENGTH> for Gas {\n    fn serialize(self) -> [Field; GAS_LENGTH] {\n        [self.da_gas as Field, self.l2_gas as Field]\n    }\n}\n\nimpl Deserialize<GAS_LENGTH> for Gas {\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\n    }\n}\n\nimpl Eq for Gas {\n    fn eq(self, other : Gas) -> bool {\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\n    }\n}\n\nimpl Empty for Gas {\n    fn empty() -> Self {\n        Gas::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Gas::empty();\n    let serialized = item.serialize();\n    let deserialized = Gas::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n"},"169":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr","source":"use crate::{\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct NoteHash {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for NoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteHash {\n    fn eq(self, other: NoteHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter) \n    }\n}\n\nimpl Empty for NoteHash {\n    fn empty() -> Self {\n        NoteHash {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl NoteHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNoteHash {\n        ScopedNoteHash { note_hash: self, contract_address }\n    }\n}\n\nstruct ScopedNoteHash {\n    note_hash: NoteHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<NoteHash> for ScopedNoteHash {\n    fn inner(self) -> NoteHash {\n        self.note_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNoteHash {\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNoteHash {\n    fn value(self) -> Field {\n        self.note_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl Eq for ScopedNoteHash {\n    fn eq(self, other: ScopedNoteHash) -> bool {\n        (self.note_hash == other.note_hash)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedNoteHash {\n    fn empty() -> Self {\n        ScopedNoteHash {\n            note_hash: NoteHash::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\n        array_concat(self.note_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            note_hash: reader.read_struct(NoteHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNoteHash {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.note_hash.value, read_request.value(), \"Value of the note hash does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the note hash does not match read request\");\n        assert(\n            read_request.counter() > self.note_hash.counter, \"Read request counter must be greater than the counter of the note hash\"\n        );\n    }\n}\n\nimpl ScopedNoteHash {\n    pub fn expose_to_public(self) -> NoteHash {\n        // Hide the actual counter when exposing it to the public kernel.\n        NoteHash { value: self.note_hash.value, counter: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = NoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"170":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"172":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr","source":"use crate::{\n    abis::{\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    transaction::tx_context::TxContext, utils::arrays::validate_array\n};\n\nstruct PrivateCircuitPublicInputsArrayLengths {\n    note_hash_read_requests: u32,\n    nullifier_read_requests: u32,\n    key_validation_requests_and_generators: u32,\n    note_hashes: u32,\n    nullifiers: u32,\n    l2_to_l1_msgs: u32,\n    private_call_requests: u32,\n    public_call_stack_hashes: u32,\n    note_encrypted_logs_hashes: u32,\n    encrypted_logs_hashes: u32,\n    unencrypted_logs_hashes: u32,\n}\n\nimpl PrivateCircuitPublicInputsArrayLengths {\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\n        PrivateCircuitPublicInputsArrayLengths {\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\n            note_hashes: validate_array(public_inputs.note_hashes),\n            nullifiers: validate_array(public_inputs.nullifiers),\n            l2_to_l1_msgs: validate_array(public_inputs.l2_to_l1_msgs),\n            private_call_requests: validate_array(public_inputs.private_call_requests),\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\n        }\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    note_hashes: [NoteHash; MAX_NOTE_HASHES_PER_CALL],\n    nullifiers: [Nullifier; MAX_NULLIFIERS_PER_CALL],\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs: [L2ToL1Message; MAX_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    tx_context: TxContext,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.returns_hash == other.returns_hash) &\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\n        (self.is_fee_payer == other.is_fee_payer) &\n        (self.max_block_number == other.max_block_number) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\n        (self.note_hashes == other.note_hashes) &\n        (self.nullifiers == other.nullifiers) &\n        (self.private_call_requests == other.private_call_requests) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.l2_to_l1_msgs == other.l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\n        self.historical_header.eq(other.historical_header) &\n        self.tx_context.eq(other.tx_context)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\n\n        fields.extend_from_array(self.max_block_number.serialize());\n\n        for i in 0..self.note_hash_read_requests.len() {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..self.nullifier_read_requests.len() {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..self.key_validation_requests_and_generators.len() {\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\n        }\n        for i in 0..self.note_hashes.len() {\n            fields.extend_from_array(self.note_hashes[i].serialize());\n        }\n        for i in 0..self.nullifiers.len() {\n            fields.extend_from_array(self.nullifiers[i].serialize());\n        }\n        for i in 0..self.private_call_requests.len() {\n            fields.extend_from_array(self.private_call_requests[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n        fields.push(self.public_teardown_function_hash);\n        for i in 0..self.l2_to_l1_msgs.len() {\n            fields.extend_from_array(self.l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        for i in 0..self.note_encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.unencrypted_logs_hashes.len() {\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.tx_context.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            is_fee_payer: reader.read() == 1,\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL]),\n            nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL]),\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            public_teardown_function_hash: reader.read(),\n            l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            tx_context: reader.read_struct(TxContext::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PrivateCircuitPublicInputs {\n    fn empty() -> Self {\n        PrivateCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter : 0 as u32,\n            end_side_effect_counter : 0 as u32,\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            tx_context: TxContext::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PrivateCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PrivateCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x15c9b0a92b9b541598e24c9f0b0b4b04b7f2408599751c45aa12de671fd9b363;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"173":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item_compressed.nr","source":"use crate::abis::{call_context::CallContext, function_data::FunctionData, gas::Gas};\nuse crate::address::AztecAddress;\nuse crate::constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH};\nuse crate::traits::{Hash, Empty, Serialize, Deserialize};\nuse crate::utils::reader::Reader;\n\n/**\n * A compressed version of the PublicCallStackItem struct used to compute the \"hash\"\n * of a PublicCallStackItem.\n * \n * Historically, we have been zeroing most values in the PublicCallStackItem struct\n * to compute the hash involved when adding a PublicCallStackItem to the PublicCallStack.\n * \n * This struct is used to store the values that we did not zero out, and allow us to hash\n * only these, thereby skipping a lot of computation and saving us a lot of constraints\n * \n * Essentially this struct exists such that we don't have a `hash` function in the \n * PublicCallStackItem struct that practically throws away some values of the struct\n * without clearly indicating that it does so.\n */\nstruct PublicCallStackItemCompressed {\n    contract_address: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    revert_code: u8,\n    start_gas_left: Gas,\n    end_gas_left: Gas,\n}\n\nimpl Eq for PublicCallStackItemCompressed {\n    fn eq(self, other: PublicCallStackItemCompressed) -> bool {\n        (self.contract_address == other.contract_address)\n            & (self.call_context == other.call_context)\n            & (self.function_data == other.function_data)\n            & (self.args_hash == other.args_hash)\n            & (self.returns_hash == other.returns_hash)\n            & (self.revert_code == other.revert_code)\n            & (self.start_gas_left == other.start_gas_left)\n            & (self.end_gas_left == other.end_gas_left)\n    }\n}\n\nimpl Hash for PublicCallStackItemCompressed {\n    fn hash(self) -> Field {\n        std::hash::pedersen_hash_with_separator(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PublicCallStackItemCompressed {\n    fn empty() -> Self {\n        PublicCallStackItemCompressed {\n            contract_address: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n    fn serialize(self) -> [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.push(self.revert_code as Field);\n        fields.extend_from_array(self.start_gas_left.serialize());\n        fields.extend_from_array(self.end_gas_left.serialize());\n\n        assert_eq(fields.len(), PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n  fn deserialize(fields: [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH]) -> PublicCallStackItemCompressed {\n    let mut reader = Reader::new(fields);\n\n    let item = PublicCallStackItemCompressed {\n      contract_address: reader.read_struct(AztecAddress::deserialize),\n      call_context: reader.read_struct(CallContext::deserialize),\n      function_data: reader.read_struct(FunctionData::deserialize),\n      args_hash: reader.read(),\n      returns_hash: reader.read(),\n      revert_code: reader.read() as u8,\n      start_gas_left: reader.read_struct(Gas::deserialize),\n      end_gas_left: reader.read_struct(Gas::deserialize),\n    };\n    reader.finish();\n    item\n  }\n}\n"},"175":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n"},"176":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr","source":"use crate::{\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for ReadRequest {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\n        ScopedReadRequest { read_request: self, contract_address }\n    }\n}\n\nstruct ScopedReadRequest {\n    read_request: ReadRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<ReadRequest> for ScopedReadRequest {\n    fn inner(self) -> ReadRequest {\n        self.read_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ScopedReadRequest {\n    fn eq(self, other: ScopedReadRequest) -> bool {\n        (self.read_request == other.read_request)\n        & (self.contract_address.eq(other.contract_address))\n    }\n}\n\nimpl Empty for ScopedReadRequest {\n    fn empty() -> Self {\n        ScopedReadRequest {\n            read_request: ReadRequest::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            read_request: reader.read_struct(ReadRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedReadRequest {\n    pub fn value(self) -> Field {\n        self.read_request.value\n    }\n    pub fn counter(self) -> u32 {\n        self.read_request.counter\n    }\n}\n\n#[test]\nfn serialization_of_empty_read() {\n    let item = ReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"179":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr","source":"use crate::{\n    address::AztecAddress,\n    abis::validation_requests::{\n    key_validation_request::KeyValidationRequest,\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\n},\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct KeyValidationRequestAndGenerator {\n    request: KeyValidationRequest,\n    sk_app_generator: Field,\n}\n\nimpl Eq for KeyValidationRequestAndGenerator {\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\n    }\n}\n\nimpl Empty for KeyValidationRequestAndGenerator {\n    fn empty() -> Self {\n        KeyValidationRequestAndGenerator {\n            request: KeyValidationRequest::empty(),\n            sk_app_generator: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\n        array_concat(self.request.serialize(), [self.sk_app_generator])\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\n        let mut reader = Reader::new(fields);\n        let res = Self {\n            request: reader.read_struct(KeyValidationRequest::deserialize),\n            sk_app_generator: reader.read(),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl KeyValidationRequestAndGenerator {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = KeyValidationRequestAndGenerator::empty();\n    let serialized = item.serialize();\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"180":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point::new(fields[0], fields[1], fields[2] as bool),\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"184":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr","source":"use crate::{\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH},\n    hash::compute_siloed_nullifier, traits::{Empty, Hash, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct Nullifier {\n    value: Field,\n    counter: u32,\n    note_hash: Field,\n}\n\nimpl Ordered for Nullifier {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for Nullifier {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for Nullifier {\n    fn eq(self, other: Nullifier) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.note_hash == other.note_hash) \n    }\n}\n\nimpl Empty for Nullifier {\n    fn empty() -> Self {\n        Nullifier {\n            value: 0,\n            counter: 0,\n            note_hash: 0,\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\n        [self.value, self.counter as Field, self.note_hash]\n    }\n}\n\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            note_hash: values[2],\n        }\n    }\n}\n\nimpl Readable for Nullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        // Public kernels output Nullifier instead of ScopedNullifier.\n        // The nullifier value has been siloed.\n        let siloed_request_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.value, siloed_request_value, \"Value of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl Nullifier {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\n        ScopedNullifier { nullifier: self, contract_address }\n    }\n}\n\nstruct ScopedNullifier {\n    nullifier: Nullifier,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<Nullifier> for ScopedNullifier {\n    fn inner(self) -> Nullifier {\n        self.nullifier\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNullifier {\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNullifier {\n    fn value(self) -> Field {\n        self.nullifier.value\n    }\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl Eq for ScopedNullifier {\n    fn eq(self, other: ScopedNullifier) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedNullifier {\n    fn empty() -> Self {\n        ScopedNullifier {\n            nullifier: Nullifier::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            nullifier: reader.read_struct(Nullifier::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.nullifier.value, read_request.value(), \"Value of the nullifier does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.nullifier.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl ScopedNullifier {\n    pub fn nullified_note_hash(self) -> Field {\n        self.nullifier.note_hash\n    }\n\n    pub fn expose_to_public(self) -> Nullifier {\n        // Hide the actual counter and note hash when exposing it to the public kernel.\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Nullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = Nullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"193":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"194":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr","source":"use crate::{\n    abis::{\n    private_call_stack_item::PrivateCallStackItem, call_context::CallContext,\n    function_data::FunctionData, caller_context::CallerContext,\n    side_effect::{Ordered, RangeOrdered, Scoped}\n},\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PrivateCallRequest {\n    target: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Ordered for PrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.start_side_effect_counter\n    }\n}\n\nimpl RangeOrdered for PrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.start_side_effect_counter\n    }\n    fn counter_end(self) -> u32 {\n        self.end_side_effect_counter\n    }\n}\n\nimpl Eq for PrivateCallRequest {\n    fn eq(self, other: PrivateCallRequest) -> bool {\n        (self.target == other.target) \n            & (self.call_context == other.call_context) \n            & (self.function_data == other.function_data) \n            & (self.args_hash == other.args_hash) \n            & (self.returns_hash == other.returns_hash)\n            & (self.caller_context == other.caller_context)\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\n    }\n}\n\nimpl Empty for PrivateCallRequest {\n    fn empty() -> Self {\n        PrivateCallRequest {\n            target: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.push(self.target.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.extend_from_array(self.caller_context.serialize());\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = PrivateCallRequest {\n            target: reader.read_struct(AztecAddress::deserialize),\n            call_context: reader.read_struct(CallContext::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            caller_context: reader.read_struct(CallerContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            end_side_effect_counter: reader.read_u32(),\n        };\n        reader.finish();\n        item\n    }\n}\n\nimpl PrivateCallRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\n        ScopedPrivateCallRequest { call_request: self, contract_address }\n    }\n\n    pub fn matches_stack_item(self, stack_item: PrivateCallStackItem) -> bool {\n        (self.target == stack_item.contract_address)\n            & (self.call_context == stack_item.public_inputs.call_context)\n            & (self.function_data == stack_item.function_data)\n            & (self.args_hash == stack_item.public_inputs.args_hash)\n            & (self.returns_hash == stack_item.public_inputs.returns_hash)\n            & (self.start_side_effect_counter\n                                == stack_item.public_inputs.start_side_effect_counter)\n            & (self.end_side_effect_counter\n                                    == stack_item.public_inputs.end_side_effect_counter)\n    }\n}\n\nstruct ScopedPrivateCallRequest {\n    call_request: PrivateCallRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\n    fn inner(self) -> PrivateCallRequest {\n        self.call_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedPrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.call_request.counter_start()\n    }\n}\n\nimpl RangeOrdered for ScopedPrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.call_request.counter_start()\n    }\n    fn counter_end(self) -> u32 {\n        self.call_request.counter_end()\n    }\n}\n\nimpl Eq for ScopedPrivateCallRequest {\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\n        (self.call_request == other.call_request)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedPrivateCallRequest {\n    fn empty() -> Self {\n        ScopedPrivateCallRequest {\n            call_request: PrivateCallRequest::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.call_request.serialize());\n        fields.extend_from_array(self.contract_address.serialize());\n\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = ScopedPrivateCallRequest {\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        item\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = ScopedPrivateCallRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"199":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\n    abis::gas_fees::GasFees,\n    constants::{\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\n    DEFAULT_INCLUSION_FEE\n},\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    utils::reader::Reader\n};\n\nstruct GasSettings {\n    gas_limits: Gas,\n    teardown_gas_limits: Gas,\n    max_fees_per_gas: GasFees,\n    inclusion_fee: Field,\n}\n\nimpl GasSettings {\n    pub fn new(\n        gas_limits: Gas,\n        teardown_gas_limits: Gas,\n        max_fees_per_gas: GasFees,\n        inclusion_fee: Field\n    ) -> Self {\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\n    }\n\n    pub fn default() -> Self {\n        GasSettings::new(\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\n            DEFAULT_INCLUSION_FEE\n        )\n    }\n}\n\nimpl Eq for GasSettings {\n    fn eq(self, other: Self) -> bool {\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\n    }\n}\n\nimpl Empty for GasSettings {\n    fn empty() -> Self {\n        GasSettings::new(\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\n        )\n    }\n}\n\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\n\n        serialized.extend_from_array(self.gas_limits.serialize());\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\n        serialized.push(self.inclusion_fee);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\n        let mut reader = Reader::new(serialized);\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasSettings::empty();\n    let serialized = item.serialize();\n    let deserialized = GasSettings::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"208":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr","source":"use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PrivateCallStackItem {\n    fn empty() -> Self {\n        PrivateCallStackItem {\n            contract_address: AztecAddress::empty(),\n            function_data: FunctionData::empty(),\n            public_inputs: PrivateCircuitPublicInputs::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = PrivateCallStackItem::empty();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item = PrivateCallStackItem::empty();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x065f2831db9ac0db5e710bd3a865b5facd8cf83f1585e1af8fd1d6ce9c47f685;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr","source":"use crate::address::AztecAddress;\nuse crate::traits::{Empty, Serialize, Deserialize};\nuse crate::constants::CALLER_CONTEXT_LENGTH;\nuse crate::utils::reader::Reader;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n    is_static_call: bool,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, other: CallerContext) -> bool {\n        other.msg_sender.eq(self.msg_sender)\n            & other.storage_contract_address.eq(self.storage_contract_address)\n            & other.is_static_call == self.is_static_call\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n            is_static_call: false,\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\n    }\n\n    // Different to an empty context, a hidden context won't reveal the caller's msg_sender and storage_contract_address,\n    // but will still propagate the is_static_call flag.\n    pub fn is_hidden(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array(self.msg_sender.serialize());\n    fields.extend_from_array(self.storage_contract_address.serialize());\n    fields.push(self.is_static_call as Field);\n\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\n    let mut reader = Reader::new(fields);\n\n    let item = CallerContext {\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\n      is_static_call: reader.read_bool(),\n    };\n    reader.finish();\n    item\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = CallerContext::empty();\n    let serialized = item.serialize();\n    let deserialized = CallerContext::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"211":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr","source":"use crate::{\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\n    constants::{\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\n},\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct LogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n}\n\nimpl Ordered for LogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for LogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for LogHash {\n    fn eq(self, other: LogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n    }\n}\n\nimpl Empty for LogHash {\n    fn empty() -> Self {\n        LogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n        }\n    }\n}\n\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length]\n    }\n}\n\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n        }\n    }\n}\n\nimpl LogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\n        ScopedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedLogHash {\n    log_hash: LogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<LogHash> for ScopedLogHash {\n    fn inner(self) -> LogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedLogHash {\n    fn eq(self, other: ScopedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedLogHash {\n    fn empty() -> Self {\n        ScopedLogHash {\n            log_hash: LogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(LogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the counter when exposing to public.\n        // The log hash must already be siloed when we call this.\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nstruct EncryptedLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    randomness: Field,\n}\n\nimpl Ordered for EncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for EncryptedLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for EncryptedLogHash {\n    fn eq(self, other: EncryptedLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.randomness == other.randomness) \n    }\n}\n\nimpl Empty for EncryptedLogHash {\n    fn empty() -> Self {\n        EncryptedLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            randomness: 0,\n        }\n    }\n}\n\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.randomness]\n    }\n}\n\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            randomness: values[3],\n        }\n    }\n}\n\nimpl EncryptedLogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedEncryptedLogHash {\n    log_hash: EncryptedLogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\n    fn inner(self) -> EncryptedLogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl ScopedEncryptedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the secret randomness and counter when exposing to public\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\n        // The log hash will already be silo'd when we call this\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nimpl Ordered for ScopedEncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedEncryptedLogHash {\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedEncryptedLogHash {\n    fn empty() -> Self {\n        ScopedEncryptedLogHash {\n            log_hash: EncryptedLogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct NoteLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    note_hash_counter: u32,\n}\n\nimpl NoteLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\n        LogHash { value: self.value, counter: 0, length: self.length }\n    }\n}\n\nimpl Ordered for NoteLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for NoteLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteLogHash {\n    fn eq(self, other: NoteLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.note_hash_counter == other.note_hash_counter) \n    }\n}\n\nimpl Empty for NoteLogHash {\n    fn empty() -> Self {\n        NoteLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            note_hash_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            note_hash_counter: values[3] as u32,\n        }\n    }\n}\n"},"215":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr","source":"struct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n"},"216":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n}\n// docs:end:call-context\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n"},"217":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"220":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize, Empty}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        (self.is_private == other.is_private)\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nimpl Empty for FunctionData {\n    fn empty() -> Self {\n        FunctionData {\n            selector: FunctionSelector::empty(),\n            is_private: false\n        }\n    }\n\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data = FunctionData::empty();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data = FunctionData::empty();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty function data hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"227":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n    counter: u32,\n}\n\nimpl Ordered for L2ToL1Message {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content, self.counter as Field]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\nimpl L2ToL1Message {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\n        ScopedL2ToL1Message { message: self, contract_address }\n    }\n}\n\nstruct ScopedL2ToL1Message {\n    message: L2ToL1Message,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\n    fn inner(self) -> L2ToL1Message {\n        self.message\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedL2ToL1Message {\n    fn counter(self) -> u32 {\n        self.message.counter\n    }\n}\n\nimpl Eq for ScopedL2ToL1Message {\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\n        (self.message == other.message)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedL2ToL1Message {\n    fn empty() -> Self {\n        ScopedL2ToL1Message {\n            message: L2ToL1Message::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            message: reader.read_struct(L2ToL1Message::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\n#[test]\nfn serialization_of_empty_l2() {\n    let item = L2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = L2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped_l2() {\n    let item = ScopedL2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"229":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"237":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr","source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  num_txs: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.num_txs);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let num_txs = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      num_txs,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      num_txs: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.num_txs == other.num_txs)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n"},"239":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr","source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"241":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n"},"243":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr","source":"use crate::{\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    abis::gas_settings::GasSettings\n};\n\n// docs:start:tx-context\nstruct TxContext {\n    chain_id : Field,\n    version : Field,\n    gas_settings: GasSettings,\n}\n// docs:end:tx-context\n\nimpl TxContext {\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\n        TxContext { chain_id, version, gas_settings }\n    }\n}\n\nimpl Eq for TxContext {\n    fn eq(self, other: Self) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.gas_settings.eq(other.gas_settings))\n    }\n}\n\nimpl Empty for TxContext {\n    fn empty() -> Self {\n        TxContext {\n            chain_id: 0,\n            version: 0,\n            gas_settings: GasSettings::empty(),\n        }\n    }\n}\n\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\n\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.extend_from_array(self.gas_settings.serialize());\n\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let context = Self {\n            chain_id: reader.read(),\n            version: reader.read(),\n            gas_settings: reader.read_struct(GasSettings::deserialize),\n        };\n\n        reader.finish();\n        context\n    }\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context = TxContext::empty();\n    let serialized = context.serialize();\n    let deserialized = TxContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let context = TxContext::empty();\n    let hash = context.hash();\n\n    // Value from tx_context.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"249":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n"},"263":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"289":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"322":{"path":"/usr/src/noir-projects/noir-contracts/contracts/auth_registry_contract/src/main.nr","source":"contract AuthRegistry {\n    use dep::aztec::{state_vars::{PublicMutable, Map}, protocol_types::address::AztecAddress};\n    use dep::authwit::auth::{IS_VALID_SELECTOR, compute_authwit_message_hash, assert_current_call_valid_authwit};\n\n    #[aztec(storage)]\n    struct Storage {\n      reject_all: Map<AztecAddress, PublicMutable<bool>>,\n      // on_behalf_of => authwit hash => authorized\n      approved_actions: Map<AztecAddress, Map<Field, PublicMutable<bool>>>,\n    }\n\n    /**\n     * Updates the `authorized` value for `msg_sender` for `message_hash`.\n     *\n     * @param message_hash The message hash being authorized\n     * @param authorize True if the caller is authorized to perform the message hash, false otherwise\n     */\n    #[aztec(public)]\n    fn set_authorized(message_hash: Field, authorize: bool) {\n        storage.approved_actions.at(context.msg_sender()).at(message_hash).write(authorize);\n    }\n\n    /**\n     * Updates the `reject_all` value for `msg_sender`.\n     * \n     * When `reject_all` is `true` any `consume` on `msg_sender` will revert.\n     * \n     * @param reject True if all actions should be rejected, false otherwise\n     */\n    #[aztec(public)]\n    fn set_reject_all(reject: bool) {\n        storage.reject_all.at(context.msg_sender()).write(reject);\n    }\n\n    /**\n     * Consumes an `inner_hash` on behalf of `on_behalf_of` if the caller is authorized to do so.\n     * \n     * Will revert even if the caller is authorized if `reject_all` is set to true for `on_behalf_of`.\n     * This is to support \"mass-revoke\".\n     *\n     * @param on_behalf_of The address on whose behalf the action is being consumed\n     * @param inner_hash The inner_hash of the authwit\n     * @return `IS_VALID_SELECTOR` if the action was consumed, revert otherwise\n     */\n    #[aztec(public)]\n    fn consume(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n        assert_eq(false, storage.reject_all.at(on_behalf_of).read(), \"rejecting all\");\n\n        let message_hash = compute_authwit_message_hash(\n            context.msg_sender(),\n            context.chain_id(),\n            context.version(),\n            inner_hash\n        );\n\n        let authorized = storage.approved_actions.at(on_behalf_of).at(message_hash).read();\n\n        assert_eq(true, authorized, \"unauthorized\");\n        storage.approved_actions.at(on_behalf_of).at(message_hash).write(false);\n\n        IS_VALID_SELECTOR\n    }\n\n    /**\n     * Updates a public authwit using a private authwit\n     * \n     * Useful for the case where you want someone else to insert a public authwit for you.\n     * For example, if Alice wants Bob to insert an authwit in public, such that they can execute\n     * a trade, Alice can create a private authwit, and Bob can call this function with it.\n     *\n     * @param approver The address of the approver (Alice in the example)\n     * @param message_hash The message hash to authorize\n     * @param authorize True if the message hash should be authorized, false otherwise\n     */\n    #[aztec(private)]\n    fn set_authorized_private(approver: AztecAddress, message_hash: Field, authorize: bool) {\n        assert_current_call_valid_authwit(&mut context, approver);\n        AuthRegistry::at(context.this_address())._set_authorized(approver, message_hash, authorize).enqueue(&mut context);\n    }\n\n    /**\n     * Internal function to update the `authorized` value for `approver` for `messageHash`.\n     * Used along with `set_authorized_private` to update the public authwit.\n     * \n     * @param approver The address of the approver\n     * @param message_hash The message hash being authorized\n     * @param authorize True if the caller is authorized to perform the message hash, false otherwise\n     */\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _set_authorized(approver: AztecAddress, message_hash: Field, authorize: bool) {\n        storage.approved_actions.at(approver).at(message_hash).write(authorize);\n    }\n\n    /**\n     * Fetches the `reject_all` value for `on_behalf_of`.\n     * \n     * @param on_behalf_of The address to check\n     * @return True if all actions are rejected, false otherwise\n     */\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_reject_all(on_behalf_of: AztecAddress) -> bool {\n        storage.reject_all.at(on_behalf_of).read()\n    }\n\n    /**\n     * Fetches the `authorized` value for `on_behalf_of` for `message_hash`.\n     * \n     * @param on_behalf_of The address on whose behalf the action is being consumed\n     * @param message_hash The message hash to check\n     * @return True if the caller is authorized to perform the action, false otherwise\n     */\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_consumable(on_behalf_of: AztecAddress, message_hash: Field) -> bool {\n        storage.approved_actions.at(on_behalf_of).at(message_hash).read()\n    }\n\n    unconstrained fn unconstrained_is_consumable(on_behalf_of: AztecAddress, message_hash: Field) -> pub bool {\n        storage.approved_actions.at(on_behalf_of).at(message_hash).read()\n    }\n}\n"},"54":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n    GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER, GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    CANONICAL_AUTH_REGISTRY_ADDRESS\n},\n    hash::pedersen_hash\n};\nuse dep::aztec::{prelude::Deserialize, context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties \n * (e.g. protocols or other users) to execute an action on their behalf.\n * \n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be \n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few \n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can \n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be \n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n * \n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer. \n * \n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is \n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n * \n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline \n * how this would look in private, and then in public later. \n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX). \n * `Alice` would make a `deposit` transaction, that she is executing using her account contract. \n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token` \n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to \n * convince the `Token` contract that it is allowed to do so. \n * \n * This is where the authentication witness comes in! The `Token` contract computes a `message_hash` from the \n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to \n * execute that call.\n * \n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her \n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n * \n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n * \n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts. \n * \n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *  \n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store \n * the messages that we have approved. \n * \n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `keccak256(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a colission and we return \n *      a success flag.\n * \n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be \n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the \n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n * \n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains. \n */\n\nglobal IS_VALID_SELECTOR = 0xabf64ad4; // 4 first bytes of keccak256(\"IS_VALID()\")\n\n/** \n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n * \n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([context.msg_sender().to_field(), context.selector().to_field(), context.args_hash]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/** \n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n * \n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n * \n * @param on_behalf_of The address that have authorized the current call\n * @param inner_hash The hash of the message to authorize  \n */\npub fn assert_inner_hash_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context.static_call_private_function(\n        on_behalf_of,\n        FunctionSelector::from_signature(\"verify_private_authwit(Field)\"),\n        [inner_hash]\n    ).unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier, 0);\n}\n\n/** \n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n * \n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n * \n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub fn assert_current_call_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash(\n        [(*context).msg_sender().to_field(), (*context).selector().to_field(), (*context).get_args_hash()]\n    );\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/** \n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n * \n * @param on_behalf_of The address that have authorized the the `inner_hash`\n */\npub fn assert_inner_hash_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    let result: Field = context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"consume((Field),Field)\"),\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default()\n    ).deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness \n * \n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n * \n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<N>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N]\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash = compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n * \n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n * \n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<N>(args: [Field; N]) -> Field {\n    pedersen_hash(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/** \n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n * \n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n * \n * @param on_behalf_of The address that have authorized the the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    pedersen_hash(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n * \n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(consumer: AztecAddress, chain_id: Field, version: Field, inner_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        consumer.to_field(),\n        chain_id,\n        version,\n        inner_hash\n    ],\n        GENERATOR_INDEX__AUTHWIT_OUTER\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n * \n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n * \n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"set_authorized(Field,bool)\"),\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n * \n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise \n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"set_reject_all(bool)\"),\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n"},"88":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::storage::{raw_storage_read, storage_read};\n\nstruct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = block_number_oracle();\n        let contract_address = contract_address_oracle();\n        let chain_id = chain_id_oracle();\n        let version = version_oracle();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<N>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n\n#[oracle(getContractAddress)]\nunconstrained fn contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn version_oracle() -> Field {}\n"},"89":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<N>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, N>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<N, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<N, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"95":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn block_number(self) -> Field {\n        block_number()\n    }\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<N>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<N>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, N>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N)\n}\n\nunconstrained fn storage_write<N>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<N>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<N>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}