{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"ContractInstanceDeployer","functions":[{"name":"deploy","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"contract_class_id","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId"},"visibility":"private"},{"name":"initialization_hash","type":{"kind":"field"},"visibility":"private"},{"name":"public_keys_hash","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::public_keys_hash::PublicKeysHash"},"visibility":"private"},{"name":"universal_deploy","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2b3U7bQBCF18GhBoOb2HGckEAIBaTehRSScMfLtM/d60p9haqss6Mclmm0UcdLVool5LG9O+ebsz+EyERqfSSvP5GJ2+Z8rN4f1ObFnGf/dzwI5po1yRkFwtkKhPMoEM5YkDNiOPU5NrFed3rNfVLr9fjuIXbWA30Ez9W2RLZqYgJ8eC1V6Wr2fAzJEVwZ8Ng8o7PGSc0zBEtNkXUbuEeFtuAe6RzBPdrBSCcxpgjX+5RskOXyvs4+XcOJyUXcKcT4bAzWxQ3V2Jav8bGRMXn1rqExqVcx+d42uRO4pjE4NbHgb44H1I7Mz6k1F2KIR9CW2pEfLWDVx7narJfTLf1iq18GbY6hn7230DWNtfaqa2J9btOeAPkb8HCm86byed+MTWx5l0JNGXgioz1f6fxn6u0RWdfXEGfAcy7Os1578nWux+4zsMvkfXrUXnUsr84srzJogwydBvyLQJdy03WH0ZbzYrHS2l0HL7oMT9ezF11GW9CLZ62dO3iRMzy5Zy9yRlvOi+U3rV04eFEwPIVnLwpGW86Lef0ZoOfgRY/h6Xn2osdoC66Rel6UDl6UDE/p2YuS0Rb04ofW7jt40Wd4+p696DPagl5819qVgxcVw1N59qJitAX3zvrzxcDBiwHDM/DsxYDRFvRirrWHDl4MGZ6hZy+GjLbgGqm1Lxy8uGB4Ljx7QXq7MvcCZK4CZC72gDmxYhntRb1/jhy8GDE8I89e4HcuuzCXe8CcWLGM9uJJa48dvBgzPGPPXpDersx5gMxFgMz9AJnLAJmrAJn3YT4nViyjvaz30EsHLy4ZnkvPXpDersx5gMyjAJmLPWBOrFhGe1l/N3fl4MUVw3Pl2QvS25V5ECBzdw+YEyuW0V4utPbEwYsJwzPx7AXp7co8DJC5CpB5FCBzESBzP0DmMkDmwxr0w5zvATO+e/S7UZ75c2rxkGfKYlQWYwpxBozU9kXJva+SWbWT1lTcj/X42POFrqeNas9XOu+XBmrSeW/l89Z/I9yZXPQO3y3j1b2JI+FxuoO8EejQ/RjiX9CW2pEftB8Qu36X68bE91v6Tax+GbS5gX63Vj+6prHW3v00cVNzy2Ved9RmLX8Fngb2wUd8J1eBV8pipGMCPNfyPA8N1TnDd/j+KNm1N7W8OrG8yqAN7tEftW8emA/M/2LGzxMncA956F7LqgX/v2EKOf4CARQXTpY1AAA=","debug_symbols":"ndpBattQGIXRvWhsiu9v6T3JWymlOIlTDMYOsVMoJnuv3dIF9Mz0JN3ZNzq82/Cyf/r48f1wej1fhu3X23A8P++uh/PpfroN6y81/3l7edudHi8u1937ddhuWl8N+9PL/anX52p4PRz3w7aW9vlt9RgtMNqsZRQZlYw2MhplNMmoyajLSIrYSBGjFDFKEaMUMUoRoxQxShGjFDFKEaMUMUoRkxQxSRGTFDFJEZMUMUkRkxQxSRGTFDFJEU2KaFJEkyKaFNGkiCZFNCmiSRFNimhSRJciuhTRpYguRXQpoksRXYroUkSXIroUMUsRsxQxSxGzFDFLEbMUMUsRsxQxSxGzFLFIEYsUsUgRixSxSBGLFLFIEYsUsUgRixSR9ZpWoVXRakOrkVYTrRqtOq1mWlEboTZCbYTaCLURaiPURqiNUBuhNkJtFLVR1EZRG0VtFLVR1EZRG0VtEGiGRDNEmiHTDKFmSDVDrBlyzRBshmQzRJsh2wzhZkg3Q7wZ8s0QcIaEM0ScIeMMIWdIOUPMGXLOEHSGpDNEnSHrDGFnSDtD3BnyzhB4hsQzRJ4h8wyhZ0g9Q+wZcs8QfIbkM0SfIfsM4WdIP0P8GfLPEICGBDREoCEDDSFoSEFDDBpy0BCEhiQ0RKEhCw1haEhDQxwa8tAQiIZENESiIRMNoWhIRUMsGnLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0bKLnuSiRS5a5KJFLlrkokUuWuSi9d8uej/93L0fdk/H/eNu7+Pjx+n531Xf+/H66+3vl/u/vwE="}],"outputs":{"globals":{},"structs":{"events":[{"fields":[{"name":"DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE","type":{"kind":"field"}},{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"version","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"salt","type":{"kind":"field"}},{"name":"contract_class_id","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId"}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"public_keys_hash","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::public_keys_hash::PublicKeysHash"}},{"name":"deployer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"ContractInstanceDeployer::ContractInstanceDeployed"}],"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"salt","type":{"kind":"field"}},{"name":"contract_class_id","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId"}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"public_keys_hash","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::public_keys_hash::PublicKeysHash"}},{"name":"universal_deploy","type":{"kind":"boolean"}}],"kind":"struct","path":"ContractInstanceDeployer::deploy_parameters"}}],"kind":"struct","path":"ContractInstanceDeployer::deploy_abi"}]}},"file_map":{"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"124":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::{address::AztecAddress, point::Point};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<M>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<M>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<M>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32\n) {}\n\nunconstrained pub fn emit_encrypted_event_log<M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<N, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<N, M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\n}\n"},"130":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs_traits.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n// TODO: this is awful but since we can't have a fn that maps [Field; N] -> [u8; 480 + N * 32]\n// (where N is the note pre-image size and 480 + N * 32 is the encryption output size)\n// The fns for LensForEncryptedLog are never used, it's just to tell the compiler what the lens are\n\n// The to_bytes fn for ToBytesForUnencryptedLog is used to allow us to hash some generic T\n\n// I could have omitted N from the trait, but wanted to keep it strictly for field arrs\n// TODO(1139): Once we enc inside the circuit, we will no longer need the oracle to return\n// anything, so we can remove this trait\ntrait LensForEncryptedLog<N, M> {\n    // N = note preimage input in fields\n    // M = encryption output len in bytes (= 480 + N * 32)\n    fn output_fields(self: [Field; N]) -> [Field; N];\n    fn output_bytes(self: [Field; N]) -> [u8; M];\n}\n\nimpl LensForEncryptedLog<1, 512> for [Field; 1] {\n    fn output_fields(self) -> [Field; 1] {[self[0]; 1]}\n    fn output_bytes(self) -> [u8; 512] {[self[0] as u8; 512]}\n}\nimpl LensForEncryptedLog<2, 544> for [Field; 2] {\n    fn output_fields(self) -> [Field; 2] {[self[0]; 2]}\n    fn output_bytes(self) -> [u8; 544] {[self[0] as u8; 544]}\n}\nimpl LensForEncryptedLog<3, 576> for [Field; 3] {\n    fn output_fields(self) -> [Field; 3] {[self[0]; 3]}\n    fn output_bytes(self) -> [u8; 576] {[self[0] as u8; 576]}\n}\nimpl LensForEncryptedLog<4, 608> for [Field; 4] {\n    fn output_fields(self) -> [Field; 4] {[self[0]; 4]}\n    fn output_bytes(self) -> [u8; 608] {[self[0] as u8; 608]}\n}\nimpl LensForEncryptedLog<5, 640> for [Field; 5] {\n    fn output_fields(self) -> [Field; 5] {[self[0]; 5]}\n    fn output_bytes(self) -> [u8; 640] {[self[0] as u8; 640]}\n}\nimpl LensForEncryptedLog<6, 672> for [Field; 6] {\n    fn output_fields(self) -> [Field; 6] {[self[0]; 6]}\n    fn output_bytes(self) -> [u8; 672] {[self[0] as u8; 672]}\n}\nimpl LensForEncryptedLog<7, 704> for [Field; 7] {\n    fn output_fields(self) -> [Field; 7] {[self[0]; 7]}\n    fn output_bytes(self) -> [u8; 704] {[self[0] as u8; 704]}\n}\nimpl LensForEncryptedLog<8, 736> for [Field; 8] {\n    fn output_fields(self) -> [Field; 8] {[self[0]; 8]}\n    fn output_bytes(self) -> [u8; 736] {[self[0] as u8; 736]}\n}\nimpl LensForEncryptedLog<9, 768> for [Field; 9] {\n    fn output_fields(self) -> [Field; 9] {[self[0]; 9]}\n    fn output_bytes(self) -> [u8; 768] {[self[0] as u8; 768]}\n}\nimpl LensForEncryptedLog<10, 800> for [Field; 10] {\n    fn output_fields(self) -> [Field; 10] {[self[0]; 10]}\n    fn output_bytes(self) -> [u8; 800] {[self[0] as u8; 800]}\n}\nimpl LensForEncryptedLog<11, 832> for [Field; 11] {\n    fn output_fields(self) -> [Field; 11] {[self[0]; 11]}\n    fn output_bytes(self) -> [u8; 832] {[self[0] as u8; 832]}\n}\nimpl LensForEncryptedLog<12, 864> for [Field; 12] {\n    fn output_fields(self) -> [Field; 12] {[self[0]; 12]}\n    fn output_bytes(self) -> [u8; 864] {[self[0] as u8; 864]}\n}\n\ntrait LensForEncryptedEvent<N, M> {\n    // N = event preimage input in bytes\n    // M = encryption output len in bytes (= 480 + M)\n    fn output(self: [u8; N]) -> [u8; M];\n}\n\nimpl LensForEncryptedEvent<96, 512> for [u8; 96] {\n    fn output(self) -> [u8; 512] {[self[0] as u8; 512]}\n}\nimpl LensForEncryptedEvent<128, 544> for [u8; 128] {\n    fn output(self) -> [u8; 544] {[self[0] as u8; 544]}\n}\nimpl LensForEncryptedEvent<160, 576> for [u8; 160] {\n    fn output(self) -> [u8; 576] {[self[0] as u8; 576]}\n}\nimpl LensForEncryptedEvent<192, 608> for [u8; 192] {\n    fn output(self) -> [u8; 608] {[self[0] as u8; 608]}\n}\nimpl LensForEncryptedEvent<224, 640> for [u8; 224] {\n    fn output(self) -> [u8; 640] {[self[0] as u8; 640]}\n}\nimpl LensForEncryptedEvent<256, 672> for [u8; 256] {\n    fn output(self) -> [u8; 672] {[self[0] as u8; 672]}\n}\n\n// This trait defines the length of the inputs in bytes to\n// the unencrypted log hash fn, where the log can be any type T\n// as long as the ACVM can convert to fields.\ntrait ToBytesForUnencryptedLog<N, M> {\n    // N = preimage input in bytes (32 * num fields or chars)\n    // M = full log input in bytes ( = N + 40 = N + 32 for addr, + 4 for selector, + 4 for len)\n    fn to_be_bytes_arr(self) -> [u8; N];\n    fn output_bytes(self) -> [u8; M];\n}\n\nimpl ToBytesForUnencryptedLog<32, 68> for Field {\n    fn to_be_bytes_arr(self) -> [u8; 32] {\n        self.to_be_bytes(32).as_array()\n    }\n    fn output_bytes(self) -> [u8; 68] {[self as u8; 68]}\n}\n\nimpl ToBytesForUnencryptedLog<32, 68> for AztecAddress {\n    fn to_be_bytes_arr(self) -> [u8; 32] {\n        self.to_field().to_be_bytes(32).as_array()\n    }\n    fn output_bytes(self) -> [u8; 68] {[self.to_field() as u8; 68]}\n}\n\nfn arr_to_be_bytes_arr<N, L>(fields: [Field; L]) -> [u8; N] {\n    let mut bytes: [u8] = &[];\n    for i in 0..L {\n        // Note that bytes.append() results in bound error\n        let to_add = fields[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes = bytes.push_back(to_add[j]);\n        }\n    }\n    bytes.as_array()\n}\n\n// each character of a string is converted into a byte\n// then an ACVM field via the oracle => we recreate here\nfn str_to_be_bytes_arr<N, L>(string: str<L>) -> [u8; N] {\n    let chars_bytes = string.as_bytes();\n    let mut bytes: [u8] = &[];\n    for i in 0..L {\n        let to_add = (chars_bytes[i] as Field).to_be_bytes(32);\n        for j in 0..32 {\n            bytes = bytes.push_back(to_add[j]);\n        }\n    }\n    bytes.as_array()\n}\n\nimpl ToBytesForUnencryptedLog<32, 68> for [Field; 1] {\n    fn to_be_bytes_arr(self) -> [u8; 32] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 68] {\n        [self[0] as u8; 68]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<64, 100> for [Field; 2] {\n    fn to_be_bytes_arr(self) -> [u8; 64] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 100] {\n        [self[0] as u8; 100]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<96, 132> for [Field; 3] {\n    fn to_be_bytes_arr(self) -> [u8; 96] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 132] {\n        [self[0] as u8; 132]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<128, 164> for [Field; 4] {\n    fn to_be_bytes_arr(self) -> [u8; 128] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 164] {\n        [self[0] as u8; 164]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<160, 196> for [Field; 5] {\n    fn to_be_bytes_arr(self) -> [u8; 160] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 196] {\n        [self[0] as u8; 196]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<192, 228> for [Field; 6] {\n    fn to_be_bytes_arr(self) -> [u8; 192] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 228] {\n        [self[0] as u8; 228]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<224, 260> for [Field; 7] {\n    fn to_be_bytes_arr(self) -> [u8; 224] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 260] {\n        [self[0] as u8; 260]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<256, 292> for [Field; 8] {\n    fn to_be_bytes_arr(self) -> [u8; 256] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 292] {\n        [self[0] as u8; 292]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<288, 324> for [Field; 9] {\n    fn to_be_bytes_arr(self) -> [u8; 288] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 324] {\n        [self[0] as u8; 324]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<320, 356> for [Field; 10] {\n    fn to_be_bytes_arr(self) -> [u8; 320] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 356] {\n        [self[0] as u8; 356]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<352, 388> for [Field; 11] {\n    fn to_be_bytes_arr(self) -> [u8; 352] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 388] {\n        [self[0] as u8; 388]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<384, 420> for [Field; 12] {\n    fn to_be_bytes_arr(self) -> [u8; 384] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 420] {\n        [self[0] as u8; 420]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<416, 452> for [Field; 13] {\n    fn to_be_bytes_arr(self) -> [u8; 416] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 452] {\n        [self[0] as u8; 452]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<448, 484> for [Field; 14] {\n    fn to_be_bytes_arr(self) -> [u8; 448] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 484] {\n        [self[0] as u8; 484]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<480, 516> for [Field; 15] {\n    fn to_be_bytes_arr(self) -> [u8; 480] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 516] {\n        [self[0] as u8; 516]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<512, 548> for [Field; 16] {\n    fn to_be_bytes_arr(self) -> [u8; 512] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 548] {\n        [self[0] as u8; 548]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<544, 580> for [Field; 17] {\n    fn to_be_bytes_arr(self) -> [u8; 544] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 580] {\n        [self[0] as u8; 580]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<576, 612> for [Field; 18] {\n    fn to_be_bytes_arr(self) -> [u8; 576] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 612] {\n        [self[0] as u8; 612]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<608, 644> for [Field; 19] {\n    fn to_be_bytes_arr(self) -> [u8; 608] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 644] {\n        [self[0] as u8; 644]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<640, 676> for [Field; 20] {\n    fn to_be_bytes_arr(self) -> [u8; 640] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 676] {\n        [self[0] as u8; 676]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<672, 708> for [Field; 21] {\n    fn to_be_bytes_arr(self) -> [u8; 672] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 708] {\n        [self[0] as u8; 708]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<704, 740> for [Field; 22] {\n    fn to_be_bytes_arr(self) -> [u8; 704] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 740] {\n        [self[0] as u8; 740]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<736, 772> for [Field; 23] {\n    fn to_be_bytes_arr(self) -> [u8; 736] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 772] {\n        [self[0] as u8; 772]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<768, 804> for [Field; 24] {\n    fn to_be_bytes_arr(self) -> [u8; 768] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 804] {\n        [self[0] as u8; 804]\n    }\n}\n\nimpl<N,M,L> ToBytesForUnencryptedLog<N, M> for str<L> where [Field; L]: ToBytesForUnencryptedLog<N,M> {\n    fn to_be_bytes_arr(self) -> [u8; N] {\n        str_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; M] {\n        [0; M]\n    }\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"236":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"// Utility function to console.log data in the acir simulator\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<M, N>(_msg: str<M>, args: [Field]) {}\n\n/// NOTE: call this with a str<N> msg of form\n/// \"some string with {0} and {1} ... {N}\"\n/// and an array of N field which will be formatted\n/// into the string in the simulator.\n/// Example:\n/// debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n/// debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\nunconstrained pub fn debug_log_format<M, N>(msg: str<M>, args: [Field; N]) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n/// NOTE: call this with a str<N> msg of length > 1\n/// Example:\n/// `debug_log(\"blah blah this is a debug string\");`\nunconstrained pub fn debug_log<N>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"292":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\n    address::{\n    eth_address::EthAddress, salted_initialization_hash::SaltedInitializationHash,\n    aztec_address::AztecAddress\n},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::pedersen_hash, traits::{ToField, FromField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH = 1;\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n       PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            pedersen_hash(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"293":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\n    address::{eth_address::EthAddress, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            pedersen_hash(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"296":{"path":"/usr/src/noir-projects/noir-contracts/contracts/contract_instance_deployer_contract/src/main.nr","source":"contract ContractInstanceDeployer {\n    use dep::aztec::protocol_types::{\n        address::{AztecAddress, EthAddress, PublicKeysHash, PartialAddress},\n        contract_class_id::ContractClassId, constants::DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE,\n        traits::Serialize, abis::log_hash::LogHash\n    };\n    use dep::aztec::{\n        context::PrivateContext, hash::compute_unencrypted_log_hash,\n        oracle::logs::emit_unencrypted_log_private_internal\n    };\n\n    #[aztec(event)]\n    struct ContractInstanceDeployed {\n        DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE: Field,\n        address: AztecAddress,\n        version: u8,\n        salt: Field, \n        contract_class_id: ContractClassId, \n        initialization_hash: Field, \n        public_keys_hash: PublicKeysHash, \n        deployer: AztecAddress,\n    }\n\n    #[aztec(private)]\n    fn deploy(\n        salt: Field,\n        contract_class_id: ContractClassId,\n        initialization_hash: Field,\n        public_keys_hash: PublicKeysHash,\n        universal_deploy: bool\n    ) {\n        // TODO(@spalladino): assert nullifier_exists silo(contract_class_id, ContractClassRegisterer)\n\n        let deployer = if universal_deploy {\n            AztecAddress::zero()\n        } else {\n            context.msg_sender()\n        };\n\n        let partial_address = PartialAddress::compute(contract_class_id, salt, initialization_hash, deployer);\n\n        let address = AztecAddress::compute(public_keys_hash, partial_address);\n\n        // Emit the address as a nullifier to be able to prove that this instance has been (not) deployed\n        context.push_nullifier(address.to_field(), 0);\n\n        // Broadcast the event\n        let event = ContractInstanceDeployed {\n            DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE,\n            contract_class_id,\n            address,\n            public_keys_hash,\n            initialization_hash,\n            salt,\n            deployer,\n            version: 1\n        };\n\n        let payload = event.serialize();\n        dep::aztec::oracle::debug_log::debug_log_format(\"ContractInstanceDeployed: {}\", payload);\n\n        let contract_address = context.this_address();\n        let counter = context.next_counter();\n\n        // @todo This is very inefficient, we are doing a lot of back and forth conversions.\n        let log_slice = payload.to_be_bytes_arr();\n        let log_hash = compute_unencrypted_log_hash(contract_address, payload);\n        // 40 = addr (32) + raw log len (4) + processed log len (4)\n        let len = 40 + log_slice.len().to_field();\n        let side_effect = LogHash { value: log_hash, counter, length: len };\n        context.unencrypted_logs_hashes.push(side_effect);\n\n        let _void = emit_unencrypted_log_private_internal(contract_address, payload, counter);\n    }\n}\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"}}}