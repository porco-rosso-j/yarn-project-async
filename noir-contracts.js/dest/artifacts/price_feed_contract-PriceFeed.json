{ "noir_version": "0.24.0+78ef0134b82e76a73dadb6c7975def22290e3a1a", "name": "PriceFeed", "functions": [{ "name": "compute_note_hash_and_nullifier", "function_type": "Unconstrained", "is_internal": false, "abi": { "parameters": [{ "name": "contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "nonce", "type": { "kind": "field" }, "visibility": "private" }, { "name": "storage_slot", "type": { "kind": "field" }, "visibility": "private" }, { "name": "note_type_id", "type": { "kind": "field" }, "visibility": "private" }, { "name": "serialized_note", "type": { "kind": "array", "length": 20, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "contract_address": [{ "start": 0, "end": 1 }], "nonce": [{ "start": 1, "end": 2 }], "note_type_id": [{ "start": 3, "end": 4 }], "serialized_note": [{ "start": 4, "end": 24 }], "storage_slot": [{ "start": 2, "end": 3 }] }, "return_type": { "abi_type": { "kind": "array", "length": 4, "type": { "kind": "field" } }, "visibility": "public" }, "return_witnesses": [24, 25, 26, 27] }, "bytecode": "H4sIAAAAAAAA/+2YS1KEQAyG09C8wefooLPhCFCycOldvP8VLIl25AedlelFqiZVXfQDOl9CV0g4EZGjb0mXltFvkfW3cB3/J5PiXmNMTmeEMzHCmSpyMtuB4p5TH8Gv2oyZAcbcAGNhgLE0wFgZYKwNMDYGGFsDjJ0BxisDjNcGGG8MMN4aYLwzwHhvgPFggPHBAOOjAcajIqMDRh/6/dKelva8tNPSXsJ8SasMWgzz9M45uyjvaSucmyQy8OtcKtwwJ/wJzMk/htSvNuTqNowz71to7xtqhR787/X9/1qCnxTZY/nk68zKWczD3qInA19Voa/4b2VC3S60CnRSeEfSP9IqFfTlTAt3S+u5rM4843fPdLCe/2H3oGx3ASwDjEVfFuxg4fyo91tuZqv12eaGtrGJxe3GA/TryL6KZOfI+zZhrw/S/U614J9y56cO1hu4p43gOwd6ZW8ZI+OF98KLDPWOtYH1CuaSnS2YS+D9+/ihapAoxGTHBThe44DJwZSDekFroKrBMH4JXMxzsczBlos9Lqa4WOFigJNtTmbxA3QuwfuRT4hpJ8qiGQAA", "debug_symbols": "q1bKyU9OLMnMzytWsqqu1VEqSyzKTEzKSYVySyoLIMxaAA==" }, { "name": "get_price", "function_type": "Open", "is_internal": false, "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "public_global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] }, "visibility": "private" }, { "name": "asset_id", "type": { "kind": "field" }, "visibility": "private" }], "param_witnesses": { "asset_id": [{ "start": 39, "end": 40 }], "inputs": [{ "start": 0, "end": 39 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::public_circuit_public_inputs::PublicCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "contract_storage_update_requests", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_update_request::StorageUpdateRequest", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "new_value", "type": { "kind": "field" } }] } } }, { "name": "contract_storage_reads", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_read::StorageRead", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "current_value", "type": { "kind": "field" } }] } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "prover_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] }, "visibility": "public" }, "return_witnesses": [40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233] }, "bytecode": "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", "debug_symbols": "1d3dbmXZdd3xd+lrIdjzey69SpALJXEAA4ZjWEKAwNC75xgpsiSIUPdgedH/unKpcNY+E57c47AG+ev9b7/80//+H3/40z/+73/+4y+//7dfnv/icX75/X/9t1/++C9/+Od//5s//ukP//qnX37//O6Xf/jn//n6v3/+3S//6x//6R9++b338+f/9rt/P5GPfMLkEy6fCPlEyifqt5/43d+8LsK+vTLqvL/Wnn67el+9+ly9+l69+rl59XquXt2uXt2vXj2uXj2vXv3qvVpX79W6eq/W1Xu1rt6rffVe7av3al+9V/vqvdpX79X+oXvV6nx7pa391dU/eO3svL14dr+/+tjbLA2aZUCzLGiWw5llHtAsBprFQbMEaJYEzQLK3QHl7oByd0C5O6DcXVDuLih3F5S7C8rdBeXugnJ3Qbm7oNxdUO4uKHcPKHcPKHcPKHcPKHcPKHcPKHcPKHcPKHcPKHcPJ3fj4eRuPJzcjYeTu/FwcjceTu7Gw8ndeDi5Gw8nd+Ph5G48oNw1UO4aKHcNlLsGyl0D5a6BctdAuWug3DVQ7hoodx2Uuw7KXQflroNy10G566DcdVDuOih3HZS7DsrdAOVugHI3QLkboNwNUO4GKHcDlLsByt0A5W6AcjdBuZug3E1Q7iYodxOUuwnK3QTlboJyN0G5m6DcLVDuFih3C5S7BcrdAuVugXK3QLlboNwtUO4WKHcblLsNyt0G5W6DcrdBuQvyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagHyagnyagnyagnyagnyavlwcjdBXi1BXi2/0EJt5PuLqz6axUCzfNnXruf7jl5//HBHBZqlQbMMaJYFzfJ13zPYa4K3V1ue79e2yW/TfKH6+S3TfFnGeLm/7anW/2pP2qu/Te4/7eTBnPz1NeL1/etlz0ez5088e/3Eswt5+u2E+l+9z3jkEyafcPlEyCd+6GvUw96+F/LIeH917dvl6+7l++7l5+7l9+7lz9XL/5hQiGfePm5ffzwfXN7uXt7vXj7uXj7vXr7uXr7VlFJ+c/7bCfkzIOXPgJI/A0r+DCj5M6DkzwDld5i/nSj5hLzzknde8s5L3nnLO2955y3vvOWdt7zzlnfe8s5b3nnLO2955yPvfOSdj7zzkXc+8s5H3vnIOx955yPvfOSdr7zzlXe+8s5X3vnKO1955yvvfOWdr7zzlXd+5J0feedH3vmRd37knR9550fe+ZF3fuSdH3Xn9TzyCZNPuHwi5BMpnyj5RMsnRj6x8gl55ybv3OSdm7xzk3du8s5N3rnJOzd55ybv3OSdu7xzl3fu8s5d3rnLO3d55y7v3OWdyx1tyR1tyR1tyR1tyR1tyR1thbzzkHce8s5D3nnIO5efRlvy02hLfhptyU+jLflptCU/jbZS3rncw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw5Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw7Xcw/XKO5d7uJZ7uJZ7uJZ7uJZ7uJZ7uJZ7uJZ7uJZ7uJZ7uJZ7uJZ7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJF7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uJV7uCP3cEfu4Y7cwx25hztyD3fkHu7IPdyRe7gj93BH7uGO3MMduYc7cg935B7uyD3ckXu4I/dwR+7hjtzDHbmHO3IPd+Qe7sg93JF7uCP3cEfu4Y7cwx25hztyD3fkHu7IPdyRe7gj93BH7uGO3MMduYc7cg935B7uyD3ckXu4I/dwR+7hjtzDHbmHO3IPd+Qe7sg93JF7uCP3cEfu4Y7cwx25hztyD3fkHu7IPdyRe7gj93BH7uGO3MMduYc7cg935B7uyD3ckXu4I/dwR+7hjtzDHbmHO3IPd+Qe7sg93JF7uCP3cEfu4Y7cwx25hztyD3fkHu7IPdyRe7gj93BH7uGO3MMduYc7cg935B7uyD3ckXu4I/dwR+7hjtzDHbmHO3IPd+Qe7sg93JF7uCP3cEfu4Y7cwx25h7NHLuJeR0w/4vqR0I+kfqT0I60fGf3I6kf07Zu+fdO3b/r2Td++6ds3ffumb9/07Zu+fdO37/r2Xd++69t3ffuub9/17bu+fde37/r2Xd9+6NsPffuhbz/07Ye+/dC3H/r2Q99+6NsPffupbz/17ae+/dS3n/r2U99+6ttPffupbz/17Ze+/dK3X/r2S99+6dsvffulb7/07Ze+/dK33/r2W99+69tvffutb7/17be+/da33/r2W9/+6Nsfffujb3/07Y++/dG3P/r2R9/+6Nsfffurb3/17a++/dW3v/r2V9/+6ttfffurb3/17R99+0ff/tG3f/TtH337R9/+0bd/9O0ffft612d612d612d612d61/f6rlc/UvqR1o+MfmT1I/r29a7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9K7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a7P9a4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v9K4v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KQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQbLKQYrKAYrKAYrKAYrKAYrHkiyBsVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgBcVgJcVgJcVgJcVgJcVg5QNJ1qQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKQYrKIYrKIYrKIYrKIYrHogyVoUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg1UUg9UUg9UUg9UUg9UUg9UPJFmbYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCaYrCGYrCGYrCGYrCGYrDmgSTrUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUAzWUgzWUgzWUgzWUgzWPpBkXYrBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWorBWsVgfTuiaKm3I6Yfcf1I6EdSP1L6kdaPjH5k9SP69kvf/o/Zi79/ab936bh36bx36bp36b536bl36b136XPt0j/22/1//9L37sa+dzf2hbvxgw/Ws99e2Vbvr7Xn+xjJGKMYYzRjjGGMsYwxDmKMeRhjGGMMZ4zBSNFhpOjc+15p7n2vNPe+V5p73yvNve+V9t73Snvve6W9973S3vuXy+a9S9+7G/fe3bj6v9NX/3f66v9OP/q/04/e0hy9pTl6S6P85urbEb2lOXpLc/TtH337R97+eR79iOlHXD8S+pHUj5R+pPUjox9Z/Yi+fdO3//HvQM3Wt0Nr/isxefLttefsX3279UErbelvr379ec/31x97H8l5IwVvpOSNVLyRmjfS8EZa3kgHN9LHv131nzsSL72dl97OS2/npbfz0tt56e0X0/vtLfb+W5zrbxHP/bew+2/h998i7r9F3n+Luv8Wff8t7t/dcf/ujh++u+2ZeE/CeH4lOP/uPzDzIQ1jpGGcNEyQhknSMEUapknDDGmYJQ1DSuAiJXAhEvhvX9env71yLN5fe+Z9bkRYf2JuRK5/Ym7ER8An5kZ8WnxibsQHyyfmRnwGfWJuxMfVJ+ZGfLLpczfiQ/ATc/+kn5f9k35e9k/6edk/6edl/6Sfl/2Tfl62+Hn5dmw/d+x86tg8nztmnzvmnzsWnzuWnztWnzvWnzv2ua+S+dxXyfzqV8n5tXvJ/LzfS/385df93744xr+9Nv/iFpn3H/HswxrHWOM4a5xgjZOscYo1TrPGGdY4yxqHlcqHlcqHlcqHlcqHlcqHlcqHlcqHlcqHlcqHlcqHlMrxPKRUfo1DSuXXOKRUfo1DSuXXOKRUfo1DSuXXOKRUfo1DSuXXOKRUfo3DSmVjpbKxUtlYqWysVDZWKhsrlY2VysZKZWOlsrFS2Vmp7KxUdlYqOyuVnZXKzkplZ6Wys1LZWansrFQOVioHK5WDlcrBSuVgpXKwUjlYqRysVA5WKgcrlZOVyslK5WSlcrJSOVmpnKxUTlYqJyuVk5XKyUrlYqVysVK5WKlcrFQuVioXK5WLlcrFSuVipXKxUrlZqdysVG5WKjcrlZuVys1K5WalcrNSuVmp3KxUHlYqDyuVh5XKw0rlYaXysFJ5WKk8rFQeViqjbF88KNv3GoeVyijb9xqHlcoo2/cah5XKKNv3GoeVyijb9xqHlcoo2/cah5XKKNv3GoeVyijb9xqHlcoo2/cah5XKKNv3GgeVysayfcayfcayfcayffagUtlYts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Zts9Zts9Zts9Zts8fVCo7y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/YFy/YFy/YFy/YFy/bFg0rlYNm+UG3f27H53LH93LHzqWOqPXs7Zp875p87Fp87lp87Vp879rmvEvvcV8mv2x3/lVvk5Ntrz9n319rz8e2UXu/3U+73key83ya/7ne+fKRfNzxfP5LxRnLeSMEbKXkjFW+k5o00vJF46e289A5eegcvvYOX3sFL7+Cld1xM77e36PtvMfffYu+/xbn+Fvncfwu7/xZ+/y3i/lvk/be4f3fn/bs7f/jutmfiPQnj+ZXgfL699PnzB//mzSUNc0DD1EMaxkjDOGmYIA2TpGGKNEyThiElcJESuBAJ/Lev69PfXjl/8eOE108evs3diLD+xNyIXP/E3IiPgE/Mjfi0+MTciA+WT8yN+Az6xNyIj6tPzI34ZPvE3IgPwU/M/ZN+Xs5P+nk5P+nn5fykn5fzk35e/jofgs79k35ezk/6eTni5+Xbsf3csfOpY/t87ph97ph/7lh87lh+7lh97lh/7tjnvkr2c18lLJkQLJkQLJkQLJkQLJkQLJkQLJkQLJkQLJkQLJkQLJmQLJmQLJmQLJmQLJmQDyqVkyUTkvXUoWQ9dShZTx1K1lOHkvXUoWQ9dShZTx1K1lOHkvXUoWQ9dShZTx1K1lOHkvXUoWQ9dShZTx1K1lOHkvXUoWQ9dShZTx1K1lOHkvXUoWQ9dShZTx1K1lOHkvXUoWQ9dShZTx1K1lOHkvXUoWQ9dShZTx1K1lOHkvXUoWQ9dShZTx1K1lOHkvXUoWQ9dShZTx1K1lOHkvXUoWQ9dShZTx1K1lOHkvXUoWQ9dShZTx1K1lOHkvXUoWQ9dShZTx1K1lOHkvXUoWQ9dShZTx1K1lOHkvXUoWQ9dShZTx1K1lOHkvXUoWQ9dShZTx1K1lOHkvXUoWQ9dShZTx1K1lOHkvXUoWQ9dShZTx1K1lOHkvXUoWQ9dShZTx1K1lOHkvXUoWQ9dShZTx1K1lOHkvXUoWQ9dShZTx1Klu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu1Llu0rlu0rlu0rlu0rlu2rB5XKxbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9xbJ9zbJ9zbJ9zbJ9zbJ9/aBSuVm2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r1m2r6/avrf3mC94j/2C9zj33+M/wsvN8/4ex//+l0fGvn155Hy/cJ33eQw2j8PmCdg8CZunYPM0bJ75z5qn6sN5FjXPfGyx3t7g+bVZfPptFt/vC4j3y8fdy/cPXT7s7f/tFv7R5efu5ffu5c/Vy3+saf7jLm93L+93Lx93L593L193L3/3rrW7d63dvWvt7l3rwl37dsT0I64fCf1I6kdKP9L6kdGPrH7kyEdC337o2w99+6FvP/Tth7790Lcf+vZD337o2099+6lvP/Xtp7791Lef+vZT337q2099+6lvv/Ttl7790rdf+vZL337p2y99+6Vvv/Ttl7791rff+vZb337r2299+61vv/Xtt7791rff+vZH3/7o2x99+6Nvf/Ttj7790bc/+vZH3/7o2199+6tvf/Xtr7791be/+vZX3/7q2199+6tv/+jbP/r2j779o2//6Ns/+vaPvv2jb//o2z/y9vd59COmH3H9SOhHUj9S+pHWj4x+ZPUj+vZN377p2zd9+6Zv/8c6z+x++8lw9nx/de379evy9fvy9efy9ffy9c/d6/tz+fp2+fp++fpx+fqX71+/fP/65fvXL9+/fvn+9cv3b1y+f+Py/RuX79+4fP/G5fs3Lt+/cfn+jcv3b1y+f+Py/ZuX79+8fP/m5fs3L9+/efn+zcv3b16+f/Py/ZuX79+8fP/W5fu3Lt+/dfn+rbv375mrv0p3Ju9evu5evu9efu5efu9e/ly9/D53L3/1FwHP+t3L/+AvAoa9Xz7OB5fPu5evu5fvu5efu5ffu5c/Vy9/nruXt7uX97uXv3vXnrt37bl71567d+25e9eeu3ftufnru/k8z93L293L+93Lx93L593L193L993Lz93L793L371r7e5da3fvWrt719rdu9bu3rV29661u3et3b1r7e5da3fvWr971/rdu9bv3rV+9671u3et371r/e5d63fvWr971/rduzbu3rVx966Nu3dt3L1r4+5dG3fv2rh71/7Yz1et3v/DJmvvr7WnP3rtnvd/pO5f/BcC7NjbMD/2w9j/6GGMNIyThgnSMPllw5x4u6yd6g+HKdIwTRpmSMMsaZgDGqa+LoFfPzr+9mJ//WP+w2GMNMyX5Yw/9X2Yyg+HKdIwTRpmSMMsaZgDGqYf0jBGGsZJwwRpGFICNymBm5TATUrgJiVwkxJ4SAk8pAQeUgIPKYGHlMBDSuAhJfCQEnhICTykBF5SAi8pgZeUwEtK4CUl8JISeEkJvKQEXlICLymBDymBDymBDymBDymBDymBDymBDymBDymBDymBDyiB7QElsD2gBLYHlMD2gBLYHlAC2wNKYHtACWwPKIHtASWwPaQENlICGymBjZTARkpgIyWwkRLYSAlspAQ2UgIbKYGdlMBOSmAnJbCTEthJCeykBHZSAjspgZ2UwE5K4CAlcJASOEgJHKQEDlICBymBg5TAQUrgICVwkBI4SQmcpAROUgInKYGTlMBJSuAkJXCSEjhJCZykBC5SAhcpgYuUwEVKYJKJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJM5KJsy/EVva8vdgt7INh/Aux1W8Y5uu+gP28Pcvr9cf5cJgkDVOkYZo0zJCG+br/iOjrx9b79urXT42/X/vVPryPc1DjfCErivdpPLP+alUfDu/1ffg9H632CxnSheH9Zx4+fubh82cevgjDvw0zpGGWNMwBDeOIkH8bBhHab8MgQvhtGESovg3zdSGZO+/D7H44TJGGadIwQxpmScMc0DBfKJd+wzBGGsZJwwRpGFICBymBg5TAQUrgICVwkBI4SQmcpAROUgInKYGTlMBJSuAkJXCSEjhJCZykBC5SAhcpgYuUwEVK4CIlcJESuEgJXKQELlICFymBv9Dn2Lw9EPRVhX/4c9kv9Dm/YZgkDVOkYZo0zJCG2f+MYfz58Nd0vtDn/PowX+hzfsMwRhrGScN84a92+fdf06kPP5u+0Of8hmGGNMyShjmgYb5QofyGYYw0jJOG+cKfaz/voRf24af2FyqU3zBMkYZp0jBDGuYLE/hXf5/1CxXKrw/zhQrlNwxjpGGcNAzpl/i/UKH8hmFIv8R/SL/Ef0i/xH9ICXxACRwPKIHjASVwPKAEDhKjigeUwEFiVEFiVEFiVPGAEjgeUgIbKYGNlMBGSmAjJbCREthICWykBDZSAhspgY2UwE5KYCclsJNCz0mh9zGcef2E+du51zfJ78fm+6n91KnzmVMfm5FfPWWfOuXaqdf/+D9/+Nd//MN//6d/+OPrwOt//un//sv//+Of/x8=" }, { "name": "constructor", "function_type": "Secret", "is_internal": false, "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "contract_deployment_data", "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "initialization_hash", "type": { "kind": "field" } }, { "name": "contract_class_id", "type": { "kind": "struct", "path": "aztec::protocol_types::contract_class_id::ContractClassId", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "contract_address_salt", "type": { "kind": "field" } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }] }, "visibility": "private" }], "param_witnesses": { "inputs": [{ "start": 0, "end": 41 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "contract_deployment_data", "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "initialization_hash", "type": { "kind": "field" } }, { "name": "contract_class_id", "type": { "kind": "struct", "path": "aztec::protocol_types::contract_class_id::ContractClassId", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "contract_address_salt", "type": { "kind": "field" } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259] }, "bytecode": "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", "debug_symbols": "tZAxCoQwEEXv8usUGxN32VxFLEaNEAhRTBAkeHdHFBvrVPMfPF4xGX7qKbkpRJgMKWGajDhTODEmWhLMR8CGge8uMDpvYaov75endF3fqtK//2Oz3ArIqmBbFWzrUm2GlRZHnbfn9xnTNl9zPwA=" }, { "name": "set_price", "function_type": "Open", "is_internal": false, "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "public_global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] }, "visibility": "private" }, { "name": "asset_id", "type": { "kind": "field" }, "visibility": "private" }, { "name": "price", "type": { "kind": "integer", "sign": "unsigned", "width": 120 }, "visibility": "private" }], "param_witnesses": { "asset_id": [{ "start": 39, "end": 40 }], "inputs": [{ "start": 0, "end": 39 }], "price": [{ "start": 40, "end": 41 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::public_circuit_public_inputs::PublicCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "contract_storage_update_requests", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_update_request::StorageUpdateRequest", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "new_value", "type": { "kind": "field" } }] } } }, { "name": "contract_storage_reads", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_read::StorageRead", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "current_value", "type": { "kind": "field" } }] } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "prover_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] }, "visibility": "public" }, "return_witnesses": [41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234] }, "bytecode": "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", "debug_symbols": "1Z3djmTZcV7fZa4JI+M/Nl/F8AVty4AAQRZEwoAh6N2dsqa6RbCGnK9GZ8+aq+kp5N4ngMj4snp1rKp/+eEf/vf/+MOf/v5//+Mff/j9v/zw+i+e9sPv/+u//PDHf/rDP/7bV/74pz/8859++P3rdz/83T/+z/d///V3P/yvv/+Hv/vh996vf/1vv/v/J1w+EfKJlE+UfKLlEyOf2J9/4nd/8boI+/GVUefba+3VH7efJ2+v16O326O3+6O3x6O356O316O396O3z6O3Pzqr9eis9qOz2o/Oaj86q/3orPajs9qPzmo/Oqv96Kz2o7Paj87qPDqr8+iszi+aVavz4ytt7c9u/+S1s/Px4tn9/upjH7UEqJYE1VKgWhpUy4BqWVAth1PLvkC1GKgWUO4uKHcXlLsLyt0F5e6CcndBubug3D2g3D2g3D2g3D2g3D2g3D2g3D2g3D2g3D2g3D2c3I0XJ3fjxcndeHFyN16c3I0XJ3fjxcndeHFyN16c3I0XJ3fjBcpdA+WugXLXQLlroNw1UO4aKHcNlLsGyl0D5a6BctdBueug3HVQ7joodx2Uuw7KXQflroNy10G566DcDVDuBih3A5S7AcrdAOVugHI3QLkboNwNUO4GKHcTlLsJyt0E5W6CcjdBuZug3E1Q7iYodxOUuwnK3QLlboFyt0C5W6DcLVDuFih3C5S7BcrdAuVugXK3QbnboNxtUO42KHcblLsNyt0G5W6DcrdBudug3B1Q7g4od0G+WoB8tQD5agHy1QLkqwXIVwuQrxYgXy1AvlqAfLUA+WoB8tUC5KsFyFcLkK8WIF8tQL5agHy1APlqAfLVAuSrBchXC5CvFiBfLUC+WoB8tQD5agHy1RLkqyXIV0uQr5YgXy1fnNxNkK+WIF8tQb5agny1BPlqCfLVEuSrJchXS5CvlhddqI389uKqz2pZTi33nB/Pbz16//GzHt1zfn5GLQGqJUG1FKiWe98z2LuCj1dbnu932+RHNYOq5lrGeLl/9KnW/6xP2qt/rPz8Viu/5xRplb/fI17f3y97PqvdfsO1+2+4dvWn9Ge0fGLkEyufOOoJxQT58cQveo962Mf3Qh4Z315d+3G9P3t9PHt9Pnt9PXt9P3v9L/vZ26/5+Lh9//F8cv0+e/159Ppf+Gst/ub19uz1/uz16m9qSWVz/scT8mdAyZ8BJX8GlPwZUPJnQMufAW3yCZdPyD1vuect97zlnrfc85Z73nLPR+75yD0fuecj93zkno/c85F7PnLPR+75yD1fuecr93zlnq/c85V7vnLPV+75yj1fuecr9/zIPT9yz4/c8yP3/Mg9P3LPj9zzI/f8yD0/as/r9ZJPmHzC5RMhn0j5RMknWj4x8omVT8g9N7nnJvfc5J6b3HOTe25yz03uuck9N7nnJvfc5Z673HOXe+5yz13uucs9d7nnLvfc5Z673POQex5yz0Puecg9D7nnMqMtmdGWzGhLZrQlM9qSGW3Jvz235N+eW/Jvzy35t+eW/NtzS/7tuSX/9txKuecp97zknpfc85J7LnO4kjlcyRyuZA5XMocrmcOVzOFK5nAlc7iSOVzJHK5kDlcyhyuZw5XM4UrmcCVzuJI5XMkcrmQOVzKHK5nDlczhSuZwJXO4kjlcyRyuZA5XMocrmcOVzOFK5nAlc7iSOVzJHK5kDlcyhyuZw5XM4UrmcCVzuJI5XMkcrmQOVzKHK5nDlczhWuZwLXO4ljlcyxyuZQ7XModrmcO1zOFa5nAtc7iWOVzLHK5lDtcyh2uZw7XM4VrmcC1zuJY5XMscrmUO1zKHa5nDtczhWuZwLXO4ljlcyxyuZQ7XModrmcO1zOFa5nAtc7iWOVzLHK5lDtcyh2uZw7XM4VrmcC1zuJY5XMscrmUO1zKHa5nDtczhWuZwLXO4ljlcyxyuZQ7XModrmcO1zOFa5nAtc7iWOVzLHK5lDtcyh2uZw7XM4VrmcC1zuJY5XMscrmUO1zKHa5nDtczhWuZwLXO4ljlcyxyuZQ7XModrmcO1zOFa5nAtc7iWOVzLHK5lDtcyh2uZw7XM4VrmcC1zuJY5XMscrmUO1zKHa5nDtczhWuZwLXO4ljlcyxxuZA43MocbmcONzOFG5nAjc7iROdzIHG5kDjcyhxuZw43M4UbmcCNzuJE53MgcbmQONzKHG5nDjczhRuZwI3O4kTncyBxuZA43MocbmcONzOFG5nAjc7iROdzIHG5kDjcyhxuZw43M4UbmcCNzuJE53MgcbmQONzKHG5nDjczhRuZwI3O4kTncyBxuZA43MocbmcONzOFG5nAjc7iROdzIHG5kDjcyhxuZw43M4UbmcCNzuJE53MgcbmQONzKHG5nDjczhRuZwI3O4kTncyBxuZA43MocbmcONzOFG5nAjc7iROdzIHG5kDjcyhxuZw43M4UbmcCNzuJE53MgcbmQONzKHG5nDjczhRuZwI3O4kTncyBxuZA43MocbmcONzOFW5nArc7iVOdzKHG5lDrcyh1uZw63M4VbmcCtzuJU53MocbmUOtzKHW5nDrczhVuZwK3O4lTncyhxuZQ63ModbmcOtzOFW5nArc7iVOdzKHG5lDrcyh1uZw63M4VbmcCtzuJU53MocbmUOtzKHW5nDrczhVuZwK3O4lTncyhxuZQ63ModbmcOtzOFW5nArc7iVOdzKHG5lDrcyh1uZw63M4VbmcCtzuJU53MocbmUOtzKHW5nDrczhVuZwK3O4lTncyhxuZQ63ModbmcOtzOFW5nArc7iVOdzKHG5lDrcyh1uZw63M4VbmcCtzuJU53MocbmUOtzKHW5nDrczhVuZwK3O4lTncyhxuZQ63ModbmcOtzOFW5nArc7iVOdzKHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHO7IHM5eMoh7HzH9iOtHQj+S+pHSj7R+ZPQjqx/Ru296903vvundN737pnff9O6b3n3Tu296903vvuvdd737rnff9e673n3Xu+96913vvuvdd737oXc/9O6H3v3Qux9690PvfujdD737oXc/9O6n3v3Uu59691PvfurdT737qXc/9e6n3v3Uu19690vvfundL737pXe/9O6X3v3Su19690vvfuvdb737rXe/9e633v3Wu99691vvfuvdb737o3d/9O6P3v3Ruz9690fv/ujdH737o3d/9O6v3v3Vu79691fv/urdX737q3d/9e6v3v3Vu3/07h+9+0fv/tG7f/TuH737R+/+0bt/9O7rrM901mc66zOd9ZnO+t7f9epHSj/S+pHRj6x+RO++zvpMZ32msz7TWZ/prM901mc66zOd9ZnO+kxnfaazPtNZn+msz3TWZzrrM531mc76TGd9prM+01mf6azPdNZnOusznfWZzvpMZ32msz7TWZ/prM901mc66zOd9ZnO+kxnfaazPtNZn+msz3TWZzrrM531mc76TGd9prM+01mf6azPdNZnOusznfWZzvpMZ32msz7TWZ/prM901mc66zOd9ZnO+kxnfaazPtNZn+msz3TWZzrrM531mc76TGd9prM+01mf6azPdNZnOusznfWZzvpMZ32msz7TWZ/prM901mc66zOd9ZnO+kxnfaazPtNZn+msz3TWZzrrM531mc76TGd9rrM+11mf66zPddbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11mf66zPddbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11mf66zPddbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11mf66zPddbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11mf66zPddYXOusLnfWFzvpCZ32hs77QWV/orC901hc66wud9YXO+kJnfaGzvtBZX+isL3TWFzrrC531hc76Qmd9obO+0Flf6KwvdNYXOusLnfWFzvpCZ32hs77QWV/orC901hc66wud9YXO+kJnfaGzvtBZX+isL3TWFzrrC531hc76Qmd9obO+0Flf6KwvdNYXOusLnfWFzvpCZ32hs77QWV/orC901hc66wud9YXO+kJnfaGzvtBZX+isL3TWFzrrC531hc76Qmd9obO+0Flf6KwvdNYXOusLnfWFzvpCZ32hs77QWV/orC901hc66wud9YXO+kJnfaGzvtBZX+isL3TWFzrrC531hc76Qmd9obO+0Flf6KwvdNYXOusLnfWFzvpCZ32ps77UWV/qrC911pc660ud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" }, { "name": "fetch_price", "function_type": "Unconstrained", "is_internal": false, "abi": { "parameters": [{ "name": "assetId", "type": { "kind": "field" }, "visibility": "private" }], "param_witnesses": { "assetId": [{ "start": 0, "end": 1 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "asset::Asset", "fields": [{ "name": "price", "type": { "kind": "integer", "sign": "unsigned", "width": 120 } }] }, "visibility": "public" }, "return_witnesses": [1] }, "bytecode": "H4sIAAAAAAAA/81XwWqDQBDdVROTmNhcCy3sF4Q19NT2YOm9h/YLLJpSSCKooenPl2oyAy9bCYWs4ICZcXYz8+btOq5SCCHFUVywUdgXk9aXSWQxlpYGzheyR+BXtvLd6eWwCeKd8sIS1JfDNzTHr68hjEvy87w5+CRgH9jGrvWyye8amM0aFNgDwOPZxxN1VKceAec/wu6+9YEf1+BpBuND4M7vgDsJeTk23yPG/+J1eoC3y/0wsh93GdYxxsDryOAX65qQbXE/akH5G/Eg3wTyTsmWwm7PDaBWCTimgIfn3JK+Esc9J1r4Gdtfn+hcb+N8iEf2AE8g2t8rY4MzfNfg2DOMc20O+EKy3ZbYM/Dx2oUt/0WeZlBLTLa+TA48YS4F95xvCjjCnuDxW/B01Ut5fTg23/s9yc28xMJuH7/qqKY5xRpSbMbP+TyY82CMsb8R81nCfTEHfnjeXnTTlzm2b+ByxGkP4Xn4zLf1mADiNPi5f9g8X+G5TVmM22Dn8yvLuV6MZ7cOziPRBPgsq7xIPrLXLEklQPMMmKjNT55GHPCh7bb4BKXnMj3w8dIPwOcYtOBnBG6vP5+OMWl9mRyeT9coGAXJcVrm3ZB+JP125FyV67xSWm3r32S9zr+ydKFwrFSbXVmpskqKSq2KfKOiBca9J31N+qkokm/1uU2zvcp3lcpX6j3fbdNS/ALtHWKhZg8AAA==", "debug_symbols": "1drNaoNQEAXgd7lrKTNz5/6Mr1K6sG0KgZCERAol+O41xJhAQiW20uPOC2ecb6HHjQe32rxV9XKz3rvy4OgpuvL54Pbban087+tqV7symxVusX53pUloCvexXC1cKZGa4iZrGs5Zy32W6V6WWeWcbq+zXfLGzUvRehKYJ4N5DMzDhAZiNJCggTwaSNFAAQ2EVtOM1tOMVtSM1tSC1tSC1tSC1tTy66ZmSr7f4WmARF2UBu4aLXbJxL7PWurUOkt1mKU6zlKdZqnOs1QPfYe8DKlZrFdHut5wG/ZJuqxeYVJXaJ6QMIyEESSMR8IoEiYgYSISJiFhMhIGqYEVqYEVqYEVqYEVqYEVqYEVqYEVqYEVqYEVqYEVqYHDlA182sCTb5DJN/jJN/xBqyXqN5j8/FCoz+eHQtPlxsE6TYDSRChNgtJkKI0haSJBafi/NCHc0QiUxkNp7r7hElM35ElvvqMxj5ixx2cSjZjhETPy2Ex7+Kx2y+p1tTj+y9Ee66/t6bL5Bg==" }], "events": [], "file_map": { "3": { "source": "struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    // TODO: change this to return a u64 as Noir now\n    // uses u64 for indexing\n    len: Field,\n    empty_value: T,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0, empty_value: initial_value }\n    }\n\n    pub fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: Field) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> Field {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> Field {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + (i as Field)] = vec.get_unchecked(i as Field);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = self.empty_value;\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if (!exceeded_len) {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}", "path": "std/collections/bounded_vec.nr" }, "31": { "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n", "path": "std/option.nr" }, "58": { "source": "use crate::{\n    context::inputs::PublicContextInputs, messaging::process_l1_to_l2_message,\n    oracle::{arguments, public_call::call_public_function_internal}\n};\nuse dep::protocol_types::{\n    abis::{\n    global_variables::GlobalVariables, function_selector::FunctionSelector,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_READ_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::hash_args, header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader\n};\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<StorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_reads: BoundedVec<StorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack_hashes: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n    prover_address: AztecAddress,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = StorageRead::empty();\n        let empty_storage_update = StorageUpdateRequest::empty();\n        PublicContext {\n            inputs,\n            side_effect_counter: inputs.call_context.start_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(0),\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_reads: BoundedVec::new(empty_storage_read),\n            public_call_stack_hashes: BoundedVec::new(0),\n            new_note_hashes: BoundedVec::new(SideEffect::empty()),\n            new_nullifiers: BoundedVec::new(SideEffectLinkedToNoteHash::empty()),\n            new_l2_to_l1_msgs: BoundedVec::new(L2ToL1Message::empty()),\n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n            historical_header: inputs.historical_header,\n            prover_address: AztecAddress::zero() // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn coinbase(self) -> EthAddress {\n        self.inputs.public_global_variables.coinbase\n    }\n\n    pub fn fee_recipient(self) -> AztecAddress {\n        self.inputs.public_global_variables.fee_recipient\n    }\n\n    pub fn finish(self) -> PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_reads: self.contract_storage_reads.storage,\n            return_values: self.return_values.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash,\n            unencrypted_log_preimages_length,\n            historical_header: self.inputs.historical_header,\n            prover_address: self.prover_address\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash {\n            value: nullifier,\n            note_hash: 0, // cannot nullify pending notes in public context\n            counter: self.side_effect_counter\n        };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field, sender: EthAddress) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            this,\n            sender,\n            self.chain_id(),\n            self.version(),\n            msg_key,\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(contract_address, function_selector, 0, false, true)\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr" }, "60": { "source": "use crate::{\n    context::inputs::PrivateContextInputs, key::nullifier_key::validate_nullifier_key_against_address,\n    messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair},\n    debug_log::debug_log\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n    nullifier_key_validation_request::NullifierKeyValidationRequest,\n    private_call_stack_item::PrivateCallStackItem,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader\n};\nuse dep::std::option::Option;\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<SideEffect, MAX_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let side_effect_counter = inputs.call_context.start_side_effect_counter;\n        let mut min_revertible_side_effect_counter = 0;\n        // Note. The side effect counter is 2 when this is the initial call\n        if (side_effect_counter == 2) {\n            min_revertible_side_effect_counter = side_effect_counter;\n        }\n        PrivateContext {\n            inputs,\n            side_effect_counter,\n            min_revertible_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(0),\n            read_requests: BoundedVec::new(SideEffect::empty()),\n            nullifier_key_validation_requests: BoundedVec::new(NullifierKeyValidationRequest::empty()),\n            new_note_hashes: BoundedVec::new(SideEffect::empty()),\n            new_nullifiers: BoundedVec::new(SideEffectLinkedToNoteHash::empty()),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(0),\n            public_call_stack_hashes: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(L2ToL1Message::empty()),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            // TODO(fees): start this from 0 and test the following:\n            // - in the private circuit init that it gets set correctly\n            // - in the private circuit inner that it remains 0\n            // I've had to initialize the counter here so that it would work for contract deployments\n            // the above checks should be doable after we figure out fee payments for contract deployments\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            read_requests: self.read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_min_revertible_side_effect_counter(&mut self) {\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        let side_effect = SideEffect { value: read_request, counter: self.side_effect_counter };\n        self.read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            msg_key,\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_note_hashes: [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero()\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr" }, "71": { "source": "use dep::protocol_types::traits::{Deserialize, Serialize};\n\n#[oracle(storageRead)]\nfn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_oracle_wrapper(storage_slot)\n}\n\n#[oracle(storageWrite)]\nfn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/storage.nr" }, "85": { "source": "mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod avm;\n\nuse private_context::PrivateContext;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none() }\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/context.nr" }, "97": { "source": "use crate::context::{Context};\nuse crate::oracle::storage::storage_read;\nuse crate::oracle::storage::storage_write;\nuse dep::std::option::Option;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_state_struct\nstruct PublicState<T> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_state_struct\n\nimpl<T> Storage<T> for PublicState<T> {}\n\nimpl<T> PublicState<T> {\n    // docs:start:public_state_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicState { context, storage_slot }\n    }\n    // docs:end:public_state_struct_new\n\n    // docs:start:public_state_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"Public state writes only supported in public functions\");\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n    // docs:end:public_state_struct_read\n\n    // docs:start:public_state_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"Public state writes only supported in public functions\");\n        let fields = T::serialize(value);\n        storage_write(self.storage_slot, fields);\n    }\n    // docs:end:public_state_struct_write\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/public_state.nr" }, "100": { "source": "use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::std::option::Option;\nuse dep::protocol_types::{hash::pedersen_hash, traits::{ToField}};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T> Storage<T> for Map<K, T> {}\n\nimpl<K, V> Map<K, V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key.to_field()], 0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/map.nr" }, "106": { "source": "use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/hasher.nr" }, "174": { "source": "global ARGS_LENGTH: Field = 16;\nglobal RETURN_VALUES_LENGTH: Field = 4;\n\n/**\n * Convention for constant array lengths are mainly divided in 2 classes:\n *  - FUNCTION CALL\n *  - TRANSACTION\n *\n * Agreed convention is to use MAX_XXX_PER_CALL resp. MAX_XXX_PER_TX, where XXX denotes a type of element such as\n * commitment, or nullifier, e.g.,:\n *  - MAX_NEW_NULLIFIERS_PER_CALL\n *  - MAX_NEW_NOTE_HASHES_PER_TX\n *\n * In the kernel circuits, we accumulate elements such as note hashes and the nullifiers from all functions calls in a\n * transaction. Therefore, we always must have:\n * MAX_XXX_PER_TX ≥ MAX_XXX_PER_CALL\n *\n * For instance:\n * MAX_NEW_NOTE_HASHES_PER_TX ≥ MAX_NEW_NOTE_HASHES_PER_CALL\n * MAX_NEW_NULLIFIERS_PER_TX ≥ MAX_NEW_NULLIFIERS_PER_CALL\n *\n */\n\n// docs:start:constants\n// \"PER CALL\" CONSTANTS\nglobal MAX_NEW_NOTE_HASHES_PER_CALL: Field = 16;\nglobal MAX_NEW_NULLIFIERS_PER_CALL: Field = 16;\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL: Field = 4;\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL: Field = 4;\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_CALL: Field = 2;\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL: Field = 16;\nglobal MAX_PUBLIC_DATA_READS_PER_CALL: Field = 16;\nglobal MAX_READ_REQUESTS_PER_CALL: Field = 32;\nglobal MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL: Field = 1;\n\n// \"PER TRANSACTION\" CONSTANTS\nglobal MAX_NEW_NOTE_HASHES_PER_TX: Field = 64;\nglobal MAX_NON_REVERTIBLE_NOTE_HASHES_PER_TX: Field = 8;\nglobal MAX_REVERTIBLE_NOTE_HASHES_PER_TX: Field = 56;\n\nglobal MAX_NEW_NULLIFIERS_PER_TX: Field = 64;\nglobal MAX_NON_REVERTIBLE_NULLIFIERS_PER_TX: Field = 8;\nglobal MAX_REVERTIBLE_NULLIFIERS_PER_TX: Field = 56;\n\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX: Field = 8;\n\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX: Field = 8;\nglobal MAX_NON_REVERTIBLE_PUBLIC_CALL_STACK_LENGTH_PER_TX: Field = 3;\nglobal MAX_REVERTIBLE_PUBLIC_CALL_STACK_LENGTH_PER_TX: Field = 5;\n\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: Field = 32;\nglobal MAX_NON_REVERTIBLE_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: Field = 16;\nglobal MAX_REVERTIBLE_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: Field = 16;\n\nglobal MAX_PUBLIC_DATA_READS_PER_TX: Field = 32;\nglobal MAX_NON_REVERTIBLE_PUBLIC_DATA_READS_PER_TX: Field = 16;\nglobal MAX_REVERTIBLE_PUBLIC_DATA_READS_PER_TX: Field = 16;\n\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_TX: Field = 2;\nglobal MAX_NEW_CONTRACTS_PER_TX: Field = 1;\nglobal MAX_READ_REQUESTS_PER_TX: Field = 128;\nglobal MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_TX: Field = 4;\nglobal NUM_ENCRYPTED_LOGS_HASHES_PER_TX: Field = 1;\nglobal NUM_UNENCRYPTED_LOGS_HASHES_PER_TX: Field = 1;\n// docs:end:constants\n\n// ROLLUP CONTRACT CONSTANTS - constants used only in l1-contracts\nglobal NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP: Field = 16;\n\n// TREES RELATED CONSTANTS\nglobal VK_TREE_HEIGHT: Field = 3;\nglobal FUNCTION_TREE_HEIGHT: Field = 5;\nglobal CONTRACT_TREE_HEIGHT: Field = 16;\nglobal NOTE_HASH_TREE_HEIGHT: Field = 32;\nglobal PUBLIC_DATA_TREE_HEIGHT: Field = 40;\nglobal NULLIFIER_TREE_HEIGHT: Field = 20;\nglobal L1_TO_L2_MSG_TREE_HEIGHT: Field = 16;\nglobal ROLLUP_VK_TREE_HEIGHT: Field = 8;\nglobal ARTIFACT_FUNCTION_TREE_MAX_HEIGHT = 5;\n\n// SUB-TREES RELATED CONSTANTS\nglobal CONTRACT_SUBTREE_HEIGHT: Field = 0;\nglobal CONTRACT_SUBTREE_SIBLING_PATH_LENGTH: Field = 16;\nglobal NOTE_HASH_SUBTREE_HEIGHT: Field = 6;\nglobal NOTE_HASH_SUBTREE_SIBLING_PATH_LENGTH: Field = 26;\nglobal NULLIFIER_SUBTREE_HEIGHT: Field = 6;\nglobal PUBLIC_DATA_SUBTREE_HEIGHT: Field = 5;\nglobal ARCHIVE_HEIGHT: Field = 16;\nglobal NULLIFIER_SUBTREE_SIBLING_PATH_LENGTH: Field = 14;\nglobal PUBLIC_DATA_SUBTREE_SIBLING_PATH_LENGTH: Field = 35;\nglobal L1_TO_L2_MSG_SUBTREE_HEIGHT: Field = 4;\nglobal L1_TO_L2_MSG_SUBTREE_SIBLING_PATH_LENGTH: Field = 12;\n\n// MISC CONSTANTS\nglobal FUNCTION_SELECTOR_NUM_BYTES: Field = 4;\nglobal MAPPING_SLOT_PEDERSEN_SEPARATOR: Field = 4;\n// sha256 hash is stored in two fields to accommodate all 256-bits of the hash\nglobal NUM_FIELDS_PER_SHA256: Field = 2;\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 32;\n\n// CONTRACT CLASS CONSTANTS\n// This should be around 8192 (assuming 2**15 instructions packed at 8 bytes each),\n// but it's reduced to speed up build times, otherwise the ClassRegisterer takes over 5 mins to compile.\n// We are not using 1024 so we can squeeze in a few more args to methods that consume packed public bytecode,\n// such as the ClassRegisterer.register, and still land below the 32 * 32 max args limit for hashing.\nglobal MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS: Field = 1000;\n// Bytecode size for private functions is per function, not for the entire contract.\n// Note that private functions bytecode includes a mix of acir and brillig.\nglobal MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS: Field = 500;\n// Same for unconstrained functions: the size is per function.\nglobal MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS: Field = 500;\n// Since we are not yet emitting selectors we'll use this magic value to identify events emitted by the ClassRegisterer.\n// This is just a stopgap until we implement proper selectors.\n// sha224sum 'struct ContractClassRegistered {contract_class_id: ContractClassId, version: Field, artifact_hash: Field, private_functions_root: Field, packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS] }'\nglobal REGISTERER_CONTRACT_CLASS_REGISTERED_MAGIC_VALUE = 0x6999d1e02b08a447a463563453cb36919c9dd7150336fc7c4d2b52f8;\n// sha224sum 'struct ClassPrivateFunctionBroadcasted'\nglobal REGISTERER_PRIVATE_FUNCTION_BROADCASTED_MAGIC_VALUE = 0x1b70e95fde0b70adc30496b90a327af6a5e383e028e7a43211a07bcd;\n// sha224sum 'struct ClassUnconstrainedFunctionBroadcasted'\nglobal REGISTERER_UNCONSTRAINED_FUNCTION_BROADCASTED_MAGIC_VALUE = 0xe7af816635466f128568edb04c9fa024f6c87fb9010fdbffa68b3d99;\n\n// CONTRACT INSTANCE CONSTANTS\n// sha224sum 'struct ContractInstanceDeployed'\nglobal DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE = 0x85864497636cf755ae7bde03f267ce01a520981c21c3682aaf82a631;\n\n// NOIR CONSTANTS - constants used only in yarn-packages/noir-contracts\n// Some are defined here because Noir doesn't yet support globals referencing other globals yet.\n// Move these constants to a noir file once the issue below is resolved:\n// https://github.com/noir-lang/noir/issues/1734\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: Field = 25;\nglobal MAX_NOTE_FIELDS_LENGTH: Field = 20;\n// GET_NOTE_ORACLE_RETURN_LENGT = MAX_NOTE_FIELDS_LENGTH + 1 + 2\n// The plus 1 is 1 extra field for nonce.\n// + 2 for EXTRA_DATA: [number_of_return_notes, contract_address]\nglobal GET_NOTE_ORACLE_RETURN_LENGTH: Field = 23;\nglobal MAX_NOTES_PER_PAGE: Field = 10;\n// VIEW_NOTE_ORACLE_RETURN_LENGTH = MAX_NOTES_PER_PAGE * (MAX_NOTE_FIELDS_LENGTH + 1) + 2;\nglobal VIEW_NOTE_ORACLE_RETURN_LENGTH: Field = 212;\n\n// LENGTH OF STRUCTS SERIALIZED TO FIELDS\nglobal AZTEC_ADDRESS_LENGTH = 1;\nglobal CALL_CONTEXT_LENGTH: Field = 8;\nglobal CONTENT_COMMITMENT_LENGTH: Field = 7;\nglobal CONTRACT_DEPLOYMENT_DATA_LENGTH: Field = 6;\nglobal CONTRACT_STORAGE_READ_LENGTH: Field = 2;\nglobal CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH: Field = 2;\nglobal ETH_ADDRESS_LENGTH = 1;\nglobal FUNCTION_DATA_LENGTH: Field = 4;\nglobal FUNCTION_LEAF_PREIMAGE_LENGTH: Field = 5;\nglobal GLOBAL_VARIABLES_LENGTH: Field = 6;\nglobal HEADER_LENGTH: Field = 25; // 2 for last_archive, 7 for content commitment, 10 for state reference, 6 for global vars\nglobal L1_TO_L2_MESSAGE_LENGTH: Field = 8;\nglobal L2_TO_L1_MESSAGE_LENGTH: Field = 2;\nglobal NEW_CONTRACT_DATA_LENGTH: Field = 3;\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH = 4;\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH = 5;\nglobal PARTIAL_STATE_REFERENCE_LENGTH: Field = 8;\nglobal PRIVATE_CALL_STACK_ITEM_LENGTH: Field = 219;\n// Change this ONLY if you have changed the PrivateCircuitPublicInputs structure.\n// In other words, if the structure/size of the public inputs of a function call changes then we should change this\n// constant as well PRIVATE_CALL_STACK_ITEM_LENGTH\nglobal PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH: Field = 214;\n// Change this ONLY if you have changed the PublicCircuitPublicInputs structure.\nglobal PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH: Field = 194;\nglobal STATE_REFERENCE_LENGTH: Field = 10; // 2 for snap + 8 for partial\nglobal TX_CONTEXT_DATA_LENGTH: Field = 11;\nglobal TX_REQUEST_LENGTH: Field = 17;\n\nglobal GET_NOTES_ORACLE_RETURN_LENGTH: Field = 674;\nglobal NOTE_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal NULLIFIERS_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal PUBLIC_DATA_WRITES_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal CONTRACTS_NUM_BYTES_PER_BASE_ROLLUP: Field = 32;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP_UNPADDED: Field = 52;\nglobal L2_TO_L1_MSGS_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal LOGS_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\n\n/**\n * Enumerate the hash_indices which are used for pedersen hashing.\n * We start from 1 to avoid the default generators. The generator indices are listed\n * based on the number of elements each index hashes. The following conditions must be met:\n *\n * +-----------+-------------------------------+----------------------+\n * | Hash size | Number of elements hashed (n) | Condition to use     |\n * |-----------+-------------------------------+----------------------|\n * | LOW       | n ≤ 8                         | 0 < hash_index ≤ 32  |\n * | MID       | 8 < n ≤ 16                    | 32 < hash_index ≤ 40 |\n * | HIGH      | 16 < n ≤ 48                   | 40 < hash_index ≤ 48 |\n * +-----------+-------------------------------+----------------------+\n *\n * Note: When modifying, modify `GeneratorIndexPacker` in packer.hpp accordingly.\n */\n// Indices with size ≤ 8\nglobal GENERATOR_INDEX__NOTE_HASH = 1;\nglobal GENERATOR_INDEX__NOTE_HASH_NONCE = 2;\nglobal GENERATOR_INDEX__UNIQUE_NOTE_HASH = 3;\nglobal GENERATOR_INDEX__SILOED_NOTE_HASH = 4;\nglobal GENERATOR_INDEX__NULLIFIER = 5;\nglobal GENERATOR_INDEX__INITIALIZATION_NULLIFIER = 6;\nglobal GENERATOR_INDEX__OUTER_NULLIFIER = 7;\nglobal GENERATOR_INDEX__PUBLIC_DATA_READ = 8;\nglobal GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST = 9;\nglobal GENERATOR_INDEX__FUNCTION_DATA = 10;\nglobal GENERATOR_INDEX__FUNCTION_LEAF = 11;\nglobal GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA = 12;\nglobal GENERATOR_INDEX__CONSTRUCTOR = 13;\nglobal GENERATOR_INDEX__CONSTRUCTOR_ARGS = 14;\nglobal GENERATOR_INDEX__CONTRACT_ADDRESS = 15;\nglobal GENERATOR_INDEX__CONTRACT_LEAF = 16;\nglobal GENERATOR_INDEX__CALL_CONTEXT = 17;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM = 18;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM_2 = 19;\nglobal GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET = 20;\nglobal GENERATOR_INDEX__L2_TO_L1_MSG = 21;\nglobal GENERATOR_INDEX__TX_CONTEXT = 22;\nglobal GENERATOR_INDEX__PUBLIC_LEAF_INDEX = 23;\nglobal GENERATOR_INDEX__PUBLIC_DATA_LEAF = 24;\nglobal GENERATOR_INDEX__SIGNED_TX_REQUEST = 25;\nglobal GENERATOR_INDEX__GLOBAL_VARIABLES = 26;\nglobal GENERATOR_INDEX__PARTIAL_ADDRESS = 27;\nglobal GENERATOR_INDEX__BLOCK_HASH = 28;\nglobal GENERATOR_INDEX__SIDE_EFFECT = 29;\nglobal GENERATOR_INDEX__FEE_PAYLOAD = 30;\n// Indices with size ≤ 16\nglobal GENERATOR_INDEX__TX_REQUEST = 33;\nglobal GENERATOR_INDEX__SIGNATURE_PAYLOAD = 34;\n// Indices with size ≤ 44\nglobal GENERATOR_INDEX__VK = 41;\nglobal GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS = 42;\nglobal GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS = 43;\nglobal GENERATOR_INDEX__FUNCTION_ARGS = 44;\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/constants.nr" }, "191": { "source": "use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::FunctionLeafPreimage;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::new_contract_data::NewContractData as ContractLeafPreimage;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, CONTRACT_TREE_HEIGHT, FUNCTION_TREE_HEIGHT,\n    NOTE_HASH_TREE_HEIGHT, NUM_FIELDS_PER_SHA256, GENERATOR_INDEX__SILOED_NOTE_HASH,\n    GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK, GENERATOR_INDEX__CONSTRUCTOR,\n    GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Checks that `value` is a member of a merkle tree with root `root` at position `index`\n// The witness being the `sibling_path`\npub fn assert_check_membership<N>(value: Field, index: Field, sibling_path: [Field; N], root: Field) {\n    let calculated_root = root_from_sibling_path(value, index, sibling_path);\n    assert(calculated_root == root, \"membership check failed\");\n}\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<N>(leaf: Field, leaf_index: Field, sibling_path: [Field; N]) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\n// Calculate the contract tree root from the sibling path and leaf preimage.\npub fn contract_tree_root_from_siblings(\n    contract_class_id: ContractClassId,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    contract_leaf_index: Field,\n    contract_leaf_sibling_path: [Field; CONTRACT_TREE_HEIGHT]\n) -> Field {\n    //TODO(Kev): if we use shorthand syntax here, we get an error as expected,\n    // since variable name is `storage_contract_address` but the span is incorrect.\n    let contract_leaf_preimage = ContractLeafPreimage { contract_address: storage_contract_address, portal_contract_address, contract_class_id };\n\n    let contract_leaf = contract_leaf_preimage.hash();\n\n    let computed_contract_tree_root = root_from_sibling_path(contract_leaf, contract_leaf_index, contract_leaf_sibling_path);\n\n    computed_contract_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn read_request_root_from_siblings(\n    read_request: Field,\n    leaf_index: Field,\n    sibling_path: [Field; NOTE_HASH_TREE_HEIGHT]\n) -> Field {\n    root_from_sibling_path(read_request, leaf_index, sibling_path)\n}\n\npub fn silo_note_hash(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\nfn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new(0);\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, commitment_index: Field) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_siloed_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_unique_siloed_note_hashes<N>(\n    first_nullifier: Field,\n    siloed_note_hashes: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_note_hashes = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_note_hash = siloed_note_hashes[i];\n        if siloed_note_hash.value != 0 {\n            let nonce = compute_note_hash_nonce(first_nullifier, i);\n            unique_siloed_note_hashes[i] = SideEffect {\n                value: compute_unique_siloed_note_hash(nonce, siloed_note_hash.value),\n                counter: siloed_note_hash.counter\n                };\n        }\n    }\n    unique_siloed_note_hashes\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/hash.nr" }, "259": { "source": "use dep::aztec::protocol_types::traits::{Serialize, Deserialize};\n\nstruct Asset {\n    price: u120,\n}\n\nglobal ASSET_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<ASSET_SERIALIZED_LEN> for Asset {\n    fn serialize(asset: Asset) -> [Field; ASSET_SERIALIZED_LEN] {\n        [asset.price as Field]\n    }\n}\n\nimpl Deserialize<ASSET_SERIALIZED_LEN> for Asset {\n    fn deserialize(fields: [Field; ASSET_SERIALIZED_LEN]) -> Asset {\n        let price = fields[0] as u120;\n        Asset { price }\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-contracts/contracts/price_feed_contract/src/asset.nr" }, "260": { "source": "mod asset;\n\ncontract PriceFeed {\n    use dep::std::option::Option;\n    use dep::aztec::{\n        context::{PrivateContext, PublicContext, Context},\n        state_vars::{\n            map::Map,\n            public_state::PublicState,\n        },\n    };\n    use dep::aztec::protocol_types::address::AztecAddress;\n    use crate::asset::Asset;\n\n    // Storage structure, containing all storage, and specifying what slots they use.\n    struct Storage {\n        assets: Map<Field, PublicState<Asset>>,\n    }\n\n    #[aztec(private)]\n    fn constructor() {}\n\n    #[aztec(public)]\n    fn set_price(asset_id: Field, price: u120) {\n        let asset = storage.assets.at(asset_id);\n        asset.write(Asset { price });\n    }\n\n    #[aztec(public)]\n    fn get_price(asset_id: Field) -> Asset {\n        storage.assets.at(asset_id).read()\n    }\n\n    unconstrained fn fetch_price(assetId: Field) -> pub Asset {\n        storage.assets.at(assetId).read()\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-contracts/contracts/price_feed_contract/src/main.nr" } } }
