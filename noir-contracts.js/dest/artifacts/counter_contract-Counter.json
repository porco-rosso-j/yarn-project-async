{ "noir_version": "0.24.0+78ef0134b82e76a73dadb6c7975def22290e3a1a", "name": "Counter", "functions": [{ "name": "get_counter", "function_type": "Unconstrained", "is_internal": false, "abi": { "parameters": [{ "name": "owner", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "owner": [{ "start": 0, "end": 1 }] }, "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" }, "return_witnesses": [1] }, "bytecode": "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", "debug_symbols": "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fdSI9FEj0keNSB81In3UiPRRI9JHjUgfNSJ91Ij0USPSR41IHzUifdSI9FEj0keNSB81In3UiPRRI9JHjUgfNSJ91Ij0USPSR41IHzUifdSK9FEr0ketSB+1In3UvjTepyvSR61IH7UifdSK9FEr0ketSB+1In3UivRRK9JHrUgftSJ91Ir0USvSR61IH7UifdSK9FEr0ketSB+1In3UivRRK9JHrUgftSJ91Ir0USvSR61IH7UifdSK9FEr0ketSB+1In3UivRRK9JHrUgftSJ91Ir0USvSR61IH7UifdSK9FEr0ketSB+1In3UivRRK9JHrUgftSJ91Ir0USvSR61IH7UifdSK9FEr0ketSB+1In3UivRRK9JHrUgftSJ91Ir0USvSR61IH7UifdSK9FEr0ketSB+1In3UivRRK9JHrUgftSJ91Ir0USvSR61IH7UifdSK9FEr0ketSB+1In3UivRRK9JHrUgftSJ91Ir0USvSR61IH7UifdSK9FEr0ketSB+1In3UivRRK9JHrUgftSJ91In0USfSR51IH3UifdS9NN6nJ9JHnUgfdSJ91In0USfSR51IH3UifdSJ9FEn0kedSB91In3UifRRJ9JHnUgfdSJ91In0USfSR51IH3UifdSJ9FEn0kedSB91In3UifRRJ9JHnUgfdSJ91In0USfSR51IH3UifdSJ9FEn0kedSB91In3UifRRJ9JHnUgfdSJ91In0USfSR51IH3UifdSJ9FEn0kedSB91In3UifRRJ9JHnUgfdSJ91In0USfSR51IH3UifdSJ9FEn0kedSB91In3UifRRJ9JHnUgfdSJ91In0USfSR51IH3UifdSJ9FEn0kedSB91In3UifRRJ9JHnUgfdSJ91In0USfSR51IH3UifdSJ9FEn0kedSB91In3UifRRJ9JHnUgfdSJ91In0USfSR51IH3UifdSJ9FEn0kedSB91In2UvUQCqfcX0Xijvr+Ixiv1/UU03qnvL6LxUn1/EY236vuLaLxW319E4736/iIaL9b3F1F5s4qkUu8vovJmFYml3l9E5c0qkku9v4jKm1UkmHp/EZU3q0gy9f4iKm9WkWjq/UVU3qwi2dT7i6i8WUXCqfcXUXmziqRT7y+i8mYViafeX0TlzSqST72/iMqbVSSgen8RlTerSEL1/iIqb1aRiOr9RVTerCIZ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q1QarFJpsEqlwSqVBqtUGqxSabBKpcEqlQarVBqsUmmwSqXBKpUGq1QarFJpsEqlwSqVBqtUGqxSabBKpcEqlQarVBqsUmmwSqXBKpUGq1QarFJpsEqlwSqVBqtUGqxSabBKpcEqlQarVBqsUmmwWqXBapUGq1UarFZpsPol8mZtlQarVRqsVmmwWqXBapUGq1UarFZpsFqlwWqVBqtVGqxWabBapcFqlQarVRqsVmmwWqXBapUGq1UarFZpsFqlwWqVBqtVGqxWabBapcFqlQarVRqsVmmwWqXBapUGq1UarFZpsFqlwWqVBqtVGqxWabBapcFqlQarVRqsVmmwWqXBapUGq1UarFZpsFqlwWqVBqtVGqxWabBapcFqlQarVRqsVmmwWqXBapUGq1UarFZpsFqlwWqVBqtVGqxWabBapcFqlQarVRqsVmmwWqXBapUGq1UarFZpsFqlwWqVBqtVGqxWabBapcFqlQarVRqsVmmwWqXBapUGq1UarFZpsFqlwWqVBqtVGqxWabBapcFqlQarVRqsVmmwWqXBapUGq1UarFZpsFqlwWqVBqtVGqxWabBGpcEalQZrVBqsUWmw5iXyZh2VBmtUGqxRabBGpcEalQZrVBqsUWmwRqXBGpUGa1QarFFpsEalwRqVBmtUGqxRabBGpcEalQZrVBqsUWmwRqXBGpUGa1QarFFpsEalwRqVBmtUGqxRabBGpcEalQZrVBqsUWmwRqXBGpUGa1QarFFpsEalwRqVBmtUGqxRabBGpcEalQZrVBqsUWmwRqXBGpUGa1QarFFpsEalwRqVBmtUGqxRabBGpcEalQZrVBqsUWmwRqXBGpUGa1QarFFpsEalwRqVBmtUGqxRabBGpcEalQZrVBqsUWmwRqXBGpUGa1QarFFpsEalwRqVBmtUGqxRabBGpcEalQZrVBqsUWmwRqXBGpUGa1QarFFpsEalwRqVBmtUGqxRabBGpcEalQZrVBqsUWmwRqXBGpUGa1QarFFpsFalwVqVBmtVGqxVabD2JfJmXZUGa1UarFVpsFalwVqVBmtVGqxVabBWpcFalQZrVRqsVWmwVqXBWpUGa1UarFVpsFalwVqVBmtVGqxVabBWpcFalQZrVRqsVWmwVqXBWpUGa1UarFVpsFalwVqVBmtVGqxVabBWpcFalQZrVRqsVWmwVqXBWpUG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NFih0mCFSoMVKg1WqDRYodJghUqDFSoNVqg0WKHSYIVKgxUqDVaoNFih0mCFSoMVKg1WqDRYodJghUqDFSoNVqg0WKHSYIVKgxUqDVaoNFih0mCFSoMVKg1WqDRYodJghUqDFSoNVqg0WKHSYIVKg5UqDVaqNFip0mClSoOVL5E3a6o0WKnSYKVKg5UqDVaqNFip0mClSoOVKg1WqjRYqdJgpUqDlSoNVn5usCxePz7BwvN3vs5l/fUPvtuff6y9Pv2xZuk//uj3b+/99sffb19qFb/UCX6pz53W/99fyhS/lCt+qVD8Uqn4pUrxS7Xil1J8o7viG90V3+ih+EYPxTd6KL7R4094o9tr4ufnxOt3vtYf/YvG+vnlK/1f/LH+86vn/7xfvf7n/er9P+9X//y/ND7321e/f/UhPw6XHh48/NyG/ZFDo4dOD4MeJj0setj0kC4n6XKSLqfocooup+hyii6n6HKKLqfocooup+hyii6n6XKaLqfpcpoup+lymi6n6XKaLqfpcpouZ+hyhi5n6HKGLmfocoYuZ+hyhi5n6HKGLmfpcpYuZ+lyli5n6XKWLmfpcpYuZ+lyli7n6HKOLufoco4u5+hyji7n6HKOLufocg4up14vemj00Olh0MOkh0UPmx4OPVx6SJdjdDlGl2N0OUaXY3Q5RpdjdDlGl2N0OUaX43Q5TpfjdDlOl+N0OU6X43Q5TpfjdDlOlxN0OUGXE3Q5QZcTdDlBlxN0OdSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0MeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR805HhBQ34fGj10ehj0MOlh0cOmh0MPlx7S5RhdjtHlGF2O0eUYXY7R5RhdjtHlGF2O0eU4XY7T5ThdjtPlOF2O0+U4XY7T5ThdjtPlBF1O0OUEXU7Q5QRdTtDlBF1O0OUEXU7Q5SRdTtLlJF1O0uUkXU7S5SRdTtLlJF1O0uUUXU7R5RRdTtHlFF1O0eUUXU7R5RRdTtHlNF1O0+U0XU7T5TRdTtPlNF1O0+U0XU7T5QxdztDlDF3O0OUMXc7Q5QxdztDlDF3O0OUsXc7S5SxdztLlLF3O0uUsXc7S5SxdztLlHF3O0eUcXc7R5RxdztHlHF3O0eUcXQ41ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUN2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUENOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUNuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUENeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryQUPOFzTk96HRQ6eHQQ8//unwsL/eeftvZ6/8ebbs7NDZZ5L9/TNjZ87Ogp0lOyt21uyMrcTYSoytxNlKnK3E2UqcrcTZSpytxNlKnK3E2UqcrSTYSoKtJNhKgq0k2EqCrSTYSoKtJNhKgq0k2UqSrSTZSpKtJNlKkq0k2UqSrSTZSpKtpNhKiq2k2EqKraTYSoqtpNhKiq2k2EqKraTZSpqtpNlKmq2k2UqaraTZSpqtpNlKmq1k2EqGrWTYSoatZNhKhq1k2EqGrWTYSoatZNlKlq1k2UqWrWTZSpatZNlKlq1k2UqWreTYSo6t5NhKjq3k2EqOreTYSo6t5NhKDq3EXi92ZuzM2Vmws2Rnxc6anQ07W3bGVsLs1Zi9GrNXY/ZqzF6N2asxezVmr8bs1Zi9GrNXY/ZqzF6N2asxezVmr8bs1Zi9GrNXY/ZqzF6N2asxezVmr8bs1Zi9GrNXY/ZqzF6N2asxezVmr8bs1Zi9GrNXY/ZqzF6N2asxezVmr8bs1Zi9GrNXY/ZqzF6N2asxezVmr8bs1Zi9GrNXY/ZqzF6N2asxezVmr8bs1Zi9GrNXY/ZqzF6N2asxezVmr8bs1Zi9GrNXY/ZqzF6N2asxezVmr8bs1Zi9GrNXY/ZqzF6N2asxezVmr8bs1Zi9GrNXY/ZqzF6N2asxezVmr8bs1Zi9OrNXZ/bqzF6d2ev7t9hZsbNmZ8POlp2xlTB7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9hrMXoPZazB7DWavwew1mL0Gs9dg9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1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yew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7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yew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0ms9dk9prMXpPZazJ7TWavyew1mb0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb02s9dm9trMXpvZazN7bWavzey1mb0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zB7HWavw+x1mL0Os9dh9jrMXofZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXg/Z65teX+zM2Jmzs2Bnyc6KnTU7G3a27IytxNhKjK3E2EqMrcTYSoytxNhKjK3E2EqMrcTZSpytxNlKnK3E2UqcrcTZSpytxNlKnK0k2EqCrSTYSoKtJNhKgq0k2EqCrSTYSoKtJNlKkq0k2UqSrSTZSpKtJNlKkq0k2UqSraTYSoqtpNhKiq2k2EqKraTYSoqtpNhKiq2k2UqaraTZSpqtpNlKmq2k2UqaraTZSpqtZNhKhq1k2EqGrWTYSoatZNhKhq1k2EqGrWTZSpatZNlKlq1k2UqWrWTZSpatZNlKlq3k2EqOreTYSo6t5NhKjq3k2EqOreTYSpi9GrNXY/ZqzF6N2asxezVmr8bs1Zi9GrNXY/ZqzF6N2asxezVmr8bs1Zi9GrNXY/ZqzF6N2av9wl779Ttnxs6CnX38b7LO/3pWVx/PPv432a/761m7fTw7dPbZJ3//zNiZs7NgZ8nOip393p+3+Hx26OyzGHbNj7O+j2fGzpydBTtLdlbsrNnZsLNlZ4fOPothZ/84u/x4Zuws2Fmys0Fv5V9g3O+eHTpr9j9UnzEuYn/8b0ekv34evv8a+eeh08Ogh0kPix42PRx6uPTw4OFnnvsjh3Q5Q5czdDlDlzN0OUOXM3Q5Q5czdDlLl7N0OUuXs3Q5S5ezdDlLl7N0OUuXs3Q5R5dzdDlHl3N0OUeXc3Q5R5dzdDlHl3NwOf560UOjh04Pgx4mPSx62PRw6OHSQ7oco8sxuhyjyzG6HKPLMboco8sxuhyjyzG6HKfLcbocp8txuhyny3G6HKfLcbocp8txupygywm6nKDLCbqcoMsJupygywm6nKDLCbqcpMtJupyky0m6nKTLSbqcpMtJupyky0m6nKLLKbqcosspupyiyym6nKLLKbqcosspupymy6GG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQ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" }, { "name": "increment", "function_type": "Secret", "is_internal": false, "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "contract_deployment_data", "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "initialization_hash", "type": { "kind": "field" } }, { "name": "contract_class_id", "type": { "kind": "struct", "path": "aztec::protocol_types::contract_class_id::ContractClassId", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "contract_address_salt", "type": { "kind": "field" } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }] }, "visibility": "private" }, { "name": "owner", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "inputs": [{ "start": 0, "end": 41 }], "owner": [{ "start": 41, "end": 42 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "contract_deployment_data", "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "initialization_hash", "type": { "kind": "field" } }, { "name": "contract_class_id", "type": { "kind": "struct", "path": "aztec::protocol_types::contract_class_id::ContractClassId", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "contract_address_salt", "type": { "kind": "field" } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278] }, "bytecode": "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", "debug_symbols": "5ZjbjtowEIbfJdcIeY728CrVXtCWSkiIXS2oUoV49yYEO2bXIt0gqkS5IhEzk8+/x56xT9Xu9cf6uH3dH6rVqQKoVt9O1eFtvW9eD8f1+7FauUW12f+sf8+L6td2t6lWiPXzJzsQu1pCgGQLTgu2SCFcjZFZOmuDUmRglBgbONiN/cuiApwqOP03cEGM4BLwYXB+BJxYYnRi3wVXd4ktT4ytT4ztnxg7lGLXU81xllw2qeUvGMcPmIUsXdygBLCRAaF7HAicp/QNcj1I/zqzksCFcwK8YMM0sXGa2DRNbO7FNu1bbCFRO4SbLxSqhfmIg5bVFnT+wiOP8wAgJBnV9QABiEZrtKx8uVL5ChxBQjadbKWROotFFAG7XUhKzCHNvDm5b1qPLg2vrr03Cg7Z3XSeipsmCAfaI3mviH7cItYkIcU2y2Vs6MN06OuJ/UhvI6fHLndQw/0UDowp3Tlb3G2vRm4+Q4WxD9VSThJTz8bE6LqznfZs2ZzqqVBXC/SS7ISzlcVDHKPPbLWYWqSp/e8YIAwqkESzlVwtnuy98n3JwVy6BXDZaoagg0Tn+ea593FbbP6/Xf4jb4+/KEsKjeqhRxbysbeTrLVjbk8xy6IwqR2ErGvw0nZsSyhWUwyUmsig9OmAUvvBQL/i3i2pD1XJ1pi2RXBZvg0hjjJTdr9xzRFYlm8s+pxgiBMOcaIvO8myfDIUipkvHj9kReOkQ5yKzbySS8uyy1VP55f65ff6fbv+vts0l9316/HPW/t4/gs=" }, { "name": "compute_note_hash_and_nullifier", "function_type": "Unconstrained", "is_internal": false, "abi": { "parameters": [{ "name": "contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "nonce", "type": { "kind": "field" }, "visibility": "private" }, { "name": "storage_slot", "type": { "kind": "field" }, "visibility": "private" }, { "name": "note_type_id", "type": { "kind": "field" }, "visibility": "private" }, { "name": "serialized_note", "type": { "kind": "array", "length": 20, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "contract_address": [{ "start": 0, "end": 1 }], "nonce": [{ "start": 1, "end": 2 }], "note_type_id": [{ "start": 3, "end": 4 }], "serialized_note": [{ "start": 4, "end": 24 }], "storage_slot": [{ "start": 2, "end": 3 }] }, "return_type": { "abi_type": { "kind": "array", "length": 4, "type": { "kind": "field" } }, "visibility": "public" }, "return_witnesses": [24, 25, 26, 27] }, "bytecode": "H4sIAAAAAAAA/+2dS2/bRhSFhxQtWy/LkmVLtvygG6fZSn4ASVfKqgUKFAWKLLpMaqcwGiSAkwDNqr+z/6KbbtN6aB7r8IoSJHVuMwQ0gCByhpz57uE8OeSwb4wJzL0r3f3WzKRD+Cj9H/w3N3QY10CTMygIZ1gQzpJDTsvWMbr5NFLQ1TXjWgEYywVgXC8A40YBGCsFYKwWgLFWAMZ6ARgbBWDcLABjswCMWwVgbBWAsV0Axu0CMHYKwLhTAMbdAjB2HTIGxBil2727397db//u17/7vQjv/TfM2MWuGC6Gv9g+OxLvmayzfZMQO9HYrwRu8gN/SH64x1CKxjaUndswuLDxrruONx0rQJMNstEd+/DpBunkkF1LkyTPIi+W07iRzhppVUm3Hd5bGXLaQfqrUJomvUbY7pqxq9A28jS462acLytTzonEOQ0KL+fYHTu2e51YYtpHemupHdbZ/lEvynJbts10+/OSbK+enr0aXg+fXV4NXp69vnx2dX5xCS2QFvLAJvkh/JJYD4ir6V6zixqlCxeI/Zi2mzk6OeQZKtk5sPFupXEte13znI2jRfo0hE4NCt8i7VoK2gWULuLGPjOueFe8SK+W/pjV7qOORBm3ddFfwZi3ocQ7rf5uGD/SVqjzzhatgzeJZ8s9z3mN0piHh/OxQt09VLJzwOXOdZvQNpPXCzY0KLxF2rUVtAsoXcSNfWZc8erxNsy4fIO1Jnh9YIRfkxg3hI62HXhBvDjWYfk5D0gnO2b4gziQXkTH/B2M2X5O/eoUzu1anuZabe80zVvECHu4DtVq36b1BVgLcIyMTj3r0KYknyD/lqdoHNEx1+k/7J5Vh9RJlzbp03KvT9K+bSvp0xH6gH+b9MExb4Q+nRx9OO+2xXFsx8i46x/ZeHeU9NkV+oB/h/TBMe+FPvBnfbZJn444TmvMXDPZsm3dvP3HXSWeRfqPrI/CdU54dhfg2SGerhLPzgI8XeLpKfF0F+Dhe717Sjy9BXj2iGdfiWdvAR4w2PZDtrH2H2WD+17Inx3yQx4JyQ/XqUR+0IrvYfaIc2Sc6DBokA6cBzTq5kU11y6zSnYmY0Wum/aEPZw3uJ+mUW8HJlsvxbTPjPPytgvG2/GAVyufKfU9zm2cFdJ1U+jLdvXdp3+2aN+nTzwabYWSnUk9cUB2NIU9DQrnduBAwcaA0kXc2GfGeXl3PeBVSvsM5aMp0tsRetj0jxTSX7Tve0Q8h+55hkp2JuXjmOzYFfY0KDwkG48VbAwoXcSNfWacl7fvAa/SdUuev4jdx/tQ7rgdN1PseqSQvi13JybrZpW7R8TzlXueoZKdSbk7JTtOhD0NCi+RjacKNgaULuLGPjPOy3vsAa/SdTu38T52H+9DuYOuj4W+bNeTdNv13NvXaVy2H4Q894T8EH5E8wZ/EteJgt41k73W1s2qD06IR6s+ULBzIO14JOxpUDiPZ2MFGwOTrYNjYbPJ2Z7F2y4Yb8cDXq18ptQfeRjPQtcjoS/bpdA/TvoN097jNILBEIPWvKGSnRPj2Y6w5/8ezx6arL7YnzaencUbe8CrPZ7tiPROhB5KcwNJ+YhN1s0qH9pzA0p2JuWjl2MT0uL7/jye1ZgfCkz2XnxsJucBFuE99IBX6bpdKM0/PJS7OI2vK/RVno9Jyh3XOdbNKnc8H6NxL11zPmab7DgU9jQonMezCs9vzJwvYMZ5eXse8GrNFyo9Y/RQ7qBrS+gLu2pm/I4J/Oy48qdgbPdqXLm8k3asxpVfjnc1rlzYrcaVWbcaV5L/aly5GlcKtxpXkv9qXPnlx5Xcv4Uf929teDX153etX6Th/H4b5yuFua3hrHLL83yGOHziUZ77W5in4hlPzTOeumc8Zc941j3jaXvGU/KMp+8ZT9UznsgzHuVnmRbmWfOMJ/CAp2YmxxN8765NfqE419afT8JxOPq5IZ2D8VKJ/DAuicgP/bo18kN/rpzDdUh+uF94QH4Yn+2TX5xu75Ef7nf0ctLl66PxPlEg0oppH+nViUP7/aZ5edY84zn2jCfyjKfqGU/fM56SZzxtz3jWPeMpe8ZT94yn5hlPxTOeU894NjzjCXN4FO4lJ3PEvNYFuNjFtL2vrI+SnRNzP21hD8+l8JhSay5l32T1xf60uZ9ZvEcF44094NXKZ0pzlw9zxND1UOjLdinMBVwsOgfG61IozJkPleyceOc+FvbwO+F8L0zrnfCuYMH+tHfY4xm8xwXjPS0Y74EHvLxmZ0x+6B+jLPKanbzGZI3+8b5+nfxCsht+GLvh+Iop7hprocmut2ZSJrvtfv294YXlxDOBcp0ypBfRMf+k1wzc/HxnWdhSN5Nrelk7Os7tuF8va2eKHR2yA8eshWM7NJ/7VLA1+SbfLtnUzLET4dXUzmRtcbpPi+vBa+j2c8LhZrW1/Dy1wrMNyXr16Ovj2vZy0t4nVkdpZ56rCNIf0oF/RNv7qKBMtg8IncFty0Y35zjels9GNyi8m2N3bHTGiYi7JxhtnmlS/kL+0amr7vN9N0cfrtMR3iK/hji+JsLBrLCOb6JjS+jYyuGGH8//gtfhO8hDTgPpSG02BItcV1XjWxfcjsPNqnN4Hs/5Nz3S785Bk1+vP/zw8c2bm9c317ffX3/68eXNbUCIwI4EdmCyJshw68IcPyWJk6wYmaycUY6caMZHxu2wVOFTJkn3BdkVTQP410l3HHNOzb4hf+tKFI91daEL/tfd65MMJxU+O5LoUxX6yM+ORHTMN0If+LM+/MmVDXEc2zEy7h4FtPHWlPSpC33AXyN9cMxzoQ/8WZ8KhVXFcWzHyLjtaio8Cp/osyn0kZ9k4OWuvxP6bOboUyNN5KcceNjHjxAgLX40QJZhHt5VyY+HW/ALc9LlZSvhh/qRlx0Hwxb5oc5AWjYPyObLaUUu5ytNmmCYhuE7PhZs3YwLZtWMx+NY77OZGmPhbZtv2z07lrB9azuO4D7XtG+c8bei4K7Sf/SNn9/evvwU37y9uv49fvfxQ/zudfzq3ce3V+/5pN+WOel2mZM+B0ucFIVLnHS2zEnPljlptMxJ3857kvkXvWQTy4J+AAA=", "debug_symbols": "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" }, { "name": "constructor", "function_type": "Secret", "is_internal": false, "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "contract_deployment_data", "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "initialization_hash", "type": { "kind": "field" } }, { "name": "contract_class_id", "type": { "kind": "struct", "path": "aztec::protocol_types::contract_class_id::ContractClassId", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "contract_address_salt", "type": { "kind": "field" } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }] }, "visibility": "private" }, { "name": "headstart", "type": { "kind": "integer", "sign": "unsigned", "width": 120 }, "visibility": "private" }, { "name": "owner", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "headstart": [{ "start": 41, "end": 42 }], "inputs": [{ "start": 0, "end": 41 }], "owner": [{ "start": 42, "end": 43 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "contract_deployment_data", "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "initialization_hash", "type": { "kind": "field" } }, { "name": "contract_class_id", "type": { "kind": "struct", "path": "aztec::protocol_types::contract_class_id::ContractClassId", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "contract_address_salt", "type": { "kind": "field" } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279] }, "bytecode": "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", "debug_symbols": "5VjbbuIwEP2XPCPkuXrMr6z6wO6yEhKiVUErrRD/voFgx7RW3QZREeWJRMycHB/PeGZ8aDbPv5b79fN21ywODWCz+HFodi/L7el1t1++7puFmzWr7e/29zhr/qw3q2aB2D6/swMJF0swSLbgtGCLZHYxRmbprQOUkIFRIjawhSv7p1kDNFbi/G3EBTESF8ObicstxIklohP7HlzdGVvviO3viG13xA4lbGO9uJhyBT9whA/BsmBxQ7Yf3WPRgVvpgPOUvkCuQuizeyqJtjBmtngmjWMkTWMkzWMkLRXSprUUs8TZIVzhF+pD8JEMhqyaoPNnNnorGwCEJKG6Ch0AidCAIStXrlSujDnx6G05lNbpQiyaCNifPFLibGnXg5OPTdvVpeW1tfZKvyEnmp+i3kETCQdaEbwqoT2yhG2XZgk7hFzEE/cwFu7tpr7hTu6huWMfNaj2cfAaYwp0zpK668kIprJQfOyFhhSNxFQ5jhhdP79p5ZjmVEGF+vNfuzCniYriIYaKz2y1GFakqcnvOYANKonEExVcQ5zcfdaoFgWH4NKU77I8BtNBkstUY9z7uMTT/9eJ/9Ct8BdFSdCoHiqikI+dnGSNHHM3rcyLsZKaP8j6BC9dfzaHYquARqllNKV3o0jrBwP9ioVMUtepkuWXdqVvXr56IY4yU3Z/cYkQnJcvSGpOMMQJhzjRl510Xp5IhWI5EI9vouLkpEOcitOPkktJ2ceqp+NT+/J3+bpe/tysThfZ7ev+30v3ePwP" }], "events": [], "file_map": { "3": { "source": "struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    // TODO: change this to return a u64 as Noir now\n    // uses u64 for indexing\n    len: Field,\n    empty_value: T,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0, empty_value: initial_value }\n    }\n\n    pub fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: Field) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> Field {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> Field {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + (i as Field)] = vec.get_unchecked(i as Field);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = self.empty_value;\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if (!exceeded_len) {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}", "path": "std/collections/bounded_vec.nr" }, "31": { "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n", "path": "std/option.nr" }, "44": { "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint};\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    log: [Field; N]\n) {\n    let _ = oracle::logs::emit_encrypted_log(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        encryption_pub_key,\n        log\n    );\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(context: &mut PublicContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(context: &mut PrivateContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/log.nr" }, "48": { "source": "use dep::std::option::Option;\nuse dep::protocol_types::{\n    constants::{\n        MAX_READ_REQUESTS_PER_CALL,\n        GET_NOTE_ORACLE_RETURN_LENGTH,\n        GET_NOTES_ORACLE_RETURN_LENGTH,\n        MAX_NOTES_PER_PAGE,\n        VIEW_NOTE_ORACLE_RETURN_LENGTH,\n    },\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption,\n};\nuse crate::oracle;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address));\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(fields: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let isEqual = fields[select.field_index] == select.value;\n        let isLt = fields[select.field_index].lt(select.value);\n\n        if (select.comparator == Comparator.EQ) {\n            assert(isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(isLt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(isLt | isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!isLt & !isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!isLt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index] as u120 < fields_1[sort.field_index] as u120;\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [Field; N], [u3; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (num_selects, select_by, select_values, select_comparators, sort_by, sort_order)\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_getter.nr" }, "49": { "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_insertion, compute_note_hash_for_consumption}\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    broadcast: bool\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    // As `is_transient` is true, this will compute the inner note hsah\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    // TODO: Strong typing required because of https://github.com/noir-lang/noir/issues/4088\n    let serialized_note: [Field; N] = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash\n    )\n        == 0\n    );\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        Note::broadcast(*note, context, storage_slot);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(context: &mut PrivateContext, note: Note) where Note: NoteInterface<N> {\n    let mut nullifier = 0;\n    let mut consumed_note_hash: Field = 0;\n    nullifier = note.compute_nullifier(context);\n\n    // We also need the note hash corresponding to the \"nullifier\"\n    let header = note.get_header();\n    // `consumed_note_hash` is used to inform the kernel which pending note hash\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // note hash) in which case `consumed_note_hash` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note hash computed in `compute_nullifier`?\n        consumed_note_hash = compute_note_hash_for_consumption(note);\n    }\n    assert(notify_nullified_note(nullifier, consumed_note_hash) == 0);\n\n    context.push_new_nullifier(nullifier, consumed_note_hash)\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr" }, "50": { "source": "use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__SILOED_NOTE_HASH},\n    hash::pedersen_hash, utils::arr_copy_slice\n};\n\nfn compute_siloed_hash(contract_address: AztecAddress, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address.to_field(), inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_NOTE_HASH)\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\nfn compute_inner_note_hash<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([header.storage_slot, note_hash], 0)\n}\n\nfn compute_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let inner_note_hash = compute_inner_note_hash(note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let siloed_note_hash = compute_siloed_note_hash(note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n    let inner_nullifier = note_with_header.compute_nullifier(context);\n\n    let input = [header.contract_address.to_field(), inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_insertion<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    compute_inner_note_hash(note)\n}\n\npub fn compute_note_hash_for_consumption<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note)\n    }\n}\n\npub fn compute_note_hash_and_nullifier<T, N, S>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    T::set_header((&mut note), note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = note.compute_nullifier_without_context();\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/note/utils.nr" }, "60": { "source": "use crate::{\n    context::inputs::PrivateContextInputs, key::nullifier_key::validate_nullifier_key_against_address,\n    messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair},\n    debug_log::debug_log\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n    nullifier_key_validation_request::NullifierKeyValidationRequest,\n    private_call_stack_item::PrivateCallStackItem,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader\n};\nuse dep::std::option::Option;\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<SideEffect, MAX_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let side_effect_counter = inputs.call_context.start_side_effect_counter;\n        let mut min_revertible_side_effect_counter = 0;\n        // Note. The side effect counter is 2 when this is the initial call\n        if (side_effect_counter == 2) {\n            min_revertible_side_effect_counter = side_effect_counter;\n        }\n        PrivateContext {\n            inputs,\n            side_effect_counter,\n            min_revertible_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(0),\n            read_requests: BoundedVec::new(SideEffect::empty()),\n            nullifier_key_validation_requests: BoundedVec::new(NullifierKeyValidationRequest::empty()),\n            new_note_hashes: BoundedVec::new(SideEffect::empty()),\n            new_nullifiers: BoundedVec::new(SideEffectLinkedToNoteHash::empty()),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(0),\n            public_call_stack_hashes: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(L2ToL1Message::empty()),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            // TODO(fees): start this from 0 and test the following:\n            // - in the private circuit init that it gets set correctly\n            // - in the private circuit inner that it remains 0\n            // I've had to initialize the counter here so that it would work for contract deployments\n            // the above checks should be doable after we figure out fee payments for contract deployments\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            read_requests: self.read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_min_revertible_side_effect_counter(&mut self) {\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        let side_effect = SideEffect { value: read_request, counter: self.side_effect_counter };\n        self.read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            msg_key,\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_note_hashes: [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero()\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr" }, "66": { "source": "use dep::std::option::Option;\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    utils::arr_copy_slice,\n};\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u3; N],\n    _sort_by: [u8; N],\n    _sort_order: [u2; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u2,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u3; N],\n    sort_by: [u8; N],\n    sort_order: [u2; N],\n    limit: u32,\n    offset: u32,\n    status: u2,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u3; M],\n    sort_by: [u8; M],\n    sort_order: [u2; M],\n    limit: u32,\n    offset: u32,\n    status: u2,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i as u32 < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: Field = 2; // num_notes & contract_address.\n            let extra_preimage_length: Field = 2; // nonce & is_transient.\n            let read_offset: Field = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n            Note::set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr" }, "69": { "source": "use dep::protocol_types::{address::{AztecAddress, PartialAddress, PublicKeysHash}, grumpkin_point::GrumpkinPoint};\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: AztecAddress) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: AztecAddress) -> [Field; 3] {\n    get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: AztecAddress) -> GrumpkinPoint {\n    let result = get_public_key_and_partial_address_internal(address);\n    let pub_key = GrumpkinPoint::new(result[0], result[1]);\n    let partial_address = PartialAddress::from_field(result[2]);\n\n    let calculated_address = AztecAddress::compute(PublicKeysHash::compute(pub_key), partial_address);\n    assert(calculated_address.eq(address));\n\n    pub_key\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_public_key.nr" }, "73": { "source": "use dep::protocol_types::{address::AztecAddress, constants::NUM_FIELDS_PER_SHA256, grumpkin_point::GrumpkinPoint};\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _encryption_pub_key: GrumpkinPoint,\n    _preimage: [Field; N]\n) -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    preimage: [Field; N]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [\n        emit_encrypted_log_oracle(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            encryption_pub_key,\n            preimage\n        ), 0\n    ]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(\n    _contract_address: AztecAddress,\n    _event_selector: Field,\n    _message: T\n) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    message: T\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/logs.nr" }, "75": { "source": "#[oracle(getRandomField)]\nfn rand_oracle() -> Field {}\n\nunconstrained pub fn rand() -> Field {\n    rand_oracle()\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/rand.nr" }, "78": { "source": "use dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint, grumpkin_private_key::GrumpkinPrivateKey};\n\nstruct NullifierKeyPair {\n    account: AztecAddress,\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\n#[oracle(getNullifierKeyPair)]\nfn get_nullifier_key_pair_oracle(_account: AztecAddress) -> [Field; 4] {}\n\nunconstrained fn get_nullifier_key_pair_internal(account: AztecAddress) -> NullifierKeyPair {\n    let result = get_nullifier_key_pair_oracle(account);\n    NullifierKeyPair {\n        account,\n        public_key: GrumpkinPoint { x: result[0], y: result[1] },\n        secret_key: GrumpkinPrivateKey { high: result[2], low: result[3] }\n    }\n}\n\npub fn get_nullifier_key_pair(account: AztecAddress) -> NullifierKeyPair {\n    get_nullifier_key_pair_internal(account)\n}\n\npub fn get_nullifier_secret_key(account: AztecAddress) -> GrumpkinPrivateKey {\n    get_nullifier_key_pair_internal(account).secret_key\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/nullifier_key.nr" }, "85": { "source": "mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod avm;\n\nuse private_context::PrivateContext;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none() }\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/context.nr" }, "100": { "source": "use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::std::option::Option;\nuse dep::protocol_types::{hash::pedersen_hash, traits::{ToField}};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T> Storage<T> for Map<K, T> {}\n\nimpl<K, V> Map<K, V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key.to_field()], 0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/map.nr" }, "101": { "source": "use dep::std::option::Option;\nuse dep::protocol_types::{\n    constants::{MAX_NOTES_PER_PAGE, MAX_READ_REQUESTS_PER_CALL},\n    abis::side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader, note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct Set<Note> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T> Storage<T> for Set<T> {}\n\nimpl<Note> Set<Note> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Set { context, storage_slot }\n    }\n    // docs:end:new\n    // docs:start:insert\n    pub fn insert<N>(self, note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        create_note(\n            self.context.private.unwrap(),\n            self.storage_slot,\n            note,\n            broadcast\n        );\n    }\n    // docs:end:insert\n\n    // docs:start:insert_from_public\n    pub fn insert_from_public<N>(self, note: &mut Note) where Note: NoteInterface<N> {\n        create_note_hash_from_public(self.context.public.unwrap(), self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n\n    // DEPRECATED\n    fn assert_contains_and_remove(_self: Self, _note: &mut Note, _nonce: Field) {\n        assert(\n            false, \"`assert_contains_and_remove` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use Set.get_notes() and Set.remove() in your contract to verify and remove a note.\"\n        );\n    }\n\n    // DEPRECATED\n    fn assert_contains_and_remove_publicly_created(_self: Self, _note: &mut Note) {\n        assert(\n            false, \"`assert_contains_and_remove_publicly_created` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use Set.get_notes() and Set.remove() in your contract to verify and remove a note.\"\n        );\n    }\n\n    // docs:start:remove\n    pub fn remove<N>(self, note: Note) where Note: NoteInterface<N> {\n        let context = self.context.private.unwrap();\n        let note_hash = compute_note_hash_for_consumption(note);\n        let has_been_read = context.read_requests.any(|r: SideEffect| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note(context, note);\n    }\n    // docs:end:remove\n\n    // docs:start:get_notes\n    pub fn get_notes<N, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, FILTER_ARGS>\n    ) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n        let storage_slot = self.storage_slot;\n        let opt_notes = get_notes(self.context.private.unwrap(), storage_slot, options);\n        opt_notes\n    }\n    // docs:end:get_notes\n\n    // docs:start:view_notes\n    unconstrained pub fn view_notes<N>(\n        self,\n        options: NoteViewerOptions<Note, N>\n    ) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/set.nr" }, "106": { "source": "use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/hasher.nr" }, "185": { "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: Field) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/utils.nr" }, "186": { "source": "use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS},\n    contract_class_id::ContractClassId, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute_from_public_key(\n        pub_key: GrumpkinPoint,\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> AztecAddress {\n        AztecAddress::compute(\n            PublicKeysHash::compute(pub_key),\n            PartialAddress::compute(\n                contract_class_id,\n                salt,\n                initialization_hash,\n                portal_contract_address\n            )\n        )\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let contract_address_salt = 3;\n    let contract_class_id = ContractClassId::from_field(4);\n    let initialization_hash = 5;\n    let portal_contract_address = EthAddress::from_field(6);\n\n    let address = AztecAddress::compute_from_public_key(\n        point,\n        contract_class_id,\n        contract_address_salt,\n        initialization_hash,\n        portal_contract_address\n    );\n\n    assert(address.to_field() == 0x2fd71a4f0742364f194dd16d0ae32d2f47845ddc7f5d328f37d4148b565c4123);\n}\n\n#[test]\nfn compute_address_from_partial_and_pubkey() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let partial_address = PartialAddress::from_field(3);\n\n    let address = AztecAddress::compute(PublicKeysHash::compute(point), partial_address);\n    assert(address.to_field() == 0x0447f893197175723deb223696e2e96dbba1e707ee8507766373558877e74197);\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/address/aztec_address.nr" }, "187": { "source": "use crate::{\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{ToField, Serialize, Deserialize}\n};\n\n// Public keys hash. Used in the computation of an address.\nstruct PublicKeysHash {\n    inner: Field\n}\n\nimpl ToField for PublicKeysHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<1> for PublicKeysHash {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<1> for PublicKeysHash {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        PublicKeysHash::from_field(fields[0])\n    }\n}\n\nimpl PublicKeysHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(public_key: GrumpkinPoint) -> Self {\n        PublicKeysHash::from_field(\n            pedersen_hash(\n                [\n            public_key.x,\n            public_key.y\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let actual = PublicKeysHash::compute(point);\n    assert(actual.to_field() == 0x1923a6246e305720b6aaf751fde0342613e93c82e455c3831e28375c16dd40d8);\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/address/public_keys_hash.nr" }, "191": { "source": "use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::FunctionLeafPreimage;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::new_contract_data::NewContractData as ContractLeafPreimage;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, CONTRACT_TREE_HEIGHT, FUNCTION_TREE_HEIGHT,\n    NOTE_HASH_TREE_HEIGHT, NUM_FIELDS_PER_SHA256, GENERATOR_INDEX__SILOED_NOTE_HASH,\n    GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK, GENERATOR_INDEX__CONSTRUCTOR,\n    GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Checks that `value` is a member of a merkle tree with root `root` at position `index`\n// The witness being the `sibling_path`\npub fn assert_check_membership<N>(value: Field, index: Field, sibling_path: [Field; N], root: Field) {\n    let calculated_root = root_from_sibling_path(value, index, sibling_path);\n    assert(calculated_root == root, \"membership check failed\");\n}\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<N>(leaf: Field, leaf_index: Field, sibling_path: [Field; N]) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\n// Calculate the contract tree root from the sibling path and leaf preimage.\npub fn contract_tree_root_from_siblings(\n    contract_class_id: ContractClassId,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    contract_leaf_index: Field,\n    contract_leaf_sibling_path: [Field; CONTRACT_TREE_HEIGHT]\n) -> Field {\n    //TODO(Kev): if we use shorthand syntax here, we get an error as expected,\n    // since variable name is `storage_contract_address` but the span is incorrect.\n    let contract_leaf_preimage = ContractLeafPreimage { contract_address: storage_contract_address, portal_contract_address, contract_class_id };\n\n    let contract_leaf = contract_leaf_preimage.hash();\n\n    let computed_contract_tree_root = root_from_sibling_path(contract_leaf, contract_leaf_index, contract_leaf_sibling_path);\n\n    computed_contract_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn read_request_root_from_siblings(\n    read_request: Field,\n    leaf_index: Field,\n    sibling_path: [Field; NOTE_HASH_TREE_HEIGHT]\n) -> Field {\n    root_from_sibling_path(read_request, leaf_index, sibling_path)\n}\n\npub fn silo_note_hash(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\nfn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new(0);\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, commitment_index: Field) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_siloed_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_unique_siloed_note_hashes<N>(\n    first_nullifier: Field,\n    siloed_note_hashes: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_note_hashes = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_note_hash = siloed_note_hashes[i];\n        if siloed_note_hash.value != 0 {\n            let nonce = compute_note_hash_nonce(first_nullifier, i);\n            unique_siloed_note_hashes[i] = SideEffect {\n                value: compute_unique_siloed_note_hash(nonce, siloed_note_hash.value),\n                counter: siloed_note_hash.counter\n                };\n        }\n    }\n    unique_siloed_note_hashes\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/hash.nr" }, "204": { "source": "use dep::aztec::note::{note_getter::view_notes, note_viewer_options::NoteViewerOptions};\nuse dep::aztec::state_vars::set::Set;\nuse crate::value_note::ValueNote;\n\nunconstrained pub fn get_balance(set: Set<ValueNote>) -> Field {\n    get_balance_with_offset(set, 0)\n}\n\nunconstrained pub fn get_balance_with_offset(set: Set<ValueNote>, offset: u32) -> Field {\n    let mut balance = 0;\n    // docs:start:view_notes\n    let options = NoteViewerOptions::new().set_offset(offset);\n    let opt_notes = set.view_notes(options);\n    // docs:end:view_notes\n    let len = opt_notes.len();\n    for i in 0..len {\n        if opt_notes[i].is_some() {\n            balance += opt_notes[i].unwrap_unchecked().value;\n        }\n    }\n    if (opt_notes[len - 1].is_some()) {\n        balance += get_balance_with_offset(set, offset + opt_notes.len() as u32);\n    }\n\n    balance\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/value-note/src/balance_utils.nr" }, "207": { "source": "use dep::aztec::{\n    protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::{rand::rand, nullifier_key::get_nullifier_secret_key, get_public_key::get_public_key},\n    log::emit_encrypted_log, hash::pedersen_hash, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\nstruct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n    header: NoteHeader,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN> for ValueNote {\n    fn serialize_content(self) -> [Field; VALUE_NOTE_LEN] {\n        [self.value, self.owner.to_field(), self.randomness]\n    }\n\n    fn deserialize_content(serialized_note: [Field; VALUE_NOTE_LEN]) -> Self {\n        ValueNote {\n            value: serialized_note[0],\n            owner: AztecAddress::from_field(serialized_note[1]),\n            randomness: serialized_note[2],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_note_content_hash(self) -> Field {\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash(self.serialize_content(),0)\n    }\n\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    fn get_header(self) -> NoteHeader {\n        self.header\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            Self::get_note_type_id(),\n            encryption_pub_key,\n            self.serialize_content(),\n        );\n    }\n\n    fn get_note_type_id() -> Field {\n        // TODO(#4519): autogenerate\n        // python -c \"print(int(''.join(str(ord(c)) for c in 'ValueNote')))\"\n        869710811710178111116101\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/value-note/src/value_note.nr" }, "220": { "source": "contract Counter {\n    // docs:start:imports\n    use dep::aztec::protocol_types::address::AztecAddress;\n    use dep::aztec::{\n        context::{PrivateContext, Context},\n        note::{\n            note_header::NoteHeader,\n            utils as note_utils,\n        },\n        state_vars::map::Map,\n    };\n    use dep::value_note::{\n            balance_utils,\n            value_note::{\n                ValueNote,\n                VALUE_NOTE_LEN,\n            },\n    };\n    use dep::easy_private_state::EasyPrivateUint;\n    // docs:end:imports\n\n    // docs:start:storage_struct\n    struct Storage {\n        counters: Map<AztecAddress, EasyPrivateUint>,\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(private)]\n    fn constructor(headstart: u120, owner: AztecAddress) {\n        let counters = storage.counters;\n        counters.at(owner).add(headstart, owner);\n    }\n    // docs:end:constructor\n\n    // docs:start:increment\n    #[aztec(private)]\n      fn increment(owner: AztecAddress) {\n        let counters = storage.counters;\n        counters.at(owner).add(1, owner);\n    }\n    // docs:end:increment\n\n    // docs:start:get_counter\n    unconstrained fn get_counter(owner: AztecAddress) -> pub Field {\n        let counters = storage.counters;\n        balance_utils::get_balance(counters.at(owner).set)\n    }\n    // docs:end:get_counter\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-contracts/contracts/counter_contract/src/main.nr" }, "222": { "source": "use dep::aztec::{\n    protocol_types::address::AztecAddress,\n    context::Context,\n    note::note_getter_options::NoteGetterOptions,\n    state_vars::set::Set,\n};\nuse dep::value_note::{\n    filter::filter_notes_min_sum,\n    value_note::ValueNote,\n};\n\nstruct EasyPrivateUint {\n    context: Context,\n    set: Set<ValueNote>,\n    storage_slot: Field,\n}\n\n// Holds a note that can act similarly to an int.\nimpl EasyPrivateUint {\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        let set = Set {\n            context,\n            storage_slot\n        };\n        EasyPrivateUint {\n            context,\n            set,\n            storage_slot,\n        }\n    }\n\n    // Very similar to `value_note::utils::increment`.\n    pub fn add(self, addend: u120, owner: AztecAddress) {\n        // Creates new note for the owner.\n        let mut addend_note = ValueNote::new(addend as Field, owner);\n\n        // Insert the new note to the owner's set of notes.\n        // docs:start:insert\n        self.set.insert(&mut addend_note, true);\n        // docs:end:insert\n    }\n\n    // Very similar to `value_note::utils::decrement`.\n    pub fn sub(self, subtrahend: u120, owner: AztecAddress) {\n        // docs:start:get_notes\n        let options = NoteGetterOptions::with_filter(filter_notes_min_sum, subtrahend as Field);\n        let maybe_notes = self.set.get_notes(options);\n        // docs:end:get_notes\n\n        let mut minuend: u120 = 0;\n        for i in 0..maybe_notes.len() {\n            if maybe_notes[i].is_some() {\n                let note = maybe_notes[i].unwrap_unchecked();\n\n                // Ensure the notes are actually owned by the owner (to prevent user from generating a valid proof while\n                // spending someone else's notes).\n                assert(note.owner.eq(owner));\n\n                // Removes the note from the owner's set of notes.\n                // docs:start:remove\n                self.set.remove(note);\n                // docs:end:remove\n\n                minuend += note.value as u120;\n            }\n        }\n\n        assert(minuend >= subtrahend);\n\n        // Creates change note for the owner.\n        let result_value = minuend - subtrahend;\n        let mut result_note = ValueNote::new(result_value as Field, owner);\n        self.set.insert(&mut result_note, result_value != 0);\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/easy-private-state/src/easy_private_uint.nr" } } }
