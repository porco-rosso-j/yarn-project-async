{ "noir_version": "0.24.0+78ef0134b82e76a73dadb6c7975def22290e3a1a", "name": "EasyPrivateVoting", "functions": [{ "name": "get_vote", "function_type": "Unconstrained", "is_internal": false, "abi": { "parameters": [{ "name": "candidate", "type": { "kind": "field" }, "visibility": "private" }], "param_witnesses": { "candidate": [{ "start": 0, "end": 1 }] }, "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" }, "return_witnesses": [1] }, "bytecode": "H4sIAAAAAAAA/81X20rDQBDdTdJr2rSvgsJ+QdkUn9SH+OybfkEkqQhtA0mK+vNi0s7gcVmK0A1kIJ3J7HbmzNlrpBBCipP4YKOwLyGtL5PYYSwtDZxPZI/Br1zlu9XrYRsk+MsLS9g8Hr9Qn1HzDKFdkp/7LcEnAfvANXat121+38Bs1qDAHgCewD2euKM69Rg4/3bIH48ni2/wNIf2IXA36oA7CXk5Nr8jxv/i9XqAt8v5MHYfdx01MSbA69jgF+uaku1wPmpB+VsJIN8U8s7IlsLtnhtCrRJwzAAP97khvRCnOScs/Ezcj098bm/jfIhH9gBPKOznysTgDM8abEugnWvzwBeR7Vtiz8HHYxdZ/os8zaGWhGx9mRx5wlwK3jnfDHBEPcEzsuDpai/l8eHY/D7qSW7mJRFu9/FFRzUtKdaQYjN+zhdAn3ujjf2tmGsJ5wX3Cy2c4XoOIVZbM69Vh2dHjHck5TBuKH7viizn9j28J3Vw9sdT4LOqizJ9y5/zNJMALTBgojY/L1rxwIe2b/EJSs9lBuDjoR+AzzNowSs7958Iy2daQlpfJse14BsFoyA5nqXfNekH0i8nzlW1LWql1b75Tbfb4iPPVgrbKrU7VLWq6rSs1aYsdipeYdw70lekH8sy/VLv+yz/VMWhVsVGvRaHfVaJHxbgBZTSDgAA", "debug_symbols": "1ZrdaoNAEIXfZa+lzMzO/vkqpRe2TSEQkpBIoQTfvYZsN4EIUknkeLcDZzzfhX4ieDKb3UfTrnfbo6lPhl68qV9P5rhvtuf52DaH1tSWXKzMavt5PkbXVeZrvVmZWix31V06qcvhlGLJMtFAllnlL92fY7rmE3dvVU8U4IgiHFGCI2LCQ2I8JMFDsnhIiofk8JDw1M147mY8eTOevQXP3oJnb8GztzzA3kzBlhZLI1CUozRyVZ98Tga2JZtC5taFcruFcvuFcoeFcseFco+/m5KMcbOkwu3ptuM+bIPkrN7ghKw3S1g4jIUjWDgWC0excBwWjsfCCVg4EQsHy8qKZWXFsrJiWVmxrKxYVlYsKyuWlRXLyoplZcWysnuulS8dPEOHzNBhZ+h4iOkClY6b9ODtwcTle5HkGuYomcjBEXk4ogBHFOGIEhqRJziiwadffChAemdw7ybs+Ak7YcJOnLCT/rfTD9/NYd28b1bnvxP6sf3ZX47dLw==" }, { "name": "compute_note_hash_and_nullifier", "function_type": "Unconstrained", "is_internal": false, "abi": { "parameters": [{ "name": "contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "nonce", "type": { "kind": "field" }, "visibility": "private" }, { "name": "storage_slot", "type": { "kind": "field" }, "visibility": "private" }, { "name": "note_type_id", "type": { "kind": "field" }, "visibility": "private" }, { "name": "serialized_note", "type": { "kind": "array", "length": 20, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "contract_address": [{ "start": 0, "end": 1 }], "nonce": [{ "start": 1, "end": 2 }], "note_type_id": [{ "start": 3, "end": 4 }], "serialized_note": [{ "start": 4, "end": 24 }], "storage_slot": [{ "start": 2, "end": 3 }] }, "return_type": { "abi_type": { "kind": "array", "length": 4, "type": { "kind": "field" } }, "visibility": "public" }, "return_witnesses": [24, 25, 26, 27] }, "bytecode": "H4sIAAAAAAAA/+2YS1KEQAyG09C8wefooLPhCFCycOldvP8VLIl25AedlelFqiZVXfQDOl9CV0g4EZGjb0mXltFvkfW3cB3/J5PiXmNMTmeEMzHCmSpyMtuB4p5TH8Gv2oyZAcbcAGNhgLE0wFgZYKwNMDYGGFsDjJ0BxisDjNcGGG8MMN4aYLwzwHhvgPFggPHBAOOjAcajIqMDRh/6/dKelva8tNPSXsJ8SasMWgzz9M45uyjvaSucmyQy8OtcKtwwJ/wJzMk/htSvNuTqNowz71to7xtqhR787/X9/1qCnxTZY/nk68zKWczD3qInA19Voa/4b2VC3S60CnRSeEfSP9IqFfTlTAt3S+u5rM4843fPdLCe/2H3oGx3ASwDjEVfFuxg4fyo91tuZqv12eaGtrGJxe3GA/TryL6KZOfI+zZhrw/S/U614J9y56cO1hu4p43gOwd6ZW8ZI+OF98KLDPWOtYH1CuaSnS2YS+D9+/ihapAoxGTHBThe44DJwZSDekFroKrBMH4JXMxzsczBlos9Lqa4WOFigJNtTmbxA3QuwfuRT4hpJ8qiGQAA", "debug_symbols": "q1bKyU9OLMnMzytWsqqu1VEqSyzKTEzKSYVySyoLIMxaAA==" }, { "name": "_initialize", "function_type": "Open", "is_internal": true, "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "public_global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] }, "visibility": "private" }, { "name": "admin", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "admin": [{ "start": 39, "end": 40 }], "inputs": [{ "start": 0, "end": 39 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::public_circuit_public_inputs::PublicCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "contract_storage_update_requests", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_update_request::StorageUpdateRequest", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "new_value", "type": { "kind": "field" } }] } } }, { "name": "contract_storage_reads", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_read::StorageRead", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "current_value", "type": { "kind": "field" } }] } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "prover_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] }, "visibility": "public" }, "return_witnesses": [40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233] }, "bytecode": "H4sIAAAAAAAA/+2deXAcxfXHZ2RZkr1aW5bve2UO42u9GkmWZNl4be7T3OY0FtgGYxsbW8aYXCRAAiEhNwnkgoSQg1zkvk9yJ5CQhITcBwT4J7+qX1X+TeX1bj/0pXdG3pWm5W75TdWr7Xkz2+/T33ndM9szu/tiEARhUF7GkR0XVC68vahfCyNb2lOsq2CTM/SEs84TznGecNZ7wjneE84GTzgbPeFs8oRzgiecE1PkVGx1wcuXtHkzFnRNm7HZM02zHmg6yTNNJ3ugaUvgxxg1xRPOVk84p3rCOc0TzumecM7whHOmJ5yzPOGc7QnnHE8453rCOc8TzvmecC7whHOhJ5w5TzjbPOFc5AnnMZ5wHusJ53GecB7vCefiFDmXAOcJ+pV9S/XrMv26XL+u0K95/bqSWXRb6/W6upkUkXWQdeptOb2ti2wVWTdZD1kv2WqyPrI1ZGvJTiRbp9u6nmwD2UlkJ5OdQnYq2Wlkp5OdQXYm2VlkZ5OdQ3Yu2Uay88jOJ7uA7EKyiwyWi8kuIdtEdinZZWSXk11BdiXZVWSbya4m20LWT3YN2bVkW8m2kW0nu47serIdZDeQ7STbRbab7EayPWR7yW4i20e2n2zA0OwA2c1kB8luMTgPkd1K9gqyV5K9iuzVZK8hu43stWSvI7ud7A6yO8leT/YGsrvI7iZ7I9k9ZG8iezPZvWRvIXsr2dvI3k72DrJ3kr2L7D6yd5O9R7NwYt9P9gDZe8neR/Z+sg+QfZDsQbKHyD5E9mGyh8k+QvYI2UfJPkb2cbJPkD1K9kmyT5F9muwzZJ8le4zsc2SfJ/sC2RfJvkT2ZbKvkH2V7GtkXyf7Btk3yb5F9m2y75B9l+x7ZN8ne5zsB2Q/JPsR2Y8NzX9C9lOyn5H9XG/j+bdfkD2hy0/q11/q11/p16eM9/ya7DeG77dkTxu+35H9Xpef0a9/0K9/1K9/0q9/1q9/0a9/1a9/069/16//0K//1K/P6tfn9Ou/9Ovz+vUF/foi2UBrudwUDC65IKWxpnNbv7rXxKKfELx8UZqM09v4Naf99XqdX1nD8Xp9vOFv0OsNhr9Rrzca9U/Q6xMMf6tebzX80/T6NMM/Q6/PMPyz9Poswz9Hr88BfyaAuV/tV75x2hWCj/O3DnzjtW8c+Bq4OvA1at948PFxbwDfBO1rBN9E7WsCX0b7JoCvWfsmap+qPxsMtrWoy4WRLJ2Fa1S9k9KuV9/Lm5w+71ZVb4sl3inp825X9bZa4FU5MlXXNQXyZpr2tYJvuvZNBd8M7ZsGvpnaNx18s7RvBvhma99M8M3Rvlngm6t9s8E3T/vmgG++9s0F3wLtmwe+hdo3H3w57VsAvjbtWwi+RdqXA98x2tcGvmO1bxH4+NmhY8B3vPYdC77F2ncc+HisPh58fI24mMdUsv8L4D3aXwe+JTy+g28pj+3gW8bjOviW85gOvhUQm315GGvYt5LHd/AVtO+lsSwoX4+qJRek1Xc6Sn2yO+16qWZVb2/69ZbuPa4OBrXOQZxu0KpPl1N8DqsdY4faOA7766F8TjC49EGZz0XMrc5DPTH7YXmV8Z4sbO+JaXcu5Xb3AksO1jme6gsbgMNCrnbZydWoILla/iwZGMdULXw9NNZy9TzgSD9XuyRXq19qztUdweCCecfXwmMtVzcDR/q52t0l1wBVLzXn6sFgcMG8489BYy1XdwGHhVztlXG16qXmXL0zGFww7/gz8FjL1VuBI/1c7bWUqx2Sq0H5HkBgHFO18DzMWMvVu4Aj/Vy9tleuAapeas7Vh4LBBfOO5wLHWq7eBxwWcnWrpVyNJFfL9zcD45iqZbZ+HWu5+rAuqzm5J/Wc61zw/VL75oHvV9o3H3xPad8CaFf6ub+1Q3K/6qXm3P9uMLhgHvM9kbGW+18CDgu52iW5WvVSc67ysx54TNXSpl/HWq4+DhwWcrVbcrXqpeZc5WeD8Jiqhe8Nj7VcfUqX1XXBM/q64Djw/UH7jgffH7VvMfj+ZDyLpHx/1r4l4PuL9i0F31+1bxn4/qZ9y8H3d+1bAb5/aF8efP/UvpXge1b7CuB7Tvvawfcv7YvA97z2dYDvBe3rBN+L2telfeq5FL53/z3tawKuXJDu8x+sAS+hsZ6D8soYnv+mx1PIBpXPtKpY7em3vaP0DEJQfdvbgSdKn6eQgRjV8ETA05E+T+m5ic706y0d44KhaQZiFaBdXRbaFUIsrpvXOV4WfNinu2IYUz9X0zk1hFhcN6+vAkb2dcRoVgzSzc2lhkbqPNAUDsZttxBXVb8S4hWBg+PVwz7LWwf3bdZszbCdx5ZmKOPY3mH4LPWBUg5yLK6b1zuBkdvYMfqMUbWMkcHYBGwp8pQ0iwyeKEaLozU265/m+RhjYD/rAB9v/3/9oKHqe7mwkiuXHldU67k7bnxMjycqYL+shqcLeGyML5bOnQU836WdZ91B5fHC8zFvXwXaWfg82z7UuRcZhVd4hVd4hVd4hVd4hVd4hVd4hVd4hVd4hVd4hVd4hffwvHhPGO91xd1vPZKM7OsEHhvz7KXfYNB14f3Wx8LBuOnfN4gKeM+Pn7laZrS5Hvb5fjjI9kVdxvuteG+13fBZeo6idCzxOYocrHM8vP+Lz3XYun+XN3jyMVqMrdjRtXaOb1RQvzOkfkdkpXFM454pWWH4VJ7+p26w3TbuvdV6LxDHEi6n/UxVR0ys9J9bKY8fPF7VBS8fP+LOMym0s50LKjY/H6nGrragcgyvh32e0AdlcmD3vJJ0774b9OhJP3ZJj24jNveZHjhGPQaP2g/fy+eBLuO99bDP03AeOAT9y8K5McJnxXgZqn/hvfb0j3H53n9XDTx43C08O2br944KmKdp3/vvjTleeN3F2/H5ZwvPnLfH9RleR0bhFV7hFV7hFV7hFV7hFV7hFV7hFV7hFV7hFV7hFV7hPTwvfteaWTOwX6cjjKP0vETpfgL/fgXXr+6rXAf3VWzfu+N7PsuNNtfDPo/A9z136nJzUPmMRNKxtHDPa8hjyfGaoT14L8bW97xXGTyrYrQYW7HL9/7TP76D9/7Ne5GdxvHEe97Yhw5Bnpq/N5EBfUbjeaOkY8PxsC+tAh+XuX11UOZ77cXA1ngZxf4uE8fnePjbSHdozfk++2oLTLbODaqOPmhTV0w7efvdMB7eo8txY5/a/kDMdl5CYz0HZdZOtXdt+u0tHdsTdV18bNfGxF4HrCnFbsfYoTaOw/56KN9f95IsL+2nFtaZuVWfWROzH5a7jfdkYfuamHbnUm73WmDJwTrHUzlzL+TXA3AtYOM8iu1GfTpAH96Ov0dTMPZP+r0SG889hEHy75UgI/vw2tfWGN9j8CyL0WeZwWM+53m0P6f1STh/xF3f8XuXA3fXKHEzS1cM92PGec/Cs1BDPl+Gzz3Zer7MfGZ6qOfLsP1xnzXM63Q8334Vxr5/wzWceT2bCSqvCW1+bjT7N69zPLyGG+qZu6L28/pK8IdQX4P2me/H66q0z8l4/Yws+DuYvM8PEvpqg6FPe8x7fwzvxbaphZ9Zxs9wvcZ+qCuPBUWtDZ+rckG6Y+jahPatgfbxPk8a40H612/l6+D021q+HsBrsK6YdvL230BffTrmOpf7rNr+3DCvg1m7JmhjLkh3bFuv62ow6sbYG4A1pdjtGJuvgzkO++uh/CxcB28YLL6kc1G/qj6zLmY/LHcb78nC9nUx7c6l3O4isGDdHE/lzDOQX8/BdbCN38PFdqM+PaAPb4+bz8TrPN4+GnNgvYaOvTHc7MPf9f231TnG+O9ZmXOMOP+J333C+U8+H6T5HDJ+XyQPcf8TEzeXsib839lc9ySDw2bsFiN2yyjGbjVit45ibNFcNHdJc5d+3xt/h7vOA8ZxHjDWe8A43gPGBg8YGz1gbPKAcYIHjBM9YMx4wNgMjEfy+sOCPlEa+vD/1GeCyt+zt/n7ASsNRvO3HbLgmwQ8R/I6ztVjyHObLh/DFuAZY9fDqRxD/l9zl49hq10dUxnvp3rAOM0DxukeMM7wgHGmB4yzPGCc7QHjHA8Y53rAOM8DxvkeMC7wgHGhB4w5DxjbPGBc5AHjMR4wHusB43EeMB7vAeNiDxhP8IDRhznfFXYZhz1PoXgs/FduJ851VMNj+zdVLbWz9PwcPz+b9m/cdcQcL24DPpdu+399wyD593GRUXiFF7/vYf4vN/6mc94RxrjfmLYwTtR8DmmP0TESxmi4jJa+t1rzf7Djs5w+/Qe7qqMrRleOhb91jzlg6zssh/s/duEVXuEVXuEVXuEVXuEVXuEVXuEVXuEVXuEV3qLwCq/wVsWLc/z4f4m8X94RRvZ1AI+N38qs9T5EZ4yOkTD6wBgNl9HOb2KU7zl11sCDv89mo2/aaWf5nlN3jK7423y8HXPgSP3+qvAKr/AKr/AKr/AKr/AKr/AKr/AKr/AKr/AKb1F4hVd4q+LFOX5mxf/cyjvCyL4u4LHxW9i13odYFaNjJIw+MEbDZVQ8Fn4jvhP7XTU8tv8ryVI7S/ecemN0jfsdfMyBI/V/McIrvMiIYxT+PwLvl3eEMe7/iGz8t0Wt42hPjI6RMEbDZVQ8Nv6/E3O6Gh78L0obeW+nneXzEf/filq4zRwrC9sxB2z8t00IcbluXu+zG7ukw5rD6LAmhsXGf1sNpQMyVssbecYr+oq+oq/om8Qr+oq+oq/om8Qr+oq+oq/om8Qr+oq+oq/om8Qr+oq+ou/IePHeAbNmYL+8I4zs6wUeC/PsNd+DWR2jYySMqTD22WWMhsuoeNamztNRwH5XDc9a4LHRN+20s3wP58SgUleOlYXtmKcnWmhjCHG5bl5HxrHK2+cZr+SDXV7JB+GVfBDeJF7JB+GVfBDeJF7JB+GVfBDeJF7JB+GVfBDeJF7JB+GVfBDeJF7JB+GVfBDeJF7JB+GVfBDeJF4X8gGfcWHWDOyXd4SRfWuAZ60Fnlqfw1kbo2MkjEcNY59dxmi4jIpnXfo8nTg2VMOzDnhsjB+W2ll6LqwYVOrKsbKwHfO0aKGNIcTlunm9CH7hFd4i8OQN1gzsl3eEkX0nAo+F/lzzWL8uRsdIGH1gjIbLqHjWW+JZVwPPeuApps/TbqmdpXPmhqBSV46Vhe2YAxsstDGEuFw3ryOjT7zYh5g1A/vlHWFkXxF4LORbzWPR+hgdI2E8ahgnesCY8YCxGRjzFhgVzySDh9fzdvWJ0tAnq19dHpsnAY+tY9hi8LTEaOHqMZysX10+hi3AY+sYtho8rTFauHoMp+hXl49hq10dUxnvp3rAOM0DxukeMM7wgHGmB4yzPGCc7QHjHA8Y53rAOM8DxvkeMC7wgHGhB4w5DxjbPGBc5AEjzg0dyfmCI/k590h+PhPNRfPCyBbRXDQXzUVz0Vw0F81HENt1zX34DCGMY5uxz1FG5AnT4ylg2zGWjftTtbY97tkjYUyHsc8DRtvPvYmOqTBGw2VUPCdb4tlQA8/JwHNS+jztltpZeub1lKBSV46Vhe2YA6dYaGMIcbluXkdGn3ixDzFrBvbLO8LIvpOAx1a/qqWfY7861RLPyTXwnAo8No6XpXaW+vlpQaWuHCsL27HfnGahjSHE5bp5HRl94sV+zqwZ2C/vCCP7TgEeW/2qln6O/ep0Szyn1sBzOvDYOF6W2lnq52cElbpyrCxsx35zhoU2hhCX6+Z1ZPSJF/s5s2Zgv7wjjOw7DXgs5FvNny1Oj9Ex8oCxzwNG0VF0LDrEKDqKjkWHGH3QURiFsSiMwiiMwiiMwhgcHddmcv1Y+5wpzlGemT5PJ85rVcNzJvDYmPuy1M7SnOlZQaWuHCsL2zEHzrLQxhDict28jozCK7xnAU/eYM3AfnlHGNl3BvBY6M81j/VnxugYCWM0XEbFc3bqPJ0FzOlqeM4GHht5b6ed5fPROUGlrhwrC9sxB86x0MYQ4nLdvI6M1fL2ecYr+oq+oq/om8Qr+oq+oq/om8Qr+oq+oq/om8Qr+oq+oq/om8Qr+oq+oq/om8Qr+oq+oq/om8Qr+oq+oq/om8Qr+oq+oq/om8Qr+oq+oq/om8Qr+oq+oq/om8Qr+tbOq3jyBmsG9ss7wsi+s4DnbAs8tT6HfnaMjpEwpsLYZ5cxGi6j4jk3fZ5O7HfV8JwLPDb6pqV2lr5zsDGo1JVjZWE75ulGC20MIS7XzevIKLzCuxF48gZrBvbLO8LIvnOAx0J/rnmsPzdGx0gYhfHoYYyGy6h4zkudJyrg+FUNz3nAY2OMs9PO8rXH+UGlrhwrC9sxB8630MYQ4nLdvI6M1fL2ecYr+oq+oq/om8Qr+oq+oq/om8Qr+oq+oq/om8Qr+oq+oq/om8Qr+oq+ou/RpS/O8TNrBvbLO8LIvo3AY2E+vOZ7JefF6BgJYyqMfXYZo+EyKp4LUufpKGC/q4bnAuCx0TfttLN8z+nCoFJXjpWF7ZinF1poYwhxuW5eR8axytvnGa/kg11eyQfhlXwQ3iReyQfhlXwQ3iReyQfhlXwQ3iReyQfhlXwQ3iReyQfhlXwQ3iReyQfhlXwQ3iReyQfhlXwQ3iReF/IBn3Fh1gzsl3eEkX3nA88FFnhqfQ7nghgdI2E8ahj77DJGw2VUPBelz9OJY0M1PBcBj43xw1I7C6qOi4NKXTlWFrZjnl5soY0hxOW6eR0ZhVd4LwaevMGagf3yjjCy70LgsdCfax7rL4rRMRLGaLiMiueS9Hk6Maer4bkEeGzkvaV2ls5Hm4JKXTlWFrZjDmyy0MYQ4nLdvI6Mwiu8m4Anb7BmYL+8I4zsuxh4LPTnmsf6S2J0jIQxGi6j4rk0fZ5OzOlqeC4FHht5b6mdpfPRZUGlrhwrC9sxBy6z0MYQ4nLdvI6Mwiu8lwFP3mDNwH55RxjZtwl4LPTnmsf6S2N0jIRRGB1i7POA0bKO0XAZFc/llngurYHncuCxMQ5bamfp+uiKoFJXjpWF7ZgDV1hoYwhxuW5eR0afeLEPMWsG9ss7wsi+y4DHVr+qpZ9jv7rSEs/lNfBcCTw2jpeldpb6+VVBpa4cKwvbsd9cZaGNIcTlunkdGX3ixX7OrBnYL+8II/uuAB5b/aqWfo79arMlnitr4NkMPDaOl6V2lvr51UGlrhwrC9ux31xtoY0hxOW6eR0ZfeLFfs6sGdgv7wgj+64CHgv5VvNni80xOkYeMPZ5wCg6io5FhxhFR9Gx6BCjDzoKozAWhbEmxvUeMMqxFsaio4x5C4yKZ5LBw+v5UYjdYsRuGcXYrUbs1lGMLZqL5qK5aC6ai+YjjS2ai+aiuWgumovmI40tmovmorloLpqL5iONLZqL5qK5aC6ai+YjjS2ai+aiuWgumovmI40tmovmorloLpqL5iONLZofXvP/phhb1bvFQpvwu4G8hMZ6DspboJ02vj9oqZ0FVUc/tGOz0Z4sbF8Cbey30MYQ4nLdvN4PPLzUAc8WSzyBwRPE6MPLAsd4ZjnGM8UxnlbHeCY4xjPOMZ6FjvHMdoxnqmM8Ex3jqXeMJ+cYzxzHeKY5xrPCMZ6MYzzjHeNpc4xnrmM80x3jaXaMp8ExnqWO8SxyjGeeYzwzHOPJOsYzyTGeRsd4ljjGs9wxnvmO8cx0jGeyYzwtjvE0OcazzDGe0AGeTFA5756B7Xnw9evyZvBdo8tXg68uJgbPdfWDj+cLuA51ftjVWlk36tQPbSnqcmFkS0knjJWDdY7XDBzXOMKzzDGeJsd4WhzjmewYz0zHeOY7xrPcMZ4ljvE0OsYzyTGerGM8MxzjmecYzyLHeJY6xtPgGE+zYzzTHeOZ6xhPm2M84x3jyTjGs8IxnmmO8cxxjCfnGE+9YzwTHeOZ6hjPbMd4FjrGM84xngmO8bQ6xjPFMZ5ZjvEscIynbhR5kr5H0D8KsZO+RzAasZO+RzAasUXzw2ue4nc3OlS9Wy20Ce8P8RIa6zkob4V2XmuBx1I7C6rebekfl9J3QraDPlsMnbKwfRtot92CdiHE5bp5fTvw8FIHPDZyq5o8SvpOiAs8sxzjmeIYT6tjPBMc4xnnGM9Cx3hmO8Yz1TGeiY7x1DvGk3OMZ45jPNMc41nhGE/GMZ7xjvG0OcYz1zGe6Y7xNDvG0+AYz1LHeBY5xjPPMZ4ZjvFkHeOZ5BhPo2M8yx3jme8Yz0zHeCY7xtPiGE+TYzzLHOMJHeBJ+g4Gb+8HH8/JbgHfdbp8LfjqYmLw3NJ28NXrMtdhfgeD/aiTrXlojJWDdY6H38G4zhGeZY7xNDnG0+IYz2THeGY6xjPfMZ7ljvE0OsYzyTGerGM8MxzjmecYzyLHeJY6xtPgGE+zYzzTHeOZ6xhPm2M84x3jyTjGs8IxnmmO8cxxjCfnGE+9YzwTHeOZ6hjPbMd4FjrGM84xngmO8bQ6xjPFMZ5ZjvEscIynbhR5kp6/3z4KsZOevx+N2EnP349GbNFcNBfNj27Nr08/difeC+QlNNZzUL4eeGzc57TUztJ3cHboutL+Ds4NoM92Q6csbN8B2t1gQbsQ4nLdvI6Mwiu8N0DsnanHjgoZI7ZahhpXdlrWwk47y/1/F7TjeqM9WdiOx3uXhTaGEJfr5nVkFF7hFV7hFV7hFV7hFV7hFV7hFV7hFV7hFV7hFV7hFd7D86rYu1OPXZ4/x9hqCY31HJR3W9bCTjvL8+c3Qjt2Gu3JwnY83jdaaGMIcbluXkdG4RVe4RVe4RVe4RVe4RVe4RVe4RVe4RVe4RVe4RVe4T08r4q9J/3Ype+1YGy1hMZ6Dsp7LGthqZ2l+fO90I7dRnuysB2P914LbQwhLtfN68govMK7F2LflHrs8v0zjK2Wofr/TZa1sNPOcv/fB+3YY7QnC9vxeO+z0MYQ4nLdvL7PbuySDvsPo8P+GJb9o6wDMlbLu8MzXtFX9BV9Rd8kXtFX9BV9Rd8kXtFX9BV9Rd8kXtFX9BV9Rd8kXtFX9BV9R8arYg+kHrujNC+PsdUSGus5KA9Y1sJOO8vz0QegHTcZ7cnCdszPAxbaGEJcrpvXkXGs8u7zjFfywS6v5IPwSj4IbxKv5IPwSj4IbxKv5IPwSj4IbxKv5IPwSj4IbxKv5IPwSj4IbxKv5IPwSj4IbxKv5IPwSj4IbxKvC/mgYt+cfuzS97oxtlpCYz0H5Zsta2GpnaXnRw5COwaM9mRhO+bnQQttDCEu183ryCi8wnsQYt+SfuwoY8RWy1D9/xbLWlhqZ6n/H4J23Gy0Jwvb8XgfstDGEOJy3byOjD7xZsBXBz7ePg58t+pyPfheocvjwfdKXW4A36t0uRF8r4b2s+81ujwBfLfp8grwvVaXt4Pvdbq8FXy36/L14LtDl28A3526vBN8r9flXeB7gy7vBt9dunwj+O7W5T3ge6Mu7wXfPbp8E/jepMv7wfdmXR4A3726fAB8b9Hlm8H3Vl0+CL636fIO8L1dlyeC7x1Q5td36nIz+N6ly1nw3afLk8D3bl2eDL736HIL+O7X5Snge0CXW8H3Xl2eCr736fI08L1fl6eD7wO6PAN8H9TlmeB7UJdnge8hXZ4Nvg/p8hzwfViX54LvYV2eB76P6PJ88D2iywvA91FdXgi+j+lyDnwf1+U28H1ClxeB71FdxjzgceAW8PE4gOMGjwO3go/HgVeAj8eBV4KPx4FXgY/HgVeDj8eB14CP8/M28HF+vhZ8nJ+vAx/n5+3g4/y8A3ycn3eCj/Pz9eDj/HwD+Dg/7wIf5+fd4OP8fCP4OD/vAR/n55vAx/n5ZvBxft4LPs7Pt4CP8/Ot4OP8fBv4OD/fDj7OTxwXOD/fCT7Oz3eBL6fL94GP8/Pd4OP8fA/4jtHl+8F3rC4/AL7jdPm94Dtel98HvsW6/H7wnaDLHwDfEl3+IPiW6vKD4Fumyw+Bb7kufwh8fA77MPjyuvww+Fbq8kfAV9DlR8DXrssfBV+kyx8DX4cufxx8nbr8CfB16fKj+lX1v2bgYdZmiF2IqZN9TVBnLkj32oZjcd283gWMrEXn6DNG1TJ2GIyKp9uCZnh8eRnqM0M38KyywGOpnaXD2gPt6DLak4XtS6CNPRbaGEJcrpvXeyC2jeMdQowGXfdSQ4t62OckfeKabPChhvx+lbedMe2wpWFH8HINO2Ji91nWkOvmsbBvFGL3GrEjI7bq05hfahmqT/cC82oLzKreNenXW1BtWqvr4lzmOBG06UTQIK02YexQG8dhfz2UL+cLQNhPLXy+ZG7Vh/pi9sNyt/GeLGzvi2l3LuV2rwGWHKxzPHW9v7F1kMNCPygd+z6Dg9cj8K+J0a0PdOPtneDj65ke8BWMOjKwHa8ZOtJva+x4w+sdwMi+XmDsiGGM0meMhhqPI2Bk32rgYd5ikK5mq4FH1bs0Rp+lBo/K3aZwkG18+lqV2OqDl2tVD/E5dqOF2Ph5nJehzg2NwNNggUd9bufP5PsH9uzrv27bpn07BraFwDbe4MTXMKYddeCrg23jhtgvqa4JQaU+qSYCQ51gBK/T2+q1AEp8dTCaNJQSjic0VMdSExbqIk1NSKgJCDX+qgkGNaGgJhDUhIGaIFATAmoCQH3gVx/w1Qd69QFefWBXH9BzQfkDuPrArT5gqw/U6gO0+sC8GBi/B9zqgll1JPWBV33AVR9o1SCqLorUwKNOcmoQUJ1fDbTqwlF9eFCDqRq0VIdUHVANzGpAVidNdTJZp7VeT7aB7CSyk8lOITuV7DSy08nOIDuT7Cyys8nOITuXbCPZeWTnk11AdiHZRWQXk11CtonsUrLLyC4nu4LsSrKryDaTXU22hayf7Bqya4PyRPK2oDzJfF1QnkRWE2Vq4nhnUJ4YVhPBauJXTfSqiV01katuPKvJWzVZqyZn1WSsmnxVE2pqAk1NmKkJMjUhpibA1ISXmuC6LShPYKkJKzVBpSak1ASUmnBSE0xqQklNIKkJo3uC8oSQmgBSEz5qgkdN6KgJHDVhoyZo1ISMmoBREy5qgkVNqKgJFDVhoiZI1ISImgBREx5qguPBoDyBoSYs1ASFmpBQExBqwkFNMKgJBTWBoCYM1ATBJ8k+RfZpss+QfZbsMbLPkX2e7AtkXyT7EtmXyb5C9lWyr5F9newbZN8k+xbZt8m+Q/bdoJxv3yd7nOwHZD8k+xHZj8l+QvZTsp+R/ZzsF2RPkD1J9kuyX5E9RfZrst+Q/ZbsabLfkf2e7BmyP5D9kexPZH8m+wvZX8n+RvZ3sn+Q/ZPsWbLnyP5F9jzZC2QvBoMTlThY/EKvtOn1/oGBbbv3DuQG9uR2H9g1sGPvrkO5gzsGrs/tuXnbvu279hzEN9+uhyeerVu/b1//odyOG7duuyW358BAbs/23DV7Dty4dT++6dG6EUT8rH7zvMo392/dmvy+x/X7eD7zjKEZfzSchj0xnDdtaK3yTcH/AGGInMw3XwMA", "debug_symbols": "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lLsLlLsLlLsLlLsLlLsLlLsLlLsLlLsLlLsLlLsLlLsByt0A5W6AcjdAuRug3A1Q7gYodwOUuwHK3QRlXYKyTvEm3k60fOKoJxRT4O2EySdcPvFdWfx8NT7YaayPVz8f671dH3evz7vX77vX193r++713/Wub73q3SR//vP89PrvW/D+9vV293q/e/26e33cvT7VlFJ+A8LbCflnQMk/A0r+GdDyz4CWfwa0/DNA2aN9OxHyCbnnLfe85Z633POWe37knh+550fu+ZF7fuSeH7nnR+75kXt+5J4ftef9esknTD7h8oklnwj5RMontnyi5BMtn5B7bnLPTe65yT03uecm99zknpvcc5N7bnLPTe65yz13uecu99zlnrvcc5d77nLPXe65yz13uedL7vmSe77kni+550vu+ZJ7vuSeL7nnS+75knsecs9D7nnIPQ+55yH3POSeh9zzkHsecs9D7nnKPU+55yn3POWep9zzlHuecs9lRtsyo22Z0bbMaFtmtC0z2t5yz7fc8y33fMs933LPt9zzLfe85J6X3POSe15yz0vuuczhWuZwLXO4ljlcyxyuZQ7XModrmcO1zOFa5nAtc7iWOVzLHK5lDtcyh2uZw7XM4VrmcC1zuJY5XMscrmUO1zKHa5nDtczhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszhjszh7CWDuOeI6UdcP7L0I6EfSf3I1o+UfqT1I3r3Te++6d03vfumd9/07pvefdO7b3r3Te++6d13vfuud9/17rvefde773r3Xe++6913vfuud3/p3V9695fe/aV3f+ndX3r3l979pXd/6d1fevdD737o3Q+9+6F3P/Tuh9790LsfevdD737o3U+9+6l3P/Xup9791LufevdT737q3U+9+6l3f+vd33r3t979rXd/693feve33v2td3/r3d9690vvfundL737pXe/9O6X3v3Su19690vvfundb737rXe/9e633v3Wu99691vvfuvdb737rXf/6N0/eveP3v2jd//o3T9694/e/aN3/+jd11mf6azPdNZnOusznfU973r1I6kf2fqR0o+0fkTvvs76TGd9prM+01mf6azPdNZnOusznfWZzvpMZ32msz7TWZ/prM901mc66zOd9ZnO+kxnfaazPtNZn+msz3TWZzrrM531mc76TGd9prM+01mf6azPdNZnOusznfWZzvpMZ32msz7TWZ/prM901mc66zOd9ZnO+kxnfaazPtNZn+msz3TWZzrrM531mc76TGd9prM+01mf6azPdNZnOusznfWZzvpMZ32msz7TWZ/prM901mc66zOd9ZnO+kxnfaazPtNZn+msz3TWZzrrM531mc76TGd9prM+01mf6azPdNZnOusznfWZzvpMZ32msz7TWZ/prM901mc66zOd9ZnO+kxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11mf66zPddbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11mf66zPddbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11mf66zPddbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11mf66zPddbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zPtdZn+usz3XWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWt3TWFzrrC531hc76Qmd9obO+0Flf6KwvdNYXOusLnfWFzvpCZ32hs77QWV/orC901hc66wud9YXO+kJnfaGzvtBZX+isL3TWFzrrC531hc76Qmd9obO+0Flf6KwvdNYXOusLnfWFzvpCZ32hs77QWV/orC901hc66wud9YXO+kJnfaGzvtBZX+isL3TWFzrrC531hc76Qmd9obO+0Flf6KwvdNYXOusLnfWFzvpCZ32hs77QWV/orC901hc66wud9YXO+kJnfaGzvtBZX+isL3TWFzrrC531hc76Qmd9obO+0Flf6KwvdNYXOusLnfWFzvpCZ32hs77QWV/orC901hc66wud9YXO+kJnfaGzvtBZX+isL3TWFzrrC531hc76Qmd9qbO+1Flf6qwvddaXOutLnfWlzvpSZ32ps77UWV/qrC911pc660ud9aXO+lJnfamzvtRZX+qsL3XWlzrrS531pc76Umd9qbO+1Flf6qwvddaXOutLnfWlzvpSZ32ps77UWV/qrC911pc660ud9aXO+lJnfamzvtRZX+qsL3XWlzrrS531pc76Umd9qbO+1Flf6qwvddaXOutLnfWlzvpSZ32ps77UWV/qrC911pc660ud9aXO+lJnfamzvtRZX+qsL3XWlzrrS531pc76Umd9qbO+1Flf6qwvddaXOutLnfWlzvpSZ32ps77UWV/qrC911pc660ud9aXO+lJnfamzvtRZX+qsL3XWlzrrS531pc76Umd9qbO+1Flf6qwvdda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3dda3ddZXOusrnfWVzvpKZ32ls77SWV/prK901lc66yud9ZXO+kpnfaWzvtJZX+msr3TWVzrrK531lc76Smd9pbO+0llf6ayvdNZXOusrnfWVzvpKZ32ls77SWV/prK901lc66yud9ZXO+kpnfaWzvtJZX+msr3TWVzrrK531lc76Smd9pbO+0llf6ayvdNZXOusrnfWVzvpKZ32ls77SWV/prK901lc66yud9ZXO+kpnfaWzvtJZX+msr3TWVzrrK531lc76Smd9pbO+0llf6ayvdNZXOusrnfWVzvpKZ32ls77SWV/prK901lc66yud9ZXO+kpnfaWzvtJZX+msr3TWVzrrK531lc76Smd9pbO+0llf6ayvdNZXOusrnfWVzvpKZ32ts77WWV/rrK911tc662ud9bXO+lpnfa2zvtZZX+usr3XW1zrra531tc76Wmd9rbO+1llf66yvddbXOutrnfW1zvpaZ32ts77WWV/rrK911tc662ud9bXO+lpnfa2zvtZZX+usr3XW1zrra531tc76Wmd9rbO+1llf66yvddbXOutrnfW1zvpaZ32ts77WWV/rrK911tc662ud9bXO+lpnfa2zvtZZX+usr3XW1zrra531tc76Wmd9rbO+1llf66yvddbXOutrnfW1zvpaZ32ts77WWV/rrK911tc662ud9bXO+lpnfa2zvtZZX+usr3XW1zrra531tc76Wmd9rbO+1llf66yvddbXOutrnfW1zvpaZ32ts75WWN9vfvK6v/9LSW8v/fs/nvDx6lMf9/fl+8/V+4+CHL90v12+3y/fvy7fH5fvz8v378v31+X7+/L93zW/af32ylzn47Wdn5VS9fZSf/147UcQHntRCjFKIU4pZFEKCUohSSlkUwopSiFNKYSSrE5JVr+TrO+3+9Xb19Xb4+rtefX2ffX2unp7X7393Lx9va7efnVW19VZXd83q/n+ytzxfYG3glJIUgrZlEKKUkhTCjmQQuJFKcQohTilEEqyBiVZg5KsQUnWoCRrUJI1KMmalGRNSrImJVmTkqxJSdakJGtS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v/RTRmbfRmbfRmbfRmbfRmbfRmbfRmbfRmbfRmbfR2bfR2bfR2bfR2bfR2bfR2bfR2bfR2bfR2bfR2Z/jcz+Gpn9NTL7a2T218jsr5HZXyOzv0Zmf43M/hqZ/RiZ/RiZ/RiZ/RiZ/RiZ/RiZ/RiZ/RiZ/RiZ/RiZ/RyZ/RyZ/RyZ/RyZ/RyZ/RyZ/RyZ/RyZ/RyZ/RyZ/T0y+3tk9vfI7O+R2d8js79HZn+PzP4emf09Mvt7ZPZrZPZrZPZrZPZrZPZrZPZrZPZrZPZrZPZrZPZrZPZ7ZPZ7ZPZ7ZPZ7ZPZ7ZPZ7ZPZ7ZPZ7ZPZ7ZPZ7ZPbPyOyfkdk/I7N/Rmb/jMz+GZn9MzL7Z2T2z8jsn4nZr9dr5Ck28hQfecoaeUqMPCVHnrJHnlIjT+mRp4zM/sheX43s9dXIXl+N7PXVyF5fjez11cheX43s9dXIXl+N7PXVyF5fjez11cheX43s9dXIXl+N7PXVyF5fjez11cheX43s9dXIXl+N7PXVyF5fjez11cheX43s9dXIXl+N7PXVyF5fjez11cheX43s9dXIXl+N7PXVyF5fjez11cheX43s9dXIXl+N7PXVyF5fjez11cheX43s9dXIXl+N7PXVyF5fjez11cheX43s9dXIXl+N7PXVyF5fjez11cheX43s9dXIXl+N7PXVyF5fjez11cheX43s9dXIXl+N7PXVyF5fjez11cheX43s9dXIXl+N7PXVyF5fjez11cheX43s9dXIXl+N7PXVyF5fjez11cheX43s9dXIXl+N7PXVyF5fjez11cheX43s9dXIXl+N7PXVyF5fjez19cheX4/s9fXIXl+P7PX1K0aekiNP2SNPqZGn9MhTRmZ/ZK+vR/b6emSvr0f2+npkr69H9vp6ZK+vR/b6emSvr0f2+npkr69H9vp6ZK+vR/b6emSvr0f2+npkr69H9vp6ZK+vR/b6emSvr0f2+npkr69H9vp6ZK+vR/b6emSvr0f2+npkr69H9vp6ZK+vR/b6emSvr0f2+npkr69H9vp6ZK+vR/b6emSvr/W9vreD+qre+0H76kH/6sH11YPx1YP51YP7qwfrqwf7qwe/+p2zv/qd8/nu1uvt1OsbsxB7n7eXxq4fX539cb9fvn9dvj8u35+X79+X76/L9/fl+8/d+z/fwvoF7788v3V1fuNn/qXWf/n+6Pfr43y81l774/p19/q4e33evX7fvb7uXt93rz9Xr9+vu9fb3eu/a2rz9f7KfH1+/bp7fdy9Pu9ev+9eX3ev77vXn6vXf99P829fb3evvzu1dXdq6+7U1t2prbtTW3entu5ObX3fz9p6/2mV9vrs+n7dvd7uXu93r193r4+71+fd6/fd6+vu9X33+rtTe+5O7bk7tefu1J67U3vuTu25O7Xn7tSeu1N77k7tuTq1P/Mvi/5y19vd6/3u9evu9XH3+rx7/b57fd29vu9ef3dq7e7U2t2ptbtTa3en9ud2av/5p8zxs//65TfPffqdun2/HXsQzcepso9T5yunPt9L/eYp+9Ip1049/+f//u4//vC7//nH3//5OfD837/8v3//z//82/8H" }, { "name": "constructor", "function_type": "Secret", "is_internal": false, "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "contract_deployment_data", "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "initialization_hash", "type": { "kind": "field" } }, { "name": "contract_class_id", "type": { "kind": "struct", "path": "aztec::protocol_types::contract_class_id::ContractClassId", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "contract_address_salt", "type": { "kind": "field" } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }] }, "visibility": "private" }, { "name": "admin", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "admin": [{ "start": 41, "end": 42 }], "inputs": [{ "start": 0, "end": 41 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "contract_deployment_data", "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "initialization_hash", "type": { "kind": "field" } }, { "name": "contract_class_id", "type": { "kind": "struct", "path": "aztec::protocol_types::contract_class_id::ContractClassId", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "contract_address_salt", "type": { "kind": "field" } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338] }, "bytecode": "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", "debug_symbols": "7Z3bThsxEIbfZa+jyjMeHyavUnGRtlRCQoAgqlQh3r0OZL0b1vWUkCx01uKCRLK9//fHyX7isPvYXd9+32yvbm8euvVjB9Ctvz52D3ebm93Th+3mftutzaq7vPmRvj+tup9X15fdGi08rSbjwPF+JETIY8H4wli0Me4HI5EbRnNxZSB0/dpAkQ/GX6w6wP81uJ0tuEPsg7uI7w5O7wluyfWrWwrD4t48r+3OuLY/49rhjGvH0toR8wZAIGm3eGP7MOnxaPOmQ5x/p/PsAKfd8WhOARDyMfzz+/TgRUY4xSE81g6BJzgEQMiHQIT6y5A+migPjzbQ60R2/kSBc0cxRaoP99i/D7wfkkAIpaWtg35ly6PRhIXRbPrUDKP9ljb2rhdqvRR7ca2XYi++9VLsJbReir3E1kuxF269lHqxpvVS7AVaL8VesPVS7EWV7xLmXojwoJcdKy2IVZWXCqyqXFNgVeWPAqsqJxRYVXlenZVUuZvAqsrHBFZVjiWw6vImHzPr+GfNe1ZaEKsub6qz6vKmOqsub6qz6vKmOqsub6qyOl3eVGfV5U11Vl3eVGdV5U0Ocm5HZsJKC2JV5U0CqypvElhVeZPAqsqbBFZV3lRn9aq8SWBV5U0CqypvElg/wJsYKbOyj6djtcbY/WBraPijQEB46+8vPbVeir241kuxF996KfYSWi/FXmLrpdgLt15KvQTTein2Aq2XYi/Yein20ny33Aup6iXE3AvzQS87Vl0OW2fV5aV1Vl2uWWfV5Y91Vl1OWGWNujyvzqrL3eqsunyszqrKsSDntuDMhJUWxKrKmwRWVd4ksKryJoFVlTcJrKq8qc7KqrxJYFXlTQKrKm+CfLEZi2biTazLm+qstCBWXd5UZ9XlTXVWXd5UZ9XlTXVWXd5UZQWjS5wEWFXmhM5k2GCmsKrUSYJV5U4SLC0JVpU9SbCq9EmCVeVPEqwqgZJgVRmUAAuqDEqCXZJBwfwGxRz74WgMTi6QDLN7TopBo0jsJ5Fo/kjp4zRHSl+TSG7+SJZcjmSDnUTyny9S+IBIDDkS2ekLF+eP5NywvT26SSSeP5InmyMFE15HQjN/pIDDXgoxTiLNfl5IC5p85XMoXEt+/ouAIzjIn0tpLk0izf/pDT7SEImFq8lH7l9lxtH50NpiEhyC8Gh08WqR/3B3C2rl/L0c98nLYdsPZsdCOc7mW3o4Gv2zY3rLHleO/+TlBM53dDDGHbRzsbvnwpfimZhNxjY8OgmE/aR4zKTi2QxyPoTRnPhyL4UveMSR0iw+Zlb5AsziLDhqFr5xVnrya3N/tfl2fbm7lVB6uv199/Lw6Q8=" }, { "name": "cast_vote", "function_type": "Secret", "is_internal": false, "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "contract_deployment_data", "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "initialization_hash", "type": { "kind": "field" } }, { "name": "contract_class_id", "type": { "kind": "struct", "path": "aztec::protocol_types::contract_class_id::ContractClassId", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "contract_address_salt", "type": { "kind": "field" } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }] }, "visibility": "private" }, { "name": "candidate", "type": { "kind": "field" }, "visibility": "private" }], "param_witnesses": { "candidate": [{ "start": 41, "end": 42 }], "inputs": [{ "start": 0, "end": 41 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "contract_deployment_data", "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "initialization_hash", "type": { "kind": "field" } }, { "name": "contract_class_id", "type": { "kind": "struct", "path": "aztec::protocol_types::contract_class_id::ContractClassId", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "contract_address_salt", "type": { "kind": "field" } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345] }, "bytecode": "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", "debug_symbols": "7Z3dbtQwEIXfJdcV8ozHP9NXQVwsUKRKVUG0QkJV351s2TgpmXqo2TZl1uKCrjTHnu/E6xyWbXw3XH39tLu9/Hp9M5zfDQDD+fu74ebb7nr/8uZ29/12OHdnw8X15/Hv+7Phy+XVxXCOHu7PVnUQ+FAJGUotuCjUos/5UIxEYa5mcWQgDNPYQJkf1X84GwD/18b9qzUeEKfGQ8Z/bpz+pXFPYRrdU5oHj+5h7PCCY8cXHDu94NhZGhsSzSvAJWWGzDzNwA7jcoZ1cUr+UJvBl9KUH5phsZlcJMARtbXrIkzVjmdcTPsZ0EkzoKOyhl3WZsgpxQkhO/rDUIQXn0HclBBgWhGIOWguReen8vHnxYYjXrQj707oX5/guNsU0lEIUpkkPuyuj69zOMocEWtzxGPMAZDKHIhQvxLjLYVKefZptbzTBi0lLi7lsad6ecTpzRDj3D2kJA3tQ9mOPC+qCYVqdlPXDIs1Ny7uvTG5GyMbw90Y0RjvujGyMdCNkY3BboxsjO/GyMZQN0Y2JnRjZGNiN0Y2xlbyJSzGEOEjY/awttKsAmsrodZhyVbqVGBtJUkF1lY6VGBtJT4Flk4J1lYyU2BtpS0F1liCirnALj+DPsAaS1B1WGMJqgobjCWoOqyxBFWHNZag6rDGElQdlk4J1liCqsMaS1B1WFsJKkD5Hksgt4K1laAUWFsJqg4bbSUoBdZWglJgbSUoBdZWglJg6ZRgbSUoBdZWglJgt0hQjFRgOebjwXrnpi/fekfz1wcB4bn/vRlzN0Y2hrsxojHJdWNkY6AbIxuD3RjZGN+NkY2hboxsTOjGyMbEboxsTE++TxhjLPmmXIxZ/Ibd3pg9rLE0W4XNxhJqHdZY6qzDGkuSdVhj6bAOS6cEayzF1WGNJbM6rK20BTh9qOohuBWsrQSlwNpKUHVYtpWgFFhbCUqBtZWgFFhbCUqBpVOCtZWgFFhbCQrKY2s8ulWCYmMJqg5rLEHVYY0lqCosOGMRSqE1lqEUWmMhSqE1lqIUWjopWls5CoMrtMmtaW0FKY3WVpLSaG1FKY3WVpZSaMFWltJobWUpjdZWltJobWUpjZZOivakshRskKWY81SOzuHqsdnw+oln7IMWPXFc9ZQ36GlMQ6Wn8c+qJ96gJ0+h9OST/7MndG+wJ9iiJ4bSE/nVtUPcoKcQ5jUeMax68hv0FMmXnpJLq55og54Szusp5bzq6fXvEAjkyjPWQThqYIOHjSMEKPvTqKVVTxvs4xAzzT2x8uT6PB+ugIt7o/diJzg3wotq8WGUf3H8Se7uVNzht+4O+6mYAyvuBF9OfQm0+H3J8TbQ5M4GDx9/pjuJywESzoVH9uwB8jv5wwCK0xxhkXcOJ5iMImgRYYvIt4ioRRRaRLFFJO7HIU834MCSKLeIuEEkR0dNBC0ibBH5FpG4IgJPb7y4ODVkFoUWUWwRpRZRbhFxg0je5jSRuCJiib4xSiJsEfkWEbWIQosotohSi0hcEbEcLRWz8NaQn9usiOTnH2siaBFhi8i3iOi5IqR34mViV2KD48U/pdJBlFtE8rlh5faOsND87i4+sUXUZ4pP7BGaSt4kVBU0qfCZqvHFj933y93Hq4v9aY3jy9uf337/eP8L" }, { "name": "add_to_tally_public", "function_type": "Open", "is_internal": true, "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "public_global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] }, "visibility": "private" }, { "name": "candidate", "type": { "kind": "field" }, "visibility": "private" }], "param_witnesses": { "candidate": [{ "start": 39, "end": 40 }], "inputs": [{ "start": 0, "end": 39 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::public_circuit_public_inputs::PublicCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "contract_storage_update_requests", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_update_request::StorageUpdateRequest", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "new_value", "type": { "kind": "field" } }] } } }, { "name": "contract_storage_reads", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_read::StorageRead", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "current_value", "type": { "kind": "field" } }] } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "prover_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] }, "visibility": "public" }, "return_witnesses": [40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233] }, "bytecode": "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", "debug_symbols": "1Z3RjmXJjV3/pZ8F45BBBkn9iuEH2ZYBAYJmMBIMGIL+3UdQZVYLylbVvt0neuXTSIkTERzxxr631uXK/OsPf/yP//W7v/zhP/705x9++9cfrv/ma3747X//6w9//s/f/envP/nzX373X3/54bfXb374/Z/+9/1///abH/7PH/74+x9+68v+9j9+8/cVcckrTF7h8oolrwh5RX7/it/8y3Nr2ZcnV877s3btt933o7vXo7v3o7vPk7vn9eju9uju/uju69Hd49HdH72r+ehdzUfvaj56V/PRu7ofvav70bu6H72r+9G7uh+9q/tn3VXL+fKktf3T7h88W11vD1f316fn7T1+b1AtBaqlQbUMp5a6QLUYqBYH1bJAtQSoFlDuFih3C5S7BcrdAuVug3K3QbnboNxtUO42KHcblLsNyt0G5W6DcrdBuTug3B1Q7g4odweUuwPK3QHl7oByd0C5O6DcHU7urouTu+vi5O66OLm7Lk7urouTu+vi5O66OLm7Lk7urouTu+sC5a6BctdAuWug3DVQ7hoodw2UuwbKXQPlroFy10C566DcdVDuOih3HZS7DspdB+Wug3LXQbnroNx1UO4uUO4uUO4uUO4uUO4uUO4uUO4uUO4uUO4uUO4uUO4GKHcDlLsByt0A5W6AcjdAuRug3A1Q7gYodwOUuwnK3QTlboJyN0G5m6DcTVDuJih3E5S7CcrdBOXuBuXuBuXuBuXuBuXuBuUuyFdbIF9tgXy1BfLVFshXWyBfbYF8tQXy1RbIV1sgX22BfLUF8tUWyFdbIF9tgXy1BfLVFshXWyBfbYF8tQXy1RbIV1sgX22BfLUF8tUWyFdbIF9tgXy1BfLVFshXWyBfbYF8tQXy1RbIV1sgX22BfLUA+WoB8tUC5KsFyFeLi5O7AfLVAuSrxUEXqle8P5z5US0GquXYa9fjvUf3f/ywRwmqZYNqKVAtDarl3GcGuyt4e9pivu5tFV+qOWj9fE81xzLG0/2tT9n+T33Snv5SuX/ayhez8vs14vn19dLzUe3xiWvPT1y7kKdfVqi/9T7WJa8weYXLK5a84me9Ru+fvn0W8hXr/enst+3z2e33s9vXs9v3s9vPo9v/PENhXfX2dnv/x/lge3t2e392+/Xs9vHs9vns9ltNKWVy/ssK+T0g5PeAlN8DUn4PSPk9IOX3AGWG+cuKlFfIPU+55yn3POWeb7nnW+75lnu+5Z5vuedb7vmWe77lnm+551vueck9L7nnJfe85J6X3POSe15yz0vueck9L7nnLfe85Z633POWe95yz1vuecs9b7nnLfe85Z6P3PORez5yz0fu+cg9H7nnI/d85J6P3PNRe57XJa8weYXLK5a8IuQVKa/Y8oqSV7S8Qu65yT03uecm99zknpvcc5N7bnLPTe65yT03uecu99zlnrvcc5d77nLPXe65yz13uecyo02Z0abMaFNmtCkz2pQZbS6550vu+ZJ7vuSeL7nn8l+jTfmv0ab812hT/mu0Kf812pT/Gm2G3HOZw6XM4VLmcClzuJQ5XMocLmUOlzKHS5nDpczhUuZwKXO4lDlcyhwuZQ6XModLmcOlzOFS5nApc7iUOVzKHC5lDpcyh0uZw6XM4VLmcClzuJQ5XMocLmUOlzKHS5nDpczhUuZwKXO4lDlcyhwuZQ6XModLmcOlzOFS5nApc7iUOVzKHC5lDpcyh0uZw6XM4VLmcClzuJQ5XMocbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbsscbrfcc5nDbZnDbZnDbZnDbZnDbZnDbZnDbZnDbZnDbZnDbZnDbZnDlczhSuZwJXO4kjlcyRyuZA5XMocrmcOVzOFK5nAlc7iSOVzJHK5kDlcyhyuZw5XM4UrmcCVzuJI5XMkcrmQOVzKHK5nDlczhSuZwJXO4kjlcyRyuZA5XMocrmcOVzOFK5nAlc7iSOVzJHK5kDlcyhyuZw5XM4UrmcCVzuJI5XMkcrmQOVzKHK5nDlczhSuZwJXO4kjlcyRyuZA5XMocrmcOVzOFK5nAlc7iSOVzJHK5kDlcyhyuZw5XM4UrmcCVzuJI5XMkcrmQOVzKHK5nDlczhSuZwJXO4kjlcyRyuZA5XMocrmcOVzOFK5nAlc7iSOVzJHK5kDlcyhyuZw5XM4UrmcCVzuJI5XMkcrmQOVzKHK5nDlczhSuZwJXO4kjlcyxyuZQ7XModrmcO1zOFa5nAtc7iWOVzLHK5lDtcyh2uZw7XM4VrmcC1zuJY5XMscrmUO1zKHa5nDtczhWuZwLXO4ljlcyxyuZQ7XModrmcO1zOFa5nAtc7iWOVzLHK5lDtcyh2uZw7XM4VrmcC1zuJY5XMscrmUO1zKHa5nDtczhWuZwLXO4ljlcyxyuZQ7XModrmcO1zOFa5nAtc7iWOVzLHK5lDtcyh2uZw7XM4VrmcC1zuJY5XMscrmUO1zKHa5nDtczhWuZwLXO4ljlcyxyuZQ7XModrmcO1zOFa5nAtc7iWOVzLHK5lDtcyh2uZw7XM4VrmcC1zuJY5XMscrmUO1zKHa5nDtczhWuZwLXO4ljlcyxyuZQ7XModrmcONzOFG5nAjc7iROdzIHG5kDjcyhxuZw43M4UbmcCNzuJE53MgcbmQONzKHG5nDjczhRuZwI3O4kTncyBxuZA43MocbmcONzOFG5nAjc7iROdzIHG5kDjcyhxuZw43M4UbmcCNzuJE53MgcbmQONzKHG5nDjczhRuZwI3O4kTncyBxuZA43MocbmcONzOFG5nAjc7iROdzIHG5kDjcyhxuZw43M4UbmcCNzuJE53MgcbmQONzKHG5nDjczhRuZwI3O4kTncyBxuZA43MocbmcONzOFG5nAjc7iROdzIHG5kDjcyhxuZw43M4UbmcCNzuJE53MgcbmQONzKHG5nDjczhRuZwI3O4kTncyBxuZA43MocbmcONzOFG5nAjc7iROZxdMoi7l5i+xPUlS18S+pLUl2x9SelLWl+id9/07pvefdO7b3r3Te++6d03vfumd9/07pvefde773r3Xe++6913vfuud9/17rvefde773r3l979pXd/6d1feveX3v2ld3/p3V9695fe/aV3P/Tuh9790LsfevdD737o3Q+9+6F3P/Tuh9791LufevdT737q3U+9+6l3P/Xup9791Lufeve33v2td3/r3d9697fe/a13f+vd33r3t979rXe/9O6X3v3Su19690vvfundL737pXe/9O6X3v3Wu99691vvfuvdb737rXe/9e633v3Wu99690fv/ujdH737o3d/9O6P3v3Ruz9690fvvs76TGd9prM+01mf6azv/tSrL0l9ydaXlL6k9SV693XWZzrrM531mc76TGd9prM+01mf6azPdNZnOusznfWZzvpMZ32msz7TWZ/prM901mc66zOd9ZnO+kxnfaazPtNZn+msz3TWZzrrM531mc76TGd9prM+01mf6azPdNZnOusznfWZzvpMZ32msz7TWZ/prM901mc66zOd9ZnO+kxnfaazPtNZn+msz3TWZzrrM531mc76TGd9prM+01mf6azPdNZnOusznfWZzvpMZ32msz7TWZ/prM901mc66zOd9ZnO+kxnfaazPtNZn+msz3TWZzrrM531mc76TGd9prM+01mf6azPdNZnOusznfWZzvpMZ32msz7TWZ/prM901mc663Od9bnO+lxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11mf66zPddbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11mf66zPddbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11mf66zPddbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11mf66zPddbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWzvqWz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" }, { "name": "end_vote", "function_type": "Open", "is_internal": false, "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "public_global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] }, "visibility": "private" }], "param_witnesses": { "inputs": [{ "start": 0, "end": 39 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::public_circuit_public_inputs::PublicCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "contract_storage_update_requests", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_update_request::StorageUpdateRequest", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "new_value", "type": { "kind": "field" } }] } } }, { "name": "contract_storage_reads", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_read::StorageRead", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "current_value", "type": { "kind": "field" } }] } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "prover_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] }, "visibility": "public" }, "return_witnesses": [39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232] }, "bytecode": "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", "debug_symbols": "zZ3brmxZsV3/pZ6RlREx4savWH7ANpaQEOfogCxZiH/3xK69sURx6auYw+2JqlSOMaOIFT1ztxWt6o8//Pbf/tuv/vCbf/vd73/45R9/+Pwnj/nhl//5jz/8/t9/9bs/v/L7P/zqP/7wwy8/v/jh17/778///ukXP/yP3/z21z/80sP+9F9+8X9OrHrifOQTJp9w+UTIJ458IuUTJZ9o+YTc8yP3POWep9zzlHuecs9T7nnKPU+55yn3POWep9zzkvtRcj9K7kfJ/Si5HyX3o4R+/OKv3ve8en58q8eJ7+/O+Xb9vnp9f9693t693t+9Pt69/vyc6+PT8+Nbn7/cn7g+372+3r2+371+3r1+X71+5M/kkT+TR/4MGPkzYOTPgJE/A0b+DBj5M2Dkz+SRP5NX7vnKPV+55yv3fOWer9zzlXu+cs9X7vmqPY/PRz5h8gmXT4R84sgnUj5R8omWT4x8Qu65yT03uecm99zknpvcc5N7bnLPTe65yT03uecu99zlnrvcc5d77nLPXe65yz13uecu99zlnofc85B7HnLPQ+55yD0Puech9zzknsv8NGR+GjI/DZmfhsxPQ+anIfPTkPlpyPw0ZH4aMj8NmZ+GzE9D5qch89OQ+WnI/DRkfhoyPw2Zn4bMT0Pmp1Fyz0vuucxoQ2a0ITPakBltyIw2ZEYbJfe85J633POWe95yz1vuecs9b7nnLfe85Z633POWey5zuJA5XMgcLmQOFzKHC5nDhczhQuZwIXO4kDlcyBwuZA4XMocLmcOFzOFC5nAhc7iQOVzIHC5kDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDndkDpcyh0uZw6XM4VLmcClzuJQ5XMocLmUOlzKHS5nDpczhUuZwKXO4lDlcyhwuZQ6XModLmcOlzOFS5nApc7iUOVzKHC5lDpcyh0uZw6XM4VLmcClzuJQ5XMocLmUOlzKHS5nDpczhUuZwKXO4lDlcyhwuZQ6XModLmcOlzOFS5nApc7iUOVzKHC5lDpcyh0uZw6XM4VLmcClzuJQ5XMocLmUOlzKHS5nDpczhUuZwKXO4lDlcyhwuZQ6XModLmcOlzOFS5nApc7iUOVzKHC5lDpcyh0uZw6XM4VLmcClzuJQ5XMocLmUOlzKHS5nDpczhUuZwKXO4lDlcyhwuZQ6XModLmcOlzOFS5nApc7iUOVzKHC5lDpcyh0uZw6XM4VLmcCVzuJI5XMkcrmQOVzKHK5nDlczhSuZwJXO4kjlcyRyuZA5XMocrmcOVzOFK5nAlc7iSOVzJHK5kDlcyhyuZw5XM4UrmcCVzuJI5XMkcrmQOVzKHK5nDlczhSuZwJXO4kjlcyRyuZA5XMocrmcOVzOFK5nAlc7iSOVzJHK5kDlcyhyuZw5XM4UrmcCVzuJI5XMkcrmQOVzKHK5nDlczhSuZwJXO4kjlcyRyuZA5XMocrmcOVzOFK5nAlc7iSOVzJHK5kDlcyhyuZw5XM4UrmcCVzuJI5XMkcrmQOVzKHK5nDlczhSuZwJXO4kjlcyRyuZA5XMocrmcOVzOFK5nAlc7iSOVzJHK5kDlcyhyuZw5XM4UrmcCVzuJI5XMkcrmQO1zKHa5nDtczhWuZwLXO4ljlcyxyuZQ7XModrmcO1zOFa5nAtc7iWOVzLHK5lDtcyh2uZw7XM4VrmcC1zuJY5XMscrmUO1zKHa5nDtczhWuZwLXO4ljlcyxyuZQ7XModrmcO1zOFa5nAtc7iWOVzLHK5lDtcyh2uZw7XM4VrmcC1zuJY5XMscrmUO1zKHa5nDtczhWuZwLXO4ljlcyxyuZQ7XModrmcO1zOFa5nAtc7iWOVzLHK5lDtcyh2uZw7XM4VrmcC1zuJY5XMscrmUO1zKHa5nDtczhWuZwLXO4ljlcyxyuZQ7XModrmcO1zOFa5nAtc7iWOVzLHK5lDtcyh2uZw7XM4VrmcC1zuJY5XMscrmUO1zKHa5nDtczhWuZwI3O4kTncyBxuZA43MocbmcONzOFG5nAjc7iROdzIHG5kDjcyhxuZw43M4UbmcCNzuJE53MgcbmQONzKHG5nDjczhRuZwI3O4kTncyBxuZA43MocbmcONzOFG5nAjc7iROdzIHG5kDjcyhxuZw43M4UbmcCNzuJE53MgcbmQONzKHG5nDjczhRuZwI3O4kTncyBxuZA43MocbmcONzOFG5nAjc7iROdzIHG5kDjcyhxuZw43M4UbmcCNzuJE53MgcbmQONzKHG5nDjczhRuZwI3O4kTncyBxuZA43MocbmcONzOFG5nAjc7iROdzIHG5kDjcyhxuZw43M4UbmcCNzuJE53MgcbmQONzKHG5nDjczhRuZwI3O4kTncyBxuZA63ModbmcOtzOFW5nArc7iVOdzKHG5lDrcyh1uZw63M4VbmcCtzuJU53MocbmUOtzKHW5nDrczhVuZwK3O4lTncyhxuZQ63ModbmcOtzOFW5nArc7iVOdzKHG5lDrcyh1uZw63M4VbmcCtzuJU53MocbmUOtzKHW5nDrczhVuZwK3O4lTncyhxuZQ63ModbmcOtzOFW5nArc7iVOdzKHG5lDrcyh1uZw63M4VbmcCtzuJU53MocbmUOtzKHW5nDrczhVuZwK3O4lTncyhxuZQ63ModbmcOtzOFW5nArc7iVOdzKHG5lDrcyh1uZw63M4VbmcCtzuJU53MocbmUOtzKHW5nDrczhVuZwK3O4lTncyhxuZQ63ModbmcOtzOFW5nD2kUHcc8T0I64fCf3I0Y+kfqT0I60fGf2I3n3Tu296903vvundN737pnff9O6b3n3Tu296913vvuvdd737rnff9e673n3Xu+96913vvuvdD737oXc/9O6H3v3Qux9690PvfujdD737oXf/6N0/eveP3v2jd//o3T9694/e/aN3/+jdP3r3U+9+6t1Pvfupdz/17qfe/dS7n3r3U+9+6t0vvfuld7/07pfe/dK7X3r3S+9+6d0vvfuld7/17rfe/da733r3W+9+691vvfutd7/17rfe/dG7P3r3R+/+6N0fvfujd3/07o/e/dG7P3r3V+/+6t1fvfurd3/17q/e/dW7v3r3V+++zvpMZ32msz7TWZ/prO/51qsfSf1I6UdaPzL6Eb37OusznfWZzvpMZ32msz7TWZ/prM901mc66zOd9ZnO+kxnfaazPtNZn+msz3TWZzrrM531mc76TGd9prM+01mf6azPdNZnOusznfWZzvpMZ32msz7TWZ/prM901mc66zOd9ZnO+kxnfaazPtNZn+msz3TWZzrrM531mc76TGd9prM+01mf6azPdNZnOusznfWZzvpMZ32msz7TWZ/prM901mc66zOd9ZnO+kxnfaazPtNZn+msz3TWZzrrM531mc76TGd9prM+01mf6azPdNZnOusznfWZzvpMZ32msz7TWZ/prM901mc66zOd9ZnO+kxnfaazPtNZn+msz3TWZzrrM531uc76XGd9rrM+11mf66zPddbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11mf66zPddbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11mf66zPddbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11mf66zPddbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11lf6KwvdNYXOusLnfWFzvpCZ32hs77QWV/orC901hc66wud9YXO+kJnfaGzvtBZX+isL3TWFzrrC531hc76Qmd9obO+0Flf6KwvdNYXOusLnfWFzvpCZ32hs77QWV/orC901hc66wud9YXO+kJnfaGzvtBZX+isL3TWFzrrC531hc76Qmd9obO+0Flf6KwvdNYXOusLnfWFzvpCZ32hs77QWV/orC901hc66wud9YXO+kJnfaGzvtBZX+isL3TWFzrrC531hc76Qmd9obO+0Flf6KwvdNYXOusLnfWFzvpCZ32hs77QWV/orC901hc66wud9YXO+kJnfaGzvtBZX+isL3TWFzrrC531hc76Qmd9obO+0Flf6KwvdNYXOusLnfUdnfUdnfUdhfX94q/ed9Z/fGd6f3+vTX2/Pt69/rx7fb57fb17fb97/bx7/b56vcJSv3K9vXv9u1Nr706t/aypTZtv18d+f+/kT7zVun98q3/+cu1fws+SUkhRCmlKIUMpZCGF+IdSiFEKcUohQSmEkqxOSVZ/J1m/3d6v3j6v3r5v3h6f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dnC9/9HHUoZ9+6TJ508Af/Wl0/7GZvq/+il25Sl+5Slx5SnnylPyylPqylP6ylPmylOuzL5dmX27Mvt2Zfbtyuzbldm3K7NvV2bfrsy+XZl9uzL7fmX2/crs+5XZ9yuz71dm36/Mvl+Zfb8y+35l9v3K7MeV2Y8rsx9XZj+uzH5cmf24MvtxZfbjyuzHldmPK7N/rsz+uTL758rsnyuzf67M/rky++fK7J8rs3+uzP65Mvt5ZfbzyuznldnPK7OfV2Y/r8x+Xpn9vDL7eWX288rs15XZryuzX1dmv67Mfl2Z/boy+3Vl9uvK7NeV2a8rs99XZr+vzH5fmf2+Mvt9Zfb7yuz3ldnvK7PfV2a/r8z+XJn9uTL7c2X258rsz5XZnyuzP1dmf67M/lyZ/bky+3tl9vfK7O+V2d8rs79XZn+vzP5emf29Mvt7Zfav7PX5lb0+v7LX51f2+vzKXp9/zpWn5JWn1JWn9JWnzJWnXJn9K3t9fmWvz6/s9fmVvT6/stfnV/b6/Mpen1/Z6/Mre31+Za/Pr+z1+ZW9Pr+y1+dX9vr8yl6fX9nr8yt7fX5lr8+v7PX5lb0+v7LX51f2+vzKXp9f2evzK3t9fmWvz6/s9fmVvT6/stfnV/b6/Mpen1/Z6/Mre31+Za/Pr+z1+ZW9Pr+y1+dX9vr8yl6fX9nr8yt7fX5lr8+v7PX5lb0+v7LX51f2+vzKXp9f2evzK3t9fmWvz6/s9fmVvT6/stfnV/b6/Mpen1/Z6/Mre31+Za/Pr+z1+ZW9Pr+y1+dX9vr8yl6fX9nr8yt7fX5lr8+v7PX5lb0+v7LX51f2+vzKXp9f2evzK3t9fmWvz6/s9fmVvT6/stfnV/b6/Mpen1/Z6/Mre31+Za/Pr+z1+ZW9Pr+y1+dX9vr8yl6fX9nr8yt7fX5lry+u7PXFlb2+uLLXF1f2+uJzrjwlrzylrjylrzxlrjzlyuxf2euLK3t9cWWvL67s9cWVvb64stcXV/b64speX1zZ64sre31xZa8vruz1xZW9vriy1xdX9vriyl5fXNnriyt7fXFlry/0vb4fD+qret8O2lcP+lcPxlcPnq8ezK8erK8e7K8enK8e/OpPzvnqT85P7259+6+WfP7BLJyqb//5olP9l3fnfL/fX74/Xr7/vHx/vnx/vXx/v3z/vHz/vnv/T29h/Qvvf3l+89X5PX/r39Ra/eOxB6F8P9X2/VR86dT50qn80qn60qn+yqmfzsB/9D3l/I1/u+Q/ce4n/x8prx+PVc1PVVlfOtVfOjVfOrXaqedv/uev/uM3v/qvv/31758Dz9/+4X/9+//9yz/9bw==" }], "events": [], "file_map": { "27": { "source": "mod poseidon;\nmod mimc;\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint\n// docs:end:pedersen_commitment\n{\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field<N>(input: [Field; N]) -> Field {\n    let mut inputs_as_bytes = [];\n\n    for i in 0..N {\n        let input_bytes = input[i].to_le_bytes(32);\n        for i in 0..32 {\n            inputs_as_bytes = inputs_as_bytes.push_back(input_bytes[i]);\n        }\n    }\n\n    let hashed_input = blake2s(inputs_as_bytes);\n    crate::field::bytes32_to_field(hashed_input)\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [u8; N], _state_length: u32) -> [u8; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n", "path": "std/hash.nr" }, "31": { "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n", "path": "std/option.nr" }, "58": { "source": "use crate::{\n    context::inputs::PublicContextInputs, messaging::process_l1_to_l2_message,\n    oracle::{arguments, public_call::call_public_function_internal}\n};\nuse dep::protocol_types::{\n    abis::{\n    global_variables::GlobalVariables, function_selector::FunctionSelector,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_READ_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::hash_args, header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader\n};\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<StorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_reads: BoundedVec<StorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack_hashes: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n    prover_address: AztecAddress,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = StorageRead::empty();\n        let empty_storage_update = StorageUpdateRequest::empty();\n        PublicContext {\n            inputs,\n            side_effect_counter: inputs.call_context.start_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(0),\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_reads: BoundedVec::new(empty_storage_read),\n            public_call_stack_hashes: BoundedVec::new(0),\n            new_note_hashes: BoundedVec::new(SideEffect::empty()),\n            new_nullifiers: BoundedVec::new(SideEffectLinkedToNoteHash::empty()),\n            new_l2_to_l1_msgs: BoundedVec::new(L2ToL1Message::empty()),\n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n            historical_header: inputs.historical_header,\n            prover_address: AztecAddress::zero() // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn coinbase(self) -> EthAddress {\n        self.inputs.public_global_variables.coinbase\n    }\n\n    pub fn fee_recipient(self) -> AztecAddress {\n        self.inputs.public_global_variables.fee_recipient\n    }\n\n    pub fn finish(self) -> PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_reads: self.contract_storage_reads.storage,\n            return_values: self.return_values.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash,\n            unencrypted_log_preimages_length,\n            historical_header: self.inputs.historical_header,\n            prover_address: self.prover_address\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash {\n            value: nullifier,\n            note_hash: 0, // cannot nullify pending notes in public context\n            counter: self.side_effect_counter\n        };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field, sender: EthAddress) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            this,\n            sender,\n            self.chain_id(),\n            self.version(),\n            msg_key,\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(contract_address, function_selector, 0, false, true)\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr" }, "60": { "source": "use crate::{\n    context::inputs::PrivateContextInputs, key::nullifier_key::validate_nullifier_key_against_address,\n    messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair},\n    debug_log::debug_log\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n    nullifier_key_validation_request::NullifierKeyValidationRequest,\n    private_call_stack_item::PrivateCallStackItem,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader\n};\nuse dep::std::option::Option;\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<SideEffect, MAX_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let side_effect_counter = inputs.call_context.start_side_effect_counter;\n        let mut min_revertible_side_effect_counter = 0;\n        // Note. The side effect counter is 2 when this is the initial call\n        if (side_effect_counter == 2) {\n            min_revertible_side_effect_counter = side_effect_counter;\n        }\n        PrivateContext {\n            inputs,\n            side_effect_counter,\n            min_revertible_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(0),\n            read_requests: BoundedVec::new(SideEffect::empty()),\n            nullifier_key_validation_requests: BoundedVec::new(NullifierKeyValidationRequest::empty()),\n            new_note_hashes: BoundedVec::new(SideEffect::empty()),\n            new_nullifiers: BoundedVec::new(SideEffectLinkedToNoteHash::empty()),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(0),\n            public_call_stack_hashes: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(L2ToL1Message::empty()),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            // TODO(fees): start this from 0 and test the following:\n            // - in the private circuit init that it gets set correctly\n            // - in the private circuit inner that it remains 0\n            // I've had to initialize the counter here so that it would work for contract deployments\n            // the above checks should be doable after we figure out fee payments for contract deployments\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            read_requests: self.read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_min_revertible_side_effect_counter(&mut self) {\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        let side_effect = SideEffect { value: read_request, counter: self.side_effect_counter };\n        self.read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            msg_key,\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_note_hashes: [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero()\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr" }, "67": { "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n// contract_address + \n// args_hash +\n// crate::abi::FUNCTION_DATA_SIZE +\n// crate::abi::CALL_CONTEXT_SIZE\n// = 2 + 4 + 8\nglobal ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE: Field = 14;\n\n#[oracle(enqueuePublicFunctionCall)]\nfn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr" }, "68": { "source": "#[oracle(packArguments)]\nfn pack_arguments_oracle<N>(_args: [Field; N]) -> Field {}\n\n// TODO: explain what this does.\nunconstrained pub fn pack_arguments<N>(args: [Field; N]) -> Field {\n    pack_arguments_oracle(args)\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr" }, "71": { "source": "use dep::protocol_types::traits::{Deserialize, Serialize};\n\n#[oracle(storageRead)]\nfn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_oracle_wrapper(storage_slot)\n}\n\n#[oracle(storageWrite)]\nfn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/storage.nr" }, "78": { "source": "use dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint, grumpkin_private_key::GrumpkinPrivateKey};\n\nstruct NullifierKeyPair {\n    account: AztecAddress,\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\n#[oracle(getNullifierKeyPair)]\nfn get_nullifier_key_pair_oracle(_account: AztecAddress) -> [Field; 4] {}\n\nunconstrained fn get_nullifier_key_pair_internal(account: AztecAddress) -> NullifierKeyPair {\n    let result = get_nullifier_key_pair_oracle(account);\n    NullifierKeyPair {\n        account,\n        public_key: GrumpkinPoint { x: result[0], y: result[1] },\n        secret_key: GrumpkinPrivateKey { high: result[2], low: result[3] }\n    }\n}\n\npub fn get_nullifier_key_pair(account: AztecAddress) -> NullifierKeyPair {\n    get_nullifier_key_pair_internal(account)\n}\n\npub fn get_nullifier_secret_key(account: AztecAddress) -> GrumpkinPrivateKey {\n    get_nullifier_key_pair_internal(account).secret_key\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/nullifier_key.nr" }, "85": { "source": "mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod avm;\n\nuse private_context::PrivateContext;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none() }\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/context.nr" }, "97": { "source": "use crate::context::{Context};\nuse crate::oracle::storage::storage_read;\nuse crate::oracle::storage::storage_write;\nuse dep::std::option::Option;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_state_struct\nstruct PublicState<T> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_state_struct\n\nimpl<T> Storage<T> for PublicState<T> {}\n\nimpl<T> PublicState<T> {\n    // docs:start:public_state_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicState { context, storage_slot }\n    }\n    // docs:end:public_state_struct_new\n\n    // docs:start:public_state_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"Public state writes only supported in public functions\");\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n    // docs:end:public_state_struct_read\n\n    // docs:start:public_state_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"Public state writes only supported in public functions\");\n        let fields = T::serialize(value);\n        storage_write(self.storage_slot, fields);\n    }\n    // docs:end:public_state_struct_write\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/public_state.nr" }, "100": { "source": "use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::std::option::Option;\nuse dep::protocol_types::{hash::pedersen_hash, traits::{ToField}};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T> Storage<T> for Map<K, T> {}\n\nimpl<K, V> Map<K, V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key.to_field()], 0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/map.nr" }, "106": { "source": "use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/hasher.nr" }, "121": { "source": "use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize}\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    portal_contract_address : EthAddress,\n\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment : bool,\n\n    start_side_effect_counter : u32,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn assert_is_zero(self) {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3595)\n        assert(self.msg_sender.to_field() == 0);\n        assert(self.storage_contract_address.to_field() == 0);\n        assert(self.portal_contract_address.to_field() == 0);\n        assert(self.function_selector.to_field() == 0);\n        assert(self.is_delegate_call == false);\n        assert(self.is_static_call == false);\n        assert(self.is_contract_deployment == false);\n        assert(self.start_side_effect_counter == 0);\n    }\n}\n\nimpl Eq for CallContext {\n    fn eq(self, call_context: CallContext) -> bool {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3595)\n        call_context.msg_sender.eq(self.msg_sender)\n            & call_context.storage_contract_address.eq(self.storage_contract_address)\n            & call_context.portal_contract_address.eq(self.portal_contract_address)\n            & call_context.function_selector.eq(self.function_selector)\n            & (call_context.is_delegate_call == self.is_delegate_call)\n            & (call_context.is_static_call == self.is_static_call)\n            & (call_context.is_contract_deployment == self.is_contract_deployment)\n            & (call_context.start_side_effect_counter == self.start_side_effect_counter)\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender.to_field(),\n            self.storage_contract_address.to_field(),\n            self.portal_contract_address.to_field(),\n            self.function_selector.to_field(),\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n            self.start_side_effect_counter as Field,\n        ]\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        CallContext {\n            msg_sender: AztecAddress::from_field(serialized[0]),\n            storage_contract_address: AztecAddress::from_field(serialized[1]),\n            portal_contract_address: EthAddress::from_field(serialized[2]),\n            function_selector: FunctionSelector::from_field(serialized[3]),\n            is_delegate_call: serialized[4] as bool,\n            is_static_call: serialized[5] as bool,\n            is_contract_deployment: serialized[6] as bool,\n            start_side_effect_counter: serialized[7] as u32,\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context: CallContext = dep::std::unsafe::zeroed();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let context: CallContext = dep::std::unsafe::zeroed();\n    let _hashed = context.hash();\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/abis/call_context.nr" }, "122": { "source": "use crate::{\n    abis::{call_context::CallContext, side_effect::{SideEffect, SideEffectLinkedToNoteHash}},\n    address::AztecAddress,\n    constants::{\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::pedersen_hash, header::Header, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Hash, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PublicCircuitPublicInputs{\n    call_context: CallContext,\n\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n\n    contract_storage_update_requests: [StorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_reads: [StorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n\n    // todo: add sideeffect ranges for the input to these hashes\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_note_hashes: [SideEffect; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [SideEffectLinkedToNoteHash; MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n\n    // Here so that the gas cost of this request can be measured by circuits, without actually needing to feed in the\n    // variable-length data.\n    unencrypted_log_preimages_length: Field,\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n\n    prover_address: AztecAddress,\n}\n\nimpl Eq for PublicCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Serialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.extend_from_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.extend_from_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_reads[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n\n        for i in 0..MAX_NEW_NOTE_HASHES_PER_CALL {\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..MAX_NEW_NULLIFIERS_PER_CALL {\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        for i in 0..MAX_NEW_L2_TO_L1_MSGS_PER_CALL {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n        fields.extend_from_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.push(self.prover_address.to_field());\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            return_values: reader.read_array([0; RETURN_VALUES_LENGTH]),\n            contract_storage_update_requests: reader.read_struct_array(StorageUpdateRequest::deserialize, [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL]),\n            contract_storage_reads: reader.read_struct_array(StorageRead::deserialize, [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(SideEffect::deserialize, [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(SideEffectLinkedToNoteHash::deserialize, [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            unencrypted_logs_hash: reader.read_array([0; NUM_FIELDS_PER_SHA256]),\n            unencrypted_log_preimages_length: reader.read(),\n            historical_header: reader.read_struct(Header::deserialize),\n            prover_address: reader.read_struct(AztecAddress::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PublicCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let serialized = pcpi.serialize();\n    let deserialized = PublicCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let hash = inputs.hash();\n\n    // Value from public_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    assert_eq(hash, 0x0d43290c164ebc3d80d4d17f1939482d9d01ad503cebceb8c665d2bd96597a68);\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/abis/public_circuit_public_inputs.nr" }, "133": { "source": "use crate::abis::{function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs};\nuse crate::address::AztecAddress;\nuse crate::constants::GENERATOR_INDEX__CALL_STACK_ITEM;\nuse crate::traits::Hash;\n\nstruct PublicCallStackItem {\n    contract_address: AztecAddress,\n    public_inputs: PublicCircuitPublicInputs,\n    function_data: FunctionData,\n    // True if this call stack item represents a request to execute a function rather than a\n    // fulfilled execution. Used when enqueuing calls from private to public functions.\n    is_execution_request: bool,\n}\n\nimpl Hash for PublicCallStackItem {\n    fn hash(self) -> Field {\n        let item = if self.is_execution_request {\n            self.as_execution_request()\n        } else {\n            self\n        };\n\n        dep::std::hash::pedersen_hash_with_separator([\n            item.contract_address.to_field(),\n            item.function_data.hash(),\n            item.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl PublicCallStackItem {\n    fn as_execution_request(self) -> Self {\n        let public_inputs = self.public_inputs;\n        let mut request_public_inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n        request_public_inputs.call_context = public_inputs.call_context;\n        request_public_inputs.args_hash = public_inputs.args_hash;\n\n        let call_stack_item = PublicCallStackItem {\n            contract_address: self.contract_address,\n            function_data: self.function_data,\n            is_execution_request: true,\n            public_inputs: request_public_inputs\n        };\n        call_stack_item\n    }\n}\n\nmod tests {\n    use crate::{\n        abis::{\n        function_data::FunctionData, function_selector::FunctionSelector,\n        public_circuit_public_inputs::PublicCircuitPublicInputs,\n        public_call_stack_item::PublicCallStackItem, side_effect::SideEffect\n    },\n        address::AztecAddress, constants::GENERATOR_INDEX__CALL_STACK_ITEM, traits::Hash\n    };\n\n    #[test]\n    fn compute_call_stack_item_request_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_internal: false, is_private: false, is_constructor: false };\n\n        let mut public_inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n        public_inputs.new_note_hashes[0] = SideEffect{\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: true, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item request hash\" test\n        assert_eq(call_stack_item.hash(), 0x2812dfeffdb7553fbbdd27c03fbdf61e3aa9bab3209db39f78838508ad892803);\n    }\n\n    #[test]\n    fn compute_call_stack_item_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_internal: false, is_private: false, is_constructor: false };\n\n        let mut public_inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n        public_inputs.new_note_hashes[0] = SideEffect{\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: false, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item hash\" test\n        assert_eq(call_stack_item.hash(), 0x1f71c0d6bd03e409df694549b6aa83d706cfe55427152e6ec443ec64fa62d3a0);\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/abis/public_call_stack_item.nr" }, "142": { "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize}\n};\n\nstruct FunctionData {\n    // First four bytes of the abi encoding \n    // of a function. \n    selector : FunctionSelector,\n    is_internal : bool,\n    is_private : bool,\n    is_constructor : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        self.is_internal == other.is_internal &\n        self.is_private == other.is_private &\n        self.is_constructor == other.is_constructor\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_internal: serialized[1] as bool,\n            is_private: serialized[2] as bool,\n            is_constructor: serialized[3] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data: FunctionData = dep::std::unsafe::zeroed();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data: FunctionData = dep::std::unsafe::zeroed();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty item hash\" test\n    assert_eq(hash, 0x200569267c0f73ac89aaa414239398db9445dd4ad3a8cf37015cd55b8d4c5e8d);\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/abis/function_data.nr" }, "145": { "source": "use crate::utils::field::field_from_bytes;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Serialize, Deserialize};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_field(value: Field) -> Self {\n        Self { inner: value as u32 }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = dep::std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/abis/function_selector.nr" }, "174": { "source": "global ARGS_LENGTH: Field = 16;\nglobal RETURN_VALUES_LENGTH: Field = 4;\n\n/**\n * Convention for constant array lengths are mainly divided in 2 classes:\n *  - FUNCTION CALL\n *  - TRANSACTION\n *\n * Agreed convention is to use MAX_XXX_PER_CALL resp. MAX_XXX_PER_TX, where XXX denotes a type of element such as\n * commitment, or nullifier, e.g.,:\n *  - MAX_NEW_NULLIFIERS_PER_CALL\n *  - MAX_NEW_NOTE_HASHES_PER_TX\n *\n * In the kernel circuits, we accumulate elements such as note hashes and the nullifiers from all functions calls in a\n * transaction. Therefore, we always must have:\n * MAX_XXX_PER_TX  MAX_XXX_PER_CALL\n *\n * For instance:\n * MAX_NEW_NOTE_HASHES_PER_TX  MAX_NEW_NOTE_HASHES_PER_CALL\n * MAX_NEW_NULLIFIERS_PER_TX  MAX_NEW_NULLIFIERS_PER_CALL\n *\n */\n\n// docs:start:constants\n// \"PER CALL\" CONSTANTS\nglobal MAX_NEW_NOTE_HASHES_PER_CALL: Field = 16;\nglobal MAX_NEW_NULLIFIERS_PER_CALL: Field = 16;\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL: Field = 4;\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL: Field = 4;\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_CALL: Field = 2;\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL: Field = 16;\nglobal MAX_PUBLIC_DATA_READS_PER_CALL: Field = 16;\nglobal MAX_READ_REQUESTS_PER_CALL: Field = 32;\nglobal MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL: Field = 1;\n\n// \"PER TRANSACTION\" CONSTANTS\nglobal MAX_NEW_NOTE_HASHES_PER_TX: Field = 64;\nglobal MAX_NON_REVERTIBLE_NOTE_HASHES_PER_TX: Field = 8;\nglobal MAX_REVERTIBLE_NOTE_HASHES_PER_TX: Field = 56;\n\nglobal MAX_NEW_NULLIFIERS_PER_TX: Field = 64;\nglobal MAX_NON_REVERTIBLE_NULLIFIERS_PER_TX: Field = 8;\nglobal MAX_REVERTIBLE_NULLIFIERS_PER_TX: Field = 56;\n\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX: Field = 8;\n\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX: Field = 8;\nglobal MAX_NON_REVERTIBLE_PUBLIC_CALL_STACK_LENGTH_PER_TX: Field = 3;\nglobal MAX_REVERTIBLE_PUBLIC_CALL_STACK_LENGTH_PER_TX: Field = 5;\n\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: Field = 32;\nglobal MAX_NON_REVERTIBLE_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: Field = 16;\nglobal MAX_REVERTIBLE_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: Field = 16;\n\nglobal MAX_PUBLIC_DATA_READS_PER_TX: Field = 32;\nglobal MAX_NON_REVERTIBLE_PUBLIC_DATA_READS_PER_TX: Field = 16;\nglobal MAX_REVERTIBLE_PUBLIC_DATA_READS_PER_TX: Field = 16;\n\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_TX: Field = 2;\nglobal MAX_NEW_CONTRACTS_PER_TX: Field = 1;\nglobal MAX_READ_REQUESTS_PER_TX: Field = 128;\nglobal MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_TX: Field = 4;\nglobal NUM_ENCRYPTED_LOGS_HASHES_PER_TX: Field = 1;\nglobal NUM_UNENCRYPTED_LOGS_HASHES_PER_TX: Field = 1;\n// docs:end:constants\n\n// ROLLUP CONTRACT CONSTANTS - constants used only in l1-contracts\nglobal NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP: Field = 16;\n\n// TREES RELATED CONSTANTS\nglobal VK_TREE_HEIGHT: Field = 3;\nglobal FUNCTION_TREE_HEIGHT: Field = 5;\nglobal CONTRACT_TREE_HEIGHT: Field = 16;\nglobal NOTE_HASH_TREE_HEIGHT: Field = 32;\nglobal PUBLIC_DATA_TREE_HEIGHT: Field = 40;\nglobal NULLIFIER_TREE_HEIGHT: Field = 20;\nglobal L1_TO_L2_MSG_TREE_HEIGHT: Field = 16;\nglobal ROLLUP_VK_TREE_HEIGHT: Field = 8;\nglobal ARTIFACT_FUNCTION_TREE_MAX_HEIGHT = 5;\n\n// SUB-TREES RELATED CONSTANTS\nglobal CONTRACT_SUBTREE_HEIGHT: Field = 0;\nglobal CONTRACT_SUBTREE_SIBLING_PATH_LENGTH: Field = 16;\nglobal NOTE_HASH_SUBTREE_HEIGHT: Field = 6;\nglobal NOTE_HASH_SUBTREE_SIBLING_PATH_LENGTH: Field = 26;\nglobal NULLIFIER_SUBTREE_HEIGHT: Field = 6;\nglobal PUBLIC_DATA_SUBTREE_HEIGHT: Field = 5;\nglobal ARCHIVE_HEIGHT: Field = 16;\nglobal NULLIFIER_SUBTREE_SIBLING_PATH_LENGTH: Field = 14;\nglobal PUBLIC_DATA_SUBTREE_SIBLING_PATH_LENGTH: Field = 35;\nglobal L1_TO_L2_MSG_SUBTREE_HEIGHT: Field = 4;\nglobal L1_TO_L2_MSG_SUBTREE_SIBLING_PATH_LENGTH: Field = 12;\n\n// MISC CONSTANTS\nglobal FUNCTION_SELECTOR_NUM_BYTES: Field = 4;\nglobal MAPPING_SLOT_PEDERSEN_SEPARATOR: Field = 4;\n// sha256 hash is stored in two fields to accommodate all 256-bits of the hash\nglobal NUM_FIELDS_PER_SHA256: Field = 2;\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 32;\n\n// CONTRACT CLASS CONSTANTS\n// This should be around 8192 (assuming 2**15 instructions packed at 8 bytes each),\n// but it's reduced to speed up build times, otherwise the ClassRegisterer takes over 5 mins to compile.\n// We are not using 1024 so we can squeeze in a few more args to methods that consume packed public bytecode,\n// such as the ClassRegisterer.register, and still land below the 32 * 32 max args limit for hashing.\nglobal MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS: Field = 1000;\n// Bytecode size for private functions is per function, not for the entire contract.\n// Note that private functions bytecode includes a mix of acir and brillig.\nglobal MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS: Field = 500;\n// Same for unconstrained functions: the size is per function.\nglobal MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS: Field = 500;\n// Since we are not yet emitting selectors we'll use this magic value to identify events emitted by the ClassRegisterer.\n// This is just a stopgap until we implement proper selectors.\n// sha224sum 'struct ContractClassRegistered {contract_class_id: ContractClassId, version: Field, artifact_hash: Field, private_functions_root: Field, packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS] }'\nglobal REGISTERER_CONTRACT_CLASS_REGISTERED_MAGIC_VALUE = 0x6999d1e02b08a447a463563453cb36919c9dd7150336fc7c4d2b52f8;\n// sha224sum 'struct ClassPrivateFunctionBroadcasted'\nglobal REGISTERER_PRIVATE_FUNCTION_BROADCASTED_MAGIC_VALUE = 0x1b70e95fde0b70adc30496b90a327af6a5e383e028e7a43211a07bcd;\n// sha224sum 'struct ClassUnconstrainedFunctionBroadcasted'\nglobal REGISTERER_UNCONSTRAINED_FUNCTION_BROADCASTED_MAGIC_VALUE = 0xe7af816635466f128568edb04c9fa024f6c87fb9010fdbffa68b3d99;\n\n// CONTRACT INSTANCE CONSTANTS\n// sha224sum 'struct ContractInstanceDeployed'\nglobal DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE = 0x85864497636cf755ae7bde03f267ce01a520981c21c3682aaf82a631;\n\n// NOIR CONSTANTS - constants used only in yarn-packages/noir-contracts\n// Some are defined here because Noir doesn't yet support globals referencing other globals yet.\n// Move these constants to a noir file once the issue below is resolved:\n// https://github.com/noir-lang/noir/issues/1734\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: Field = 25;\nglobal MAX_NOTE_FIELDS_LENGTH: Field = 20;\n// GET_NOTE_ORACLE_RETURN_LENGT = MAX_NOTE_FIELDS_LENGTH + 1 + 2\n// The plus 1 is 1 extra field for nonce.\n// + 2 for EXTRA_DATA: [number_of_return_notes, contract_address]\nglobal GET_NOTE_ORACLE_RETURN_LENGTH: Field = 23;\nglobal MAX_NOTES_PER_PAGE: Field = 10;\n// VIEW_NOTE_ORACLE_RETURN_LENGTH = MAX_NOTES_PER_PAGE * (MAX_NOTE_FIELDS_LENGTH + 1) + 2;\nglobal VIEW_NOTE_ORACLE_RETURN_LENGTH: Field = 212;\n\n// LENGTH OF STRUCTS SERIALIZED TO FIELDS\nglobal AZTEC_ADDRESS_LENGTH = 1;\nglobal CALL_CONTEXT_LENGTH: Field = 8;\nglobal CONTENT_COMMITMENT_LENGTH: Field = 7;\nglobal CONTRACT_DEPLOYMENT_DATA_LENGTH: Field = 6;\nglobal CONTRACT_STORAGE_READ_LENGTH: Field = 2;\nglobal CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH: Field = 2;\nglobal ETH_ADDRESS_LENGTH = 1;\nglobal FUNCTION_DATA_LENGTH: Field = 4;\nglobal FUNCTION_LEAF_PREIMAGE_LENGTH: Field = 5;\nglobal GLOBAL_VARIABLES_LENGTH: Field = 6;\nglobal HEADER_LENGTH: Field = 25; // 2 for last_archive, 7 for content commitment, 10 for state reference, 6 for global vars\nglobal L1_TO_L2_MESSAGE_LENGTH: Field = 8;\nglobal L2_TO_L1_MESSAGE_LENGTH: Field = 2;\nglobal NEW_CONTRACT_DATA_LENGTH: Field = 3;\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH = 4;\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH = 5;\nglobal PARTIAL_STATE_REFERENCE_LENGTH: Field = 8;\nglobal PRIVATE_CALL_STACK_ITEM_LENGTH: Field = 219;\n// Change this ONLY if you have changed the PrivateCircuitPublicInputs structure.\n// In other words, if the structure/size of the public inputs of a function call changes then we should change this\n// constant as well PRIVATE_CALL_STACK_ITEM_LENGTH\nglobal PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH: Field = 214;\n// Change this ONLY if you have changed the PublicCircuitPublicInputs structure.\nglobal PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH: Field = 194;\nglobal STATE_REFERENCE_LENGTH: Field = 10; // 2 for snap + 8 for partial\nglobal TX_CONTEXT_DATA_LENGTH: Field = 11;\nglobal TX_REQUEST_LENGTH: Field = 17;\n\nglobal GET_NOTES_ORACLE_RETURN_LENGTH: Field = 674;\nglobal NOTE_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal NULLIFIERS_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal PUBLIC_DATA_WRITES_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal CONTRACTS_NUM_BYTES_PER_BASE_ROLLUP: Field = 32;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP_UNPADDED: Field = 52;\nglobal L2_TO_L1_MSGS_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal LOGS_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\n\n/**\n * Enumerate the hash_indices which are used for pedersen hashing.\n * We start from 1 to avoid the default generators. The generator indices are listed\n * based on the number of elements each index hashes. The following conditions must be met:\n *\n * +-----------+-------------------------------+----------------------+\n * | Hash size | Number of elements hashed (n) | Condition to use     |\n * |-----------+-------------------------------+----------------------|\n * | LOW       | n  8                         | 0 < hash_index  32  |\n * | MID       | 8 < n  16                    | 32 < hash_index  40 |\n * | HIGH      | 16 < n  48                   | 40 < hash_index  48 |\n * +-----------+-------------------------------+----------------------+\n *\n * Note: When modifying, modify `GeneratorIndexPacker` in packer.hpp accordingly.\n */\n// Indices with size  8\nglobal GENERATOR_INDEX__NOTE_HASH = 1;\nglobal GENERATOR_INDEX__NOTE_HASH_NONCE = 2;\nglobal GENERATOR_INDEX__UNIQUE_NOTE_HASH = 3;\nglobal GENERATOR_INDEX__SILOED_NOTE_HASH = 4;\nglobal GENERATOR_INDEX__NULLIFIER = 5;\nglobal GENERATOR_INDEX__INITIALIZATION_NULLIFIER = 6;\nglobal GENERATOR_INDEX__OUTER_NULLIFIER = 7;\nglobal GENERATOR_INDEX__PUBLIC_DATA_READ = 8;\nglobal GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST = 9;\nglobal GENERATOR_INDEX__FUNCTION_DATA = 10;\nglobal GENERATOR_INDEX__FUNCTION_LEAF = 11;\nglobal GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA = 12;\nglobal GENERATOR_INDEX__CONSTRUCTOR = 13;\nglobal GENERATOR_INDEX__CONSTRUCTOR_ARGS = 14;\nglobal GENERATOR_INDEX__CONTRACT_ADDRESS = 15;\nglobal GENERATOR_INDEX__CONTRACT_LEAF = 16;\nglobal GENERATOR_INDEX__CALL_CONTEXT = 17;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM = 18;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM_2 = 19;\nglobal GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET = 20;\nglobal GENERATOR_INDEX__L2_TO_L1_MSG = 21;\nglobal GENERATOR_INDEX__TX_CONTEXT = 22;\nglobal GENERATOR_INDEX__PUBLIC_LEAF_INDEX = 23;\nglobal GENERATOR_INDEX__PUBLIC_DATA_LEAF = 24;\nglobal GENERATOR_INDEX__SIGNED_TX_REQUEST = 25;\nglobal GENERATOR_INDEX__GLOBAL_VARIABLES = 26;\nglobal GENERATOR_INDEX__PARTIAL_ADDRESS = 27;\nglobal GENERATOR_INDEX__BLOCK_HASH = 28;\nglobal GENERATOR_INDEX__SIDE_EFFECT = 29;\nglobal GENERATOR_INDEX__FEE_PAYLOAD = 30;\n// Indices with size  16\nglobal GENERATOR_INDEX__TX_REQUEST = 33;\nglobal GENERATOR_INDEX__SIGNATURE_PAYLOAD = 34;\n// Indices with size  44\nglobal GENERATOR_INDEX__VK = 41;\nglobal GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS = 42;\nglobal GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS = 43;\nglobal GENERATOR_INDEX__FUNCTION_ARGS = 44;\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/constants.nr" }, "177": { "source": "struct Reader<N> {\n    data: [Field; N],\n    offset: Field,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/utils/reader.nr" }, "182": { "source": "use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/type_serialization.nr" }, "186": { "source": "use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS},\n    contract_class_id::ContractClassId, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute_from_public_key(\n        pub_key: GrumpkinPoint,\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> AztecAddress {\n        AztecAddress::compute(\n            PublicKeysHash::compute(pub_key),\n            PartialAddress::compute(\n                contract_class_id,\n                salt,\n                initialization_hash,\n                portal_contract_address\n            )\n        )\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let contract_address_salt = 3;\n    let contract_class_id = ContractClassId::from_field(4);\n    let initialization_hash = 5;\n    let portal_contract_address = EthAddress::from_field(6);\n\n    let address = AztecAddress::compute_from_public_key(\n        point,\n        contract_class_id,\n        contract_address_salt,\n        initialization_hash,\n        portal_contract_address\n    );\n\n    assert(address.to_field() == 0x2fd71a4f0742364f194dd16d0ae32d2f47845ddc7f5d328f37d4148b565c4123);\n}\n\n#[test]\nfn compute_address_from_partial_and_pubkey() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let partial_address = PartialAddress::from_field(3);\n\n    let address = AztecAddress::compute(PublicKeysHash::compute(point), partial_address);\n    assert(address.to_field() == 0x0447f893197175723deb223696e2e96dbba1e707ee8507766373558877e74197);\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/address/aztec_address.nr" }, "191": { "source": "use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::FunctionLeafPreimage;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::new_contract_data::NewContractData as ContractLeafPreimage;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, CONTRACT_TREE_HEIGHT, FUNCTION_TREE_HEIGHT,\n    NOTE_HASH_TREE_HEIGHT, NUM_FIELDS_PER_SHA256, GENERATOR_INDEX__SILOED_NOTE_HASH,\n    GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK, GENERATOR_INDEX__CONSTRUCTOR,\n    GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Checks that `value` is a member of a merkle tree with root `root` at position `index`\n// The witness being the `sibling_path`\npub fn assert_check_membership<N>(value: Field, index: Field, sibling_path: [Field; N], root: Field) {\n    let calculated_root = root_from_sibling_path(value, index, sibling_path);\n    assert(calculated_root == root, \"membership check failed\");\n}\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<N>(leaf: Field, leaf_index: Field, sibling_path: [Field; N]) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\n// Calculate the contract tree root from the sibling path and leaf preimage.\npub fn contract_tree_root_from_siblings(\n    contract_class_id: ContractClassId,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    contract_leaf_index: Field,\n    contract_leaf_sibling_path: [Field; CONTRACT_TREE_HEIGHT]\n) -> Field {\n    //TODO(Kev): if we use shorthand syntax here, we get an error as expected,\n    // since variable name is `storage_contract_address` but the span is incorrect.\n    let contract_leaf_preimage = ContractLeafPreimage { contract_address: storage_contract_address, portal_contract_address, contract_class_id };\n\n    let contract_leaf = contract_leaf_preimage.hash();\n\n    let computed_contract_tree_root = root_from_sibling_path(contract_leaf, contract_leaf_index, contract_leaf_sibling_path);\n\n    computed_contract_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn read_request_root_from_siblings(\n    read_request: Field,\n    leaf_index: Field,\n    sibling_path: [Field; NOTE_HASH_TREE_HEIGHT]\n) -> Field {\n    root_from_sibling_path(read_request, leaf_index, sibling_path)\n}\n\npub fn silo_note_hash(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\nfn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new(0);\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, commitment_index: Field) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_siloed_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_unique_siloed_note_hashes<N>(\n    first_nullifier: Field,\n    siloed_note_hashes: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_note_hashes = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_note_hash = siloed_note_hashes[i];\n        if siloed_note_hash.value != 0 {\n            let nonce = compute_note_hash_nonce(first_nullifier, i);\n            unique_siloed_note_hashes[i] = SideEffect {\n                value: compute_unique_siloed_note_hash(nonce, siloed_note_hash.value),\n                counter: siloed_note_hash.counter\n                };\n        }\n    }\n    unique_siloed_note_hashes\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/hash.nr" }, "231": { "source": "contract EasyPrivateVoting {\n    // docs:start:imports\n    use dep::aztec::{\n        protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress},\n        context::{PrivateContext, Context}, state_vars::{map::Map, public_state::PublicState}\n    };\n    // docs:end:imports\n    // docs:start:storage_struct\n    struct Storage {\n        admin: PublicState<AztecAddress>, // admin can end vote\n        tally: Map<Field, PublicState<Field>>, // we will store candidate as key and number of votes as value\n        voteEnded: PublicState<bool>, // voteEnded is boolean\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(private)] // annotation to mark function as private and expose private context\n    fn constructor(admin: AztecAddress) { // called when contract is deployed\n        context.call_public_function(\n            // we cannot update public state directly from private function but we can call public function (which queues it)\n            context.this_address(),// contract address whose method we want to call\n            FunctionSelector::from_signature(\"_initialize((Field))\"), // function selector\n            [admin.to_field()] // parameters\n        );\n    }\n    // docs:end:constructor\n    // docs:start:initialize\n    #[aztec(public)] // annotation to mark function as public and expose public context\n    internal fn _initialize(admin: AztecAddress) { // internal - can only be called by contract\n        storage.admin.write(admin);\n        storage.voteEnded.write(false);\n    }\n    // docs:end:initialize\n    // docs:start:cast_vote\n    #[aztec(private)] // annotation to mark function as private and expose private context\n    fn cast_vote(candidate: Field) {\n        let secret = context.request_nullifier_secret_key(context.msg_sender()); // get secret key of caller of function\n        let nullifier = dep::std::hash::pedersen_hash([context.msg_sender().to_field(), secret.low, secret.high]); // compute nullifier with this secret key so others can't descrypt it\n        context.push_new_nullifier(nullifier, 0); // push nullifier\n        context.call_public_function(\n            context.this_address(),\n            FunctionSelector::from_signature(\"add_to_tally_public(Field)\"),\n            [candidate]\n        );\n    }\n    // docs:end:cast_vote\n\n    // docs:start:add_to_tally_public\n    #[aztec(public)]\n    internal fn add_to_tally_public(candidate: Field) {\n        assert(storage.voteEnded.read() == false, \"Vote has ended\"); // assert that vote has not ended\n        let new_tally = storage.tally.at(candidate).read() + 1;\n        storage.tally.at(candidate).write(new_tally);\n    }\n    // docs:end:add_to_tally_public\n\n    // docs:start:end_vote\n    #[aztec(public)] \n    fn end_vote() {\n        assert(storage.admin.read().eq(context.msg_sender()), \"Only admin can end votes\"); // assert that caller is admin\n        storage.voteEnded.write(true);\n    }\n    // docs:end:end_vote\n    // docs:start:get_vote\n    unconstrained fn get_vote(candidate: Field) -> pub Field {\n        storage.tally.at(candidate).read()\n    }\n    // docs:end:get_vote\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-contracts/contracts/easy_private_voting_contract/src/main.nr" } } }
