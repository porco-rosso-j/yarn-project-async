{ "noir_version": "0.24.0+78ef0134b82e76a73dadb6c7975def22290e3a1a", "name": "DelegatedOn", "functions": [{ "name": "private_set_value", "function_type": "Secret", "is_internal": false, "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "contract_deployment_data", "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "initialization_hash", "type": { "kind": "field" } }, { "name": "contract_class_id", "type": { "kind": "struct", "path": "aztec::protocol_types::contract_class_id::ContractClassId", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "contract_address_salt", "type": { "kind": "field" } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }] }, "visibility": "private" }, { "name": "new_value", "type": { "kind": "field" }, "visibility": "private" }, { "name": "owner", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "inputs": [{ "start": 0, "end": 41 }], "new_value": [{ "start": 41, "end": 42 }], "owner": [{ "start": 42, "end": 43 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "contract_deployment_data", "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "initialization_hash", "type": { "kind": "field" } }, { "name": "contract_class_id", "type": { "kind": "struct", "path": "aztec::protocol_types::contract_class_id::ContractClassId", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "contract_address_salt", "type": { "kind": "field" } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276] }, "bytecode": "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", "debug_symbols": "7VjtbuIwEHwX/0aR98PrXV7l1B+5O05CQrQq6KQT4t0vaWrHUKtRU0Fb1F8QsTuZjMfeCQe3uf/V7tf3251bHhyAW/44uN1Du+0vd/v2ce+WfuFW29/d53Hh/qw3K7dE5OPiRR0Ee64EhVwLXiq1SKrPxcgcxmqDGjIwhoQNrHZSf7dwgF+VOF2NeEBMxIPiu4nze4gTh4ROHEdw8U/Y4YLYckHseEFsrWEbpTU14Ql8tJjw0Qq7oI9PN7DqDSInF3iEKTtCkFSNVljM1yymnKC1sCNbjbq3ZHQE1FwcfA03UtLEh9dLAQEy4YAnkszYE+hvREKTTMKDTGg4qQp8q1JRBa+sSjcVNBMyK3Xp6dAH0umkP6fD16aD43Kh6OuuUcbsMC6OjeGkxvCFucvVuVu2ATFN7FZGP2YvmTiuWdMcCDTOARn8FW/nOSMk1rGoleriU6JsNnIAnTft9HY0FEs5KhY5qqohmM852hcbCFRmqWg35MQY09HS/36y48h/7ufM0CgRJp6TYgoNocgMzENOb+rnf35TK4ZdDEMUaKCqDirldKJC54m974OZfdX0EXLAkVDsAhkmQ1N/QyBOMpPp+TErTT0TTzXBnCac00RvbSLf1Cd8oOTlEPHMFX2TzGmqzikhn/fZ6NVIx7vu4m/7uG5/blb9Hzrd5f7fw/D1+B8=" }, { "name": "view_public_value", "function_type": "Unconstrained", "is_internal": false, "abi": { "parameters": [], "param_witnesses": {}, "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" }, "return_witnesses": [0] }, "bytecode": "H4sIAAAAAAAA/81UwU7DMAx12rTr6BBcOYAscUeZxAeUX+APiloQl1XqNgl+HrGAo75lFpeFaU+K7DhO7Lw4JiIy9IucJhjax4PICmy8G43o7hg8umXpD7GkYrYbheg1+GViuwabgTzD+leqPJ1bXtIhRxVwxwljxW/AoOfAR+xXw3oGtiza63m9h/VC2VMq8YKObxKerlT2Ik8F3KUR3R2HH54wFsM8xFtAHuUJ8sFSZpgXZxJ7JnqTLraraOoPqe80h7djyD/Es+BzJ/JKZLB7YO17LICX4FcrnOH/seCPfz9ln6loqlNOeC7eLeCvPvPff+VCuPVYb4axfeuf+7YzkJqN0kRplGtkYEM9V2xE+63Kgi2UiFYC2ObikprTIaVJ/0JOOjQy0HYr8kbk0zi2n/y+6voPHrYbHl75ZdiuujV9A7j5yHMWCAAA", "debug_symbols": "zZfNasMwEITfZc+m7I8qWX6V0oPaumAwTohNoRi/e2ziOIeEQExi5rYLM5rvIA2op3r3nbpq17RU9MRv71R89NTuUzPtbZcOHRXi2TIqm59pNBky+q3qkgpVN2TXatF4Vo/ORR3DDbEFnbVObJEGGT6zkcZD0QQomhyKJkLRCGPhCBaOYuEYFo7DwsFqZMGqZMHqZMEqZcFqZcVqZX1tK58ydIMM2yDDbZDxlKYLvGREvX89hGU5mvUillxnIg9HFOCIcjiiiEZkDEckcEQ3X7/6MLuM3VWDm1/hCSs8+QpPfNzj+DHPuPylQ5W+6nL6vo9r978/jcMR" }, { "name": "compute_note_hash_and_nullifier", "function_type": "Unconstrained", "is_internal": false, "abi": { "parameters": [{ "name": "contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "nonce", "type": { "kind": "field" }, "visibility": "private" }, { "name": "storage_slot", "type": { "kind": "field" }, "visibility": "private" }, { "name": "note_type_id", "type": { "kind": "field" }, "visibility": "private" }, { "name": "serialized_note", "type": { "kind": "array", "length": 0, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "contract_address": [{ "start": 0, "end": 1 }], "nonce": [{ "start": 1, "end": 2 }], "note_type_id": [{ "start": 3, "end": 4 }], "serialized_note": [], "storage_slot": [{ "start": 2, "end": 3 }] }, "return_type": { "abi_type": { "kind": "array", "length": 4, "type": { "kind": "field" } }, "visibility": "public" }, "return_witnesses": [4, 5, 6, 7] }, "bytecode": "H4sIAAAAAAAA/+2WwW7DIAyGTSAkhFTabTvmEVIthx33/g81DW9284e2p5pDpVpCgAn2Z8chDETk6F98aT1di65/S78+JmdDW2tLTvcknN2TcHpDTneDk/sgY+65lmNpQ2mfoh9h32LFs61fkXbngY6SS+uIDous88oNOt3bgU6/SR/2GKJ9DNsouTK1W9472/yA/IdG7L09e6uc/NWv1mIU2+qnh1wlGRueRWf07aQl8EnyjnT8TrskGGtNK/dMe12mO3tCtecE6/FG3Itx3AOwLDBXf73EwfLGvNU3zWyTPduW6Xg2sbhqvsB4apyrRnGubDeLrR+y/W/NkJ+xytMJ1jM8MzfInQO/alvnyPjiffEiw1SxZlhPoOuqWPAugc/X54dpQOoQLztO4Dzo7l3ILvILnT1C/YIMAAA=", "debug_symbols": "q1bKyU9OLMnMzytWsqqu1VEqSyzKTEzKSYVySyoLIMxaAA==" }, { "name": "constructor", "function_type": "Secret", "is_internal": false, "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "contract_deployment_data", "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "initialization_hash", "type": { "kind": "field" } }, { "name": "contract_class_id", "type": { "kind": "struct", "path": "aztec::protocol_types::contract_class_id::ContractClassId", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "contract_address_salt", "type": { "kind": "field" } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }] }, "visibility": "private" }], "param_witnesses": { "inputs": [{ "start": 0, "end": 41 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "contract_deployment_data", "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "initialization_hash", "type": { "kind": "field" } }, { "name": "contract_class_id", "type": { "kind": "struct", "path": "aztec::protocol_types::contract_class_id::ContractClassId", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "contract_address_salt", "type": { "kind": "field" } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259] }, "bytecode": "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", "debug_symbols": "tZA7CoQwFEX3cusU5uMMk60MFk+NEAhRTBAkZO9GFBvrVO8dOJziJrh5oGhnH6ATOIf+J4SF/Ikh0hqhGwbjx3Izw2SdgRZCZfbypGrbW5Xq+3vsT5M7Bi4qtmXFtqrVLrDRaql35ly/YNyX680H" }, { "name": "view_private_value", "function_type": "Unconstrained", "is_internal": false, "abi": { "parameters": [{ "name": "amount", "type": { "kind": "field" }, "visibility": "private" }, { "name": "owner", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "amount": [{ "start": 0, "end": 1 }], "owner": [{ "start": 1, "end": 2 }] }, "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" }, "return_witnesses": [2] }, "bytecode": "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5llO5nmazFNA5tmCzHMGmec1Mk8RmWdnMs/FZJ4KMs80Ms91ZJ5hZJ4DyDx3knnWJPMcTuZ5lMyTo3nwbwZ/Atlf1TT+7eEcbXv4t5tl+QJVx66O6pgX1D9CeN4V2tdV2Umt7KRWNv5d85wW8ASaJ2jE04XM05HMU0jmySfztCHzdCbzdCDztCfzJMk87cg8uWSePDJPJzJPisxTQOZpS+ZJEHiS4Aggk/m5kMnvfORBJuee2kAmvyfcFjK5x60dZCVQf8nku6IFkPVU0+0hK4Vp+V+uSxZCJn/bIQWZ3N/fATL5G6kdIZPxMraVtEc3yKQ9iiCT9ugOmbRHMWTSHiWQSXv0gEzaoydk0h7YFtIevSCT9iiDTNqjN2TSHtIWkW1Saf18qXMOrGPqJ6Gaxn4i57ywn1SqaewnfaBsyfqqaewn8h1V7Cf91TT2kwEwLf8PVNPYT6TO+LpK2+DrL20YQiZtXQGZvCaVkMlr1wcyeY37QiZ9oR9k0mf6QyZ9C+sofXAgZDKNx5sBUI9aNV31v3tkjjdYVgjPpbxCcAwk8bQl8xSQeVJknk5knjwyTy6Zpx2ZJ0nmaU/m6UDm6UzmaUPmySfzFJJ5OpJ5upB5clrQI+Nn2XaZ5nFZdqlWdmkLlt1DK7tHC5ZdrJVd3IJlF2llF7Vg2b6v+b7WUmX7vub7ml52v9jLHlWF57TkkdCehzDdDzz9Y/dUpd3Us6oq2m5fqF9c24220QfaZ4DWTimYj+cd+zhouwSUK9uW530MZf8axNsOlX/QDpUGS2ULtwMavdd7vZfP29d7nXp9//Ve7/XebF5//HXr9f3Xe73Xe7N5/fHXrdf3X+/1Xu/N5vXHX7de33+913u9N5vXH3/den3/9V7v9d5sXn/8dev1/dd7vdd7s3n98det1/df7/Ve783m9cdft17ff73Xe703m9cff916ff/1Xu/13mxehuNZVHZF7GVPG5nUyo4eCe15CNMVjtvCTT3rvo+H9ein1ScF87F/hg7qmIByZdtY58Aw7b3e673eG2q593pv4L3eGwTe673e673e673e673e673e673e673eGwTe673e673e673e673e673e673e673eGwTe673e673e673e673e673e673e673eGwTe673e673e673e673e673e673e673eGwTe673e673e673e673e673e673e673eGwTe673e673e673e673e673e673e673eGwTe673e673e673e673e673e673e673eGwTe673e673e673e673e673e673e673eGwTe673e673e673e673e673e673e673eGwSt2huV3TX+smuSWtnRI6E9D2G6q+O2cFTPqmgb3aAeFVp9UjAfX+9uDuqYgHJl2/Icjd7rzpuC+TngcdD30k3Zn9BTTubpSebpQebpQubpReYpJfN0J/MUkXk6k3l6k3nKyDwlZJ5iMk8nMk+CwJMMGo7zo2yQms6BbLCaLodsiJruDdlQNV0G2TA13Quy4Wq6FLIRaronZFVqugdkaTVdAlm1mi6GrEZNd4dspJougmyUmu4E2RpqujNko9V0F8jGqOkBkK2ppvtDtpaa7gfZ2mq6ErKxaroCsnFqOoRMXptBkOWq6cGQ5anpIZC1UdNDIWurpodB1k5ND4csX02PgKxATVdB1l5NpyFLqulqyArVdA1ksp+MhKyDmh4FWUc1vQZk8hqOhkxewzGQyWu4JmSyX6wFmXxWWBsy6TtjIZM+Jq9V1HaLyurny/q4T0k5uZCNM5Q31uCSaTyOyDphEO9xBMsK4bmUVwiOtUg8ncg8xWSeEjJPGZmnN5mnM5mniMzTncxTSubpRebpQubpQebpSeYpJ/PkaJ5oTCSv4TjIpB1xrCbr4mcKGYPJ8gWqjl0c1BHHpAHUFR8hTOO5RZyujcdTlQIPbt/BeflqHGc3pe7dwNM9fk8NjvGb4sHzhkXxe9KO6pn5aFYcNGxXKSsF87EPFDuoYwLKlW3LczR6rztv5NGvh+Hn2K4kRsmK3Hqqk5onejR2HMDzmz3i92SOS8UWHrweVhK/J+2onlXRduU999cg3uNdadDw9ZI6pGA+XtssddB2CShXti3P0ei97rx4LMFzxLJcdxKjZCVuPdVJzRM9Gju+4PXbsvg9meNdqYUHr7/1it+TdlTPzPFOzi3lBvEe78qDhq+X1CEF8/FaarmDtktAubJteY5G73XnxWMJXmOT5XqQGCXDa4NyXUfeN6LrVXepSkTblWNjdM3qKFg+D/6XZe7pVb+Ne0vr6+xqDCnlyqOpY0gHn7Wtx5D4WdvVZ1sH9axydV4k2kbPoOHrhfcPynwsv6eDtksEq5+nCOE5Gr3XnTfylGhWPH9UQmKU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", "debug_symbols": "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sEKlwQqVBitUGqxQabBCpcEKlQYrVBqsUGmwQqXBCpUGK1QarFBpsEKlwQqVBitUGqxQabBSpcFKlQYrVRqsVGmw8iFys6ZKg5UqDVaqNFip0mClSoOVKg1WqjRYqdJgpUqDlSoNVqo0WKnSYKVKg5WvGyzLrL8es9z9d6/z4+DBg68bp99y0OhBpweDHkx6sOjBpgeHHqTLcbqcoMsJupygywm6nKDLCbqcoMsJupygywm6nKTLSbqcpMtJupyky0m6nKTLSbqcpMtJupyiyym6nKLLKbqcosspupyiyym6nKLLKbqcpstpupymy2m6nKbLabqcpstpupymy2m6nKHLGbqcocsZupyhyxm6nKHLGbqcocsZupyly1m6nKXLWbqcpctZupyly1m6nKXLWbqco8s5upyjyzm6nKPLObqco8s5upyjyzm4nHo86EGjB50eDHow6cGiB5seHHpw6UG6HKPLMboco8sxuhyjyzG6HKPLMbocashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+asgHDTke0JCfB40edHow6MGkB4sebHpw6MGlB+lyjC7H6HKMLsfocowux+hyjC7H6HKMLsfocpwux+lynC7H6XKcLsfpcpwux+lynC7H6XKCLifocoIuJ+hygi4n6HKCLifocoIuJ+hyki4n6XKSLifpcpIuJ+lyki4n6XKSLifpcooup+hyii6n6HKKLqfocooup+hyii6n6HKaLqfpcpoup+lymi6n6XKaLqfpcpoup+lyhi5n6HKGLmfocoYuZ+hyhi5n6HKGLmfocpYuZ+lyli5n6XKWLmfpcpYuZ+lyli5n6XKOLufoco4u5+hyji7n6HKOLufoco4uhxqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmgIecDGvLzoNGDTg8GPZj0YNGDTQ8OPbj0IF2O0eUYXY7R5RhdjtHlGF2O0eUYXY7R5RhdjtPlOF2O0+U4XY7T5ThdjtPlOF2O0+U4XU7Q5QRdTtDlBF1O0OUEXU7Q5QRdTtDlBF1O0uUkXU7S5SRdTtLlJF1O0uUkXU7S5SRdTtHlFF1O0eUUXU7R5RRdTtHlFF1O0eUUXU7T5TRdTtPlNF1O0+U0XU7T5TRdTtPlNF3O0OUMXc7Q5QxdztDlDF3O0OUMXc7Q5QxdztLlLF3O0uUsXc7S5SxdztLlLF3O0uUsXc7R5RxdztHlHF3O0eUcXc7R5RxdztHlUEM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQ7TtDvv1xsB798qDRg04PBj2Y9GDRgw0P5s//cHi9PGj0oNODQQ++/MMRsf7Xg5H++Dr4/Muir4NFDzY9OPTg0oMHD76G2d9y0OhBpweDHqTLKbqcosspupyiyym6nKbLabqcpstpupymy2m6nKbLabqcpstpupyhyxm6nKHLGbqcocsZupyhyxm6nKHLGbqcpctZupyly1m6nKXLWbqcpctZupyly1m6nKPLObqco8s5upyjyzm6nKPLObqco8s5uBx/POhBowedHgx6MOnBogebHhx6cOlBuhyjyzG6HKPLMboco8sxuhyjyzG6HKPLMbocp8txuhyny3G6HKfLcbocp8txuhyny3G6nKDLCbqcoMsJupygywm6nKDLCbqcoMsJupyky0m6nKTLSbocashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0MOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0MeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR805HpAQ34eNHrQ6cGgB5MeLHqw6cGhB5cepMsxuhyjyzG6HKPLMboco8sxuhyjyzG6HKPLcbocp8txuhyny3G6HKfLcbocp8txuhynywm6nKDLCbqcoMsJupygywm6nKDLCbqcoMtJupyky0m6nKTLSbqcpMtJupyky0m6nKTLKbqcosspupyiyym6nKLLKbqcosspupyiy2m6nKbLabqcpstpupymy2m6nKbLabqcpssZupyhyxm6nKHLGbqcocsZupyhyxm6nKHLWbqcpctZupyly1m6nKXLWbqcpctZupylyzm6nKPLObqco8s5upyjyzm6nKPLObocashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2ashGDdmoIRs1ZKOGbNSQjRqyUUM2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6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LvHfLcfzHef5wyec3gu4LmE5wqea3hu4LmF5+BeDO7F4F4M7sXgXgzuxeBeDO7F4F4M7sXgXhzuxeFeHO7F4V4c7sXhXhzuxeFeHO7F4V4C7iXgXgLuJeBeAu4l4F4C7iXgXgLuJeBeEu4l4V4S7iXhXhLuJeFeEu4l4V4S7iXhXgrupeBeCu6l4F4K7qXgXgrupeBeCu6l4F4a7qXhXhrupeFeGu6l4V4a7qXhXhrupeFeBu5l4F4G7mXgXgbuZeBeBu5l4F4G7mXgXhbuZeFeFu5l4V4W7mXhXhbuZeFeFu5l4V4O7uXgXg7u5eBeDu7l4F4O7uXgXg7uBfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfpuQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7wb03YC+G9B3A/puQN8N6LsBfTeg7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQt9N6LsJfTeh7yb03YS+m9B3E/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeg7xb03YK+W9B3C/puQd8t6LsFfbeg7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/puQ99t6LsNfbeh7zb03Ya+29B3G/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeY786D+e7znMFzDs+9/N9lHjV/Pff8P/fVuWPnXjvmbzhn8JzDc/H63NbXue1X5xKeK3iu4bmB5xaeO3bOH/CcwXMOz8G9ONyLw7043IvDvTjci8O9BNxLwL0E3EvAvQTcS8C9BNxLwL28dswxtx/nzP3VuWPnXjvmbzhn8JzDcwHPJTxX8FzDcwPPwb0k3EvBvRTcS8G9FNxLwb0U3EvBvRTcS8G9FNxLw7003EvDvTTcS3+zl/avcx2vzhU81/DcwHMLzx07Nw94zuA5h+cCnoN7GbiXgXsZuJeBexm4l4V7WbiXhXtZuJeFe1m4l4V7WbiXhXtZuJf75o/f9te5m1fnXv/vWfP1vJqXz2t4buC5hecOnbPXzvcbzhk85/BcwHMJzxU81/DcwHMLz8G9GNyLwb0Y3IvBvRjci8G9GNyLwb0Y3IvBvTjcyzf+2Y8vf+lHvzrn8FzAcwnPFTzX8NzAcwvPHTv3jX/+/BzcS8C9BNxLwL0E3EvAvQTcS8C9BNxLwr0k3EvCvSTcS8K9JNxLwr1844rt+3Uu5tW51/+7zK9/PT/78lzCcwXPNTw38NzCc8fOfeN8Pz9n8JzDc3AvDffScC8N99JwLw330nAvA/cycC8D9zJwLwP3MnAvA/cycC/D9uLf/P37z+55/+bv339+7ps//9V9nZt/93NBfyL/peoTD+lPPGQ+8ZD9xEPuAw/5RjP+4IfYJx7in3hIfOIhn/ji7RNfvH3ii7dPfPH2iS/ePvHF+ye+eP/EF++f+OL9E1+8f+KL90988f6JL94/8cX77//i03/8jHLGff2u8fWEe/cT4vH2J/z+Dz3zh4RnzYsn+NufEG9/Qv6RfxxePqHe/oR++xPm7U/Ytz/h3v2E/AO+6f7x95y5r55gb3+Cv/0J8fYn5NufUG9/Qr/9CfP2J+zbn3DvfkK9/Zuut3/T9fZvut7+Tdfbv+l6+zddb/+m6+3fdL39m663f9P99m+63/5N99u/6X77N/3Nr0P15tcT7kU/6t/8OtTPzy08d+zcN78O9fNz3/w6lP/698V5r8598+tQv3YG86oz8O9+Heqn5xKeK3iu4bmB5xaeO3bum583//k5g+fgXhbuZeFeFu5l4V4W7mXhXhbu5eBeDu7l4F4O7uXgXg7u5eBeDu7l4F6O7SUeD3jO4DmH5wKeS3iu4LmG5waeW3gO7sXgXoz9HE2Yw3MBzyU8V/Bcw3MDzy08x37uKvwBz8G9ONyLw7043IvDvTjci8O9ONyLw70E3EvAvQTcS8C9BNxLwL0E3EvAvQTcS8C9JNxLwr0k3EvCvSTcS8I/7gn/uH/3z+n4Seca3/1zOn567vUfB//1r0Oev8j6l98hUfGNX/+RT8i3P6He/oR++xPm7U/Ytz/h3v2Eb/z6j3yCvf0Jb/+m++3fdL/9m+63f9P99m+63/5N99u/6X77Nz1v/6bn7d/0vP2bnrd/0/P2b3re/k3P27/pefs3PW//puft3/T+Ad/03/wZz1h7+xP87U/4A77pv/kznrH59ifU25/Qf+Qfh5dPmLc/Yd/+hHv3E+7x9ifY25/w9j9P39v/PH1v//P0vf3P0/f2P0/f2/88fW//8/S9+8/T+Xi8/Qn29if4258Qb39Cvv0J9fYn9NufMG9/wr79CW//pu3t37S9/Zu2t3/T9vZv2t7+Tdvbv2l7+zdtb/+m7e3ftL39m/a3f9P+9m/a3/5N+9u/6W9+LsHz65+X4p3/9gk/zg08t/DcsXPf/FzCz88ZPPd6E/H4+jnx8Ht17ps/0vv1E/rxeLw6l/BcwXMNzw08t/DcsXPf/FzCz88ZPOfwHNxLwr0k3EvCvSTcS8K9JNxLwb0U3EvBvRTcS8G9FNxLwb0U3EvBvRTcS8O9NNxLw7003EvDvTTcS8O9NNxLw7003MvAvQzcy8C9fPOrufFrH/eEglfnXu/l+av0X8/bl88reK7huYHnFp47du6bX6f8+TmD5xyeC3gO7mXhXhbuZeFeFu5l4V4O7uXgXg7u5eBeDu7l4F4O7uXgXg7u5dhe6vGA5wyec3gu4LmE5wqea3hu4LmF5+BeDO7F4F4M7sXgXr4x8edfP3/9dc/uq3Ov95K/+tLzbzFenWt4buC5heeOnfvGhX9+zuA5h+cCnkt4Du7F4V4c7sXhXhzuJeBeAu4l4F4C7iXgXgLuJeBeAu4l4F4C7iXhXhLuJeFeEu4l4V4S7iXhXhLuJeFeEu7lG999/vXCj3PlL88ZPOfwXMBzCc8VPNfw3MJzx869dtN+/v3WX8/1pr06F/BcwnMFzzU8N/DcwnPHzr12099wzuA5uJeBexm4l4F7GbiXgXsZuJeBe1m4l4V7ee2m3vPj33/mF7/+/Wb317mA5xKeK3iu4bmB5xaeO3butZv+hnMGz8G9HNzLwb0c3MvBvRzcy8G9HNtLPx7wnMFzDs8FPJfwXMFzDc8NPLfwHNyLwb0Y3IvBvRjci8G9GNyLwb0Y3IvBvRjci8O9ONyLw7043IvDvTjci8O9ONyLw7043EvAvQTcS8C9BNxLwL0E3EvAvQTcS8C9BNxLwr0k3EvCvSTcS8K9JNxLwr0k3EvCvSTcS8G9FNxLwb0U3EvBvRTcS8G9FNxLwb0U3EvDvTTcS8O9NNxLw7003EvDvTTcS8O9NNzLwL0M3MvAvQzcy8C9DNzLwL0M3MvAvQzcy8K9LNwL9N2GvtvQdxv6bkPfbei7DX23oe829N2GvtvQdxv6bkPfbei7DX23oe829N2GvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfnW9898q/zrW9Otfw3MBzC88dO/eN7/78nMFz/vNz++pcwHMJz73cSzz8x7l4xMv/fg3PDTy38Nyxc6999zecM3jOX5+rx9e5mVfnAp4beG7RuX3tmHHzde7GXp1zeC7guYTnip2zb/Zy9vW/592rcw7PBTyXPztn9vK/3+udxfzo5iPt8ercwnOvv/eo/tvnXvvZbzhn8NzrP34Zv56renUu4LmE5wqea3hu4LnXe8n78ddLUa//OBw799rPfsO513vJ3V/PvfqOwuG5gOcSnit4ruG5+fm5V/dZLDx37NxrP4v+9T57/pLrq3MGzzk893ov/dVBP8/9u+/vP/4Thc3yx0fw/D/763e2/fUp+ZGn1Eee0h95ynzkKfuRp9wnnlKPjzzFPvIU/8hTPvLt10e+/frIt18f+fbrI99+feTbr498+/2Rb78/8u33R779/si33x/59vsj335/5Nvvj3z7/ZFvf37/9/L8m4C//r7lj3/zjPp6hn/gGb9/XxU//seq6JfP6A88Yz7wjP3AM+79z9j/7J9RfpwzeM7huYDnXt/M4z/++dwx3X/7f8P7+neYnPvX7+qP+XpGfeAZ/YFnzAeesR94xr3/Gd/8Osof+wz7/c/4+rcg3fbLZ/gHnhEfeEZ+4Bn1gWf0B54xH3jG7//O7fH1D6uzf/uLi//2KfeBp9zj8ZGn2Eee4h95SnzkKfmRp/xnv/of5xqeG3hu4blj5+wBzxk85/BcwHMJz8G9GNyLwb0Y3IvBvTjci8O9ONyLw7043IvDvXzzK9HPPyf+OHeRf/v2++mPcdw3v2z9Bz9kP/GQ+8BDvvnV8z/4IfaJh/gnHhL/yYf8OJfwXMFzDc8NPLff/NDV1w9h3MWrc4d+WOu++UX8n58zeM7huYDnEp4reK7huYHnFp6Deym4l4J7KbiXgnspuJeCeym4l4J7KbiXgntpuJeGe2m4l4Z7abiXhntpuJeGe2m4l4Z7GbiXgXsZuJeBexm4l4F7GbiXgXsZuJeBe1m4l4V7WbiXhXtZuJeFe1m4l4V7WbiXhXs5uJeDezm4l4N7ObiXg3s5uJeDezm4l0N72cfjAc8ZPOfwXMBzCc8VPNfw3MBzC8/BvRjci8G9GNyLwb0Y3IvBvRjci8G9GNyLwb043IvDvTjci8O9ONyLw7043IvDvTjci8O9BNxLwL0E3EvAvQTcS8C9BNxLwL0E3EvAvSTcS8K9JNxLwr0k3EvCvSTcS8K9JNxLwr0U3EvBvRTcS8G9FNxLwb0U3EvBvRTcS8G9NNxLw7003EvDvTTcS8O9NNxLw7003EvDvQzcy8C9DNzLwL0M3MvAvQzcy8C9DNzLwL0s3MvCvSzcy8K9LNzLwr0s3MvCvSzcy8K9HNzLwb0c3MvBvRzcy8G9HNzLwb0c3Av0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg0xp0Wru3/wOwns/wDzwjPvCM/MAz6gPP+AP+QV75I3GuypfPmA884w/4B3nl4+sZ9fIZ9/Zn+OPxgWfYB57hH3hGfOAZ+YFnvP0f2Pd8Rn/gGfOBZ+wHnnHvf4Y9PvAM+8Az/APPiA88Iz/wjA985/aB79w+8J3bB75z+8B37h/4zv0D37l/4Dv3D3zn/oHv3D/wnfsHvnP/wHfuH/jO/QPfeXzgO48PfOfxge88PvCdxwe+8/jAdx4f+M7jA995fOA7jw985/mB7/z1r6/+/FiyYy9X/PzFjR//jZ6/fvAf/5VRz3MNzw08t/DcsXOvf3X1N5wzeM7huYDnEp6Deym4l9e/uvr8xamvf5/DTbw6t/DcsXOvf3X1N5wzeM7/s+ee/+F//Pm//8Of/99//Pt/fh55/sd/+Z//7f/8n3/5Xw==" }, { "name": "public_set_value", "function_type": "Open", "is_internal": false, "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "public_global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] }, "visibility": "private" }, { "name": "new_value", "type": { "kind": "field" }, "visibility": "private" }], "param_witnesses": { "inputs": [{ "start": 0, "end": 39 }], "new_value": [{ "start": 39, "end": 40 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::public_circuit_public_inputs::PublicCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "is_contract_deployment", "type": { "kind": "boolean" } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "contract_storage_update_requests", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_update_request::StorageUpdateRequest", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "new_value", "type": { "kind": "field" } }] } } }, { "name": "contract_storage_reads", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_read::StorageRead", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "current_value", "type": { "kind": "field" } }] } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "contract_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "prover_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] }, "visibility": "public" }, "return_witnesses": [40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233] }, "bytecode": "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", "debug_symbols": "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ModrmcO1zOFa5nAtc7iWOVzLHK5lDtcyh2uZw7XM4VrmcC1zuJY5XMscrmUO1zKHa5nDtczhWuZwLXO4ljlcyxyuZQ43MocbmcONzOFG5nAjc7iROdzIHG5kDjcyhxuZw43M4UbmcCNzuJE53MgcbmQONzKHG5nDjczhRuZwI3O4kTncyBxuZA43MocbmcONzOFG5nAjc7iROdzIHG5kDjcyhxuZw43M4UbmcCNzuJE53MgcbmQONzKHG5nDjczhRuZwI3O4kTncyBxuZA43MocbmcONzOFG5nAjc7iROdzIHG5kDjcyhxuZw43M4UbmcCNzuJE53MgcbmQONzKHG5nDjczhRuZwI3O4kTncyBxuZA43MocbmcONzOFG5nAjc7iROdzIHG5kDjcyhxuZw43M4UbmcCNzuJE53MgcbmQONzKHG5nDjczhRuZwI3O4kTncyBxuZA43MocbmcONzOFG5nArc7iVOdzKHG5lDrcyh1uZw63M4VbmcCtzuJU53MocbmUOtzKHW5nDrczhVuZwK3O4lTncyhxuZQ63ModbmcOtzOFW5nArc7iVOdzKHG5lDrcyh1uZw63M4VbmcCtzuJU53MocbmUOtzKHW5nDrczhVuZwK3O4lTncyhxuZQ63ModbmcOtzOFW5nArc7iVOdzKHG5lDrcyh1uZw63M4VbmcCtzuJU53MocbmUOtzKHW5nDrczhVuZwK3O4lTncyhxuZQ63ModbmcOtzOFW5nArc7iVOdzKHG5lDrcyh1uZw63M4VbmcCtzuJU53MocbmUOtzKHW5nDrczhVuZwK3O4lTncyhxuZQ63ModbmcOtzOFW5nArc7iVOdzKHG5lDmcvGcS9j5h+xPUjoR85+pHUj5R+pPUjox/Ru296903vvundN737pnff9O6b3n3Tu296903vvuvdd737rnff9e673n3Xu+96913vvuvdd737oXc/9O6H3v3Qux9690PvfujdD737oXc/9O4fvftH7/7Ru3/07h+9+0fv/tG7f/TuH737R+9+6t1Pvfupdz/17qfe/dS7n3r3U+9+6t1Pvfuld7/07pfe/dK7X3r3S+9+6d0vvfuld7/07rfe/da733r3W+9+691vvfutd7/17rfe/da7P3r3R+/+6N0fvfujd3/07o/e/dG7P3r3R+/+6t1fvfurd3/17q/e/dW7v3r3V+/+6t3XWZ/prM901mc66zOd9b0/9epHUj9S+pHWj4x+RO++zvpMZ32msz7TWZ/prM901mc66zOd9ZnO+kxnfaazPtNZn+msz3TWZzrrM531mc76TGd9prM+01mf6azPdNZnOusznfWZzvpMZ32msz7TWZ/prM901mc66zOd9ZnO+kxnfaazPtNZn+msz3TWZzrrM531mc76TGd9prM+01mf6azPdNZnOusznfWZzvpMZ32msz7TWZ/prM901mc66zOd9ZnO+kxnfaazPtNZn+msz3TWZzrrM531mc76TGd9prM+01mf6azPdNZnOusznfWZzvpMZ32msz7TWZ/prM901mc66zOd9ZnO+kxnfaazPtNZn+msz3TWZzrrM531mc76TGd9rrM+11mf66zPddbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11mf66zPddbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11mf66zPddbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11mf66zPddbnOutznfW5zvpcZ32usz7XWZ/rrM911uc663Od9bnO+lxnfa6zPtdZn+usz3XW5zrrc531uc76XGd9rrM+11mf66zPddYXOusLnfWFzvpCZ32hs77QWV/orC901hc66wud9YXO+kJnfaGzvtBZX+isL3TWFzrrC531hc76Qmd9obO+0Flf6KwvdNYXOusLnfWFzvpCZ32hs77QWV/orC901hc66wud9YXO+kJnfaGzvtBZX+isL3TWFzrrC531hc76Qmd9obO+0Flf6KwvdNYXOusLnfWFzvpCZ32hs77QWV/orC901hc66wud9YXO+kJnfaGzvtBZX+isL3TWFzrrC531hc76Qmd9obO+0Flf6KwvdNYXOusLnfWFzvpCZ32hs77QWV/orC901hc66wud9YXO+kJnfaGzvtBZX+isL3TWFzrrC531hc76Qmd9obO+0Flf6KwvdNYXOusLnfWFzvpCZ31HZ31HZ31HZ31HZ31HZ31HZ31HZ31HZ31HZ31HZ31H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" }], "events": [], "file_map": { "3": { "source": "struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    // TODO: change this to return a u64 as Noir now\n    // uses u64 for indexing\n    len: Field,\n    empty_value: T,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0, empty_value: initial_value }\n    }\n\n    pub fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: Field) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> Field {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> Field {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + (i as Field)] = vec.get_unchecked(i as Field);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = self.empty_value;\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if (!exceeded_len) {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}", "path": "std/collections/bounded_vec.nr" }, "31": { "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n", "path": "std/option.nr" }, "44": { "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint};\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    log: [Field; N]\n) {\n    let _ = oracle::logs::emit_encrypted_log(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        encryption_pub_key,\n        log\n    );\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(context: &mut PublicContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(context: &mut PrivateContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/log.nr" }, "48": { "source": "use dep::std::option::Option;\nuse dep::protocol_types::{\n    constants::{\n        MAX_READ_REQUESTS_PER_CALL,\n        GET_NOTE_ORACLE_RETURN_LENGTH,\n        GET_NOTES_ORACLE_RETURN_LENGTH,\n        MAX_NOTES_PER_PAGE,\n        VIEW_NOTE_ORACLE_RETURN_LENGTH,\n    },\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption,\n};\nuse crate::oracle;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address));\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(fields: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let isEqual = fields[select.field_index] == select.value;\n        let isLt = fields[select.field_index].lt(select.value);\n\n        if (select.comparator == Comparator.EQ) {\n            assert(isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(isLt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(isLt | isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!isLt & !isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!isLt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index] as u120 < fields_1[sort.field_index] as u120;\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [Field; N], [u3; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (num_selects, select_by, select_values, select_comparators, sort_by, sort_order)\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_getter.nr" }, "49": { "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_insertion, compute_note_hash_for_consumption}\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    broadcast: bool\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    // As `is_transient` is true, this will compute the inner note hsah\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    // TODO: Strong typing required because of https://github.com/noir-lang/noir/issues/4088\n    let serialized_note: [Field; N] = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash\n    )\n        == 0\n    );\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        Note::broadcast(*note, context, storage_slot);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(context: &mut PrivateContext, note: Note) where Note: NoteInterface<N> {\n    let mut nullifier = 0;\n    let mut consumed_note_hash: Field = 0;\n    nullifier = note.compute_nullifier(context);\n\n    // We also need the note hash corresponding to the \"nullifier\"\n    let header = note.get_header();\n    // `consumed_note_hash` is used to inform the kernel which pending note hash\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // note hash) in which case `consumed_note_hash` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note hash computed in `compute_nullifier`?\n        consumed_note_hash = compute_note_hash_for_consumption(note);\n    }\n    assert(notify_nullified_note(nullifier, consumed_note_hash) == 0);\n\n    context.push_new_nullifier(nullifier, consumed_note_hash)\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr" }, "50": { "source": "use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__SILOED_NOTE_HASH},\n    hash::pedersen_hash, utils::arr_copy_slice\n};\n\nfn compute_siloed_hash(contract_address: AztecAddress, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address.to_field(), inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_NOTE_HASH)\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\nfn compute_inner_note_hash<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([header.storage_slot, note_hash], 0)\n}\n\nfn compute_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let inner_note_hash = compute_inner_note_hash(note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let siloed_note_hash = compute_siloed_note_hash(note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n    let inner_nullifier = note_with_header.compute_nullifier(context);\n\n    let input = [header.contract_address.to_field(), inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_insertion<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    compute_inner_note_hash(note)\n}\n\npub fn compute_note_hash_for_consumption<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note)\n    }\n}\n\npub fn compute_note_hash_and_nullifier<T, N, S>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    T::set_header((&mut note), note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = note.compute_nullifier_without_context();\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/note/utils.nr" }, "58": { "source": "use crate::{\n    context::inputs::PublicContextInputs, messaging::process_l1_to_l2_message,\n    oracle::{arguments, public_call::call_public_function_internal}\n};\nuse dep::protocol_types::{\n    abis::{\n    global_variables::GlobalVariables, function_selector::FunctionSelector,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_READ_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::hash_args, header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader\n};\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<StorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_reads: BoundedVec<StorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack_hashes: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n    prover_address: AztecAddress,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = StorageRead::empty();\n        let empty_storage_update = StorageUpdateRequest::empty();\n        PublicContext {\n            inputs,\n            side_effect_counter: inputs.call_context.start_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(0),\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_reads: BoundedVec::new(empty_storage_read),\n            public_call_stack_hashes: BoundedVec::new(0),\n            new_note_hashes: BoundedVec::new(SideEffect::empty()),\n            new_nullifiers: BoundedVec::new(SideEffectLinkedToNoteHash::empty()),\n            new_l2_to_l1_msgs: BoundedVec::new(L2ToL1Message::empty()),\n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n            historical_header: inputs.historical_header,\n            prover_address: AztecAddress::zero() // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn coinbase(self) -> EthAddress {\n        self.inputs.public_global_variables.coinbase\n    }\n\n    pub fn fee_recipient(self) -> AztecAddress {\n        self.inputs.public_global_variables.fee_recipient\n    }\n\n    pub fn finish(self) -> PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_reads: self.contract_storage_reads.storage,\n            return_values: self.return_values.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash,\n            unencrypted_log_preimages_length,\n            historical_header: self.inputs.historical_header,\n            prover_address: self.prover_address\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash {\n            value: nullifier,\n            note_hash: 0, // cannot nullify pending notes in public context\n            counter: self.side_effect_counter\n        };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field, sender: EthAddress) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            this,\n            sender,\n            self.chain_id(),\n            self.version(),\n            msg_key,\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(contract_address, function_selector, 0, false, true)\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr" }, "60": { "source": "use crate::{\n    context::inputs::PrivateContextInputs, key::nullifier_key::validate_nullifier_key_against_address,\n    messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair},\n    debug_log::debug_log\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n    nullifier_key_validation_request::NullifierKeyValidationRequest,\n    private_call_stack_item::PrivateCallStackItem,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader\n};\nuse dep::std::option::Option;\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<SideEffect, MAX_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let side_effect_counter = inputs.call_context.start_side_effect_counter;\n        let mut min_revertible_side_effect_counter = 0;\n        // Note. The side effect counter is 2 when this is the initial call\n        if (side_effect_counter == 2) {\n            min_revertible_side_effect_counter = side_effect_counter;\n        }\n        PrivateContext {\n            inputs,\n            side_effect_counter,\n            min_revertible_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(0),\n            read_requests: BoundedVec::new(SideEffect::empty()),\n            nullifier_key_validation_requests: BoundedVec::new(NullifierKeyValidationRequest::empty()),\n            new_note_hashes: BoundedVec::new(SideEffect::empty()),\n            new_nullifiers: BoundedVec::new(SideEffectLinkedToNoteHash::empty()),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(0),\n            public_call_stack_hashes: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(L2ToL1Message::empty()),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            // TODO(fees): start this from 0 and test the following:\n            // - in the private circuit init that it gets set correctly\n            // - in the private circuit inner that it remains 0\n            // I've had to initialize the counter here so that it would work for contract deployments\n            // the above checks should be doable after we figure out fee payments for contract deployments\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            read_requests: self.read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_min_revertible_side_effect_counter(&mut self) {\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        let side_effect = SideEffect { value: read_request, counter: self.side_effect_counter };\n        self.read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            msg_key,\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_note_hashes: [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero()\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr" }, "66": { "source": "use dep::std::option::Option;\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    utils::arr_copy_slice,\n};\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u3; N],\n    _sort_by: [u8; N],\n    _sort_order: [u2; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u2,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u3; N],\n    sort_by: [u8; N],\n    sort_order: [u2; N],\n    limit: u32,\n    offset: u32,\n    status: u2,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u3; M],\n    sort_by: [u8; M],\n    sort_order: [u2; M],\n    limit: u32,\n    offset: u32,\n    status: u2,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i as u32 < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: Field = 2; // num_notes & contract_address.\n            let extra_preimage_length: Field = 2; // nonce & is_transient.\n            let read_offset: Field = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n            Note::set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr" }, "69": { "source": "use dep::protocol_types::{address::{AztecAddress, PartialAddress, PublicKeysHash}, grumpkin_point::GrumpkinPoint};\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: AztecAddress) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: AztecAddress) -> [Field; 3] {\n    get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: AztecAddress) -> GrumpkinPoint {\n    let result = get_public_key_and_partial_address_internal(address);\n    let pub_key = GrumpkinPoint::new(result[0], result[1]);\n    let partial_address = PartialAddress::from_field(result[2]);\n\n    let calculated_address = AztecAddress::compute(PublicKeysHash::compute(pub_key), partial_address);\n    assert(calculated_address.eq(address));\n\n    pub_key\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_public_key.nr" }, "71": { "source": "use dep::protocol_types::traits::{Deserialize, Serialize};\n\n#[oracle(storageRead)]\nfn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_oracle_wrapper(storage_slot)\n}\n\n#[oracle(storageWrite)]\nfn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/storage.nr" }, "73": { "source": "use dep::protocol_types::{address::AztecAddress, constants::NUM_FIELDS_PER_SHA256, grumpkin_point::GrumpkinPoint};\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _encryption_pub_key: GrumpkinPoint,\n    _preimage: [Field; N]\n) -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    preimage: [Field; N]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [\n        emit_encrypted_log_oracle(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            encryption_pub_key,\n            preimage\n        ), 0\n    ]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(\n    _contract_address: AztecAddress,\n    _event_selector: Field,\n    _message: T\n) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    message: T\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/logs.nr" }, "75": { "source": "#[oracle(getRandomField)]\nfn rand_oracle() -> Field {}\n\nunconstrained pub fn rand() -> Field {\n    rand_oracle()\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/rand.nr" }, "85": { "source": "mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod avm;\n\nuse private_context::PrivateContext;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none() }\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/context.nr" }, "97": { "source": "use crate::context::{Context};\nuse crate::oracle::storage::storage_read;\nuse crate::oracle::storage::storage_write;\nuse dep::std::option::Option;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_state_struct\nstruct PublicState<T> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_state_struct\n\nimpl<T> Storage<T> for PublicState<T> {}\n\nimpl<T> PublicState<T> {\n    // docs:start:public_state_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicState { context, storage_slot }\n    }\n    // docs:end:public_state_struct_new\n\n    // docs:start:public_state_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"Public state writes only supported in public functions\");\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n    // docs:end:public_state_struct_read\n\n    // docs:start:public_state_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"Public state writes only supported in public functions\");\n        let fields = T::serialize(value);\n        storage_write(self.storage_slot, fields);\n    }\n    // docs:end:public_state_struct_write\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/public_state.nr" }, "101": { "source": "use dep::std::option::Option;\nuse dep::protocol_types::{\n    constants::{MAX_NOTES_PER_PAGE, MAX_READ_REQUESTS_PER_CALL},\n    abis::side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader, note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct Set<Note> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T> Storage<T> for Set<T> {}\n\nimpl<Note> Set<Note> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Set { context, storage_slot }\n    }\n    // docs:end:new\n    // docs:start:insert\n    pub fn insert<N>(self, note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        create_note(\n            self.context.private.unwrap(),\n            self.storage_slot,\n            note,\n            broadcast\n        );\n    }\n    // docs:end:insert\n\n    // docs:start:insert_from_public\n    pub fn insert_from_public<N>(self, note: &mut Note) where Note: NoteInterface<N> {\n        create_note_hash_from_public(self.context.public.unwrap(), self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n\n    // DEPRECATED\n    fn assert_contains_and_remove(_self: Self, _note: &mut Note, _nonce: Field) {\n        assert(\n            false, \"`assert_contains_and_remove` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use Set.get_notes() and Set.remove() in your contract to verify and remove a note.\"\n        );\n    }\n\n    // DEPRECATED\n    fn assert_contains_and_remove_publicly_created(_self: Self, _note: &mut Note) {\n        assert(\n            false, \"`assert_contains_and_remove_publicly_created` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use Set.get_notes() and Set.remove() in your contract to verify and remove a note.\"\n        );\n    }\n\n    // docs:start:remove\n    pub fn remove<N>(self, note: Note) where Note: NoteInterface<N> {\n        let context = self.context.private.unwrap();\n        let note_hash = compute_note_hash_for_consumption(note);\n        let has_been_read = context.read_requests.any(|r: SideEffect| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note(context, note);\n    }\n    // docs:end:remove\n\n    // docs:start:get_notes\n    pub fn get_notes<N, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, FILTER_ARGS>\n    ) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n        let storage_slot = self.storage_slot;\n        let opt_notes = get_notes(self.context.private.unwrap(), storage_slot, options);\n        opt_notes\n    }\n    // docs:end:get_notes\n\n    // docs:start:view_notes\n    unconstrained pub fn view_notes<N>(\n        self,\n        options: NoteViewerOptions<Note, N>\n    ) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/set.nr" }, "106": { "source": "use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/aztec/src/hasher.nr" }, "174": { "source": "global ARGS_LENGTH: Field = 16;\nglobal RETURN_VALUES_LENGTH: Field = 4;\n\n/**\n * Convention for constant array lengths are mainly divided in 2 classes:\n *  - FUNCTION CALL\n *  - TRANSACTION\n *\n * Agreed convention is to use MAX_XXX_PER_CALL resp. MAX_XXX_PER_TX, where XXX denotes a type of element such as\n * commitment, or nullifier, e.g.,:\n *  - MAX_NEW_NULLIFIERS_PER_CALL\n *  - MAX_NEW_NOTE_HASHES_PER_TX\n *\n * In the kernel circuits, we accumulate elements such as note hashes and the nullifiers from all functions calls in a\n * transaction. Therefore, we always must have:\n * MAX_XXX_PER_TX  MAX_XXX_PER_CALL\n *\n * For instance:\n * MAX_NEW_NOTE_HASHES_PER_TX  MAX_NEW_NOTE_HASHES_PER_CALL\n * MAX_NEW_NULLIFIERS_PER_TX  MAX_NEW_NULLIFIERS_PER_CALL\n *\n */\n\n// docs:start:constants\n// \"PER CALL\" CONSTANTS\nglobal MAX_NEW_NOTE_HASHES_PER_CALL: Field = 16;\nglobal MAX_NEW_NULLIFIERS_PER_CALL: Field = 16;\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL: Field = 4;\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL: Field = 4;\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_CALL: Field = 2;\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL: Field = 16;\nglobal MAX_PUBLIC_DATA_READS_PER_CALL: Field = 16;\nglobal MAX_READ_REQUESTS_PER_CALL: Field = 32;\nglobal MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL: Field = 1;\n\n// \"PER TRANSACTION\" CONSTANTS\nglobal MAX_NEW_NOTE_HASHES_PER_TX: Field = 64;\nglobal MAX_NON_REVERTIBLE_NOTE_HASHES_PER_TX: Field = 8;\nglobal MAX_REVERTIBLE_NOTE_HASHES_PER_TX: Field = 56;\n\nglobal MAX_NEW_NULLIFIERS_PER_TX: Field = 64;\nglobal MAX_NON_REVERTIBLE_NULLIFIERS_PER_TX: Field = 8;\nglobal MAX_REVERTIBLE_NULLIFIERS_PER_TX: Field = 56;\n\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX: Field = 8;\n\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX: Field = 8;\nglobal MAX_NON_REVERTIBLE_PUBLIC_CALL_STACK_LENGTH_PER_TX: Field = 3;\nglobal MAX_REVERTIBLE_PUBLIC_CALL_STACK_LENGTH_PER_TX: Field = 5;\n\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: Field = 32;\nglobal MAX_NON_REVERTIBLE_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: Field = 16;\nglobal MAX_REVERTIBLE_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: Field = 16;\n\nglobal MAX_PUBLIC_DATA_READS_PER_TX: Field = 32;\nglobal MAX_NON_REVERTIBLE_PUBLIC_DATA_READS_PER_TX: Field = 16;\nglobal MAX_REVERTIBLE_PUBLIC_DATA_READS_PER_TX: Field = 16;\n\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_TX: Field = 2;\nglobal MAX_NEW_CONTRACTS_PER_TX: Field = 1;\nglobal MAX_READ_REQUESTS_PER_TX: Field = 128;\nglobal MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_TX: Field = 4;\nglobal NUM_ENCRYPTED_LOGS_HASHES_PER_TX: Field = 1;\nglobal NUM_UNENCRYPTED_LOGS_HASHES_PER_TX: Field = 1;\n// docs:end:constants\n\n// ROLLUP CONTRACT CONSTANTS - constants used only in l1-contracts\nglobal NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP: Field = 16;\n\n// TREES RELATED CONSTANTS\nglobal VK_TREE_HEIGHT: Field = 3;\nglobal FUNCTION_TREE_HEIGHT: Field = 5;\nglobal CONTRACT_TREE_HEIGHT: Field = 16;\nglobal NOTE_HASH_TREE_HEIGHT: Field = 32;\nglobal PUBLIC_DATA_TREE_HEIGHT: Field = 40;\nglobal NULLIFIER_TREE_HEIGHT: Field = 20;\nglobal L1_TO_L2_MSG_TREE_HEIGHT: Field = 16;\nglobal ROLLUP_VK_TREE_HEIGHT: Field = 8;\nglobal ARTIFACT_FUNCTION_TREE_MAX_HEIGHT = 5;\n\n// SUB-TREES RELATED CONSTANTS\nglobal CONTRACT_SUBTREE_HEIGHT: Field = 0;\nglobal CONTRACT_SUBTREE_SIBLING_PATH_LENGTH: Field = 16;\nglobal NOTE_HASH_SUBTREE_HEIGHT: Field = 6;\nglobal NOTE_HASH_SUBTREE_SIBLING_PATH_LENGTH: Field = 26;\nglobal NULLIFIER_SUBTREE_HEIGHT: Field = 6;\nglobal PUBLIC_DATA_SUBTREE_HEIGHT: Field = 5;\nglobal ARCHIVE_HEIGHT: Field = 16;\nglobal NULLIFIER_SUBTREE_SIBLING_PATH_LENGTH: Field = 14;\nglobal PUBLIC_DATA_SUBTREE_SIBLING_PATH_LENGTH: Field = 35;\nglobal L1_TO_L2_MSG_SUBTREE_HEIGHT: Field = 4;\nglobal L1_TO_L2_MSG_SUBTREE_SIBLING_PATH_LENGTH: Field = 12;\n\n// MISC CONSTANTS\nglobal FUNCTION_SELECTOR_NUM_BYTES: Field = 4;\nglobal MAPPING_SLOT_PEDERSEN_SEPARATOR: Field = 4;\n// sha256 hash is stored in two fields to accommodate all 256-bits of the hash\nglobal NUM_FIELDS_PER_SHA256: Field = 2;\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 32;\n\n// CONTRACT CLASS CONSTANTS\n// This should be around 8192 (assuming 2**15 instructions packed at 8 bytes each),\n// but it's reduced to speed up build times, otherwise the ClassRegisterer takes over 5 mins to compile.\n// We are not using 1024 so we can squeeze in a few more args to methods that consume packed public bytecode,\n// such as the ClassRegisterer.register, and still land below the 32 * 32 max args limit for hashing.\nglobal MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS: Field = 1000;\n// Bytecode size for private functions is per function, not for the entire contract.\n// Note that private functions bytecode includes a mix of acir and brillig.\nglobal MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS: Field = 500;\n// Same for unconstrained functions: the size is per function.\nglobal MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS: Field = 500;\n// Since we are not yet emitting selectors we'll use this magic value to identify events emitted by the ClassRegisterer.\n// This is just a stopgap until we implement proper selectors.\n// sha224sum 'struct ContractClassRegistered {contract_class_id: ContractClassId, version: Field, artifact_hash: Field, private_functions_root: Field, packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS] }'\nglobal REGISTERER_CONTRACT_CLASS_REGISTERED_MAGIC_VALUE = 0x6999d1e02b08a447a463563453cb36919c9dd7150336fc7c4d2b52f8;\n// sha224sum 'struct ClassPrivateFunctionBroadcasted'\nglobal REGISTERER_PRIVATE_FUNCTION_BROADCASTED_MAGIC_VALUE = 0x1b70e95fde0b70adc30496b90a327af6a5e383e028e7a43211a07bcd;\n// sha224sum 'struct ClassUnconstrainedFunctionBroadcasted'\nglobal REGISTERER_UNCONSTRAINED_FUNCTION_BROADCASTED_MAGIC_VALUE = 0xe7af816635466f128568edb04c9fa024f6c87fb9010fdbffa68b3d99;\n\n// CONTRACT INSTANCE CONSTANTS\n// sha224sum 'struct ContractInstanceDeployed'\nglobal DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE = 0x85864497636cf755ae7bde03f267ce01a520981c21c3682aaf82a631;\n\n// NOIR CONSTANTS - constants used only in yarn-packages/noir-contracts\n// Some are defined here because Noir doesn't yet support globals referencing other globals yet.\n// Move these constants to a noir file once the issue below is resolved:\n// https://github.com/noir-lang/noir/issues/1734\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: Field = 25;\nglobal MAX_NOTE_FIELDS_LENGTH: Field = 20;\n// GET_NOTE_ORACLE_RETURN_LENGT = MAX_NOTE_FIELDS_LENGTH + 1 + 2\n// The plus 1 is 1 extra field for nonce.\n// + 2 for EXTRA_DATA: [number_of_return_notes, contract_address]\nglobal GET_NOTE_ORACLE_RETURN_LENGTH: Field = 23;\nglobal MAX_NOTES_PER_PAGE: Field = 10;\n// VIEW_NOTE_ORACLE_RETURN_LENGTH = MAX_NOTES_PER_PAGE * (MAX_NOTE_FIELDS_LENGTH + 1) + 2;\nglobal VIEW_NOTE_ORACLE_RETURN_LENGTH: Field = 212;\n\n// LENGTH OF STRUCTS SERIALIZED TO FIELDS\nglobal AZTEC_ADDRESS_LENGTH = 1;\nglobal CALL_CONTEXT_LENGTH: Field = 8;\nglobal CONTENT_COMMITMENT_LENGTH: Field = 7;\nglobal CONTRACT_DEPLOYMENT_DATA_LENGTH: Field = 6;\nglobal CONTRACT_STORAGE_READ_LENGTH: Field = 2;\nglobal CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH: Field = 2;\nglobal ETH_ADDRESS_LENGTH = 1;\nglobal FUNCTION_DATA_LENGTH: Field = 4;\nglobal FUNCTION_LEAF_PREIMAGE_LENGTH: Field = 5;\nglobal GLOBAL_VARIABLES_LENGTH: Field = 6;\nglobal HEADER_LENGTH: Field = 25; // 2 for last_archive, 7 for content commitment, 10 for state reference, 6 for global vars\nglobal L1_TO_L2_MESSAGE_LENGTH: Field = 8;\nglobal L2_TO_L1_MESSAGE_LENGTH: Field = 2;\nglobal NEW_CONTRACT_DATA_LENGTH: Field = 3;\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH = 4;\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH = 5;\nglobal PARTIAL_STATE_REFERENCE_LENGTH: Field = 8;\nglobal PRIVATE_CALL_STACK_ITEM_LENGTH: Field = 219;\n// Change this ONLY if you have changed the PrivateCircuitPublicInputs structure.\n// In other words, if the structure/size of the public inputs of a function call changes then we should change this\n// constant as well PRIVATE_CALL_STACK_ITEM_LENGTH\nglobal PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH: Field = 214;\n// Change this ONLY if you have changed the PublicCircuitPublicInputs structure.\nglobal PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH: Field = 194;\nglobal STATE_REFERENCE_LENGTH: Field = 10; // 2 for snap + 8 for partial\nglobal TX_CONTEXT_DATA_LENGTH: Field = 11;\nglobal TX_REQUEST_LENGTH: Field = 17;\n\nglobal GET_NOTES_ORACLE_RETURN_LENGTH: Field = 674;\nglobal NOTE_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal NULLIFIERS_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal PUBLIC_DATA_WRITES_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal CONTRACTS_NUM_BYTES_PER_BASE_ROLLUP: Field = 32;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP_UNPADDED: Field = 52;\nglobal L2_TO_L1_MSGS_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal LOGS_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\n\n/**\n * Enumerate the hash_indices which are used for pedersen hashing.\n * We start from 1 to avoid the default generators. The generator indices are listed\n * based on the number of elements each index hashes. The following conditions must be met:\n *\n * +-----------+-------------------------------+----------------------+\n * | Hash size | Number of elements hashed (n) | Condition to use     |\n * |-----------+-------------------------------+----------------------|\n * | LOW       | n  8                         | 0 < hash_index  32  |\n * | MID       | 8 < n  16                    | 32 < hash_index  40 |\n * | HIGH      | 16 < n  48                   | 40 < hash_index  48 |\n * +-----------+-------------------------------+----------------------+\n *\n * Note: When modifying, modify `GeneratorIndexPacker` in packer.hpp accordingly.\n */\n// Indices with size  8\nglobal GENERATOR_INDEX__NOTE_HASH = 1;\nglobal GENERATOR_INDEX__NOTE_HASH_NONCE = 2;\nglobal GENERATOR_INDEX__UNIQUE_NOTE_HASH = 3;\nglobal GENERATOR_INDEX__SILOED_NOTE_HASH = 4;\nglobal GENERATOR_INDEX__NULLIFIER = 5;\nglobal GENERATOR_INDEX__INITIALIZATION_NULLIFIER = 6;\nglobal GENERATOR_INDEX__OUTER_NULLIFIER = 7;\nglobal GENERATOR_INDEX__PUBLIC_DATA_READ = 8;\nglobal GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST = 9;\nglobal GENERATOR_INDEX__FUNCTION_DATA = 10;\nglobal GENERATOR_INDEX__FUNCTION_LEAF = 11;\nglobal GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA = 12;\nglobal GENERATOR_INDEX__CONSTRUCTOR = 13;\nglobal GENERATOR_INDEX__CONSTRUCTOR_ARGS = 14;\nglobal GENERATOR_INDEX__CONTRACT_ADDRESS = 15;\nglobal GENERATOR_INDEX__CONTRACT_LEAF = 16;\nglobal GENERATOR_INDEX__CALL_CONTEXT = 17;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM = 18;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM_2 = 19;\nglobal GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET = 20;\nglobal GENERATOR_INDEX__L2_TO_L1_MSG = 21;\nglobal GENERATOR_INDEX__TX_CONTEXT = 22;\nglobal GENERATOR_INDEX__PUBLIC_LEAF_INDEX = 23;\nglobal GENERATOR_INDEX__PUBLIC_DATA_LEAF = 24;\nglobal GENERATOR_INDEX__SIGNED_TX_REQUEST = 25;\nglobal GENERATOR_INDEX__GLOBAL_VARIABLES = 26;\nglobal GENERATOR_INDEX__PARTIAL_ADDRESS = 27;\nglobal GENERATOR_INDEX__BLOCK_HASH = 28;\nglobal GENERATOR_INDEX__SIDE_EFFECT = 29;\nglobal GENERATOR_INDEX__FEE_PAYLOAD = 30;\n// Indices with size  16\nglobal GENERATOR_INDEX__TX_REQUEST = 33;\nglobal GENERATOR_INDEX__SIGNATURE_PAYLOAD = 34;\n// Indices with size  44\nglobal GENERATOR_INDEX__VK = 41;\nglobal GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS = 42;\nglobal GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS = 43;\nglobal GENERATOR_INDEX__FUNCTION_ARGS = 44;\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/constants.nr" }, "182": { "source": "use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/type_serialization.nr" }, "185": { "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: Field) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/utils.nr" }, "186": { "source": "use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS},\n    contract_class_id::ContractClassId, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute_from_public_key(\n        pub_key: GrumpkinPoint,\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> AztecAddress {\n        AztecAddress::compute(\n            PublicKeysHash::compute(pub_key),\n            PartialAddress::compute(\n                contract_class_id,\n                salt,\n                initialization_hash,\n                portal_contract_address\n            )\n        )\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let contract_address_salt = 3;\n    let contract_class_id = ContractClassId::from_field(4);\n    let initialization_hash = 5;\n    let portal_contract_address = EthAddress::from_field(6);\n\n    let address = AztecAddress::compute_from_public_key(\n        point,\n        contract_class_id,\n        contract_address_salt,\n        initialization_hash,\n        portal_contract_address\n    );\n\n    assert(address.to_field() == 0x2fd71a4f0742364f194dd16d0ae32d2f47845ddc7f5d328f37d4148b565c4123);\n}\n\n#[test]\nfn compute_address_from_partial_and_pubkey() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let partial_address = PartialAddress::from_field(3);\n\n    let address = AztecAddress::compute(PublicKeysHash::compute(point), partial_address);\n    assert(address.to_field() == 0x0447f893197175723deb223696e2e96dbba1e707ee8507766373558877e74197);\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/address/aztec_address.nr" }, "187": { "source": "use crate::{\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{ToField, Serialize, Deserialize}\n};\n\n// Public keys hash. Used in the computation of an address.\nstruct PublicKeysHash {\n    inner: Field\n}\n\nimpl ToField for PublicKeysHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<1> for PublicKeysHash {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<1> for PublicKeysHash {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        PublicKeysHash::from_field(fields[0])\n    }\n}\n\nimpl PublicKeysHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(public_key: GrumpkinPoint) -> Self {\n        PublicKeysHash::from_field(\n            pedersen_hash(\n                [\n            public_key.x,\n            public_key.y\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let actual = PublicKeysHash::compute(point);\n    assert(actual.to_field() == 0x1923a6246e305720b6aaf751fde0342613e93c82e455c3831e28375c16dd40d8);\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/address/public_keys_hash.nr" }, "191": { "source": "use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::FunctionLeafPreimage;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::new_contract_data::NewContractData as ContractLeafPreimage;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, CONTRACT_TREE_HEIGHT, FUNCTION_TREE_HEIGHT,\n    NOTE_HASH_TREE_HEIGHT, NUM_FIELDS_PER_SHA256, GENERATOR_INDEX__SILOED_NOTE_HASH,\n    GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK, GENERATOR_INDEX__CONSTRUCTOR,\n    GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Checks that `value` is a member of a merkle tree with root `root` at position `index`\n// The witness being the `sibling_path`\npub fn assert_check_membership<N>(value: Field, index: Field, sibling_path: [Field; N], root: Field) {\n    let calculated_root = root_from_sibling_path(value, index, sibling_path);\n    assert(calculated_root == root, \"membership check failed\");\n}\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<N>(leaf: Field, leaf_index: Field, sibling_path: [Field; N]) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\n// Calculate the contract tree root from the sibling path and leaf preimage.\npub fn contract_tree_root_from_siblings(\n    contract_class_id: ContractClassId,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    contract_leaf_index: Field,\n    contract_leaf_sibling_path: [Field; CONTRACT_TREE_HEIGHT]\n) -> Field {\n    //TODO(Kev): if we use shorthand syntax here, we get an error as expected,\n    // since variable name is `storage_contract_address` but the span is incorrect.\n    let contract_leaf_preimage = ContractLeafPreimage { contract_address: storage_contract_address, portal_contract_address, contract_class_id };\n\n    let contract_leaf = contract_leaf_preimage.hash();\n\n    let computed_contract_tree_root = root_from_sibling_path(contract_leaf, contract_leaf_index, contract_leaf_sibling_path);\n\n    computed_contract_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn read_request_root_from_siblings(\n    read_request: Field,\n    leaf_index: Field,\n    sibling_path: [Field; NOTE_HASH_TREE_HEIGHT]\n) -> Field {\n    root_from_sibling_path(read_request, leaf_index, sibling_path)\n}\n\npub fn silo_note_hash(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\nfn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new(0);\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, commitment_index: Field) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_siloed_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_unique_siloed_note_hashes<N>(\n    first_nullifier: Field,\n    siloed_note_hashes: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_note_hashes = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_note_hash = siloed_note_hashes[i];\n        if siloed_note_hash.value != 0 {\n            let nonce = compute_note_hash_nonce(first_nullifier, i);\n            unique_siloed_note_hashes[i] = SideEffect {\n                value: compute_unique_siloed_note_hash(nonce, siloed_note_hash.value),\n                counter: siloed_note_hash.counter\n                };\n        }\n    }\n    unique_siloed_note_hashes\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/hash.nr" }, "207": { "source": "use dep::aztec::{\n    protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::{rand::rand, nullifier_key::get_nullifier_secret_key, get_public_key::get_public_key},\n    log::emit_encrypted_log, hash::pedersen_hash, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\nstruct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n    header: NoteHeader,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN> for ValueNote {\n    fn serialize_content(self) -> [Field; VALUE_NOTE_LEN] {\n        [self.value, self.owner.to_field(), self.randomness]\n    }\n\n    fn deserialize_content(serialized_note: [Field; VALUE_NOTE_LEN]) -> Self {\n        ValueNote {\n            value: serialized_note[0],\n            owner: AztecAddress::from_field(serialized_note[1]),\n            randomness: serialized_note[2],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_note_content_hash(self) -> Field {\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash(self.serialize_content(),0)\n    }\n\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    fn get_header(self) -> NoteHeader {\n        self.header\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            Self::get_note_type_id(),\n            encryption_pub_key,\n            self.serialize_content(),\n        );\n    }\n\n    fn get_note_type_id() -> Field {\n        // TODO(#4519): autogenerate\n        // python -c \"print(int(''.join(str(ord(c)) for c in 'ValueNote')))\"\n        869710811710178111116101\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/aztec-nr/value-note/src/value_note.nr" }, "224": { "source": "// A contract used along with `Parent` contract to test nested calls.\ncontract DelegatedOn {\n    use dep::std::option::Option;\n\n    use dep::aztec::{\n        context::{PrivateContext, PublicContext, Context}, log::emit_unencrypted_log,\n        state_vars::{public_state::PublicState, set::Set},\n        protocol_types::{abis::{function_selector::FunctionSelector, call_context::CallContext}, address::AztecAddress},\n        note::{\n        note_getter_options::NoteGetterOptions, note_viewer_options::NoteViewerOptions,\n        utils as note_utils, note_header::NoteHeader\n    }\n    };\n    use dep::value_note::value_note::{ValueNote, VALUE_NOTE_LEN};\n\n    struct Storage {\n        current_value: PublicState<Field>,\n        a_private_value: Set<ValueNote>,\n    }\n\n    #[aztec(private)]\n    fn constructor() {}\n\n    #[aztec(private)]\n    fn private_set_value(new_value: Field, owner: AztecAddress) -> Field {\n        let mut note = ValueNote::new(new_value, owner);\n        storage.a_private_value.insert(&mut note, true);\n        new_value\n    }\n\n    #[aztec(public)]\n    fn public_set_value(new_value: Field) -> Field {\n        storage.current_value.write(new_value);\n        new_value\n    }\n\n    unconstrained fn view_private_value(amount: Field, owner: AztecAddress) -> pub Field {\n        let options = NoteViewerOptions::new().select(0, amount, Option::none()).select(1, owner.to_field(), Option::none()).set_limit(1);\n        let notes = storage.a_private_value.view_notes(options);\n        notes[0].unwrap_unchecked().value\n    }\n\n    unconstrained fn view_public_value() -> pub Field {\n        storage.current_value.read()\n    }\n\n    // TODO: remove this placeholder once https://github.com/AztecProtocol/aztec-packages/issues/2918 is implemented\n    unconstrained fn compute_note_hash_and_nullifier(\n        contract_address: AztecAddress,\n        nonce: Field,\n        storage_slot: Field,\n        note_type_id: Field,\n        serialized_note: [Field; 0]\n    ) -> pub [Field; 4] {\n        [0, 0, 0, 0]\n    }\n}\n", "path": "/Users/jack-sw/Codes/aztec-packages/noir-projects/noir-contracts/contracts/delegated_on_contract/src/main.nr" } } }
