{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"FPC","functions":[{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"other_asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"gas_token_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"7d3RbuzKeabhe9nHxoBV/EkWcyuDwcBJnIEBww5iZ4CB4XsfbVuktLyrV/diffvratV7ZictqfiYYv8ve4n115/+/Xf/+t//53///o//8ac///Qv//OvP/3hT//227/8/k9/fPtvf/1p+h+5/P3/+uf//O0ff/4//Pkvv/2vv/z0L8u0/ean3/3x39/+07787Tc//cfv//C7n/5lzuvf/tdvfv6i/cIXzbn2RSUfX7RPc+WL5itftNa+KKVlff+qlNZU+bLt2peVa1+2X/qymK59Wbr2Zfnal83Xviyufdly7cuunSVx7SyJa2dJXDtLlmtnyXLtLFmunSXLtbNkuXaWLNfOkuXaWbJcO0uWa2fJcu0sWa+dJeu1s2S9dpas186S9dpZsl47S9ZrZ8l67SxZr50l67WzZLt2lmzXzpLt2lmyXTtLtmtnyXbtLNmunSXbtbNku3aWbNfOknLtLCnXzpJy7Swp186Scu0sKdfOknLtLCnXzpJy7Swp186S/dpZsl87S/ZrZ8l+7SzZr50l+7WzZL92luzXzpL92lmyXztL0jRd/Lp08evyxa+bL35dXPy65eLXrRe/brv4deXi1108X9LF8yVdPF/SxfMlXTxf0sXzJV08X9LF8yVdPF/SxfMlXTxf8sXzJV88X/LF8yVfPF/yxfMlXzxf8sXzJV88X/LF8yVfPF/mi+fLfPF8mS+eL/PF82W+eL7MF8+Xizdo08U7tOniLdp08R5tuniTNl28S5su3qZNF+/Tpos3atPFO7Xp4q3adPFebbp4szZdvFubLt6uTRfv16aLN2zTxTu26eIt23Txnm26eNM2Xbxrmy7etk0X79umizduU/3Wwp7n48umff/my37zixfHnMr7q2Nep/PVbzNx5dV77PH+6n1ZPj6qyzEdS9r6W1Lpb0l7d0uq38p57pJSf0vK/S1p7m9J0d+Slv6W1N/Ve+/v6r33d/Xeu7t656m7q3eeurt656m7q3eeurt656m7q3eeurt656m7q3eeurt656m7q3ee+rt6p/6u3qm/q3fq7+qd+rt6J/dFYFn29xcv28dNirwtx4JKZwvK7lN7KflYUCm1BeXeFjT3tqDobUFLbwtae1vQ1tuCBNehvH9aULqzoLePD45vvW4f3zmdC9o7W9A89bag1NuCcm8LmntbUPS2oMW9oDmfCyrfLOiX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"},{"name":"fee_entrypoint_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"secret_hash","type":{"kind":"field"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+xdB3gcxfXfOxXLyJJtjA0YbJ/cu29P3Q3ZYNONTe8gy5IxGJveIfTQEkiBJJAQSIAkkALpIRXSe++NkIQUSPJPSE8g/5nTPvTT0+ze3d680w7cfd/7bm9uyu+9efPmTd2UN/gZO8bz9q8bfE4pqgm+04oyLIy+8bnWEFZvSDvOENZsCJtgCNvVEDZFUQ8Lm26IN8MQljGEtRjC5gRh+EkF3z3Bd2u2o62tvzPX77f6vdlc9+au9mxb++aOLr/Lb+9q35Lram3t72rr6uze3N2Z7fbbWvv9gfbu1oHs4Oep1FBe2TI/GtvYQIaEda6i54PnefA8H54XwLPGk5TnxYp+kxoM43z9JkE44/D1W1Kk4JNmepUt7+PPsaijv7Onoz62L51vxhuq3zTUbwp0kp6VqfJ+r35oc7ULxMdPyrIcJ9vLK2uAW27ePj2gLJ4OhPAMN8z6j5+xsGdSI41cjaAQYypjLlBG/+mUPcV+JiVTubYbs02e/2DIa3O2b0u7v7ljS6ff39ve1dfX3er7ud6O3o7Nua6B/s3tfld7l8qzrzfXpYrL9fb5/dnejn7dEBu9oUaHH9sN8Q+WO0r6/DElCPiPKfv5/smiMkjx/SeQsKV8jVhtGACN1VaDpXxt1tH/WVZ8Mvw63xZvsDfVn0r0plIG1zbO31vEWQc4/xwA/Uvw/Wzw/dfATuwWxPub+vF3Rf9Q9E9F/1L0b0X/UfRfRc9pT1LR/1KDFZdSlFZUo6hWUZ2iekVjFDWkveE9/l8NPT5vAOUqrUUB+n+xXBmV6rF+n5LpscamBQHrzG3nu0s62T2W5nsXMH+W8q2osj0rpGyNaUHAjQLKNi7hyqb5Hue4sv1VSNma0oKAmwSUrTnhyqb5bhZQNgms2gKPS9v38cen7c+w1oCe/h5m+J6F578Gz/ozIT0U3yZvum7HC8hsoj2Z+XxcYVtv/mzRGJH/vasCPUnRboomK5qiaHdFeyjaU9FURXsp2lvRNEXTFc1QlFHUomimolmKZiuakx50r9EF3zU9ctVkkiFsN0PYZEPYFEPY7oawPQxhexrCphrC9jKE7W0Im2YIm24Im2EIyxjCWgxhMw1hswxhsw1hc9IjO8laQZ0sty3uaqGP6R8Y/Eyy2F9dXyczlud1USbPW3azJ7/uyfby8qdYrIuXO1EX/f7u1uTX5+9hLa8uf0+LdXGDE3WR9afakl9/1t/LVl59WX9vi3Vxowt10ZX1p9mSn+p7plvKq1/lNcNiXdzkQF30KZ4zluTXpfJqsZSXYtmfabEubk5+XfRrnmfZkV+fzmu2nby6dF5zLNbFLRWqi2x5H9+iv+db9Fd87G/LrYtXOFIXFvs136Jd9m+2WBevFKoL25tbLLZf36L++VLySzP5JWF8S3nNtThvpfOwPVel5wEnCszXzUvbrWvbfOv17F0F+H59XbL51vo4T4DvN1TINpaLc77F9mixrv03JFxvdHuZK6A3b0w437sKtZc3OdJeFlhsLxbr2rcpP1pDIz9C/9Z24oXTCOmhdbOF6aE4NvVM762aJKBn9wi3r3LxaZ4XCvB9ryPjpoUWfc1FFtuqRb3xXamLv1tcI1uclmnDSWoXJru5COzmYrCbS4Tspt6PupuA/bgv4XZT87xEgO/7HWmrSyy2r6UW7aZFvfFdqYt/WLSby9IybThJ7cJkN5eC3VwGdjMrZDf1Hv7JAvbj7Qm3m5rnrADf73CkrWYtti/fot20qDe+K3XxT4t2M5eWacNJahcmu+mD3cyB3WwVspv63NMUAfvxzoTbTc1zqwDf73KkrbZabF9tFu2mRb3xXamLf1m0m+1pmTacpHZhspttYDfbwW52CNlNfVZ0dwH78XDC7abmuUOA70ccaasdFttXp0W7aVFvfFfq4t8W7WZXWqYNJ6ldmOxmJ9jNLrCb3UJ2U5+v30PAfrw/4XZT89wtwPcHHGmr3Rbb13KLdtOi3viu1MV/LNrNFWmZNpykdmGym8vBbq4Au7lSyG7qO0n2FLAfH0643dQ8rxTg+yOOtNWVFtvXKot206Le+K7UxX8t2s3VaZk2nKR2YbKbq8Burga7uY+Q3dT3OE0VsB8fS7jd1DzvI8D3xx1pq/tYbF89Fu2mRb3xXamL5yzazTVpmTacpHZhsps9YDfXgN1cK2Q39d13ewnYj08l3G5qntcK8P2YI211rcX2ta9Fu2lRb3xX6uJ5i3Zzv7RMG05SuzDZzX3Bbu4HdnOdkN3U94XuLWA/PpNwu6l5XifA92cdaavrLLav9RbtpkW98V2pi/9ZtJv7p2XacJLahclurge7uT/YzQOE7KYufJqA/fhCwu2m5vkAAb6/6EhbPcBi+zrQot20qDe+K3XhWayLg9IybThJ7cJkNw8Eu3kQ2M2Dheymvpd+uoD9+ErC7abm+WABvr/qSFs92GL7OsSi3bSoN74rdZGyWBeHpmXacJLahcluHgJ281CwmxuE7KZ+l8cMAfvxjYTbTc3zBgG+v+lIW91gsX0dZtFuWtQb35W6SFusi41pmTacpHZhspuHgd3cCHZzk5Dd1O8/ygjYj+8k3G5qnjcJ8P1dR9rqJovt63CLdtOi3viu1EWNxbo4Ii3ThpPULkx283Cwm0eA3TxSyG7qd8a1CNiPHyTcbmqejxTg+4eOtNUjLbavoyzaTYt647tSF7UW6+LotEwbTlK7MNnNo8BuHg128xghu6nfszlTwH78JOF2U/N8jADfP3WkrR5jsX0da9FuWtQb35W6qLNYF8elZdpwktqFyW4eC3bzOLCbxwvZTf1u4lkC9uOJhNtNzfPxAnz/wpG2erzF9nWCRbtpUW98V+qi3mJdnJiWacNJahcmu3kC2M0TwW6eJGQ39fvcZwvYj18l3G5qnk8S4PvXjrTVkyy2r5Mt2k2LeuO7UhdjLNbFKWmZNpykdmGymyeD3TwF7OapQnazIT38va+25PTbhNtNzfOpAnz/zpG2eqrF9tVr0W5a1BvflbposFgXm9MybThJ7cJkN3vBbm4Gu9mX9oZ90pbrbrxnT0Z9aRl9tW3jtlhs76a61ER1uSWoy90V9avnuiCcVauRz2x5H/+ZVGXqI1vex++3qDf1gHMgEPLW4Pu04Htb8H160H/OD+KfoX5vV3Smoh2Kdio6S9HZis5RdK6i8xSdr+gCRRcqukjRxYouUXSpossUXa7oCkUvU3SloqsUXa3oGkXXKrpO0fWKXq7oBkU3KrpJ0c2KblH0CkWvVHSrotsUvUrRq9OB4Oll9xp8xhv+sf3SIosV42+1aNhfY1FhdINsBKWWVHSbuBHva9OCgF+btp/v7RaVQYrv28FEW8o3r2xprzLW36ZVlcS5VahR3AF6a92FuN2yC0FWnUDXQZi0otisAFTs1wU/Xq95kqiAOwQs0x2WW40U32lBvsvF+AZhGWbL+/haMd+Qtl83d1q2ZGQAdL5XBvnalsXrhWRxl5As7hKUxVYhWTyT8LlEqfbwh9Hlu68APjHd/2OF3kmbLe/jW9RL32Jd+zblpx0pPd9p8ri9EuVZSJ8wT4k+y5ZM0Kl8Y5SXnC3v479BqBNA0CVi9guVozG/UcAo/CUhk/mlOG/l8vymdDINzF/qZPTyTeCcxK2fQjK3WT93Q15+a6tqG1s6/YEtA63tnd25zX5Ha0fHQNtAZ0dX25aB9rbeLZ39fltva667vzM74Hf193e2t/Z1dgx0b+nrGECj7W9pbW3b0r25z2/PdfRuznZtae3NDrR1tuayvVtaO7dsae3q6Ohtbd3S0TXQ1d2Vy/UOtHZl2zs7u7MdudbunFT93B3UTyVH1zanYbATe3Pw4x5XDLgUvjcLGOt7hTquewVHL1oW9wjI4i1CsniLoCz6hTz7vyZ8JCfVHv6W8JGclO7/3ZGRnEW99C3Wtf/36kiOf/w3C43k3uriSO6twiO5twoYhX+/BEdy96WTaWD+LTRSuM+xkdz9Fkdyf7c4kpOqn/thJBfWKSR5Ck4Sp1QH84CLHcwDwh3MAwIdzH8r1MHYXOdN0FrRsA6mXFzPVWgEUC7Ot1nsoC3qn/+cUAfwtiI66HJl+va0vY5w2PRogjro/wrVz9tfRFOt7wh+PJg2bGTKlvfxwzb02NyhVm5eFjdF+RIVTzK0bVSlZFhuXg8lvD50g3lIwDF6p5CT+M603FT0g0KyeJeQLN4lPC0vIQuvPtnT8lLtITW6fBeclpfS/bRlvulje1reol76Fuvatym/F8u0/Dss21P6vFty1uQhoU7g3YKzJhrzuwWMQr2QUbA9Lf+QRUfwPelkGhibdYF6+Z60/LS8zfp52OK0PBrtckf9UvXz8CiM+qWOLz0S/HivKwZcCt8jAsb6fUId1/sERy9aFu8VkMX7hWTx/rTsURkJz74h4SM5qfYwNuEjOSnd38WRkZxFvfQt1rW/S3Ukxz/+I0IjuQ+4OJL7gPBI7gMCRqH5JTiS+2A6mQamWWik8EHHRnIfsjiS28XiSE6qfj6UrvwGK5tTcJI4pTqYD7vYwXxYuIP5sEAHM6FCHYzNdd4ErRUN62DKxTWxQiOAcnF+xGIHbVH//IlCHcBH0vIbrB5N2+sIh02PJqiDniBUP48a6sf2qLffov3ZZjGvj1rsyyp5/59N3Ij3Y2lBwB9L28/34xaVQYrvj6eHBGwp34re/7fNEW+6X6hRfCLKmy5X6T5u0RtAq06gXwzbZj8Z/PhU2rN//5+ugE8IWKZPWG41UnynBfkuF+NjwjLMlvfxtWI+JjCsfFxoiP14Wm4h71NCsvi0kCw+nZbdniohi90Svqgp1R4mJ3xRU0r3pziyqGlRL32Lde1PqS5q8k++z7IlE3QqP5MWnHN+TKgT+IzgnLPG/BkBozDVkUXNxyw6gp9NJ9PATBWak/tsWn5R02b9fC5tb850isU5U6n6+Vy68ttTbU7DYCf2+eDHF1wx4DoPCXyfFzDWXxTquL4oOHrRsviCgCy+JCSLLwnKYpuQZ793wkdyUu1hWsJHclK6P92RkZxFvfQt1rU/vTqS4x//80IjuS+7OJL7svBI7ssCRmHmS3Ak95V0Mg3MTKGRwlccG8l91eJIbrrFkZxU/Xw1XfntqTan4CRxSnUwX3Oxg/macAfzNYEOZrYj21NtGrDJQh5subjmOLI99esWO2iL+ufPEeoAvp6W3576jbS9jnBKfTI76NlC9fONF9FU6zeDH99Ke/bv/wvb0GNzh1q5eVncFCVy3xzJ0LZRlZJhuXl9O+H1oRvMtwUco+8IOYnfSctNRX9LSBbfFZLFd4Wn5SVkMT/h0/JS7WFBwqflpXR/oSPT8hb10rdY1/7C6rQ8/+T7LFsyQWf3e5KzJt8W6gS+JzhrojF/T8AoLHVkWv7bFh3B76eTaWCWCo0qv5+Wn5a3WT8/sDgtv9DiqF+qfn4wCqN+qeNLPwx+/MgVAy6F74cCxvrHQh3XjwVHL1oWPxKQxU+EZPGTtOxRGQnPPpvwkZxUe/ATPpKT0v2cIyM5i3rpW6xrP1cdyfGP/0OhkdxPXRzJ/VR4JPdTAaPQ8RIcyf0snUwD0yE0UviZYyO5n1scyeUsjuSk6ufn6cpvsLI5BSeJU6qDecLFDuYJ4Q7mCYEOpsuRDVY2DdgCIQ+2XFzdjmyw+oXFDtqi/vndQh3AL9LyG6yeTNvrCBfWJ7OD7hKqnyehg67U/XWnC3V8v0wLAv5l2n6+v7JomKX4/hW4bJbyrehliduElO3XaUHAvxZQtqcSrmya76cElM2E1caOPu1VpS3LwKan9pu0rAyz5X3yxu8pAa/8t+lk645+G/RDArpj85bv3yVchlq3dT3bnp+32Gb831qsj98nvD60vvxeoC0/bbE+JPjW65dPC/C9sj7ZtnurEN+rhEbxtm2txfrxV1lee6uUY23zhZmI95m0IOBnBBzrPyTcsdZ8/yE9JGBL+VZU2U4TUrY/pgUB/1FA2f6UcGXTfP+pQqO4bHmffMP9k0Av9n8JH3npUdf/CfD9Z8uNdKw3NFesf2tD9nzwfBo8nw7P24Jn/flLeiitTT71yPXPAvJ71qK3C03QKINseR9/wGJdzw/y+avK82+K/q7oH4r+qehfiv6t6D+K/qvoOV2/iv6nGVTDv5SitKIaRbWK6hTVKxqjqEHRWEW7KGpUNE5Rk6JmReMVTVA0UdGuiiYp2k3RZEVTFO2uaA9FeyqaqmivmkEvEufO/xroAIb9zRD2d0PYPwxh/zSE/csQ9m9D2H8MYf81hD1nCHveEPY/Q1he3iwsZQhLG8JqDGG1hrA6Q1i9IWyMIazBEDbWELaLIazREDbOENZkCGs2hI03hE0whE00hO1qCJtkCNvNEDbZEDbFELa7IWwPQ9iehrCphrC9aoZsDH1K3YhTis0p19b+1UJe/QODn79ZxNWT8D0FAc9b/m5Pft3/sJeX/0+LdbHGibro9/9lTX59/r+t5dXl/8diXax1oi6y/n9tya8/6z9nK6++rP+8xbrY14W66Mr6/7MlPz17XGMnr379pq4ae3WxnwN10afHI5bk16XyqrGUl2LZr7VYF+uSXxf9muc6O/Lr03nV28mrS+c1xmJdrE9+Xeis/QYr8uvP5zXWSl59+bx2sVgX+ye+LrryPDdakV8epj/ORl79g3k1WayLA5JeF32DPDfbkF/XYF7jbeQ1yLI/wWJdHJjwutgS8DzRAs+bg7x2tZBXZ5DXJIt1cVCy6yJHJx53K59nn/KaXHZeXQOU1xSLdXFwouuiazPxvHv58nvhJOseZefV+UJee1qsi0MSXRftL/A8tWye/Rfy2qvG3pxlj8UzLocm5EBrgY9vcd7Mtzjv4+9rsS42OFIXFucHfIvjW3+9xbo4zJG6sDgO8i368f6BFutioyN1YdHf8y36K/4hFutikyN1YbFf8y3aZf8wi3VxuCM31Fhsv75F/fOl5Jdm8kvCuvILrwm06IfqPGzvAdL7q55N298HNa3Gbl3b5vuM9NDeH5t8DyR817/Wx2k19vne6sjZ/ekW26PFuva3JlxvdHvZW0BvTk8439pGSLSXMxxpLzMstheLde3blF9+j6E35Efo39pO0H7kGTVD+5EzNUNxbOrZ9vTQvlOb9bcj4bdoap4zAu1rpyPjpozFed4Wi23Vot74rtTFdot+/8wamTacpHZhspstYDdngt2cJWQ3z0wP7c3HfMuV0zkJt5ua51kCdvNcR9rqLIvta7ZFu2lRb3xX6uJMi3ZzTo1MG05SuzDZzdlgN+eA3ZwrZDd3pIfOL2G+5crpgoTbTc3zXAG7eaEjbXWuxfY1z6LdtKg3vit1scOi3ZxfI9OGk9QuTHZzHtjN+WA3FwjZzZ3poTOemG+5crok4XZT87xAwG5e6khbXWCxfS20aDct6o3vSl3stGg3F9XItOEktQuT3VwIdnMR2M3FQnbzrPTQOXjMt1w5XZFwu6l5XixgN1/mSFtdbLF9LbFoNy3qje9KXZxl0W4urZFpw0lqFya7uQTs5lKwm8uE7ObZ6aG7QjDfcuV0dcLtpuZ5mYDdvMaRtrrMYvvKWrSbFvXGd6UuzrZoN/0amTacpHZhsptZsJs+2M2ckN08Jz10nxLmW66crk+43dQ85wTs5ssdaas5i+2r1aLdtKg3vit1cY5Fu9lWI9OGk9QuTHazFexmG9jNdiG7eW566M45zLdcOd2UcLupeW4XsJs3O9JW2y22rw6LdtOi3viu1MW5Fu1mZ41MG05SuzDZzQ6wm51gN7uE7OZ56aF7OTHfcuX0yoTbTc1zl4DdvNWRttplsX11W7SbFvXGd6UuzrNoN5fXyLThJLULk93sBru5HOzmCiG7eX566O5izLdcOb064XZT87xCwG6+xpG2usJi+1pp0W5a1Bvflbo436LdXFUj04aT1C5MdnMl2M1VYDdXC9nNC9JD97tjvuXK6Y6E203N82oBu/k6R9rqaovtax+LdtOi3viu1MUFFu1mT41MG05SuzDZzX3AbvaA3VwjZDcv1IUL2I87E243Nc9rBPi+y5X7zCy2r7UW7aZFvfFdqYsLLdrNfWtk2nCS2oXJbq4Fu7kv2M39hOzmRdrXFLAfdyfcbmqe9xPg+82u3D1o8259i3bTot74rtTFRRbt5voamTacpHZhspvrwG6uB7u5v5DdvDg99C41zLdcOb0l4XZT87y/AN9vdeWeUJv3/Vu0mxb1xnelLi62aDcPrJFpw0lqFya7eQDYzQPBbh4kZDcvSQ+9bxLzLVdODyTcbmqeDxLg+22u3Olr8x0EFu2mRb3xXamLSyzazUNqZNpwktqFyW4eDHbzELCbhwrZzUvTQ+/kxXzLldODCbebmudDBfh+yJX7ty22rw0W7aZFvfFdqYtLLdrNw2pk2nCS2oXJbm4Au3kY2M2NQnbzsvTQe8sx33Ll9O6E203N80YBvt/jSFvdaLF9bbJoNy3qje9KXVxm0W4eXiPThpPULkx2cxPYzcPBbh4hZDcvV4XXC9iP9ybcbmqejxDg+32OtNUjLLavIy3aTYt647tSF5dbtJtH1ci04SS1C5PdPBLs5lFgN48WsptXqMLHCNiPDybcbmqejxbg+0OOtNWjLbavYyzaTYt647tSF1dYtJvH1si04SS1C5PdPAbs5rFgN48TspsvU4U3CNiPRxNuNzXPxwnw/VFH2upxFtvX8RbtpkW98V2pi5dZtJsn1Mi04SS1C5PdPB7s5glgN08UsptXqsLHCtiPTyTcbmqeTxTg+5OOtNUTLbavkyzaTYt647tSF1datJsn18i04SS1C5PdPAns5slgN08RsptXqcJ3EbAfjyfcbmqeTxHg+9OOtNVTLLavUy3aTYt647tSF1dZtJu9NTJtOEntwmQ3TwW72Qt2c7OQ3bxaFd4oYD8+l3C7qXneLMD35x1pq5sttq8+i3bTot74rtTF1Rbt5pYamTacpHZhspt9YDe3gN3sF7Kb16jCxwnYjy8l3G5qnvsF+P6yI22132L7GrBoNy3qje9KXVxj0W5urZFpw0lqFya7OQB2cyvYzdOE7Oa1qvAmAfvxtYTbTc3zaQJ8f92Rtnqaxfa1zaLdtKg3vit1ca1Fu3l6jUwbTlK7MNnNbWA3Twe7eYaQ3bxOFd4sYD++lXC7qXk+Q4DvbzvSVs+w2L62W7SbFvXGd6UurrNoN8+skWnDSWoXJru5HezmmWA3dwjZzetV4eMF7Mf3Em43Nc87BPj+viNtdYfF9rXTot20qDe+K3VxvUW7eVaNTBtOUrsw2c2dYDfPArt5tpDdfLkqfIKA/fhRwu2m5vlsAb5/7EhbPdti+zrHot20qDe+K3Xxcot289wamTacpHZhspvngN08F+zmeUJ28wZV+EQB+/GzhNtNzfN5Anz/3JV32lhsX+dbtJsW9cZ3pS5usGg3L6iRacNJahcmu3k+2M0LwG5eKGQ3b1SF7ypgP55MuN3UPF8owPcvXblj3GL7usii3bSoN74rdXGjRbt5cY1MG05SuzDZzYvAbl4MdvMSIbt5kyp8koD9eCrhdlPzfIkA379x5c5Hi+3rUot206Le+K7UxU0W7eZlNTJtOEntwmQ3LwW7eRnYzcuF7ObNqvDdBOzH7xNuNzXPlwvw/bQrd/BYbF9XWLSbFvXGd6UubrZoN19WI9OGk9QuTHbzCrCbLwO7eaWQ3bxFFT5ZwH78MeF2U/N8pQDff3LlTLTF9nWVRbtpUW98V+riFot28+oamTacpHZhsptXgd28GuzmNUJ28xWq8CkC9uMvCbebmudrBPh+1pUzKhbb17UW7aZFvfFdqYtXWLSb19XItOEktQuT3bwW7OZ1YDevF7Kbr1SF7y5gP/6ecLupeb5egO9/uLJn0GL7erlFu2lRb3xX6uKVFu3mDTUybThJ7cJkN18OdvMGsJs3CtnNW1XhewjYj38n3G5qnm8U4Ps/rqzhWmxfN1m0mxb1xnelLm61aDdvrpFpw0lqFya7eRPYzZvBbt4iZDdvU4XvKWA/nk+43dQ83yLA9/9cmVOz2L5eYdFuWtQb35W6uM2i3XxljUwbTlK7MNnNV4DdfCXYzVuF7OarVOFTBexHekyy7abm+VYBvmvGOOLjWGxft1m0mxb1xnelLl5l0W6+qkamDSepXZjs5m1gN18FdvPVQnbz1arwvQTsR33C7abm+dUCfI9xpK2+2mL7eo1Fu2lRb3xn6sKi3XxtjUwbTlK7MNnN14DdfC3YzdtrvGGftOW6m+jZk9HtNcm2macp4T2dtt8HzfPs68YE0A39Id1IwfNceF4Az0+lkvO8WNEdQT/F+bqjJpmYi+XrdQp/nTdI1C5Nnx7Pim606fJrWd62ddliXlkpjCkHMM51AOMCz67dos/rWZ9lvdN6nUUn4fUWOy1tCOoD4p8kdzoGuGXn3dnVmm3d3NUtKYPX1cjIwDbO36XcwFnrJVun6LMS8nxDYGzuDL7vCr7fGHy/Kfi+O/h+c/B9T/B9b/D9luD7rcH3fcH3/cH3A4ETkwnKfZv6/XZF71D0oKKHFL1T0bsUvVvRexQ9rOgRRe9V9D5F71f0AUUfVPQhRR9W9BFFjyr6qKKPKfq4ok8o+qSiTyl6TNHjij6t6DOKPqvocwzL59XvLyj6oqIvKfqyoq8o+qqiryn6uqJvKPqmom8p+rai7yj6rqLvKfq+oh8o+qGiHyn6saKfKPqpop8p+rmiJxT9QtGTin6p6FeKfq3oqQDLxgDLb9Tv3yr6naLfK3pa0TOK/qDoj4r+pOj/FP1Z0V8UPavor4r+pujviv6h6J+K/qXo34r+o+i/ip7TzqKi/+n6UIqaUpRWVKOoVlGdonpFYxQ1KBqraBdFjYrGKWpS1KxovKIJiiYq2lXRJEW7KZqsaIqi3RXtoWhPRVMV7aVob0XTFE1XNENRRlGLopmKZimarWiOormK5imar2iBooWKFilarGiJoqWKlinKKtKNLaeoVVGbonZFHbXD67VT/e5S1K1ouaIVilYqWqVotaJ9FPUoWqNoraJ9Fe2naJ2i9Yr2V3SAogMVHaToYEWHKDpU0QZFhynaqGiTosMVHaHoSEVHKTo6wEIN+Rj1+1hFxyk6XtEJik5UdJKikxWdouhURb2KNivqU7RFUb+iAUVbFZ2maJui0xWdoWi7ojMV7VC0U9FZis5WdI6icxWdp+h8RRcoulDRRYouVnSJoksVXabockVXKHqZoisVXaXoakXXKLpW0XWKrg94IbvxcvX7BkU3KrpJ0c2KblH0CkWvVHSrotsUvUrRqxW9RtFrFd2u6A5Fr1P0ekVvUHSnorsUvVHRmxTdrejNiu5RdK+ityh6q6L7FN2v6AFFb1P0dkXvUPSgoocUvVPRuxS9W9F7FD2s6BFF71X0PkXvV/QBRR9U9CFFH1b0EUWPKvqooo8p+riiTyj6pKJPKXpM0eMB7zTw+rT6/RlFn1X0OUWfV/QFRV9U9CVFX1b0FUVfVfQ1RV9X9A1F31T0rdrBPL4d5El+znfU7+8q+p6i7yv6gaIfBnF/FHz/OEjTE6T5ifr9U0U/U/RzRU8o+oWiJxX9UtGvFP1a0VOKfqPot4p+p+j3ip5W9IyiPyj6o6I/Kfo/RX9W9BdFzyr6q6K/Kfq7on8o+qeifyn6t6L/KPqvoucUPa/ofxqjct5SitKKahTVKqpTVK9ojKIGRWMV7aKoUdE4RU2KmhWNVzRB0URFuyqapGg3RZMVTVG0u6I9FO2paKqiveqG18ne6vc0RdMVzVCUUdSiaKaiWYpmK5qjaK6ieYrmK1qgaKGiRUFe44K8FqvfSxQtVbRMkXZKfUU5Ra2K2hS1K+pQ1Fk3mKYr+O4OvpcH3yuC75XB96rge3XwvU/w3RN8rwm+1wbf+wbf+wXf64Lv9cH3/sH3AcH3gcH3QcH3wcH3IcH3ocH3huD7sOB7Y/C9Kfg+PPg+Ivg+Mvg+Kvg+Ovg+Rn9r4dUE33fVDM2yUJh2HDIs7B5DvLca4t1niHe/IewBQ9q3G8IeNIS90xD2bkPYw4aw9xrC3m8I+6Ah7MOGsEcNYR8zhH3CEPYpQ9jjhrDPGMI+Zwj7giHsS4awrxjCvmYI+4Yh7FuGsO8Ywr5nCPuBIexHhrCfGMJ+Zgh7whD2pCHsV4awpwxhvzPo6R8NYc8awv5pCHvOEJauHRk2xhA2zhA20RA2xRC2lyEsYwibYwhbaAhbZghrM4Rpxy3DwpYbwlYawlYbwnoMYWsNYfsZwtYbwg4whB1kCDvEELbBELbREHa4IexIQ9jRhrBjDWEnGMJONoT1GsK2GMK2GsJON4SdaQg7yxB2riHsAkPYxYawywxhLzOEXW0Iu84QdpMh7GaDnt5iCHuFIe0rDfFeYwh7rSHt7YawNxjC7jTkd5ch7I2GtG8yxHuLIeythrT3GcLebgh7hyG/Bw1hDxnSvtMQ7xFD2HsNad9nCPuQIezDhvw+Ygh71JD2o4Z4nzKEPWZI+7gh7HuGsB8awn5kCPuxIeynhrCfG8J+YQj7pSHs14aw3xjCfmcIe9oQ9gdD2J8MYX82hD1rCPubIewfhrB/GcL+Ywh7zhD2P0OYHgTxsBpDWJ0hbIwhbKwhrNEQ1mQIG28Im2gIm2QIm2wI290QtqchbC9D2DRDWIshbI4hbIEhbIkhLGsIazWEdRjCug1h+xjC1hjC9jWErTOE6QFaDwvbZIh3uCHsCEPYkUEYfvhiUbkLPBYn331tqyzllY3iOVvex/9xrT35HVtnd+X2Bf+uiLrPlvcZtkhWrhz0QoMlXKKLOHfWlM9zZ2ffQF9bZ5dk3dhcxL3Xkbp5c01l7Ee58qy1yPM9jvBscUHdf5MjPKcs8vxGR9rgWyzi1PPHY7zhOzn38MwfO2W2t8rk29Euk29nm1v5dnQL5dsvlG+nTL65rFC9bZbJt1UK7xa35NvhC8lByO6IyaFDKN92t/IVa8eu6a+UXZfqN3P5uTiWt21fyKL/lx0Gkm/1x6MK8+B5vufGVv/j6sx86XCXjzAcXzd4fKHBG1IumqTBj23Fc2F7/DwHMM63iBGNzQl13vCP7dmf4+vsjWJPsDdDmR/R6UZeiS38ItYXPuXm7fd2dvX1ZnslZXB8nYwMbOM81hGcFmfuRLfwY2czNng+Ucn4JEUnKzpF0amKehVtVtSnaItunJp28cwH7mwL86S6RAvTpweURX9guQf43kb9x88YgBpBgcW06rnAqvv9FnuIAaGKtN0r2uR5qyGvzdm+Le3+5o4tnX5/b3tXX193q+/nejt6Ozbnugb6N7f7Xe1dKs++3lyXKi7X2+f3Z3s78jrV6I0cj3ie/Ua3tc6+ldGf0+oEAZ9WZz/fbRaVQYrvbeAnWspX5Oj/QIDVVoOlfG3W0emWFf+FDY0q3xavsj3nqQ72nGcEuryd95xnBD0nhm037F6w3ZuearE3PcOiom53pDe1yfOZjvamZwr1pjvqBAHvEOhNdya8N9V873SkN90eYLXdm9qso7OEetOzRqE37U12b0qfHMri7ECXz+G9qf7jOQbAds/Za0GR+gcGP2dbVMpzHOk5bfJ8LuTld7Xmcp2tOl7XlqzftqUv15XLbdnclu3L9vbl+rvb/O6Btlxba9+Wvs0qz15/IDvQ29c90DWIq5I957lCPed5dYKAzxPoOc9PeM+p+T7fkZ7znACr7XwvEOrtLgh6+Ur2dpsd7O0uDPTvIt7bXRj0dhh2Ud1IC2a7B9xssQe80KIBuMiRHtAmzxc72gNeLNQDXlInCPgSgR7w0oT3gJrvSx3pAS8KsNrO9zKhHvCyUegB+xycPb080L8reA94uWH29IoKzJ72WZw9vdyiAbjCkR7QJs8vc3T29GVCPeCVdYKArxToAa9KeA+o+b7KkR7wigCr7dlTm3V0tVBvenUwe4of24YrZbGuThQy1rb1f8BC3W9p7+psbR/ojKqbJB0md6UjtbnVdYsj+lipie4kHXS+yBGeLW479k95CfJ8siN251iLdueaOrv9M/kD1xgGgrb9rWstYKet8LRdeTxg1fR8gWe9Ym46i1MLca4NiXN8nd1zP7squq5uuMxttzeberzQe+nZmEWO8Jy2yPNiR3iuscjzEkd4tuknLa0Qz9nyPv4yi/L7bcoNvz3ruYHTdwRnzqIOSeJsdUSebY7gbHcEZ4cjODsdwdnlCM5uR3AudwTnCkdwrnQE5ypHcK52BOc+juDscQTnGkdwrnUE576O4NzPEZzrHMG53hGc+zuC8wBHcB7oCM6DHMF5sCM4D3EE56GO4NzgCM7DHMG50RGcmxzBebgjOI9wBOeRjuA8yhGcRzuC8xhHcB7rCM7jHMF5vCM4T3AE54mO4DzJEZwnO4LzFEdwnuoIzl5HcG52BGefIzi3OIKz3xGcA47g3OoIztMcwbnNEZynO4LzDEdwbncE55mO4NzhCM6djuA8yxGcZzuC8xxHcJ7rCM7zHMF5viM4L3AE54WO4LzIEZwXO4LzEkdwXuoIzsscwXm5IzivcATnyxzBeaUjOK9yBOfVjuC8xhGc1zqC8zpHcF7vCM6XO4LzBkdw3ugIzpscwXmzIzhvcQTnKxzB+UpHcN7qCM7bHMH5KkdwvtoRnK9xBOdrHcF5uyM473AE5+scwfl6R3C+wRGcdzqC8y5HcL7REZxvcgTn3Y7gfLMjOO9xBOe9juB8iyM43+oIzvscwXm/IzgfcATn2xzB+XZHcL7DEZwPOoLzIUdwvtMRnO9yBOe7HcH5HkdwPuwIzkccwfleR3C+zxGc73cE5wccwflBR3B+yBGcH3YE50ccwfmoIzg/6gjOjzmC8+OO4PyEIzg/6QjOTzmC8zFHcD7uCM5PO4LzM47g/KwjOD/nCM7PO4LzC47g/KIjOL/kCM4vO4LzK47g/KojOL/mCM6vO4LzG47g/KYjOL/lCM5vO4LzO47g/K4jOL/nCM7vO4LzB47g/KEjOH/kCM4fO4LzJ47g/KkjOH/mCM6fO4LzCUdw/sIRnE86gvOXjuD8lSM4f+0IzqccwfkbR3D+1hGcv3ME5+8dwfm0IzifcQTnHxzB+UdHcP7JEZz/5wjOPzuC8y+O4HzWEZx/dQTn3xzB+XdHcP7DEZz/dATnvxzB+W9HcP7HEZz/dQTnc47gfN4RnP9zBKfO0AWcKUdwph3BWeMIzlpHcNY5grPeEZxjHMHZ4AjOsY7g3MURnI2O4BznCM4mR3A2O4JzvCM4JziCc6IjOHd1BOckR3DuJoQzzXC2Zjva2vo7c/1+q9+bzXVv7mrPtrVv7ujyu/z2rvYtua7W1v6utq7O7s3dndluv6213x9o724dCPKeZ5HnyY7wnLLI85SXYD3vXiGes+V9/D1S9uR3d40bdmdPR/Sx1iLPUx3pE/ayoI+dnX0DfW2dXVF1ky3v4+9tsd3cVeOGrZhmkefXOWIrpjvSbmY4gjPzErS9LY74AjMttu/fOcLzLIs8/7jWjTY42xFbMccRnHMdwTnPEZzzHcG5wBGcCx3BucgRnIsdwbnEEZxLHcG5zBGcWUdw+o7gzDmCs9URnG2O4Gx3BGeHIzg7HcHZ5QjObkdwLncE5wpHcK50BOcqR3CudgTnPo7g7HEE5xpHcK51BOe+juDczxGc6xzBud4RnPs7gvMAR3Ae6AjOgxzBebAjOA9xBOehjuDc4AjOwxzBudERnJscwXm4IziPcATnkY7gPMoRnEc7gvMYR3Ae6wjO4xzBebwjOE9wBOeJjuA8yRGcJzuC8xRHcJ7qyN7HXot7H6+rc6NuNjuiQ32O4NziCM5+R3AOOIJza4VsXLl2aY5Fnk9zxK5vs2jXr3HErp/uSLs5wxGc2x3BeaYjOHc4gnOnIzjPcgTn2Y7gPMcRnOc6gvM8R3Ce7wjOCxzBeaEjOC9yBOfFjuC8xBGclzqC8zJHcF7uCM4rHMH5MkdwXukIzqscwXm1IzivcQTntY7gvM4RnNc7gvPljuC8wRGcNzqC8yZHcN7sCM5bHMH5CkdwvtIRnLc6gvM2R3C+yhGcr3YE52scwflaR3De7gjOOxzB+TpHcL7eEZxvcATnnY7gvMsRnG90BOebHMF5tyM43+wIznscwXmvIzjf4gjOtzqC8z5HcN7vCM4HHMH5Nkdwvt0RnO9wBOeDjuB8yBGc73QE57scwfluR3C+xxGcDzuC8xFHcL7XEZzvcwTn+x3B+QFHcH7QEZwfcgTnhx3B+RFHcD7qCM6POoLzY47g/LgjOD/hCM5POoLzU47gfMwRnI87gvPTjuD8jCM4PyuEM81wlnsOus4iz59zhOd6izx/3hGex1jk+QuO8NxgkecvOsLzWIs8f8kRnnexyPOXHeG50SLPX3GE53EWef6qIzw3WeT5a47w3GyR5687wvN4izx/wxGeJ1jk+ZuO8DzRIs/fcoTnXS3y/G1HeJ5kkefvOMLzbhZ5/q4jPE+2yPP3HOF5ikWev+8Iz7tb5PkHjvC8h0Wef+gIz3ta5PlHjvA81SLPP3aE570s8vwTR3je2yLPP3WE52kWef6ZIzxPt8jzzx3heYZFnp9whOeMRZ5/4QjPLRZ5ftIRnmda5PmXjvA8yyLPv3KE59kWef61RZ712nhtkNdC4D8VyKAm+F+vJeu1Vb3WqNfe9FqUXpvRaxV67l7PZeu5XT3Xqef+9FyYnhvScyV67kCPpfXYUo+19NhD++LaN9W+mvZddF+u+zZt6zOKtC3QbUPripadvhN9rqJ5iuYrWgBYP5Yawr9I0WJFSxQtVbRMy0iRryin61FRm6J2RR2KOhV1KepWtFzRCkUrFa1StFrRPkG9rVG0VtG+ivZTtE7RekX7KzpA0YGKDlJ0sKJDFB2qaIOiwxRtVLRJ0eGKjlB0pKKjFB2t6BhFxyo6TtHxik5QdKKikxSdrOgURacq6lW0WVGfoi2K+hUNKNqq6DRF2xSdrugMRdsVnaloh6Kdis5SdLaicxSdq+g8RecrukDRhYouUnSxoksUXaroMkWXK7pC0csUXanoKkVXK7pG0bWKrlN0vaKXK7pB0Y2KblJ0s6JbFL1C0SsV3aroNkWvUvRqRa9R9FpFtyu6Q9HrFL1e0RsU3anoLkVvVPQmRXcrerOiexTdq+gtit6q6D5F9yt6QNHbFL1d0TsUPajoIUXvVPQuRe9W9B5FDyt6RNF7Fb1P0fsVfUDRBxV9SNGHFX1E0aOKPqroY4o+rugTij6p6FOKHlP0uKJPK/qMos8q+pyizyv6gqIvKvqSoi8r+oqiryr6mqKvK/qGom8q+paibyv6jqLvKvqeou8r+oGiHyr6kaIfK/qJop8q+pminyt6QtEvFD2p6JeKfqXo14qeUvQbRb9V9DtFv1f0tKJnFP1B0R8V/UnR/yn6s6K/KHpW0V8V/U3R3xX9Q9E/Ff1L0b8V/UfRfxU9p+h5Rf9TpI1BSlFaUY2iWkV1iuoVjVHUoGisol0UNSoap6hJUbOi8YomKJqoaFdFkxTtpmiyoimKdle0h6I9FU1VtJeivRVNUzRd0QxFGUUtimYqmqVotqI5iuYqmqdovqIFihYqWqRosaIlipYqWqZIGzlfUU5Rq6I2Re2KOhR1KupS1K1ouaIVivS76vV74PU71vPvL1ek37ut32mt3xet38Ws33Os3yGs38+r332r3yur39mq34eq3zWq3+Op35Gp3z+p3+2o35uo30mo3/en36Wn31On3wGn36+m312m3wum37ml32el3xWl38Ok33Gk3x90qiL93hv9Hhj9jhX9/hL9bhD93g39Tgv9jgf9/gT9PgF9V7++B1/fMa/vb9d3o+t7x/Wd3vq+bH0Xtb7nWd+hrO8n1nf/6nt19Z21+j5YfdeqvsdU3xGq79/Ud1teqUjfyajvO9R3Cep7+vQdePp+OX13m74XTd85pu/z0ndl6Xuo9B1P+v4kfTeRvvdH36mj76vRd8Hoe1b0HSb6fhB994a+10LfGaHvY9B3Heh7BPQZfX3+XZ8tv0eRPhOtzxvrs7z6nKw+g6rPd+qzk/pcoj7zp8/T6bNq+hyYPmOlzy/ps0H63I0+06LPi+izGPqcgz5DoPfn673vel+53rOt90Prvca6P9F7ZPX+U723U++b1HsS9X4/vZdO71PTe8D0nii9R0jvmdF7SPSeCr3HQK+56zVovSar1yj1mp1ew9JrOnqNQ8/56zlwPSes50j1nKGeQ9NzSnqORc856DG4HpPqMZoes2gfXvu02sfTPo/2AdaTk+IN9rX02Tv47j3vvP4zzzovc97OTO+WLZkLt513WmbnBf3nDGzfqc2+l4E01J9uOH/79m0D2/rPyWzZ2X9uZsfO8zJn9p7Xd1rmgt7t5/dntu3Q2ezoP1f3I3lDSp+ZwffGc3ZesG3H1syOFzLatqNv+/nnbtu5IzPQu217v+698qaUPnsF332927fnsZ57bv85551yZu9Fp2zedt4p5267RHd2eatbYpKvlp7k66Un+VbpSb5TepKflp7k56Un+XXpSX5TepKnS0/yh9KT/L30JP8sPcl/Sk/yXOlJdFdbYpKG0pM0l55kQulJppaeZO/Sk8wpPcm80pMsLD3J4tKTtJeepLP0JKtKT7JP6Un2LT3JutKTbCg9ycbSkxxRepKjSk9yculJTi09yUDpSU4rPcl5kGRu8L3x/M3bt/VltvSe15s5d7tyOLTnsWMeOR7gb5xfVuoLykp9Ezhbcyh14OucNZgLuUgj3Z2emqHExXpnN5SYRnM3PYh3yFDS/EyL/qw555zeixW6Lf0XZXaef15m50Bm887zd2w5FxMeHjfhcXETnho34b1efPncH7fQh+Im/GIZaH9URtqfxQX8q1ITfiiINCduwsVxE7bGTbg8bsL94ia8FhIWW5WU9oa4hb4ybsJ3xkD78SDeBkjbMjLtuedvPu+c3r7zwjM4AjKYFHwfaMZLSY4ulVFKeGLpZZ0St6yzvdKF+skg3qricVKSnlJxUsJDy8C5qXScR8bFuSUGTrLGGyFtSUpKGRxVPKOU5NhSGaWEJ5deVm/css71ShfqN4J4JSgpJekpFScljKOklLYEJaUkJSspJYyjpD8M4sVWUsqgBCWlJCUrKSUsQUkpSclKSgnjKOkTXplCfaJ0oT4RV6hPlC7UJ+IK9YkyhPrbIF4JLZ+S9ECSonBSwjgtn9KW0PIpScktnxLGafl/CeLFVlLKoAQlpSQlKyklLEFJKUnJSkoJ4yjpv4J4JSgpJekpFScljKOklLYEJaUkJSspJYyjpOlgOiW2klIGJSgpJSlZSSlhCUpKSUpWUkoYR0nHlivUsaULdWxcoY4tXahj4wp1bBlCnRykjT0kpQxKGJJSkpKHpJSwhCEpJSl5SEoJ4wxJdw/SlmBOKUlPqTgpYRxzSmlLMKeUpGRzSgnjmNOWclt+S+ktvyVuy28pveW3xG35LWW0/PmlK+n8uEo6vwwlnV+6ks6Pq6Tzy1BSv1wl9UtXUj+ukvqlK6kfV0n9MpS0q1yhdpUu1K64Qu0qXahdcYXaVYZQe0pv+T1xW35PGS2/p/SW3xO35feU0fIPKldJDypdSQ+Kq6QHla6kB8VV0oPKUNJNpSvpprhKuqkMJd1UupJuiqukm8pQ0uPLVdLjS1fS4+Mq6fGlK+nxcZX0+DKUtLdcofaWLtTeuELtLV2ovXGF2luGUG8LdpPsmYqfdm6qRMCU8PgyCt0at9Cz4yZ8sAy0qXT8tHulYwKeGzehHzfhPnETHho34ea4CU8ro0bOilvoBWUUekXcQq8to9Bb4xZ6exmFfqmMtN+PC/gXcROeURcf7SV1MQu9qoxCvxq30O+WUegTcQt9qoxC546Jn7a3jLSvLSPt98tIO7UhftoZDTEraG7chEviJuyIm3Bl3IT7xk14UNyEF5dRle+LW+ijcRN+Om7CL8ZN+O24CX8UN+Gv4iZ8Om7C9NiYCcfFTTglbsJM3IRL4iZcCQmL2POPSdfGLfMiSFhqo7wubqG3xE342zLQNuwSs9BJcROetEt8tG8vI+0H4gL+ZNyEfy8DbU1jzEKb4ibcrzE+2o1xCz0mbsLeuAm3lsHm/s3x0x7cHBPwprgJd5aB9roy0t4YF/CtcRO+qwy0ny4j7efjAv5q3IRPl4E2NT5+2rrxMQE3xk24oAy0+5SRdt+4gA+Mm3BrGWgvLyPtVXEBvzxuwvvLQPuBMtJ+JC7gT8ZN+NMy0P4hbqHPxk04cUJ8tC1lpJ0zISbgRXETHlgG2uPKSHtSXMB9cRNeVQbaV5WR9va4gO+Km/AjZaD9YtxCvx434R/KQFszMX7aMRNjAm6Km3BRGWjPLiPtFXEBXxc34a1xE94DCVtGsnnm+dvP23bW9ovDeb0vbsmPlSHgz8Yt9MkyCn0qbqENu8YvdM8y0k7bNSbgWXETrikD7c1lpH19XMBvjpvwHXETPhw34WOQMFZL/Wzckp8so2aeiltozaT4hY6ZFLPQ2WUUOj9uoQeVUegJZaQ9JS7g/rgJrykD7VfLSPujuIB/ETfh03ET/iVuwvrdhhLGMg+77Baz5Hm7xa+ZRXELPaCMQg+JW+i2Mgo9M26ht5ZR6D1lpL0vLuAH4yb8QhlomyfHT7vX5JiA50PCEhcGl8Qtsy1uwgMgYSwDcUjckreVUTdnxi30pjIKfWXcQh8uo9DHykj72biAvxw34e/KQPu/MtLWTIkJeGzchPOmxEd7Rhlp31tG2k/GZfZ/ZRQ6dfeYhc6JmzAbN+HquAkPiZvw5t3jC/Z1cQu9N27Cd8dN+P4y2PxY3EIfL6PQf5WRtmeP+GkP3SMms5eXUeiNcQu9PW7Cu8pAe8SeMQs9fs/4hW6LW+jOMgrNTB1KG8s1mz01Juo1U+OjXhe30M1lFDoQt9Bryij05XELva+MQt8et9DPllHoF+MW+lQZhf4+bqFj9opfaONeMQudX0ahi+MWemAZhR4at9DTyyh0R9xCby6j0FvjFvrOMgp9OG6hXy2j0G/GLfSPZRT6l7iF7rZ3/ELnlJF2wd4xAS+Lm/DQMtD2lZF2a1zAZ8ZNeHMZaO8tI+39cQE/FDfhF8tA+/My0v4yLuDfxU04Zlp8tNPKSNsyLSbgeXETrisD7QllpD0lLuD+uAmvKQPtG8pI+6a4gN8aN+FjZaAdMz1+2t2mxwS8V9yEc+Im7ICELSPZLDzQXB635GPKEPAJcQu9qIxCL4tb6N1lFPqeMtK+Ly7gj8RN+P0y0O45I37auTNiAl4SN+EaSBir3ayLW/LmMuQ0ELfQG8oo9A1lpH1TXMBvjZvwsTLQjs/ET7u5jLQ7MjGZPT9uwsviJrw+bsLb4ia8IxNfsIe2DKWN1co3tcREvaMlPupz4hZ6axmFviZuoQ+XUej74xb6zTIK/W7cQv9RRqENM+OnHTczJuBd4ybMloF2fRlpD4oLeGPchDvKQPtwGWk/HhfwZ+Im/AEkjGULfxK35H+VIafn4hY6Y1b8QrNlpG2bFRPw8rgJjy0D7Z1lpH1bXMDvjpvwcUgYS4U/F7fkX5Yhp9/ELXTs7PiFTi0j7fTZMQHPjptwbRlojy0j7YlxAW+Om/DKMtDeUUbaO+MCviduwk+UgfY7ZaT9QVzAP4ub8L9loN11Tvy0U+bEBLx33ITLy0C7sYy0R8YFfHzchBeVinZcEKkuNfgN93Z5GW/oqutsOZ8uv7ceMk97wz9pLLhhqOxGjBuE6zB6N3MqCBsDUsqnYeXk0wRhNRBWG4TVQlhdEFYHxTZYl0c2f53fWNv5Zv22hoAPu/lmfZ3vOPv5ZrXaNXlDMs9AOWOhDuiyl5RFnrDsVEBUDoXXwvMeEBcun8ljrg+ex0F6uvOqOSJdA0vXDHF2gXTjWDr6TXVdB+n08WBqA4RZSN+6Gr2htuIBXo/hpQ/Wab11PFlfy4yW37b2n7fh/O3btw1s6z/n0P4zN/efc+5p2846ZvC18ikASwzswRhIecOZeR7ioBHD5xpDWAbSN0Acm4ynQKCUdz3D1AC4LJadQ6Psgew8gwxQNhrPLvbxtA7rOIrAswvgsd9IBo2nAJ9ZNPbPe3aNMjc4aSarZm+kERLqJPK6vQvDQ7+pvCrmymDWeLiNa4R4NQnBSGHY4Ui0wbwjGeRF+ev+ZBWUO8Z+ua0pkD85ToSDyquFON+EuGuC5yb4Hx3jBhYmZRdT3sgBB/0eCxjHAA76lupDxzA8YwyysD4gyA7acgkHDdtLXYiMayEOvaII7mZ64WNqezhQ0p8mkJVwv5pvA41F8EZxjijAWyPjDf0U4o14apTlTWrA1WoacBH+cSAzinN8AZk1hcgM228jPJPMBHjL4UDRYr55mY1nMsO+hmRGcXoLyGx8iMxw8EiyorhpiNfE0o6BOPrzfPBM8bD/kRwDoO0kXj3Gq8ewytSZ31bqGKAZ8Iy3jmewPVMZNn11ne8EAfnpfCcKyWFX+/nmxyx0ZQ21USpnAtTtbqALtnjCsmnOgMqh8Fp4vhjiwlUjw2wBYW+GODiRtCtLR78nggzOhnTcRjSCXNC/kqjzlDfcFmbg90TASGHjAWMtYCO+roQwiUlUHJdx3xr9Corzeoh7bfDcBP+PAX4aWJjURFiUb10PGHF8RN8C45U8nrEMz9gI+eB4hE+I6jDUEfqeAHxRGOkXjqGprYyFMO7r4ZxWM4SRHmD55ANPgDCS8UQIIz6x/FL0RKDfjtQT9DdMeiKAp82Ep5bhwYn0ehaH0tZCnLcE3yZ/TKa/Hxx3UXl8bDIeMFKcByIwmuynadzVzPIQ4i1fRxMZb7UG3ijOOxku/Mj0OYP+i4Qfh31vrTfcjiHvFOcRkNP7gmds39jPPG74nz5RvutEkOVuAjzrfCfbzzfvs00B/jNQDvK0O8jAFk9YNvlsVA6F18LzYxB3d1YPVIeEXbdF8vV2j0jXwNI1Qxz0JyezdPSb6lrL7kPwTHokMzYY7u9yXmqBl0nwTHik5oS5b0E4cK49rM9An47ifCn4Ntks9KfRX6C0lfCn+UIyLv4SRt4fNBp4Rn/a5fngSuHh8sM50ShfhOL8OPgO6wvtb94Y9EX4eAb1ljBSnJ9HYMS8CKfJF+FrMg3e8HmrHiu8Dc7NNTPeagEH8UZxfh3Bm9T8oRDvPs4lki8yxsA7xfk9yOmZ4FnXP9URrif9x/A/faJ8EbT1L5b5I+QpCfNH/4a4heaPtB6Qru8WkW4cS4fzThMgXTHzTv8Hz6RHMrbNPLeE6xjEC8XBdXXqz3BuwLSOLTUfEraOPQYw8vWmsDkxWm9+P/vPKu6u3ID0Rs6pwKfNjZz5OZkgrB6gWPcburKdMnsNcl1S/rNQ/5Q19c1UDq4NU/9k26bifDn2lbhmR897Qly+Psf7VFzTHB+RbixL1+yNnLdMeSPXUOk3+myUDjd3LgnCZPzf3JYkbu6k/Zdb+8/beP7m7dv69us9r/fIc/r7I/Z1LmHYU97IfZ0Up7qvc+gjpVfY95Fd4PsGcMw0N/gudU8Kzl9XaE+KL+PnDMqMj+Fw/YJkRnGWFJBZ2BgObZZpDCfgw+Vk+p9BmfH+h+9FwT6grYDMmkNkhnnyfSFS416Z+e1BmfF1C74XBdctVhSQWdi6BfalfJ4q7Y3sqzNBOF8jpr0uPA8dX2gNQGhvxKDsaTxFssd+X39wbWEd4xk/mBfhrGOyw7EhxRUat+caGR7C6DGMHuNXZk0j14Vrw8Xg2Q3wTLKOZ7DfoDJs7w+yv3YzOBaZIiSH3e3nmx+LkO9IbYvKmQx1i+MAWzxh2eR7UjkUXgvPx0NcuM09j5l0lrA3Qxyc3+FrTXxtS8vgcMiDz+M0glzQNkjUecoLX+OaAhgpbBJg5HsDNF+9gFegj8zPp5ey/n0pxO0Pnpvg/12BnyYWJjlvFjbuRH8G+wrCIzD/6pvGz+MN8qHnGoPMcK6MeMC5PfJtcT2Mr1HqMGpHpraA4/e0AR/hQlnivBR9c38b9wyhftPcw24QxteNaR+Rq/okgKfdhIfXQ8obkj9fu8PxAcW5LvgOWzuyfy5k0CckHeD+OK4vUpwbIzBiXoTT5I/zfXlCvOXtaNgZJuSN4twawZvMHMign2Of9+FrPrR2N97AO8V5LcjpjuAZ2zf2R/cb/qdPlI+LeyAF9vv4Qv5DFv0d0qMpBp7QB7PFE5ZNvh2VQ+G18HwfxN2D1QPVIWHXdUd2f4+IdE0sXTPEQZ9wCktHv6mutezuhGfSI8k1sN1CeMG1O4qD88tS+2q4D0I4JoIcw/oM9P0ozruC77B9RLhOqz/op2CfLbX3N2xPdhowmvZpc57R7z4PcHu2cXdlW6PWIEtZa0R++FojrrOkILs62/xkc1mZ9jWYr0Tfhb4qfaL6FeJN68pkkLFOVM/iS/mnQmunkRfYoP+UhAtspkLcYi6woXZPcXW9mc7VF5NfORfboF80WmcghPxLqTW2rFQ7wj0yHtSjx+RHH9wbr9t+DSTahcXHdmITs9A6QNa0VjKe8Y2+iu22j/uycE6KwnGdZhnExXnvjDdUDzg2p3ZIcdPeyH0JDUXm1wxx0F6Fzffgmt1sKEtqfb2R4aDfuL4usX+z1HuTmgx4LOpUFvfEYVkSbTLuvlK8D0cY47C7XVAnV4mWmzP6FBwH9uvrIO4akI1pL7/p7h4ej+YTTe290nu1TOv0BwG/ZwI2gXsEBriPlfGG14HH8PIxoel+iMOC70L3Q/D5PtxnL92n1DIsuP5McY4swEfYPoIxhryOKTIvzxvuX+K85XiWRxSGNMTB83yYxrTmfhIrg+PcNaS8sYa8Ti0yL88b3q8iz3z9HvVVl4VtFs+F4n7znuA5W95n2NlIaseTGGbkf2vwrWW1HdKhrTXhx34K99lIjLGwv2k24JW3Qea1FW5fomyQ6SzIOUym+Gk0pMV+byvw69nml83vpAzY+PwOn8tJGfaNp9m+8YmGeA3Ad8azOxarF8pXYl621H2/xJtpfqeOxZfZGy+173L4XZh8DyGeIxDwx30sm+wp98lwzyfO73B7YdqriOf19EfXm+meh2Lya/ZG9nVRYyvc/1uJ+Z2we/2w7UvsBy71HqqxBjw294M1eyP3Wku1yVLvMcCzWQ0GjEmYz2o04LFYP77pzJfU3DWOB9HGLRGVuZ+3qXj+POMNH6PqD66hdUFcP3jGc+C4zx/bM+VHz+gj1LO0he4Aovg0NubrZGjrOE+4p0G6n6hlWND3ozirg+9CZwM4H/WGvNYUmZfnDe83cJ6J79VKeyPXAZ5ncbHNNkekw3z1h69poD3EeSWc86BvgbvGhp2Ro7xrGFasz3oWB+cXKM6G4LvQPadUv1HzGVH6RHEOL1De+JDy6g15HVVkXp43XJ9w3YufzcPzAcXoU1Q6LEt/xrE02HchJr72heNaa/2Hn80iJsSP+EzneqTGrbz9c72N0m20aRSnP/gOG7dG9WeXAb+ebX5HcV8C8UnffD63Fv6/AOKhLtofn/pC+w/8rKSvXsodtsSbadxL+eCc24vl7Db2iUk4uz0N4hZzdpuvT+p64/1AQ5H5lXOmOwn7u2TKHmyjuwjlK9GO8MyAB/XoMfnRB3WI72ugfGTvYRxs+wL3u+XbPj/fwu9PwXMgtts+rm3hmgKux9BzDuLy9RJeD7imSXHRR0L7Vkx+uH8T7VXYXcfoB8+DsqT2NYTtrcJ9DVJr+6XsaxBew8mGrRdJtMlS99xjv4Z9iiDGLM7vo072iJbrG30KjgP79f0h7n7Bc9i+BtM5wIshjamN4zpxjxUeh+8hJ/uF9oJ4pDiHAN6dgE2g3ge4X5Xxhte/x/DSeMxURxRnU/Bd7B4APvavRD/C1/VxvZ/iHF2Aj4khfDQY8jquyLw8b7hPiTrK9yBEYcA5SDxThGmQZ4pzSgGck0LK28WQ1+Yi8/K84X0p8kxYcW8Cthlss6b7AWzrT9idfM0G/rcF31pWOyAdti8TfuybcB1MYlyFfcx4A94K2CDj3bXcvkTZIJQ9xaHzJmFzQjwt7+temIPx7PoB1CfVQLkXAy6+PhC2Fw91nT4ZW1i7sh04b8XX/dNYcMNQ2ab5LBFftmtwnGN/X8bgPS72z/MMPx9j2nuJfZ8EX7o/wfNkdYY5xDo2h7gLpDmrt++MNedsPf/M/h3nvXChGgLHsOc986VpaW+kgmO8TPCb54UNth6YQMdOf3TDuHLO4LNIw+jua8eGwQ885bGTEBuG8/TCJZUs/IWLKkH4OvyFyyohvNgJ42HOL4S9sNAGYS8suEDYC4fLYQL6hx6kMWymGsM2U+UXWYk3CBvLjEp+sZ3JMz/xAmVT2DgwKhTWFPzASxOag7BhL4cB/uh7QhCGC4QTgzBsLLsGYbjwMykIww76wOA549kydIMvrTjIdr7BRrFDrOc7aJgPtZ9vfqC4IciLnE8q5yCog8OCZ9uO3wbINwXlUHgtPC+AuBSP5EEOCWHXenZw8HxYRLoDWbpmiHMwpDuUpaPfOKicETzL6GxrVWeDj0s62wlxue7RQHE0dRY3INnX2XYhnW2v6mwJPJWqs+sgLtc9GpiPps7SRZgyOttbtbPBxyWdPQLict2jy1dGU2cpLxmd7RPS2daqzpbAU6k62wtxue7RpUKjqbN0UFBGZwekdLavqrPF81Sqzu6EuFz36FDMaOpsf/AsorPdg/bQvs76VTtbAk+l6uzlEJfr3t7B82jq7LnBs57/6gkm3KYHYTJ63ObL6HG2o6rHxfNUqh7fAnG5PtLc02jq8dXBs9bj/QM9boGwA4KwmUGYkG53y+h2W9VGl8BTqbr9RojLdXRW8Dyauv3q4FlGZ7u6q37F4MclnX0Q4nLdC5ZLR1Vn7wmeZXS2W0hns9XxWwk8laqzH4a4XPdoo/Ro6uy7g2ftL9wf+AsLIOyBIGwhhL0tCFsEYW8PwhZD2DuCsCUQ9mAQthTCHgrClkHYO4OwLIS9KwjzIezdQVgOwt4ThLVC2MNBWBuEPRKEtUPYe4OwDgh7XxDWCWHvD8K6IOwDQVg3hH0wCFsOYR8KwlZA2IeDsJUQ9pEgbBWEPRqErYawjwZh+0DYx4KwHgj7eBC2BsI+EYSthbBPBmH7QtingrD9IOyxIGwdhD0ehK2HsE8HYftD2GeCsAOCML1xh/ZjfDI1+C1yAMzfPJDfv+EN/6TY7ww848ZqicskdJ602bKvd/v2jedsu6D3vP715+/oO2/bzh0pgEiwSUT4H7LwPMTB7T24TQnPMdTCM+6Tw7RjDGHPgzhMvxGf1J40nXfY+4bxXrlq2ZUvW+D8Tw63gNEnqvnimSCJd7eWeiaoXhbPsDNBwvsxI/UA7wYRuMsrh9sDi5E73lluvVuJccYauxWJM7JCfGbxLJvN+5u0rMYzWUWdSZY+75byws86IwbSQdziiXeJJAEjhaUBj0QbiLIHWIe41ZnLrC5hMsPtt4GH+oJd1VgbwV2VsOc6e7xXNmPAge/JWjtnCNv4AFsTw8z5QZlL3D+RgrI8xgO+lxltNIXRM/bjEm44+tccI77XgbZe14fwgXe6TA3kH/aOnBqDDDAfL8irkYXpMiXuCkD+KG/6jXdI4dZ1wiPlX5BOpLzhfQLKotF+2VlJGaOtM8kY70CfF6FDJluGNtUL/ud33jZ4EvfXRNdXQwXL9iLKFrBvObSlHvDvMTz0wbsfBXQsV+oUB96XJeEXCPFZUV90LJNVpX3RsDsv8Gypa5jxTjm0W6Y7CkcTo+m9HFJ9Q5gNwzo0HSPE+5eSJLNhd77BM2E9RNZ/zqFMqb9NM/mh/1wL/vPGAv7zWBZWSd+UfuP4ivgy+ZPoPwv4SznT2I/7Iqg79SF84B2sJxTpP6MM8B4nKttkT6TGv2Ftowm+uV2W9IlIJ8gfwzkA+pbqmwVknNczftcOlzHetXNaAf+Z39nA7xDF8Q7eS4J9AaVNeyPv46Fj5DyPjCfrbwnY/rzsw947Y7pD55wCsuf3iZneA0Pyorhpb/h96pSXDue2hGRP8fDeYcm5jrA2Z7oDX6psL6JsgT6q5DGH6b5ga3j8zX2NXmn33+MReIG7B4e1SZtjFZ2v9XdGK/npfHcVksMk+/nmx2x0XJJsE5WD98xMBl2wxROWnQqIyqHwWnh+ZWooLsUjeZDOEvZmiINjPX7vFP3G93RdnxrKg9vG/DURwTPaBok6T3kj7wbj93c1eyPf8ymi2wXsJN5fZRpn4V1lSZIZjq34mFFjfSOMs6z7e8pemOY1OQ6c1/zc7KG498A4i49j0Y6jzCXeD2Uaw9BvXIuk8Yxp3CG63yCQ85gQjHiNEY5xTXzUQpyHihxnoQzoGcd4Jl9Dag4irP2OB4zEM455pPwuHONm4De+l4P0F6/qMc0hSOwHiJpDSANGPmYXmi+IbGvVsuXWBXB9T39S7HcGnnF+Quq9BKW8K1l4/JTFeUssS6o9hukB2iuJcTza6mLkjmMjAX+svdEbvnZRCA/681JjNQE+s+gr2l6v4uOB8UxWzd7IMYLQWCzSd8W7Z6uYq5hfLJg1Hu6D4ngxnRCMlRxjh/VvWIfkj4wxyKwxYTJDP43Gsei/PwtjbAH/pB1lGvUedopzA4yx/wFjbO5v4pwBylxiv7xp/MrPluAamWnMiX6pgH+Ul3N9CMaou7w5H7gWkg4MgGmMjbzhPI7JdozWXFOTZ76jXnqsSuPpyrzfabDssPfcVMsW6StKHo+g/km0B2x7xeDZVRhPVN0I+z75Mctu9vPN21ha1+DrNbhmQnH2jrCfmBfhJHtKeTaBrCaDzCbb521YfZH9mjAKZXsRZQvUaX7cPMV+vnld2T3Ii3SF8FN5tRBnXgFd2Z3Jh3SF8mwCWe0OMttdQGZRulLJsr2IsgXqNKfz3cN+vnld2TPIi3SF8FN5tRAnV0BX9mTyIV2hPJtAVnuCzPa0z1ukrlB5aeATdSYNceh/2h/D8WcqxIMXwoOQbrTqfKfazzevc3sFeZHOEX4qrxbi9BTQub2YfEjnKM8mkNVeILO97PMWqXNUXhr43BPipiEO/U86x/GnKsSDF8KDkG7kr13d236+eZ2j9wOTzhF+Kq8W4mwooHPTmHxI5yjPJpAVxcW5EeE1gkg9xPkkGkeY5pNwHDNNCGPYONokMxxfcX2k9pNmcan9YNuj+C/W8Xgx73q2vg7E9lpQG6tn9YFnB/oKtLFC+zZwD/+YiHQUH/ec8bmoepYPzkVti8ApOe8XpkP1FSzbiyhbSof4+y2pTlCHKM7ZBXSI2xfT/iTiaWJEOj7mMenQGJYP6tCFBXRIan9WmA6NqWDZXkTZUjrE+3reh2Bf/7IS+3q+LoPz0dMi0lH8KB3i/R/q0HUFdEjKjwjTIfQTCBPqUtobKXfqj3lbyVSIBy+EB0ldJP+SdHEak0ktxLmtgC7uzfggXaQ8m4CnvSPSUfwoXZzG8kFdvCMCJ+4LorRCfn2kfmLZxIvFfSQ+lqHrlrfdF50+B2sPpcz147r5DCE8E0rAg6/Bm24fjy/EZ35dgfiwvReqhclqApNVM8TJgPxaBOSXgnIpb/pN5bmI2TSObYR4ExOCkcLwFQ8C+hxpw7AO+dkBlFljwmRmup+L1tN0//Cx9BBegfna/HnTqVBeBnDgXD7FOQj2u3wqwNYEcXG/y24sTHKPEZVFee/GZKkx0noCrkHRM+53kegDU97I/XZUNs650RxffQgftRDny0X6UygDfl4P9wWjPZE6u8/vT8GzJPRNPFdivpN0gvzAKQZZCOx/Ej27z/evcRnj/rUfFBg78P2FpD+YJ9+7l4aycH4k7Y08f05jO56Hji95dl/ijirTHIJp7yDFebLEOQRsx/TNx3JpiIdn0HU4tyUke4qH+xWk9i9EtTkqT6ifyGGf5AEG/GTgeRLgsa8vuWyjN7xPKIQHz8tIrK0gn7bPz9sfNw2+flZifCjkG+bHTTODvMg+UDnoO88CXbBUto9lpwKicii8Fp5rggOpjd6QDuJYitKSjLC96k8zxBlr4C1jmbcMw0O/Z8XEPD4hmFtYHPpNeq/16K/pIfzcxuv6I91C+5oR4mk6w4vtnjBSGM55ScyrYF9DedPv6YCHxid7GGTWmDCZTQFcNCYjXc3PJ9YM4bW/p8zP27A9oLwM4MB9ghTn1FlDcScH2HC8iGNEvjdVaCzmm8Zi9JvKw/Ei+l18TItziagrUmfyw/bYoD/OeamEHFMhcpQsO6xtT5Cth5Lnj7EvkfIjSznbi/2x9PjKth8p4PdW/dPg45J/urpE/xTtgP644J9GYZ6WEMwtLI7JP11WM4Sf91foa6HdzgjxVIqvhfdPSvmnYX6IyT/dzSCzpPmnOO4gvxDnxA4B/9T+HI9vvKNuKsOG98RdMHMo7kbwT/ncPPaxqKejOU9umovlviiuK6GuSN3R1MRw8/nPJgMvlZBjKkSOkmWHte0m2XrIYZ17wL/H8NAH+z/7dq49W+q9pehrSM1zUhm2/dMZwJ/NfDMC9SLkR7YL+SR52x4sP79g27Ec0pk59uvAx7LJP6VyKLwWnq8D/5R8VvSbKC1hp/ZBcZshznQDbxlPxvemvOn3nJcQ5hkOYq7qRnzMfLxFv8kmahtzOoxduC+DY0/s02cK8ZRheOk3ypjCcHyYEcIT5qNmAA/5nBMMMmtMmMxwnk5iz0fYnP1rayTLHRwT8XcKcBy4T/uLM4bivh7GRDg3rj/o16H+S537C9v7h/vYiR/Excc/jZAGdVBqjM/3cdBvnGfgvFRCjqkQOUqWHWYzhNcCc1jnHvDvMTz0wT4qYx3P4Jz99BLwZACPxN5aqb3iUnPVMn3G4Jy9wNglJ+Tr5G373CAvsu1UzkzQmXnBs+0x0VzINwXlUHgtPD8GYyIaJ6E/RmlJRtQ+KG4zxMkYeMt4MuM9ypt+z4uJuSUhmLmvTr9J77UevRf8Xt5f4ZgW7fZsIZ7CfHmUMYXhGE7KpwzzQ9CnxHfDcpk1JkxmOJ4hvxDHQF8H/9T+fOWgf8rfazGVYcP3Wvx8+lDcb4N/Sv+jb2faayR1NiVsnYTKQz8PfT/ui4adV8kI4Q47r5IBjJyXSsgxFSLH0TxfJFQPOaxzD/j3GB7+LGPnWrONrLxCeNDXEPD3fOTTtn8qMVctY9tbs0J+ZKuQT5K37fODvMi2UzmzQWcWBM+2/dP5kG8KyqHwWniml7hr3SefFf0mSksyygTPFLcZ4sw08JbxZHxvypt+L4iJeZaDmJMiZz4OoN/UVrXu/wF8at7H4pgI+5q5QjyFjRNQxhSG4xYpfzXMd0J/lXyhaQaZNSZMZjhWIl8Wx1fNtUN47c+1DfrU06G8jDdyP04txPnitKG4uwbY0DdFfzTDwqT6/JQ30ueh31Rekzf8TkEK4/5zI6SpxLpDC8NNv2cCxgzjpRJyTIXIUbJsqh/Ke6qhbIF6yGGde8C/x/DQB/sSAd+tD+cAisGD/pHEHk8hez7MR7V97wjvi03zGhRnDshvtPqEKubKYBYqO2vy7UyymGfAM1pzvELz/cPGclGymG/AM7/CssBx34sd81wHMbso5zlVzFXMLyLMVVtXxRyGudoGq5jDMFf9jSrmMMxV3agM5qqtq2J+MWGu2roq5jDM1TZYxRyGuepvVDGHYa7qRmUwV21dFfOLCXPV1lUxh2GutsEq5jDMVX+jijkMc1U3KoO5auuqmF9MmKu27qWDGd8/R1jxjENLQjBSGJ4Xmi2EJ8Pw0G+sQ9rPP8Mgs8aEySwDuOjsBd7fsKBuCK/AGdc2lCmdC+Hna2shzrIpQ3GXBNjwfEUL8DOThWkepO4mprIob/pN5eGZ5ZkQhnjpexYLk9TnsDvHZgNGzksl5JgKkaNk2WFnvoTtSg7r3AP+PYaHPrMBj/095n4W7VUxeLCvkrg/D/m0fdba/p54Pytl23W+AmdK8/voFwZ5kQ2mctDfW+QN6YItnrDsVEBUDoXXwvOGuqG4FI/kQTpL2JshDp4l4ed5+RlsXcT6uqE8uE1sBLmgbZDqz8PO8mJ/zs/3yuh2dF83D/BQ39VikFklfKBSZDYT8My0j2fY3RWUv1avk8C3arFerm98f0aG1UstxPnz5KG4veBbmXwUkz8rdXdqmD9L5eHZVfRb6BnfpSvRX6a8kXdYUdlod0jf6kP4qIU42wP5m97FibyhrzifhQn1F75pLEu/FwBG3uYkfbdMkBc9ZwyykCo7zNZUouwMK9vEt3Ub62/uw36U3/NH5dVCnEsj9NnUJ5PNwTZOPC2Q5C2QK8fDeUO/pZ7FWQD8U5yrI/jHd2Mjb1JtNwM8ZOA3li1gy/PjnAWM9xT7nYFn9GUW2cfT0egNt9uF8CwCPAvt4/GF+MyPRxYHedk+/76EyWoOk1UzxFkM8lsiID/TmIB+U3kuYhYqO19/S4uQxVIDnqUVlgWVVyrmxVXMFcGcBN3Ae7gIayPEW5AQjHx+Q8juR/qHWIemsfoieE6SzDKAi8atpHvaxfoAjKkF7t/I4diH/F7CgXdMU5xv7DYU9yMwpuZ3tiE/qKf25wWi53CoPI2R39vdxPDSdwsLa/CG6sk27haGG+VDGE3rPtJyTIXIUbLssHuzK8m354XrDz3j/It1vzkYi5J9oDZJZeMcMsX5WoGxKLdHCwy8ZYLnRZXmN8Rmcn51HPIj6lmcRSATivO9CJmMZvtJA8YMfKchDo5t0t7IOc6MN7ptoYHxYKXsQO+x79N5L2IyqYU4vyig93xcRHpv0vGo8RT3b0y6yMc4qIu/KXKuRHh8FKmfVF4aeEH9SkMc+p/0k8sw44n5gPk5F6wf4gU/GXjGOQ77/l5bFn3LYvAsBTzW21Aw50Jl2F5bXmYfbz7frEC96Hx9+3jbdL6tAnLQOtMW5EW2j8rJgs60B88pz65daIN8U1AOhdfC84T6wW+t+7kgrBXSU1qSEbUPitsMcZYaeMtY5i3H8NDv9piYlzmIuSrn+JhbWRz6TfZFt9d/wf4K3k/qdkJtGPv4nBBPWYaXfqOMKQzn5uzb4Wh/Mgt4aKy9wCCzxoTJDPcO07wI6apWg+n1Q3jt+0CD6/OLobwM4DCNhW6eNBR3ZoCtyRvps+J6FupppdYk+b4ljZF8blyHR7z0PZ+FCe19idwrYJpXml9BOaZC5ChZNtUP5b3QULZAPeSwzj3g32N46IN7ouz7sYN7TGeWgAf7Nol56Er467bXXn0mq5lMVs0QB31iAT8/r9vLGB767cuWnTX5JSZZ5Ax4pPrHMFlQeaVizlYxVzF7VX2uYq7qc7a8T1XOVcwVxVzV55cOZjzDjfMeFG9+QjBSGM5zCox/IuctsA5pHmKJQWaVmM8qRWY450ZzRji3eQPMZwmM5dtQpjSfRTioPNx7f+CuQ3FvgfksiotzQUtYmOS+L75uTL+pvCbgawmE8bmrRkiDuiKlz3xfJP1eBhg5L5WQYypEjpJlU/1Q3osNZQvUQw7r3AP+PYaHPjh/JDAH0Yf2qhg86BNIrCNIzbWgDbY9n8XXjfj8UTPEyYH8BNaXfdP8Gv1ulS172Np2lCzaDHjaKiwLXAcvBXOuirkimKu6UcUchrmqG1XMYZiruhEPM56JwvErxVuaEIyVXBcMG+dhHdK4bb5BZo0Jk5lp/we1Fz3GfhLG/wL7CNpQpvy+Hjx7T3FaJw7FfQrG/5QGx86meSGpfU5hcy5UHo71cWzNx/phe5+k9Dls75MPGDkvlZBjKkSOkmVT/VDe80eBby+CbwEdyKG+eSB7j+GhD4717Y8X/U60lcXgwb5dYj4V+bS9p96+/fc7pfbL6nw77Oebnx/oDPIi+0/ltEHddnlDumCLJyw7FRCVQ+G18Dx2zFBcikfyIJ0l7M0QB/fHd7B09LsdZJAaM5QHt8eNIBfT2YCMZflwn7WN4a20zxpmJ9G3oX5zqUFmjQmTGc7lSuzZw3UQ3Ke8x5ihcu3Pp/udKVZexhs5l18Lcf42YSju3gG2MP/I5EtLraWF+dJUHq6PoM9Ez3h+VqK/THkj15X53C7qZH0IH3jGZ14g/wneyA+eWUQZ8HXrpNkprBPsV6T8ubB1LNO5B9Rxk+8vZUvDfH+0paazKxLrb6We7RReD8ziWR7heY6SfXDUXwGfLIdttxg8HYDHJd9T50u+ne31P+4ftjFZoX/YCfLrEpBflN+JfrVrmNE+oX9H8bIJwch9fNPclPZ7NoFPJrAWm7/vB8vLAA4qrxbiPAY+2VEGnyzJfT3xU4m+PuyMKM79mfpRAfnkTPLJMvmg3tZ75r6/FuJsLuAPLmFpJfulUvpJ7JcE2n8b2ppi8HQBnk77eHwhPvP9ZHeQl+1+cjmTlcl+UpxukN9yAfmZ+kD6TeVVMVcxh2FGf4SwNkK8bEIwVsiHy6KfQ/lrX+Ja8HME+on8miLOp2YAB5VXC3FuBD/nBvBzuE8T5ltK2PIo35LKawIesK+T8nP4/R3tTBZhfo6AfNpM8sky+WB74H4O6gHFub1IP0fYryjZz0G/QsCudKENKwbPcsDTbR+PL8Rn3s9ZEeRl289ZyWRlsssUZwXIb6WA/Ex9K/2m8qqYq5irmKuYXwqY0W8nrI0QL5sQjBUa6wzz2yl/7Rt/Hvx2Ab+nS8uB7wXh4wfcj7EJ/PYvg9/OffSwMZiEbxI1BqPymoAH9N2k/PZOhqeTySLMbxeQT5dJPlkmH2wP3G9HPaA4PyjSbxf2k0v229FPFrArXWjDisGzEvCssI/HF+Iz77evCvKy7bevZrIy2WWKswrkt1pAfqa+lX5TeVXMVcxVzFXMLwXM6LcT1kaIl00IxgqNdYb57ZS/9o13aRgqV2J+UMuhG8rLeCPHD7UQZ0/w25sDbNoH5T562BhMwjeJGoNReU3AA/puUn57N8PTzWQR5rcLyKfLJJ8skw+2B+63ox5QnL2Cui/kt8vKenAPLbaXjDdS7xB3JgK3ySbkGB+4Zxh9buk7LizmmzPJzLSnmOLMK1FmtMcI91QvN8hM6syPQJvOy2wVkxnfN10LcZYWkNmqEJnhvmySFcVNQzzsg3Q47VvCd4ikIR7uSRPad9tmkhE/b4wy6ixRRrSmi3pFfKFPI8VblvGWM/BGcVYV4C0bwhvWP/GUleUtJ+Rj5WW2D5MZ4V8NMqM4+xWQ2T4hMsN7ukhW+4DMBHhrbYC8LOabl9kaJjPC3wMyozgHF5DZmhCZrQaZkazWgMwkzi1on7DdgNFjGOmDZxkoHZ5hXWMfY8n751Fma4XwrCkBz1rA02Mfjy/EZ97X2TfIy/Y84H5MVmuYrJohzr4gv/0E5JeCcilv+k3luYgZz0US1kaI15YQjBTWAxj5XS7a7m6DcbfAmCyHczZ83E3l1UKcX48finsmjLtXMPniGUuUudQdlGFnLPGeDNP9w1Ln4sLeC9UGePiZAyH55Ezy4WeHdRzyX+o9s5+L5zouKTDuNvWTUufe4vTlQv1SR6n9dg/gkTgTKcRnFv0e2/0kt59tTFZoP4X9nnxb7mF46DeVV8VcxVzFPLqYsc9BH4TitScEI4XhefAe+3jy6zh8vK59tvvAnxTwNTpS3sj30BIOKg/viXgX+JNvB3+S9hfheVeTvyR1p1nY+VCc8zPdMSR1XrXQnT9C/pXUe5DzPim/28Xkb1Kc9xeYX+J3+vDxCJ5zEb773JeaH0UbEzWvTXE+WkBmPSEyM93bR3HTEA/thw6nMQ6ef0h7I98doeMLjWc7TDJqY7hQRp8pUUZkl1CviC+KK8kbP3vvG3ijOF8qwNvSEN6w/nuCZ4qL9d8DaXFNiNc/z0PHl5rPEJqP7UCfiGRP+Km8WojznQKy5/5VJ5Md3pGAc6kCvLXinKfFfDtw/pBkRvj3BZlRnB8XkNl+ITJbAzLjc21pKAv9vrQ3ct6S9JXnoeMLyahN57vOfr552a8P8iLZE34qrxbi/LqA7NfD74w3JHvKswnkRXGFeGvX+e4vJLMDmMwI//4gM4rzTAGZHRAis3UgM5IVxU1DvPWQVofzs7ukrxQPz0ELnYuO3FOEZ1pfqmULnFPOlXpHCJ7JP0BAFo3e8PMghfAcIIwnqm6wbAGbkd/TdmCQF/c30WZQnJqxg99hNuNAxgftZ0R/k3g6EHg70D5vw+SaYnKtZNleRNlSdXpQkBf3s7FOKU5TgTo9iPFBdYp+NvF0EPB2kH3eIuu0kmV7EWVL1enBQV7cf8c6pTi7F6jTgxkfVKfovxNPBwNvB9vnLbJOK1m2F1G2VJ0eEuTFxxdYpxSnpUCdHsL4oDrF8QXxdAjwdoh93iLrlMpLA5+EqycIP4TJgXxFjr+nQjx4ITxI6sahQV58/IO6QXGWFtCNQxkfpBs4/iGeDgXeDrXPW6RuUHlpeCZczweYNsDvnjIxDQQfne9hMfIdKPDR+W4sH6/PAzyQQxqeqaxi/jfFPQzS7M/iPc9+6yPHVEeok/T/qgidFGo3kW12fyhbQK/zbZZ45+PvQw3y2bdAm93I+KA2i+NvXkeobxl7vHXotb9OQ1mjZR8qUbYXUfZh9svOj5PRThP/HsNDn8MAzyYhPIeVgGcT4NlgH48vxGd+jfDwIC/be4GOYLI6jMmqGeIcDvI7QkB+KSiX8qbfVJ6LmDUeajeEtRHiHZoQjBS2AfAI6HOkDcM65HeJosw6EiazbsBI+zFwn8bpY4fwCqxz5Neu10F5GcCBa0EUZyfsC9kRYGuCuB0GflDmUud7+fl2+o3jfhov4tkWesa5WYG7cfJyXhGCEX0Cfqcl5wPvtLw4ws9CvwZlQGFkO7Ce0J5I3akfVk9dgJHwrgY8Uj4R6QT5Y2sMshA4H5YVkvGwO+LrQmSM+7yuL+Cr8/1WpD/YhkhWpne6ZTy7fpLUnqcNTGZ8LrgW4ryigMw2hMgMdZxkhX2mlG0M03EqD/tMsuON8L/wOppvso30uxMw8n0daNPxHWIdLExStmH7/9Dm7muQo9RaKJVFdT0aZXsRZUvsLSp1HRbvahEYz3Vj2ykGD9oAqXdHCPA5bA+q7fHlYUxWK5ismiEOnmUSmL/wTTadzytWMVcxVzFXMVcxJxMz+riEtRHidSQEI4XhfITEnHOUv4Z1SD70GoPMGhMmMxy70HwVnqH/EcylrbGPtxtlytfJqLxaiOPDXNrPDHNpOKZZzcKSPJeG70UWmEvrlphL+12BubRxBhnw8THeRV6JMXPYXeT4DiE+9yM5/gubZ8B3jJL+oo6bxutJeKfnGsAjYC8i21q1bJn1jlLvS8K7cyTaTaM3vB8uhKcS8zhhdSP8bqyskK3M9xd4d0/GG2krayHO2F0Gv8Pmd/mdLdQP4PwuyQp9X6kz0XjPcwZ+V7JsL6Jsh+a0unFsQ7pC+Km8WoizWwFdCRsnYR9NssJ9LxL7cHTftq+hLKnxRZhebqhg2V5E2QL7yXI4PvKAf4/hoQ/uOTvcPp7ORm/4frtCeHDfi8QeDiE+s7ifw/Zc9JFMVhuZrJohzhEgvyMF5JeCcilv+k3lVTFXMVcxVzGXihnn0ghrI8TbkBCMFIb7cgX6lEg/AuuQxpMrDDJbkzCZ4TwizU3i+7sP22UIr8D8YifKlM+Rmu41fbZ5KO4RATac11oD/HSzMMl5pLB9qKZ9bPhuQHrGeQWB8VGnaX6QysZ3aNM4oD6EDxzrnBwx1sGxBcqAnnHN4DAWJuSL+8gf5U2/NwJG4rkSYyJ8n0rGM6+bkf5iW6X/UbeTsOaCe2mk1iPC2lq1bJG9qblS9y/hPl2JdoPrX8XgEZ5fyDZ75vkEqfYYpgdor6TmMko5JyU8l5GrzmWU96mOoyrnb3M/A8cEhyUEYyXHUWE2DOuQr6OgzFYkTGZ4bovGL3iG4E4YR0mdJ+JnFtYxbHhm4QMwjrobxlF87IV7GFDmo7mHwTS2omf0PST6wJQ38h3rVDaVp+NQG6r3wtcXKc47CoyjVhtkQM+mc6BoT6Tab9iZxsMBI/GM9kTaJ6JxlMknkj5TbTHfvJ5R31UXIuNaiPPBAuuO/Kwz6Q/l2QSyorhpb2QflQnC+bloureG56HjS+mhkO3Py/6oIC+SPbf9tRDnUwVkfxT8znhDsse2QvKiuGmIh7LU4dyWkOwpHs5xVWLOi7c53Fs2WvNtQn1UDvtDD/j3GB764L5dCV0t9Y7HIwHPUfbxSLXJvJ09OsjL9hjoGCarTiarZohzNMjvGAH5mcY39JvKcxGzxsPtViPE60oIRgo7CvBIjS/CbBjWIfnc6wwyW5EwmeEYiMYZ5F/ofvS3MAaSuMcHx2zUb3MctRDnQhgDPQNjoE1MvsgPylzgzuzI+Xa8D4vGGhsgjJ5xDCQ11lwXghF9Amrn9SF81EKcfxQ5BkIZ8PVK7AvRnki1Xz4O5DYY6wT9ACmfCMefGfgt7BNlK+mHcxmjH14bHBgo1g8n/cFxNckK/XDeR2WC8KMYFvLDeR46vpQeol9kMd8c+hgke8JP5dVCnOYCsuf+yjomuyaQF8VNQzyUpQ7ntoRkT/FwnUdy/TaszVViTyu/N9FUtkAfVfKe1nWAR0JXcc61GDzS/rAQn3k7e2yQl+0x0HFMVuuYrJohzrEgv+ME5JeCcilv+k3luYgZ90mgP0/xNiQEI4UdA3gE9DnShmEdks+9ySCzFQmTmWl9j/wL3Y92NA7hlRoDHQnlZbyR63q1EKcbxkDLA2xN3sgxJq4voMyl9mmFrS/gPi3OF47dcAwk0QeadJfKpvJwjF8fwkctxFkX4UMhb7h3jp9FkmyrYeOdowEj31Mo6f9Q/ZPvZdqXLDXeqZTPzWWMPvemEn1u0h8c75CspG09+i4W882hH0AyI/zHgsxe8AMKyOy4EJmhjpOsjgOZCcyzROp4dwXL9iLKFujDOk11SvYS+zCKs7nEOqW+zbTnN8q/5L4J9lP1LM5xgJPinBaBE+e4UK+kfJowvUKfhvp5klcj/C+859Q3yZ9+rwaMFIZrqfxeSJwzX1MB2YbNmR8HGPl6ciX2MfG6xnUGksuKhMoM1xmwrgkbnp8Q2Gsw7C6f2iDvNQyPjHz8vlL3X6P9kJpzFNCDLNqSBmv5tht99RVMVs0QR3gPWaRtM73fxJ4sOtqxz4qSxSYDHqk7/MNksclQtkVZ5Ms+tghZHGvAI+DLRsriWEPZFmXRpss+vghZHG/Ac3yFZUHllYp5YwIwN7BnO2V35m3cCUXI4gQDnhMqLIsTDGXbk0UuP599YhGyONGA58QKy4LKKxXzsQnA3MCe7ZTdkfe1TipCFicZ8JxUYVlQeaViPtZBzCckAHMDe7ZTdke/LvvkImRxsgHPyRWWxcmGsi3KYkCXfUoRsjjFgOeUCsviFEPZFvvVvF90ahGyONWA59QKy4LKKxXzCQ5iPt5BzBsdxLzJQczHOojZxTaYBN1oYM92yu7o02X3FiGLXgOe3grLgsp7KWA+wUHMxzqIeZODmE9xEHMS5IzvINhjnCQef0sjw0My8xhGj2FshGdc39gcPPd49tYhsH42Q1l91uUxWD9cX+h3n2jZfp/Ot1+AJ53vgP188/N6W4O8aF/AgEFWpwXPKcv1tBXyTUE5FF4Lz5PHDcWleCQPsgeEXa9jbgmeETtP18vSNUOcLZBugKWj31TXWnaN0M4ldKsYvdb7IKgtTwNZrAme8X0nm1mYpL3czHDT717ASPYS7cNmITxh73Ck8vA9GmsSKrNmCMO1+kYhPFMYnikGWUiVPYmVPamCZY9nZY+vYNljWdljK1j2VFb21AqWPZ2VPb2CZc9jZc+rYNlzWNlzKlj2Qlb2wgqWvZiVvbiCZc9nZc9nZTfBM753y/q7c/zN+T6eyqA9Ufx9TkLjiL5S39vTC3gk+mmhvtV4NmsN4wn3QeLeJam9er0MDx+XlYp5o4OYNzmIuRJn4Kq6MXxtyhXMJziI2UV9PtFBzC7K2UV9PslBzCc7iPkUBzG7qM8u9oNVX7QymKt9SmUwu6gbp1YxVwRz1eevDGYX26CLPlIS5KznQWlO9MvjJPEM7qVAPCQzj2H0GEbcg9ELMqN12R7P7l4KKgvX6LdYl0f0XpctomUP7qUQ2POQn1feaj/f/LzyaUFetJdiq0FW24LnlOV6wn0OKSiHwmvh+Quwl4LikTzIHhB2vf5B+xwQO093HEvXDHH6Id1Wlo5+U11r2X0C2rmEbhWj13ovBbVl2ktRXV+3X3Z1fX0w7+r6unzZ1fX1wbyTur5eB//1sTBJH7SPYaTfxwFG8kFl95AO4qGyUkHevOxmJqskyqwZwnDfxDghPGH9ZyXKDus/K1F2WP9ZibLD+s9KlB3Wf1ai7LD+sxJlh/WflSg7rP+sRNlh/Wclyg7rPytRdlj/WbWpVZtqu+yqTa3a1EqVnWSbiv5+DeCxPkbyN+fvBqEyaM8vlY3jM4H57vyeXxor0CfFfmfg+TjAIzH2ERqv5OdmexlPdYwnPKOIe357BfhMeeHzj71QD6Vg3ugg5qSeiY7CnNSz5y823TjeQcxJvUvhxabPJzqI2UU5u6jPJzmI+WQHMSf1bpAXmz672A9WfdHKYK72KZXB7KJunFrFXBHMVZ+/MphdbIMu+khJuT+N5kQfbJLEY//+NNo/2OPZ3fNLZeFe0n7r8ojek90vWvbgnl+Bvbn5eeXT7Oebn1emPa605/c0g6xOD55TlusJ9+OmoBwKr4XntzUNxaV4JA+yB4RdR6X9uIidp+tl6ZohzgCkO42lo99499yboJ1L6FYxem26P023c2pztRBGaRsgDO0phVHeu0IYyWYyhJEsdocwktOeEEb1uReEkczTEHZG8FwPYduD5zEQdmbwvDeE7QieJ0LYzuB5Fwg7K3jeA8LODp5x//I5wfNuEHZu8Ix7jc8LnidA2PnBM+4LviB4boKwC4Nn3MN7UfCMdXlx8Iz7bS8JnmdA2KXBM+6NvSx4ng1hlwfPuI/1iuB5FoS9LHieC2FXBs9zIOyq4DkDYVcHzy0Qdk3wvAjCrg2ecW/pdcHzTAi7PnjGfaAvD54XQNgNwfN8CLsxeF4OYTcFzysh7ObguRXCbgmeV0HYK4LnLIS9MnjeB8JuDZ7bIey24HkZhL0qeM5B2KuD5x4Ie03wvBTCXhs8r4Ww24Pn/SDsjuB5PYS9Lng+AMJeHzwfCGFvCJ4PgrA7g+eDIeyu4PkQCHtj8Lw/hL0peD4Uwu4Ontsg7M3B8xIIuyd47oCwe4NnH8LeEjwfBmFvDZ6PgLD7gucuCLs/eD4Kwh4InjdA2NuC52Mg7O3BczeEkY3bAmHkK6JvRrYaz2hRP9cPYWQfByCM7ONWCCM7fxqEka3ZBmFkH0+HMFrHPwPCaI1/O4SRPTsTwqgv2QFhZAt3QhjZzLMgjOz32RBG/dA5EEY2+FwII1t9HoRRf3U+hJGdvwDCqA+7EMKoj7gIwqhfuxjCyC5fAmHU110KYdRfXQZhZOcvhzCy31dAGNn5l0FYJni+EsLI3l4FYWRHr4YwsvPXQBj1EddCGNn56yCM+oPrIYz6kpdDGNngGyCMbPWNEEa2/yYIWxQ83wxhZPtvgTCyDa+AMLKPr4Qwsre3QhjZ79sgjGzIqyCM7PKrIYz6iNdAGNmu10IY2f7bIYxs1x0QRu/jfh2EkU16PYSRXXkDhFG/dieE0f3Cd0EY9XVvhDDq194EYbSX5G4Io37tzRDWEzzfA2Frgud7IYz6prdAGN0N+FYIo/7qPghbFzzfD2HUhz0AYdS/vA3CqF8jm6xtn7ZX9D5UtOUbWVgDlJ3x7I6B+HtI6TeVpzHyd282wTO+n7ebhWncAu+7z+PuZrjpN75LnnjohjB6Jr1KQRqeF76nmN6xXR9SXi3EOSDodEzv1W7wRN5nn39HOfX9NJYmbEcDRopzSARGzItwbmT8oiyPAd4E6jtn4u1whgd5O7yA/I8RwCip61h/Ou9NBt4pzjHNQ3I6LnhG23UkyPE0w//0SbHfGXjG+j5OgGedr8D7UPPzTScA/xkoB3nCd2Da4gnLpvkm/r7PWnje2jwUl7+Hk+qQsOu2SGsSUe/vXMfSmd7fmfJGvsOWflNda9mdBHpGeqRlJ/V+6mNDeDkceKE4ZJc0Hql32PN3VvN32GMfVc/iUNpaiHNWhM3Sf5EvQHxjf4t+goBti+xvjwGMFLYRMHKetb50BAO6Jvgfx7wbWVjV/ym+Pmz6PxsgDul1lP9Dca4v0P8KtMm8/0NzJNz/ORIwUpybCvg/R8HvjBft/xwFvAnYv5yJN6qbjQbebisg/6MEMErafqw/nfcmA+8U53bol14H/g3V2+EgxwcM/9Mnyv/B+pawtzrfY+3nO+zudtKjYw084fvsbfGEZZP/w/2KWni+H/wf7o9QHRJ23RbJ/0XsPF0nS9cMcY6GdNzXoN84BrkL9OwB8H+k+qmjQ3jZALxQHPR/DhfCw/0fwoFjZu7/UByT//PuAv4P+QLEN/a36CcI2LbI/vYowEhh6KNxnrW+/DaY5G6C/3FtoIuFSfoRVBblzeWM/VwXhNEz+j/cJ2oAvjNeZfy2TYCReDD5bej/bArJax3EIb2uDymvFuJ8pkD/K9Am8/4PrSWRbSdshwNGivOFAv7PEfA74w3VN8qXZHAE8NZln7eciTeqmy4Db18rIP8jBDAK8e6j7pH/023gneJ8G/ql74J/Q/W2AeT4K8P/9Inyf7C+Jeyt0Bxp1jSPeLSBJ5wLscUTlk3+D/crcA7zl+D/cH+E6pCw4zoCYufpNrF0OGeC8xbc16DfOAb5IejZr8D/keqnjgzhZR3wQnHw/ES3EB7e//Cxto5D9VTP4uC4heI8U8D/IV+A+EbfAv0EAdvmIy+UN/0+AjBSGPponGetL3eC/0P9MK5/mea1pGxrmF+Hvg75M6Z5lDWAu5OFadyHCeHmczb0+zDAaPLl6Bnf4XlYSF7o/1D91YeUVwtx0sEGi7D+V2CeoBv9OLLthA3bG8Wpj8CIeRHObsYvyhL3fAvYm04Tb9zeIG/jCshfwCfvrIStJf9nhYF3ijNx/JCcJgXPum1Sva0GOc40/E+fKP8H61vC3grNkWZN84hHGnjCuRBbPGHZ5P9wvwLnMFvGD8Xl/gjVIWHHdQTEztMdxtLhnAnOW3Bfg37jGGR30DPSo0qMATgv6P/wNXGNZ4UQHt7/EI4VIEeqJ+7/4JoBxVkYYbPQt8B5Eu47SM43rPaG80u/NwFGCsO1LM6z1pfDwP+hfrjDwFcH8CVVj2F8UXn4/vPVELYa8NJ3NwtLst+Gd8R2heSF/g/VX70XPganOD0F+l/rY6Tg3be0X5BsO/f/aiHOfgX8Hx9+Z7yRuo2y9IE3gfruNvFmmv+hOAcVkL8vgFFS17H+dN5rDLy/4I9Dv7QJ/BtqC/uCHE81/E+fKP8H61tifCM0Rsia/OiNBp7QF7DFE5ZN/o9pPwg9nwL+D+/7qQ5xXtu0/sLTrWDp0GfAtf6wuXWqay27o0DPTgX/ZzWk6wmes+V9jPMPxAv6PxQH17+sv2c8wLOG4SEcOK7m618Uh9Li+tdpBfwf8gVM+03QTxCwbZH9rQ8Y+d6SRgPPWl9+FBz8wD0qeP5mDQuT9H94PdJv9H/2ZTygT4R+m6k+kur/UH8R5f/gGhmdJ4jyfyjOFQX63zb7MumK8n/aACPFubpE/4f3uWH+zxr7vOVMvFHdrDHwdkPl/Z+cEO8+6h75P/saeKc4r4B+6Vbwb6je1oEc7zb8T5+q/zO6/s+bIvwfvqZQrP/TxdKV4/+8BvTsbvB/pPqpDSG8rAZeTP6P1H6kfRkewoFjZu7/UBxKi/7PAwX8H/IFcG6F0qKfkAT/B300zrPWl9PB/yG7heeyl7KwBuAlY5kvKovypt9Uhsa4LHim/0zpVjN5oO3g9U9payHOBwv0WQJ9S95noPOAdYx/7FsozqMFfIa18DvjDfmBlGcTYF8ry1sHttEon4HifKqA/AXGUR2SPsN+wKPOe5mBd4rzWbDlnwefgOqtDeT4PcP/9InyGfYFWa4X4Fnnu7/9fPM+wwHAfwbKQZ4OBBnY4gnLJp+ByqHwWnj+LvgMFI/kQXVI2HHsidh5uqUsXTPEwb5uf5aOflNda9l9GfTse+AzrIV0PcFztrxPXnbrQnhBn4HiULkazzIhPD0MD+FYBnLk48zVDB/6+j8r4DNQ/4l3lPD+VnKOqM0bzi/93hcwUhjemcJ51vpyX3CBBq694P0kORYm6QtRWZQ3/abycO4hJ4unC30Rsk/LGJ5aiPPHAn0492uoD18GvBFPS4G3Hvu85XB+ivPWA7xRnL9W3ofKSfqma4FHnfcKA+8U519gW/9j6KNx38cuE0b+T5+oPnwNyHI/AZ6Fxmv5Phz7oYw3cl4W/Qfbffh6yBf7SgqvheexE4bi8j6VjzFxbhax83RLWbpmb6QPY+ov6TfVtZbd/0DPSI8kbe2+IbwsA14oDtpaqXkIbvsJR9S+j2UMH+772DWQYVgfTv0Z9uG8/5McR4Ttj1gDGPnYt9HAs9aXbdCH01xBFtKsYGE6+kohvlYwvug3lacx0l0+WLc8HfHZBXEoD17/lLYW4syMqH/N/yrr/PudWK91jP9VgJHizI3AaNKRHOO3CfhdLcrboD+0D+NtmYE3irO4gPz3EcAoxPuwMQb5DMsNvFMcf8KQnFrBJ+DrZvr/tYb/6RPlM+wDspQY5wmNX7I4h0J6tK+BJxwD2+IJyyafgffFOH+zBnwG3odTHRJ2XLtF7Dwd3y+DY+U1kI73z/Qb5xU7Qc/Wgs8gtVdiTQgv6DNQHLJLGs9yITwrGR7CsRzkyNcKljF8uFZwUAGfgfpP014J7FsFbFvkWsE+gNG0V4LznPcxwWfoZDyE8SVVj2F8UXl45gTPQfF0xGcHxKE8eP3jHn+Kc3yBPsu+7zvoM2C9ZLyR6z3o15xcwGfgbSLH+EX/a6Uob4M+wyrGm8lnozhbKu6zDfoM0nugyWfoMvBOcbaBLT8DfAK+r0b/f4nhf/pE+QyrQJY9AjwLjZeyOGdDerTGwBOOuW3xhGWTz8D7Ypwvuhh8Bt6H83N8ui2S7UbsPB0/E4hj830g3RqWjn73BN9adjtBzy4Bn0FqPLhPCC/oM1AcskuS5335njTCgfvWwvoM3JNGca4u0mfAMwyUFvtWqXHLcm84v3zc0uyN7A8aDTzn1zCDC7i13rYzHvCcKvIlvXed8u5keDVG8gOwbnk64rMN4lAevP5xvzzFeXWBPsv+2cVBn4HqjN9JZvJr7ijgM3AdyTF+0f9aLspbtg3ngrjPgLxRnDdW3GfLtgnxPmxMQz5Dh4F3inMv2PK3gk9A9dYOcnyv4X/6RPkMeOeOxLhSaLyURR+A9GgfA0845rbFE+ZFPgPvi3G+6BHwGXgfTnVI2HVbJNuN2Hm6TpYOx+arIB3vn+k3zmO+DfTsveAzSI0HV4Xwgj4DxcE7utqF8HQwPISjHeQY1mdQWuwzHi3SZ8D7Ligt9q1S45awu7tWAEbeHzQaeNb6ci34DEsZD7hvAvmSqsewfRNUnsZI7zxoE8Uz2IejnDLeSL2qhThfKtCHcx2lPhz3FxBPeI5E6l71rhDeTD7UNwr04RJ3f0mOMbCv1nm3GninON8F2/p96KP5Hk/9/1OG/+kT1YejjZSwGULjx6xp/milgSc8T2SLJyyb+nAqB9d86PnX0IfzdTuqQ9MaKGLn6TpYOlwTxjluPudHv9GP/jHo2VPQh0vZ2uUhvGAfTnHQ1rYK4eG2n3C0ghypnngfjueEXtjvVWQfjuf4eP8nOT4O23/fBRj5eYBGA8/5897Qhy9jPOD7hJCvnBBf/Pwc/aby0M/AfYO4h4K+W1mY0BnCPO5Whpv7Gbj/rxXC6BnvlWgLyWsJxKE6rQ8prxbi1E4c/A7rf63biOBeCe7/cH8M/Z+GCIwm/8dn/KIsZc81m307qhvfwFtzAfl3CGCU4X1Q17H+dN5LDbxTnEkTh+Q0OXjGccEykONsw//0ifJ/pM9NC80HZU3zfKaz4LiPyhZPWDb5P1QOheMc46yJQ3HD9nLhGiT5wlF7wNpYumaIg3O6hc6sa9ntCXpGeiTZT3WG8LIEeKE4ZJc0nqVCeHj/Qzjw7B3VUz2LQ2lrIc7iCJuF/g+eJeC+g4xtG+R3mTecXz430eyN3EvZaOBZ68se4P/MD8Jx32iWhUnaViqL8qbf6OtwOTd5w/01+s6xMEn/O+xsB/o63JcbTT9SSBY5lDt9ovoutA0CY7VW9IOLwYPnmyR8ZSE+s2hrnvfs9tHc1rcyWaGtF557G+Z/Ud70O2odtIrZPmaNh9s5fF9uLiEYKUx2zjva7mIdUn+UNcisMWEyw/tNBPr8LPokeFdPH/iwWfvltqa8kXcDLWH1gncDNe46FHdrgC1s3mUJC5P0O6gszzP7tOgbLYEweh4HGAX6u9Yo3xz3pPD5HJNvTnHOKeCbjzPIgJ7RJzTZKSl/PazNdQBG4hl9ECn/kHQi5Q33s1EW0n6KxXxbsf+sC5Ex3vf5sgLzbYX6YpzPxHujJfRHaF6nFecWSGaEH/cCUpzrC8isO0RmqON8H1faG3nfbiYI5/MczwfhPA8dX3IdVWAfSCvOB/F793D+ieLcVkD2fG6plckOz07i/qAl9nmLtC84P0T9I/ahSeo7m72RPgHylg7SLQh+t8nKNYs+S61n7kvRZ7nXMGdZ4w2vD+yDW1nelGYBhLeyvCu4L7EPMdYxPlYYMN5fAKOAXvVJ7ltCu6DzNp01oTgPwnzwO2FdgfRlPsjxo4b/6ZNivzPwjHM3Evu7hfZk5tsRP+u72sBTD8jAFk9YdorlTeF4zvjRiSMxkDyoDvH9ArQ3woSd0i1h6ZohzkpIF3aGH/esPAx69lEYs0nND68M4SULvFCcHPDC52f5/gWcU6/3zD4xrg88XsC2zLfPv9H+Ebb5gJHifG6U7J8A70b75xt4pzhfBr38Ktg37ofo/39i+J8+Vfs3uvbvxxH2j9uxYu1flqUrx/59E/TsJ2D/pO6CWxnCSw54oThRc8sUH+0ftad6Fsf0HpRfFrAtAv6v0f4RtiWAkeL8ZpTsn9SYKsz/Q94pzjOgl38E+0Z1mgU5Pmf4nz5V+ze69u+/EfaP27Fi7V+OpSvH/v0F9Oy5UfD/uI1C+4f7amjvAs7/8vuZhdYaIvdroN/K719Em0zpaCyOdpt4qmdxcK6A4owN1jFMNrHRkFbX65P1g8+mPQy4vo5zx6O5z5Rkapr/x3Ua05rbaM7/m87r0DPuj+0IyQv3x/L3rkXNhU+N0AmRdchgfyw/Q8PPM+MZmukRGDEvwmmaeyYZ4NkKAR+g1cSbaT2L4swuIH+JuX/JeVX+3rWsgXeKswDWVRcFz3j+B+3QcsP/9InyU7C+Jc50Cs35ZbG/4/ftIU94jscWT1g2+SlUDp7hfqGv3XUoLj/fSnWI9/pR34zYeTr+7i48F4v3JIXdyYh7i5eBnpEeSfZT3SG84PoHxcH1Xin/g/c/pnUNPv7j69E4/lsbYbNwXxCeDzLtQZQ6HxS2DwfPB/EzFI0GnnEvitbbmUH4fEizlIVJjv/Dzj3hOVi+9xnPDKH/w/fMJm1f72j640KyyJU6x4j7rwT66zZsl8XgwfGxxN4UIT6zaOtt74/lttVnsqr0HsSwMRLe51DFXMVswoxnW3BfBsWrxD0WxWA0zTlIjWfC+gqsQ+pDlxpk1pgwmS0DPAJ+ShbnkfB84+XgdwucA2tLsfIygAPfnUZxDp00FPeqABv6IegrLWBhkr4SleV55vk89OcWQBg9455egT66LWpeEtfcSd+i5iUpzi0FxhPjDDLg5/LD7NRozkUSz+g3Sfm0eNYx45nvY5D2rSzm24b9Z12IjHFf+BsKzBEW6otx7rgS58AE5prbcP6N3ztgmvu9p4DMOkNkhjrOz4+koSzs73DvLp5VSxvy0PGFZJQTmndow3mfYvZTP1hA9nwOyWeyM+2nlpwvFpg7Nd6HGbUP+pECMlsRIrNC+6AX2Oct0iZTeeg7ot+RJH+j2RvpRyFvtA96cfA7JyvXLPp5tZ7Z/xi2Vw/mpvk+aL4ujL4N3we9GMJ9lnfl9kH7w/aB8/fvrjBg/FwBjAJ3xGSF1kSM+2CWGHh/YR8gzPt/FdaPSF9mghx/YvifPin2OwPPOEf3YtkHgzz1gAxs8YRlp7wi9gHuOhIDyYPqsNR9MAtYurL2AYKe/QTGuZXaB8jtM+6DMZ1doXT8Xc06DrWnes88jqiFOL8sYFtmWuffbP8I20zASHF+M0r2zz7v0fsAkfcX9gGCXv4R7Bv3Q/L7twz/06dq/0Z5H2CE/eN2rFj7Z3qvNcUpeR8g6NlzYP+k9sKuDOHFdA4kaj7edA4u7BwIroO/4H8Gc4hhtsW+/2u2f4QNz+q9oMMFMErZP6kxVZj/h7y/8G4tmOMdHzyb7rTS/083/E+fqv0bXfs3bdJIDCQPbsdG4xzIJNAz0qPROAeC6z3FnAPha48m/4/PzaH/N6eAbbG/zmO2f4QN13kozoJRsn9Sdx2G+X/IO8VZCnqZBfvG32+k/9/H8D99qvZvdO3f6gj7F/ccSDtLV479awM92wfsX6X8P9MdVqZzIPODZ9z7T2kqsX8v7L1eeG88P9OGNpnS0Vxk1B1Ki1k+uFZ2cIRNbDSk1fV6A5wDqd6THg93Je5JXwBxSrkn/cQC/WQS7kk/NQIj5kU4TeuVlbknfXBti/Nm2gNBcQYKyF9ivVhyXamUe9LPgP7jTPBDTPekX2b4nz5Rfkr1nvTSecKyyU+Juif9UvBTknhP+tmgZ5eBn1Lpe9Jx/dd0T3qlzg/wfXrYR/F9Wzi+oDjXRtissHvSTXu0pM5dhvW3eE+66W5IzjPuX9R6uygIX2JIswT4kloDCFuzp/I0xoXBs2mPIPo//GzIaJ9fIR7wXLbUWHomw2MqW0AWuVLXWHDProSvgufhi8GD42OJ/YxCfGbR1ts+B8JtDT/PX+l962FjJCqvirmKOQwz3pmB+9Io3tKEYDTNOUiNZ8L6CqxD6kMXGGRWiTtNS5HZTMAj4KdkcR4J91l9cpJouW3oH9F4ieOohTiv3m0o7qcDbE2QBn2lmSxM0lcK0zf0lUx+Hz3jORCBPnrYeRuOMepcOecD12q+VmA8Mc4gA77+EWanRnMuktsKSZ8W5/8y3sixTCV8K4v5tmH/WRciYxyT/rjAHGGhvhjnjitx3rlSZ2cIv2nu98kCMmsPkRnqOD9zmIaysL/D8x54JjttyEPHF5JRLilncJ4pIHs+h8TfYWs6gyPEW2tSzs48W0Bm3SEyK/QuAv4e90wQzvss/i4C9GMqMe/DbTuVhz4o+i9J8luaIQz5oed0kG4+YQLMEn5qyht+tgMx455nijNmtyHMpDt0nmQBS4c+EuVNaeZD+DKWd9gakP31hbZh52n4OlW3AWNjAYz29aotK7S2ktdXtC8674UG3inOBBgr7Bo8Y/taBHJsMfxPnxT7nYFnnOuTOEOj811pP9+8HuGekAyUgzytBhnY4gnLTnnD961QeC08Z6AN8/0tVIeEXfcVtL6F2Hm6mSxdM8TBNTS+d4V+4znIKaBnpEdadoshXU/wnC3vM2yNj/OC61Qv7CkDXsLWk/A8HbWnqPUkijO/gG1ZZJ1/s/0jbIsA4wvvBh4l+2efd7P9W2zgneL4oJetYN9M5+nWGv6nT9X+ja79WxNh/7gdK9b+LWDpyrF/naBna8H+LYR0PcFztryP0f6ZztNRHJzXX8zSmc4Tkzz5eTr0OSnOgQVsi/15Y7P9W8x4HXZvzijZP6k58zD/z3RX7+Ggl0eCfTOdp+sz/E+fqv0bXfu3OcL+cTtWrP1bytKVY/+OBT3rA/snNa+wPISXxcALxYk6T8fvgDD5f4tZPuj/nV7Attg/U2a2f6bzdBRnxyjZP6nzdNz+zTTwTnHOBb08H+wb1Snul7rW8D99qvZvdO3fNRH2j9uxYu3fYpauHPt3MejZtaPg/3EbhfYPz5jQXj/TXCvuAxyt/Ws410qyQ5tM6WguEu028VTP4lBanBO9LcImNhrS5s9JwnkS7m8n7f0suIZrWnvGPQKm/R6jufZsumubnvE8SS4kr8UQh+8NjlqHvbfSY5ngPAmti/F1T/TnKc79ERgxL8JpWvfkZ0yE1lbaTLxR3Swz8PZQAflLrDtLrith/em8TftIKM7D0H+8F/wQqjccpz1m+J8+UX4K1rfUe9877eebRZ+Pn59GnvAdG7Z4wrLJT+HnNNDf/JRhrY3kQXVI2HEdHLHzdKZ3hvF3caS88LOaeKbrg6Bnj4GfUqn3eBAvOE6jOLjXSGrcyPsfvs9Ox6F64uM/PAdGcb4YYbNwT2rUWQ0h2xZ57qINMPI14EYDz7gPUuvt3CAc9422sLAGb8j+2OaLyqK8W+CZMM4JnlsgrAXw0vdCFia5dsH9WPq9CDBmgueFgEdqHJFheExlC8gih3KnT1TftQjwCJzRb22EMorBg2MliTVOIT6H3fNh+zwJH5PwM2f4zkjh80p53eZ3ENBvPDtYxSyPWePhdg7fXbUwIRj53IhQG4y0u1iH1B+1GGRWiX1xpcgsA3gy9vFkcU6G8tc+iTdZtNxW9DVo7MFx1EKc900eilsbPDd5w9+/Rt8ZFibpd1BZlDf9Rr/D5EPRM57NEOjv8nJeFIIR53P4XV+cD7zra3wg/0JnM1AG9Iw+oclOSc2PhrW5pYAxEzyjDyLlH5JOkA61GGQh7adYzLcV+8+6EBnj2tneETqEeRFO3hfjuXaKi/u26b/nveHjcBu+2UDwwfMzpeQ7UOBj6WyyzwM8kEMannGuq9D/prg+pOHj8ufZ7zGe+Z66F+bjIvRCqk8WmpdvxXkRahN83hjPvC0t0Cb4HAu1CVyH4HfrCPGWE5rbysuMn/Ei/LgH/4XzQQVk1hoiM9O8PcVNQzw8H0fnETz4n85/YDz6rsQ8De8/qDz0c9FHysCz542ub9QMYcgPPZO8aQ4Rxw8Z+5jzY208i4GYcY8exTlw8hBm0h06/9HC0qEfRnlTmpkQvojlXbn9f9kOxFjH+Gg1YDy0AEYBveqQ3P+H9kXnPcfAO8U5HMYjRwbP2L7mghz7DP/TJ8V+4/84Nyfxvkih9ap8O+LnHjsMPOH6jy2esOxUQFQO3ltMz5uhDVM8kgfVIZ4VpPl9xM7TZVi6ZoiD93TyOwr5u9Ly+/9Az/pgTI5j5Z7gOVveJy+7thBeWoAXihO1j4Ti4/watad6zzzmqYU4pxewLXPt82+0f4RtLmCkODtGyf4J8G60f/MNvFOcc0Evzwf7xv2Q/L4tw//0qdq/0bV/10TYv0zwXKr9a2HpyrF/F4OeXQv2bw6k6wmes+V9jPaP2yi0f3j+bT5Lx+cm0B+uZ3G4z6k/NxewLQJzOEb7N5/xivbv1lGyf1JzhGH+H/JOcV4LenkH2Deq0xaQ4/2G/+lTtX+ja//ui7B/3I4Va/8WsnTl2L87Qc/ul12TMdo/bqPQ/pneC4rz+9R+cN9KixDuOQw336PS7A3vM/QHbTKF872E6Nvye6soLZ5beSTCJjYa0up6/UDd4DOuFaEc+dqJ1N4ItP+UN/2m8nCdxLS+g+twpjXV0Vzf4e8yaIJn3P+8NCSv+RCHvxssaq3j8UrPaQf7n/GdLhlv5D2O2J99rsA8ahZ+Z7yh+kb5kgzwnhYBH6DVxBvVzSIDb18pIH+JeWzJeVV+j0zGwDvF+Sb0H98GP4TqDf2UJw3/0yfKT5F+z4fQnF8W+zvSI9Od5LgX2BZPWDb5KfwuNNzD/wvwU/jeX6pDfE8I9c1RZzT53XamPcMpL/zudKprLbvvg549CX6KVD/lh/CCfgrFwfX8jBAe3v/wvSw6DtUTP0eF7+WhOL8vsMeCfAE8J8V9ByHbFrlPGN+7SWF4Jo7zjHuN8GzVLEgzm4VJjv+pLMqbflN56KPNhrDZgJe+57IwjXueEO65DDf9ngcYiYe5EEbP6P/MC8krA3GoHutDysN1Mm/K4FdY/2t9Ljvwf/jdv4QN51teONscgRHzIpyzGb+mvfsNEC9ji7fgvYect0zwe7aBt10KyF/i3bQyvA/qOp8vazHwTnHGTxmS08TgWbdHqreZKEfD//SJ8n+wviV8PqF+NIv9Fj9HiDzhPKctnrBs8n+oHOwP6XnGlKG4fHzG9wfg3rCoO8rmsXR4rgjXtvjdPvxeLC27yaBnpEeS/dTCEF4ywAtfu5Kcf+H9D+FoATlSPfE9pri+RHHmR9gszRv5AsQ3zq2gnyB1V8ZMbzi//K4MPG8/BzBmGM9aX06C+Z8ZQXgLpJnFwiRtK5VFedNv9HW4nJu84f4afc9hYZJrl2Hzf+jrcF9uNP1IIVnkUO70ieq70DZY98Oy2QH0g4vBMx/wSPjKyKfNc1pCtmZAag+6kK8y7A5l8imoHPQpsO+3xROWTT4FP3uEd5VsAJ+Cj99JZ3GvomkeOGy+HO83WT9lKA9ul/DcMtoGqXMHYeeWcX2bwuYBHql+NMxOYj9K/ccsg8waEyaz2YBHoI/Oog9B+ed9CPA5Z9kvdyDFyssADiqvFuLcPG0obm+ALcxPSNo8SSZ4jponkeovo+Zf0O7wuxRM8y8UZ3sBX3qcQQb0jD5ckuxU2HyLlD+XCfKi5wyTRZidMvnAUrY0zAdGW8rXwCXnxMPaWrVsERudK3V/ufR8Oo5di8EjPC7L4rwBliXVHsP0AO2VgP3Moa0uRu7S+0pK3feG53xcmk/FcY3tO0D43OVCJiucu6zEfZNhc6J436RpT1jU/HJmFDDyuVzJNeswe4B1mAme5xlklkmYzNBv5/Nb2u+/D8YkAv688bweX5fDtaBDYUzydhiT8Llz9NsoTHLONcxvwznXuUy+uJ6L/biUPz47BCOuk1Abqg/hA/eOv6/I+X3TGjuO/U1zS6O5N5J4Rnsi7V/QmMTkX0jM8UnKmK9HchnjmuCnCqzZ8zk90h/ct0qywj5TagwZVl+VWI8I63uwbAH7VvJ6BM6fCehYO/ZVxeCRvrNK0het1H10s5msKn1PWpjPEnW3WxVzFbOrmHEeD/cdUrw5CcHIz1u4MrZKgsxwbEXjF9xv9GcYWwnsI2hPgZz4GQvcr0NxxsPY6m8FxlazWVglxy3027SOYBpr4NhKwJfOy3lhCEYqD3WnPoQPXNf2dh/8KjS2QhnQM65XmOyJ1L2dYW0Dz2pxu/xi9dWL2Tv0Ui1boP8oeYwiPSbAtlcMniXCeKLqRniuOSvUH+ftbinnI/eKsKmYF+Hk+4/DzkdKnc+ZDdgy8LuSZXsRZUvd4+jbzzevK3jWLQP48d0VFGduAV3h71fid4Xgu5pyIDOpd0eF6Uoly/Yiyhao05zQmdK8rvAzpfx+STzX6RfQlbD7GPAdXiQrfGeP1HtPwnSFykt7I8+HZoLwNiYHujuT489UiAcvhAch3WjFs8QW883rHL6LKAP48d2qFGefAjrH7yXh70HGe1A6QGYS776K0jkqL+2NPDudCsL5nSqkcxx/qkI8eCE8COlG/j1sAu8Oy+scf3cY4cd7dijOoQV0LuwOHcqzCWRFcSu9fh+mhzjHxNdFw8bRXUIYw8bRJpkR/rQ3Uh+p/fB5Rmo/HYwnaj/VtbMX7dpZrpy1M6kzLFJrZ9RebK+d8XcJmmwIxekC+QnY8Eh7gXeouYa5lPWR0cRIYZW418vm+kgSZGZaH6G5Fu2PXL77EF4BXz6n8eI9fRnAgeM8ivPNvYfiXhVga2LYiJ9lLExyv1/Y+65x3orGmqb3XeP6iESfk/JG7n2lsk1369eH8IF7z26J8EWRN1wL4esjQud/It9lOR8wmu4ElPJ/8C6oDPwWPgeUFZJxXqf42qbpLl6K8/oCYxd+Xou/gwj3BVLcNJSF9Zb2Rt5TQz43z0PHl9JDoXXlHI6jotaVKc5bCsiej6uXMdnhGjSOd5YxWdJ4h9oV/U+yp3i4Jiu0JhzZ5nCcK122F1G2wPy98YypaU2G4rynRN2gvhb7NuJpdkQ6frcc9pv1LA7udaY4H4jAKdm3h+nQ0gqW7UWULaVDeLdKBuoEdYjifLyADnG/mXQI94oQT3Mj0lH8KB2azfJBHfp0kXs68D4PqbtWwvSqkmV7EWVLzcWUco8JzsUIjJdaS52L6QQ8UmuvAnyKzsV0M1nNZrJqhjg4r9EtID/TPAv9pvKqmCuDWePhewIbId7chGCksGWAR2puJszuYh1mgudWg8wyCZOZDxhpjgbv7Hka5o8E9h8Y33PJ716uhTivgfmjP8WYP5KaVwybP8IzccXOHwnMIbSa5hX5+FzHIb+sPoQPPEf67yJ9MZRB1LylsO8y7M5Uypt+ox/Lx86j6UOG2RPTXRpS83Bhc+bzASOF4ft2BexFZFurli0zx9/oDe/39CfFfmfguRXwSLSbRm/4XfyF8AiPx/L3qbQaypJqj2F6gPZKauyH9rOQ3HHsJ7HPo9Sxn/SarBCfWfQVbY/9ljNZzWayaoY43SC/5QLyS3kj9z/R7+WAh/fZjRBvfkIw8netSbWBKHuAdUj2e7FBZn7CZLYMMNJYAOcyc3sM4ZW6D56/W6idyQ/nJI+CMUlHgA39SBxj8X3Lkr5l2Pop3ufI917gGTjsx6X88bkhGHEdgtpQfQgftRBnTSD/sDFJq0EG3J/F8TraE6n2GzZe7wKMxDPaEyn/AvcTZOA3ykJ6jtM2T9R31YXIuBbibIjQIcyLcJL+UJ5NICvsM6XO9obV18IKlu1FlC11v3spd+mhXy7li5ayLiI9vyvpi1KfbdsXXcFkNZfJqhniLAf5rRCQX5TPsgLw8L4I/aqFCcFIYWiLRnPfPZ8HDfNFkyAz9Jf5uQ7dl+xMmC+6O/ii54IvyufUcU9rJXzRML1AP8w0Z07Po+GL8vMhJl+U84G+6BURfoTJ9w6zHVLrRGHtoBswmvazS/kSeBdRxhu5PlGJ+RXbPFE/VRci41qIc1MBv5PP1XDbiuME7B+l1kLD6quzgmV7CS1boC9oNekTP7+A+nRHifrE51qw/S+PSMf3CKC95+9lWA44Kc4bixyzo04LrHNE6jSVl/ZGjvdS3vDz3vQ/7ZntZHmkRpkH9MGoznFNpRL+QNi7lHHdk8JwX4fA2eBWk4+1nMlHRhZ+X6lraziOldAfqTUytIkN1vJtz5nmY0xr6BQHMUj1+WHr5d2Gsu3JoqPdNIY2yWKFAY/UWCtMFisMZVuURb7slUXIYqUBz8oKy2KloWyLsmjTZa8qQharDHhWVVgWVF6pmLsTgLmBPdspuzNv41YXIYvVBjyrKyyL1Yay7ckil58P2acIWexjwLNPhWVB5ZWKeWUCMDewZztld3SnIK8oWfQY8PRUWBZURqmYVzqIeXUCMDeEPGfL+nT067LXFCGLNQY8ayosizWGsi3KIn8ubG0RslhrwLO2wrJYayjbYr+a94v2LUIW+xrw7FthWVB5pWJe7SDmVQ5i7nYQ8woHMa90ELOLbTAJutHAnu2U3dGny96vCFnsZ8CzX4VlQeW9FDCvdhDzSgcxr3AQ81oHMSdBzrg3ZL89JfH4W0rdA0cYGuEZ1zfWBc89nt2zOlTWOihrvXV5DNYP1xf6vV60bL9P53uAAE863wPt55uf1zsoyIvWtg80yOrg4DlluZ4OgnxTUA6F18Lzmj2H4lI8kgfZA8Ku19D3D54RO0+3H0vXDHH2h3QHsnT0m+pay64T2rmEbhWj13otn9ryNJAFni/RH93217EwSXu5juGm3/sBRrKXaB/WCeEJW6uvZNleAstugmc8Gy+wNp2fEyO9JdtDZeO+PopzZNC+wvbVrGe8LTfwxtuLiV9TXhRnNsQhjPUsznrATnFOiMA+mnqO+2qw7ae9kXVB+2p4P57xqm11tMqWapfU91G7JJ3GdklxTi/QLvdnfFC7NLXB/SPSUfyoNrie5YNt8KwInHhvBqVtgLCMVxmdpvLSwAvqVxri0P/ULrkdy4wyD3iHBtV5I8PjebLjACqL8uayw3rH/W4C53EHUGa0321/Jh8p37HRG5I3fVLsN/6Pvr+E/gjVeRZtAuWdYTzhvSm4L03AlvomX4Lb0lIxdzuIeYWDmFc6iNlF3VjlIObVDmJ2UZ/3cRCzi3J2UZ97HMS8xkHMax3E7KI+u9gPVn3RymCu9imVweyibuxbxVwRzFWfvzKYXWyDLvpISZAz7pNpmiqJZ3CfDOIhmXkMo8cw4v6a9SCzA4LnHs/uPhkq6wAoS2DvR+Q+pgNFyx7cJ3OwAE8630Ps55ufVz40yIvWxA4xyGpD8JyyXE+HQr4pKIfCa+F5l6lDcSkeySMTPBN2vfZG+2sQO083l6Vrhji4h+cQlo5+U11r2XnQziV0qxi91muA1JZxnwytxzTC9wEsTNJeHsBw0++5gJHsJdoHiT1nKS98jY/Kawa57J9QmTVDGPJDz+kg3fTg93JZueZtCa5PI2a8p4XitEB7Jp2t8YbXB94TM5flTWmmQ/hclnfYvpT11vlvHdY+6xgf6w0Y5xTAaF+vWvtkeB/U1wOBR533TAPvFGfh1CE5LQ6esX3NADmuMPxPn2L8nBdTn4w8JaFPXh7RJ1MdltonH8DSldMnZ0HPVkD/vD+k6wmes+V9hu375bwsA14ozgLgZQFLR/FxTxC1p3oWh9LWQpy1BWzLDOv8m+0fYZsBGF8Yc4yS/bPPu9n+7W/gneIcDHp5KNg37ofo/080/E+fqv0bXft3QoT943asWPu3jKUrx/5tAj07EezfTEjXEzxny/sY7R+3UWj/lgAvfE8kxUf7R/KsZ3HQ56Q4fQVsyxLr/Jvt3/6MV7R/W0fJ/tnnPdr/Q94pznbQyx1g36hOl4EcLzf8T5+q/Rtd+3dZhP3jdqxY+7eApSvH/p0DenY52D+peYWDQnjZH3ihOFngJcvSUfwo/29/lg/6f9cWsC3231Vstn+EzfSO8BtGyf7Z591s/w4w8E5xXgF6eSvYN6rTBSDHuw3/06dq/0bX/r0pwv5xO1as/dufpSvH/r0G9OzuUfD/uI1C+5cDXvhcJ8VH+0fyrGdxKG0txLm/gG3JWeffbP8OYLyi/XvHKNk/+7xH+3/IO8V5N+jlw2DfqE7xnNYnDf/Tp2r/Rtf+fSLC/nE7Vqz9y7J05di/94OefRLs3wJI1xM8Z8v7GO0ft1Fo/9qAl5ksHcVH+0fyrGdxKC2urXyugG1ps86/2f7NZLyi/fvSKNk/+7yb7d8CA+8U5+ugl980rG9kQY5PVNc/Emv/fh5h/7gdG431j++Cnj0xiusfM4EXitMBvPD1D4qP9o/kWc/i4PoHxflNAdvSYZ3/6PWPDsBIcZ4eJftnn/fo9Q/kneL8H+jlX8C+UZ3i+kdqr5H/06dq/0bX/nl7DcW1tf4xk6Urx/79HfSM9EjLLgvpeoLnbHkfo/3jNgrt3xzgZQ5LZ1r/4P7fApYP+n8NAa9htsX+/KfZ/hE2HKNTnHEFMErZP6m5X27/TPMTFGfiXkNymgT2jep0JshxpuF/+lTt3+jav5YI+8ft2Gisf+wOejYT7F+l/D9uo9D+zQNe+PoHxY9a/6A4pvWPBQVsyzzr/Eevf8wDjBRnySjZP/u8R/t/yDvFyYFetoF9ozrF9Y99Df/Tp2r/Rtf+rY2wf3HXP+awdOXYvy7Qs33B/lVq/YPbKLR/i4CXRSydaf2D+39Zlg/6fwcVsC325z/N9o+w4Rid4mwYJfsnNfcbtv6BvFOcI0AvjwL7RnU6B+S4xfA/far2b3TtX1+E/eN2bDTWP44DPdsyCv4ft1Fo/5YCL3z9g+Kj/SN51rM4uP5Bcc4oYFuWWuc/ev1jKWCkODtHyf7Z5z3a/0PeKc55oJcXgH2jOsX1j+sM/9Onav9G1/5dG2H/4q5/LGLpyrF/l4CeXQf2bw6k6wmes+V9jPaP2yi0f/OBF77/uZT1D9z/THFuKWBb5lvnP3r/83zASHFuGyX7Z593s/2bY+Cd4twOevk6w/rGIpDjA9X1j8Tav/sj7B+3Y6Ox/nEX6NkDo7j+Ydr/vBB44esfpv3PJE++/xnXPyjOuwrYloXW+Y9e/1gIGCnOI6Nk/+zzHr3+gbxTnA+CXn4Y7BvVKa5/fN7wP32q9m907d/nBNY/bO5//hjo2efB/i2CdD3Bc7a8T+T+Z9P6Ryfw0snSmdY/uP83h+WD/t/XCtgW+/OfZvtH2HCMTnG+NUr2T2rul9s/0/wExfk+6OUPDesbuP/5t9X1j8Tav99E2L+4+59trn/8FPTst6Pg/3EbhfZvP+CFr39Q/Kj1D4pjWv/4UwHbYv99YNHrH/j+RIrz7CjZP/u8R/t/yDvF+Sfo5b/BvlGd4vrH2L1H/k+fqv0bXfvXsPdQXFvrH50sXTn273nQM9KjSq5/cBuF9m8dhLUEzxQf32NI/0n6resY7nUG3BQW9S4ruosL7TbxVM/i4LwlxZkc1JHJJjYa0up6XVA3+Ix3yC2ENHNZWAPgy3h25Rh2Px+VpzEuDp7x7jt69gF3JwvTuLuEcPPxB/3uAozEQyeE0XNr8J2CNDyvdohD96vXh5RXC3HmRuhEA8TLeNZk0qoxLg/yIhtM2LoBI8VZGIER8yKccxm/KEu8p0+qvjlv7QwP8pYtIH+Bd4r5krxj/em8Fxt4pzjtew/JqRP8EGoLeE/JesP/9InyU7C+VwrJcpX9fPN+ymrgPwPlIE/7gAxs8YRlk59C5VB4LTyvAz+F4pE8qA4Ju26LK4JnxM7TzWbpmiHOCki3iqWj31TX+bvpQM/Wg59ifwwwKLsVIby0Ay8Uh+yS5N0ZixkewoH3mnI/guJQWvQjNkTYLM0b+QLEN/a36CdI2Lao/nY5YKQwvK+b86z1Zeceg8/o/8yHNAtZmKReUVmU90LGA/o/CyGMntH/mc3CGkAmGcu4ZzPcJl/H5MvRM/o/nSF5of9DfU19SHm1EGdLgf5XoJ9sxX6Sz+Wa+snTCvg/3fA74w3VN8qXZIDv3pFaq+K8Ud0sNPC2o/L+py/JO9afznuxgXeKcy70S+cb5mHQ/7k25jwN1vcKIVkK+FVZ7NtJj1YaeEI/xRZPWDb5P1QOhdfC8zXg/1A8kgfVIWHXbZH6IcTO03WydM0QB+/tXsnS0W+qay27i0HPrq2A/7M8hBf0fygO2aXR9n8IR5T/Q3FuKeD/kC+A802UFv0ECdsW1d92A0YKK+T/5MD/aTWkWcbCGiB9xjJfYe+2p/I0RvJnlkEY6hXhXsjCJPeuhflt8wFjlN9G79JOQRqeF/o/XJd5eajLbynQ/wrM5Q2gH0e2nbDNBowU54EC/g/3CbmfjrIUHm+1mnjj9gZ5e2cB+Qv45K2SthbrT+ftG3inOI9Av/Q+8G+o3lpBjo8b/qdPlP+D9S3lSwqMY7M4j0B6tNzA00qQgS2esGzyf7hfUQvPj4H/w/0RqkPCrtsi+b+Inaebz9I1Q5wuSMd9DfqNY5APgZ49Dv6PVD/VFcIL+j8UB+dDfCE8vP8hHD7IkeqJ+z84bqE4Xyrg/5AvgPMk3HeQnG9o9YbzS79xnwSFLQaMnGetL0/vPvjcBP/PgTQ+C5O0rVQW5W3ydYgvH8JQrwj3UhYm2R6WMtz0G/024mEphNEz+j+LQ/LC8x58LzMvD/cyP1Gg/xVYEx7ANkm2nbDhfhuK86sC/g9v3z7jF2UpbG9yJt6obnwDb78vIH+BeZqcpK3F+tN5txp4pzh/gn7pz+DfUL21gxzphXP4P32i/B+sb4nxvtAYIWvyo2cbeEJfwBZPWDb5P1QOziHT8//A/+F9P9UhzmvTnR2InadbzNKhz4B3u4SN9XGv3N9Az0iPJPupeSG8zAdeKA7ZJY2nVQgP73/4+ELHoXqqZ3HwfC3FaQhkGOb/kC9g8i3QT5Cag273hvPL/Zpmb+SYtNHAs9aXy8H/mcd4wHmtSvAVpus4ZxK1jpQB3ItYmKT/w/ff0m/sn4mHRRBGz1H+D8VB/2dJ8FwfUl4txJkeocsNnsj7bAawTXL/B99nQ3FmRmA0te/ZjF+UJdobgfpuN/E2n+FB3uYXkL/AfQLtkrqO9afznmvgneIsmTYkp2Xg31BbmAdyXG34nz5R/g/Wt8S+fCFfMu//5ID/DJRj6jNt+z/4/ggcU+P7Buh51bShuHzsTXWI41HqcxA7T8f3LOCYHddtwsbEeMdFK+jZavB/pPapLgvhBf0fikN2SeORujuO75slHOhH8jEzxaG0OG5ZX6T/g/uEKS36CVJ3pYT1t0sBI78Dp9HAc35cNmXwuQn+XwBp5rIwyfsvwvY/U3noo5n2P2cAt2n9S2r/e9j6F/o6XGfC1r8WheSFe+Kpr6kPKa8W4pxYoP8V6CcHsJ/kZ5lM/eSpBfyfJfA74w3VN8qXZLAEeJNa/+e88TEp8jZQef/Tl+Qd60/nPc/AO8U5A/qlM8G/4T69/v8yw//0ifJ/sL4lxvtCflUW+3Z+3yvyhH6KLZ6wbPJ/qBycx6PnS8H/oXgkD6pDwo5zsYidp+N3dTVDHLzbjd/ty98JqGV3NujZZeD/SPVTS0N4wbks03y01P4LPh/F9+JgH8X3jOL9uhTn2gL+D/kCxDf2t+gnSL0rNqy/XQIYKcw0l4PjrvvA/5ltSMN9kEr6sXMZXo2RfAWT/9MI3/NZmMYtdXfpfIab+5Hot+GeFXoeF3ynvJHvcsE2Q3G4LvPyUJfvLND/Wp/L8zf3oR9Htp2w4Xozxbm7gP/DfULuk6Mscbwl4AMMmHjLBL9NY6n7CshfYv2xEmcUyP+ZZeCd4rwD+qWHwL/h7+fQ/z9q+J8+Uf4P1reULykwjs3iPALp0VIDT/ieY1s8Ydnk/5jeNUzPHwH/h/sjVIe4rk/+b9Q7mhewdM0QZzGkC9tbgGOQ94CePQr+j1Q/tTiElwzwwtfENJ5ZQnh4/0M4cFzN94xmGD7ct/d4kfM/OE9iWieSmm8IWyfC8/bc12n0RvKs9eUk8H8Ctr0ZkKaFhWm+pO5AorIob/pN5TUBDy0Q1gJ46XsWC5OcD53FcNNvXKMjHmYBHqn2MJPhMZUtIIscyp0+UX0Xno0Q6K9bSz1LjXv3JMaOQnxm0dY/79nto7lt5XNdeB5kHshPaqwbNkbCsW4VszxmjYfbORwvz0oIRtP4XWpsEGZ3sQ6pP2oxyKwxYTKbCXgE+vws3slD+Wuf5F/gw7bYL7c1xcrLAA4qrxbi3Dt9KO5zATbs09HvmM7CJP0OKstjPKDfQfxMhzB6HgcYBfq7VpOvSmVTeaiT9SF81EKchuDPMN98nEEG9Iw+oclOjea8HvGMPoiUf0g6kfKG+9koC2k/xWK+rdh/1oXIuBbiTI7QoWL6YpyHxfGthP4Izdu24lwWyYzwm+ZR9y4gs4UhMkMdJ1lR3DSUhf1d2hu5nvB8EM7z0PGFZJQTGsO34hwKnx82reHPLSB7Ph8zm8kO18cpruZtun3eIu0LlYd+EPahSeo7m72RPgHylg7SBa+IHuZfCsg1iz5LrWfuS9Fn6Zw+hJnqvMYbXh/YB/NzrZRmKoTPZnlXbk9JaxYx1jE+THcYrCiA0b5etWZleDefu8kYeKc4PeCvrg2esX1NAzluMvxPnxT7nYFnnLuR2OcmtJ8jr0e4dzID5SBPuD/CFk9Ydsobvr8T30NMzxuhDfN9oFSHeDaS1gQQO083naVrhjhLIF3YXRS493s96BnpkeT88JIQXlqAF4qDc/98fpbi4/7QTPBc75l94lqIc2wB2zLNOv9m+0fYpgFGinPiKNk/+7yb7d9MA+8Upxf0sg/sG/dD9P/nGP6nT9X+ja79OzvC/nE7Vqz9a2HpyrF/W0HPzgH7l4F0PcFztryP0f5xG4X2L2pumeKj/aP2VM/i4Pooxbm4gG2x7/+a7R9hmw4YKc7lo2T/pMZUYf4f8k5xrga9vBbsG9VpC8jxNYb/6VO1f6Nr/14dYf+4HSvW/s1i6cqxfzeAnr1mFPw/bqPQ/uFZYNq7gPO/meAZ9zW0COHOMNz0G/1WCiPZoU2mdDQWR7tNPNWzODhXQHHeHGETGw1pdb021w4+m/Yw4Po6zh1L7bsO2/eC54NIpqb5f1ynMa25jeb8P/Fg2teL+2PnheQ1HeJQe6gPKQ/nwh8u0E9aX4cM9sfS3CSfe0Z/g+K8v8D8J98zbJp7Np1jE5hbbDXxZlrPojiPFpC/xNy/5Lwq1p/Ou8XAO8X5JPQfj4EfQvWGdugbhv/pE+WnYH1L7McTmvPLYn/H7xBAnvCsjC2esGzyU/i+Uzzj9nXwU/h+VapD010QiJ2nm8fSmc7UpLyRax/8niktu8+Cnn0D/BSpfmphCC+4/sHvtpf0P3j/Y1rX4OM/vh6N478fFFiD5+PLRs+8B1HqPErYPpwFgJHC8KwP5xn3omi9HRuET4M0M1iY5PifyqK8Z8AzYSQeZkAY7uel7xYWlrR9vaPpjwvJIlfqHCPuv5LarzuzBDw4PpbYmyLEZxZt/fOe3T6a29aZTFaV3oMYNkai8lzEjO84xP0CFA/b7WhiNI2FpfzsDMNDv7EOybbPMMisMWEyywCejH08+b2mTaws3b83zhgqd4b9cnMpVl4GcFB5uLZ484yhuOODZ+wfsQ9vYmGSfTiV5TEesA9Hn4O+6Rn3mgr0HTmT30dlR50D43zgGsLUgKFCe01RBvSM/pXJTo3mHBnxjP25lK9FOkHtYIZBFtJ9vsV8c9h/1oXIGPcrz4vQoWL6YpzTrMT5JIE50BzOC5HMCL9pTnJpAZnND5EZ6jg/15D2Rp7HyATh3AbQXlOci6X4Dex3T/CcLe8T2VaoPOzTM8F30vqBZm9k/4a88X2T6CsJyDWL/W+tZ+4XsP9dO2MIM+kO7Zvk60jY51AelAb3Tc5keVdsrj2bG7ZvtI7xYVrbX18Ao329ymVleB9+Nw7fM4u8U5yDwfc6NHjG9jUW5Hii4X/6pNjvDDzjmF7iHmGhee68HvE964sMPOG8sS2esOyUN/xOONz/Ss8nQBvma8ZUh3h3HM0LInaeromlw7XmBZBuEUtHv/GsxSbQsxNh/JGBdD3Bc7a8T152C0J4mQG8UJwW4KWFpaP4uG+c2lO9Z/bvaiFOXwHbMtY6/2b7R9jGAkaKs3WU7J993s32L2PgneJsB73cAfaN+yH5e9MN/9Onav9G1/5dFmH/uB0r1v7NYOnKsX/ngJ5dDvZPau/cghBeWoAXioNzU6b7UOh/XO+RGjuH7RtB3Kb9H/xsEz+jhP443zeE+wkpzo0RNrHRkFbX69drBp9Nazu47oDzAKN1HwrOXZnmcnDOzTR/OppzOaa7ZugZ9w3NCcmrCeLwc9hR8xp3Fugnrc8pB/uG8O7GjDdy3xT2Z3cXmEfge6lM8wh8L5HU2qCJN9PcJMW5r4D8JeZxJOcVsP503jMMvFOcd0D/8RD4IdgO6f9HDf/TJ8pPwfqW2Kcg5P9ksQ8mPVpo4An9CVs8Ydnkp5je+0bPHwE/he/jyQTPeF86jdkRO0/H71k33UWX8sLvkMW9e+8BPXsU/JRK3WOHdoh4oTg4dy+wbmXsf0zzepngma+n8PPE+vN4gfUU8gVwTw6lRT9Bap9uxhvOL/2eBxgpDPdAc55xXVH/N94beqY001iYpP9LZVHe9BvvhOF7m/A+QPR/+F6ipO13kmwPYXcGzJCVRa7UMXYG8Aj01+2NrLxCeHB8LDFWEuIzi7be9r4hblszTFaV3k8SNkai8qqYq5hfTJjxXFgm+MZ5iRkJwWiaJ5Eag4X1b1iH1O9PM8isEvf2lCKz6YBH4k4eze8EVpb2/VKZoXIF7kNoT7HyMoAD70OgOF0zh+LWBdjC/LsMCxvNfdhNwFcGwugZ95RJ+Dkpb+QaGJVN5ek4/Awm5wPPYE4I/iy0pwxlQM/oe89iYZJtrpj7rTPBM9p2KT+cZEc6NIHJIsxOmcYuUmP5sLEL3tVAYRMAzwQhPBmGJ1Mt+4WyBWx0DvsG+qTY7ww843qSRLvBOYdi8AiPp7Om9TXJ9phhfNLvl9id+G24hlUMnuqd+MM/WlZ8ntZ0roHiVO+Xr2JOMubqPf4j8WQYHvqNdUh9e4tBZhMSJrMMYORz1npMeGRmCK/AWK8Nx+3F3Lf/75ahuMcG2HA/xgTgJ8PCJMcdVBblnWGybGLyozB6Rh9PYD6izTTuoLJxfxA/A8X5wDNQfcGfpvGqadyH6+zC98nn64TvazHdo8P3sUj6mVT/pC8tBlkI+FFZKX9R81HKnpudmcHvYvfcBNGNe5qwf5TQHyH7nJcZvwOI22e8A+iCTLTMFoTIDHWc390vxFtOaN9KXmZ83wrhN70z9fJMtMwWhchsPsiM37mf9kbuA0kF4XwfK50R43no+EIyasV9Oxbzzcue9vLyPUO4v5jivDwz+B0me753OMNk1wTyoriS85dhNnl2Bcv2IsrO2C+73VSnfL0L6/RVQWCxdcrXybCfLWYfOd5HkQme+RkSvGuK4rwuAifOKaFeSd1JHaZX0wAP4cQ1Mvq/Ej5r2N6fGQaZtQAe6fUUqtMlTD4ysvD7Sp2PxTlJCf2RmldFe9JgLd/2/P5kvtfStO6C/RNhkHonRtgay2JD2fZk0ZHX46VFyGKpAY/EXclRslhqKNuiLIa9SztKFssMeATud46UxTJD2RZlkfejskXIImvAk62wLKLeTR6FeXECMDewZztld+ZtnF+ELHwDHr/CsvANZduTxeC52VwRssgZ8OQqLAsqr1TMyxKAuYE92ym7o1uX3VqELFoNeForLAsqr1TMyxzE7CcAcwN7tlN2R78uu60IWbQZ8LRVWBZthrItymJAl91ehCzaDXjaKyyLdkPZFvvVvF/UUYQsOgx4OiosCyqvVMy+g5izDmJe7CDmpQ5iXuYgZhfbYBJ0o4E92ym7I39ev7MIWXQa8HRWWBZU3ksBs+8g5mUOYl7qIOZ2BzEnQc56PaMleF7eIonH31LqeWDC0AjPuL7RFTz3eHb3d1NZXVBWt3V5DNYP1xf63S1att+n810hwJPOd6X9fPPzequCvGhdeKVBVquD55TleloF+aagHAqvhefOlqG4FI/kQfaAsOv15+XBM2Ln6TpZumaIsxzSrWTp6DfVtZbdEmjnErpVjF5rOVBbxrsbaF0Vz/Z1sTBJe9nFcNPvTsBI9hLtQ5cQHiorFeTNy8YzY0sSKrNmCEN+6DkdpOPvcRSS67B3lNUyzDMhnOJsgPZMOkt3K7ewdKj7/E4ovFu5k+Uddh+W/bX29ixi5HeLzjBgPLwARvt61Z6V3FvSDTzqvMcaeKc4x7QMyem44Bnb13iQ42mG/+mTYr8z8NwJsnyx9MnIUxL65K0RfTLVYal9chdLV06ffBLo2WnQPy+BdD3Bc7a8T152y0N4aQFeKA7eG8/PVFN83BdH7amexcF76ynOzgK2Zbx1/s32j7CNB4wU59xRsn/2eTfbvyUG3inORaCXl4B9436I/v9Gw//0qdq/0bV/N0TYP27HirV/LSxdOfbvCtCzG8H+Sd0vvjyEF7zngOLge8v5ORCKj/aP2lM9i4N3mlOc2wrYFvv+r9n+EbYuwEhxXjtK9k9qTBXm/yHvFOcNoJd3gX2jOm0BOT5o+J8+Vfs3uvbvHRH2j9uxYu3fLJauHPv3ZtCzB0fB/+M2Cu0fnikay9JRfLR/JM96Fgff3UBxHilgW+zfYWy2f2MZr2j/PjBK9k/qPdNh/h/yTnEeBb38GNg3qtNZIMcvG/6nT9X+ja79+1KE/eN2rFj7N4+lK8f+fQr07Mtg/1ogXU/wnC3vY7R/3Eah/cMzkvx8JsWP8v/4u5vQ//tWAdti/7y32f4RNhyjU5zvjZL9kzrrzu1fi4F3ivNj0Mufgn2jOsUz5s8Y/qdP1f6Nrv17OsL+cTtWrP0by9KVY/9+AXr2zCj4f9xGof3DO0rp3neKj3M9eCe81F33LQw3/Ua/lcKizvPSWkzUvOVUlg/OW/4zwiY2GtLqen1tzeAz3gmD949kWJjkGkjGGy4P+l3snTB4l81sFiZ0V0jR7xYiHkzvFqK15pQX/m4hvHOmlHcLjZ05XA74EboLJH+ms5R7TpoiMGJehDPD+A17t1DGPm/GO1zw/iHO26QC8hewSW1CvBvfLdRi4J3i7DFzSE5Tg2e802gmyHGB4X/6pNjvDDxX3y1UOk9YNvkpUe8Wmj9zKC4/t051OJrvFpoOekZ6JNlPzQ/hZTrwQnHwbhKpcSPvf/h9cDoO1VM9i4PvFqI4foTNwjsO8d1C3HeQ9LdmesP5pd/ob1EY3lPNecb7+kzvv0H/B/d4StUjlUV502/0ZfH+DArLAF76nsnCJMeuYfWB74QkHmZCGD3juxVnheSF95TzO/d4eXjn3v4F+l/rdxUF71aktsHX8rG9UZyDC/g/3CfMMH5RlngvX8Y2b4Fvx3nj7xVA3jYVkL+AT94u6f9g/em8pxl4pzhHQ790LPg3VG/43omthv/pk2K/M/CM9S1hb3W+8+3nm/d/+L1+8w08LQQZ2OIJyyb/h/sVeKfgAPg/3B+hOiTsui2S/4vYebpZLF0zxMHxP/c16DeOQU4EPdsK/o9UPzU3hJcJwAvFwX2zUneH8f6Hv79Fx6F6qmdxcG8txdlZwP/h758w3QUsOd8Q9m6hOYCR+4CNBp7x/Tpabyd5w/nG9zHiPIrU/hcqi/Lm83qm9z82ecPfBUnf/H08DV6y3gkp2R74eripbAFZ5Ep9Lwa+UyojhGd6CXgygEdi7CjEZxZt/fOe3T6a21Y+11Xp96plGB76jWcdXMOM90YSVhx7TksIRgrDPi4jhCfMhmUAD9n2JoPMGhMms7GAR6D/zL8/bzdWlu7f3zJTtNwc9tvkx3MctRBn5qyhuA8E2JogDfbhY1mYZB8epm/Yh5v8EXrG9+cJ9B05k9/HzwihTtaH8IH3/z5SwM8dZ5ABPaN/lWFhoz1Hxm2FpK9FOkHYmgyyyNgvOysk4xz2n3UhMsa54k8UmLsq1BfjnCaOFSX0R2gONC+z2UxmhN80J/nZAjIrNJ+P830UN+2NfMdsJgjnNoDu26d42F4qMb7jbQX3t5Gtx/4gSf1Aszfc/hM/9JwO0tFeC/SVJPr9FMgq6uwoxfkhzGWR7tC54SaWDvscypvS4Lnh6Szvis21B3er8vf3Eh+zDRh/WgCjfb3KZWV4H/4+Waqf8QbeKc6TME/4K5hvJn2ZBHJ81vA/fVLsdwaecUwv9Z4ZgXnuYe8i/P/2zh5GkqOK4z2zszO7O7uzn7e3xiD3ne8QXxJzx4fu7GSNJUcObAkCCyFxPp+NwZzts09wITkBGYFJSJADJDKcIBEQkCACJAIkLBILWUgICeMEySfce/W//c1/X3cbb9fsWXJLq62qeVX13quaV/969brG3z+iTPQbdyUT++4Vs79To/IB0v/Gd9h/z0ZjeDe2pjj0C5J3r+exoxPQnEc9j8Xxdy0q3b2NefYO9h87qLef0tPjPeHvVrl9noCGPuF1qyf6M6CRPodGw/dSRfPfFtvSPQaN7d+6yUr7d/uE7F8u/O32byeQXTQL2HsupjR93Nw37wSf6/nY/p2s/dt+8JC2zY59UPu3ZvWOY/+WMc80jyrdbaPefkpPj/eE9s9tFO0ffVOyAfSfebxFznf+fW94NuBbZdIdbbLqCYvSbksmj5tWXfqkygdnZeYzDupW4/o44qZ9z89zh9y/RU77r7b9LJI+kciXQ59baWUn7cuhzlSmNOOGztS0tQMaj4Hz/mZi4BrmRBafcoob4ruLZXE0borr2VcaeGRb4jPyI5Qpzbi9DON9MZJtx/ihbA+36D+HHyfnXOf4VW0vB7KLZh/rx9eAQ/h91udPBp/r6Vm+RDrzb6hm+y16rsH+e6DR72t3jVN47wZxC+/RUPoJ4BTRSR8aw+i3dcm71/Pf/ItijXtF/W9aM3bvMcyzJ4FTcvnWztXIsgNZ6CcRP2uZ+HFfn/hwP2X1DI2GZ1uiearBZvGMN4ovJk7IFadbFrPyKs/7ZVRGbNB0rljpajeV02e7YWU5ceSGyaU8Y4U8tmmtmI1z0n+PJbrX4p1yfh/cHxL1neMM+f/dY/MsPVcc04f1eeb6fcsMcs7cZ9l13FBpuorOUUQzj3iSuj2S+vso8lz37jP3ePcCj9FeOBfGqLNhHEPZ9o1AZ+N7TGfr4CfD+nkQN7RnfVXr+48fzNrvRa7bwvHOxwA0q+cOaX+SeFtDHa7h61aWcw2vm29cwyM8ojTjhjKsHRcjnOvnA5yTwxo5eIbwWgvOXQ104GcydXbqJH1kbityYi2+z1YWR32x81jzO2z3ItfPxRodc6/0eovvqkS+SjfF45XQWa647TOZdOaxVuI/8gv9qkVnZ2t0xjleprRoGR9U4n9V7jZAcUOi47owj/2df1d4TiBbz/XgXloHJiijPEp73BCxUo51vwddeewIz05F8zv4sjR3FDcUvW/l/hHVYdzQsrU9N197OjenP4NynA14/H0Lj93Pqzvn5t3LPntnkcZnO5BdNH+An/CP8DdrvuxCj28Gn+vpWb5Emnv6HLFSmfzcB/OIZ78l+qFM9Bt3JRP77hWz59O8p0Xpv+I77OfYGkPeqeP3r0b11q3epDh6D2evOHpGrTzjZv+EefYm9h97qLef0tPjPTOxIy4L32PlO/aSxc+f/ffUKhrp09835fmzaN5qsS3dY9DY/m2brLR/b5+Q/cuFv93+7QWyi+afmJf/gn1zHFJ9fjv4XM/H9u9k7d97DfbP7dgHtX8bVu849u8dzLPbsH+7qLef0tPjPaH9cxtF+1eiTGc69J+pDs97ctltt7/K74FHlUl3tMmq5zH6xOMeN6S69EmtnJvVA59xULca182FO2n6hegTcT9JztjJtvfE6ROJfDn0uUX+05P05UTv4CvNuKEHatraA02Z0sOi3a9xf8OcyOJTTnFDWqvcj1CCR9E80MAj21L9yI/gsUQ53y912TQ20d3951v0n8OPk9OvUELGKh35ZUXzOfjIv5DSjAuiv/3h4HM9TTiF450jTiET/plyDdY8OhfIRDzRlUzsWzjF43F4Z9ZD5w5pPY5HY8h7ZLVnJ+9ez++fje7o6RX1d9kydm+KeaZ5NM/7fSQL13vR0He/kYkf9/WJD/r1/DwlOtsSzaMNNotnvNFdhsQJGWxb43p7BjxG74U3nStWfAsfbaLOrpXlfG/I8aDHMfF8cRdlu+BX/7etLOf8q8O/xJOSgXt6pYl/Nmraor9D4zes6W8Amqda1t/OfdkJ/6ykttyXy++baL7Vgn9WkC+Lw/GmfqWDFciWYZ92MZJNY7MbyHa1Rf8rGXjMuUfl+FVt7wWyi+Y7WJe+C3wjXXwCerwVfK6nCf9wvD9KsV7c6/j5LGUqoYOuZGLfwj/qh3sopX8I/CM66UNjGN2tRt693obVi+7maVrrNNaV7q5jnt0C/sm1Ti3XyML3W/0d7nn6X8QH98waJ39vlv5v0fyoBf8IC9Df5Nghk227QFnUtvIr4FFljIF2mav58pv+nfQa6vdRZ2RllVzDTHKpL7WtvPrjd2uEshH41f/orH1e+NvPbdYgQ1PMVYR/POa5otmEXqL+BqD5acv6u9m1ThL+2UptOf7ZBI+iea0F/2whXxaH4039SgdbkG3UtWzpvmmXTWMzCmT7eYv+tzLwmEn2C5x7/t4YZRfNL7AuvR7gG+LINz4k/uF451jvqnZPdd/ulPs9zaNTgUynoYOuZGLfwj/qhzhW6V8D/4hO+tAYinfuRci719uwehPQ8N3qU1ZPeY11pbtfYp69AfyTa52qO28n/hEN46XnFevlMfjcszXdGyKa37bgH2EB4h/HDpls2wXKoraV3wKPlFc8uswHZ5zJuET3KY6LQ/zAs+NcuE59qW3l1V/F3yp4U9kY8uizoZVVfPcz8T00vpXvg0cfD2KidAR5ME/7NW2NQOP+H++Pe/A/z9//8yxxnGy7eIveJfhLC/5xTDg2ealL3pPR+XgnbOey+R6Bsv2tRf+dY/L3ecw5193/sxrILpq3sC79HfiG32d9/m7wuZ4m/MPxzmFvM90TM3NPoMd7UaZT0EFXMrFv4R/HFQOk/wP843jE99RVXviXvHu9Fas3Ac0m6tX51rkH+Qfm2bvAP2PU20/p6fGemT2AyzKCLNyjip9csXOrxg99A9LjEPyQRnUHoHmvBf8IC0hurrfECbn8DXXrLeNEiXv032Wu5svPgH9G4F11lq0sJ/6pi/+hvXQ90ydE/OOYaAlyl8V8cNsqeORcUZnSxD+rNW31QeN3SXl/vEtqOx3izy2WN+GfSWpLtp26EI+iOd3AI9sSn37HOXU5gWy54n9cNo3NciDbp1r0P8nA4zzuiBD+GQayi+bs+UM9nUvpapw0biPo8UvB53qa8A/HO4e9zeIjnd7BP+5H3Axkoi+kK5nYt/CP4wr6MC+eP6R1PKIxFO/0xTbdkbdq9SKfSYQ1/Oyl0t1nMM80j3KuU+s1svQhS3T+kMsn63hAfHDPLD6GRqO6A9A83GCzJsUhFqAvgnLqfwbb1rjeTvDffSfjQOaDexMD/DMI6gwgVy7b6r4PX1eIf7j370Me8b1iZTn3A3X+OGKdCMspTfwzrmlrCTSad8Oa/gagebJl/e0cEyb8w719WTRjtG+04J815Mti9ny2KGZ1yfi7XD4Ql01j0w9k++a88Wdas3PJzvGr2o58j6L5Ntalp4FvNG7EPy8Hn+tpwj8c7xzvu2fCVVOu7X5GTJmIU7qSiX0L/6gfnm8q/RLwzwc5i9Y6RN69nt/5Mylmzy9Ur+0uuUp3z2KevQz8k2udmtTIsgT+RUP7nes8ztcf8TGEHhlLQhrVHYDmVgv+IT7Qf8cOOf1ddXEyPH9UGc+yXOZqvoyTcdkH30XXfF+6cHmIxu8rZp8+O146/FeV91K+Z+X9lO9b+ULKL1j5IOUHVr6Y8otWPkz5oZWPUn5k5UvKW/lyyi9b+UrKr1j5OOXHVr6a8qtWvpbya1Y+SfmJla+n/LqVb6T8hpVvpvymlW+l/JaVb6f8tpXvpPyOlZ9K+VNWvpvyu1Z+OuVPozzLen/pzt1EC123m9bUQef8XrhUtbuYgV/6t4k9fT9FOtrIgdFVtim52A/W2PtodIp8e/eceyDHhdyLqVw0n03/K5rPg87XkOrzh4LP9TThQq67OfbhmfDmlJhHuHA9kIn4rSuZ2LdwofubeLZ9GbTup9IYMn5T6/NmQ72R1eNZWvQOjOqRvnoq3X0Rac4jxwG5sCLtAfvKYaNWINcz156++dzjLz5X2BPFmezhc/F1sM6DX6/L792StVGm+qSp7imr9LtmbXaqg0vTLxNjLRSzz0dtjeS6Ea05+mxUzGJc4T7RbaJMY1LNFe21Xrpy9XuP3Hju5vevXX/1lUdu3LhyiyOnXnw0eyhXTwtG2wvqLZBT62MctFVJ9umUzjRrnuWsoSe5KGIEXhYx0la5I23pyJF2z2QWD9RND2V3ZwPK9I1dQNldBIKyu54Woff3/z6JbrtHY9OvZrJ0l5eKPCcJQtIdtxve7LSEvMZAK0TXKzqjYOkt4Iml0veD1r0KjGytHnrjVxrqDaxeFJ3aK45+v5Wnl1BIoPqvnSkjNDJEOFweG2/itzB+9fAG4RyootKd3n575dqrT9x8+oXnr3792pUbz7z4g+uP3bx+9dXnX7z+6JUXXugFyl02ASIjLRoawz7SXFoHSC8izbqjoOw2FBPlyR8NneSIQo5oTLn9WLD+l4vZcCg9lNHLKGcvSPeL2RCVIpDDy8ZBP5tBWaQ/n4CEN13+dEDVhvS3GPA2KI7qdwn8dcjLBcq7UBzVwWagn/8Bhwd2VVkZCwA=","debug_symbols":"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yTwt6fpSVZam0LSk60tVWZq40pKuL1VlabpIS7q+VJWlSRot6fpSVZamRrSk60tVWZqQ0JKuL1VlaRpAS7q+VJWlrvot6fpSVZY637ek60tVWepO35KuL1VlqYN8S7q+VJWlLu8t6fpSVZY6sbek60tV+eqtvvvqrb776q2+++qtvvvqrb776q2+++qtvvvqrb776q2+++qtvvvqrb776q2+++qtvvvqrb776q2+++qtvvvqrb776q2effVWz756q2dfvdWzr97qeRFf6bpSVdlXb/Xsq7d69tVbPfvqrZ599VbPvnqrZ1+91bOv3urZV2/17Ku3evbVWz376q2effVWz756q2dfvdWzr97q2Vdv9eyrt3r21Vs9++qtnn31Vs++eqtnX73Vs6/e6tlXb/Xsq7d69tVbPfvqrZ599VbPvnqrZ1+91bOv3urZV2/17Ku3evbVWz376q2effVWz756q2dfvdWzr97q2Vdv9eyrt3r21Vs9++qtnn31Vs++eqtnX73Vs6/e6tlXb/Xsq7d69tVbPfvqrZ599VbPvnqrZ1+91bOv3urZV2/17Ku3evbVWz376q2effVWz756q2dfvdWzr97q2Vdv9eyrt3r21Vs9++qtnn31Vs++eqtnX73Vs6/e6tlXb/Xsq7d69tVbPfvqrZ599VbPvnqrZ1+91bOv3urZV2/17Ku3evbVWz376q2effVWz756q2dfvdWzr97q2Vdv9eyrt3r21Vs9++qtnn31Vs++eqsXX73Vi6/e6sVXb/Xiq7d6WcRXuq5UVfHVW7346q1efPVWL756qxdfvdWLr97qxVdv9eKrt3rx1Vu9+OqtXnz1Vi++eqsXX73Vi6/e6sVXb/Xiq7d68dVbvfjqrV589VYvvnqrF1+91Yuv3urFV2/14qu3evHVW7346q1efPVWL756qxdfvdWLr97qxVdv9eKrt3rx1Vu9+OqtXnz1Vi++eqsXX73Vi6/e6sVXb/Xiq7d68dVbvfjqrV589VYvvnqrF1+91Yuv3urFV2/14qu3evHVW7346q1efPVWL756qxdfvdWLr97qxVdv9eKrt3rx1Vu9+OqtXnz1Vi++eqsXX73Vi6/e6sVXb/Xiq7d68dVbvfjqrV589VYvvnqrF1+91Yuv3urFV2/14qu3evHVW7346q1efPVWL756qxdfvdWLr97qxVdv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"},{"name":"pay_refund","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"refund_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"fee_entrypoint_public","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"pay_refund_with_shielded_rebate","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"secret_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"7V3hziNHbnyX/W0ETbLZzfarBEHgu/MFBgz7cPYFCIx798zGkr7P2dnt5UlNlYbzy2t7NF1kL2tqSmzqtw9/+f5P//iv//zhp7/+/MuHb//9tw8//vzn73794eeftn/77UP5N+L/+6+//O27nz7+h19+/e7vv374tnzz4fuf/rL985/ffPjrDz9+/+Fb4fbP//jm4wfE+4Hq/YB6P9C8H+jeD5j3A8P5AS5f/4FvPrluqF6uHL3friXmnWsr9evFlazerh66c3Fj6ZeLG6u8v/h32HQPbCrCl0upaA0Fznfle9Abbp3gJqJ6vZp6+TLuXm9BdiX7FLcswv373evSu+vSu7eld+9L725L7z5W3l3K0rvT0rvz0rsvrVVZWquytFZlaa3K0lqVpbUqS2u1Lq3VurRW69JarUtrtS6t1bq0VuvSWq1La7UurdW6tFZ1aa3q0lrVpbWqS2tVl9aqLq1VXVqrurRWdWmt6tJabUtrtS2t1ba0VtvSWm1La7UtrdW2tFbb0lptS2u1La3VvrRW+9Ja7UtrtS+t1b60VvvSWu1La7UvrdW+tFb70lq1pbVqS2vVltaqLa1VW1qrtrRWbWmt2tJataW1aktrdSyt1bG0VsfSWh1La3UsrdWxtFbH0lodS2t1LK3VsbRWqZS1t6e1t+e1t5e1t69rb69rb9/W3r6vvb2tvf3aqqW1VUtrq5bWVi2trVpaW7W0tmppbdXS2qqltVVLa6uW11Ytr61aXlu1a/uZaG1DE63taKL7Wpqq8LXvrIrw7er9fjkxu1zcavm0X47ua4B6aO8esbsdk739mORpa7p8gtyf8DffurtvPW1Cl0+4+2/F3YAr7g5cce+5uPe8uve8uve8uve8+juu3Xte3Xte3Xte3Xte3Xte3Xuu7j1X956re8/Vvefq3nN177m691zde67uPVf3njf3njf3njf3njf3njf3njf/2Qr3njf3njf3njf3nnf3nnf3nnf3nnf3nnf3nnf3nnf/gRr3nnf3nnf3npt7z8295+bec3Pvubn33Nx7bu49N/8pKveem3vPh3vPh3vPh3vPh3vPh3vPh3vPh3vPh3vPh//onP/sXHF/gtyfYPcnxP2J6v6Euj/R3J/o7k+Y+xPuPSf3npN7z92HY9l9Opbdx2PZfT6W3Qdk2X1Clt1HZNl/Rpbde87uPWf3nrN7z9m95+zec3bvObv33O3DsduHY7cPx24fjt0+HLt9OHb7cOz24djtw7Hbh2O3D8duH47dPhy7fTh2+3Ds9uHY7cOx24djtw/Hbh+O3T4cu304dvtw7Pbh2O3DsduHY7cPx24fjt0+HLt9OHb7cOz24djtw7Hbh2O3D8duH47dPhy7fTh2+3Ds9uHY7cOx24djtw/Hbh+O3T4cu304dvtw7Pbh2O3DsduHY7cPx24fjt0+HLt9OHb7cOz24djtw7Hbh2O3D8duH47dPhy7fTh2+3Ds9uHY7cOx24djtw/Hbh+O3T4cu304dvtw7PbhxO3DiduHE7cPJ24fTtw+nLh9OHH7cOL24cTtw4nbhxO3DyduH07cPpy4fThx+3Di9uHE7cOJ24cTtw8nbh9O3D6cuH04cftw4vbhxO3DiduHE7cPJ24fTtw+nLh9OHH7cOL24cTtw4nbhxO3DyduH07cPpy4fThx+3Di9uHE7cOJ24cTtw8nbh9O3D6cuH04cftw4vbhxO3DiduHE7cPJ24fTtw+nLh9OHH7cOL24cTtw4nbhxO3DyduH07cPpy4fThx+3Di9uHE7cOJ24cTtw8nbh9O3D6cuH04cftw4vbhxO3DiduHE7cPJ24fTtw+nLh9OHH7cOL24cTtw4nbhxO3DyduH07cPpy4fThx+3Di9uHE7cOJ24cTtw8nbh9O3D6cuH04cftw4vbhxO3DiduHE7cPJ24frrp9uOr24arbh6tuH666fbjq9uGq24erbh+uun246vbhqtuHq24frrp9uOr24arbh6tuH666fbjq9uGq24erbh+uun246vbhqtuHq24frrp9uOr24arbh6tuH666fbjq9uGq24erbh+uun246vbhqtuHq24frrp9uOr24arbh6tuH666fbjq9uGq24erbh+uun246vbhqtuHq24frrp9uOr24arbh6v7Ptz29adcPrR951j/8Lmd36qptx/kaf3dtX3vTL+26zH9qtMz/TrG5eLW+NMz/XXfE3Sit+tABaYyQc9argMPWOUN0Edsn17M17Swvd147P7YD7drBknpdm29hik5wqw5wtQcYbYUYe7b4C8Y5m3WCpHpp2FSjjAPQkFcrg99YimfhtmDw2zldnHj/uUwt2/Irk/97WupSU6sX3MySv3ypduG3yqZ+Q/3vWTFzqzsZGWcWfk0K72c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"},{"name":"prepare_fee","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"from","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"portal_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"pending_shields","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"other_asset","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"gas_token_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"amount","type":{"kind":"field"}},{"name":"asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"FPC::fee_entrypoint_public_parameters"}}],"kind":"struct","path":"FPC::fee_entrypoint_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"amount","type":{"kind":"field"}},{"name":"asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"secret_hash","type":{"kind":"field"}}],"kind":"struct","path":"FPC::pay_refund_with_shielded_rebate_parameters"}}],"kind":"struct","path":"FPC::pay_refund_with_shielded_rebate_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"other_asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_token_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"FPC::constructor_parameters"}}],"kind":"struct","path":"FPC::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"refund_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"FPC::pay_refund_parameters"}}],"kind":"struct","path":"FPC::pay_refund_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"amount","type":{"kind":"field"}},{"name":"asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"secret_hash","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"FPC::fee_entrypoint_private_parameters"}}],"kind":"struct","path":"FPC::fee_entrypoint_private_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"from","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"FPC::prepare_fee_parameters"}}],"kind":"struct","path":"FPC::prepare_fee_abi"}]}},"file_map":{"112":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__INNER_NOTE_HASH,\n    hash::{\n    pedersen_hash, compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_inner_note_hash_from_preimage(storage_slot: Field, note_content_hash: Field) -> Field {\n    pedersen_hash(\n        [storage_slot, note_content_hash],\n        GENERATOR_INDEX__INNER_NOTE_HASH\n    )\n}\n\nfn compute_inner_note_hash<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    compute_inner_note_hash_from_preimage(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N, M>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let (_, inner_nullifier) = note_with_header.compute_note_hash_and_nullifier(context);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\nfn compute_note_hash_for_read_request_from_innter_and_nonce(\n    inner_note_hash: Field,\n    nonce: Field\n) -> Field {\n    // TODO(#1386): This if-else can be nuked once we have nonces injected from public\n    if (nonce == 0) {\n        // If nonce is zero, that means we are reading a public note.\n        inner_note_hash\n    } else {\n        compute_unique_note_hash(nonce, inner_note_hash)\n    }\n}\n\npub fn compute_note_hash_for_read_request<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let inner_note_hash = compute_inner_note_hash(note);\n    let nonce = note.get_header().nonce;\n\n    compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, nonce)\n}\n\npub fn compute_note_hash_for_consumption<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    if (header.note_hash_counter != 0) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        inner_note_hash\n    } else {\n        // If a note is not transient, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the siloed_note_hash which has already been hashed with\n        // nonce and then contract address. This hash will match the existing leaf in the note hash\n        // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, header.nonce);\n        compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, N, M, S>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n    let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, note_header.nonce);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        let (_, nullifier) = note.compute_note_hash_and_nullifier_without_context();\n        nullifier\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [inner_note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"122":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::{compute_siloed_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_contract_initialization_nullifier(context.this_address());\n    let header = context.get_header();\n    header.prove_nullifier_inclusion(init_nullifier);\n}\n\nfn compute_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    compute_siloed_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(address)\n    )\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"123":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr","source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"},"125":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"128":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n"},"135":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n"},"139":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"140":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{\n    abis::{\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\n    utils::reader::Reader,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n}\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\n    let mut reader = Reader::new(fields);\n\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n    // WARNING: if updating, see comment in public_call_stack_item.ts's PublicCallStackItem.hash()\n    let item = PublicCallStackItem {\n        contract_address: AztecAddress::from_field(reader.read()),\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\n        public_inputs: PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            args_hash: reader.read(),\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            end_side_effect_counter: 0,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0\n        },\n        is_execution_request: true\n    };\n    reader.finish();\n\n    item\n}\n"},"149":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr","source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext}, oracle::storage::storage_read,\n    state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PublicContext> {\n    // Intended to be only called once. \n    pub fn initialize<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T> SharedImmutable<T, UnconstrainedContext> {\n    unconstrained pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PrivateContext> {\n    pub fn read_private<T_SERIALIZED_LEN>(self) -> T  where T: Deserialize<T_SERIALIZED_LEN> {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n"},"167":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{GAS_LENGTH, FIXED_DA_GAS, FIXED_L2_GAS}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\n    abis::gas_fees::GasFees\n};\nuse std::ops::{Add, Sub};\n\nstruct Gas {\n    da_gas: u32,\n    l2_gas: u32,\n}\n\nimpl Gas {\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\n        Self { da_gas, l2_gas }\n    }\n\n    pub fn tx_overhead() -> Self {\n        Self { da_gas: FIXED_DA_GAS, l2_gas: FIXED_L2_GAS }\n    }\n\n    pub fn compute_fee(self, fees: GasFees) -> Field {\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.da_gas == 0) & (self.l2_gas == 0)\n    }\n\n    pub fn within(self, limits: Gas) -> bool {\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\n    }\n}\n\nimpl Add for Gas {\n    fn add(self, other: Gas) -> Self {\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\n    }\n}\n\nimpl Sub for Gas {\n    fn sub(self, other: Gas) -> Self {\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\n    }\n}\n\nimpl Serialize<GAS_LENGTH> for Gas {\n    fn serialize(self) -> [Field; GAS_LENGTH] {\n        [self.da_gas as Field, self.l2_gas as Field]\n    }\n}\n\nimpl Deserialize<GAS_LENGTH> for Gas {\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\n    }\n}\n\nimpl Eq for Gas {\n    fn eq(self, other : Gas) -> bool {\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\n    }\n}\n\nimpl Empty for Gas {\n    fn empty() -> Self {\n        Gas::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Gas::empty();\n    let serialized = item.serialize();\n    let deserialized = Gas::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n"},"169":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr","source":"use crate::{\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct NoteHash {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for NoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteHash {\n    fn eq(self, other: NoteHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter) \n    }\n}\n\nimpl Empty for NoteHash {\n    fn empty() -> Self {\n        NoteHash {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl NoteHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNoteHash {\n        ScopedNoteHash { note_hash: self, contract_address }\n    }\n}\n\nstruct ScopedNoteHash {\n    note_hash: NoteHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<NoteHash> for ScopedNoteHash {\n    fn inner(self) -> NoteHash {\n        self.note_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNoteHash {\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNoteHash {\n    fn value(self) -> Field {\n        self.note_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl Eq for ScopedNoteHash {\n    fn eq(self, other: ScopedNoteHash) -> bool {\n        (self.note_hash == other.note_hash)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedNoteHash {\n    fn empty() -> Self {\n        ScopedNoteHash {\n            note_hash: NoteHash::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\n        array_concat(self.note_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            note_hash: reader.read_struct(NoteHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNoteHash {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.note_hash.value, read_request.value(), \"Value of the note hash does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the note hash does not match read request\");\n        assert(\n            read_request.counter() > self.note_hash.counter, \"Read request counter must be greater than the counter of the note hash\"\n        );\n    }\n}\n\nimpl ScopedNoteHash {\n    pub fn expose_to_public(self) -> NoteHash {\n        // Hide the actual counter when exposing it to the public kernel.\n        NoteHash { value: self.note_hash.value, counter: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = NoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"170":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"172":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr","source":"use crate::{\n    abis::{\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    transaction::tx_context::TxContext, utils::arrays::validate_array\n};\n\nstruct PrivateCircuitPublicInputsArrayLengths {\n    note_hash_read_requests: u32,\n    nullifier_read_requests: u32,\n    key_validation_requests_and_generators: u32,\n    note_hashes: u32,\n    nullifiers: u32,\n    l2_to_l1_msgs: u32,\n    private_call_requests: u32,\n    public_call_stack_hashes: u32,\n    note_encrypted_logs_hashes: u32,\n    encrypted_logs_hashes: u32,\n    unencrypted_logs_hashes: u32,\n}\n\nimpl PrivateCircuitPublicInputsArrayLengths {\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\n        PrivateCircuitPublicInputsArrayLengths {\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\n            note_hashes: validate_array(public_inputs.note_hashes),\n            nullifiers: validate_array(public_inputs.nullifiers),\n            l2_to_l1_msgs: validate_array(public_inputs.l2_to_l1_msgs),\n            private_call_requests: validate_array(public_inputs.private_call_requests),\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\n        }\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    note_hashes: [NoteHash; MAX_NOTE_HASHES_PER_CALL],\n    nullifiers: [Nullifier; MAX_NULLIFIERS_PER_CALL],\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs: [L2ToL1Message; MAX_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    tx_context: TxContext,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.returns_hash == other.returns_hash) &\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\n        (self.is_fee_payer == other.is_fee_payer) &\n        (self.max_block_number == other.max_block_number) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\n        (self.note_hashes == other.note_hashes) &\n        (self.nullifiers == other.nullifiers) &\n        (self.private_call_requests == other.private_call_requests) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.l2_to_l1_msgs == other.l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\n        self.historical_header.eq(other.historical_header) &\n        self.tx_context.eq(other.tx_context)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\n\n        fields.extend_from_array(self.max_block_number.serialize());\n\n        for i in 0..self.note_hash_read_requests.len() {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..self.nullifier_read_requests.len() {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..self.key_validation_requests_and_generators.len() {\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\n        }\n        for i in 0..self.note_hashes.len() {\n            fields.extend_from_array(self.note_hashes[i].serialize());\n        }\n        for i in 0..self.nullifiers.len() {\n            fields.extend_from_array(self.nullifiers[i].serialize());\n        }\n        for i in 0..self.private_call_requests.len() {\n            fields.extend_from_array(self.private_call_requests[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n        fields.push(self.public_teardown_function_hash);\n        for i in 0..self.l2_to_l1_msgs.len() {\n            fields.extend_from_array(self.l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        for i in 0..self.note_encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.unencrypted_logs_hashes.len() {\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.tx_context.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            is_fee_payer: reader.read() == 1,\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL]),\n            nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL]),\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            public_teardown_function_hash: reader.read(),\n            l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            tx_context: reader.read_struct(TxContext::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PrivateCircuitPublicInputs {\n    fn empty() -> Self {\n        PrivateCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter : 0 as u32,\n            end_side_effect_counter : 0 as u32,\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            tx_context: TxContext::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PrivateCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PrivateCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x15c9b0a92b9b541598e24c9f0b0b4b04b7f2408599751c45aa12de671fd9b363;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"173":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item_compressed.nr","source":"use crate::abis::{call_context::CallContext, function_data::FunctionData, gas::Gas};\nuse crate::address::AztecAddress;\nuse crate::constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH};\nuse crate::traits::{Hash, Empty, Serialize, Deserialize};\nuse crate::utils::reader::Reader;\n\n/**\n * A compressed version of the PublicCallStackItem struct used to compute the \"hash\"\n * of a PublicCallStackItem.\n * \n * Historically, we have been zeroing most values in the PublicCallStackItem struct\n * to compute the hash involved when adding a PublicCallStackItem to the PublicCallStack.\n * \n * This struct is used to store the values that we did not zero out, and allow us to hash\n * only these, thereby skipping a lot of computation and saving us a lot of constraints\n * \n * Essentially this struct exists such that we don't have a `hash` function in the \n * PublicCallStackItem struct that practically throws away some values of the struct\n * without clearly indicating that it does so.\n */\nstruct PublicCallStackItemCompressed {\n    contract_address: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    revert_code: u8,\n    start_gas_left: Gas,\n    end_gas_left: Gas,\n}\n\nimpl Eq for PublicCallStackItemCompressed {\n    fn eq(self, other: PublicCallStackItemCompressed) -> bool {\n        (self.contract_address == other.contract_address)\n            & (self.call_context == other.call_context)\n            & (self.function_data == other.function_data)\n            & (self.args_hash == other.args_hash)\n            & (self.returns_hash == other.returns_hash)\n            & (self.revert_code == other.revert_code)\n            & (self.start_gas_left == other.start_gas_left)\n            & (self.end_gas_left == other.end_gas_left)\n    }\n}\n\nimpl Hash for PublicCallStackItemCompressed {\n    fn hash(self) -> Field {\n        std::hash::pedersen_hash_with_separator(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PublicCallStackItemCompressed {\n    fn empty() -> Self {\n        PublicCallStackItemCompressed {\n            contract_address: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n    fn serialize(self) -> [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.push(self.revert_code as Field);\n        fields.extend_from_array(self.start_gas_left.serialize());\n        fields.extend_from_array(self.end_gas_left.serialize());\n\n        assert_eq(fields.len(), PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n  fn deserialize(fields: [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH]) -> PublicCallStackItemCompressed {\n    let mut reader = Reader::new(fields);\n\n    let item = PublicCallStackItemCompressed {\n      contract_address: reader.read_struct(AztecAddress::deserialize),\n      call_context: reader.read_struct(CallContext::deserialize),\n      function_data: reader.read_struct(FunctionData::deserialize),\n      args_hash: reader.read(),\n      returns_hash: reader.read(),\n      revert_code: reader.read() as u8,\n      start_gas_left: reader.read_struct(Gas::deserialize),\n      end_gas_left: reader.read_struct(Gas::deserialize),\n    };\n    reader.finish();\n    item\n  }\n}\n"},"175":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n"},"176":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr","source":"use crate::{\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for ReadRequest {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\n        ScopedReadRequest { read_request: self, contract_address }\n    }\n}\n\nstruct ScopedReadRequest {\n    read_request: ReadRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<ReadRequest> for ScopedReadRequest {\n    fn inner(self) -> ReadRequest {\n        self.read_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ScopedReadRequest {\n    fn eq(self, other: ScopedReadRequest) -> bool {\n        (self.read_request == other.read_request)\n        & (self.contract_address.eq(other.contract_address))\n    }\n}\n\nimpl Empty for ScopedReadRequest {\n    fn empty() -> Self {\n        ScopedReadRequest {\n            read_request: ReadRequest::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            read_request: reader.read_struct(ReadRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedReadRequest {\n    pub fn value(self) -> Field {\n        self.read_request.value\n    }\n    pub fn counter(self) -> u32 {\n        self.read_request.counter\n    }\n}\n\n#[test]\nfn serialization_of_empty_read() {\n    let item = ReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"179":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr","source":"use crate::{\n    address::AztecAddress,\n    abis::validation_requests::{\n    key_validation_request::KeyValidationRequest,\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\n},\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct KeyValidationRequestAndGenerator {\n    request: KeyValidationRequest,\n    sk_app_generator: Field,\n}\n\nimpl Eq for KeyValidationRequestAndGenerator {\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\n    }\n}\n\nimpl Empty for KeyValidationRequestAndGenerator {\n    fn empty() -> Self {\n        KeyValidationRequestAndGenerator {\n            request: KeyValidationRequest::empty(),\n            sk_app_generator: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\n        array_concat(self.request.serialize(), [self.sk_app_generator])\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\n        let mut reader = Reader::new(fields);\n        let res = Self {\n            request: reader.read_struct(KeyValidationRequest::deserialize),\n            sk_app_generator: reader.read(),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl KeyValidationRequestAndGenerator {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = KeyValidationRequestAndGenerator::empty();\n    let serialized = item.serialize();\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"180":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point::new(fields[0], fields[1], fields[2] as bool),\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"184":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr","source":"use crate::{\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH},\n    hash::compute_siloed_nullifier, traits::{Empty, Hash, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct Nullifier {\n    value: Field,\n    counter: u32,\n    note_hash: Field,\n}\n\nimpl Ordered for Nullifier {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for Nullifier {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for Nullifier {\n    fn eq(self, other: Nullifier) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.note_hash == other.note_hash) \n    }\n}\n\nimpl Empty for Nullifier {\n    fn empty() -> Self {\n        Nullifier {\n            value: 0,\n            counter: 0,\n            note_hash: 0,\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\n        [self.value, self.counter as Field, self.note_hash]\n    }\n}\n\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            note_hash: values[2],\n        }\n    }\n}\n\nimpl Readable for Nullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        // Public kernels output Nullifier instead of ScopedNullifier.\n        // The nullifier value has been siloed.\n        let siloed_request_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.value, siloed_request_value, \"Value of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl Nullifier {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\n        ScopedNullifier { nullifier: self, contract_address }\n    }\n}\n\nstruct ScopedNullifier {\n    nullifier: Nullifier,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<Nullifier> for ScopedNullifier {\n    fn inner(self) -> Nullifier {\n        self.nullifier\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNullifier {\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNullifier {\n    fn value(self) -> Field {\n        self.nullifier.value\n    }\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl Eq for ScopedNullifier {\n    fn eq(self, other: ScopedNullifier) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedNullifier {\n    fn empty() -> Self {\n        ScopedNullifier {\n            nullifier: Nullifier::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            nullifier: reader.read_struct(Nullifier::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.nullifier.value, read_request.value(), \"Value of the nullifier does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.nullifier.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl ScopedNullifier {\n    pub fn nullified_note_hash(self) -> Field {\n        self.nullifier.note_hash\n    }\n\n    pub fn expose_to_public(self) -> Nullifier {\n        // Hide the actual counter and note hash when exposing it to the public kernel.\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Nullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = Nullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"192":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr","source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n  fn eq(self, other: Self) -> bool {\n    (self.nullifier == other.nullifier) &\n    (self.next_nullifier == other.next_nullifier) &\n    (self.next_index == other.next_index)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"193":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"194":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr","source":"use crate::{\n    abis::{\n    private_call_stack_item::PrivateCallStackItem, call_context::CallContext,\n    function_data::FunctionData, caller_context::CallerContext,\n    side_effect::{Ordered, RangeOrdered, Scoped}\n},\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PrivateCallRequest {\n    target: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Ordered for PrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.start_side_effect_counter\n    }\n}\n\nimpl RangeOrdered for PrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.start_side_effect_counter\n    }\n    fn counter_end(self) -> u32 {\n        self.end_side_effect_counter\n    }\n}\n\nimpl Eq for PrivateCallRequest {\n    fn eq(self, other: PrivateCallRequest) -> bool {\n        (self.target == other.target) \n            & (self.call_context == other.call_context) \n            & (self.function_data == other.function_data) \n            & (self.args_hash == other.args_hash) \n            & (self.returns_hash == other.returns_hash)\n            & (self.caller_context == other.caller_context)\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\n    }\n}\n\nimpl Empty for PrivateCallRequest {\n    fn empty() -> Self {\n        PrivateCallRequest {\n            target: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.push(self.target.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.extend_from_array(self.caller_context.serialize());\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = PrivateCallRequest {\n            target: reader.read_struct(AztecAddress::deserialize),\n            call_context: reader.read_struct(CallContext::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            caller_context: reader.read_struct(CallerContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            end_side_effect_counter: reader.read_u32(),\n        };\n        reader.finish();\n        item\n    }\n}\n\nimpl PrivateCallRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\n        ScopedPrivateCallRequest { call_request: self, contract_address }\n    }\n\n    pub fn matches_stack_item(self, stack_item: PrivateCallStackItem) -> bool {\n        (self.target == stack_item.contract_address)\n            & (self.call_context == stack_item.public_inputs.call_context)\n            & (self.function_data == stack_item.function_data)\n            & (self.args_hash == stack_item.public_inputs.args_hash)\n            & (self.returns_hash == stack_item.public_inputs.returns_hash)\n            & (self.start_side_effect_counter\n                                == stack_item.public_inputs.start_side_effect_counter)\n            & (self.end_side_effect_counter\n                                    == stack_item.public_inputs.end_side_effect_counter)\n    }\n}\n\nstruct ScopedPrivateCallRequest {\n    call_request: PrivateCallRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\n    fn inner(self) -> PrivateCallRequest {\n        self.call_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedPrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.call_request.counter_start()\n    }\n}\n\nimpl RangeOrdered for ScopedPrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.call_request.counter_start()\n    }\n    fn counter_end(self) -> u32 {\n        self.call_request.counter_end()\n    }\n}\n\nimpl Eq for ScopedPrivateCallRequest {\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\n        (self.call_request == other.call_request)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedPrivateCallRequest {\n    fn empty() -> Self {\n        ScopedPrivateCallRequest {\n            call_request: PrivateCallRequest::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.call_request.serialize());\n        fields.extend_from_array(self.contract_address.serialize());\n\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = ScopedPrivateCallRequest {\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        item\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = ScopedPrivateCallRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"199":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\n    abis::gas_fees::GasFees,\n    constants::{\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\n    DEFAULT_INCLUSION_FEE\n},\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    utils::reader::Reader\n};\n\nstruct GasSettings {\n    gas_limits: Gas,\n    teardown_gas_limits: Gas,\n    max_fees_per_gas: GasFees,\n    inclusion_fee: Field,\n}\n\nimpl GasSettings {\n    pub fn new(\n        gas_limits: Gas,\n        teardown_gas_limits: Gas,\n        max_fees_per_gas: GasFees,\n        inclusion_fee: Field\n    ) -> Self {\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\n    }\n\n    pub fn default() -> Self {\n        GasSettings::new(\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\n            DEFAULT_INCLUSION_FEE\n        )\n    }\n}\n\nimpl Eq for GasSettings {\n    fn eq(self, other: Self) -> bool {\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\n    }\n}\n\nimpl Empty for GasSettings {\n    fn empty() -> Self {\n        GasSettings::new(\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\n        )\n    }\n}\n\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\n\n        serialized.extend_from_array(self.gas_limits.serialize());\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\n        serialized.push(self.inclusion_fee);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\n        let mut reader = Reader::new(serialized);\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasSettings::empty();\n    let serialized = item.serialize();\n    let deserialized = GasSettings::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"208":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr","source":"use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PrivateCallStackItem {\n    fn empty() -> Self {\n        PrivateCallStackItem {\n            contract_address: AztecAddress::empty(),\n            function_data: FunctionData::empty(),\n            public_inputs: PrivateCircuitPublicInputs::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = PrivateCallStackItem::empty();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item = PrivateCallStackItem::empty();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x065f2831db9ac0db5e710bd3a865b5facd8cf83f1585e1af8fd1d6ce9c47f685;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr","source":"use crate::address::AztecAddress;\nuse crate::traits::{Empty, Serialize, Deserialize};\nuse crate::constants::CALLER_CONTEXT_LENGTH;\nuse crate::utils::reader::Reader;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n    is_static_call: bool,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, other: CallerContext) -> bool {\n        other.msg_sender.eq(self.msg_sender)\n            & other.storage_contract_address.eq(self.storage_contract_address)\n            & other.is_static_call == self.is_static_call\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n            is_static_call: false,\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\n    }\n\n    // Different to an empty context, a hidden context won't reveal the caller's msg_sender and storage_contract_address,\n    // but will still propagate the is_static_call flag.\n    pub fn is_hidden(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array(self.msg_sender.serialize());\n    fields.extend_from_array(self.storage_contract_address.serialize());\n    fields.push(self.is_static_call as Field);\n\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\n    let mut reader = Reader::new(fields);\n\n    let item = CallerContext {\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\n      is_static_call: reader.read_bool(),\n    };\n    reader.finish();\n    item\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = CallerContext::empty();\n    let serialized = item.serialize();\n    let deserialized = CallerContext::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"211":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr","source":"use crate::{\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\n    constants::{\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\n},\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct LogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n}\n\nimpl Ordered for LogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for LogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for LogHash {\n    fn eq(self, other: LogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n    }\n}\n\nimpl Empty for LogHash {\n    fn empty() -> Self {\n        LogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n        }\n    }\n}\n\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length]\n    }\n}\n\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n        }\n    }\n}\n\nimpl LogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\n        ScopedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedLogHash {\n    log_hash: LogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<LogHash> for ScopedLogHash {\n    fn inner(self) -> LogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedLogHash {\n    fn eq(self, other: ScopedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedLogHash {\n    fn empty() -> Self {\n        ScopedLogHash {\n            log_hash: LogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(LogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the counter when exposing to public.\n        // The log hash must already be siloed when we call this.\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nstruct EncryptedLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    randomness: Field,\n}\n\nimpl Ordered for EncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for EncryptedLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for EncryptedLogHash {\n    fn eq(self, other: EncryptedLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.randomness == other.randomness) \n    }\n}\n\nimpl Empty for EncryptedLogHash {\n    fn empty() -> Self {\n        EncryptedLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            randomness: 0,\n        }\n    }\n}\n\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.randomness]\n    }\n}\n\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            randomness: values[3],\n        }\n    }\n}\n\nimpl EncryptedLogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedEncryptedLogHash {\n    log_hash: EncryptedLogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\n    fn inner(self) -> EncryptedLogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl ScopedEncryptedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the secret randomness and counter when exposing to public\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\n        // The log hash will already be silo'd when we call this\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nimpl Ordered for ScopedEncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedEncryptedLogHash {\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedEncryptedLogHash {\n    fn empty() -> Self {\n        ScopedEncryptedLogHash {\n            log_hash: EncryptedLogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct NoteLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    note_hash_counter: u32,\n}\n\nimpl NoteLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\n        LogHash { value: self.value, counter: 0, length: self.length }\n    }\n}\n\nimpl Ordered for NoteLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for NoteLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteLogHash {\n    fn eq(self, other: NoteLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.note_hash_counter == other.note_hash_counter) \n    }\n}\n\nimpl Empty for NoteLogHash {\n    fn empty() -> Self {\n        NoteLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            note_hash_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            note_hash_counter: values[3] as u32,\n        }\n    }\n}\n"},"215":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr","source":"struct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n"},"216":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n}\n// docs:end:call-context\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n"},"217":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"22":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"220":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize, Empty}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        (self.is_private == other.is_private)\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nimpl Empty for FunctionData {\n    fn empty() -> Self {\n        FunctionData {\n            selector: FunctionSelector::empty(),\n            is_private: false\n        }\n    }\n\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data = FunctionData::empty();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data = FunctionData::empty();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty function data hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"227":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n    counter: u32,\n}\n\nimpl Ordered for L2ToL1Message {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content, self.counter as Field]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\nimpl L2ToL1Message {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\n        ScopedL2ToL1Message { message: self, contract_address }\n    }\n}\n\nstruct ScopedL2ToL1Message {\n    message: L2ToL1Message,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\n    fn inner(self) -> L2ToL1Message {\n        self.message\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedL2ToL1Message {\n    fn counter(self) -> u32 {\n        self.message.counter\n    }\n}\n\nimpl Eq for ScopedL2ToL1Message {\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\n        (self.message == other.message)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedL2ToL1Message {\n    fn empty() -> Self {\n        ScopedL2ToL1Message {\n            message: L2ToL1Message::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            message: reader.read_struct(L2ToL1Message::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\n#[test]\nfn serialization_of_empty_l2() {\n    let item = L2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = L2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped_l2() {\n    let item = ScopedL2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"235":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<N> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<N> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<N> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<N> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"236":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"// Utility function to console.log data in the acir simulator\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<M, N>(_msg: str<M>, args: [Field]) {}\n\n/// NOTE: call this with a str<N> msg of form\n/// \"some string with {0} and {1} ... {N}\"\n/// and an array of N field which will be formatted\n/// into the string in the simulator.\n/// Example:\n/// debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n/// debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\nunconstrained pub fn debug_log_format<M, N>(msg: str<M>, args: [Field; N]) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n/// NOTE: call this with a str<N> msg of length > 1\n/// Example:\n/// `debug_log(\"blah blah this is a debug string\");`\nunconstrained pub fn debug_log<N>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n"},"237":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr","source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  num_txs: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.num_txs);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let num_txs = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      num_txs,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      num_txs: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.num_txs == other.num_txs)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n"},"238":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"239":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr","source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"241":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n"},"243":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr","source":"use crate::{\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    abis::gas_settings::GasSettings\n};\n\n// docs:start:tx-context\nstruct TxContext {\n    chain_id : Field,\n    version : Field,\n    gas_settings: GasSettings,\n}\n// docs:end:tx-context\n\nimpl TxContext {\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\n        TxContext { chain_id, version, gas_settings }\n    }\n}\n\nimpl Eq for TxContext {\n    fn eq(self, other: Self) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.gas_settings.eq(other.gas_settings))\n    }\n}\n\nimpl Empty for TxContext {\n    fn empty() -> Self {\n        TxContext {\n            chain_id: 0,\n            version: 0,\n            gas_settings: GasSettings::empty(),\n        }\n    }\n}\n\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\n\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.extend_from_array(self.gas_settings.serialize());\n\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let context = Self {\n            chain_id: reader.read(),\n            version: reader.read(),\n            gas_settings: reader.read_struct(GasSettings::deserialize),\n        };\n\n        reader.finish();\n        context\n    }\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context = TxContext::empty();\n    let serialized = context.serialize();\n    let deserialized = TxContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let context = TxContext::empty();\n    let hash = context.hash();\n\n    // Value from tx_context.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"247":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"249":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n"},"25":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n#[no_predicates]\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    let value = pedersen_commitment_with_separator(input, 0);\n    if (value.x == 0) & (value.y == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value.x, y: value.y, is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        points[i] = EmbeddedCurveScalar::from_field(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let values = multi_scalar_mul(generators, points);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: values[2] as bool }\n}\n\n#[no_predicates]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let v1 = pedersen_commitment_with_separator(input, separator);\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    multi_scalar_mul(\n        [length_generator[0], v1],\n        [EmbeddedCurveScalar { lo: N as Field, hi: 0 }, EmbeddedCurveScalar { lo: 1, hi: 0 }]\n    )[0]\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n#[test]\nfn assert_pedersen_noir() {\n    // TODO: make this a fuzzer test once fuzzer supports curve-specific blackbox functions.\n    let input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq(pedersen_hash_with_separator(input, 4), pedersen_hash_with_separator_noir(input, 4));\n    assert_eq(pedersen_commitment_with_separator(input, 4), pedersen_commitment_with_separator_noir(input, 4));\n}\n"},"263":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"273":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"289":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"303":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/main.nr","source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n\ncontract Token {\n    // Libs\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        hash::compute_secret_hash,\n        prelude::{NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress},\n        encrypted_logs::{\n        encrypted_note_emission::{\n        encode_and_encrypt_note, encode_and_encrypt_note_with_keys,\n        encode_and_encrypt_note_with_keys_unconstrained\n    },\n        encrypted_event_emission::{encode_and_encrypt_event, encode_and_encrypt_event_with_keys_unconstrained}\n    }\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public, compute_authwit_nullifier};\n    // docs:end:import_authwit\n\n    use crate::types::{transparent_note::TransparentNote, token_note::{TokenNote, TOKEN_NOTE_LEN}, balances_map::BalancesMap};\n    // docs:end::imports\n\n    #[aztec(event)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: BalancesMap<TokenNote>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128>>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n\n    // docs:start:admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[aztec(public)]\n    #[aztec(view)]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_public\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n\n    // docs:start:mint_private\n    #[aztec(public)]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        storage.balances.add(caller, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, caller, caller));\n\n        Token::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    // docs:start:shield\n    #[aztec(public)]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n\n    // docs:start:transfer_public\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n\n    // docs:start:burn_public\n    #[aztec(public)]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:redeem_shield\n    #[aztec(private)]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let pending_shields = storage.pending_shields;\n        let secret_hash = compute_secret_hash(secret);\n        // Get 1 note (set_limit(1)) which has amount stored in field with index 0 (select(0, amount)) and secret_hash\n        // stored in field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TransparentNote::properties().amount, amount, Option::none()).select(\n            TransparentNote::properties().secret_hash,\n            secret_hash,\n            Option::none()\n        ).set_limit(1);\n        let notes = pending_shields.get_notes(options);\n        let note = notes.get_unchecked(0);\n        // Remove the note from the pending shields set\n        pending_shields.remove(note);\n\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        storage.balances.add(to, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, to));\n    }\n    // docs:end:redeem_shield\n\n    // docs:start:unshield\n    #[aztec(private)]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n\n    // docs:start:transfer\n    #[aztec(private)]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, from_ivpk));\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk));\n\n        Transfer { from, to, amount: amount.to_field() }.emit(encode_and_encrypt_event_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk));\n    }\n    // docs:end:transfer\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[aztec(private)]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier, 0);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_from\n    #[aztec(private)]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, from_ivpk));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, to_ivpk));\n    }\n    // docs:end:transfer_from\n\n    // docs:start:burn\n    #[aztec(private)]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n\n    /// Internal ///\n\n    // docs:start:increase_public_balance\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n\n    // docs:start:balance_of_private\n    unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.balance_of(owner).to_field()\n    }\n    // docs:end:balance_of_private\n}\n// docs:end:token_all"},"315":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr","source":"use dep::aztec::{\n    prelude::{AztecAddress, NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash},\n    note::utils::compute_note_hash_for_consumption, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app\n};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\nglobal TOKEN_NOTE_LEN: Field = 3; // 3 plus a header.\n// TOKEN_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TOKEN_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n#[aztec(note)]\nstruct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NoteInterface<TOKEN_NOTE_LEN, TOKEN_NOTE_BYTES_LEN> for TokenNote {\n    // docs:start:nullifier\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self {\n            amount,\n            npk_m_hash: owner_npk_m_hash,\n            randomness: unsafe_rand(),\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n"},"317":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr","source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::{note_getter_options::PropertySelector, utils::compute_note_hash_for_consumption},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash}\n};\n\nglobal TRANSPARENT_NOTE_LEN: Field = 2;\n// TRANSPARENT_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TRANSPARENT_NOTE_BYTES_LEN: Field = 2 * 32 + 64;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[aztec(note)]\nstruct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nstruct TransparentNoteProperties {\n    amount: PropertySelector,\n    secret_hash: PropertySelector,\n}\n\nimpl NoteInterface<TRANSPARENT_NOTE_LEN, TRANSPARENT_NOTE_BYTES_LEN> for TransparentNote {\n\n    // Custom serialization to avoid disclosing the secret field\n    fn serialize_content(self) -> [Field; TRANSPARENT_NOTE_LEN] {\n        [self.amount, self.secret_hash]\n    }\n\n    // Custom deserialization since we don't have access to the secret plaintext\n    fn deserialize_content(serialized_note: [Field; TRANSPARENT_NOTE_LEN]) -> Self {\n        TransparentNote {\n            amount: serialized_note[0],\n            secret_hash: serialized_note[1],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): Ensure nullifier collisions are prevented\n    fn compute_note_hash_and_nullifier(self, _context: &mut PrivateContext) -> (Field, Field) {\n        self.compute_note_hash_and_nullifier_without_context()\n    }\n\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit. \n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n\n    // CUSTOM FUNCTIONS FOR THIS NOTE TYPE\n    // Custom serialization forces us to manually create the metadata struct and its getter\n    pub fn properties() -> TransparentNoteProperties {\n        TransparentNoteProperties {\n            amount: PropertySelector { index: 0, offset: 0, length: 32 },\n            secret_hash: PropertySelector { index: 1, offset: 0, length: 32 }\n        }\n    }\n}\n// docs:end:token_types_all\n"},"32":{"path":"std/merkle.nr","source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n"},"326":{"path":"/usr/src/noir-projects/noir-contracts/contracts/fpc_contract/src/main.nr","source":"mod lib;\n\ncontract FPC {\n    use dep::aztec::{\n        protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, traits::is_empty},\n        state_vars::SharedImmutable, context::gas::GasOpts\n    };\n    use dep::token::Token;\n    use dep::gas_token::GasToken;\n    use crate::lib::compute_rebate;\n\n    #[aztec(storage)]\n    struct Storage {\n        other_asset: SharedImmutable<AztecAddress>,\n        gas_token_address: SharedImmutable<AztecAddress>,\n    }\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(other_asset: AztecAddress, gas_token_address: AztecAddress) {\n        storage.other_asset.initialize(other_asset);\n        storage.gas_token_address.initialize(gas_token_address);\n    }\n\n    #[aztec(private)]\n    fn fee_entrypoint_private(amount: Field, asset: AztecAddress, secret_hash: Field, nonce: Field) {\n        assert(asset == storage.other_asset.read_private());\n        Token::at(asset).unshield(context.msg_sender(), context.this_address(), amount, nonce).call(&mut context);\n        context.set_as_fee_payer();\n        // Would like to get back to\n        // FPC::at(context.this_address()).pay_refund_with_shielded_rebate(amount, asset, secret_hash).set_public_teardown_function(&mut context);\n        context.set_public_teardown_function(\n            context.this_address(),\n            FunctionSelector::from_signature(\"pay_refund_with_shielded_rebate(Field,(Field),Field)\"),\n            [amount, asset.to_field(), secret_hash]\n        );\n    }\n\n    #[aztec(private)]\n    fn fee_entrypoint_public(amount: Field, asset: AztecAddress, nonce: Field) {\n        FPC::at(context.this_address()).prepare_fee(context.msg_sender(), amount, asset, nonce).enqueue(&mut context);\n        context.set_as_fee_payer();\n        // TODO(#6277) for improving interface:\n        // FPC::at(context.this_address()).pay_refund(context.msg_sender(), amount, asset).set_public_teardown_function(&mut context);\n        context.set_public_teardown_function(\n            context.this_address(),\n            FunctionSelector::from_signature(\"pay_refund((Field),Field,(Field))\"),\n            [context.msg_sender().to_field(), amount, asset.to_field()]\n        );\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn prepare_fee(from: AztecAddress, amount: Field, asset: AztecAddress, nonce: Field) {\n        // docs:start:public_call\n        Token::at(asset).transfer_public(from, context.this_address(), amount, nonce).call(&mut context);\n        // docs:end:public_call\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn pay_refund(refund_address: AztecAddress, amount: Field, asset: AztecAddress) {\n        // Just do public refunds for the present\n        let refund = compute_rebate(context, amount);\n        Token::at(asset).transfer_public(context.this_address(), refund_address, refund, 0).call(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn pay_refund_with_shielded_rebate(amount: Field, asset: AztecAddress, secret_hash: Field) {\n        let refund = compute_rebate(context, amount);\n        Token::at(asset).shield(context.this_address(), refund, secret_hash, 0).call(&mut context);\n    }\n}\n"},"327":{"path":"/usr/src/noir-projects/noir-contracts/contracts/fpc_contract/src/lib.nr","source":"use dep::aztec::context::PublicContext;\n\npub fn compute_rebate(context: PublicContext, initial_amount: Field) -> Field {\n    let actual_fee = context.transaction_fee();\n    assert(!initial_amount.lt(actual_fee), \"Initial amount paid to the paymaster does not cover actual fee\");\n    initial_amount - actual_fee\n}\n"},"38":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"4":{"path":"std/cmp.nr","source":"// docs:start:eq-trait\ntrait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\nimpl Eq for Field { fn eq(self, other: Field) -> bool { self == other } }\n\nimpl Eq for u64 { fn eq(self, other: u64) -> bool { self == other } }\nimpl Eq for u32 { fn eq(self, other: u32) -> bool { self == other } }\nimpl Eq for u8 { fn eq(self, other: u8) -> bool { self == other } }\nimpl Eq for u1 { fn eq(self, other: u1) -> bool { self == other } }\n\nimpl Eq for i8 { fn eq(self, other: i8) -> bool { self == other } }\nimpl Eq for i32 { fn eq(self, other: i32) -> bool { self == other } }\nimpl Eq for i64 { fn eq(self, other: i64) -> bool { self == other } }\n\nimpl Eq for () { fn eq(_self: Self, _other: ()) -> bool { true } }\nimpl Eq for bool { fn eq(self, other: bool) -> bool { self == other } }\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3) & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\nstruct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n// docs:start:ord-trait\ntrait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"44":{"path":"std/slice.nr","source":"use crate::append::Append;\n\nimpl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::unsafe::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"},"47":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"65":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::PrivateContext,\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}},\n    state_vars::{shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter}\n};\n\nglobal DELAY = 5;\n\n// docs:start:key-getters\ntrait KeyGetters {\n  fn get_npk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ivpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ovpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_tpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_npk_m_hash(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Field;\n}\n\nimpl KeyGetters for Header {\n    fn get_npk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, NULLIFIER_INDEX, self)\n    }\n\n    fn get_ivpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, INCOMING_INDEX, self)\n    }\n\n    fn get_ovpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, OUTGOING_INDEX, self)\n    }\n\n    fn get_tpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, TAGGING_INDEX, self)\n    }\n\n    fn get_npk_m_hash(self, context: &mut PrivateContext, address: AztecAddress) -> Field {\n        get_master_key(context, address, NULLIFIER_INDEX, self).hash()\n    }\n}\n// docs:end:key-getters\n\nfn get_master_key(\n    context: &mut PrivateContext,\n    address: AztecAddress,\n    key_index: Field,\n    header: Header\n) -> Point {\n    let key = fetch_key_from_registry(context, key_index, address, header);\n    if is_empty(key) {\n        // Keys were not registered in registry yet --> fetch key from PXE\n        let keys = fetch_and_constrain_keys(address);\n        // Return the corresponding to index\n        keys.get_key_by_index(key_index)\n    } else {\n        // Keys were registered --> return the key\n        key\n    }\n}\n\nfn fetch_key_from_registry(\n    context: &mut PrivateContext,\n    key_index: Field,\n    address: AztecAddress,\n    header: Header\n) -> Point {\n    let x_coordinate_map_slot = key_index * 2 + 1;\n    let y_coordinate_map_slot = x_coordinate_map_slot + 1;\n    let x_coordinate_derived_slot = derive_storage_slot_in_map(x_coordinate_map_slot, address);\n    let y_coordinate_derived_slot = derive_storage_slot_in_map(y_coordinate_map_slot, address);\n\n    let x_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        x_coordinate_derived_slot\n    );\n    let y_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        y_coordinate_derived_slot\n    );\n    let x_coordinate = x_coordinate_registry.get_value_in_private(header);\n    let y_coordinate = y_coordinate_registry.get_value_in_private(header);\n\n    Point::new(x_coordinate, y_coordinate, false)\n}\n\n// Passes only when keys were not rotated - is expected to be called only when keys were not registered yet\nfn fetch_and_constrain_keys(address: AztecAddress) -> PublicKeys {\n    let (public_keys, partial_address) = get_public_keys_and_partial_address(address);\n\n    let computed_address = AztecAddress::compute(public_keys.hash(), partial_address);\n\n    assert(computed_address.eq(address));\n\n    public_keys\n}\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n"},"80":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n"},"81":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr","source":"use std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext, oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: Header, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for Header {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier);\n\n        // 2) Check that the witness we obtained matches the nullifier\n        assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n        // 3) Compute the nullifier tree leaf\n        let nullifier_leaf = witness.leaf_preimage.hash();\n\n        // 4) Prove that the nullifier is in the nullifier tree\n        assert(\n            self.state.partial.nullifier_tree.root\n            == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n        );\n        // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n        //     was included in the nullifier tree.\n    }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, N, M>(header: Header, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M>;\n}\n\nimpl ProveNoteIsNullified for Header {\n    // docs:start:prove_note_is_nullified\n    fn prove_note_is_nullified<Note, N, M>(self, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M> {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n    // docs:end:prove_note_is_nullified\n}\n"},"89":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<N>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, N>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"9":{"path":"std/compat.nr","source":"global BN254_MODULUS_BE_BYTES: [u8] = &[\n    48, 100, 78, 114, 225, 49, 160, 41, 184, 80, 69, 182, 129, 129, 88, 93, 40, 51, 232, 72, 121, 185, 112, 145, 67, 225, 245, 147, 240, 0, 0, 1\n];\n\npub fn is_bn254() -> bool {\n    crate::field::modulus_be_bytes() == BN254_MODULUS_BE_BYTES\n}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<N, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<N, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"95":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn block_number(self) -> Field {\n        block_number()\n    }\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<N>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<N>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, N>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N)\n}\n\nunconstrained fn storage_write<N>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<N>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<N>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}