{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"Delegator","functions":[{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"private_delegate_set_value","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"target_contract","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"value","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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7vluNfd8t5p7vlvNPd+t5p7vVnPPd6u557vV3PPdau75bjX3fLeae75bzT3freae71Zzz3eruee71dzz3Wru+W4193y3mnu+W809363mnu9Wc893q7nnu9Xc891q7vluNfd8t5p7vlvNPd+t5p7vVnPPd6u557vV3PPdau75bjX3fLeae75bzT3freae71Zzz3eruee71dzz3Wru+W4193y3mnu+W809363mnu9Wc893q7nnu9Xc891q7vluNfd8t5p7vlvNPd+t5p7vVnPPD6u554fV3PPDau75YTX3/LhVq2qdvNRhNff8sJp7fljNPT+s5p4fVnPPD6u554fV3PPDau75YTX3/LCae35YzT0/rOaeH1Zzzw+rueeH1dzzw2ru+WE19/ywmnt+WM09P6zmnh9Wc88Pq7nnh9Xc88Nq7vlhNff8sJp7fljNPT+s5p4fVnPPD6u554fV3PPDau75YTX3/LCae35YzT0/rOaeH1Zzzw+rueeH1dzzw2ru+WE19/ywmnt+WM09P6zmnh9Wc88Pq7nnh9Xc88Nq7vlhNff8sJp7fljNPT+s5p4fVnPPD6u554fV3PPDau75YTX3/LCae35YzT0/rOaeH1Zzzw+rueeH1dzzw2ru+WE19/ywmnt+WM09P6zmnh9Wc88Pq7nnh9Xc88Nq7vlhNff8sJp7fljNPT+s5p4fVnPPD6u554fV3PPDau75YTX3/LCae35YzT0/rOaeH1Zzzw+rueeH1dzzw2ru+WE19/ywmnt+WM09P6zmnh9Wc88Pp7nn281p7vm9WiMvda/WyEvdqzXyUvdqq1W1Rl7qXq2Rl7pXa+Sl7tUaeal7tVZeymnu+b1aKy/lNPf8Xq2Vl3Kae36v1spLOc09v1dr5aWc5p7fq7XyUk5zz+/VWnkpp7nn92qtvJTT3PN7tVZeymnu+b1aKy/lNPf8Xq2Vl3Kae36v1spLOc09v1dr5aWc5p7fq7XyUk5zz+/VWnkpp7nn92qtvJTT3PN7tVZeymnu+b1aKy/lNPf8Xq2Vl3Kae36v1spLOc09v1dr5aWc5p7fq7XyUk5zz+/VWnkpp7nn92qtvJTT3PN7tVZeymnu+b1aKy/lNPf8Xq2Vl3Kae36v1spLOc09v1dr5aWc5p7fq7XyUk5zz+/VWnkpp7nn92qtvJTT3PN7tVZeymnu+b1aKy/lNPf8Xq2Vl3Kae36v1spLOc09v1dr5aWc5p7fq7XyUk5zz+/VWnkpp7nn92qtvJTT3PN7tVZeymnu+b1aKy/lNPf8Xq2Vl3Kae36v1spLOc09v1dr5aWc5p7fq3XyUsVq7nmxmnterOaeF6u55/darKp18lLFau55sZp7XqzmnheruefFau55sZp7XqzmnheruefFau55sZp7XqzmnheruefFau55sZp7XqzmnheruefFau55sZp7XqzmnheruefFau55sZp7XqzmnheruefFau55sZp7XqzmnheruefFau55sZp7XqzmnheruefFau55sZp7XqzmnheruefFau55sZp7XqzmnheruefFau55sZp7XqzmnheruefFau55sZp7XqzmnheruefFau55sZp7XqzmnheruefFau55sZp7XqzmnheruefFau55sZp7XqzmnheruefFau55sZp7XqzmnheruefFau55sZp7XqzmnheruefFau55sZp7XqzmnheruefFau55sZp7XqzmnheruefFau55sZp7XqzmnheruefFau55sZp7XqzmnpdMs7Hvp749Tz0dje9+5xzzPC+/PjzPe/k6x1H/5jdPt+nx4em2fWd3vPrm/Xh+89T45qVOvz671Pm19oncB9q/qX0iL4b2b2pf0d5W+0Q+He3f1D5RakH7N7VPlOHQ/k3tEyVatH9T+0S/laD9W9pPmTaToP2b2tPX89Wevl5W7fcHjOVYXmtPX89X+4r2ttrT1/PVnr5eVu23L+3X19rT1/PVnr6er/b09Wy1z7QlD+3f1J6+nq/29PWyar88/k53WbfX2tPX89W+or2t9vT1fLWnr+erPX09X+3p6/lqT1/PVvtMG5vR/k3t6ev5ak9fz1d7+nq+2le0t9Wevp6v9vT1fLWnr+erPX09X+3p69lqP9PX89Wevp6v9vT1fLWnr+erfUV7W+3p6/lqT1/PV3v6er7a09fz1Z6+nq32lb6er/b09Xy1p6/nqz19PV/tK9rbak9fz1d7+nq+2tPX89Wevp6v9vT1bLVf6Ov5ak++H6r9/RseEpXjmJXaN/dmLBXtbbUn3/tqT7731Z5876s9+d5Xe/K9rfYr+d5Xe/5ux1d7/m7HV3v6er7aV7RPqn1zN+JKX89Xe/p6vtrT1/PVnr5eVu2bO9JW+nq22m/09Xy1p6/n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v+3zx75/m+evse/f9vlj37/t88e+f9vnj33/ts8f+/5tn//i92+9+P1bL37/1ovfv/Xi9+9y8ft3ufj9u1z8/l0ufv8OmPGuPf/F79/l4vfvcvH7d7n4/btc/P5dL37/rhe/f9eL37/rxe/fAfOltee/+P27Xvz+XS9+/64Xv3/Xi9+/28Xv3+3i9+928ft3u/j9q5lTWh5Hmspaledv/v2VZprowPPvFz//ce3za+ZnDjx/ufj5p4uff774+evFz79c/PwXv3/32Pdv8+9X99j3b/v8se/f5vmP2Pdv+/yx79/m308ese/f9vlj37/t88e+f9vnj33/ts8f+/5tnz/2/dvsPxyx79/2+WPfv63zL7fY92/7/LHv3/b5Y9+/7fPHvn/b5499/7bPH/v+bZ8/9v3bPv+179/ldu37d7ld/P4tF79/y8Xv33Lx+7dc/P7VzF8aeP6L37/l4vdvufj9Wy5+/5aL37/Txe/f6eL373Tx+3e6+P2rmb808PwXv3+ni9+/08Xv3+ni9+908ft3vvj9O1/8/p0vfv/OF79/NfOXBp7/4vevZP7PrS6P89+Om/L8rb+/WiTzfwaeXzL/Z+T5y8XPP138/PPFz18vfv7l4udfL37+7eLnv/j9W2Pfv62/X12W2Pdv+/yx79/2+WPfv+3zx75/W38/uUjm/4w8f+z7t33+2Pdv+/yx79/2+WPfv+3zx75/m/2HNfb92z5/7Pu3ff7Y92/7/LHv3/b5Y9+/7fPHvn/b5499/7bPH/v+bZ8/9v3bPv/F79/t4vfvdvH7d7v4/btd/P7dLn7/bhe/f7eL37/bxe/f7eL373bx+3e/+P27X/z+3S9+/+4Xv38l85dGnv/i9+9+8ft3v/j9u1/8/t0vfv8eF79/j4vfv8fF79/j4vevZP7SyPNf/P49Ln7/Hhe+f2/bf3z9+ua8P85Ty/F1+Gl7/GOv35ps/2Plr/1j01/7x+b3/7Gy/MeTiQDr9hD021/C/Ps/dv/f/n//+f/45//8v/y3//o/7v/EP/4f/89/+V//9Z//+7/8+l//9f//v//f/y/3z/5f"},{"name":"public_delegate_set_value","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"target_contract","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"value","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"view_public_value","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/7VUPU/DMBR00nyYpCBgACEx+CekG2MLEwsDA3tamxIBseQkEvx5RCzZ5HBcCdH0JOtdnvzOzxfbARkQmBiT3wiIJxERPwIPx9wF8CsTV0qVn6yqufhgsmuZfGZr2dW8+am8NpFCNevH0vBiH9wUi8QVB6RksCSHeaHJnUHO9pv148TwrWhv3+Tm9aF7XwuFXoQefxgZQ6udD2p3sm5VuWlXnCvRNFg98yh+7VDMQPGlrOp7jlXR/5SehGoqWWNV/Ecl7UYC3M6jzvfS8GI/LLRubrTYhLpaM3X25l4hBtz2QMlwBKfsJ4M1mlaqciseRcnxcqZOmxjd32a/8QGYAQ+BJ5585OjtihR02YR2BGT8jFBnHxR6n3Dt4lBHTu9pbrRio237z8F3O+fSxFMyBmrZPu35sJrH4NUc1nF91LkQPNU46sc3EZZJnHYGAAA=","debug_symbols":"7ZjRaoMwFIbfJdcycnKSk9hXGWPY1g5BtFQ7GOK7L3YmbhjWC2GQNVdyzMefP99VyMCO5f769lo1p7Zju+eB1e2h6Ku2sdPA+JO6/ezORTPNXV9cerbjGSubo/2OGTtVdcl2KHHMVpwWeia1NJ41ZnzJbDRtijYwk4bTKlpviTboowOtzaZoLVy0WUfnoWggchKBcnVnA1CGe1pIT4OkII2eVqS+FwrAiOhgyeF3mNAdlMySCygCrESaWan0D/ZmBfhjakHjWEkQ0AJJS0iLSFpCWjBpCWmRSUtIi0paQlroH2kB7bXQRi06aQlpMX+vBdSihe5oyaW7dkGuliIC5dw/j7u/4JH3h8j7i8j7Y+T9Zbz97fReXKpiX5fTO8S0eG0O7lnCjv3H+WvFsp8="},{"name":"enqueued_delegate_set_value","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"target_contract","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"value","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"7ZzRbuIwEEX/Jc+o8ozHY7u/slqtaEtXSBVUha60Qvz7JjRxQojwtqRoouEJQsbxvUdOch3h7IqnxcP771/L1fN6U9z/2BUv68f5drlelVu7Aujw2+Z1vqo2N9v527a4N7NisXoqP/ez4nn5sijuLdn97KQOGWJdikyQqgFhoNp6wrraBhMz1ZEi1dXROZuqkcz+56wAN1XhfD3hBB7qakILFwr3lwi3AU1i6DhVRzocO3zjsePQsSOEugkY4zId+AgNRx87HKP97tGC5rriRx0xCCOI51Z84K74qgMcoQMKZzqwI3QQfV0dIMbz+BEsN0QRXITeWEa6th4Gm/QwH+kZGPrUnojE7XiAcjwMKPGNVd8BDzV5p8Ypq3Hq1TgNapxGLU6tUeMU1DhFNU6tbKeOm2rLxmedtkI6qZOHhAD7ZsYEHrGtBv40Q7oxvJih8Fw3CYbCE+MkGArPopNgKDzlToKh8Pw8BYYkPJlPgqHwzD8JhsJnE5NgqHae4h0lht4dMay40I3LIBe184kMF7VzhAwXtbk/w0Vtls9wUZvPz3NxajN3hovaHJ3hojYbB+MajwH5hIvavJvhQjcug1zU5t0MF7V5N8NFbd7NcFGbdzNc1Obd81xYbd7NcFGbdzNchOddTn97tcwuw6XUl4rhiEvlVHiCHdEpqXEqPGWO6FR4bhzRqfAkOKJT4dluRKfC09p4Tr3w/DWiU+GJakSn189IaXUTQgh43inaANyU2+BCt7ySb6XL9638iK4vn4TLj7Y5OJKBE/pOtnwyllv53vfls3D5aDDJR2/68r10+SEk+dZhX34QLt85l+R3r7K1/ChcvjcmyfehTz9c/V4e0zqK8jv1LyUBhOm5+n0xxpQAyvM+kwC66g101gj7w1092EmrpymrR7iDQfxgQnM5BzhalO4+1jnfDS9ZBA/pKVfsPT+r28WvtRteTvcf7eCL7fDT7cqtP/O35fzhZVG9LKPa+b56bN6dUW5u/75+7Clr/wE="},{"name":"get_private_value","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"current_value","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"a_map_with_private_values","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"current_value","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"a_map_with_private_values","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"target_contract","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"value","type":{"kind":"field"}}],"kind":"struct","path":"Delegator::public_delegate_set_value_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"Delegator::public_delegate_set_value_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"target_contract","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"value","type":{"kind":"field"}},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Delegator::private_delegate_set_value_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"Delegator::private_delegate_set_value_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"target_contract","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"value","type":{"kind":"field"}}],"kind":"struct","path":"Delegator::enqueued_delegate_set_value_parameters"}}],"kind":"struct","path":"Delegator::enqueued_delegate_set_value_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"amount","type":{"kind":"field"}},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Delegator::get_private_value_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"Delegator::get_private_value_abi"}]}},"file_map":{"110":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr","source":"use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus, PropertySelector},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\n\nmod test;\n\nfn extract_property_value_from_selector<N>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note. \n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value = serialized_note[selector.index].to_be_bytes(32);\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, N, M>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<N>(serialized_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let is_equal = value_field == select.value.to_field();\n        let is_lt = value_field.lt(select.value.to_field());\n\n        if (select.comparator == Comparator.EQ) {\n            assert(is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(is_lt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(is_lt | is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!is_lt & !is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!is_lt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N, M> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    context.push_note_hash_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, M, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> where Note: NoteInterface<N, M> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nfn constrain_get_notes_internal<Note, N, M, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> where Note: NoteInterface<N, M> {\n    let mut returned_notes = BoundedVec::new();\n\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        let opt_note = filtered_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n\n            // The below code is used to collapse a sparse array into one where the values are guaranteed to be at the \n            // front of the array. This is highly useful because the caller knows that the returned array won't have\n            // more than option.limits notes, and can therefore loop over this limit value instead of the entire array,\n            // resulting in a smaller circuit and faster proving times.\n            // We write at returned_notes[num_notes] because num_notes is only advanced when we have a value in \n            // filtered_notes.\n            returned_notes.push(note);\n        };\n    }\n\n    // As long as we only loop till `options.limit` the array will be guaranteed to be at most of length `options.limit`.\n    assert(returned_notes.len() <= options.limit, \"Got more notes than limit.\");\n    // We will however check that nothing else was returned after the limit.\n    for i in options.limit..filtered_notes.len() {\n        assert(filtered_notes[i].is_none(), \"Got more notes than limit.\");\n    }\n\n    assert(returned_notes.len() != 0, \"Cannot return zero notes\");\n\n    returned_notes\n}\n\nunconstrained fn get_note_internal<Note, N, M>(storage_slot: Field) -> Note where Note: NoteInterface<N, M> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, M, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N, M> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained pub fn view_notes<Note, N, M>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N, M>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N, M> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n"},"112":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__INNER_NOTE_HASH,\n    hash::{\n    pedersen_hash, compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_inner_note_hash_from_preimage(storage_slot: Field, note_content_hash: Field) -> Field {\n    pedersen_hash(\n        [storage_slot, note_content_hash],\n        GENERATOR_INDEX__INNER_NOTE_HASH\n    )\n}\n\nfn compute_inner_note_hash<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    compute_inner_note_hash_from_preimage(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N, M>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let (_, inner_nullifier) = note_with_header.compute_note_hash_and_nullifier(context);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\nfn compute_note_hash_for_read_request_from_innter_and_nonce(\n    inner_note_hash: Field,\n    nonce: Field\n) -> Field {\n    // TODO(#1386): This if-else can be nuked once we have nonces injected from public\n    if (nonce == 0) {\n        // If nonce is zero, that means we are reading a public note.\n        inner_note_hash\n    } else {\n        compute_unique_note_hash(nonce, inner_note_hash)\n    }\n}\n\npub fn compute_note_hash_for_read_request<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let inner_note_hash = compute_inner_note_hash(note);\n    let nonce = note.get_header().nonce;\n\n    compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, nonce)\n}\n\npub fn compute_note_hash_for_consumption<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    if (header.note_hash_counter != 0) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        inner_note_hash\n    } else {\n        // If a note is not transient, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the siloed_note_hash which has already been hashed with\n        // nonce and then contract address. This hash will match the existing leaf in the note hash\n        // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, header.nonce);\n        compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, N, M, S>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n    let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, note_header.nonce);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        let (_, nullifier) = note.compute_note_hash_and_nullifier_without_context();\n        nullifier\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [inner_note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"125":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"127":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle<N>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<N>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<N>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n"},"132":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<N>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field\n) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number as Field, N)\n}\n\nunconstrained pub fn storage_read<T, N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"135":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n"},"138":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        inner_note_hash,\n        counter\n    )\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field, _counter: u32) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(\n    nullifier: Field,\n    inner_note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash, counter)\n}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, NB, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N, NB> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n// Only ever use this in private!\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n// Only ever use this in private!\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n"},"140":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{\n    abis::{\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\n    utils::reader::Reader,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n}\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\n    let mut reader = Reader::new(fields);\n\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n    // WARNING: if updating, see comment in public_call_stack_item.ts's PublicCallStackItem.hash()\n    let item = PublicCallStackItem {\n        contract_address: AztecAddress::from_field(reader.read()),\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\n        public_inputs: PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            args_hash: reader.read(),\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            end_side_effect_counter: 0,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0\n        },\n        is_execution_request: true\n    };\n    reader.finish();\n\n    item\n}\n"},"144":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{hash::pedersen_hash, storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"146":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UnconstrainedContext> {\n    unconstrained pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"153":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr","source":"use dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE, lifecycle::{create_note, create_note_hash_from_public, destroy_note},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader, note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note> PrivateSet<Note, &mut PublicContext> {\n    // docs:start:insert_from_public\n    pub fn insert_from_public<N, M>(self, note: &mut Note) where Note: NoteInterface<N, M> {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note> PrivateSet<Note, &mut PrivateContext> {\n    // docs:start:insert\n    pub fn insert<N, M>(self, note: &mut Note) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    // docs:start:remove\n    pub fn remove<N, M>(self, note: Note) where Note: NoteInterface<N, M> {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read = self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note(self.context, note);\n    }\n    // docs:end:remove\n\n    // docs:start:get_notes\n    pub fn get_notes<N, M, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> where Note: NoteInterface<N, M> {\n        get_notes(self.context, self.storage_slot, options)\n    }\n    // docs:end:get_notes\n}\n\nimpl<Note> PrivateSet<Note, UnconstrainedContext> {\n    // docs:start:view_notes\n    unconstrained pub fn view_notes<N, M>(\n        self,\n        options: NoteViewerOptions<Note, N, M>\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N, M> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"},"167":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{GAS_LENGTH, FIXED_DA_GAS, FIXED_L2_GAS}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\n    abis::gas_fees::GasFees\n};\nuse std::ops::{Add, Sub};\n\nstruct Gas {\n    da_gas: u32,\n    l2_gas: u32,\n}\n\nimpl Gas {\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\n        Self { da_gas, l2_gas }\n    }\n\n    pub fn tx_overhead() -> Self {\n        Self { da_gas: FIXED_DA_GAS, l2_gas: FIXED_L2_GAS }\n    }\n\n    pub fn compute_fee(self, fees: GasFees) -> Field {\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.da_gas == 0) & (self.l2_gas == 0)\n    }\n\n    pub fn within(self, limits: Gas) -> bool {\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\n    }\n}\n\nimpl Add for Gas {\n    fn add(self, other: Gas) -> Self {\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\n    }\n}\n\nimpl Sub for Gas {\n    fn sub(self, other: Gas) -> Self {\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\n    }\n}\n\nimpl Serialize<GAS_LENGTH> for Gas {\n    fn serialize(self) -> [Field; GAS_LENGTH] {\n        [self.da_gas as Field, self.l2_gas as Field]\n    }\n}\n\nimpl Deserialize<GAS_LENGTH> for Gas {\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\n    }\n}\n\nimpl Eq for Gas {\n    fn eq(self, other : Gas) -> bool {\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\n    }\n}\n\nimpl Empty for Gas {\n    fn empty() -> Self {\n        Gas::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Gas::empty();\n    let serialized = item.serialize();\n    let deserialized = Gas::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n"},"169":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr","source":"use crate::{\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct NoteHash {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for NoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteHash {\n    fn eq(self, other: NoteHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter) \n    }\n}\n\nimpl Empty for NoteHash {\n    fn empty() -> Self {\n        NoteHash {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl NoteHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNoteHash {\n        ScopedNoteHash { note_hash: self, contract_address }\n    }\n}\n\nstruct ScopedNoteHash {\n    note_hash: NoteHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<NoteHash> for ScopedNoteHash {\n    fn inner(self) -> NoteHash {\n        self.note_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNoteHash {\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNoteHash {\n    fn value(self) -> Field {\n        self.note_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl Eq for ScopedNoteHash {\n    fn eq(self, other: ScopedNoteHash) -> bool {\n        (self.note_hash == other.note_hash)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedNoteHash {\n    fn empty() -> Self {\n        ScopedNoteHash {\n            note_hash: NoteHash::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\n        array_concat(self.note_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            note_hash: reader.read_struct(NoteHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNoteHash {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.note_hash.value, read_request.value(), \"Value of the note hash does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the note hash does not match read request\");\n        assert(\n            read_request.counter() > self.note_hash.counter, \"Read request counter must be greater than the counter of the note hash\"\n        );\n    }\n}\n\nimpl ScopedNoteHash {\n    pub fn expose_to_public(self) -> NoteHash {\n        // Hide the actual counter when exposing it to the public kernel.\n        NoteHash { value: self.note_hash.value, counter: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = NoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"170":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"172":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr","source":"use crate::{\n    abis::{\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    transaction::tx_context::TxContext, utils::arrays::validate_array\n};\n\nstruct PrivateCircuitPublicInputsArrayLengths {\n    note_hash_read_requests: u32,\n    nullifier_read_requests: u32,\n    key_validation_requests_and_generators: u32,\n    note_hashes: u32,\n    nullifiers: u32,\n    l2_to_l1_msgs: u32,\n    private_call_requests: u32,\n    public_call_stack_hashes: u32,\n    note_encrypted_logs_hashes: u32,\n    encrypted_logs_hashes: u32,\n    unencrypted_logs_hashes: u32,\n}\n\nimpl PrivateCircuitPublicInputsArrayLengths {\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\n        PrivateCircuitPublicInputsArrayLengths {\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\n            note_hashes: validate_array(public_inputs.note_hashes),\n            nullifiers: validate_array(public_inputs.nullifiers),\n            l2_to_l1_msgs: validate_array(public_inputs.l2_to_l1_msgs),\n            private_call_requests: validate_array(public_inputs.private_call_requests),\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\n        }\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    note_hashes: [NoteHash; MAX_NOTE_HASHES_PER_CALL],\n    nullifiers: [Nullifier; MAX_NULLIFIERS_PER_CALL],\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs: [L2ToL1Message; MAX_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    tx_context: TxContext,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.returns_hash == other.returns_hash) &\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\n        (self.is_fee_payer == other.is_fee_payer) &\n        (self.max_block_number == other.max_block_number) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\n        (self.note_hashes == other.note_hashes) &\n        (self.nullifiers == other.nullifiers) &\n        (self.private_call_requests == other.private_call_requests) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.l2_to_l1_msgs == other.l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\n        self.historical_header.eq(other.historical_header) &\n        self.tx_context.eq(other.tx_context)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\n\n        fields.extend_from_array(self.max_block_number.serialize());\n\n        for i in 0..self.note_hash_read_requests.len() {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..self.nullifier_read_requests.len() {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..self.key_validation_requests_and_generators.len() {\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\n        }\n        for i in 0..self.note_hashes.len() {\n            fields.extend_from_array(self.note_hashes[i].serialize());\n        }\n        for i in 0..self.nullifiers.len() {\n            fields.extend_from_array(self.nullifiers[i].serialize());\n        }\n        for i in 0..self.private_call_requests.len() {\n            fields.extend_from_array(self.private_call_requests[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n        fields.push(self.public_teardown_function_hash);\n        for i in 0..self.l2_to_l1_msgs.len() {\n            fields.extend_from_array(self.l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        for i in 0..self.note_encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.unencrypted_logs_hashes.len() {\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.tx_context.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            is_fee_payer: reader.read() == 1,\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL]),\n            nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL]),\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            public_teardown_function_hash: reader.read(),\n            l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            tx_context: reader.read_struct(TxContext::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PrivateCircuitPublicInputs {\n    fn empty() -> Self {\n        PrivateCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter : 0 as u32,\n            end_side_effect_counter : 0 as u32,\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            tx_context: TxContext::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PrivateCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PrivateCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x15c9b0a92b9b541598e24c9f0b0b4b04b7f2408599751c45aa12de671fd9b363;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"173":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item_compressed.nr","source":"use crate::abis::{call_context::CallContext, function_data::FunctionData, gas::Gas};\nuse crate::address::AztecAddress;\nuse crate::constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH};\nuse crate::traits::{Hash, Empty, Serialize, Deserialize};\nuse crate::utils::reader::Reader;\n\n/**\n * A compressed version of the PublicCallStackItem struct used to compute the \"hash\"\n * of a PublicCallStackItem.\n * \n * Historically, we have been zeroing most values in the PublicCallStackItem struct\n * to compute the hash involved when adding a PublicCallStackItem to the PublicCallStack.\n * \n * This struct is used to store the values that we did not zero out, and allow us to hash\n * only these, thereby skipping a lot of computation and saving us a lot of constraints\n * \n * Essentially this struct exists such that we don't have a `hash` function in the \n * PublicCallStackItem struct that practically throws away some values of the struct\n * without clearly indicating that it does so.\n */\nstruct PublicCallStackItemCompressed {\n    contract_address: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    revert_code: u8,\n    start_gas_left: Gas,\n    end_gas_left: Gas,\n}\n\nimpl Eq for PublicCallStackItemCompressed {\n    fn eq(self, other: PublicCallStackItemCompressed) -> bool {\n        (self.contract_address == other.contract_address)\n            & (self.call_context == other.call_context)\n            & (self.function_data == other.function_data)\n            & (self.args_hash == other.args_hash)\n            & (self.returns_hash == other.returns_hash)\n            & (self.revert_code == other.revert_code)\n            & (self.start_gas_left == other.start_gas_left)\n            & (self.end_gas_left == other.end_gas_left)\n    }\n}\n\nimpl Hash for PublicCallStackItemCompressed {\n    fn hash(self) -> Field {\n        std::hash::pedersen_hash_with_separator(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PublicCallStackItemCompressed {\n    fn empty() -> Self {\n        PublicCallStackItemCompressed {\n            contract_address: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n    fn serialize(self) -> [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.push(self.revert_code as Field);\n        fields.extend_from_array(self.start_gas_left.serialize());\n        fields.extend_from_array(self.end_gas_left.serialize());\n\n        assert_eq(fields.len(), PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n  fn deserialize(fields: [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH]) -> PublicCallStackItemCompressed {\n    let mut reader = Reader::new(fields);\n\n    let item = PublicCallStackItemCompressed {\n      contract_address: reader.read_struct(AztecAddress::deserialize),\n      call_context: reader.read_struct(CallContext::deserialize),\n      function_data: reader.read_struct(FunctionData::deserialize),\n      args_hash: reader.read(),\n      returns_hash: reader.read(),\n      revert_code: reader.read() as u8,\n      start_gas_left: reader.read_struct(Gas::deserialize),\n      end_gas_left: reader.read_struct(Gas::deserialize),\n    };\n    reader.finish();\n    item\n  }\n}\n"},"175":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n"},"176":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr","source":"use crate::{\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for ReadRequest {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\n        ScopedReadRequest { read_request: self, contract_address }\n    }\n}\n\nstruct ScopedReadRequest {\n    read_request: ReadRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<ReadRequest> for ScopedReadRequest {\n    fn inner(self) -> ReadRequest {\n        self.read_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ScopedReadRequest {\n    fn eq(self, other: ScopedReadRequest) -> bool {\n        (self.read_request == other.read_request)\n        & (self.contract_address.eq(other.contract_address))\n    }\n}\n\nimpl Empty for ScopedReadRequest {\n    fn empty() -> Self {\n        ScopedReadRequest {\n            read_request: ReadRequest::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            read_request: reader.read_struct(ReadRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedReadRequest {\n    pub fn value(self) -> Field {\n        self.read_request.value\n    }\n    pub fn counter(self) -> u32 {\n        self.read_request.counter\n    }\n}\n\n#[test]\nfn serialization_of_empty_read() {\n    let item = ReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"179":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr","source":"use crate::{\n    address::AztecAddress,\n    abis::validation_requests::{\n    key_validation_request::KeyValidationRequest,\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\n},\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct KeyValidationRequestAndGenerator {\n    request: KeyValidationRequest,\n    sk_app_generator: Field,\n}\n\nimpl Eq for KeyValidationRequestAndGenerator {\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\n    }\n}\n\nimpl Empty for KeyValidationRequestAndGenerator {\n    fn empty() -> Self {\n        KeyValidationRequestAndGenerator {\n            request: KeyValidationRequest::empty(),\n            sk_app_generator: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\n        array_concat(self.request.serialize(), [self.sk_app_generator])\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\n        let mut reader = Reader::new(fields);\n        let res = Self {\n            request: reader.read_struct(KeyValidationRequest::deserialize),\n            sk_app_generator: reader.read(),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl KeyValidationRequestAndGenerator {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = KeyValidationRequestAndGenerator::empty();\n    let serialized = item.serialize();\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"180":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point::new(fields[0], fields[1], fields[2] as bool),\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"184":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr","source":"use crate::{\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH},\n    hash::compute_siloed_nullifier, traits::{Empty, Hash, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct Nullifier {\n    value: Field,\n    counter: u32,\n    note_hash: Field,\n}\n\nimpl Ordered for Nullifier {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for Nullifier {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for Nullifier {\n    fn eq(self, other: Nullifier) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.note_hash == other.note_hash) \n    }\n}\n\nimpl Empty for Nullifier {\n    fn empty() -> Self {\n        Nullifier {\n            value: 0,\n            counter: 0,\n            note_hash: 0,\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\n        [self.value, self.counter as Field, self.note_hash]\n    }\n}\n\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            note_hash: values[2],\n        }\n    }\n}\n\nimpl Readable for Nullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        // Public kernels output Nullifier instead of ScopedNullifier.\n        // The nullifier value has been siloed.\n        let siloed_request_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.value, siloed_request_value, \"Value of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl Nullifier {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\n        ScopedNullifier { nullifier: self, contract_address }\n    }\n}\n\nstruct ScopedNullifier {\n    nullifier: Nullifier,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<Nullifier> for ScopedNullifier {\n    fn inner(self) -> Nullifier {\n        self.nullifier\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNullifier {\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNullifier {\n    fn value(self) -> Field {\n        self.nullifier.value\n    }\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl Eq for ScopedNullifier {\n    fn eq(self, other: ScopedNullifier) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedNullifier {\n    fn empty() -> Self {\n        ScopedNullifier {\n            nullifier: Nullifier::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            nullifier: reader.read_struct(Nullifier::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.nullifier.value, read_request.value(), \"Value of the nullifier does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.nullifier.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl ScopedNullifier {\n    pub fn nullified_note_hash(self) -> Field {\n        self.nullifier.note_hash\n    }\n\n    pub fn expose_to_public(self) -> Nullifier {\n        // Hide the actual counter and note hash when exposing it to the public kernel.\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Nullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = Nullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"193":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"194":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr","source":"use crate::{\n    abis::{\n    private_call_stack_item::PrivateCallStackItem, call_context::CallContext,\n    function_data::FunctionData, caller_context::CallerContext,\n    side_effect::{Ordered, RangeOrdered, Scoped}\n},\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PrivateCallRequest {\n    target: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Ordered for PrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.start_side_effect_counter\n    }\n}\n\nimpl RangeOrdered for PrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.start_side_effect_counter\n    }\n    fn counter_end(self) -> u32 {\n        self.end_side_effect_counter\n    }\n}\n\nimpl Eq for PrivateCallRequest {\n    fn eq(self, other: PrivateCallRequest) -> bool {\n        (self.target == other.target) \n            & (self.call_context == other.call_context) \n            & (self.function_data == other.function_data) \n            & (self.args_hash == other.args_hash) \n            & (self.returns_hash == other.returns_hash)\n            & (self.caller_context == other.caller_context)\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\n    }\n}\n\nimpl Empty for PrivateCallRequest {\n    fn empty() -> Self {\n        PrivateCallRequest {\n            target: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.push(self.target.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.extend_from_array(self.caller_context.serialize());\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = PrivateCallRequest {\n            target: reader.read_struct(AztecAddress::deserialize),\n            call_context: reader.read_struct(CallContext::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            caller_context: reader.read_struct(CallerContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            end_side_effect_counter: reader.read_u32(),\n        };\n        reader.finish();\n        item\n    }\n}\n\nimpl PrivateCallRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\n        ScopedPrivateCallRequest { call_request: self, contract_address }\n    }\n\n    pub fn matches_stack_item(self, stack_item: PrivateCallStackItem) -> bool {\n        (self.target == stack_item.contract_address)\n            & (self.call_context == stack_item.public_inputs.call_context)\n            & (self.function_data == stack_item.function_data)\n            & (self.args_hash == stack_item.public_inputs.args_hash)\n            & (self.returns_hash == stack_item.public_inputs.returns_hash)\n            & (self.start_side_effect_counter\n                                == stack_item.public_inputs.start_side_effect_counter)\n            & (self.end_side_effect_counter\n                                    == stack_item.public_inputs.end_side_effect_counter)\n    }\n}\n\nstruct ScopedPrivateCallRequest {\n    call_request: PrivateCallRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\n    fn inner(self) -> PrivateCallRequest {\n        self.call_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedPrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.call_request.counter_start()\n    }\n}\n\nimpl RangeOrdered for ScopedPrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.call_request.counter_start()\n    }\n    fn counter_end(self) -> u32 {\n        self.call_request.counter_end()\n    }\n}\n\nimpl Eq for ScopedPrivateCallRequest {\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\n        (self.call_request == other.call_request)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedPrivateCallRequest {\n    fn empty() -> Self {\n        ScopedPrivateCallRequest {\n            call_request: PrivateCallRequest::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.call_request.serialize());\n        fields.extend_from_array(self.contract_address.serialize());\n\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = ScopedPrivateCallRequest {\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        item\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = ScopedPrivateCallRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"199":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\n    abis::gas_fees::GasFees,\n    constants::{\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\n    DEFAULT_INCLUSION_FEE\n},\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    utils::reader::Reader\n};\n\nstruct GasSettings {\n    gas_limits: Gas,\n    teardown_gas_limits: Gas,\n    max_fees_per_gas: GasFees,\n    inclusion_fee: Field,\n}\n\nimpl GasSettings {\n    pub fn new(\n        gas_limits: Gas,\n        teardown_gas_limits: Gas,\n        max_fees_per_gas: GasFees,\n        inclusion_fee: Field\n    ) -> Self {\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\n    }\n\n    pub fn default() -> Self {\n        GasSettings::new(\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\n            DEFAULT_INCLUSION_FEE\n        )\n    }\n}\n\nimpl Eq for GasSettings {\n    fn eq(self, other: Self) -> bool {\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\n    }\n}\n\nimpl Empty for GasSettings {\n    fn empty() -> Self {\n        GasSettings::new(\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\n        )\n    }\n}\n\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\n\n        serialized.extend_from_array(self.gas_limits.serialize());\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\n        serialized.push(self.inclusion_fee);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\n        let mut reader = Reader::new(serialized);\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasSettings::empty();\n    let serialized = item.serialize();\n    let deserialized = GasSettings::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"208":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr","source":"use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PrivateCallStackItem {\n    fn empty() -> Self {\n        PrivateCallStackItem {\n            contract_address: AztecAddress::empty(),\n            function_data: FunctionData::empty(),\n            public_inputs: PrivateCircuitPublicInputs::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = PrivateCallStackItem::empty();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item = PrivateCallStackItem::empty();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x065f2831db9ac0db5e710bd3a865b5facd8cf83f1585e1af8fd1d6ce9c47f685;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr","source":"use crate::address::AztecAddress;\nuse crate::traits::{Empty, Serialize, Deserialize};\nuse crate::constants::CALLER_CONTEXT_LENGTH;\nuse crate::utils::reader::Reader;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n    is_static_call: bool,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, other: CallerContext) -> bool {\n        other.msg_sender.eq(self.msg_sender)\n            & other.storage_contract_address.eq(self.storage_contract_address)\n            & other.is_static_call == self.is_static_call\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n            is_static_call: false,\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\n    }\n\n    // Different to an empty context, a hidden context won't reveal the caller's msg_sender and storage_contract_address,\n    // but will still propagate the is_static_call flag.\n    pub fn is_hidden(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array(self.msg_sender.serialize());\n    fields.extend_from_array(self.storage_contract_address.serialize());\n    fields.push(self.is_static_call as Field);\n\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\n    let mut reader = Reader::new(fields);\n\n    let item = CallerContext {\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\n      is_static_call: reader.read_bool(),\n    };\n    reader.finish();\n    item\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = CallerContext::empty();\n    let serialized = item.serialize();\n    let deserialized = CallerContext::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"211":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr","source":"use crate::{\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\n    constants::{\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\n},\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct LogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n}\n\nimpl Ordered for LogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for LogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for LogHash {\n    fn eq(self, other: LogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n    }\n}\n\nimpl Empty for LogHash {\n    fn empty() -> Self {\n        LogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n        }\n    }\n}\n\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length]\n    }\n}\n\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n        }\n    }\n}\n\nimpl LogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\n        ScopedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedLogHash {\n    log_hash: LogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<LogHash> for ScopedLogHash {\n    fn inner(self) -> LogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedLogHash {\n    fn eq(self, other: ScopedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedLogHash {\n    fn empty() -> Self {\n        ScopedLogHash {\n            log_hash: LogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(LogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the counter when exposing to public.\n        // The log hash must already be siloed when we call this.\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nstruct EncryptedLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    randomness: Field,\n}\n\nimpl Ordered for EncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for EncryptedLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for EncryptedLogHash {\n    fn eq(self, other: EncryptedLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.randomness == other.randomness) \n    }\n}\n\nimpl Empty for EncryptedLogHash {\n    fn empty() -> Self {\n        EncryptedLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            randomness: 0,\n        }\n    }\n}\n\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.randomness]\n    }\n}\n\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            randomness: values[3],\n        }\n    }\n}\n\nimpl EncryptedLogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedEncryptedLogHash {\n    log_hash: EncryptedLogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\n    fn inner(self) -> EncryptedLogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl ScopedEncryptedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the secret randomness and counter when exposing to public\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\n        // The log hash will already be silo'd when we call this\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nimpl Ordered for ScopedEncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedEncryptedLogHash {\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedEncryptedLogHash {\n    fn empty() -> Self {\n        ScopedEncryptedLogHash {\n            log_hash: EncryptedLogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct NoteLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    note_hash_counter: u32,\n}\n\nimpl NoteLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\n        LogHash { value: self.value, counter: 0, length: self.length }\n    }\n}\n\nimpl Ordered for NoteLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for NoteLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteLogHash {\n    fn eq(self, other: NoteLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.note_hash_counter == other.note_hash_counter) \n    }\n}\n\nimpl Empty for NoteLogHash {\n    fn empty() -> Self {\n        NoteLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            note_hash_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            note_hash_counter: values[3] as u32,\n        }\n    }\n}\n"},"215":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr","source":"struct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n"},"216":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n}\n// docs:end:call-context\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n"},"217":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"22":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"220":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize, Empty}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        (self.is_private == other.is_private)\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nimpl Empty for FunctionData {\n    fn empty() -> Self {\n        FunctionData {\n            selector: FunctionSelector::empty(),\n            is_private: false\n        }\n    }\n\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data = FunctionData::empty();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data = FunctionData::empty();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty function data hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"227":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n    counter: u32,\n}\n\nimpl Ordered for L2ToL1Message {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content, self.counter as Field]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\nimpl L2ToL1Message {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\n        ScopedL2ToL1Message { message: self, contract_address }\n    }\n}\n\nstruct ScopedL2ToL1Message {\n    message: L2ToL1Message,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\n    fn inner(self) -> L2ToL1Message {\n        self.message\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedL2ToL1Message {\n    fn counter(self) -> u32 {\n        self.message.counter\n    }\n}\n\nimpl Eq for ScopedL2ToL1Message {\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\n        (self.message == other.message)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedL2ToL1Message {\n    fn empty() -> Self {\n        ScopedL2ToL1Message {\n            message: L2ToL1Message::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            message: reader.read_struct(L2ToL1Message::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\n#[test]\nfn serialization_of_empty_l2() {\n    let item = L2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = L2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped_l2() {\n    let item = ScopedL2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"229":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"237":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr","source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  num_txs: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.num_txs);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let num_txs = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      num_txs,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      num_txs: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.num_txs == other.num_txs)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n"},"239":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr","source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"241":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n"},"243":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr","source":"use crate::{\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    abis::gas_settings::GasSettings\n};\n\n// docs:start:tx-context\nstruct TxContext {\n    chain_id : Field,\n    version : Field,\n    gas_settings: GasSettings,\n}\n// docs:end:tx-context\n\nimpl TxContext {\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\n        TxContext { chain_id, version, gas_settings }\n    }\n}\n\nimpl Eq for TxContext {\n    fn eq(self, other: Self) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.gas_settings.eq(other.gas_settings))\n    }\n}\n\nimpl Empty for TxContext {\n    fn empty() -> Self {\n        TxContext {\n            chain_id: 0,\n            version: 0,\n            gas_settings: GasSettings::empty(),\n        }\n    }\n}\n\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\n\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.extend_from_array(self.gas_settings.serialize());\n\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let context = Self {\n            chain_id: reader.read(),\n            version: reader.read(),\n            gas_settings: reader.read_struct(GasSettings::deserialize),\n        };\n\n        reader.finish();\n        context\n    }\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context = TxContext::empty();\n    let serialized = context.serialize();\n    let deserialized = TxContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let context = TxContext::empty();\n    let hash = context.hash();\n\n    // Value from tx_context.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"249":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n"},"263":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"273":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"289":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"330":{"path":"/usr/src/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Deserialize, Serialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n"},"343":{"path":"/usr/src/noir-projects/noir-contracts/contracts/delegator_contract/src/main.nr","source":"// A contract used along with `Parent` contract to test nested calls.\ncontract Delegator {\n    use dep::aztec::prelude::{AztecAddress, FunctionSelector, NoteHeader, NoteGetterOptions, PublicMutable, PrivateSet, Deserialize, Map};\n    use dep::value_note::value_note::ValueNote;\n    use dep::delegated_on::DelegatedOn;\n\n    #[aztec(storage)]\n    struct Storage {\n        current_value: PublicMutable<Field>,\n        a_map_with_private_values: Map<AztecAddress, PrivateSet<ValueNote>>,\n    }\n\n    #[aztec(private)]\n    fn private_delegate_set_value(\n        target_contract: AztecAddress,\n        value: Field,\n        owner: AztecAddress\n    ) -> Field {\n        // Call the target private function\n        DelegatedOn::at(target_contract).private_set_value(value, owner).delegate_call(&mut context)\n    }\n\n    #[aztec(private)]\n    fn enqueued_delegate_set_value(target_contract: AztecAddress, value: Field) {\n        DelegatedOn::at(target_contract).public_set_value(value).delegate_enqueue(&mut context)\n    }\n\n    #[aztec(public)]\n    fn public_delegate_set_value(target_contract: AztecAddress, value: Field) -> Field {\n        DelegatedOn::at(target_contract).public_set_value(value).delegate_call(&mut context)\n    }\n\n    #[aztec(private)]\n    fn get_private_value(amount: Field, owner: AztecAddress) -> pub Field {\n        let mut options = NoteGetterOptions::new();\n        options = options.select(ValueNote::properties().value, amount, Option::none()).set_limit(1);\n        let notes = storage.a_map_with_private_values.at(owner).get_notes(options);\n        notes.get_unchecked(0).value\n    }\n\n    unconstrained fn view_public_value() -> pub Field {\n        storage.current_value.read()\n    }\n}\n"},"344":{"path":"/usr/src/noir-projects/noir-contracts/contracts/delegated_on_contract/src/main.nr","source":"// A contract used along with `Parent` contract to test nested calls.\ncontract DelegatedOn {\n    use dep::aztec::prelude::{\n        AztecAddress, FunctionSelector, NoteHeader, NoteGetterOptions, NoteViewerOptions, PublicMutable,\n        PrivateSet, PrivateContext, Map\n    };\n    use dep::aztec::encrypted_logs::encrypted_note_emission::encode_and_encrypt_note;\n    use dep::value_note::value_note::ValueNote;\n\n    #[aztec(storage)]\n    struct Storage {\n        current_value: PublicMutable<Field>,\n        a_map_with_private_values: Map<AztecAddress, PrivateSet<ValueNote>>,\n    }\n\n    #[aztec(private)]\n    fn private_set_value(new_value: Field, owner: AztecAddress) -> Field {\n        let header = context.get_header();\n        let owner_npk_m_hash = header.get_npk_m_hash(&mut context, owner);\n\n        let mut note = ValueNote::new(new_value, owner_npk_m_hash);\n        storage.a_map_with_private_values.at(owner).insert(&mut note).emit(encode_and_encrypt_note(&mut context, context.msg_sender(), owner));\n        new_value\n    }\n\n    #[aztec(public)]\n    fn public_set_value(new_value: Field) -> Field {\n        storage.current_value.write(new_value);\n        new_value\n    }\n\n    #[aztec(private)]\n    fn get_private_value(amount: Field, owner: AztecAddress) -> pub Field {\n        let mut options = NoteGetterOptions::new();\n        options = options.select(ValueNote::properties().value, amount, Option::none()).set_limit(1);\n        let notes = storage.a_map_with_private_values.at(owner).get_notes(options);\n        notes.get_unchecked(0).value\n    }\n\n    unconstrained fn view_public_value() -> pub Field {\n        storage.current_value.read()\n    }\n}\n\n"},"44":{"path":"std/slice.nr","source":"use crate::append::Append;\n\nimpl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::unsafe::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"},"5":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\nstruct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len);\n        self.get_unchecked(index)\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Responds with undefined data for `index` where `self.len < index < self.max_len()`.\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Does not check whether the passed `index` is a valid index within the vector.\n    ///\n    /// Silently writes past the end of the vector for `index` where `self.len < index < self.max_len()`\n    /// Panics if the given index points beyond the maximum length of the vector (`self.max_len()`).\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        \n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen>  {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n    // TODO: Allow imports from \"super\"\n    use crate::collections::bounded_vec::BoundedVec;\n\n    #[test]\n    fn empty_equality() {\n        let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n        let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n        assert_eq(bounded_vec1, bounded_vec2);\n    }\n\n    #[test]\n    fn inequality() {\n        let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n        let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n        bounded_vec1.push(1);\n        bounded_vec2.push(2);\n\n        assert(bounded_vec1 != bounded_vec2);\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n}\n"},"65":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::PrivateContext,\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}},\n    state_vars::{shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter}\n};\n\nglobal DELAY = 5;\n\n// docs:start:key-getters\ntrait KeyGetters {\n  fn get_npk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ivpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ovpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_tpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_npk_m_hash(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Field;\n}\n\nimpl KeyGetters for Header {\n    fn get_npk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, NULLIFIER_INDEX, self)\n    }\n\n    fn get_ivpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, INCOMING_INDEX, self)\n    }\n\n    fn get_ovpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, OUTGOING_INDEX, self)\n    }\n\n    fn get_tpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, TAGGING_INDEX, self)\n    }\n\n    fn get_npk_m_hash(self, context: &mut PrivateContext, address: AztecAddress) -> Field {\n        get_master_key(context, address, NULLIFIER_INDEX, self).hash()\n    }\n}\n// docs:end:key-getters\n\nfn get_master_key(\n    context: &mut PrivateContext,\n    address: AztecAddress,\n    key_index: Field,\n    header: Header\n) -> Point {\n    let key = fetch_key_from_registry(context, key_index, address, header);\n    if is_empty(key) {\n        // Keys were not registered in registry yet --> fetch key from PXE\n        let keys = fetch_and_constrain_keys(address);\n        // Return the corresponding to index\n        keys.get_key_by_index(key_index)\n    } else {\n        // Keys were registered --> return the key\n        key\n    }\n}\n\nfn fetch_key_from_registry(\n    context: &mut PrivateContext,\n    key_index: Field,\n    address: AztecAddress,\n    header: Header\n) -> Point {\n    let x_coordinate_map_slot = key_index * 2 + 1;\n    let y_coordinate_map_slot = x_coordinate_map_slot + 1;\n    let x_coordinate_derived_slot = derive_storage_slot_in_map(x_coordinate_map_slot, address);\n    let y_coordinate_derived_slot = derive_storage_slot_in_map(y_coordinate_map_slot, address);\n\n    let x_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        x_coordinate_derived_slot\n    );\n    let y_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        y_coordinate_derived_slot\n    );\n    let x_coordinate = x_coordinate_registry.get_value_in_private(header);\n    let y_coordinate = y_coordinate_registry.get_value_in_private(header);\n\n    Point::new(x_coordinate, y_coordinate, false)\n}\n\n// Passes only when keys were not rotated - is expected to be called only when keys were not registered yet\nfn fetch_and_constrain_keys(address: AztecAddress) -> PublicKeys {\n    let (public_keys, partial_address) = get_public_keys_and_partial_address(address);\n\n    let computed_address = AztecAddress::compute(public_keys.hash(), partial_address);\n\n    assert(computed_address.eq(address));\n\n    public_keys\n}\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n"},"88":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::storage::{raw_storage_read, storage_read};\n\nstruct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = block_number_oracle();\n        let contract_address = contract_address_oracle();\n        let chain_id = chain_id_oracle();\n        let version = version_oracle();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<N>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n\n#[oracle(getContractAddress)]\nunconstrained fn contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn version_oracle() -> Field {}\n"},"89":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<N>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, N>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<N, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<N, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"95":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn block_number(self) -> Field {\n        block_number()\n    }\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<N>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<N>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, N>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N)\n}\n\nunconstrained fn storage_write<N>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<N>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<N>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}