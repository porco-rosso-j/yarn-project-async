{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"Uniswap","functions":[{"name":"_assert_token_is_same","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"token_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"3d3djh23lQXgd9G1MKj9S9KvMhgMlMQZCDDkIFYGGBh592nHp1sSfOyTtWxWr9KVLbtYRYrcq9Sfzu7+8c1fvv3TP/7nv99/+Ov3P7z55j9/fPPd939+9/H99x+efvXjm+M/zP71X3/427sPP/2HHz6++/vHN98cb998++EvT//859s3f33/3bdvvonV//yvtz8NcHRAoAMSHVDogEYHDHTARAesf3/A219ct6puV64xXq419zvXpo3ni9Nmvly96s7F7TFuF7dXfH7xv6btx++Zth3ht0vtqDx14va7fr+XfZp3PZi3meXz1TaO3573yJdFjrL5y3n7pnn/fPfYevfcevfaevfeevex9e5z693XzrvHsfXutvXuW2s1ttZqbK3V2FqrsbVWY2utxtZaja21mltrNbfWam6t1dxaq7m1VnNrrebWWs2ttZpbazW31mptrdXaWqu1tVZra63W1lqtrbVaW2u1ttZqba3V2lqrvbVWe2ut9tZa7a212ltrtbfWam+t1d5aq721VntrrY6ttTq21urYWqtja62OrbU6ttbq2FqrY2utjq21OrbW6txaq3Nrrc6ttTq31urcWqtza63OrbU6t9bq3Fqrc2utrq21urbW6tpaq2trra6ttbq21uraWqtra62urbW6ttaqHcfe29ve2/ve28fe2+fe29fe2/fe24+9t597b7+3am1v1dreqrW9VWt7q9b2Vq3trVrbW7W2t2ptb9Xa3qr1vVXre6t278eZbO/nmWzvB5rs932iKcOfP3aWEf5y9f2Py8Wct4s7j19+XM5+3+ef/tCP7pnDn8Z0+OOYyKeafh6BfFLpNgL+7G3gH76FP32LfPLnNgL+/G3AH8ANeM8D3vOA9zzhPU94zxPe88Q/cQ3vecJ7nvCeJ7znCe95wnte8J4XvOcF73nBe17wnhe85wXvecF7XvCeF7znDe95w3ve8J43vOcN73njvRXwnje85w3vecN7PuA9H/CeD3jPB7znA97zAe/5wBtq4D0f8J4PeM8nvOcT3vMJ7/mE93zCez7hPZ/wnk+8iwre8wnv+YL3fMF7vuA9X/CeL3jPF7znC97zBe/5wlvn0D3344BHGDzC4REBj0h4RMEjGh4x4BETHgHvucF7DvfGOtwc63B3rMPtsQ73xzrcIOtwh6zDLbJu8J47vOcO77nDe+7wnju85w7vucN7Djucww7nsMM57HAOO5zDDuewwznscA47nMMO57DDOexwDjucww7nsMM57HAOO5zDDuewwznscA47nMMO57DDOexwDjucww7nsMM57HAOO5zDDuewwznscA47nMMO57DDOexwDjucww7nsMM57HAOO5zDDuewwznscA47nMMO57DDOexwDjucww7nsMM57HAOO5zDDuewwznscA47nMMO57DDOexwDjucww7nsMM57HAOO5zDDuewwznscA47nMMO57DDOexwDjtcwA4XsMMF7HABO1zADhewwwXscAE7XMAOF7DDBexwATtcwA4XsMMF7HABO1zADhewwwXscAE7XMAOF7DDBexwATtcwA4XsMMF7HABO1zADhewwwXscAE7XMAOF7DDBexwATtcwA4XsMMF7HABO1zADhewwwXscAE7XMAOF7DDBexwATtcwA4XsMMF7HABO1zADhewwwXscAE7XMAOF7DDBexwATtcwA4XsMMF7HABO1zADhewwwXscAE7XMAOF7DDBexwATtcwA4XsMMF7HABO1zADhewwwXscAE7XMAOF7DDBexwATtcwA4XsMMF7HABO1zADhewwwXscAE7XMAOF7DDBexwATtcwA4XsMMF7HABO1zCDpewwyXscAk7XMIOl7DDJexwCTtcwg6XsMMl7HAJO1zCDpewwyXscAk7XMIOl7DDJexwCTtcwg6XsMMl7HAJO1zCDpewwyXscAk7XMIOl7DDJexwCTtcwg6XsMMl7HAJO1zCDpewwyXscAk7XMIOl7DDJexwCTtcwg6XsMMl7HAJO1zCDpewwyXscAk7XMIOl7DDJexwCTtcwg6XsMMl7HAJO1zCDpewwyXscAk7XMIOl7DDJexwCTtcwg6XsMMl7HAJO1zCDpewwyXscAk7XMIOl7DDJexwCTtcwg6XsMMl7HAJO1zCDpewwyXscAk7XMIOl7DDJexwCTtcwg6XsMMl7HAJO1zCDpewwyXscAk7XMEOV7DDFexwBTtcwQ5XsMMV7HAFO1zBDlewwxXscAU7XMEOV7DDFexwBTtcwQ5XsMMV7HAFO1zBDlewwxXscAU7XMEOV7DDFexwBTtcwQ5XsMMV7HAFO1zBDlewwxXscAU7XMEOV7DDFexwBTtcwQ5XsMMV7HAFO1zBDlewwxXscAU7XMEOV7DDFexwBTtcwQ5XsMMV7HAFO1zBDlewwxXscAU7XMEOV7DDFexwBTtcwQ5XsMMV7HAFO1zBDlewwxXscAU7XMEOV7DDFexwBTtcwQ5XsMMV7HAFO1zBDlewwxXscAU7XMEOV7DDFexwBTtcwQ5XsMMV7HAFO1zBDlewwxXscAU7XMEOV7DDFexwBTtcww7XsMM17HANO1zDDtewwzXscA07XMMO17DDNexwDTtcww7XsMM17HANO1zDDtewwzXscA07XMMO17DDNexwDTtcww7XsMM17HANO1zDDtewwzXscA07XMMO17DDNexwDTtcww7XsMM17HANO1zDDtewwzXscA07XMMO17DDNexwDTtcww7XsMM17HANO1zDDtewwzXscA07XMMO17DDNexwDTtcww7XsMM17HANO1zDDtewwzXscA07XMMO17DDNexwDTtcww7XsMM17HANO1zDDtewwzXscA07XN93uDnLb4PmXPHFuLd3rs54vnpZ3HuKnfIUP+UpccpT8pSn1ClP6VOeMk55yjzlKeuMp6xTan+dUvvrlNpfp9T+OqX21ym1v06p/XVK7a9Tan+dUfvjOE55yh9R+3a8PMXNP7v63o88tbDnn9X69K+f/SzYp+fc5uSCcwrBOaXgnEpwTi04pyE4pyk4p6U3JzsE5ySY4yaY4yaY4yaY4yaY4yaY4yaY4yaY4yaY4y6Y4y6Y4y6Y4y6Y4y6Y4y6Y4y6Y4y6Y4y6Y4y6Y4yGY4/EK+VTxMqfue3NKwTm9Qt1Ne55THnZvTlNwTktvTnkIzskE53T+n5+yX+ZUh38xpztX93q+eHz6G2gfL/OPi88/Lz7/uvj8x8XnP8Xnv15esivvzX9de/51XHz+dvH5q+f/o/mL58/T/W4X+2d/R/vZ/MXz59H8W/z8x3j+/F3Mu/N/hT+/hX+afzyY/xjPX4yOee9rrI6Lzz/3zv/2lDrlKX3KU8YpT5mnPGWd8ZRxnPIUO+UpfspT4pSnnFL745TaH6fU/jil9scptT9Oqf15Su3PU2p/nlL785Tan6fU/jyl9ucptT9Pqf15Su3PU2p/nVL765TaX6fU/jql9tcptb9Oqf3Hn7BfX4y79xSziHr+kurpy6tPs7r/Ja2t55tHxPp08b2v1maMl5mkf3HxbQHj6guYV1/AuvYC5uNuBvUF2NUXEFdfQF19AReP0XlcPEbncfUYtavHqF09Rh83Nagv4OrvgcftEuoLuPqLzC7+Bc20q7+J7epvYrv6m9iv/ib2q7+J/epvYr/6m/hxw8uZC7jNSerlepuT1PvyNiepV+BtTq/wVosaL3Pqe3NaenOKQ3BOJjgnF5xTCM4pBedUgnNqwTkNwTkJ5ngI5ngK5ngK5ngK5ngK5ngK5ngK5ngK5ngK5ngK5ngK5ngJ5ngJ5ngJ5ngJ5ngJ5ngJ5ngJ5ngJ5ngJ5ngJ5ngL5ngL5ngL5ngL5ngL5ngL5ngL5ngL5ngL5ngL5vgQzPEhmONDMMeHYI4PwRwfgjk+BHN8COb4EMzxIZjjUzDHp2COT8Ecn4I5PgVzfArm+BTM8SmY41Mwx6dgji/BHF+COb4Ec3wJ5vgSzPElmONLMMeXYI4vwRxfejm+Dr0cX4dejq9DL8fXoZfj69DL8XXo5fg69HJ8HXo5vg69HF+HYI6bYI6bYI6bYI6bYI6bYI6bYI6bYI6bYI6bYI6bYI67YI67YI67YI67YI67YI67YI67YI67YI4L9nMuwX7OJdjPuQT7OZdgP+cS7Odcgv2cS7Cfcwn2cy7Bfs4l2M+5BPs5l2A/5xLs51yC/ZxLsJ9zCfZzLsF+ziXYz7kE+zmXYD/nEuznXIL9nEuwn3MJ9nMuwX7OJdjPuQT7OZdgP+cS7Odcgv2cS7Cfcwn2cy7Bfs4l2M+5BPs5l2A/5xLs51yC/ZxLsJ9zCfZzLsF+ziXYz7kE+zmXYD/nEuznXIL9nEuwn3O9Rj9n2ssPY87sz+cEXXxbwLj6AubVF7AuvoDtPai3x9g5j/lD3hCf/XR1yzl+ezvMrZ9/i5/+fRy/vSFPl3xaxNPldmdL4mtYRL7GIn59Vvfu3uPl5uNTafg6ntdQX8Ea+itYw/gK1jC/gjWs66/hj+nVfeU1/MrLNOPTGuKLNdzGOTkuyHFJjityXJPjBjlukuMWNc6OX2tQfDzQ2IHODgx2YLIDix3Y7MDBDpzsQPbkGHtyjD05xp4cY0+OsSfH2JNj7Mkx9uQYe3KMPTnOnhxnT46zJ8fZk+PsyXH25Dh7cpw9Oc6eHGdPTrAnJ9iTE+zJCfbkBHtygj05wZ6cYE9OsCcn2JOT7MlJ9uQke3KSPTnJnpxkT06yJyfZk5PsyUn25BR7coo9OcWenGJPTrEnp9iTU+zJKfbkFHtyij05zZ6cZk9Osyen2ZPT7Mlp9uQ0e3KaPTnNnpxmT85gT85gT85gT85gT85gT85gT85gT85gT85gT85gT85kT85kT85kT85kT85kT85kT85kT85kT85kT85kT85iT85iT85iT85iT85iT85iT85iT85iT85iTw5ryMYasrGGbKwhG2vIT18/sAOLHdjswMEOnOxA9uSwhmysIRtryMYasrGGbKwhG2vIxhqysYZsrCEba8jGGrKxhmysIRtryMYasrGGbKwhG2vIxhqysYZsrCEba8jGGrKxhmysIRtryMYasrGGbKwhG2vIxhqysYZsrCEba8jGGrKxhmysIRtryMYasrGGbKwhG2vIxhqysYZsrCEba8jGGrKxhmysIRtryMYasrGGbKwhG2vIxhqysYZsrCEba8jGGrKxhmysIRtryMYasrGGbKwhG2vIxhqysYZsrCEba8jGGrKxhmysIRtryMYasrGGbKwhG2vIxhqysYZsrCEba8jGGrKxhmysIRtryMYasrGGbKwhO2vIzhqys4bsrCE7a8jOGrKzhuysITtryM4asrOG7KwhO2vIzhqys4bsrCE7a8jOGrKzhuysITtryM4asrOG7KwhO2vIzhqys4bsrCE7a8jOGrKzhuysITtryM4asrOG7KwhO2vIzhqys4bsrCE7a8jOGrKzhuysITtryM4asrOG7KwhO2vIzhqys4bsrCE7a8jOGrKzhuysITtryM4asrOG7KwhO2vIzhqys4bsrCE7a8jOGrKzhuysITtryM4asrOG7KwhO2vIzhqys4bsrCE7a8jOGrKzhuysITtryM4asrOG7KwhO2vIzhqys4bsrCE7a8jOGrKzhuysITtryM4asrOG7Kwh++MfIj7XlwN/+W1Eph0vj/EvvqXJ3W868tl3NKnj09V29zuaPN3vdrF/toCnVH9ZwLz6Ata1FxCPf5b5Ky9gPn+Tm6eKvrsAu/oC/OoLiKsvIK++gLrOAvruAvrqC1B/Ez9cgPqb+OEC1N/EjxZgF3oT31/Ahd7E9xcg/iYOX7eLI+3uAsTfxI8XIP4mfrwA8Tfx4wWIv4kfL0D8Tfx4AeJv4s8WUMfdBYi/iR8uwMXfxOHzeQF9fwHib+KnlHmwAPU38cMFqL+JHy5A/U08Xn5ewbwLW67+Inu4APUX2cMFqL/IHi5A/UX2aAGh/iJ7uAD1F9nDBZwfo1HPV1t0f7GA50mV4qRacVJDcVJTcVKvkJVHPk8qze5NKg/FSZnipFxxUqE4qVScVClOqhUnNRQnNRUnpZjopZjopZjopZjopZjopZjopZjopZjopZjopZjopZjorZjorZjorZjorZjorZjorZjorZjorZjorZjorZjoQzHRh2KiD8VEH4qJPhQTfSgm+lBM9KGY6EMx0Ydiok/FRJ+KiT4VE30qJvpUTPSpmOhTMdGnYqJPxUSfiom+FBN9KSb6Ukz0pZjoSzHRl2KiL8VEX4qJvhQTfQkmeh6CiZ6HYKLnIZjoeQgm+tMFipMSTPQ8BBM9D8FEz0Mw0fNQTHRTTHRTTHRTTHRTTHRTTHRTTHRTTHRTTHRTTHRTTHRXTHRXTHRXTHRXTHRXTHRXTHRXTHRXTHRXTHRXTPRQTPRQTPRQTPRQTPRQTPRQTPRQTPRQTPRQTHTFntFU7BlNxZ7RVOwZTcWe0VTsGU3FntFU7BlNxZ7RVOwZTcWe0VTsGU3FntFU7BlNxZ7RVOwZTcWe0VTsGU3FntFU7BlNxZ7RVOwZTcWe0VTsGU3FntFU7BlNxZ7RVOwZTcWe0VTsGU3FntFU7BlNxZ7RVOwZTcWe0VTsGU3FntFU7BlNxZ7RVOwZTcWe0VTsGU3FntFU7BlNxZ7RVOwZTcWe0VTsGU3FntFU7BlNxZ7RVOwZTcWe0VTsGU3FntFU7BlNxZ7RVOwZTcWe0VTsGU3FntFS7BktxZ7RUuwZLcWe0ToEE70Ue0ZLsWe0XqFnNObLT1zJ4/6kpuKkluCkXqFn9N+YlClOyhUnFYqTSsVJleKkWnFSioluioluionuionuionuionuionuionuionuionuionuionuiokeiokeiokeiokeiokeiokeiokeiokeiokeiokeiomeiomeiomeiomeiomeiomeWon+9Kv/fff39+/+9N23PzyN+el//uPDnz++//7D7Zcf/+9vP/+fp2v/Hw=="},{"name":"swap_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"input_asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"input_asset_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"input_amount","type":{"kind":"field"},"visibility":"private"},{"name":"output_asset_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce_for_unshield_approval","type":{"kind":"field"},"visibility":"private"},{"name":"uniswap_fee_tier","type":{"kind":"field"},"visibility":"private"},{"name":"minimum_output_amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"},"visibility":"private"},{"name":"secret_hash_for_L1_to_l2_message","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_L1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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0mdtXvqszUuftfvSZ+2+9Fm7L33W7kuftR5jnyaufumzdl/6rN2XPmv3pc/afemz1pY+a23ps9aWPms95j/tyR6rz1v/ztXb0qs/ll59WXr1denVt6VX31devcsYqHmrT0uvPi+9+qXPWpdRUPNWv/RZeyx91h5Ln7XH0mftsfRZW5Y+a8vSZ21Z+qwtS5+1LkOh5q1+6bO2LH3WlqXP2rL0WVuWPmvr0mdtXfqsrUuftXXps9ZlPNS81S991talz9q69Flblz5r69JnbVv6rG1Ln7Vt6bO2LX3WugyKmrf6pc/atvRZ25Y+a9vSZ21b+qztS5+1femz1mVgVLb8WH391tXvS6/ell79sfTqy9Krr0uvvi29+r7w6pPL3Kh5q09Lr37lszZtK5+1aVv5rE3bymdt2lY+a9O28lmbtpXP2rQtfdampc/atPRZm5Y+a9PSZ63L3Kh5q1/6rE1Ln7Vp6bM2LX3WpqXP2rz0WZuXPmvz0mdtXvqsdZkbNW/1S5+1eemzNi991ualz9q89Fm7L33W7kuftfvSZ+2+9FnrMjdq3uqXPmv3pc/afemzdl/6rN2XPmtt6bPWZW7Uvt9/x7737TtXn5de/b706m3p1R9Lr74svfq69Orb0qvvK6/eZW7UvNUvfdYeS5+1x9JnrcvcqHmrX/qsPZY+a4+lz9pj6bP2WPqsLUuftWXps7YsfdaWpc9al7lR81a/9Flblj5ry9JnbVn6rC1Ln7V16bO2Ln3W1qXP2rr0WesyN2re6pc+a+vSZ21d+qytS5+1demzti191ralz9q29Fnblj5rXeZGzVv90mdtW/qsbUuftW3ps7Ytfda6zI0yuy9ot/ad341ymRs1b/V56dXvS6/ell79sfTqy9Krr0uvvi29+r7w6vO28lmbt5XP2rytfNbmbeWzNm8rn7V5W/mszdvKZ23eVj5r87byWZu3pc/atPRZm5Y+a9PSZ21a+qx1mRs1b/VLn7Vp6bM2LX3WpqXP2rT0WZuXPmvz0mdtXvqszUuftS5zo+atfumzNi991ualz9q89Fmblz5r96XP2n3ps3Zf+qzdlz5rXeZGzVv90mftvvRZuy991u5Ln7Uuc6OOvN1XfxzfuXqXuVHzVp+WXn1eevX70qu3pVd/LL36svTq69Krb0uvfumz9lj6rD2WPmuPpc/aY+mz1mVu1LzV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XK4KfHCye7lcrgp8dLJ7uVyuCnx4snu5XK4KfNSye7lcrgp8LLN7uVyuCnwos3u5XK4KfCSze7lUriqBz2N2L5fKVSXwWczu5VK5qlsxXOVSuaoEPoPZvVwqV5XA5y+7l8vlqsBnL7uXy+WqwOcuu5fL5arAZy67l8vlqsDnLbuXy+WqwGctu5fL5arA5yy7l8vlqsBnLLuXy+WqwOcru5fL5arAZyu7l8vlqsDnKruXy+WqwGcqu5fL5arA5ym7l8vlqsBnKbuXy+Wqdi5XtXO5KvAp2e7lcrkq43JVxuWqwGegu5fL5arAZ6C7l8vlqsBnoLuXy+WqwGegu5fL5arAZ6C7l8vlqsBnoLuXy+WqwGegu5fL5aq4ZqsnrtnqiWu2euKarZ64ZqsnrtnqiWu2euKarZ64ZqsnrtnqiWu2euKarZ64ZqsnrtnqiWu2euKarZ64ZqsnrtnqiWu2euKarZ64ZqsnrtnqiWu2euKarZ64ZqsnrtnqiWu2euKarZ64ZqsnrtnqiWu2euKarZ64ZqsnrtnqiWu2euKarZ64ZqsnrtnqiWu2euKarZ64ZqsnrtnqiWu2euKarZ65ZqtnrtnqmWu2euaarZ434yqXylVlrtnqmWu2euaarZ65ZqtnrtnqmWu2euaarZ65ZqtnrtnqmWu2euaarZ65ZqtnrtnqmWu2euaarZ65ZqtnrtnqmWu2euaarZ65ZqtnrtnqmWu2euaarZ65ZqtnrtnqmWu2euaarZ65ZqtnrtnqmWu2euaarZ65ZqtnrtnqmWu2euaarZ65ZqtnrtnqmWu2euaarZ65ZqtnrtnqmWu2euaarZ65ZqtnrtnqmWu2euaarZ65ZqtnrtnqmWu2euaarZ65ZqtnrtnqmWu2euaarZ65ZqtnrtnqmWu2euaarZ65ZqtnrtnqmWu2euaarZ65ZqtnrtnqmWu2euaarZ65ZqtnrtnqmWu2euaarZ65ZqtnrtnqmWu2euaarZ65ZqtnrtnqmWu2euaarZ65ZqtnrtnqmWu2euaarZ65ZqtnrtnqmWu2euaarZ65ZqtnrtnqmWu2euaarZ65ZqtnrtnqmWu2+s41W33nmq2+c81W37lmq++bcZVL5ap2rtnqO9ds9Z1rtvrONVt955qtvnPNVt+5ZqvvXLPVd67Z6jvXbPWda7b6zjVbfeearb5Hmr7da74/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2kRaU66Xq8q0dbOmXC9XlWnDZE25Xq4q0zbFmnK9XFWmzYE15Xq5qkxb8mrK9XJVmTbC1ZTr5aoybT+rKdfLVWXa9FVTrperyrTVqqZcL1eVaYNTTblerirTtqKacr1cVabNPDXlermqTFtoasr1clWZNq7UlOvlqjJtF6kp18tVZdqkUVOul6vKtDWiplwvV5VpQ0JNuV6uKtM2gJpyvVxVpqn6NeV6uapMk+9ryvVyVZmm09eU6+WqMk2QrynXy1VlmvJeU66Xq8o0ib2mXC9X5TVbffWarb56zVZfvWarr16z1Vev2eqr12z11Wu2+uo1W331mq2+es1WX71mq69es9VXr9nqq9ds9dVrtvrqNVt99ZqtvnnNVt+8ZqtvXrPVN6/Z6tuteJVr5ao2r9nqm9ds9c1rtvrmNVt985qtvnnNVt+8ZqtvXrPVN6/Z6pvXbPXNa7b65jVbffOarb55zVbfvGarb16z1Tev2eqb12z1zWu2+uY1W33zmq2+ec1W37xmq29es9U3r9nqm9ds9c1rtvrmNVt985qtvnnNVt+8ZqtvXrPVN6/Z6pvXbPXNa7b65jVbffOarb55zVbfvGarb16z1Tev2eqb12z1zWu2+uY1W33zmq2+ec1W37xmq29es9U3r9nqm9ds9c1rtvrmNVt985qtvnnNVt+8ZqtvXrPVN6/Z6pvXbPXNa7b65jVbffOarb55zVbfvGarb16z1Tev2eqb12z1zWu2+uY1W33zmq2+ec1W37xmq29es9U3r9nqm9ds9c1rtvrmNVt985qtvnnNVt+8ZqtvXrPVN6/Z6pvXbPXNa7b65jVbffOarb55zVbfvGarb16z1Tev2eqb12z1zWu2+uY1W33zmq2+ec1W371mq+9es9V3r9nqu9ds9f1WvMq1clW712z13Wu2+u41W333mq2+e81W371mq+9es9V3r9nqu9ds9d1rtvruNVt995qtvnvNVt+9ZqvvXrPVd6/Z6rvXbPXda7b67jVbffearb57zVbfvWar716z1Xev2eq712z13Wu2+u41W333mq2+e81W371mq+9es9V3r9nqu9ds9d1rtvruNVt995qtvnvNVt+9ZqvvXrPVd6/Z6rvXbPXda7b67jVbffearb57zVbfvWar716z1Xev2eq712z13Wu2+u41W333mq2+e81W371mq+9e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"},{"name":"swap_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"input_asset_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"input_amount","type":{"kind":"field"},"visibility":"private"},{"name":"output_asset_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce_for_transfer_approval","type":{"kind":"field"},"visibility":"private"},{"name":"uniswap_fee_tier","type":{"kind":"field"},"visibility":"private"},{"name":"minimum_output_amount","type":{"kind":"field"},"visibility":"private"},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"secret_hash_for_L1_to_l2_message","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_L1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"nonce_for_swap_approval","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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6n1r9bG1+txafW2tvjdW32NsrV62Vj+3Vr+z1/bY2Wt77Oy1PXb22h47e22Pnb22x9ZeK1t7rWzttbK118rWXitbe61s7bWytdfK1l4rW3utbO21c2uvnVt77dzaa+fWXju39tq5tdfOrb12bu21c2uvnVt7rW7ttbq11+rWXqtbe62+1GvvRRxR5AnO1TbvRdKw/w65tfraWn3vrN7G1upla/Vza/W6tXrbWr1vrX5rr7Wtvda29lrb2mt9a6/1rb3Wt/Za39prn3Gm0RvVb+21vrXX+tZe61t7rW/ttbG118bWXhtbe21s7bXPONPojeq39trY2mtja6+Nrb02tvba3Nprc2uvza29Nrf22mecafRG9Vt7bW7ttflSr70XKUSRJzjX7ROdjw83Ffov8Ywzgt6qXzbXPzfXr5vrt831++b6Y3P9ubn+2lz/5v7bm/tvb+6/vbn/9ub++4wTj96qf3P/7c39tzf3397cf3tr/9Uxtvbfm/6t/femf2v/venf2n9v+rf235v+rf33pn9r/73p39p/b/q39t+b/s39Vzb3X9ncf2Vz/5XN/fcZJyO9Vf/m/iub+69s7r+yuf/K5v47X+y/9zKCKfMMN5Px+MxuHxr2X0M312+b6/fN9cfm+nNz/bW5/t5b/zPOIXqrftlc/+b+q5v77zPOI3qr/s39Vzf3X93cf3Vz/9XN/dc291/b3H9tc/+1zf33GacqvVX/5v5rm/uvbe6/trn/2ub+65v7r2/uv765//rm/vuMk5beqn9z//XN/dc391/f3H99c/+Nzf03Nvff2Nx/48X+ey9jmDJPcbPMe5kpjf3XiM315+b6a3P9vbf+HJvrl831z8316+b6bXP9m/tvbu6/ubn/5ub+m5v7b23uv7W5/9bm/lub++9TzmZ6p/7N/bc299/a3H9rc/+tzf23N/ff3tx/e3P/7c399ylnM71T/+b+25v7b2/uv725//be/itjb/+Vsbf/ytjbf2Xs7b8y9vZfGXv7r4wX+++9TGLKPMPNZo57GZXC/mv03vqfctLRO/XL5vrn5vp1c/22uX7fXH9srj8317+5/8rm/js399+5uf/Ozf13bu6/Tzmb6Z36N/ffubn/zs39d27uv3Nz/9XN/Vc391/d3H91c/99ytlM79S/uf/q5v6rm/uvbu6/urn/2ub+a5v7r23uv7a5/z7lbKZ36t/cf21z/7XN/dc29197sf/+KOMDU+YZbqbWjzKF/dd4yklH79Svm+u3zfX75vpjc/25uf7aXH/vrf8pJx29U//m/hub+29s7r9POULpnfo399/Y3H9jc/+Nzf03Nvff3Nx/c3P/zc39Nzf336eczfRO/Zv7b27uv7m5/+bm/pub+29t7r+1uf/W5v5bm/vvU85meqf+zf23Nvff2tx/a3P/rc39tzf3397cf/vF/nsvo5gyz3Az70eZkHlYxjFlAlMmMWUKU6YRZeZTzrT5QhnBlJmYMoopY5gyjikTmDKJKVOYMhgKCIYCgqGAYCggGAoIhgKCoYBgKCAYCgiGAoKhwMRQYGIoMDEUmBgKTAwFJoYCE0OBiaHAxFBgYiigGAoohgKKoYBiKKAYCiiGAoqhgGIooBgKKIYChqGAYShgGAoYhgKGoYBhKGAYChiGAoahgGEo4BgKOIYCjqGAYyjgGAo4hgKOoYBjKOAYCjiGAoGhQGAoEBgKBIYCgaFAYCgQGAoEhgKBoUBgKJAYCiSGAomhQGIokBgKJIYCiaFAYiiQGAokhgKFoUBhKFAYChSGAoWhQGEoUBgKFIYChaFAYSjQGAo0hgKNoUBjKIDJDk5MdnBisoMTkx2cmOzgxGQHFZMdVEx2UDHZQcVkB3UYpoxjygSmTGLKFKYMhgKY7KBisoOKyQ4qJjuomOygYrKDiskOKiY7qJjsoGKyg4rJDiomO6iY7KBisoOKyQ4qJjuomOygYrKDiskOKiY7qJjsoGKyg4rJDiomO6iY7KBisoOKyQ4qJjuomOygYrKDiskOKiY7qJjsoGKyg4rJDiomO6iY7KBisoOKyQ4qJjuomOygYrKDiskOKiY7qJjsoGKyg4rJDiomO6iY7KBisoOKyQ4qJjuomOygYrKDiskOKiY7qJjsoGKyg4rJDiomO6iY7KBisoOKyQ4qJjuomOygYrKDiskOKiY7qJjsoGKyg4rJDiomO6iY7KBisoOKyQ4qJjuomOygYrKDiskOKiY7qJjsoGKyg4rJDiomO6iY7KBisoOKyQ4qJjuomOygYrKDhskOGiY7aJjsoGGygzYMU8YxZQJTJjFlClMGQwFMdtAw2UHDZAcNkx00THbQMNlBw2QHDZMdNEx20DDZQcNkBw2THTRMdtAw2UHDZAcNkx00THbQMNlBw2QHDZMdNEx20DDZQcNkBw2THTRMdtAw2UHDZAcNkx00THbQMNlBw2QHDZMdNEx20DDZQcNkBw2THTRMdtAw2UHDZAcNkx00THbQMNlBw2QHDZMdNEx20DDZQcNkBw2THTRMdtAw2UHDZAcNkx00THbQMNlBw2QHDZMdNEx20DDZQcNkBw2THTRMdtAw2UHDZAcNkx00THbQMNlBw2QHDZMdNEx20DDZQcNkBw2THTRMdtAw2UHDZAcNkx00THbQMNlBw2QHDZMdNEx20DDZQcNkBw2THTRMdtAw2UHDZAcNkx00THbQMNlBx2QHHZMddEx20DHZQR+GKeOYMoEpk5gyhSmDoQAmO+iY7KBjsoOOyQ46JjvomOygY7KDjskOOiY76JjsoGOyg47JDjomO+iY7KBjsoOOyQ46JjvomOygY7KDjskOOiY76JjsoGOyg47JDjomO+iY7KBjsoOOyQ46JjvomOygY7KDjskOOiY76JjsoGOyg47JDjomO+iY7KBjsoOOyQ46JjvomOygY7KDjskOOiY76JjsoGOyg47JDjomO+iY7KBjsoOOyQ46JjvomOygY7KDjskOOiY76JjsoGOyg47JDjomO+iY7KBjsoOOyQ46JjvomOygY7KDjskOOiY76JjsoGOyg47JDjomO+iY7KBjsoOOyQ46JjvomOygY7KDjskOOiY76JjsoGOyg47JDjomO+iY7KBjsoOOyQ46JjvomOxgYLKDgckOBiY7GJjsYAzDlHFMmcCUSUyZwpTBUACTHQxMdjAw2cHAZAcDkx0MTHYwMNnBwGQHA5MdDEx2MDDZwcBkBwOTHQxMdjAw2cHAZAcDkx0MTHYwMNnBwGQHA5MdDEx2MDDZwcBkBwOTHQxMdjAw2cHAZAcDkx0MTHYwMNnBwGQHA5MdDEx2MDDZwcBkBwOTHQxMdjAw2cHAZAcDkx0MTHYwMNnBwGQHA5MdDEx2MDDZwcBkBwOTHQxMdjAw2cHAZAcDkx0MTHYwMNnBwGQHA5MdDEx2MDDZwcBkBwOTHQxMdjAw2cHAZAcDkx0MTHYwMNnBwGQHA5MdDEx2MDDZwcBkBwOTHQxMdjAw2cHAZAcDkx0MTHYwMNnBwGQHA5MdDEx2MDDZwcBkBwOTHQxMdjAw2cHAZAcDkx0MTHYwMdnBxGQHE5MdTEx2MIdhyjimTGDKJKZMYcpgKIDJDiYmO5iY7GBisoOJyQ4mJjuYmOxgYrKDickOJiY7mJjsYGKyg4nJDiYmO5iY7GBisoOJyQ4mJjuYmOxgYrKDickOJiY7mJjsYGKyg4nJDiYmO5iY7GBisoOJyQ4mJjuYmOxgYrKDickOJiY7mJjsYGKyg4nJDiYmO5iY7GBisoOJyQ4mJjuYmOxgYrKDickOJiY7mJjsYGKyg4nJDiYmO5iY7GBisoOJyQ4mJjuYmOxgYrKDickOJiY7mJjsYGKyg4nJDiYmO5iY7GBisoOJyQ4mJjuYmOxgYrKDickOJiY7mJjsYGKyg4nJDiYmO5iY7GBisoOJyQ4mJjuYmOxgYrKDickOJiY7mJjsYGKyg4nJDiYmO5iY7GBisoOJyQ4mJjtYmOxgYbKDhckOFiY7WMMwZRxTJjBlElOmMGUwFMBkBwuTHSxMdrAw2cHCZAcLkx0sTHawMNnBwmQHC5MdLEx2sDDZwcJkBwuTHSxMdrAw2cHCZAcLkx0sTHawMNnBwmQHC5MdLEx2sDDZwcJkBwuTHSxMdrAw2cHCZAcLkx0sTHawMNnBwmQHC5MdLEx2sDDZwcJkBwuTHSxMdrAw2cHCZAcLkx0sTHawMNnBwmQHC5MdLEx2sDDZwcJkBwuTHSxMdrAw2cHCZAcLkx0sTHawMNnBwmQHC5MdLEx2sDDZwcJkBwuTHSxMdrAw2cHCZAcLkx0sTHawMNnBwmQHC5MdLEx2sDDZwcJkBwuTHSxMdrAw2cHCZAcLkx0sTHawMNnBwmQHC5MdLEx2sDDZwcJkBwuTHSxMdrAw2cHCZAcLkx1sTHawMdnBxmQHG5Md7GGYMo4pE5gyiSlTmDIYCmCyg43JDjYmO9iY7GBjsoONyQ42JjvYmOxgY7KDjckONiY72JjsYGOyg43JDjYmO9iY7GBjsoONyQ42JjvYmOxgY7KDjckONiY72JjsYGOyg43JDjYmO9iY7GBjsoONyQ42JjvYmOxgY7KDjckONiY72JjsYGOyg43JDjYmO9iY7GBjsoONyQ42JjvYmOxgY7KDjckONiY72JjsYGOyg43JDjYmO9iY7GBjsoONyQ42JjvYmOxgY7KDjckONiY72JjsYGOyg43JDjYmO9iY7GBjsoONyQ42JjvYmOxgY7KDjckONiY72JjsYGOyg43JDjYmO9iY7GBjsoONyQ42JjvYmOxgY7KDjckONiY72JjsYGOyg43JDjYmO9iY7GBjsoMNyQ7agGQHb2UEU2ZiyiimjGHKOKZMYMokpkxhymAoIBgKCIYCgqGAYCggGAoIhgKCoYBgKCAYCgiGAhNDgYmhwMRQYGIoMDEUmBgKTAwFJoYCE0OBiaGAYiigGAoohgKKoYBiKKAYCiiGAoqhgGIooBgKGIYChqGAYShgGAoYhgKGoYBhKGAYChiGAoahgGMo4BgKOIYCjqGAYyjgGAo4hgKOoYBjKOAYCgSGAoGhQGAoEBgKBIYCgaFAYCgQGAoEhgKBoUBiKJAYCiSGAomhQGIokBgKJIYCiaFAYiiQGAoUhgKFoUBhKFAYChSGAoWhQGEoUBgKFIYChaFAYyjQGAo0hgKNoUBjKNAYCjSGAo2hQGMogMkOCiY7KJjsoGCyg4LJDsowTBnHlAlMmcSUKUwZDAUw2UHBZAcFkx0UTHZQMNlBwWQHBZMdFEx2UDDZQcFkBwWTHRRMdlAw2UHBZAcFkx0UTHZQMNlBwWQHBZMdFEx2UDDZQcFkBwWTHRRMdlAw2UHBZAcFkx0UTHZQMNlBwWQHBZMdFEx2UDDZQcFkBwWTHRRMdlAw2UHBZAcFkx0UTHZQMNlBwWQHBZMdFEx2UDDZQcFkBwWTHRRMdlAw2UHBZAcFkx0UTHZQMNlBwWQHBZMdFEx2UDDZQcFkBwWTHRRMdlAw2UHBZAcFkx0UTHZQMNlBwWQHBZMdFEx2UDDZQcFkBwWTHRRMdlAw2UHBZAcFkx0UTHZQMNlBwWQHBZMdFEx2UDDZQcFkBwWTHRRMdlAw2UHBZAcFkx0UTHZQMNlBwWQHJyY7ODHZwYnJDk5MdnAOw5RxTJnAlElMmcKUwVAAkx2cmOzgxGQHJyY7ODHZwYnJDk5MdnBisoMTkx2cmOzgxGQHJyY7ODHZwYnJDk5MdnBisoMTkx2cmOzgxGQHJyY7ODHZwYnJDk5MdnBisoMTkx2cmOzgxGQHJyY7ODHZwYnJDk5MdnBisoMTkx2cmOzgxGQHJyY7ODHZwYnJDk5MdnA+JW0XWo8yNg7LTEyZJ6y02zZW/rj6tgcUh2UCUyYxZQpTpiFlnpFPu+3IzHuZ2z30U5nfX906flzcLo9rb8b3kCR8kiafJOWTZHySnE9S8ElKPkkFl5QP8x/SP2n6/cUfTwoxPqx1pj709976c2yuXzbXr5vrN2r9MeWuX+VQv2+uPzbXn5vr5+b/qf7i5n/4Q38c6+fm/7n+ubl+bv8610/On7o/P0fNQ/3cz8+n+pv7/q24X9wjDvVz37/tdx0ddqif+/4912+b6+d+/jzXz/38ea6fm//n+rn5f66f+/n5k/6b5t/r18H9/Hyun9t/2+dDfx3qJ/dfixP95P57qp/cf0/1k/vvqX5y/+3796/uPtRP7r/lJ/qP/TceRTTFT/RL6v1fWbI+tlnF+mhLVtV+XO0aH6Lajy6Wvn+QPuXk4vJx/zNyuenni390+4s5hqt2K9+q2/mtutVv1a19q24d3630o9scf7uBrPs7Z3/ImNUP/bG5/txcf22uv/fWP8fm+mVz/ZNbf+hDf/yk/+D5XR/7959M6Pja9Hq876e9qsej/tQ/P5ajj4Xcbd/1sZCb4Ls+FnJvetPHouSW966PhdxJ3/Wx/GnQhx/LnwZ9+LHYnx/L0cfy53PL4cfyi80Hj8fHouPkY5lz3IvMaX7SaGs+FJX8r9/v5+jeGSdV7r9xZ97/xnH7Znik37j/xn2un/tv3Of6uf/Gfa6f+2/c5/qNW388+Fl5qJ/7b9zn+rn/xn2un/tv3Of6uf33XD+5/57pd3L//dDfh/x0cv891U/uv3F/NK8hh/rJ/TfGiX52/z3Tz+6/Z/q5/bfk/vxW8/D7l3P717l+bv861R/c/nWun3xG6ZFRrD68f4Pbv871c/vXuX5u/zrXz+1f5/rJ/SsfebY+5g/398dz/eT+e6qf3H/P9JOf8XKun9x/T/WT++9Dfx8//5OfUVP5mJE5nNFW8jNqzmbMlfyMmnP95P57qp/cf0/1k/vvqX5y/z3TT37Gzrn+Zxy7fHpKrT7lpxm/UMYxZQJTJjFlnnHscsR8lIk8LNOQMk/5acYvlBFMmYkp8xQKpDzKdB2WMUwZx5QJTJnElClMmUaUsaf8NOMXygimzMSUeQoF/KNMHJcxTBnHlAlMmcSUKUyZhpR5yk8zfqGMYMpMTBkMBQRDAcFQQDAUEAwFBEMBwVBgYigwMRSYGApMDAUmhgITQ4GJocDEUGBiKDAxFFAMBRRDgaf8NGM+RpYkpx+WUUwZw5RxTJnAlHkGBXJ+lLE8LFOYMg0p85SfZvxCGcGUmZgyiiljmDKOKfMUCjxmLW8V47BMYsoUpkxDyvjAlBFMmYkpo5gyhinjmDIYCjiGAo6hgGMoEBgKBIYCgaFAYCgQGAoEhgKBoUBgKBAYCgSGAomhQGIokBgKJIYCiaFAPoUC8VEm7bBMYMokpkxhyjSkTD2FAvkoU0MPywimzMSUUUwZw5RxTJnAlElMmcKUeQoFPD8ocLil+pTs4BfKCKbMxJRRTBnDlHFMmcCUSUyZwpSBUMDHwJQRTJmJKaOYMoYp45gygSmTmDKFKYOhgGAoIBgKCIYCgqGAYCggGAoIhgKCocBTsoM17fGN4NNv238u05AyT8kOfqGMYMpMTJlnUKDUH2VCD8sYpoxjygSmTGLKFKZMQ8o8JTv4hTKCKfMUCoh+UGAellFMGcOUcUyZwJRJTJnClGlImadkB79QRjBlMBQwDAUMQwHDUMAwFDAMBQxDAcNQwDEUcAwFHEMBx1DAMRRwDAUcQwHHUMAxFHAMBQJDgadkB6s+vrD34Rf2p2QHv1BGMWUMU8YxZZ5CgX58KWypwzKJKVOYMg0p85Ts4BfKCKbMxJRRTBnDlHkKBfLDCPrQCJ6SHfxCmcSUKUyZhpR5SnbwC2UEU2ZiyiimjGHKYChQGAoUhgKFoUBhKNAYCjSGAo2hQGMo0BgKNIYCjaFAYyjQGAo0hAIxBqaMYMpMTBnFlHkGBT5+jln6p6s/yjimTGDKJKZMYco8gwLt41HmcJoonpId/EIZwZSZmDKKKWOYMo4pE5gyiSnzFArM+qBAHpZpSJmnZAe/UEYwZSamjGLKGKaMY8oEpkxiymAoMDEUUAwFFEMBxVBAMRRQDAUUQwHFUEAxFFAMBRRDAcNQwDAUMAwFDEMBw1DAMBQwDAWekh3sx59X5xiHezZPyQ5+oUxDyjwlO/iFMoIp84yfvhwjHmWOV9ozsoNfKWOYMo4pE5gyiSlTmDINKfOM7OBXyjyFAo982q2iHpaZmDKKKWOYMo4pE5gyiSlTmDINKfOU7OAXymAokBgKJIYCiaFAYiiQGAokhgKJoUBiKFAYChSGAoWhQGEoUBgKFIYChaFAYShQGAoUhgL9lG8Ej0NO5zg8miWekR38SpmJKaOYMoYp85R9gcdPw08Z47BMYMokpkxhyjSiTI6BKSOYMhNTRjFlnkKBx+FZt4pxWMYxZQJTJjFlClOmIWVkYMoIpszElFFMGQwFBEMBwVBAMBQQDAUEQ4GJocDEUGBiKDAxFJgYCkwMBSaGAhNDgYmhwMRQQDEUUAwFFEMBxVBAMRRQDAUUQwHFUEAxFFAMBQxDAcNQwDAUOE7bzar7L6vPNj8rM+M+sTI1+tPVfrTPa/H41Xb/lJiS1qP3lvnYcvjYE56pjwZi9wZy9waKvIF63ASfBl4/N9CbN3Ccl9ypAdm9gbl7A7pPA3HYgO3eALsTnzbA7sSnDbA78WkDGznxcQMbOfFhA0HuxDrvf8FTk8MGyJ34vAFyJz5vgNyJzxsgd+LzBsid+LwBcif+1ICPwwbInfi8AXIn1sfgosZxA+ROrBJ/u4Fkd+LTBtid+LQBdifO+1trHW5sJbuRnTbAbmSnDbAb2WkD7EZ22gC7kZ02wG5kZw0UHqPq9z8yiUb81MBdlDKKMkZRzigqGEW9gZXj8bMiJnIoqhhFNaGoHoyihFHUZBSljKKMUZQzigpGUYxEb0aiNyHRaxASvQYh0WsQEr0GIdFrEBK9BiHRaxASvQYh0WsQEr0GI9GFkejCSHRhJLowEl0YiS6MRBdGogsj0YWR6MJI9MlI9MlI9MlI9MlI9MlI9MlI9MlI9MlI9MlI9MlIdGUkujISXRmJroxEV0aiKyPRlZHoykh0ZSS6MhLdGIlujEQ3RqIbI9GNkejGSHRjJLoxEt0YiW6MRHdGojsj0Z2R6M5IdGckujMS3RmJ7oxEd0aiOyPRg5HowUj0YCR6MBI9GIkejEQPRqIHI9GDkejBSPRkJHoyEj0ZiZ6MRE9Goicj0ZOR6MlI9GQkejISvRiJXoxEL0aiFyPRi5HoxUj0YiQ648xoMc6MFuPMaDHOjBbjzGgxzowW48xoMc6MFuPMaDHOjBbjzGgxzowW48xoM86MNuPMaDPOjDbjzGgPQqI348xoM86MNuPMaDPOjDbjzGgzzow248xoM86MNuPMaDPOjDbjzGgzzow248xoM86MNuPMaDPOjDbjzGgzzow248xoM86MNuPMaDPOjDbjzGgzzow248xoM86MNuPMaDPOjDbjzGgzzow248xoM86MNuPMaDPOjDbjzGgzzow248xoM86MNuPMaDPOjDbjzGgzzow248xoM86MNuPMaDPOjDbjzGgzzow248xoM86MNuPMaDPOjPYbZkb18d43fceiilFUE4p6w8zoF0QJo6jJKEoZRRmjKGcUFYyiGIkejEQPRqInI9GTkejJSPRkJHoyEj0ZiZ6MRE9Goicj0ZOR6MVI9GIkejESvRiJXoxEL0aiFyPRi5HoxUj0YiR6MxK9GYnejERvRqI3I9Gbkei/mIRMq3uZ+rTX/Zx99D/yc+pT5v2t5ejn1PsXU5O7NODjFxOWGzUg5A1UPm6wedjA3L0B3b0B270B372B2KeBOGwgd2+A3YlPG2B34rMGhN2JTxvYyImPG9jIiY8bIHdinf3jYjU5bIDcic8bIHfi8wbInfi8AXInPm+A3InPGyB34k8N+DhqYJI78XkD5E6s8y5E47gBcidWiZMG2J34tAF2Jz5tgN2J8/7WWocbW5PdyE4bYDey0wbYjeysAWU3stMG2I3stAF2IzttAI9Rdb03oBE/NXAXFYyiklFUMYpqQlH2BlaejPTcRAmjqMkoShlFGaMoZxQVjKKSUVQximpCUc5IdGckujMS3RmJ7oxEd0aiOyPRnZHozkh0ZyR6MBI9GIkejEQPRqIHI9GDkejBSPRgJHowEj0YiZ6MRE9Goicj0ZOR6MlI9GQkejISPRmJnoxET0aiFyPRi5HoxUj0YiR6MRK9GIlejEQvRqIXI9GLkejNSPRmJHozEr0Zid6MRG9Gojcj0ZuR6M1I9CYkugxCossgJLoMQqLLICS6DEKiyyAkugxCossgJLoMQqLLYCS6MBJdGIkujEQXRqILI9GFkejCSHRhJLowEl0YiT4ZiT4ZiT4ZiT4ZiT4ZiT4ZiT4ZiT4ZiT4ZiT4Zia6MRFdGoisj0ZWR6MpIdGUkujISXRmJroxEV0aiM86MCuPMqDDOjArjzKgwzowK48yoMM6MCuPMqDDOjArjzKgwzowK48yoMM6MCuPMqDDOjArjzKgwzowK48yoMM6MCuPMqDDOjArjzKgwzowK48yoMM6MCuPMqDDOjArjzKgwzowK48yoMM6MCuPMqDDOjArjzKgwzowK48yoMM6MCuPMqDDOjArjzKgwzowK48yoMM6MCuPMqDDOjArjzKgwzowK48yoMM6MCuPMqDDOjArjzKgwzowK48yoMM6MCuPMqDDOjArjzKgwzowK48zoZJwZnYwzo5NxZnQyzozOQUj0yTgzOhlnRifjzOhknBmdjDOj8w0zo1qP36axcSxKGEVNRlHKKMoYRTmjqGAUlYyiilFUE4qajESfjESfjESfjESfjESfjESfjESfjESfjESfjERXRqIrI9GVkejKSHRlJLoyEl0Zia6MRFdGoisj0Y2R6MZIdGMkujES3RiJboxEN0aiGyPRjZHov5iE1H6IulH/RJTX4zfPvbNPrv5jP6d+2ym+C5Gjn1Ofv5ia3KgB3b0BI2+g8i6k52EDvnsDsXsDuXsDtXsDvU8DcdTAL6ZSN2qA3YlPG2B34tMG2J34tIGNnPi4gY2c+LgBcifW2T8uVpPDBsid+LwBcic+b4DciU8bSHInPm+A3InPGyB34k8N+DhsgNyJzxsgd2KddyEaxw2QO7FKnDTA7sSnDbA78WkD7E78eGutw42tYjey0wbYjey0AXYjO22A3chOG2A3stMG2I3stAE8RtX13oBG/NTAXVQTiurBKEoYRU1GUW9g5elITxujKGcUFYyiklFUMYpqPlE6BqMoYRQ1GUUREl0HIdF1EBJdByHRdRASXQch0XUwEl0YiS6MRBdGogsj0YWR6MJIdGEkujASXRiJLoxEn4xEn4xEn4xEn4xEn4xEn4xEn4xEn4xEn4xEn4xEV0aiKyPRlZHoykh0ZSS6MhJdGYmujERXRqIrI9GNkejGSHRjJLoxEt0YiW6MRDdGohsj0Y2R6MZIdGckujMS3RmJ7oxEd0aiOyPRnZHozkh0ZyS6MxI9GIkejEQPRqIHI9GDkejBSPRgJHowEj0YiR6MRE9Goicj0ZOR6MlI9GQkejISPRmJnoxET0aiJyPRi5HoxUj0YiR6MRK9GIlejEQvRqIXI9GLkejFSPRmJHozEr0Zic44M6qMM6PKODOqjDOjyjgzqowzo8o4M2qMM6PGODNqjDOjxjgzeruAURQh0Y1xZtQYZ0aNcWbUGGdGjXFm1BhnRo1xZtQYZ0aNcWbUGGdGjXFm1BhnRo1xZtQYZ0aNcWbUGGdGjXFm1BhnRo1xZtQYZ0aNcWbUGGdGjXFm1BhnRo1xZtQYZ0aNcWbUGGdGjXFm1BhnRo1xZtQYZ0aNcWbUGGdGjXFm1BhnRo1xZtQYZ0aNcWbUGGdGjXFm1BhnRo1xZtQYZ0aNcWbUGGdGjXFm1BhnRo1xZtQYZ0aNcWbUGGdGjXFm1BhnRo1xZtQYZ0aNcWbU3jAzqvX4bRobx6KMUZQzigpGUckoqhhFNaGoN8yMfkGUMIqajKIYiZ6MRE9Goicj0ZOR6MlI9GQkejESvRiJXoxEL0aiFyPRi5HoxUj0YiR6MRK9GInejERvRqI3I9GbkejNSPRmJHozEr0Zid6MRG9CovsgJLoPQqL7eAansu87414qZ6K87i3c/qM/rjZ7aHJCTUGoKQk1FaGm5tP0lBnIZ2sSQk2TUJMSaiLkuBByXAg5LoQcFzzHY+RdU8w80tR8muYg1CSEmiahJiXUZISanFBTEGpKQk2EHJ+EHFdCjishx5WQ40rIcSXkuBJyXAk5roQcV0KOKyHHjZDjRshxI+S4EXLcCDluhBw3Qo4bIceNkONGyHEn5LgTctwJOf6UybicfdeU9ffvZz5lMO7ZmopQU/NpespU3LM1CaGmSahJCTUZoSYn1ETI8SDkeBByPAg5nniOnz6rpBBqmoSalFCTEWpyQk1BqCkJNRWhpubTVIQcL0KOFyHHi5DjRcjxIuR4EXK8CDlehBwvQo43IcebkONNyPEm5HgTcrwJOd6EHG9Cjjchx5uP4zH4OB6Dj+Mx+Dgeg4/jMfg4Hk+ZK4uUhyaJM01n+5nxlLmyJ2t6ylzZszUJoaZJqEkJNRmhJifUFISaklATIceFkOOTkOOTkOMTz/HTZ5WphJqMUJMTagpCTUmoqQg1NZ8mHYSahFATIceVkONKyHEl5LgSclwJOa6EHFdCjhshx42Q40bIcSPkuBFy3Ag5boQcN0KOGyHHjZDjTshxJ+S4E3LcCTnuhBx3Qo47Icd/MVcmcq8yZ82zKjnj3oKk5kcdHXp0vcXjSFYfH+/+25Gs/3CgZd6lyMenM1MfLcj+Lcz9W1D6Fup+L8yehy3Y/i34/i3E/i3k/i3UTi3EYQu9fQvJ786nLfC782kL/O582sJW7nzcwlbufNwCvTvrI7GoJoct0LvzeQv07nzeAr07n7dA786nLRS9O5+3QO/On1rwcdgCvTuft0Dvzjrv761x3AK9O6vESQv87nzaAr87n7bA786Pn5/SOtwKK35rO2uh+a3ttAV+azttgd/aTlvgt7bTFvit7bSFd0BVXe+Xa8RPLdxlFaesZpSVY3DKEk5Zb2HnuB8iKyZyKEs5ZRmnLOeUFZyyklNWccpqSlkyOGUJpyxOygsn5YWT8sJJeeGkvHBSXjgpL5yUn5yUn5yUn5yUn5yUn5yUn5yUn5yUn5yUn5yUn5yUV07KKyfllZPyykl55aS8clJeOSmvnJRXTsorJ+WNk/LGSXnjpLxxUt44KW+clDdOyhsn5Y2T8sZJeeekvHNS3jkp75yUd07KOyflnZPyzkl556S8c1I+OCkfnJQPTsoHJ+WDk/LBSfngpHxwUj44KR+clE9Oyicn5ZOT8slJ+eSkfHJSPjkpn5yUT07KJyfli5PyxUn54qR8cVK+OClfnJQvTsoXJ+WLk/LFSfnmpHxzUr45Kd+clG9Oyjcn5ZuT8s1J+eakfFNSvgYl5WtQUr44Z1+Lc/a1BiXli3P2tThnX4tz9rU4Z1+Lc/a1OGdfi3P2tThnX4tz9rU4Z1+Lc/a1OGdfi3P2tThnX4tz9rU4Z1+Lc/a1OGdfi3P2tThnX4tz9rU4Z1+Lc/a1OGdfi3P2tThnX4tz9rU4Z1+Lc/a1OGdfi3P2tThnX4tz9rU4Z1+Lc/a1OGdfi3P2tThnX4tz9rU4Z1+Lc/a1OGdfi3P2tThnX4tz9rU4Z1+Lc/a1OGdfi3P2tThnX4tz9rU4Z1+Lc/a1OGdfi3P2tThnX4tz9rU4Z1+Lc/a1OGdfi3P2tThnX4tz9rU4Z1+Lc/a1OGdfi3P2tThnX+sts69a8pA1jmUZpyznlBWcspJTVnHKakpZb5l9/YIs4ZQ1OWVxUr44KV+clC9Oyhcn5YuT8sVJ+eakfHNSvjkp35yUb07KNyflm5PyzUn55qR8U1K+ByXle1BSvgcl5XtQUr4HJeV7UFK+ByXle1BSvgcl5XtwUl44KS+clH/ONOftDR+y5uwzWV7jfvntj/iPq80eqpxSVVCqSkpVRamqGVU9Z47z6aqEUtWkVKWUqijZPinZPinZPinZPt/B9hh5vzxmHqlqRlU6KFUJpapJqUopVRmlKqdUFZSqklIVJduVku1GyXajZLtRst0o2W6UbDdKthsl242S7UbJdqNku1Oy3SnZ7pRsd0q2OyXbnZLtTsl2p2S7U7LdKdkelGwPSrYHJdufM9cn9qFKapypOt0Xfc5Y39NVFaWqZlT1nJm+p6sSSlWTUpVSqjJKVU6pipLtScn2pGR7UrK93sH20yeZEkpVk1KVUqoySlVOqSooVSWlqqJU1YyqmpLtTcn2pmR7U7K9KdnelGxvSrY3Jdubku1NyPYYg5DtN1WEbL+pImT7TRUh22+qCNl+U0XI9psqQrbfVBGy/aaKkO03VZRsF0q2CyXbhZLtQsl2oWT7c2biRn2MgIr+vfuiN1XNqOo5M3FPVyWUqialKqVUZZSqnFJVUKpKSlWUbJ+UbFdKtisl2/UdbD99klGlVGWUqpxSVVCqSkpVRamqGVXZoFQllKoo2W6UbDdKthsl242S7UbJdqNku1Gy3SnZ7pRsd0q2OyXbnZLtTsl2p2S7U7LdKdnulGwPSrYHJduDku1ByfagZHtQsj0o2f6cmbjb9upD1Ug/U3W6L/qcmbinq5qUqpRSlVGqckpVQakqKVUVpapmVFWUbC9Kthcl24uS7fUOtp8+yZRTqgpKVUmpqihVNaOqHpSqhFLVpFSllKoo2d6UbG9Ktjcl25uS7c3IdhmMbJfByHYZjGyXwch2GYxsl8HIdhmMbJfByHYZjGyXQcl2oWS7ULJdKNkulGwXSrYLJduFku1CyXahZPvxTJx0P1QNrRNVdXtK+3F1Tfncgx9psni04OPj6t9+bPMfDj6feRci+rh2pj4a0N0bsN0bcPIG6n4PzJ6HDcTuDeTuDdTuDfTmDRzPGnI2EIcNyO4NsDvxaQPsTnzaALsTnzawkRMfN7CREx83QO7EOvvHxWpy2AC5E583QO7Epw0YuROfN0DuxOcNkDvxeQPkTvypAR+HDZA78XkD5E6s8x5+1zhugNyJVeKkAXYnPm2A3YlPG2B34rynM7UON7ac3chOG2A3stMG2I3stAF2IzttgN3IThtgN7LTBvAYVX8c6KkRPzXwQ1QMRlHCKGoyilJGUW9g5bC7KBM5FOWMooJRVDKKKkZRTSgqB6MoYRQ1GUUpoyhGoicj0ZOR6MlI9GQkejISvRiJXoxEL0aiFyPRi5HoxUj0YiR6MRK9GIlejERvRqI3I9GbkejNSPRmJHozEr0Zid6MRG9Gojch0ecgJPochESfg5DocxASfQ5Cos9BSPQ5CIk+ByHR5yAk+hyMRBdGogsj0YWR6MJIdGEkujASXRiJLoxEF0aiCyPRJyPRJyPRJyPRJyPRJyPRJyPRJyPRJyPRJyPRJyPRlZHoykh0ZSS6MhJdGYmujERXRqIrI9GVkejKSHRjJLoxEt0YiW6MRDdGohsj0Y2R6MZIdGMkujES3RmJ7oxEd0aiOyPRnZHozkh0ZyS6MxLdGYnujEQPRqIHI9GDkejBSHTGmdHJODM6GWdGJ+PM6GScGZ2MM6OTcWZ0Ms6MTsaZ0ck4MzoZZ0Yn48zoZJwZnYwzo5NxZnQyzoxOxpnRyTgzOhlnRifjzOhknBmdjDOjk3FmdDLOjE7GmdHJODM6GWdGJ+PM6GScGZ2MM6OTcWZ0Ms6MTsaZ0ck4MzoZZ0Yn48yoMs6MKuPMqDLOjCrjzKgOQqIr48yoMs6MKuPMqDLOjCrjzKgyzowq48yoMs6MKuPMqDLOjCrjzKgyzowq48yoMs6MKuPMqDLOjCrjzKgyzowq48yoMs6MKuPMqDLOjCrjzKgyzowq48yoMs6MKuPMqL5hZlRLHqLGsShlFGWMopxRVDCKSkZRxSiqCUW9YWb0C6KEURQj0Y2R6MZIdGMkujES3RiJboxEN0aiOyPRnZHozkh0ZyS6MxLdGYnujER3RqI7I9GdkejBSPRgJHowEj0YiR6MRA9Gogcj0YOR6MFI9GAkejIS/ReTkNX33+aW9nkiSn6Ltd8v/40yj+vdji7PWXW/PG9fh08u/0M/Kn77UO6fphz9qLj+Ysrywg37d2s4LtZw5b3hnocN53druL5bw/3NGv7FNO6FG5brNhyHDc/v1vDVnrROG7bv1vDVnrROG77wk9Zxwxd+0jpu+GJPWjr7x8VqctjwxZ60Thvuiz1pnTd8sSet84Yv9qR13vDFnrTOG7bLNuzjsOGLPWmdN3yxJy2d97e+/aHzsOGLPWmpxEnDV3vSOm34ak9aJw3buNqTVt6F3/Y2Dhu+2oPHacNXe/A4bdi+W8NXe/A4bfhqDx6nDV/tweOsYeG3JfV76EE04qeG703wf6n/QhP8fvmFJvg98AtN8PvaF5rYwKvORmpNNvCf8yY28JTzJjb4gnrexAZfOk+bmBt8kTxvYoNt+PMmNviGe97EBt9az5vgd+wvNHEFx55XcOx5BceeV3DseQXH1is4tl7BsfUKjq1XcGy9gmPrFRxbr+DYegXH1is4tl7Bse0Kjm1XcGy7gmPbFRzbruDYdgXHtis4tl3Bse0Kjm1XcGy/gmP7FRzbr+DYfgXH9is4tl/Bsf0Kju1XcGy/gmP7FRw7ruDYcQXHjis4dlzBseMKjh1XcOy4gmPHFRw7ruDYcQXHzis4dl7BsfMKjr3D4YPnTVzBsXc4JPC8iSs49g6H+Z03cQXH3uHQvdMmdjhI77yJKzj2DgfenTdxBcfe4WC68yau4Ng7HCB33sQVHHuHg97Om7iCY+9wINt5E1dw7B0OTjtv4gqOvcMBZ+dNXMGxdziI7LyJKzj2DgeGnTdxAcf2HQ72Om/iAo7tO5w4dt7EBRzbxwUc23c47eu8iQs4tu9wKtd5ExdwbB9XcOwNzjz7QhNXcOwNzjz7QhNXcOwNzjz7QhNXcOwrnHnmVzjzzK9w5plf4cwzv8KZZ36FM8/8Cmee+RXOPPMrnHnmVzjzzK9w5plf4cwzv8KZZ36FM8/8Cmee+RXOPPMrnHnmVzjzzK9w5plf4cwzv8KZZ36FM8/8Cmee+RXOPPMrnHnmVzjzzK9w5plf4cwzv8KZZ36FM8/8Cmee+RXOPPMrnHnmVzjzzK9w5plf4cwzv8KZZ36FM8/8Cmee+RXOPPMrnHnmVzjzzK9w5plf4cwzv8KZZ36FM8/8Cmee+RXOPPMrnHnmVzjzzK9w5plf4cwzv8KZZ36FM8/8Cmee+RXOPPMrnHnmVzjzzK9w5plf4cwzv8KZZ36FM8/8Cmee+RXOPPMrnHnmVzjzzK9w5plf4cwzv8KZZ77BmWdajze3cdwEv2N/oQl+x/5CE/yO/YUm+B37vIkNzjz7QhP8jv2FJvgd+wtN8Dv2F5rgd+wvNHEFx97gzLMvNHEFx97gzLMvNHEBx44Nzjz7QhMXcOzY4MyzLzRxAceOcQHHjg3OPPtCExdw7NjgzLMvNHEBx44Nzjw7b2KDM8++0MQVHHuDM8++0MQVHHuDM8++0MQVHHuDM8++0MQVHHuDM8++0MQVHHuDM8++0MQVHHuDM8++0MTejn37b//vP/73f/7H//hf/+nfbq/57X/8H//yn/79n//1X37813////7bX/+X27X/Pw=="},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"_approve_bridge_and_exit_input_asset_to_L1","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"token_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"pending_shields","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"token","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"portal_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"portal_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"input_asset_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"input_amount","type":{"kind":"field"}},{"name":"output_asset_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"nonce_for_transfer_approval","type":{"kind":"field"}},{"name":"uniswap_fee_tier","type":{"kind":"field"}},{"name":"minimum_output_amount","type":{"kind":"field"}},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"secret_hash_for_L1_to_l2_message","type":{"kind":"field"}},{"name":"caller_on_L1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"nonce_for_swap_approval","type":{"kind":"field"}}],"kind":"struct","path":"Uniswap::swap_public_parameters"}}],"kind":"struct","path":"Uniswap::swap_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"token_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Uniswap::_assert_token_is_same_parameters"}}],"kind":"struct","path":"Uniswap::_assert_token_is_same_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"Uniswap::constructor_parameters"}}],"kind":"struct","path":"Uniswap::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"token_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}}],"kind":"struct","path":"Uniswap::_approve_bridge_and_exit_input_asset_to_L1_parameters"}}],"kind":"struct","path":"Uniswap::_approve_bridge_and_exit_input_asset_to_L1_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"input_asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"input_asset_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"input_amount","type":{"kind":"field"}},{"name":"output_asset_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"nonce_for_unshield_approval","type":{"kind":"field"}},{"name":"uniswap_fee_tier","type":{"kind":"field"}},{"name":"minimum_output_amount","type":{"kind":"field"}},{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"}},{"name":"secret_hash_for_L1_to_l2_message","type":{"kind":"field"}},{"name":"caller_on_L1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"Uniswap::swap_private_parameters"}}],"kind":"struct","path":"Uniswap::swap_private_abi"}]}},"file_map":{"112":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__INNER_NOTE_HASH,\n    hash::{\n    pedersen_hash, compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_inner_note_hash_from_preimage(storage_slot: Field, note_content_hash: Field) -> Field {\n    pedersen_hash(\n        [storage_slot, note_content_hash],\n        GENERATOR_INDEX__INNER_NOTE_HASH\n    )\n}\n\nfn compute_inner_note_hash<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    compute_inner_note_hash_from_preimage(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N, M>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let (_, inner_nullifier) = note_with_header.compute_note_hash_and_nullifier(context);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\nfn compute_note_hash_for_read_request_from_innter_and_nonce(\n    inner_note_hash: Field,\n    nonce: Field\n) -> Field {\n    // TODO(#1386): This if-else can be nuked once we have nonces injected from public\n    if (nonce == 0) {\n        // If nonce is zero, that means we are reading a public note.\n        inner_note_hash\n    } else {\n        compute_unique_note_hash(nonce, inner_note_hash)\n    }\n}\n\npub fn compute_note_hash_for_read_request<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let inner_note_hash = compute_inner_note_hash(note);\n    let nonce = note.get_header().nonce;\n\n    compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, nonce)\n}\n\npub fn compute_note_hash_for_consumption<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    if (header.note_hash_counter != 0) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        inner_note_hash\n    } else {\n        // If a note is not transient, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the siloed_note_hash which has already been hashed with\n        // nonce and then contract address. This hash will match the existing leaf in the note hash\n        // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, header.nonce);\n        compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, N, M, S>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n    let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, note_header.nonce);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        let (_, nullifier) = note.compute_note_hash_and_nullifier_without_context();\n        nullifier\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [inner_note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"122":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::{compute_siloed_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_contract_initialization_nullifier(context.this_address());\n    let header = context.get_header();\n    header.prove_nullifier_inclusion(init_nullifier);\n}\n\nfn compute_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    compute_siloed_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(address)\n    )\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"123":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr","source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"},"125":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"127":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle<N>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<N>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<N>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n"},"128":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n"},"135":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n"},"139":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"140":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{\n    abis::{\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\n    utils::reader::Reader,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n}\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\n    let mut reader = Reader::new(fields);\n\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n    // WARNING: if updating, see comment in public_call_stack_item.ts's PublicCallStackItem.hash()\n    let item = PublicCallStackItem {\n        contract_address: AztecAddress::from_field(reader.read()),\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\n        public_inputs: PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            args_hash: reader.read(),\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            end_side_effect_counter: 0,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0\n        },\n        is_execution_request: true\n    };\n    reader.finish();\n\n    item\n}\n"},"149":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr","source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext}, oracle::storage::storage_read,\n    state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PublicContext> {\n    // Intended to be only called once. \n    pub fn initialize<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T> SharedImmutable<T, UnconstrainedContext> {\n    unconstrained pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PrivateContext> {\n    pub fn read_private<T_SERIALIZED_LEN>(self) -> T  where T: Deserialize<T_SERIALIZED_LEN> {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n"},"167":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{GAS_LENGTH, FIXED_DA_GAS, FIXED_L2_GAS}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\n    abis::gas_fees::GasFees\n};\nuse std::ops::{Add, Sub};\n\nstruct Gas {\n    da_gas: u32,\n    l2_gas: u32,\n}\n\nimpl Gas {\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\n        Self { da_gas, l2_gas }\n    }\n\n    pub fn tx_overhead() -> Self {\n        Self { da_gas: FIXED_DA_GAS, l2_gas: FIXED_L2_GAS }\n    }\n\n    pub fn compute_fee(self, fees: GasFees) -> Field {\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.da_gas == 0) & (self.l2_gas == 0)\n    }\n\n    pub fn within(self, limits: Gas) -> bool {\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\n    }\n}\n\nimpl Add for Gas {\n    fn add(self, other: Gas) -> Self {\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\n    }\n}\n\nimpl Sub for Gas {\n    fn sub(self, other: Gas) -> Self {\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\n    }\n}\n\nimpl Serialize<GAS_LENGTH> for Gas {\n    fn serialize(self) -> [Field; GAS_LENGTH] {\n        [self.da_gas as Field, self.l2_gas as Field]\n    }\n}\n\nimpl Deserialize<GAS_LENGTH> for Gas {\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\n    }\n}\n\nimpl Eq for Gas {\n    fn eq(self, other : Gas) -> bool {\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\n    }\n}\n\nimpl Empty for Gas {\n    fn empty() -> Self {\n        Gas::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Gas::empty();\n    let serialized = item.serialize();\n    let deserialized = Gas::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n"},"169":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr","source":"use crate::{\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct NoteHash {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for NoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteHash {\n    fn eq(self, other: NoteHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter) \n    }\n}\n\nimpl Empty for NoteHash {\n    fn empty() -> Self {\n        NoteHash {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl NoteHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNoteHash {\n        ScopedNoteHash { note_hash: self, contract_address }\n    }\n}\n\nstruct ScopedNoteHash {\n    note_hash: NoteHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<NoteHash> for ScopedNoteHash {\n    fn inner(self) -> NoteHash {\n        self.note_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNoteHash {\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNoteHash {\n    fn value(self) -> Field {\n        self.note_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl Eq for ScopedNoteHash {\n    fn eq(self, other: ScopedNoteHash) -> bool {\n        (self.note_hash == other.note_hash)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedNoteHash {\n    fn empty() -> Self {\n        ScopedNoteHash {\n            note_hash: NoteHash::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\n        array_concat(self.note_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            note_hash: reader.read_struct(NoteHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNoteHash {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.note_hash.value, read_request.value(), \"Value of the note hash does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the note hash does not match read request\");\n        assert(\n            read_request.counter() > self.note_hash.counter, \"Read request counter must be greater than the counter of the note hash\"\n        );\n    }\n}\n\nimpl ScopedNoteHash {\n    pub fn expose_to_public(self) -> NoteHash {\n        // Hide the actual counter when exposing it to the public kernel.\n        NoteHash { value: self.note_hash.value, counter: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = NoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"170":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"172":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr","source":"use crate::{\n    abis::{\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    transaction::tx_context::TxContext, utils::arrays::validate_array\n};\n\nstruct PrivateCircuitPublicInputsArrayLengths {\n    note_hash_read_requests: u32,\n    nullifier_read_requests: u32,\n    key_validation_requests_and_generators: u32,\n    note_hashes: u32,\n    nullifiers: u32,\n    l2_to_l1_msgs: u32,\n    private_call_requests: u32,\n    public_call_stack_hashes: u32,\n    note_encrypted_logs_hashes: u32,\n    encrypted_logs_hashes: u32,\n    unencrypted_logs_hashes: u32,\n}\n\nimpl PrivateCircuitPublicInputsArrayLengths {\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\n        PrivateCircuitPublicInputsArrayLengths {\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\n            note_hashes: validate_array(public_inputs.note_hashes),\n            nullifiers: validate_array(public_inputs.nullifiers),\n            l2_to_l1_msgs: validate_array(public_inputs.l2_to_l1_msgs),\n            private_call_requests: validate_array(public_inputs.private_call_requests),\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\n        }\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    note_hashes: [NoteHash; MAX_NOTE_HASHES_PER_CALL],\n    nullifiers: [Nullifier; MAX_NULLIFIERS_PER_CALL],\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs: [L2ToL1Message; MAX_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    tx_context: TxContext,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.returns_hash == other.returns_hash) &\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\n        (self.is_fee_payer == other.is_fee_payer) &\n        (self.max_block_number == other.max_block_number) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\n        (self.note_hashes == other.note_hashes) &\n        (self.nullifiers == other.nullifiers) &\n        (self.private_call_requests == other.private_call_requests) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.l2_to_l1_msgs == other.l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\n        self.historical_header.eq(other.historical_header) &\n        self.tx_context.eq(other.tx_context)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\n\n        fields.extend_from_array(self.max_block_number.serialize());\n\n        for i in 0..self.note_hash_read_requests.len() {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..self.nullifier_read_requests.len() {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..self.key_validation_requests_and_generators.len() {\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\n        }\n        for i in 0..self.note_hashes.len() {\n            fields.extend_from_array(self.note_hashes[i].serialize());\n        }\n        for i in 0..self.nullifiers.len() {\n            fields.extend_from_array(self.nullifiers[i].serialize());\n        }\n        for i in 0..self.private_call_requests.len() {\n            fields.extend_from_array(self.private_call_requests[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n        fields.push(self.public_teardown_function_hash);\n        for i in 0..self.l2_to_l1_msgs.len() {\n            fields.extend_from_array(self.l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        for i in 0..self.note_encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.unencrypted_logs_hashes.len() {\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.tx_context.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            is_fee_payer: reader.read() == 1,\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL]),\n            nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL]),\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            public_teardown_function_hash: reader.read(),\n            l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            tx_context: reader.read_struct(TxContext::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PrivateCircuitPublicInputs {\n    fn empty() -> Self {\n        PrivateCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter : 0 as u32,\n            end_side_effect_counter : 0 as u32,\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            tx_context: TxContext::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PrivateCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PrivateCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x15c9b0a92b9b541598e24c9f0b0b4b04b7f2408599751c45aa12de671fd9b363;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"173":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item_compressed.nr","source":"use crate::abis::{call_context::CallContext, function_data::FunctionData, gas::Gas};\nuse crate::address::AztecAddress;\nuse crate::constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH};\nuse crate::traits::{Hash, Empty, Serialize, Deserialize};\nuse crate::utils::reader::Reader;\n\n/**\n * A compressed version of the PublicCallStackItem struct used to compute the \"hash\"\n * of a PublicCallStackItem.\n * \n * Historically, we have been zeroing most values in the PublicCallStackItem struct\n * to compute the hash involved when adding a PublicCallStackItem to the PublicCallStack.\n * \n * This struct is used to store the values that we did not zero out, and allow us to hash\n * only these, thereby skipping a lot of computation and saving us a lot of constraints\n * \n * Essentially this struct exists such that we don't have a `hash` function in the \n * PublicCallStackItem struct that practically throws away some values of the struct\n * without clearly indicating that it does so.\n */\nstruct PublicCallStackItemCompressed {\n    contract_address: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    revert_code: u8,\n    start_gas_left: Gas,\n    end_gas_left: Gas,\n}\n\nimpl Eq for PublicCallStackItemCompressed {\n    fn eq(self, other: PublicCallStackItemCompressed) -> bool {\n        (self.contract_address == other.contract_address)\n            & (self.call_context == other.call_context)\n            & (self.function_data == other.function_data)\n            & (self.args_hash == other.args_hash)\n            & (self.returns_hash == other.returns_hash)\n            & (self.revert_code == other.revert_code)\n            & (self.start_gas_left == other.start_gas_left)\n            & (self.end_gas_left == other.end_gas_left)\n    }\n}\n\nimpl Hash for PublicCallStackItemCompressed {\n    fn hash(self) -> Field {\n        std::hash::pedersen_hash_with_separator(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PublicCallStackItemCompressed {\n    fn empty() -> Self {\n        PublicCallStackItemCompressed {\n            contract_address: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n    fn serialize(self) -> [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.push(self.revert_code as Field);\n        fields.extend_from_array(self.start_gas_left.serialize());\n        fields.extend_from_array(self.end_gas_left.serialize());\n\n        assert_eq(fields.len(), PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n  fn deserialize(fields: [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH]) -> PublicCallStackItemCompressed {\n    let mut reader = Reader::new(fields);\n\n    let item = PublicCallStackItemCompressed {\n      contract_address: reader.read_struct(AztecAddress::deserialize),\n      call_context: reader.read_struct(CallContext::deserialize),\n      function_data: reader.read_struct(FunctionData::deserialize),\n      args_hash: reader.read(),\n      returns_hash: reader.read(),\n      revert_code: reader.read() as u8,\n      start_gas_left: reader.read_struct(Gas::deserialize),\n      end_gas_left: reader.read_struct(Gas::deserialize),\n    };\n    reader.finish();\n    item\n  }\n}\n"},"175":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n"},"176":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr","source":"use crate::{\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for ReadRequest {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\n        ScopedReadRequest { read_request: self, contract_address }\n    }\n}\n\nstruct ScopedReadRequest {\n    read_request: ReadRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<ReadRequest> for ScopedReadRequest {\n    fn inner(self) -> ReadRequest {\n        self.read_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ScopedReadRequest {\n    fn eq(self, other: ScopedReadRequest) -> bool {\n        (self.read_request == other.read_request)\n        & (self.contract_address.eq(other.contract_address))\n    }\n}\n\nimpl Empty for ScopedReadRequest {\n    fn empty() -> Self {\n        ScopedReadRequest {\n            read_request: ReadRequest::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            read_request: reader.read_struct(ReadRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedReadRequest {\n    pub fn value(self) -> Field {\n        self.read_request.value\n    }\n    pub fn counter(self) -> u32 {\n        self.read_request.counter\n    }\n}\n\n#[test]\nfn serialization_of_empty_read() {\n    let item = ReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"179":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr","source":"use crate::{\n    address::AztecAddress,\n    abis::validation_requests::{\n    key_validation_request::KeyValidationRequest,\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\n},\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct KeyValidationRequestAndGenerator {\n    request: KeyValidationRequest,\n    sk_app_generator: Field,\n}\n\nimpl Eq for KeyValidationRequestAndGenerator {\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\n    }\n}\n\nimpl Empty for KeyValidationRequestAndGenerator {\n    fn empty() -> Self {\n        KeyValidationRequestAndGenerator {\n            request: KeyValidationRequest::empty(),\n            sk_app_generator: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\n        array_concat(self.request.serialize(), [self.sk_app_generator])\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\n        let mut reader = Reader::new(fields);\n        let res = Self {\n            request: reader.read_struct(KeyValidationRequest::deserialize),\n            sk_app_generator: reader.read(),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl KeyValidationRequestAndGenerator {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = KeyValidationRequestAndGenerator::empty();\n    let serialized = item.serialize();\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"180":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point::new(fields[0], fields[1], fields[2] as bool),\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"184":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr","source":"use crate::{\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH},\n    hash::compute_siloed_nullifier, traits::{Empty, Hash, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct Nullifier {\n    value: Field,\n    counter: u32,\n    note_hash: Field,\n}\n\nimpl Ordered for Nullifier {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for Nullifier {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for Nullifier {\n    fn eq(self, other: Nullifier) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.note_hash == other.note_hash) \n    }\n}\n\nimpl Empty for Nullifier {\n    fn empty() -> Self {\n        Nullifier {\n            value: 0,\n            counter: 0,\n            note_hash: 0,\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\n        [self.value, self.counter as Field, self.note_hash]\n    }\n}\n\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            note_hash: values[2],\n        }\n    }\n}\n\nimpl Readable for Nullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        // Public kernels output Nullifier instead of ScopedNullifier.\n        // The nullifier value has been siloed.\n        let siloed_request_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.value, siloed_request_value, \"Value of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl Nullifier {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\n        ScopedNullifier { nullifier: self, contract_address }\n    }\n}\n\nstruct ScopedNullifier {\n    nullifier: Nullifier,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<Nullifier> for ScopedNullifier {\n    fn inner(self) -> Nullifier {\n        self.nullifier\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNullifier {\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNullifier {\n    fn value(self) -> Field {\n        self.nullifier.value\n    }\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl Eq for ScopedNullifier {\n    fn eq(self, other: ScopedNullifier) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedNullifier {\n    fn empty() -> Self {\n        ScopedNullifier {\n            nullifier: Nullifier::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            nullifier: reader.read_struct(Nullifier::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.nullifier.value, read_request.value(), \"Value of the nullifier does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.nullifier.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl ScopedNullifier {\n    pub fn nullified_note_hash(self) -> Field {\n        self.nullifier.note_hash\n    }\n\n    pub fn expose_to_public(self) -> Nullifier {\n        // Hide the actual counter and note hash when exposing it to the public kernel.\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Nullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = Nullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"192":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr","source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n  fn eq(self, other: Self) -> bool {\n    (self.nullifier == other.nullifier) &\n    (self.next_nullifier == other.next_nullifier) &\n    (self.next_index == other.next_index)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"193":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"194":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr","source":"use crate::{\n    abis::{\n    private_call_stack_item::PrivateCallStackItem, call_context::CallContext,\n    function_data::FunctionData, caller_context::CallerContext,\n    side_effect::{Ordered, RangeOrdered, Scoped}\n},\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PrivateCallRequest {\n    target: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Ordered for PrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.start_side_effect_counter\n    }\n}\n\nimpl RangeOrdered for PrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.start_side_effect_counter\n    }\n    fn counter_end(self) -> u32 {\n        self.end_side_effect_counter\n    }\n}\n\nimpl Eq for PrivateCallRequest {\n    fn eq(self, other: PrivateCallRequest) -> bool {\n        (self.target == other.target) \n            & (self.call_context == other.call_context) \n            & (self.function_data == other.function_data) \n            & (self.args_hash == other.args_hash) \n            & (self.returns_hash == other.returns_hash)\n            & (self.caller_context == other.caller_context)\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\n    }\n}\n\nimpl Empty for PrivateCallRequest {\n    fn empty() -> Self {\n        PrivateCallRequest {\n            target: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.push(self.target.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.extend_from_array(self.caller_context.serialize());\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = PrivateCallRequest {\n            target: reader.read_struct(AztecAddress::deserialize),\n            call_context: reader.read_struct(CallContext::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            caller_context: reader.read_struct(CallerContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            end_side_effect_counter: reader.read_u32(),\n        };\n        reader.finish();\n        item\n    }\n}\n\nimpl PrivateCallRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\n        ScopedPrivateCallRequest { call_request: self, contract_address }\n    }\n\n    pub fn matches_stack_item(self, stack_item: PrivateCallStackItem) -> bool {\n        (self.target == stack_item.contract_address)\n            & (self.call_context == stack_item.public_inputs.call_context)\n            & (self.function_data == stack_item.function_data)\n            & (self.args_hash == stack_item.public_inputs.args_hash)\n            & (self.returns_hash == stack_item.public_inputs.returns_hash)\n            & (self.start_side_effect_counter\n                                == stack_item.public_inputs.start_side_effect_counter)\n            & (self.end_side_effect_counter\n                                    == stack_item.public_inputs.end_side_effect_counter)\n    }\n}\n\nstruct ScopedPrivateCallRequest {\n    call_request: PrivateCallRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\n    fn inner(self) -> PrivateCallRequest {\n        self.call_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedPrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.call_request.counter_start()\n    }\n}\n\nimpl RangeOrdered for ScopedPrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.call_request.counter_start()\n    }\n    fn counter_end(self) -> u32 {\n        self.call_request.counter_end()\n    }\n}\n\nimpl Eq for ScopedPrivateCallRequest {\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\n        (self.call_request == other.call_request)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedPrivateCallRequest {\n    fn empty() -> Self {\n        ScopedPrivateCallRequest {\n            call_request: PrivateCallRequest::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.call_request.serialize());\n        fields.extend_from_array(self.contract_address.serialize());\n\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = ScopedPrivateCallRequest {\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        item\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = ScopedPrivateCallRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"199":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\n    abis::gas_fees::GasFees,\n    constants::{\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\n    DEFAULT_INCLUSION_FEE\n},\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    utils::reader::Reader\n};\n\nstruct GasSettings {\n    gas_limits: Gas,\n    teardown_gas_limits: Gas,\n    max_fees_per_gas: GasFees,\n    inclusion_fee: Field,\n}\n\nimpl GasSettings {\n    pub fn new(\n        gas_limits: Gas,\n        teardown_gas_limits: Gas,\n        max_fees_per_gas: GasFees,\n        inclusion_fee: Field\n    ) -> Self {\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\n    }\n\n    pub fn default() -> Self {\n        GasSettings::new(\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\n            DEFAULT_INCLUSION_FEE\n        )\n    }\n}\n\nimpl Eq for GasSettings {\n    fn eq(self, other: Self) -> bool {\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\n    }\n}\n\nimpl Empty for GasSettings {\n    fn empty() -> Self {\n        GasSettings::new(\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\n        )\n    }\n}\n\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\n\n        serialized.extend_from_array(self.gas_limits.serialize());\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\n        serialized.push(self.inclusion_fee);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\n        let mut reader = Reader::new(serialized);\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasSettings::empty();\n    let serialized = item.serialize();\n    let deserialized = GasSettings::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"208":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr","source":"use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PrivateCallStackItem {\n    fn empty() -> Self {\n        PrivateCallStackItem {\n            contract_address: AztecAddress::empty(),\n            function_data: FunctionData::empty(),\n            public_inputs: PrivateCircuitPublicInputs::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = PrivateCallStackItem::empty();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item = PrivateCallStackItem::empty();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x065f2831db9ac0db5e710bd3a865b5facd8cf83f1585e1af8fd1d6ce9c47f685;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr","source":"use crate::address::AztecAddress;\nuse crate::traits::{Empty, Serialize, Deserialize};\nuse crate::constants::CALLER_CONTEXT_LENGTH;\nuse crate::utils::reader::Reader;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n    is_static_call: bool,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, other: CallerContext) -> bool {\n        other.msg_sender.eq(self.msg_sender)\n            & other.storage_contract_address.eq(self.storage_contract_address)\n            & other.is_static_call == self.is_static_call\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n            is_static_call: false,\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\n    }\n\n    // Different to an empty context, a hidden context won't reveal the caller's msg_sender and storage_contract_address,\n    // but will still propagate the is_static_call flag.\n    pub fn is_hidden(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array(self.msg_sender.serialize());\n    fields.extend_from_array(self.storage_contract_address.serialize());\n    fields.push(self.is_static_call as Field);\n\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\n    let mut reader = Reader::new(fields);\n\n    let item = CallerContext {\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\n      is_static_call: reader.read_bool(),\n    };\n    reader.finish();\n    item\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = CallerContext::empty();\n    let serialized = item.serialize();\n    let deserialized = CallerContext::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"211":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr","source":"use crate::{\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\n    constants::{\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\n},\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct LogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n}\n\nimpl Ordered for LogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for LogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for LogHash {\n    fn eq(self, other: LogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n    }\n}\n\nimpl Empty for LogHash {\n    fn empty() -> Self {\n        LogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n        }\n    }\n}\n\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length]\n    }\n}\n\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n        }\n    }\n}\n\nimpl LogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\n        ScopedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedLogHash {\n    log_hash: LogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<LogHash> for ScopedLogHash {\n    fn inner(self) -> LogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedLogHash {\n    fn eq(self, other: ScopedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedLogHash {\n    fn empty() -> Self {\n        ScopedLogHash {\n            log_hash: LogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(LogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the counter when exposing to public.\n        // The log hash must already be siloed when we call this.\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nstruct EncryptedLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    randomness: Field,\n}\n\nimpl Ordered for EncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for EncryptedLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for EncryptedLogHash {\n    fn eq(self, other: EncryptedLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.randomness == other.randomness) \n    }\n}\n\nimpl Empty for EncryptedLogHash {\n    fn empty() -> Self {\n        EncryptedLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            randomness: 0,\n        }\n    }\n}\n\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.randomness]\n    }\n}\n\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            randomness: values[3],\n        }\n    }\n}\n\nimpl EncryptedLogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedEncryptedLogHash {\n    log_hash: EncryptedLogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\n    fn inner(self) -> EncryptedLogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl ScopedEncryptedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the secret randomness and counter when exposing to public\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\n        // The log hash will already be silo'd when we call this\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nimpl Ordered for ScopedEncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedEncryptedLogHash {\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedEncryptedLogHash {\n    fn empty() -> Self {\n        ScopedEncryptedLogHash {\n            log_hash: EncryptedLogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct NoteLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    note_hash_counter: u32,\n}\n\nimpl NoteLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\n        LogHash { value: self.value, counter: 0, length: self.length }\n    }\n}\n\nimpl Ordered for NoteLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for NoteLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteLogHash {\n    fn eq(self, other: NoteLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.note_hash_counter == other.note_hash_counter) \n    }\n}\n\nimpl Empty for NoteLogHash {\n    fn empty() -> Self {\n        NoteLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            note_hash_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            note_hash_counter: values[3] as u32,\n        }\n    }\n}\n"},"215":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr","source":"struct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n"},"216":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n}\n// docs:end:call-context\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n"},"217":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"22":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"220":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize, Empty}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        (self.is_private == other.is_private)\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nimpl Empty for FunctionData {\n    fn empty() -> Self {\n        FunctionData {\n            selector: FunctionSelector::empty(),\n            is_private: false\n        }\n    }\n\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data = FunctionData::empty();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data = FunctionData::empty();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty function data hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"227":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n    counter: u32,\n}\n\nimpl Ordered for L2ToL1Message {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content, self.counter as Field]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\nimpl L2ToL1Message {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\n        ScopedL2ToL1Message { message: self, contract_address }\n    }\n}\n\nstruct ScopedL2ToL1Message {\n    message: L2ToL1Message,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\n    fn inner(self) -> L2ToL1Message {\n        self.message\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedL2ToL1Message {\n    fn counter(self) -> u32 {\n        self.message.counter\n    }\n}\n\nimpl Eq for ScopedL2ToL1Message {\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\n        (self.message == other.message)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedL2ToL1Message {\n    fn empty() -> Self {\n        ScopedL2ToL1Message {\n            message: L2ToL1Message::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            message: reader.read_struct(L2ToL1Message::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\n#[test]\nfn serialization_of_empty_l2() {\n    let item = L2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = L2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped_l2() {\n    let item = ScopedL2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"235":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<N> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<N> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<N> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<N> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"237":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr","source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  num_txs: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.num_txs);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let num_txs = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      num_txs,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      num_txs: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.num_txs == other.num_txs)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n"},"238":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"239":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr","source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"241":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n"},"243":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr","source":"use crate::{\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    abis::gas_settings::GasSettings\n};\n\n// docs:start:tx-context\nstruct TxContext {\n    chain_id : Field,\n    version : Field,\n    gas_settings: GasSettings,\n}\n// docs:end:tx-context\n\nimpl TxContext {\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\n        TxContext { chain_id, version, gas_settings }\n    }\n}\n\nimpl Eq for TxContext {\n    fn eq(self, other: Self) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.gas_settings.eq(other.gas_settings))\n    }\n}\n\nimpl Empty for TxContext {\n    fn empty() -> Self {\n        TxContext {\n            chain_id: 0,\n            version: 0,\n            gas_settings: GasSettings::empty(),\n        }\n    }\n}\n\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\n\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.extend_from_array(self.gas_settings.serialize());\n\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let context = Self {\n            chain_id: reader.read(),\n            version: reader.read(),\n            gas_settings: reader.read_struct(GasSettings::deserialize),\n        };\n\n        reader.finish();\n        context\n    }\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context = TxContext::empty();\n    let serialized = context.serialize();\n    let deserialized = TxContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let context = TxContext::empty();\n    let hash = context.hash();\n\n    // Value from tx_context.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"247":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"249":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n"},"25":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n#[no_predicates]\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    let value = pedersen_commitment_with_separator(input, 0);\n    if (value.x == 0) & (value.y == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value.x, y: value.y, is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        points[i] = EmbeddedCurveScalar::from_field(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let values = multi_scalar_mul(generators, points);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: values[2] as bool }\n}\n\n#[no_predicates]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let v1 = pedersen_commitment_with_separator(input, separator);\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    multi_scalar_mul(\n        [length_generator[0], v1],\n        [EmbeddedCurveScalar { lo: N as Field, hi: 0 }, EmbeddedCurveScalar { lo: 1, hi: 0 }]\n    )[0]\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n#[test]\nfn assert_pedersen_noir() {\n    // TODO: make this a fuzzer test once fuzzer supports curve-specific blackbox functions.\n    let input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq(pedersen_hash_with_separator(input, 4), pedersen_hash_with_separator_noir(input, 4));\n    assert_eq(pedersen_commitment_with_separator(input, 4), pedersen_commitment_with_separator_noir(input, 4));\n}\n"},"263":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"273":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"289":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"303":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/main.nr","source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n\ncontract Token {\n    // Libs\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        hash::compute_secret_hash,\n        prelude::{NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress},\n        encrypted_logs::{\n        encrypted_note_emission::{\n        encode_and_encrypt_note, encode_and_encrypt_note_with_keys,\n        encode_and_encrypt_note_with_keys_unconstrained\n    },\n        encrypted_event_emission::{encode_and_encrypt_event, encode_and_encrypt_event_with_keys_unconstrained}\n    }\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public, compute_authwit_nullifier};\n    // docs:end:import_authwit\n\n    use crate::types::{transparent_note::TransparentNote, token_note::{TokenNote, TOKEN_NOTE_LEN}, balances_map::BalancesMap};\n    // docs:end::imports\n\n    #[aztec(event)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: BalancesMap<TokenNote>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128>>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n\n    // docs:start:admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[aztec(public)]\n    #[aztec(view)]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_public\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n\n    // docs:start:mint_private\n    #[aztec(public)]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        storage.balances.add(caller, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, caller, caller));\n\n        Token::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    // docs:start:shield\n    #[aztec(public)]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n\n    // docs:start:transfer_public\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n\n    // docs:start:burn_public\n    #[aztec(public)]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:redeem_shield\n    #[aztec(private)]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let pending_shields = storage.pending_shields;\n        let secret_hash = compute_secret_hash(secret);\n        // Get 1 note (set_limit(1)) which has amount stored in field with index 0 (select(0, amount)) and secret_hash\n        // stored in field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TransparentNote::properties().amount, amount, Option::none()).select(\n            TransparentNote::properties().secret_hash,\n            secret_hash,\n            Option::none()\n        ).set_limit(1);\n        let notes = pending_shields.get_notes(options);\n        let note = notes.get_unchecked(0);\n        // Remove the note from the pending shields set\n        pending_shields.remove(note);\n\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        storage.balances.add(to, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, to));\n    }\n    // docs:end:redeem_shield\n\n    // docs:start:unshield\n    #[aztec(private)]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n\n    // docs:start:transfer\n    #[aztec(private)]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, from_ivpk));\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk));\n\n        Transfer { from, to, amount: amount.to_field() }.emit(encode_and_encrypt_event_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk));\n    }\n    // docs:end:transfer\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[aztec(private)]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier, 0);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_from\n    #[aztec(private)]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, from_ivpk));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, to_ivpk));\n    }\n    // docs:end:transfer_from\n\n    // docs:start:burn\n    #[aztec(private)]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n\n    /// Internal ///\n\n    // docs:start:increase_public_balance\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n\n    // docs:start:balance_of_private\n    unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.balance_of(owner).to_field()\n    }\n    // docs:end:balance_of_private\n}\n// docs:end:token_all"},"315":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr","source":"use dep::aztec::{\n    prelude::{AztecAddress, NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash},\n    note::utils::compute_note_hash_for_consumption, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app\n};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\nglobal TOKEN_NOTE_LEN: Field = 3; // 3 plus a header.\n// TOKEN_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TOKEN_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n#[aztec(note)]\nstruct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NoteInterface<TOKEN_NOTE_LEN, TOKEN_NOTE_BYTES_LEN> for TokenNote {\n    // docs:start:nullifier\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self {\n            amount,\n            npk_m_hash: owner_npk_m_hash,\n            randomness: unsafe_rand(),\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n"},"317":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr","source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::{note_getter_options::PropertySelector, utils::compute_note_hash_for_consumption},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash}\n};\n\nglobal TRANSPARENT_NOTE_LEN: Field = 2;\n// TRANSPARENT_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TRANSPARENT_NOTE_BYTES_LEN: Field = 2 * 32 + 64;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[aztec(note)]\nstruct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nstruct TransparentNoteProperties {\n    amount: PropertySelector,\n    secret_hash: PropertySelector,\n}\n\nimpl NoteInterface<TRANSPARENT_NOTE_LEN, TRANSPARENT_NOTE_BYTES_LEN> for TransparentNote {\n\n    // Custom serialization to avoid disclosing the secret field\n    fn serialize_content(self) -> [Field; TRANSPARENT_NOTE_LEN] {\n        [self.amount, self.secret_hash]\n    }\n\n    // Custom deserialization since we don't have access to the secret plaintext\n    fn deserialize_content(serialized_note: [Field; TRANSPARENT_NOTE_LEN]) -> Self {\n        TransparentNote {\n            amount: serialized_note[0],\n            secret_hash: serialized_note[1],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): Ensure nullifier collisions are prevented\n    fn compute_note_hash_and_nullifier(self, _context: &mut PrivateContext) -> (Field, Field) {\n        self.compute_note_hash_and_nullifier_without_context()\n    }\n\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit. \n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n\n    // CUSTOM FUNCTIONS FOR THIS NOTE TYPE\n    // Custom serialization forces us to manually create the metadata struct and its getter\n    pub fn properties() -> TransparentNoteProperties {\n        TransparentNoteProperties {\n            amount: PropertySelector { index: 0, offset: 0, length: 32 },\n            secret_hash: PropertySelector { index: 1, offset: 0, length: 32 }\n        }\n    }\n}\n// docs:end:token_types_all\n"},"32":{"path":"std/merkle.nr","source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n"},"38":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"395":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_bridge_contract/src/main.nr","source":"// docs:start:token_bridge_imports\n\n// Minimal implementation of the token bridge that can move funds between L1 <> L2.\n// The bridge has a corresponding Portal contract on L1 that it is attached to\n// And corresponds to a Token on L2 that uses the `AuthWit` accounts pattern.\n// Bridge has to be set as a minter on the token before it can be used\n\ncontract TokenBridge {\n    use dep::aztec::prelude::{FunctionSelector, AztecAddress, EthAddress, PublicMutable, SharedImmutable};\n\n    use dep::token_portal_content_hash_lib::{get_mint_public_content_hash, get_mint_private_content_hash, get_withdraw_content_hash};\n\n    use dep::token::Token;\n    // docs:end:token_bridge_imports\n\n    // docs:start:token_bridge_storage_and_constructor\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[aztec(storage)]\n    struct Storage {\n        token: PublicMutable<AztecAddress>,\n        portal_address: SharedImmutable<EthAddress>,\n    }\n\n    // Constructs the contract.\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(token: AztecAddress, portal_address: EthAddress) {\n        storage.token.write(token);\n        storage.portal_address.initialize(portal_address);\n    }\n    // docs:end:token_bridge_storage_and_constructor\n\n    #[aztec(private)]\n    fn get_portal_address() -> EthAddress {\n        storage.portal_address.read_private()\n    }\n\n    #[aztec(public)]\n    fn get_portal_address_public() -> EthAddress {\n        storage.portal_address.read_public()\n    }\n\n    // docs:start:claim_public\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount publicly\n    #[aztec(public)]\n    fn claim_public(to: AztecAddress, amount: Field, secret: Field, message_leaf_index: Field) {\n        let content_hash = get_mint_public_content_hash(to, amount);\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret,\n            storage.portal_address.read_public(),\n            message_leaf_index\n        );\n\n        // Mint tokens\n        Token::at(storage.token.read()).mint_public(to, amount).call(&mut context);\n    }\n    // docs:end:claim_public\n\n    // docs:start:exit_to_l1_public\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message publicly\n    // Requires `msg.sender` to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[aztec(public)]\n    fn exit_to_l1_public(\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_public(), content);\n\n        // Burn tokens\n        Token::at(storage.token.read()).burn_public(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    // docs:end:exit_to_l1_public\n    // docs:start:claim_private\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount in private assets\n    // User needs to call token.redeem_shield() to get the private assets\n    #[aztec(private)]\n    fn claim_private(\n        secret_hash_for_redeeming_minted_notes: Field, // secret hash used to redeem minted notes at a later time. This enables anyone to call this function and mint tokens to a user on their behalf\n        amount: Field,\n        secret_for_L1_to_L2_message_consumption: Field // secret used to consume the L1 to L2 message\n    ) {\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash = get_mint_private_content_hash(secret_hash_for_redeeming_minted_notes, amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            storage.portal_address.read_private()\n        );\n\n        // Mint tokens on L2\n        // `mint_private` on token is public. So we call an internal public function\n        // which then calls the public method on the token contract.\n        // Since the secret_hash is passed, no secret is leaked.\n        TokenBridge::at(context.this_address())._call_mint_on_token(amount, secret_hash_for_redeeming_minted_notes).enqueue(&mut context);\n    }\n    // docs:end:claim_private\n\n    // docs:start:exit_to_l1_private\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message privately\n    // Requires `msg.sender` (caller of the method) to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[aztec(private)]\n    fn exit_to_l1_private(\n        token: AztecAddress,\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_private(), content);\n\n        // docs:start:call_assert_token_is_same\n        // Assert that user provided token address is same as seen in storage.\n        TokenBridge::at(context.this_address())._assert_token_is_same(token).enqueue(&mut context);\n        // docs:end:call_assert_token_is_same\n\n        // Burn tokens\n        Token::at(token).burn(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    /// docs:end:exit_to_l1_private\n\n    // docs:start:get_token\n    #[aztec(public)]\n    #[aztec(view)]\n    fn get_token() -> AztecAddress {\n        storage.token.read()\n    }\n    // docs:end:get_token\n\n    // docs:start:call_mint_on_token\n    // This is a public call as we need to read from public storage.\n    // Also, note that user hashes their secret in private and only sends the hash in public\n    // meaning only user can `redeem_shield` at a later time with their secret.\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _call_mint_on_token(amount: Field, secret_hash: Field) {\n        Token::at(storage.token.read()).mint_private(amount, secret_hash).call(&mut context);\n    }\n    // docs:end:call_mint_on_token\n\n    // docs:start:assert_token_is_same\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _assert_token_is_same(token: AztecAddress) {\n        assert(storage.token.read().eq(token), \"Token address is not the same as seen in storage\");\n    }\n    // docs:end:assert_token_is_same\n}\n"},"396":{"path":"/usr/src/noir-projects/noir-contracts/contracts/uniswap_contract/src/main.nr","source":"// docs:start:uniswap_setup\nmod util;\n\n// Demonstrates how to use portal contracts to swap on L1 Uniswap with funds on L2\n// Has two separate flows for private and public respectively\n// Uses the token bridge contract, which tells which input token we need to talk to and handles the exit funds to L1\ncontract Uniswap {\n    use dep::aztec::prelude::{FunctionSelector, AztecAddress, EthAddress, Map, PublicMutable, SharedImmutable};\n    use dep::aztec::context::gas::GasOpts;\n\n    use dep::authwit::auth::{\n        IS_VALID_SELECTOR, assert_current_call_valid_authwit_public,\n        compute_authwit_message_hash_from_call, compute_authwit_message_hash, set_authorized\n    };\n\n    use dep::token::Token;\n    use dep::token_bridge::TokenBridge;\n    use crate::util::{compute_swap_private_content_hash, compute_swap_public_content_hash};\n\n    #[aztec(storage)]\n    struct Storage {\n        portal_address: SharedImmutable<EthAddress>,\n    }\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(portal_address: EthAddress) {\n        storage.portal_address.initialize(portal_address);\n    }\n    // docs:end:uniswap_setup\n\n    // docs:start:swap_public\n    #[aztec(public)]\n    fn swap_public(\n        sender: AztecAddress,\n        input_asset_bridge: AztecAddress,\n        input_amount: Field,\n        output_asset_bridge: AztecAddress,\n        // params for using the transfer approval\n        nonce_for_transfer_approval: Field,\n        // params for the swap\n        uniswap_fee_tier: Field,\n        minimum_output_amount: Field,\n        // params for the depositing output_asset back to Aztec\n        recipient: AztecAddress,\n        secret_hash_for_L1_to_l2_message: Field,\n        caller_on_L1: EthAddress,\n        // nonce for someone to call swap on sender's behalf\n        nonce_for_swap_approval: Field\n    ) {\n        if (!sender.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, sender);\n        }\n\n        let input_asset = TokenBridge::at(input_asset_bridge).get_token().view(&mut context);\n\n        // Transfer funds to this contract\n        Token::at(input_asset).transfer_public(\n            sender,\n            context.this_address(),\n            input_amount,\n            nonce_for_transfer_approval\n        ).call(&mut context);\n\n        // Approve bridge to burn this contract's funds and exit to L1 Uniswap Portal\n        Uniswap::at(context.this_address())._approve_bridge_and_exit_input_asset_to_L1(input_asset, input_asset_bridge, input_amount).call(&mut context);\n        // Create swap message and send to Outbox for Uniswap Portal\n        // this ensures the integrity of what the user originally intends to do on L1.\n        let input_asset_bridge_portal_address = TokenBridge::at(input_asset_bridge).get_portal_address_public().view(&mut context);\n        let output_asset_bridge_portal_address = TokenBridge::at(output_asset_bridge).get_portal_address_public().view(&mut context);\n        // ensure portal exists - else funds might be lost\n        assert(\n            !input_asset_bridge_portal_address.is_zero(), \"L1 portal address of input_asset's bridge is 0\"\n        );\n        assert(\n            !output_asset_bridge_portal_address.is_zero(), \"L1 portal address of output_asset's bridge is 0\"\n        );\n\n        let content_hash = compute_swap_public_content_hash(\n            input_asset_bridge_portal_address,\n            input_amount,\n            uniswap_fee_tier,\n            output_asset_bridge_portal_address,\n            minimum_output_amount,\n            recipient,\n            secret_hash_for_L1_to_l2_message,\n            caller_on_L1\n        );\n        context.message_portal(storage.portal_address.read_public(), content_hash);\n    }\n    // docs:end:swap_public\n\n    // docs:start:swap_private\n    #[aztec(private)]\n    fn swap_private(\n        input_asset: AztecAddress, // since private, we pass here and later assert that this is as expected by input_bridge\n        input_asset_bridge: AztecAddress,\n        input_amount: Field,\n        output_asset_bridge: AztecAddress,\n        // params for using the unshield approval\n        nonce_for_unshield_approval: Field,\n        // params for the swap\n        uniswap_fee_tier: Field,// which uniswap tier to use (eg 3000 for 0.3% fee)\n        minimum_output_amount: Field, // minimum output amount to receive (slippage protection for the swap)\n        // params for the depositing output_asset back to Aztec\n        secret_hash_for_redeeming_minted_notes: Field,// secret hash used to redeem minted notes at a later time. This enables anyone to call this function and mint tokens to a user on their behalf\n        secret_hash_for_L1_to_l2_message: Field, // for when l1 uniswap portal inserts the message to consume output assets on L2\n        caller_on_L1: EthAddress // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n    ) {\n        // Assert that user provided token address is same as expected by token bridge.\n        // we can't directly use `input_asset_bridge.token` because that is a public method and public can't return data to private\n        Uniswap::at(context.this_address())._assert_token_is_same(input_asset, input_asset_bridge).enqueue_view(&mut context);\n\n        // Transfer funds to this contract\n        Token::at(input_asset).unshield(\n            context.msg_sender(),\n            context.this_address(),\n            input_amount,\n            nonce_for_unshield_approval\n        ).call(&mut context);\n\n        // Approve bridge to burn this contract's funds and exit to L1 Uniswap Portal\n        Uniswap::at(context.this_address())._approve_bridge_and_exit_input_asset_to_L1(input_asset, input_asset_bridge, input_amount).enqueue(&mut context);\n\n        // Create swap message and send to Outbox for Uniswap Portal\n        // this ensures the integrity of what the user originally intends to do on L1.\n        let input_asset_bridge_portal_address = TokenBridge::at(input_asset_bridge).get_portal_address().view(&mut context);\n        let output_asset_bridge_portal_address = TokenBridge::at(output_asset_bridge).get_portal_address().view(&mut context);\n        // ensure portal exists - else funds might be lost\n        assert(\n            !input_asset_bridge_portal_address.is_zero(), \"L1 portal address of input_asset's bridge is 0\"\n        );\n        assert(\n            !output_asset_bridge_portal_address.is_zero(), \"L1 portal address of output_asset's bridge is 0\"\n        );\n\n        let content_hash = compute_swap_private_content_hash(\n            input_asset_bridge_portal_address,\n            input_amount,\n            uniswap_fee_tier,\n            output_asset_bridge_portal_address,\n            minimum_output_amount,\n            secret_hash_for_redeeming_minted_notes,\n            secret_hash_for_L1_to_l2_message,\n            caller_on_L1\n        );\n        context.message_portal(storage.portal_address.read_private(), content_hash);\n    }\n    // docs:end:swap_private\n\n    // docs:start:authwit_uniswap_set\n    // This helper method approves the bridge to burn this contract's funds and exits the input asset to L1\n    // Assumes contract already has funds.\n    // Assume `token` relates to `token_bridge` (ie token_bridge.token == token)\n    // Note that private can't read public return values so created an internal public that handles everything\n    // this method is used for both private and public swaps.\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _approve_bridge_and_exit_input_asset_to_L1(\n        token: AztecAddress,\n        token_bridge: AztecAddress,\n        amount: Field\n    ) {\n        // Since we will authorize and instantly spend the funds, all in public, we can use the same nonce\n        // every interaction. In practice, the authwit should be squashed, so this is also cheap!\n        let nonce = 0xdeadbeef;\n\n        let selector = FunctionSelector::from_signature(\"burn_public((Field),Field,Field)\");\n        let message_hash = compute_authwit_message_hash_from_call(\n            token_bridge,\n            token,\n            context.chain_id(),\n            context.version(),\n            selector,\n            [context.this_address().to_field(), amount, nonce]\n        );\n\n        // We need to make a call to update it.\n        set_authorized(&mut context, message_hash, true);\n\n        let this_portal_address = storage.portal_address.read_public();\n        // Exit to L1 Uniswap Portal !\n        TokenBridge::at(token_bridge).exit_to_l1_public(this_portal_address, amount, this_portal_address, nonce).call(&mut context)\n    }\n    // docs:end:authwit_uniswap_set\n\n    // docs:start:assert_token_is_same\n    #[aztec(public)]\n    #[aztec(internal)]\n    #[aztec(view)]\n    fn _assert_token_is_same(token: AztecAddress, token_bridge: AztecAddress) {\n        assert(\n            token.eq(TokenBridge::at(token_bridge).get_token().view(&mut context)), \"input_asset address is not the same as seen in the bridge contract\"\n        );\n    }\n    // docs:end:assert_token_is_same\n}\n"},"397":{"path":"/usr/src/noir-projects/noir-contracts/contracts/uniswap_contract/src/util.nr","source":"// docs:start:uniswap_public_content_hash\nuse dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\n// This method computes the L2 to L1 message content hash for the public\n// refer `l1-contracts/test/portals/UniswapPortal.sol` on how L2 to L1 message is expected\npub fn compute_swap_public_content_hash(\n    input_asset_bridge_portal_address: EthAddress,\n    input_amount: Field,\n    uniswap_fee_tier: Field,\n    output_asset_bridge_portal_address: EthAddress,\n    minimum_output_amount: Field,\n    aztec_recipient: AztecAddress,\n    secret_hash_for_L1_to_l2_message: Field,\n    caller_on_L1: EthAddress\n) -> Field {\n    let mut hash_bytes = [0; 260]; // 8 fields of 32 bytes each + 4 bytes fn selector\n\n    let input_token_portal_bytes = input_asset_bridge_portal_address.to_field().to_be_bytes(32);\n    let in_amount_bytes = input_amount.to_be_bytes(32);\n    let uniswap_fee_tier_bytes = uniswap_fee_tier.to_be_bytes(32);\n    let output_token_portal_bytes = output_asset_bridge_portal_address.to_field().to_be_bytes(32);\n    let amount_out_min_bytes = minimum_output_amount.to_be_bytes(32);\n    let aztec_recipient_bytes = aztec_recipient.to_field().to_be_bytes(32);\n    let secret_hash_for_L1_to_l2_message_bytes = secret_hash_for_L1_to_l2_message.to_be_bytes(32);\n    let caller_on_L1_bytes = caller_on_L1.to_field().to_be_bytes(32);\n\n    // function selector: 0xf18186d8 keccak256(\"swap_public(address,uint256,uint24,address,uint256,bytes32,bytes32,address)\")\n    hash_bytes[0] = 0xf1;\n    hash_bytes[1] = 0x81;\n    hash_bytes[2] = 0x86;\n    hash_bytes[3] = 0xd8;\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = input_token_portal_bytes[i];\n        hash_bytes[i + 36] = in_amount_bytes[i];\n        hash_bytes[i + 68] = uniswap_fee_tier_bytes[i];\n        hash_bytes[i + 100] = output_token_portal_bytes[i];\n        hash_bytes[i + 132] = amount_out_min_bytes[i];\n        hash_bytes[i + 164] = aztec_recipient_bytes[i];\n        hash_bytes[i + 196] = secret_hash_for_L1_to_l2_message_bytes[i];\n        hash_bytes[i + 228] = caller_on_L1_bytes[i];\n    }\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:uniswap_public_content_hash\n\n// docs:start:compute_swap_private_content_hash\n// This method computes the L2 to L1 message content hash for the private\n// refer `l1-contracts/test/portals/UniswapPortal.sol` on how L2 to L1 message is expected\npub fn compute_swap_private_content_hash(\n    input_asset_bridge_portal_address: EthAddress,\n    input_amount: Field,\n    uniswap_fee_tier: Field,\n    output_asset_bridge_portal_address: EthAddress,\n    minimum_output_amount: Field,\n    secret_hash_for_redeeming_minted_notes: Field,\n    secret_hash_for_L1_to_l2_message: Field,\n    caller_on_L1: EthAddress\n) -> Field {\n    let mut hash_bytes = [0; 260]; // 8 fields of 32 bytes each + 4 bytes fn selector\n\n    let input_token_portal_bytes = input_asset_bridge_portal_address.to_field().to_be_bytes(32);\n    let in_amount_bytes = input_amount.to_be_bytes(32);\n    let uniswap_fee_tier_bytes = uniswap_fee_tier.to_be_bytes(32);\n    let output_token_portal_bytes = output_asset_bridge_portal_address.to_field().to_be_bytes(32);\n    let amount_out_min_bytes = minimum_output_amount.to_be_bytes(32);\n    let secret_hash_for_redeeming_minted_notes_bytes = secret_hash_for_redeeming_minted_notes.to_be_bytes(32);\n    let secret_hash_for_L1_to_l2_message_bytes = secret_hash_for_L1_to_l2_message.to_be_bytes(32);\n    let caller_on_L1_bytes = caller_on_L1.to_field().to_be_bytes(32);\n\n    // function selector: 0x16f416eb keccak256(\"swap_private(address,uint256,uint24,address,uint256,bytes32,bytes32,address)\")\n    hash_bytes[0] = 0x16;\n    hash_bytes[1] = 0xf4;\n    hash_bytes[2] = 0x16;\n    hash_bytes[3] = 0xeb;\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = input_token_portal_bytes[i];\n        hash_bytes[i + 36] = in_amount_bytes[i];\n        hash_bytes[i + 68] = uniswap_fee_tier_bytes[i];\n        hash_bytes[i + 100] = output_token_portal_bytes[i];\n        hash_bytes[i + 132] = amount_out_min_bytes[i];\n        hash_bytes[i + 164] = secret_hash_for_redeeming_minted_notes_bytes[i];\n        hash_bytes[i + 196] = secret_hash_for_L1_to_l2_message_bytes[i];\n        hash_bytes[i + 228] = caller_on_L1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:compute_swap_private_content_hash\n"},"44":{"path":"std/slice.nr","source":"use crate::append::Append;\n\nimpl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::unsafe::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"},"47":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"54":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n    GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER, GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    CANONICAL_AUTH_REGISTRY_ADDRESS\n},\n    hash::pedersen_hash\n};\nuse dep::aztec::{prelude::Deserialize, context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties \n * (e.g. protocols or other users) to execute an action on their behalf.\n * \n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be \n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few \n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can \n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be \n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n * \n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer. \n * \n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is \n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n * \n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline \n * how this would look in private, and then in public later. \n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX). \n * `Alice` would make a `deposit` transaction, that she is executing using her account contract. \n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token` \n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to \n * convince the `Token` contract that it is allowed to do so. \n * \n * This is where the authentication witness comes in! The `Token` contract computes a `message_hash` from the \n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to \n * execute that call.\n * \n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her \n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n * \n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n * \n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts. \n * \n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *  \n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store \n * the messages that we have approved. \n * \n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `keccak256(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a colission and we return \n *      a success flag.\n * \n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be \n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the \n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n * \n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains. \n */\n\nglobal IS_VALID_SELECTOR = 0xabf64ad4; // 4 first bytes of keccak256(\"IS_VALID()\")\n\n/** \n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n * \n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([context.msg_sender().to_field(), context.selector().to_field(), context.args_hash]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/** \n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n * \n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n * \n * @param on_behalf_of The address that have authorized the current call\n * @param inner_hash The hash of the message to authorize  \n */\npub fn assert_inner_hash_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context.static_call_private_function(\n        on_behalf_of,\n        FunctionSelector::from_signature(\"verify_private_authwit(Field)\"),\n        [inner_hash]\n    ).unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier, 0);\n}\n\n/** \n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n * \n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n * \n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub fn assert_current_call_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash(\n        [(*context).msg_sender().to_field(), (*context).selector().to_field(), (*context).get_args_hash()]\n    );\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/** \n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n * \n * @param on_behalf_of The address that have authorized the the `inner_hash`\n */\npub fn assert_inner_hash_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    let result: Field = context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"consume((Field),Field)\"),\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default()\n    ).deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness \n * \n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n * \n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<N>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N]\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash = compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n * \n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n * \n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<N>(args: [Field; N]) -> Field {\n    pedersen_hash(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/** \n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n * \n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n * \n * @param on_behalf_of The address that have authorized the the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    pedersen_hash(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n * \n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(consumer: AztecAddress, chain_id: Field, version: Field, inner_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        consumer.to_field(),\n        chain_id,\n        version,\n        inner_hash\n    ],\n        GENERATOR_INDEX__AUTHWIT_OUTER\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n * \n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n * \n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"set_authorized(Field,bool)\"),\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n * \n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise \n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"set_reject_all(bool)\"),\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n"},"65":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::PrivateContext,\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}},\n    state_vars::{shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter}\n};\n\nglobal DELAY = 5;\n\n// docs:start:key-getters\ntrait KeyGetters {\n  fn get_npk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ivpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ovpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_tpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_npk_m_hash(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Field;\n}\n\nimpl KeyGetters for Header {\n    fn get_npk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, NULLIFIER_INDEX, self)\n    }\n\n    fn get_ivpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, INCOMING_INDEX, self)\n    }\n\n    fn get_ovpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, OUTGOING_INDEX, self)\n    }\n\n    fn get_tpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, TAGGING_INDEX, self)\n    }\n\n    fn get_npk_m_hash(self, context: &mut PrivateContext, address: AztecAddress) -> Field {\n        get_master_key(context, address, NULLIFIER_INDEX, self).hash()\n    }\n}\n// docs:end:key-getters\n\nfn get_master_key(\n    context: &mut PrivateContext,\n    address: AztecAddress,\n    key_index: Field,\n    header: Header\n) -> Point {\n    let key = fetch_key_from_registry(context, key_index, address, header);\n    if is_empty(key) {\n        // Keys were not registered in registry yet --> fetch key from PXE\n        let keys = fetch_and_constrain_keys(address);\n        // Return the corresponding to index\n        keys.get_key_by_index(key_index)\n    } else {\n        // Keys were registered --> return the key\n        key\n    }\n}\n\nfn fetch_key_from_registry(\n    context: &mut PrivateContext,\n    key_index: Field,\n    address: AztecAddress,\n    header: Header\n) -> Point {\n    let x_coordinate_map_slot = key_index * 2 + 1;\n    let y_coordinate_map_slot = x_coordinate_map_slot + 1;\n    let x_coordinate_derived_slot = derive_storage_slot_in_map(x_coordinate_map_slot, address);\n    let y_coordinate_derived_slot = derive_storage_slot_in_map(y_coordinate_map_slot, address);\n\n    let x_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        x_coordinate_derived_slot\n    );\n    let y_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        y_coordinate_derived_slot\n    );\n    let x_coordinate = x_coordinate_registry.get_value_in_private(header);\n    let y_coordinate = y_coordinate_registry.get_value_in_private(header);\n\n    Point::new(x_coordinate, y_coordinate, false)\n}\n\n// Passes only when keys were not rotated - is expected to be called only when keys were not registered yet\nfn fetch_and_constrain_keys(address: AztecAddress) -> PublicKeys {\n    let (public_keys, partial_address) = get_public_keys_and_partial_address(address);\n\n    let computed_address = AztecAddress::compute(public_keys.hash(), partial_address);\n\n    assert(computed_address.eq(address));\n\n    public_keys\n}\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n"},"80":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n"},"81":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr","source":"use std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext, oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: Header, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for Header {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier);\n\n        // 2) Check that the witness we obtained matches the nullifier\n        assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n        // 3) Compute the nullifier tree leaf\n        let nullifier_leaf = witness.leaf_preimage.hash();\n\n        // 4) Prove that the nullifier is in the nullifier tree\n        assert(\n            self.state.partial.nullifier_tree.root\n            == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n        );\n        // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n        //     was included in the nullifier tree.\n    }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, N, M>(header: Header, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M>;\n}\n\nimpl ProveNoteIsNullified for Header {\n    // docs:start:prove_note_is_nullified\n    fn prove_note_is_nullified<Note, N, M>(self, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M> {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n    // docs:end:prove_note_is_nullified\n}\n"},"89":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<N>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, N>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<N, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<N, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"95":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn block_number(self) -> Field {\n        block_number()\n    }\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<N>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<N>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, N>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N)\n}\n\nunconstrained fn storage_write<N>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<N>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<N>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}