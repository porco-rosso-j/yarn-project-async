{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"Counter","functions":[{"name":"initialize","is_unconstrained":false,"custom_attributes":["aztec(private)","aztec(initializer)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"headstart","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"outgoing_viewer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"increment","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"outgoing_viewer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"get_counter","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"counters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"headstart","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"outgoing_viewer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Counter::initialize_parameters"}}],"kind":"struct","path":"Counter::initialize_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"outgoing_viewer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Counter::increment_parameters"}}],"kind":"struct","path":"Counter::increment_abi"}]}},"file_map":{"102":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::{Point, pub_key_to_bytes},\n    constants::{GENERATOR_INDEX__IVSK_M, GENERATOR_INDEX__OVSK_M}, hash::poseidon2_hash\n};\n\nuse std::field::bytes32_to_field;\n\nuse crate::oracle::unsafe_rand::unsafe_rand;\n\nuse crate::event::event_interface::EventInterface;\nuse crate::note::note_interface::NoteInterface;\n\nuse crate::encrypted_logs::{\n    header::EncryptedLogHeader, incoming_body::EncryptedLogIncomingBody,\n    outgoing_body::EncryptedLogOutgoingBody\n};\n\npub fn compute_encrypted_event_log<Event, NB, MB, OB>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    event: Event\n) -> [u8; OB] where Event: EventInterface<NB, MB> {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    let eph_sk: Scalar = fr_to_fq(unsafe_rand());\n    let eph_pk = eph_sk.derive_public_key();\n\n    // TODO: (#7177) This value needs to be populated!\n    let recipient = AztecAddress::from_field(0);\n\n    let ivpk_app = compute_ivpk_app(ivpk, contract_address);\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_Header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_event(event, randomness).compute_ciphertext(eph_sk, ivpk_app);\n    let outgoing_body_ciphertext: [u8; 176] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk_app).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; OB] = [0; OB];\n    // @todo We ignore the tags for now \n\n    let eph_pk_bytes = pub_key_to_bytes(eph_pk);\n    for i in 0..64 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[128 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[176 + i] = outgoing_Header_ciphertext[i];\n    }\n    for i in 0..176 {\n        encrypted_bytes[224 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = OB - 400;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[400 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (64 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (176 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\npub fn compute_encrypted_note_log<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> [u8; M] where Note: NoteInterface<N, NB> {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    let eph_sk: Scalar = fr_to_fq(unsafe_rand());\n    let eph_pk = eph_sk.derive_public_key();\n\n    // TODO: (#7177) This value needs to be populated!\n    let recipient = AztecAddress::from_field(0);\n\n    let ivpk_app = compute_ivpk_app(ivpk, contract_address);\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_Header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_note(note, storage_slot).compute_ciphertext(eph_sk, ivpk_app);\n    let outgoing_body_ciphertext: [u8; 176] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk_app).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now \n\n    let eph_pk_bytes = pub_key_to_bytes(eph_pk);\n    for i in 0..64 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[128 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[176 + i] = outgoing_Header_ciphertext[i];\n    }\n    for i in 0..176 {\n        encrypted_bytes[224 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 400;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[400 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (64 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (176 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field elememt to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let r_bytes = r.to_be_bytes(32);\n\n    let mut high_bytes = [0; 32];\n    let mut low_bytes = [0; 32];\n\n    for i in 0..16 {\n        high_bytes[16 + i] = r_bytes[i];\n        low_bytes[16 + i] = r_bytes[i + 16];\n    }\n\n    let low = bytes32_to_field(low_bytes);\n    let high = bytes32_to_field(high_bytes);\n\n    Scalar::new(low, high)\n}\n\nfn compute_ivpk_app(ivpk: Point, contract_address: AztecAddress) -> Point {\n    // It is useless to compute this, it brings no value to derive fully.\n    // Issue(#6955)\n    ivpk\n    /*\n    // @todo Just setting infinite to false, but it should be checked.\n    // for example user could define ivpk = infinity using the registry\n    assert((ivpk.x != 0) & (ivpk.y != 0), \"ivpk is infinite\");\n\n    let i = fr_to_fq(poseidon2_hash([contract_address.to_field(), ivpk.x, ivpk.y, GENERATOR_INDEX__IVSK_M]));\n    let I = i.derive_public_key();\n\n    let embed_I = Point { x: I.x, y: I.y, is_infinite: false };\n    let embed_ivpk = Point { x: ivpk.x, y: ivpk.y, is_infinite: false };\n\n    let embed_result = embedded_curve_add(embed_I, embed_ivpk);\n\n    Point::new(embed_result.x, embed_result.y)*/\n}\n"},"103":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    encrypted_logs::payload::compute_encrypted_note_log, oracle::logs_traits::LensForEncryptedLog\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field, address::AztecAddress, point::Point, abis::note_hash::NoteHash,\n    constants::MAX_NOTE_HASHES_PER_CALL, utils::arrays::find_index\n};\n\nunconstrained fn compute_unconstrained<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    compute(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note)\n}\n\nfn compute<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let encrypted_log: [u8; M] = compute_encrypted_note_log(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note);\n    let log_hash = sha256_to_field(encrypted_log);\n    (encrypted_log, log_hash)\n}\n\nfn emit_with_keys<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    note: Note,\n    ovpk: Point,\n    ivpk: Point,\n    inner_compute: fn(AztecAddress, Field, Field, Point, Point, Note) -> ([u8; M], Field)\n) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    let note_exists_index = find_index(\n        context.note_hashes.storage,\n        |n: NoteHash| n.counter == note_hash_counter\n    );\n    assert(\n        note_exists_index as u32 != MAX_NOTE_HASHES_PER_CALL, \"Can only emit a note log for an existing note.\"\n    );\n\n    let contract_address: AztecAddress = context.this_address();\n    let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n    let (encrypted_log, log_hash) = inner_compute(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n\npub fn encode_and_encrypt_note<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let header = context.get_header();\n        let ovpk = header.get_ovpk_m(context, ov);\n        let ivpk = header.get_ivpk_m(context, iv);\n        emit_with_keys(context, e.note, ovpk, ivpk, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let header = context.get_header();\n        let ovpk = header.get_ovpk_m(context, ov);\n        let ivpk = header.get_ivpk_m(context, iv);\n        emit_with_keys(context, e.note, ovpk, ivpk, compute_unconstrained);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ovpk: Point,\n    ivpk: Point\n) -> fn[(&mut PrivateContext, Point, Point)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys_unconstrained<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ovpk: Point,\n    ivpk: Point\n) -> fn[(&mut PrivateContext, Point, Point)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, compute_unconstrained);\n    }\n}\n"},"104":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/outgoing_body.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash\n};\n\nuse std::aes128::aes128_encrypt;\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nstruct EncryptedLogOutgoingBody {\n    eph_sk: Scalar,\n    recipient: AztecAddress,\n    recipient_ivpk_app: Point,\n}\n\nimpl EncryptedLogOutgoingBody {\n    pub fn new(eph_sk: Scalar, recipient: AztecAddress, recipient_ivpk_app: Point) -> Self {\n        Self { eph_sk, recipient, recipient_ivpk_app }\n    }\n\n    pub fn compute_ciphertext(self, ovsk_app: Scalar, eph_pk: Point) -> [u8; 176] {\n        // Again, we could compute `eph_pk` here, but we keep the interface more similar\n        // and also make it easier to optimise it later as we just pass it along\n\n        let mut buffer: [u8; 160] = [0; 160];\n\n        let serialized_eph_sk_high = self.eph_sk.hi.to_be_bytes(32);\n        let serialized_eph_sk_low = self.eph_sk.lo.to_be_bytes(32);\n\n        let address_bytes = self.recipient.to_field().to_be_bytes(32);\n        let serialized_recipient_ivpk_app = self.recipient_ivpk_app.serialize();\n        let serialized_recipient_ivpk_app_x = serialized_recipient_ivpk_app[0].to_be_bytes(32);\n        let serialized_recipient_ivpk_app_y = serialized_recipient_ivpk_app[1].to_be_bytes(32);\n\n        for i in 0..32 {\n            buffer[i] = serialized_eph_sk_high[i];\n            buffer[i + 32] = serialized_eph_sk_low[i];\n            buffer[i + 64] = address_bytes[i];\n            buffer[i + 96] = serialized_recipient_ivpk_app_x[i];\n            buffer[i + 128] = serialized_recipient_ivpk_app_y[i];\n        }\n\n        // We compute the symmetric key using poseidon.\n        let full_key: [u8; 32] = poseidon2_hash(\n            [\n            ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y,\n            GENERATOR_INDEX__SYMMETRIC_KEY as Field\n        ]\n        ).to_be_bytes(32).as_array();\n\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(buffer, iv, sym_key).as_array()\n    }\n}\n\nmod test {\n    use crate::encrypted_logs::outgoing_body::EncryptedLogOutgoingBody;\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, hash::poseidon2_hash\n    };\n\n    use crate::context::PrivateContext;\n\n    #[test]\n    fn test_encrypted_log_outgoing_body() {\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        );\n        let recipient_ivsk_app = Scalar::new(\n            0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        );\n        let sender_ovsk_app = Scalar::new(\n            0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        );\n\n        let eph_pk = eph_sk.derive_public_key();\n        let recipient_ivpk_app = recipient_ivsk_app.derive_public_key();\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let body = EncryptedLogOutgoingBody::new(eph_sk, recipient, recipient_ivpk_app);\n\n        let ciphertext = body.compute_ciphertext(sender_ovsk_app, eph_pk);\n\n        let expected_outgoing_body_ciphertext = [\n            127, 84, 96, 176, 101, 107, 236, 57, 68, 8, 53, 202, 138, 74, 186, 54, 74, 193, 245, 7, 109, 59, 218, 33, 1, 31, 205, 225, 241, 209, 64, 222, 94, 245, 4, 150, 47, 241, 187, 64, 152, 20, 102, 158, 200, 217, 213, 82, 1, 240, 170, 185, 51, 80, 27, 109, 63, 231, 235, 120, 174, 44, 133, 248, 10, 97, 60, 40, 222, 190, 147, 76, 187, 48, 91, 206, 48, 106, 56, 118, 38, 127, 82, 4, 182, 188, 44, 224, 31, 129, 47, 107, 134, 252, 20, 25, 122, 191, 158, 69, 35, 255, 215, 171, 196, 45, 91, 184, 83, 80, 238, 201, 1, 233, 235, 159, 171, 130, 158, 64, 176, 165, 132, 30, 84, 81, 71, 195, 145, 47, 82, 247, 210, 192, 23, 4, 220, 90, 56, 109, 46, 105, 79, 251, 165, 141, 185, 233, 191, 118, 219, 153, 191, 162, 99, 238, 241, 249, 9, 74, 210, 241, 54, 28, 126, 226, 85, 235, 174, 75, 239, 207, 100, 184, 248, 194\n        ];\n\n        for i in 0..expected_outgoing_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_outgoing_body_ciphertext[i]);\n        }\n        assert_eq(expected_outgoing_body_ciphertext.len(), ciphertext.len());\n    }\n}\n"},"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\nstruct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext(self, secret: Scalar, point: Point) -> [u8; 48] {\n        let full_key = point_to_symmetric_key(secret, point);\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes(32).as_array();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nfn test_encrypted_log_header() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar::new(\n        0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    );\n    let point = Point::new(\n        0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        false\n    );\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    let expected_header_ciphertext = [\n        228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 23, 131, 32, 226, 26, 176, 43, 39, 239, 177, 177, 192, 85, 216, 17, 15, 18, 187, 35, 225, 135, 192, 63, 88, 29, 173, 232, 46, 72, 82, 187, 139\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext);\n}\n"},"106":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/incoming_body.nr","source":"use crate::note::note_interface::NoteInterface;\nuse crate::event::event_interface::EventInterface;\nuse dep::protocol_types::{scalar::Scalar, point::Point};\n\nuse std::aes128::aes128_encrypt;\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nstruct EncryptedLogIncomingBody<M> {\n    plaintext: [u8; M]\n}\n\nimpl<M> EncryptedLogIncomingBody<M> {\n    pub fn from_note<T, N>(note: T, storage_slot: Field) -> Self where T: NoteInterface<N, M> {\n        let mut plaintext = note.to_be_bytes(storage_slot);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn from_event<T, MR>(event: T, randomness: Field) -> Self where T: EventInterface<M, MR> {\n        let mut plaintext = event.private_to_be_bytes(randomness);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn compute_ciphertext(self, eph_sk: Scalar, ivpk_app: Point) -> [u8] {\n        let full_key = point_to_symmetric_key(eph_sk, ivpk_app);\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(self.plaintext, iv, sym_key)\n    }\n}\n\nmod test {\n    use crate::encrypted_logs::incoming_body::EncryptedLogIncomingBody;\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, traits::Serialize, abis::event_selector::EventSelector\n    };\n\n    use crate::{\n        note::{note_header::NoteHeader, note_interface::NoteInterface},\n        event::event_interface::EventInterface, oracle::unsafe_rand::unsafe_rand,\n        context::PrivateContext\n    };\n\n    struct AddressNote {\n        address: AztecAddress,\n        owner: AztecAddress,\n        randomness: Field,\n        header: NoteHeader,\n    }\n\n    global ADDRESS_NOTE_LEN: Field = 3;\n    global ADDRESS_NOTE_BYTES_LEN = 32 * 3 + 64;\n\n    impl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n        fn compute_note_content_hash(self) -> Field {1}\n\n        fn get_note_type_id() -> Field {\n            1\n        }\n\n        fn get_header(self) -> NoteHeader { self.header}\n\n        fn set_header(&mut self, header: NoteHeader) {self.header = header; }\n\n        fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n            (1, 1)\n        }\n\n        fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {(1,1)}\n\n        fn serialize_content(self) -> [Field; ADDRESS_NOTE_LEN] { [self.address.to_field(), self.owner.to_field(), self.randomness]}\n\n        fn deserialize_content(fields: [Field; ADDRESS_NOTE_LEN]) -> Self {\n            AddressNote { address: AztecAddress::from_field(fields[0]), owner: AztecAddress::from_field(fields[1]), randomness: fields[2], header: NoteHeader::empty() }\n        }\n\n        fn to_be_bytes(self, storage_slot: Field) -> [u8; ADDRESS_NOTE_BYTES_LEN] {\n            let serialized_note = self.serialize_content();\n\n            let mut buffer: [u8; ADDRESS_NOTE_BYTES_LEN] = [0; ADDRESS_NOTE_BYTES_LEN];\n\n            let storage_slot_bytes = storage_slot.to_be_bytes(32);\n            let note_type_id_bytes = AddressNote::get_note_type_id().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = storage_slot_bytes[i];\n                buffer[32 + i] = note_type_id_bytes[i];\n            }\n\n            for i in 0..serialized_note.len() {\n                let bytes = serialized_note[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n            buffer\n        }\n    }\n\n    impl AddressNote {\n        pub fn new(address: AztecAddress, owner: AztecAddress, randomness: Field) -> Self {\n            AddressNote { address, owner, randomness, header: NoteHeader::empty() }\n        }\n    }\n\n    #[test]\n    fn test_encrypted_note_log_incoming_body() {\n        let note = AddressNote::new(\n            AztecAddress::from_field(0x1),\n            AztecAddress::from_field(0x2),\n            3\n        );\n\n        let storage_slot = 2;\n\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        );\n        let ivpk_app = Point::new(\n            0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            false\n        );\n\n        let body = EncryptedLogIncomingBody::from_note(note, storage_slot);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk_app);\n\n        let expected_note_body_ciphertext = [\n            228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 63, 127, 188, 251, 150, 188, 238, 205, 3, 86, 102, 164, 175, 12, 137, 158, 163, 111, 205, 10, 229, 230, 46, 202, 110, 107, 156, 180, 67, 192, 161, 201, 48, 153, 169, 1, 25, 182, 93, 39, 39, 207, 251, 218, 234, 147, 156, 13, 110, 180, 190, 199, 41, 6, 211, 203, 176, 110, 165, 186, 110, 127, 199, 22, 201, 149, 92, 249, 219, 68, 145, 68, 179, 29, 233, 34, 98, 123, 197, 234, 169, 53, 44, 14, 81, 60, 92, 27, 250, 134, 49, 248, 57, 119, 236, 118, 158, 104, 82, 243, 98, 164, 60, 72, 74, 27, 177, 194, 221, 225, 193, 150, 67, 235, 205, 106, 150, 24, 126, 186, 220, 178, 199, 189, 113, 54, 181, 55, 46, 15, 236, 236, 9, 159, 5, 172, 237, 154, 110, 50, 241, 64, 92, 13, 37, 53, 20, 140, 42, 146, 229, 63, 97, 25, 159, 63, 235, 104, 68, 100\n        ];\n\n        assert_eq(expected_note_body_ciphertext.len(), ciphertext.len());\n\n        for i in 0..expected_note_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_note_body_ciphertext[i]);\n        }\n    }\n\n    struct TestEvent {\n        value0: Field,\n        value1: Field,\n        value2: Field,\n    }\n\n    impl Serialize<3> for TestEvent {\n        fn serialize(self) -> [Field; 3] {\n            [self.value0, self.value1, self.value2]\n        }\n    }\n\n    global TEST_EVENT_LEN: Field = 3;\n    global TEST_EVENT_BYTES_LEN = 32 * 3 + 64;\n    global TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS = 32 * 3 + 32;\n\n    impl EventInterface<TEST_EVENT_BYTES_LEN, TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS> for TestEvent {\n        fn get_event_type_id() -> EventSelector {\n            EventSelector::from_signature(\"TestEvent(Field,Field,Field)\")\n        }\n\n        fn private_to_be_bytes(self, randomness: Field) -> [u8; TEST_EVENT_BYTES_LEN] {\n            let mut buffer: [u8; TEST_EVENT_BYTES_LEN] = [0; TEST_EVENT_BYTES_LEN];\n\n            let randomness_bytes = randomness.to_be_bytes(32);\n            let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = randomness_bytes[i];\n                buffer[32 + i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes = serialized_event[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn to_be_bytes(self) -> [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] {\n             let mut buffer: [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] = [0; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS];\n\n             let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n             for i in 0..32 {\n                 buffer[i] = event_type_id_bytes[i];\n            }\n\n             let serialized_event = self.serialize();\n\n             for i in 0..serialized_event.len() {\n                 let bytes = serialized_event[i].to_be_bytes(32);\n                 for j in 0..32 {\n                     buffer[32 + i * 32 + j] = bytes[j];\n                }\n            }\n\n             buffer\n        }\n\n        fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n            _emit(self);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_event_incoming_body() {\n        let test_event = TestEvent { value0: 1, value1: 2, value2: 3 };\n\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        );\n\n        let ivpk_app = Point::new(\n            0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            false\n        );\n\n        let randomness = 2;\n\n        let body = EncryptedLogIncomingBody::from_event(test_event, randomness);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk_app);\n\n        let expected_event_body_ciphertext = [\n            228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 63, 127, 188, 251, 150, 188, 238, 205, 3, 86, 102, 164, 175, 12, 137, 158, 163, 111, 205, 10, 229, 230, 46, 202, 110, 107, 156, 180, 67, 192, 161, 201, 66, 122, 29, 35, 42, 33, 153, 216, 199, 208, 103, 207, 126, 153, 189, 136, 19, 220, 238, 15, 169, 29, 255, 11, 123, 107, 70, 192, 53, 40, 36, 93, 187, 32, 123, 136, 104, 23, 229, 245, 152, 90, 84, 2, 136, 112, 42, 27, 82, 214, 104, 14, 250, 48, 199, 245, 88, 22, 200, 77, 38, 51, 127, 56, 138, 255, 16, 46, 179, 129, 215, 185, 185, 116, 148, 16, 133, 62, 56, 180, 10, 132, 109, 77, 206, 199, 21, 167, 7, 163, 171, 158, 244, 23, 18, 121, 108, 42, 107, 7, 48, 84, 212, 104, 39, 16, 109, 7, 108, 129, 60, 80, 112, 241, 223, 140, 186, 158, 38, 74, 230, 213, 159, 175, 142, 228, 128, 160\n        ];\n\n        assert_eq(expected_event_body_ciphertext.len(), ciphertext.len());\n\n        for i in 0..expected_event_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_event_body_ciphertext[i]);\n        }\n    }\n}\n"},"110":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr","source":"use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus, PropertySelector},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\n\nmod test;\n\nfn extract_property_value_from_selector<N>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note. \n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value = serialized_note[selector.index].to_be_bytes(32);\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, N, M>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<N>(serialized_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let is_equal = value_field == select.value.to_field();\n        let is_lt = value_field.lt(select.value.to_field());\n\n        if (select.comparator == Comparator.EQ) {\n            assert(is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(is_lt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(is_lt | is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!is_lt & !is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!is_lt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N, M> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    context.push_note_hash_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, M, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> where Note: NoteInterface<N, M> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nfn constrain_get_notes_internal<Note, N, M, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> where Note: NoteInterface<N, M> {\n    let mut returned_notes = BoundedVec::new();\n\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        let opt_note = filtered_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n\n            // The below code is used to collapse a sparse array into one where the values are guaranteed to be at the \n            // front of the array. This is highly useful because the caller knows that the returned array won't have\n            // more than option.limits notes, and can therefore loop over this limit value instead of the entire array,\n            // resulting in a smaller circuit and faster proving times.\n            // We write at returned_notes[num_notes] because num_notes is only advanced when we have a value in \n            // filtered_notes.\n            returned_notes.push(note);\n        };\n    }\n\n    // As long as we only loop till `options.limit` the array will be guaranteed to be at most of length `options.limit`.\n    assert(returned_notes.len() <= options.limit, \"Got more notes than limit.\");\n    // We will however check that nothing else was returned after the limit.\n    for i in options.limit..filtered_notes.len() {\n        assert(filtered_notes[i].is_none(), \"Got more notes than limit.\");\n    }\n\n    assert(returned_notes.len() != 0, \"Cannot return zero notes\");\n\n    returned_notes\n}\n\nunconstrained fn get_note_internal<Note, N, M>(storage_slot: Field) -> Note where Note: NoteInterface<N, M> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, M, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N, M> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained pub fn view_notes<Note, N, M>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N, M>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N, M> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n"},"112":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__INNER_NOTE_HASH,\n    hash::{\n    pedersen_hash, compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_inner_note_hash_from_preimage(storage_slot: Field, note_content_hash: Field) -> Field {\n    pedersen_hash(\n        [storage_slot, note_content_hash],\n        GENERATOR_INDEX__INNER_NOTE_HASH\n    )\n}\n\nfn compute_inner_note_hash<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    compute_inner_note_hash_from_preimage(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N, M>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let (_, inner_nullifier) = note_with_header.compute_note_hash_and_nullifier(context);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\nfn compute_note_hash_for_read_request_from_innter_and_nonce(\n    inner_note_hash: Field,\n    nonce: Field\n) -> Field {\n    // TODO(#1386): This if-else can be nuked once we have nonces injected from public\n    if (nonce == 0) {\n        // If nonce is zero, that means we are reading a public note.\n        inner_note_hash\n    } else {\n        compute_unique_note_hash(nonce, inner_note_hash)\n    }\n}\n\npub fn compute_note_hash_for_read_request<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let inner_note_hash = compute_inner_note_hash(note);\n    let nonce = note.get_header().nonce;\n\n    compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, nonce)\n}\n\npub fn compute_note_hash_for_consumption<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    if (header.note_hash_counter != 0) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        inner_note_hash\n    } else {\n        // If a note is not transient, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the siloed_note_hash which has already been hashed with\n        // nonce and then contract address. This hash will match the existing leaf in the note hash\n        // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, header.nonce);\n        compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, N, M, S>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n    let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, note_header.nonce);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        let (_, nullifier) = note.compute_note_hash_and_nullifier_without_context();\n        nullifier\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [inner_note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"113":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_inner_note_hash, compute_note_hash_for_consumption}, note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let inner_note_hash = compute_inner_note_hash(*note);\n\n    let serialized_note = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash,\n        note_hash_counter\n    )\n        == 0\n    );\n\n    context.push_note_hash(inner_note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, N, M>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let inner_note_hash = compute_inner_note_hash(*note);\n\n    context.push_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let (note_hash, nullifier) = note.compute_note_hash_and_nullifier(context);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let note_hash_for_consumption = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a non-transient note and we don't populate the note_hash with real\n        // value (if we did so the `notifyNullifiedNote` oracle would throw).\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a transient note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can find it and squash both\n        // the note and the nullifier.\n        note_hash\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    assert(notify_nullified_note(nullifier, note_hash_for_consumption, nullifier_counter) == 0);\n\n    context.push_nullifier(nullifier, note_hash_for_consumption)\n}\n"},"114":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\nstruct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting  \n * a change note in a token's transfer function only when there is \"change\" left).\n */\nstruct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(self) {}\n}\n"},"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"122":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::{compute_siloed_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_contract_initialization_nullifier(context.this_address());\n    let header = context.get_header();\n    header.prove_nullifier_inclusion(init_nullifier);\n}\n\nfn compute_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    compute_siloed_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(address)\n    )\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"123":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr","source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"},"124":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::{address::AztecAddress, point::Point};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<M>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<M>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<M>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32\n) {}\n\nunconstrained pub fn emit_encrypted_event_log<M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<N, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<N, M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\n}\n"},"128":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n"},"132":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<N>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field\n) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number as Field, N)\n}\n\nunconstrained pub fn storage_read<T, N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"133":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/unsafe_rand.nr","source":"#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n\n// Called `unsafe_rand` because we do not constrain in circuit that we are dealing with an actual random value.\n// Instead we just trust our PXE.\nunconstrained pub fn unsafe_rand() -> Field {\n    rand_oracle()\n}\n"},"136":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use crate::keys::PublicKeys;\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained fn get_public_keys_and_partial_address_oracle_wrapper(address: AztecAddress) -> [Field; 13] {\n    get_public_keys_and_partial_address_oracle(address)\n}\n\nfn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle_wrapper(address);\n\n    let keys = PublicKeys {\n        npk_m: Point::new(result[0], result[1], result[2] as bool),\n        ivpk_m: Point::new(result[3], result[4], result[5] as bool),\n        ovpk_m: Point::new(result[6], result[7], result[8] as bool),\n        tpk_m: Point::new(result[9], result[10], result[11] as bool)\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"138":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        inner_note_hash,\n        counter\n    )\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field, _counter: u32) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(\n    nullifier: Field,\n    inner_note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash, counter)\n}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, NB, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N, NB> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n// Only ever use this in private!\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n// Only ever use this in private!\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n"},"139":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"144":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{hash::pedersen_hash, storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"153":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr","source":"use dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE, lifecycle::{create_note, create_note_hash_from_public, destroy_note},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader, note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note> PrivateSet<Note, &mut PublicContext> {\n    // docs:start:insert_from_public\n    pub fn insert_from_public<N, M>(self, note: &mut Note) where Note: NoteInterface<N, M> {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note> PrivateSet<Note, &mut PrivateContext> {\n    // docs:start:insert\n    pub fn insert<N, M>(self, note: &mut Note) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    // docs:start:remove\n    pub fn remove<N, M>(self, note: Note) where Note: NoteInterface<N, M> {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read = self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note(self.context, note);\n    }\n    // docs:end:remove\n\n    // docs:start:get_notes\n    pub fn get_notes<N, M, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> where Note: NoteInterface<N, M> {\n        get_notes(self.context, self.storage_slot, options)\n    }\n    // docs:end:get_notes\n}\n\nimpl<Note> PrivateSet<Note, UnconstrainedContext> {\n    // docs:start:view_notes\n    unconstrained pub fn view_notes<N, M>(\n        self,\n        options: NoteViewerOptions<Note, N, M>\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N, M> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"},"155":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_delay_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initally equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation \n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the \n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a \n// reduced delay, invalidating prior private reads.\nstruct ScheduledDelayChange<INITIAL_DELAY> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option, \n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pre: Option<u32>,\n    post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numeric value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\nimpl<INITIAL_DELAY> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior contraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This \n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is \n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in \n            //                             which to scheduled value change\n\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY)\n            )\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Serialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn serialize(self) -> [Field; 1] {\n        // We pack all three u32 values into a single U128, which is made up of two u64 limbs.\n        // Low limb: [ pre_inner: u32 | post_inner: u32 ]\n        // High limb: [ empty | pre_is_some: u8 |  post_is_some: u8 | block_of_change: u32 ]\n\n        let lo = ((self.pre.unwrap_unchecked() as u64) * (1 << 32))\n            + (self.post.unwrap_unchecked() as u64);\n\n        let hi = (self.pre.is_some() as u64) * (1 << 33) \n            + (self.post.is_some() as u64 * (1 << 32)) \n            + self.block_of_change as u64;\n\n        let packed = U128::from_u64s_le(lo, hi);\n\n        [packed.to_integer()]\n    }\n}\n\nimpl<INITIAL_DELAY> Deserialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn deserialize(input: [Field; 1]) -> Self {\n        let packed = U128::from_integer(input[0]);\n\n        // We use division and modulo to clear the bits that correspond to other values when unpacking.\n\n        let pre_is_some = ((packed.hi as u64) / (1 << 33)) as bool;\n        let pre_inner = ((packed.lo as u64) / (1 << 32)) as u32;\n\n        let post_is_some = (((packed.hi as u64) / (1 << 32)) % (1 << 1)) as bool;\n        let post_inner = ((packed.lo as u64) % (1 << 32)) as u32;\n\n        let block_of_change = ((packed.hi as u64) % (1 << 32)) as u32;\n\n        Self {\n            pre: if pre_is_some { Option::some(pre_inner) } else { Option::none() },\n            post: if post_is_some { Option::some(post_inner) } else { Option::none() },\n            block_of_change,\n            _dummy: [0; INITIAL_DELAY],\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"157":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable_private_getter.nr","source":"use dep::protocol_types::{\n    hash::{pedersen_hash, poseidon2_hash}, traits::{FromField, ToField}, address::AztecAddress,\n    header::Header\n};\n\nuse crate::context::PrivateContext;\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{\n    shared_mutable::SharedMutable, scheduled_delay_change::ScheduledDelayChange,\n    scheduled_value_change::ScheduledValueChange\n}\n};\n\nstruct SharedMutablePrivateGetter<T, INITIAL_DELAY> {\n    context: &mut PrivateContext,\n    // The contract address of the contract we want to read from\n    other_contract_address: AztecAddress,\n    // The storage slot where the SharedMutable is stored on the other contract\n    storage_slot: Field,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numberic value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\n// We have this as a view-only interface to reading Shared Mutables in other contracts.\n// Currently the Shared Mutable does not support this. We can adapt SharedMutable at a later date\nimpl<T, INITIAL_DELAY> SharedMutablePrivateGetter<T, INITIAL_DELAY> {\n    pub fn new(\n        context: &mut PrivateContext,\n        other_contract_address: AztecAddress,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        assert(other_contract_address.to_field() != 0, \"Other contract address cannot be 0\");\n        Self { context, other_contract_address, storage_slot, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    pub fn get_value_in_private(self, header: Header) -> T where T: FromField + ToField + Eq {\n        // We create a dummy SharedMutable state variable so that we can reuse its historical_read_from_public_storage\n        // method, greatly reducing code duplication. \n        let dummy: SharedMutable<T, INITIAL_DELAY, ()> = SharedMutable::new((), self.storage_slot);\n        let (value_change, delay_change, historical_block_number) = dummy.historical_read_from_public_storage(header, self.other_contract_address);\n\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // If our context has the same header as the one we pass in via the parameter, we are trying to read the \"current\" value\n        // and thus need to set the tx max block number below. If the context header is not the same as the one we pass in, this means\n        // we are trying to read a historical value and thus have no constraint on the max block number that this transaction can be included in.\n        if (self.context.historical_header.global_variables.block_number.eq(header.global_variables.block_number)) {\n            self.context.set_tx_max_block_number(block_horizon);\n        }\n\n        value_change.get_current_at(historical_block_number)\n    }\n}\n"},"159":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_value_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\nstruct ScheduledValueChange<T> {\n    pre: T,\n    post: T,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Serialize<3> for ScheduledValueChange<T> {\n    fn serialize(self) -> [Field; 3] where T: ToField {\n        [self.pre.to_field(), self.post.to_field(), self.block_of_change.to_field()]\n    }\n}\n\nimpl<T> Deserialize<3> for ScheduledValueChange<T> {\n  fn deserialize(input: [Field; 3]) -> Self  where T: FromField {\n    Self {\n        pre: FromField::from_field(input[0]),\n        post: FromField::from_field(input[1]),\n        block_of_change: FromField::from_field(input[2]),\n    }\n  }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>  {\n    fn eq(self, other: Self) -> bool where T: Eq {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"160":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable.nr","source":"use dep::protocol_types::{\n    hash::{pedersen_hash, poseidon2_hash}, header::Header, address::AztecAddress,\n    traits::{FromField, ToField}\n};\n\nuse crate::context::{PrivateContext, PublicContext};\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{scheduled_value_change::ScheduledValueChange, scheduled_delay_change::ScheduledDelayChange}\n};\nuse crate::oracle::storage::storage_read;\nuse dep::std::unsafe::zeroed;\n\nmod test;\n\nstruct SharedMutable<T, INITIAL_DELAY, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Serialize<N> trait, and allocate N storage slots to\n// this state variable. This is incorrect, since what we actually store is:\n//  - a ScheduledValueChange<T>, which requires 1 + 2 * M storage slots, where M is the serialization length of T\n//  - a ScheduledDelayChange, which requires another storage slot\n//\n// TODO https://github.com/AztecProtocol/aztec-packages/issues/5736: change the storage allocation scheme so that we\n// can actually use it here\nimpl<T, INITIAL_DELAY, Context> Storage<T> for SharedMutable<T, INITIAL_DELAY, Context> {}\n\n// TODO: extract into a utils module once  we can do arithmetic on generics, i.e. https://github.com/noir-lang/noir/issues/4784\nfn concat_arrays<N, M, O>(arr_n: [Field; N], arr_m: [Field; M]) -> [Field; O] {\n    assert_eq(N + M, O);\n    let mut out: [Field; O] = [0; O];\n    for i in 0..N {\n        out[i] = arr_n[i];\n    }\n    for i in 0..M {\n        out[N+i] = arr_m[i];\n    }\n    out\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, INITIAL_DELAY, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    fn hash_scheduled_data(\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) -> Field where T: ToField {\n        // TODO(#5491 and https://github.com/noir-lang/noir/issues/4784): update this so that we don't need to rely on\n        // ScheduledValueChange serializing to 3 and ScheduledDelayChange serializing to 1\n        let concatenated: [Field; 4] = concat_arrays(value_change.serialize(), delay_change.serialize());\n        poseidon2_hash(concatenated)\n    }\n\n    // Since we can't rely on the native storage allocation scheme, we hash the storage slot to get a unique location in\n    // which we can safely store as much data as we need.\n    // See https://github.com/AztecProtocol/aztec-packages/issues/5492 and\n    // https://github.com/AztecProtocol/aztec-packages/issues/5736\n    // We store three things in public storage:\n    //  - a ScheduledValueChange\n    //  - a ScheduledDelaChange\n    //  - the hash of both of these (via `hash_scheduled_data`)\n    fn get_value_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 0], 0)\n    }\n\n    fn get_delay_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 1], 0)\n    }\n\n    fn get_hash_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 2], 0)\n    }\n\n    // It may seem odd that we take a header and address instead of reading from e.g. a PrivateContext, but this lets us\n    // reuse this function in SharedMutablePrivateGetter.\n    fn historical_read_from_public_storage(\n        self,\n        header: Header,\n        address: AztecAddress\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) where T: FromField + ToField + Eq {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for both the ScheduledValueChange and\n        // ScheduledDelayChange, but that'd require one full sibling path per storage slot (since due to kernel siloing\n        // the storage is not contiguous), and in the best case in which T is a single field that'd be 4 slots.\n        // Instead, we get an oracle to provide us the correct values for both the value and delay changes, and instead\n        // prove inclusion of their hash, which is both a much smaller proof (a single slot), and also independent of\n        // the size of T.\n        let (value_change_hint, delay_change_hint) = get_public_storage_hints(address, self.storage_slot, historical_block_number);\n\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let hash = header.public_storage_historical_read(self.get_hash_storage_slot(), address);\n\n        // @todo This is written strangely to bypass a formatting issue with the if that is breaking ci.\n        let (a, b, c) = if hash != 0 {\n            let a = SharedMutable::hash_scheduled_data(value_change_hint, delay_change_hint);\n            (a, value_change_hint, delay_change_hint)\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized, meaning no value or delay change was ever\n            // scheduled. Therefore, the hints must then correspond to uninitialized scheduled changes.\n            let b = ScheduledValueChange::deserialize(zeroed());\n            let c = ScheduledDelayChange::deserialize(zeroed());\n            (hash, b, c)\n        };\n\n        assert_eq(hash, a, \"Hint values do not match hash\");\n        assert_eq(value_change_hint, b, \"Non-zero value change for zero hash\");\n        assert_eq(delay_change_hint, c, \"Non-zero delay change for zero hash\");\n\n        (value_change_hint, delay_change_hint, historical_block_number)\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PublicContext> {\n    pub fn schedule_value_change(self, new_value: T) where T: ToField {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) where T: ToField {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value_in_public(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay_in_public(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value_in_public(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay_in_public(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        self.context.storage_read(self.get_delay_change_storage_slot())\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) where T: ToField {\n        // Whenever we write to public storage, we write both the value change and delay change as well as the hash of\n        // them both. This guarantees that the hash is always kept up to date.\n        // While this makes for more costly writes, it also makes private proofs much simpler because they only need to\n        // produce a historical proof for the hash, which results in a single inclusion proof (as opposed to 4 in the\n        // best case scenario in which T is a single field). Private shared mutable reads are assumed to be much more\n        // frequent than public writes, so this tradeoff makes sense.\n        self.context.storage_write(self.get_value_change_storage_slot(), value_change);\n        self.context.storage_write(self.get_delay_change_storage_slot(), delay_change);\n        self.context.storage_write(\n            self.get_hash_storage_slot(),\n            SharedMutable::hash_scheduled_data(value_change, delay_change)\n        );\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext> {\n    pub fn get_current_value_in_private(self) -> T where T: FromField + ToField + Eq {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n\n        let (value_change, delay_change, historical_block_number) = self.historical_read_from_public_storage(self.context.get_header(), self.context.this_address());\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n}\n\nunconstrained fn get_public_storage_hints<T, INITIAL_DELAY>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>) {\n    // This function cannot be part of the &mut PrivateContext impl because that'd mean that by passing `self` we'd also\n    // be passing a mutable reference to an unconstrained function, which is not allowed. We therefore create a dummy\n    // state variable here so that we can access the methods to compute storage slots. This will all be removed in the\n    // future once we do proper storage slot allocation (#5492).\n    let dummy = SharedMutable::new((), storage_slot);\n\n    (\n        storage_read(address, dummy.get_value_change_storage_slot(), block_number), storage_read(address, dummy.get_delay_change_storage_slot(), block_number)\n    )\n}\n"},"180":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point::new(fields[0], fields[1], fields[2] as bool),\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"192":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr","source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n  fn eq(self, other: Self) -> bool {\n    (self.nullifier == other.nullifier) &\n    (self.next_nullifier == other.next_nullifier) &\n    (self.next_index == other.next_index)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"21":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    fn new(x: Field, y: Field, is_infinite: bool) -> Self {\n        Self { x, y, is_infinite }\n    }\n\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n// Scalar represented as low and high limbs\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    pub fn derive_public_key(self) -> EmbeddedCurvePoint {\n        let public_key = fixed_base_scalar_mul(self.lo, self.hi);\n        EmbeddedCurvePoint { x: public_key[0], y: public_key[1], is_infinite: false }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, key: EmbeddedCurveScalar) -> bool {\n        (key.hi == self.hi) & (key.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n#[foreign(multi_scalar_mul)]\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> [Field; 3]\n// docs:end:multi_scalar_mul\n{}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(\n    scalar_low: Field,\n    scalar_high: Field\n) -> [Field; 3]\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    let scalar = EmbeddedCurveScalar { lo: scalar_low, hi: scalar_high };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n"},"217":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"22":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"229":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"235":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<N> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<N> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<N> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<N> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"236":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"// Utility function to console.log data in the acir simulator\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<M, N>(_msg: str<M>, args: [Field]) {}\n\n/// NOTE: call this with a str<N> msg of form\n/// \"some string with {0} and {1} ... {N}\"\n/// and an array of N field which will be formatted\n/// into the string in the simulator.\n/// Example:\n/// debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n/// debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\nunconstrained pub fn debug_log_format<M, N>(msg: str<M>, args: [Field; N]) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n/// NOTE: call this with a str<N> msg of length > 1\n/// Example:\n/// `debug_log(\"blah blah this is a debug string\");`\nunconstrained pub fn debug_log<N>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n"},"238":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"246":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: Field = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point {\n            x: 0,\n            y: 0,\n            is_infinite: false\n        }\n    }\n}\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn pub_key_to_bytes(pk: Point) -> [u8; 64] {\n    assert(!pk.is_infinite, \"Point at infinity is not a valid public key.\");\n    let mut result = [0 as u8; 64];\n    let x_bytes = pk.x.to_be_bytes(32);\n    let y_bytes = pk.y.to_be_bytes(32);\n    for i in 0..32 {\n        result[i] = x_bytes[i];\n        result[i + 32] = y_bytes[i];\n    }\n    result\n}\n"},"247":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"25":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n#[no_predicates]\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    let value = pedersen_commitment_with_separator(input, 0);\n    if (value.x == 0) & (value.y == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value.x, y: value.y, is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        points[i] = EmbeddedCurveScalar::from_field(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let values = multi_scalar_mul(generators, points);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: values[2] as bool }\n}\n\n#[no_predicates]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let v1 = pedersen_commitment_with_separator(input, separator);\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    multi_scalar_mul(\n        [length_generator[0], v1],\n        [EmbeddedCurveScalar { lo: N as Field, hi: 0 }, EmbeddedCurveScalar { lo: 1, hi: 0 }]\n    )[0]\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n#[test]\nfn assert_pedersen_noir() {\n    // TODO: make this a fuzzer test once fuzzer supports curve-specific blackbox functions.\n    let input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq(pedersen_hash_with_separator(input, 4), pedersen_hash_with_separator_noir(input, 4));\n    assert_eq(pedersen_commitment_with_separator(input, 4), pedersen_commitment_with_separator_noir(input, 4));\n}\n"},"273":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"292":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\n    address::{\n    eth_address::EthAddress, salted_initialization_hash::SaltedInitializationHash,\n    aztec_address::AztecAddress\n},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::pedersen_hash, traits::{ToField, FromField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH = 1;\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n       PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            pedersen_hash(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"293":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\n    address::{eth_address::EthAddress, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            pedersen_hash(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"32":{"path":"std/merkle.nr","source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n"},"330":{"path":"/usr/src/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Deserialize, Serialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n"},"331":{"path":"/usr/src/noir-projects/aztec-nr/value-note/src/balance_utils.nr","source":"use dep::aztec::{\n    context::UnconstrainedContext, state_vars::PrivateSet,\n    note::{note_getter::view_notes, note_viewer_options::NoteViewerOptions}\n};\nuse crate::value_note::ValueNote;\n\nunconstrained pub fn get_balance(set: PrivateSet<ValueNote, UnconstrainedContext>) -> Field {\n    get_balance_with_offset(set, 0)\n}\n\nunconstrained pub fn get_balance_with_offset(set: PrivateSet<ValueNote, UnconstrainedContext>, offset: u32) -> Field {\n    let mut balance = 0;\n    // docs:start:view_notes\n    let mut options = NoteViewerOptions::new();\n    let notes = set.view_notes(options.set_offset(offset));\n    // docs:end:view_notes\n    for i in 0..options.limit {\n        if i < notes.len() {\n            balance += notes.get_unchecked(i).value;\n        }\n    }\n\n    if (notes.len() == options.limit) {\n        balance += get_balance_with_offset(set, offset + options.limit);\n    }\n\n    balance\n}\n"},"339":{"path":"/usr/src/noir-projects/noir-contracts/contracts/counter_contract/src/main.nr","source":"contract Counter {\n    // docs:start:imports\n    use dep::aztec::prelude::{AztecAddress, Map};\n    use dep::value_note::{balance_utils, value_note::{ValueNote, VALUE_NOTE_LEN}};\n    use dep::easy_private_state::EasyPrivateUint;\n    // docs:end:imports\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        counters: Map<AztecAddress, EasyPrivateUint>,\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(private)]\n    #[aztec(initializer)]\n    // We can name our initializer anything we want as long as it's marked as aztec(initializer)\n    fn initialize(headstart: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let counters = storage.counters;\n        counters.at(owner).add(headstart, owner, outgoing_viewer);\n    }\n    // docs:end:constructor\n\n    // docs:start:increment\n    #[aztec(private)]\n    fn increment(owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        dep::aztec::oracle::debug_log::debug_log_format(\"Incrementing counter for owner {0}\", [owner.to_field()]);\n        let counters = storage.counters;\n        counters.at(owner).add(1, owner, outgoing_viewer);\n    }\n    // docs:end:increment\n\n    // docs:start:get_counter\n    unconstrained fn get_counter(owner: AztecAddress) -> pub Field {\n        let counters = storage.counters;\n        balance_utils::get_balance(counters.at(owner).set)\n    }\n    // docs:end:get_counter\n\n    // docs:start:test_imports\n    use dep::aztec::test::{helpers::{cheatcodes, test_environment::TestEnvironment}};\n    use dep::aztec::protocol_types::storage::map::derive_storage_slot_in_map;\n    use dep::aztec::note::note_getter::{MAX_NOTES_PER_PAGE, view_notes};\n    use dep::aztec::note::note_viewer_options::NoteViewerOptions;\n    // docs:end:test_imports\n\n    // docs:start:txe_test_increment\n    #[test]\n    fn test_increment() {\n        // Setup env, generate keys\n        let mut env = TestEnvironment::new();\n        let owner = env.create_account();\n        let outgoing_viewer = env.create_account();\n        let initial_value: Field = 5;\n        env.impersonate(owner);\n\n        // Deploy contract and initialize \n        let initializer = Counter::interface().initialize(initial_value as u64, owner, outgoing_viewer);\n        let counter_contract = env.deploy(\"@aztec/noir-contracts.js/Counter\").with_private_initializer(initializer);\n        let contract_address = counter_contract.to_address();\n\n        // docs:start:txe_test_read_notes\n        // Read the stored value in the note\n        env.impersonate(contract_address);\n        let counter_slot = Counter::storage().counters.slot;\n        let owner_slot = derive_storage_slot_in_map(counter_slot, owner);\n        let mut options = NoteViewerOptions::new();\n        let notes: BoundedVec<ValueNote, MAX_NOTES_PER_PAGE> = view_notes(owner_slot, options);\n        let initial_note_value = notes.get(0).value;\n        assert(\n            initial_note_value == initial_value, f\"Expected {initial_value} but got {initial_note_value}\"\n        );\n        // docs:end:txe_test_read_notes\n\n        // Increment the counter\n        let increment_call_interface = Counter::at(contract_address).increment(owner, outgoing_viewer);\n        env.call_private_void(increment_call_interface);\n        // get_counter is an unconstrained function, so we call it directly (we're in the same module)\n        let current_value_for_owner = get_counter(owner);\n        let expected_current_value = initial_value + 1;\n        assert(\n            expected_current_value == current_value_for_owner, f\"Expected {expected_current_value} but got {current_value_for_owner}\"\n        );\n    }\n    // docs:end:txe_test_increment\n}\n"},"340":{"path":"/usr/src/noir-projects/aztec-nr/easy-private-state/src/easy_private_uint.nr","source":"use dep::aztec::{\n    context::PrivateContext, protocol_types::{address::AztecAddress},\n    note::note_getter_options::NoteGetterOptions, state_vars::PrivateSet,\n    encrypted_logs::encrypted_note_emission::encode_and_encrypt_note\n};\nuse dep::value_note::{filter::filter_notes_min_sum, value_note::ValueNote};\n\nstruct EasyPrivateUint<Context> {\n    context: Context,\n    set: PrivateSet<ValueNote, Context>,\n    storage_slot: Field,\n}\n\n// Holds a note that can act similarly to an int.\nimpl<Context> EasyPrivateUint<Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        let set = PrivateSet::new(context, storage_slot);\n        EasyPrivateUint { context, set, storage_slot }\n    }\n}\n\nimpl<Context> EasyPrivateUint<&mut PrivateContext> {\n    // Very similar to `value_note::utils::increment`.\n    pub fn add(self, addend: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let header = self.context.get_header();\n        let owner_npk_m_hash = header.get_npk_m_hash(self.context, owner);\n        // Creates new note for the owner.\n        let mut addend_note = ValueNote::new(addend as Field, owner_npk_m_hash);\n\n        // Insert the new note to the owner's set of notes.\n        // docs:start:insert\n        self.set.insert(&mut addend_note).emit(encode_and_encrypt_note(self.context, outgoing_viewer, owner));\n        // docs:end:insert\n    }\n\n    // Very similar to `value_note::utils::decrement`.\n    pub fn sub(self, subtrahend: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let header = self.context.get_header();\n        let owner_npk_m_hash = header.get_npk_m_hash(self.context, owner);\n\n        // docs:start:get_notes\n        let options = NoteGetterOptions::with_filter(filter_notes_min_sum, subtrahend as Field);\n        let notes = self.set.get_notes(options);\n        // docs:end:get_notes\n\n        let mut minuend: u64 = 0;\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n\n                // Removes the note from the owner's set of notes.\n                // docs:start:remove\n                self.set.remove(note);\n                // docs:end:remove\n\n                minuend += note.value as u64;\n            }\n        }\n\n        assert(minuend >= subtrahend);\n\n        // Creates change note for the owner.\n        let result_value = minuend - subtrahend;\n        let mut result_note = ValueNote::new(result_value as Field, owner_npk_m_hash);\n        self.set.insert(&mut result_note).emit(encode_and_encrypt_note(self.context, outgoing_viewer, owner));\n    }\n}\n"},"38":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"4":{"path":"std/cmp.nr","source":"// docs:start:eq-trait\ntrait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\nimpl Eq for Field { fn eq(self, other: Field) -> bool { self == other } }\n\nimpl Eq for u64 { fn eq(self, other: u64) -> bool { self == other } }\nimpl Eq for u32 { fn eq(self, other: u32) -> bool { self == other } }\nimpl Eq for u8 { fn eq(self, other: u8) -> bool { self == other } }\nimpl Eq for u1 { fn eq(self, other: u1) -> bool { self == other } }\n\nimpl Eq for i8 { fn eq(self, other: i8) -> bool { self == other } }\nimpl Eq for i32 { fn eq(self, other: i32) -> bool { self == other } }\nimpl Eq for i64 { fn eq(self, other: i64) -> bool { self == other } }\n\nimpl Eq for () { fn eq(_self: Self, _other: ()) -> bool { true } }\nimpl Eq for bool { fn eq(self, other: bool) -> bool { self == other } }\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3) & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\nstruct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n// docs:start:ord-trait\ntrait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"47":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"5":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\nstruct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len);\n        self.get_unchecked(index)\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Responds with undefined data for `index` where `self.len < index < self.max_len()`.\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Does not check whether the passed `index` is a valid index within the vector.\n    ///\n    /// Silently writes past the end of the vector for `index` where `self.len < index < self.max_len()`\n    /// Panics if the given index points beyond the maximum length of the vector (`self.max_len()`).\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        \n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen>  {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n    // TODO: Allow imports from \"super\"\n    use crate::collections::bounded_vec::BoundedVec;\n\n    #[test]\n    fn empty_equality() {\n        let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n        let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n        assert_eq(bounded_vec1, bounded_vec2);\n    }\n\n    #[test]\n    fn inequality() {\n        let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n        let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n        bounded_vec1.push(1);\n        bounded_vec2.push(2);\n\n        assert(bounded_vec1 != bounded_vec2);\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n}\n"},"64":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::{Point, pub_key_to_bytes},\n    utils::arr_copy_slice\n};\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret_fields = multi_scalar_mul([point], [secret]);\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/6061): make the func return Point struct directly\n    let shared_secret = pub_key_to_bytes(Point::new(shared_secret_fields[0], shared_secret_fields[1], false));\n    let mut shared_secret_bytes_with_separator = [0 as u8; 65];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[64] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nfn check_point_to_symmetric_key() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar::new(\n        0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    );\n    let point = Point::new(\n        0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        false\n    );\n\n    let key = point_to_symmetric_key(secret, point);\n    // The following value gets updated when running encrypt_buffer.test.ts with AZTEC_GENERATE_TEST_DATA=1\n    let expected_key = [\n        49, 167, 146, 222, 151, 129, 138, 184, 87, 210, 245, 249, 99, 100, 1, 59, 223, 180, 5, 99, 14, 7, 177, 236, 159, 203, 231, 72, 220, 180, 241, 23\n    ];\n    assert_eq(key, expected_key);\n}\n"},"65":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::PrivateContext,\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}},\n    state_vars::{shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter}\n};\n\nglobal DELAY = 5;\n\n// docs:start:key-getters\ntrait KeyGetters {\n  fn get_npk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ivpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ovpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_tpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_npk_m_hash(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Field;\n}\n\nimpl KeyGetters for Header {\n    fn get_npk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, NULLIFIER_INDEX, self)\n    }\n\n    fn get_ivpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, INCOMING_INDEX, self)\n    }\n\n    fn get_ovpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, OUTGOING_INDEX, self)\n    }\n\n    fn get_tpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, TAGGING_INDEX, self)\n    }\n\n    fn get_npk_m_hash(self, context: &mut PrivateContext, address: AztecAddress) -> Field {\n        get_master_key(context, address, NULLIFIER_INDEX, self).hash()\n    }\n}\n// docs:end:key-getters\n\nfn get_master_key(\n    context: &mut PrivateContext,\n    address: AztecAddress,\n    key_index: Field,\n    header: Header\n) -> Point {\n    let key = fetch_key_from_registry(context, key_index, address, header);\n    if is_empty(key) {\n        // Keys were not registered in registry yet --> fetch key from PXE\n        let keys = fetch_and_constrain_keys(address);\n        // Return the corresponding to index\n        keys.get_key_by_index(key_index)\n    } else {\n        // Keys were registered --> return the key\n        key\n    }\n}\n\nfn fetch_key_from_registry(\n    context: &mut PrivateContext,\n    key_index: Field,\n    address: AztecAddress,\n    header: Header\n) -> Point {\n    let x_coordinate_map_slot = key_index * 2 + 1;\n    let y_coordinate_map_slot = x_coordinate_map_slot + 1;\n    let x_coordinate_derived_slot = derive_storage_slot_in_map(x_coordinate_map_slot, address);\n    let y_coordinate_derived_slot = derive_storage_slot_in_map(y_coordinate_map_slot, address);\n\n    let x_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        x_coordinate_derived_slot\n    );\n    let y_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        y_coordinate_derived_slot\n    );\n    let x_coordinate = x_coordinate_registry.get_value_in_private(header);\n    let y_coordinate = y_coordinate_registry.get_value_in_private(header);\n\n    Point::new(x_coordinate, y_coordinate, false)\n}\n\n// Passes only when keys were not rotated - is expected to be called only when keys were not registered yet\nfn fetch_and_constrain_keys(address: AztecAddress) -> PublicKeys {\n    let (public_keys, partial_address) = get_public_keys_and_partial_address(address);\n\n    let computed_address = AztecAddress::compute(public_keys.hash(), partial_address);\n\n    assert(computed_address.eq(address));\n\n    public_keys\n}\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n"},"66":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr","source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH, hash::poseidon2_hash,\n    point::Point, traits::{Deserialize, Serialize, Empty, is_empty}\n};\nuse crate::keys::constants::{NUM_KEY_TYPES, NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX};\n\nglobal PUBLIC_KEYS_LENGTH = 12;\n\nstruct PublicKeys {\n    npk_m: Point,\n    ivpk_m: Point,\n    ovpk_m: Point,\n    tpk_m: Point,\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m : Point::empty(),\n            ivpk_m : Point::empty(),\n            ovpk_m : Point::empty(),\n            tpk_m : Point::empty()\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        ( self.npk_m == other.npk_m ) &\n        ( self.ivpk_m == other.ivpk_m ) &\n        ( self.ovpk_m == other.ovpk_m ) &\n        ( self.tpk_m == other.tpk_m )\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash(\n                [\n                self.npk_m.x,\n                self.npk_m.y,\n                self.npk_m.is_infinite as Field,\n                self.ivpk_m.x,\n                self.ivpk_m.y,\n                self.ivpk_m.is_infinite as Field,\n                self.ovpk_m.x,\n                self.ovpk_m.y,\n                self.ovpk_m.is_infinite as Field,\n                self.tpk_m.x,\n                self.tpk_m.y,\n                self.tpk_m.is_infinite as Field,\n                GENERATOR_INDEX__PUBLIC_KEYS_HASH\n            ]\n            )\n        }\n        )\n    }\n\n    pub fn get_key_by_index(self, index: Field) -> Point {\n        assert(index as u8 < NUM_KEY_TYPES, \"Invalid key index\");\n        if index == NULLIFIER_INDEX {\n            self.npk_m\n        } else if index == INCOMING_INDEX {\n            self.ivpk_m\n        } else if index == OUTGOING_INDEX {\n            self.ovpk_m\n        } else {\n            self.tpk_m\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.x,\n            self.npk_m.y,\n            self.npk_m.is_infinite as Field,\n            self.ivpk_m.x,\n            self.ivpk_m.y,\n            self.ivpk_m.is_infinite as Field,\n            self.ovpk_m.x,\n            self.ovpk_m.y,\n            self.ovpk_m.is_infinite as Field,\n            self.tpk_m.x,\n            self.tpk_m.y,\n            self.tpk_m.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: Point::new(serialized[0], serialized[1], serialized[2] as bool),\n            ivpk_m: Point::new(serialized[3], serialized[4], serialized[5] as bool),\n            ovpk_m: Point::new(serialized[6], serialized[7], serialized[8] as bool),\n            tpk_m: Point::new(serialized[9], serialized[10], serialized[11] as bool)\n        }\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: Point { x: 1, y: 2, is_infinite: false },\n        ivpk_m: Point { x: 3, y: 4, is_infinite: false },\n        ovpk_m: Point { x: 5, y: 6, is_infinite: false },\n        tpk_m: Point { x: 7, y: 8, is_infinite: false }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x146f68c0e0ba4067d61a3304bbfdec0797d5df1357db6c01247c48bfb345c7d7;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nfn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nfn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: Point { x: 1, y: 2, is_infinite: false },\n        ivpk_m: Point { x: 3, y: 4, is_infinite: false },\n        ovpk_m: Point { x: 5, y: 6, is_infinite: false },\n        tpk_m: Point { x: 7, y: 8, is_infinite: false }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.x, deserialized.npk_m.x);\n    assert_eq(keys.npk_m.y, deserialized.npk_m.y);\n    assert_eq(keys.ivpk_m.x, deserialized.ivpk_m.x);\n    assert_eq(keys.ivpk_m.y, deserialized.ivpk_m.y);\n    assert_eq(keys.ovpk_m.x, deserialized.ovpk_m.x);\n    assert_eq(keys.ovpk_m.y, deserialized.ovpk_m.y);\n    assert_eq(keys.tpk_m.x, deserialized.tpk_m.x);\n    assert_eq(keys.tpk_m.y, deserialized.tpk_m.y);\n}\n"},"80":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n"},"81":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr","source":"use std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext, oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: Header, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for Header {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier);\n\n        // 2) Check that the witness we obtained matches the nullifier\n        assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n        // 3) Compute the nullifier tree leaf\n        let nullifier_leaf = witness.leaf_preimage.hash();\n\n        // 4) Prove that the nullifier is in the nullifier tree\n        assert(\n            self.state.partial.nullifier_tree.root\n            == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n        );\n        // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n        //     was included in the nullifier tree.\n    }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, N, M>(header: Header, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M>;\n}\n\nimpl ProveNoteIsNullified for Header {\n    // docs:start:prove_note_is_nullified\n    fn prove_note_is_nullified<Note, N, M>(self, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M> {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n    // docs:end:prove_note_is_nullified\n}\n"},"88":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::storage::{raw_storage_read, storage_read};\n\nstruct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = block_number_oracle();\n        let contract_address = contract_address_oracle();\n        let chain_id = chain_id_oracle();\n        let version = version_oracle();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<N>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n\n#[oracle(getContractAddress)]\nunconstrained fn contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn version_oracle() -> Field {}\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"}}}