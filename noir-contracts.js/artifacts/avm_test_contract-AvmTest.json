{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"AvmTest","functions":[{"name":"get_transaction_fee","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zWMOw6AMAxDX38IMXRhYWEBegRW7i9ORRzaSE4sf3KRYDbATp9oCpXJThAeBvtNQiUMqcn0Vusx0mFraeNVvGV4b5WW3cmG4qwod4pur/ABTxeOqJMAAAA=","debug_symbols":"bY7RCsIgGIXf5b8eYU5t+ioR4TYXgvyO6YKQ3r3fWhHU3fnO+S5OgdH16+XscYoJzLFAiIPNPiJRAbbbs2ebZou1SNkuGUynOGvA4VijkPcGJh8cmJZT/rGFVIfNFrITH1v/k5XUepOV4u23fCK42sXbPrh6r24rDu+3hPk2vxZyHw=="},{"name":"variable_base_msm","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/5VUO1LDMBBd2/FHVizPOAmkYYaPPWmgpIRUHAMazsAFoKbjCByFioazcAP8di2tHTIw0YzslXbf09td2S0lREVK/TihYcT9DjnK+leEeUveEidFjiK/1cHJqG4Io+S8fxy3zIzwGZs8UzERlYuJUWRsggZKTEsRIsqIA0tsYZ4h9khWySAFmLLzYZk4ZsERyyac/oQc79P+Mb+mQWAiUhCYdb4KMwr64CBVnqryrGXF48G5cfX4qFwlYatgSaxBCQsK5xdT0vhr8fCUvd8/ImshNVKh9GpT3X2vm7eX7cfr83ZziSydT5ZK5YhG4qxEWMw40GFpdpYUluUUV0wTsp1vg9WErCZkJSEWYadQaY8VtR5aKnSnowrJD4cUh0P+EdYGiAl3JtM7Y6Z3ptQ7Y37fGbjmUuK5TH8UaCqWA0elhJXEGDH3kWJUQlopwJM6JoXDKalTUrefdAmXkDoFeNKaSeGolbRW0lo/3imk+huiP5Am1NporZtprWv9nBvt0uImH7XYqDOStJLhsCWL8i1csoX9Vefz5z8draDoAub6E/MHtSj4PUoFAAA=","debug_symbols":"nddBboMwEEbhu3iNKsAzYw9XqaqKJKRCQhAFUqlCuXtNqx6gbxdD/tX7vGAPl+H0+Hgf5+uyhu51D9Ny7rdxmctpD/VLG3+errd+Ph6sW3/fQifRmyoM86X8lCjPKlzHaQhdbPX5Vh0zYTNlM2OzxGYZzWLNZg2btWzGckeWO7JukQUQFkBYAGEBhAUQFkDYfRPWTdh9E5jb0UyZEmVKlClRpkSZEmVKlClRpkSZEmVKjCkxpsSYEmNKjCkxpsSYEmNKjCkxpiQxJYnlTix3YrkTy51Y7sS6JdYts26Z3e7McmfWLbNumXXL7Jpmljuz3M5yO8vtLLez2+1MiTMlzpQ4U+JMiTMlTf1/JuX02d/H/jQNx/f08fIxn/8+r8tx+7r9vin//QY="},{"name":"keccak_hash","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"data","type":{"kind":"array","length":10,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/0WQwQ6DIBBEB1FUNJ6bJk1sK7dem/TU/0+/qju7i5CMPmBghz0QgekFGTf4WGUFG5L8AvVFJYFOFDaEumTYUYa8Lxr2lOFAGfLeZDhShhNlOFOGmTJcqMIozNgVD4V46BOYq1ekGwP3IQGQlBJnD/kUs6/NvtPeTo6GHBI1ekHJj/lAoCMHNWYuUXd6D5tFbxHP5FJtyTb6c6PzSBlnhZF/Zrm+4QF3i6I3tKzaBB0jzqiLZaiPmNrJZVNktfUTvRCTrMXv8GYxRK801AarLz6Jlx/1B5Rmwb0vAgAA","debug_symbols":"ndFRCsIwDAbgu+S5yGyrm72KiHRbJ4WSjrUTpOzuNsoOsLzlT/I9/QVG16+vp8cpJjD3AiEONvuINRVoTqr9bdNskRYp2yWDuWrVCnA40tjJTcDkgwOj5GV7CGIdj91YTDc8duYxyWOKx/RhVtPbLt72wVGLdFxx2EutMX/m/6X+fgE="},{"name":"send_l2_to_l1_msg","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"content","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/zWNOw6AMAxDX3+oElJnFhagB2Bg5f7iVDhVY8mJkzjyRYKaEXYmNFUai1owvriSiGJoBF91O9pX7NNGGsqMeSglUA6V9cHD7hlEOc2zfcYfkjr9xI0AAAA=","debug_symbols":"bc5BCsIwEAXQu8y6SJMoaXIVEUnbVAJhUppUkODdndGKgu7mz3+LX2H0/Xo5B5xSBnusENPgSkhIqUK7E+L5zbNDfuTilgJWyLZTDXgc+RbycG9gCtGDVXz/eEl+41LuP9r8w9oovWFtOvGNTxSubgmuj54Hcrfi8N5LsdzmV0P2AQ=="},{"name":"get_version","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zWMOw6AMAxDX38IMXRDYmEBegRW7i9ORRzaSE4sf3KRYDbATp9oCpXJThAeBvtNQiUMqcn0Vusx0mFraeNVvGV4b5WW3cmG4qwod4pur/ABj2lMHJMAAAA=","debug_symbols":"bY7RCoMgGIXf5b+WodU0fZUxhpUNQTTSBkN69/1ujQ3q7nznfBcnw2C65X6zfgwR1CWDC71ONnikDPTE6LuNk/aliEnPCVTb0oqA8UOJTK4ERusMqLo6r2RnN1zSzcb4s+WRzEXNNpmLRvzLV4SHnq3unCn3yrb4/vsWMT2nz4LuCw=="},{"name":"poseidon2_hash","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"data","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/71aTagsRxWurqrunu7pmbnd83N/HpKob0CzEtFACIoL3YiiQkQ0glnqIooQfwhBROJGDS4UXYiQICgSVyJiMEKMYERE1J2iiAtx9VDEpaBzTtU5p2qq5k7n3pt3Yd6r7j516uec7/xV3VZGqclM7f5epfxft3uj5qra/VfA762KWruG3v2KuSro1RY+Qi+99WTK3EamQGmxCdSqhO/K7n4Vtip4es3unzk+7qgn3ZuBRQcdpN9kS/OqFb5UNOJW+/nUQl0ztRbqmqnhjXbUmuaMf0ao4YMSmsMcx8xRaBqmmQhNIzTwmzJNIzTTmE97W77cVqVK/zqUHYgRfsYPA2xmuAnwYSYMZ35s14T/70YXpIEeZqto9UeoW6GxOExGeLN4s6a3wy+0zTPUOprkXMjnwfe710Wk2AZSnDspzqUDdVogU/iwEKaL4DvLwLCO61gaWeqp0DhAB/gqULnxDej+RPAxy+n1jBHXMDwmI6bQCo3GlapYespTC5rd8LN4M07ct4Vr+g2b7tEw74XwPonsSkDdM/WJUPdMXTNDeKru3f3zmOsMK+oqbBIo56+GuUOXORB+dlv43ZnzPgVQaAUKCACkhqcuUHNH09EXVpDJKI6ko473jA0RtJrAtgrMazRohX9qAyuneNX4RRRrFEfSAcf7hFsLsfLwV5bYhD4AnUrT2LjHNeyv+ia0YH+/m9mNY3PouHWFucs8G4bAIoHQiZsbr3NHAO2qQMKKWONanvVrKd6djN95djmZB36xUrxjFU+ji2k6kV13QHZdYsU6P2rH6+9k/e2WrFoDq31ePJ2HRBNCQr9IkHhBWHRbRTTw5ReBs3Qs5qT0yOIT0ALClxhVHe/HZXpaRPha8DvRwRkHA9AqhZd1vErX3AU6BemlOKtSmgObEiumZIj9lgnIHyDB2UScZFUMi1OEXyWqUpECsGBdy0YiniYKMWXzoDlOIWEvWMNPxGy3uTCmjUMdyzSt0NjsLii39lyoM3VOcio2sPVsOl5klyzI+gXZu9MlsGp+T0JRZqmN0CjeLOtBUFRHQHC/B0HRsonueOg20YvW68U+CCY85WPGpCAOAe8iw/vKEMLHgrV4/4voaRlBuMyEIMHWG9l6EwnKspUWXBxzchW3Sm/vC55BKfhQKkyAUJxvEHE2Ik7kDOIs/gMtIHzTVSOFq/r1wAJe0btcz4cY3tM9W4O+8KoWPvDPMkxdRZtQ4c5/AFr3F2JvaLYYamzJUQejug2ekmg/fDlSi+8QUh+5XLSNiLY5KtoxSJUAq2a0BIiygjXEY81AQXeDc/8ktGRz8ga6cga6Evbw6yuGO8TQA/L7DLRCfkQ9BGF4ySKAjkvs+AS0YBM/h1sAO2zg8alcgrjnaNeiDBs3qY0nOvUIPnMB2Rm8gh8O+RX3RAKFPmdbIluJc3YftHsJH+nlGv6HSX4BZyoT0tIZtmfFtmUltkViyMTe0hfNbiQL2BPRixOG6V4pZVIwIiYHwuFJMu+J5zPZs7xt1E+/lpWuE1hgjIHb+z1owcbcyWB8jOWSTKbhQVOHwa6EkRyAgQESuClT8GQRDzXLCl5pnPtP0AOzGvMCNC8g0Oel13DX3IWGhX/qRf2XskNAs8JRfg6tfctENnqFbFYyFPxWFWN4xdB5CVo5zC1ljquSbQ90XGPH30ALJPRbjs97ePwLY64XzC1jzJ0K5s7cpM480bnH3IXD3AW8gh8O+Wf3RPiHPhdbItt4w8IftAfaheIRAL5nMMk/4EwT3e399myw88CtPkLRkEQtAwf2hKKBtT/Q+cCKibh6xqqgtmKMl+Tr7iS5PvuROsJPg1v1b2gFOkgicj6JVbJ9WcHdlbOgIBwjTFnRNC3qjRuCESxw6HOOF8j6rd9EShBQCMJmIPXW7Qj1Hkq2IQPBS8NsV7vN0j1bL1Bvfe8I9d6Iep+6SZ16ojOv3udOvc+9Xp7hkPeIg2h9n/Mtka1FQ90H7X2IB8Sp1/ZTmOQaZ5pVb9ieNbuGdRJgUOBp6sjQYRyqXwetQKtSbLSJZWv90lvGRpuJrY9ho+KW+D9QkROuHbtA+lrpzowRMdpbBPm9qB8iADfs7dDa1+LWk9ltQSFVkBULG+SKbN4JrZwWh+gTI20pQtPv8ZGQfh9bAKgi6UdyxxVlrMW9aLGH1uCJll6LV06LV17CDnEfEdF3hCj2RlpMy8ARjZaIaaB4ECb5fpxpkt3UZCtEMZJcmoOJOjKVGNPrj8YxPWujJOeXiZ5ykSqO86trVZtizRtvixf87oT1Eq0y8zLZwBLxvy1UVGewh2zxkzlbXKa2mLfA8hb0WSOko37lQVeAaYH+apwWSMo+jwMmn5rEXG2KKcf1G7lkw+65d/EMlsI7/S34B1Tz2+wZEGI/GJFsrARTazepNQUaHlOnDlNkzjc45LMS37S+z+m2EL9C2+c+aI/HU3m58sGafgZnmhhbDi/ZxC4Peoayjgyd8ww/yniG7pBnGGQpgwrLzG3mUOdYNbLnVs2eoWLPUCoqGzNe5pLno5nwGz8tVBEwd/XoX/nuRt1g4WVUHS0H73yCXc7ZOqVIaiIg/ykGcpCOBzCVBFsg+FeyyX/jBNvC479ylex+jM73x3T+n6Lz80M6b0fp/N9xptmiXxPrPIcVorbHalVGhTXgWc7uWsEYemZ2ISantqhtic7zMUkdKS8mywZLnnvBPqIVFP/5I6eQ5MHsQwcJ3SiLeBQVFYRE4+eMlOnLcoRdgqaOvvD2TkZxJNvTXu5ajWDPxK51xBHfbBRHygEFw7VXeV2QT3Tk+2ecCEo540SnqWkQ1w2F8oyP6Mwbb2QI33UoyE677jJyTW7QfNy7QfMWGRk/vI2m9KgAv04qfzQk2hfzDnW1yp+ByBgqf+ZdHI6BMzYPv2KVP/MhMTNTdZ3Kn3kvzjQboNUcHc+5ZQ4Zpuzhv1ZhOT2baZkgGOSAuolp0gNsKcejrXoU/nk6465E4XRSyiJzjbm2+ZSKSllBxSrIJkX60BFrUOZxb+LNEyx9SNLNl3NJ+iqWfr4GBUSX1aDMlxSn3FN1nRqU+TzONImKKD7esPQ3iaRrFZV+6sigfw1alybpdeLTKKequfBVZ1RnSOJGztdYSwY2vwtWWtSTp8HHPJgoX5f4UJnnZbkLjWIOusqcsT4GmkZFtxckI0SD9sPkLIcFATtv/6HcWY75cXBDjzUTvzwXHGtVkZdDJ2u/rlzd2/ws40bHn9gtVHrAg1EJ70SfVTyUJydmWpKiXpobBtcg4NrE4FoG5A9kbLkX55JMQUb4x+xUy61BHTilDS4ESHYhtahGZU5StAovatYHL2oOuRsOQ3YXlFt7LnZvXezeStBDVcjkwmOwoMEvaLg7XYIwxu9JKMos9VJoFG/WQCD47xEQPOxBYNX1DnjxschkZteLCYsM9E5UdD0tLUvzIQ+uEEtm48rSXmrOVVpwRFCWtre4oAdBmL0vd0f5RsrS9vUSvXTqQFlaqxFlaXsPzjRb6cWkjT3emiOY7PXFI3WA2ORfVoEixe6z8U50Uc8+eAOXNIsbvqTZ5aokB2cyT2ZCdVG5pDwbxZHmjSB9KBEMJ5g1P3Kyaj+o8smquzLLgJuyrWkSeDZeYfa9Xnzae9mRAiVGwS27vorSC8xL7MdUpvRIAYaUHnUCdyp9Y93Fwp3EY3UXD/c2shOPKZfe2E9H6Y39Yi692au75NObXl2e3tgn1Q2lN/ZxnGlirml7guL/wdRf11ExymnQU3sapNlak8pME9FPIwvRsIJp9knXirdizRtTc5d7BoYdiGZePfMKj+ElaEL/sS1iT4sH+6J+fFRvvw+tfS3uPdka2ayZ4YT99URFB4SrvdIa9+uTKwY0PFbyLNSGN/vDD55sg2y83lR+Qes44tzDlOP605hrEHAmmKojF/oCudAXObqHHNL+njG1PhjXngmmzt2kzj3RhcfULYepW8plhBc45O8Up4CN73NrS2RBydJ9IGd6S/EIgL1zmOQvcabJIeuanDO7wtOD98T7OjJ0eF/A/lHF9wXSeDwAw0aWslHxpX1y/1eJxw07Xfi5+n1P+Hxu/74QJb1Tv/FtoYqAucvI7vju5fYGj+fGwLvJwTufA/QuB+izSKojIP8vBrJQrw9e1kGwlNbb5LLisBHK+eU6l8utx+j8+ojOlyvR+e6Qzg9jdL5scabZK1N1rPOcDo4PG5cHwsZlkh8vyTOzC1nm1Ba1bWzFBg/PyvtUfHhGInJFB3g8+zX8/g/wNqljqzkAAA==","debug_symbols":"5Z1vjxzFHYS/i1+jqHu6p6eHrxJFkQETWUI2wiZShPjuWft25kDX2tqNmktV/V5h49njedBdV83+Kf/25od33/36r3++//Djx09vvv37b29++vj928/vP364/O63N+lvuX79t59+fvvhy7/49PntL5/ffJu+efPuww+Xf/7+zZsf3//07s23ZVl//8c3Xx6wPvqA9ugDtkcf0B99wP7gA5b06APyow9YRg9o65avj2ltaX962Dcvri5bu15c8/Z8bRpd2vblem3Zcrp9cSvHta2UP176RF5kyass+SpL3mTJN1nyLku+q5KXJEueZcllM7TIZmhhztB2fN3W60ty5gy9Tc6cobfJmTP0Njlzht4mZ87Qm+SVOYlukzMn0W1y5iS6TS6bRFU2iapsElXZJKqySVRlk2hlvpu7TS6boatshq6yGbrKZugqm6GrbIaushm6ymboKpuhTTZDm2yGNtkMbbIZ2mQztMlmaJPN0CaboU02Q5tshm6yGbrJZugmm6GbbIZushm6yWboJptEm2wSbbJJ1GWTqMsmUZdNoi6bRF02ibpsEnXZu7kum6FdNkO7bIbuNBn6hEMTjE84NGn3hEMTYU84NLn0hEMTNk84NAnyhEMTC084NGf9Ew7NAf4VJyeuYzknrnM5J66DOSeukzknrqM5J66zOSeuwzknrtM5J67jOSey8zmTnc+Z7HzOZOdzJjuf8yufP1t55qllwLNx8Syv+/NVl7wd1y5//oTZQxdf4bMy/KIMX5ThqzL8qgzflOE3ZfiuDL8LwxflhC3KCVuUE7YoJ+wrDwVMhldO2KKcsEU5YYtywhblhK3KCVuVE7YqJ2xVTthXHkCYDK+csJU4YZelH0/3LSUtA3jihMXwxAm7LC0/ww++bVbic35Zl37Ar8s+gCc+5zE88TmP4YnPeQxPfM5jeOZzHsIzn/MQnvmch/DEd1IQvhHfSWF45YRtygnblBP2lT/CPxleOaSackg15ZDamI/Kvp23gX0HF5eaDopSR3frG/O5OteU+RCea8p8Ys81Zb6BmmvKHGRzTZlTb64pc0TONWW+6Ztq2pnvEOeahulIPUxH6mE60itPGfw/TV1Spuf1em3Pg3u27pIxwHN36bz7+XLm3tvA06XxIk+X79uc0oGcU3658LAkl26ETV26ETZ16UbY1KUbYdMaxtQlS7GpS5pi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"},{"name":"l1_to_l2_msg_exists","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"msg_hash","type":{"kind":"field"},"visibility":"private"},{"name":"msg_leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zVOMRKAIAxLoXAMHrOLi8Lo6Or/z1fZFOhdIdekSRsiUBKsDsxSm6Ai2yfsFwsZCNZSIWvUSXIr9ClDdEShOrIEpNOerWM4FH1IKL3uGQkekRuEFpqYwBMG5YsucMR5uAj3j/0D/874V8YAAAA=","debug_symbols":"tZBNCsMgFITv8tZSjIn4c5VSiklMEURDNIUiuXs1bUohXTa7N28+mGES9Lqdb1fjBh9AnhNY36lovMsqAT5VZP2GUbnyCFFNEWRVCcIQaNevN8cLgsFYDbImdEE7XlC+0RjXH1j8YhnH5A0zTptv+IJKo/rvjfg+pDk4JIu7moxqrS5LF2923TZ8lvExvpzMPgE="},{"name":"get_address","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zWMOw6AMAxDX38IMZSVhQXoEVi5vzgVcWgjObH8yUWC2QA7faIpVCY7QXgY7DcJlTCkJtNbrcdIh62ljVfxluG9VVp2JxuKs6LcKbq9wgczsEd4kwAAAA==","debug_symbols":"bc5LCsMgFAXQvbyxFL/5uJVSiklMEURDNIUi2Xu1TUsgmb377hncBIPulsfduNEHkNcE1vcqGu9ySoAvBH++YVKuPEJUcwTZUNwi0G4oJyMrgtFYDZJRsaKD5qQWm+ak4X/dnuGKsnrDFRVsj285PNVsVGd1mVe6xfW/tTnG1/Rtsn0D"},{"name":"create_different_nullifier_in_nested_call","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"nestedAddress","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"set_opcode_u8","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zWMOw6AQAhEH/sxxmJrGxvdPYKt94+nEnAhGZjMh06GVQEHc5IqNBY9YngI9ptIQ0IaZnprzBj51LWNeJVuM7zXEcsW94qiOquWvIzur+ED0VY4q5UAAAA=","debug_symbols":"TclRCoAgDADQu+y7E3SViJimMZAtSoMYu7uCfvj5eApncOU6iKO8sG4KSTxmEm5SW+DDh9ClMBgL+2nzf/ex3So="},{"name":"read_storage_list","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/31Sy27DMAyT83DbJNZx22XAtsYYsPt67P+jX1WTsuIUKCpAtiJRtChklV7kOEixT6nWlYyoxHIF+FU8sqIEleCpjCK7coVJ/1OO95XMgA8M2TlaCNTBQtgxMgTNWPy0SgBiCgROSMG/gX2zLydEz5QdFq0wbIXOkij6CwfcX+VY/qUO2K18d2+cmzsg207CKTtmlE0B5pOmLf52tXEnGjY1ntlEY+wZ01DdGdEltDn6uhPAFupcbEP+1NwYkzGCLRVXMv4hesYImJJRwdpodBMYm0B9FLiTpAaKFZS4c+wjNXgyjPpkz1qW1y1ZvCPX3Zc+n4z/HnH9GeHHDX4HOLC9PNwCAAA=","debug_symbols":"5ZhNasMwEEbvorUpmhn9+iqlFCVxisHIIXYKxeTulZvItNStd0FCO83MQ7xvNUgTOzS7y9tr64/9wOrniXX93o1t70M1Mf6E9NUdTs7PjWF055HVCMZUrPGHcESurxU7tl3DakJ5rX7RwLW+0wAICw1CrdCSSNxpScoutF27WoKlCCNswEby6GGkoO/wSzVnlQVlVQVl1QVlNQVlteVkJf74rGCXrJr/r088sgTqh8bNHrK2x6ztKWt7kbW9zNpeZW2v07ZHiPZoVuxN1vY2Z3uR+K7dsE98127YJ75rN+wT37V/24fq3Z1bt+ua+eU/Dy9+Hz8CQjl+nG6TwH4C"},{"name":"nested_call_to_add","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"arg_a","type":{"kind":"field"},"visibility":"private"},{"name":"arg_b","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"nested_call_to_add_with_gas","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"arg_a","type":{"kind":"field"},"visibility":"private"},{"name":"arg_b","type":{"kind":"field"},"visibility":"private"},{"name":"l2_gas","type":{"kind":"field"},"visibility":"private"},{"name":"da_gas","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/82aS28kSRHHs6vd7bK7qrv65Xbb43f3jOflHu/s7CAkRmivSHAAxBENT6FZQLwOCPgCcOMjcNgD8Bk4cOCAOHLnAEfEAQkhJJCoiIyIf2ZVubzmIa0l29mR/19mVmZWRFRWr1zXuXTblT9HTn76pcUN+V+Hfl85LZWFpPztDF1HTWuqJCpZi8x1uUTCLS6VPbgel7aodS71yj/b5+Wf4dr5VtP+C6roU/srGhX14XbXOqodx0b62aU/60RGswN10qROTE2WnZG7ielWmBU+Wmddb6TfgYG7AAcxmJlmAE0GDQ0g58YHdrF0dUNUjzw49MVyvhJpYmjqkVdTReHVI190I1bn0HQMdGjbSfuY0xEuszD1EOrC1ANrkFoo0MtYcF8sm9FxF6YeY9wTrx77ohvbuMe6P1x6Wv55Fcxtj4upNJuf0YA/QSUSvruWySvXoKPzZz0nGKfMmExeudS6ywdVddKmToP5dTYwolO78i6XRjetdIKVTmylB9FKt40kkT6TppVOmlY6g7obqbMm9cj2cxaPu8C4i4ZxZ9gXyU37IoXG8ZQ5MfJavglq/KLnUj3gRV9QiYTfxHJwKbP7O4tvgdptopslr6qTNnUwCRkmIbNJSG3Rk2jR0xqnuzi1jZ+aOsNI5IbNbDkS7ROavOmGzeFztiK/lN/ol5LgVluxhUaps5+Zd0njqa0O8UOL2EzDfWW3qBNoXHQ38O57P5jfvg8RoW9KPq77+efmkTLrOq35gTTayrzboUmbFjn1C9hz9Z+U4zkrUpucMMo0eYpRc3us9+2NbLJH8Y7xTr7QK/4VpmbUt6UiJuWpOVT//mtMzdAWYOA7Y5cyxG3GUh+JO3KrdKsxsfVmTz9QBO3EVxdsDrtu639kLU6gnnr1xBfdhNUTm6RAnbSpx2ixMVrGcaWtf40ZE1NP0f/Mq6e+6KZrcdqq6VhQrqQ+49h9IG8YV/KGwJ2ZpqjtOht9U7YyhaZrF+JwrU6uN2hnZpoJNLNYMzfNDJp5rNkzzRyavVizMM0eNItYs2+aBTT7sWZpmn1olrHmwDRLaA5izaFpDqA5rGiwpw8tn9jhPaW5guxAbLTK6u7GLQaecrcMIK/RyVjE99ba3T1g97xm1xcZ/RLMih4xSoIjoEdAj7A574SUvX0eZkWPGSXBMdBjoMf13o7t2lqQsrdvw6zoCaMkOAF6AvRE0K/CrOgpoyQ4BXoK9FTQ78Cs6BmjJDgDegb0rH6NZzYtd0SO25FygF+GWdFzRklwDvQc6Lmg34VZ0QtGSXAB9ALohaDfg1nRFaMkWAFdAV3Vr3Fl19iClL19A2ZF14ySYA10DXRtN+Q4irK7t6gzKw0sZHfNu05vCZiWTZk6SOh3kdDvOk3oE6/pdCyEIPT02Rurbc6lbfasfGbA/pNKlHfs19MPiv37PiPYZz+aSGkpWeqSLUvzjX3JQjrf54/UVUYff4Br6DcFtH7szrZXYY1OMYl6lkr2IO95TV8upBHJ2pGmYNpvDKZMvzWXDnYcMsg+1rThWbMn199rq+FFLB+8tJngIZMWMG86QMnjse1g7vKywU86OxDRXDB4aqw9Seey6rn4hWGM1p6CgucqfSLIxedlMTquxrbg5CKXmywXlzKO0YndhZNaYpb7oj5cxciwHZFwN4lRfw9N4jRsGtQLegqzVuFWmwXZUFAv6Bdh1ip/b5JgHiRJQb2gr2HWKn8zk2AvyJ2CekHfg1mr/N1PgkWQUgX19Zn9j5FpO1IO8Cswa5V3OQvvniyfC+rrve3bdLQgZW9fg1mrlqGDs8wwqK/3trTpuCMyvDsyaUfKazqDWasO4KKDTDaod/rQvANnM3NhtptXst21up2yxa0gXBxaHnZQyzEPfFFrpnEiegyndeIfWk9EfypO8ayj6QvnTac84j5SK2XO1io7QscncQIFNSd+FKD+GQyrMuB3Onr31sJ2T9x07/9R41z0IHzYjx4aDngC9myAiAschxJeQFnqIHnhlwM+4lw0HUmkjQ+HtMhFx3IPPlDYth3E54s8HErdxhhO4Hk7lubwU/S2PSaTacrwJZUAm89P7ZwixWimfcvl2N1yC1dUqs5GJrLZWpxxeKAytlPMUcLGsVTMnB3izCx4jTl4KjGu5Uv+4C44/kGbqUWHGQK/BqLZdhQh/Fy+iueSV2jm9JDH5iS/07GWRO1TF+Y5yY15zig4ZSrvw88hNONc4+bQXMjlEfojmBVti7OFs9y380uYFW2Ls4XME6G/gFnRtjhbSNwompBpO1L29nWYFW0LzYXEDUJ3YFa0Lc4WvsjoT2FWtC1oFr7I6B9gVrQtAhYSRwh9F2ZF2wJNoY6oRH8Gs6I+cJDgsHZKUojDI/SzLjo8oaq2c41CXHjRhMzbkbK3j8GsaNu5RiHhhdC/wKxo27lGIaGI0J/ArGjbIUUhkYzQj8KsaNshRaGeoES/BbOibYcUhcRYQj8Ds6JtxweFLzL6BmZF244PCl9kdA6zom3HB4UvMvpHmBVtOwsoxPsS+jeYFb3PKAnuA70P9L6gP4ZZ0QeMkuAB0AdAHwj6J5gVvWSUBJdAL4FeCvp7mBV9yCgJHgJ9CPShoD+EWdFHjJLgEdBHQB8JuoJZ0ceMkuAx0MdAHwv6G5gVfcIoCZ4AfQL0iaCvYVb0KaMkeAr0KdCngn4aZkWvGCXBFdAroFeC/g5mRTeMkmADdAN04+xUh+8/vMHiWg7/f6ZSNZfR5/bNWloMU6JnaOZZ+XvNzfyVStWMjNTXGNmzniVKBL7F4N+pVI4u+Ydl+xtyEHgbtkHacB2nDW8jbXjhB/VCRO9INv/SZ/MvyUS//G5523/SVIiYl2uVPfcVG6tIvJEqtYe36T+N+V880lqCvZHpeW6nbM9rpxj6HjHdto+pPiF1OfmtpKgbF77WzNHgNS7l2ul3TwpL2fgtIy3/+7e8cqfYNgg6xZcm9L07Xv63vbjqaHpbVSdt6qKW8gwkeI5rNSOpmTa9/5nGeyRI3PYwAQu/XRbS2L5sl2VH8xB/Dsnz8hFkL0NhlmuVzfEibmFpzRxJy0JzK9opV6vwDVRXlKO4mbmlc704nZPTtZlMzcwy4sQS3KxpgQaY8oE9YkydvvLjt7G1d6XqJAaWxg6q793sIeHNLV/g+VRlN+OLGfpwMah+f6h1YyUf6NtGN2+s/MaNlfwvN1Zy28Z6Dxtr8N9trC80bqzkpo21FW+sAhuriDbWyDbWsGmBCkx50bCxgi+PyesDjUu8z2xjFU0by38zjD7u/5Z+/w06ccLq1SgAAA==","debug_symbols":"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"},{"name":"note_hash_exists","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"note_hash","type":{"kind":"field"},"visibility":"private"},{"name":"leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zVOMRKAIAxLoXAMHrOLi8LgA1z9//kqmwK9K+SaNGlDBEqC1YFZahNUZPuE/WIhA8FaKmSNOkluhT5liI4oVEeWgHTas3UMh6IPCaXXPSPBI3KD0EITE3jCoHzRBY44Dxfh/rF/Nqh/GMYAAAA=","debug_symbols":"tZBNCsIwFITv8tZB8tOYNlcRkbRNJRCS0qSChN7dRKsIdWl3b958MMMk6HU7Xy/GDT6APCWwvlPReJdVAnwg9PkNo3LlEaKaIkiCmWgQaNeXu6LHBcFgrAbJKF/Qhq8JWema4w/b/EIF5XxlBcPkGz6jUoj9uxDfZlT7ZmRxU5NRrdVl5uLNrnuvnmW8jy8nsw8="},{"name":"nullifier_collision","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/zWNsQ6AMAhEH21jjENnFxe1m6ur/x+/Ss4Wkndc4AgnGWYHNkZpQmXyZuIhnJvkWMVi1LTUVWojRv6dgmV3WW7ixSUpXQ+l1ld8sxrsGYUAAAA=","debug_symbols":"vZDLCoMwEEX/ZdahZHyN8VdKKVFjCUgiJhZK8N+btPYBdd3d3LlncbgBetUul7M2g3XQHAOMtpNeWxNTAH5A/vi6SZr0cF7OHhrEStQMlOnTTXmxMhj0qKDJs3JlP3zBa7HhBeKHFnswlUQbTBUX3/CJJSXcVyKq3ko1Zv9SiuEqZy3bUaXNUreY7jVhjP42PZvI3gE="},{"name":"assertion_failure","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/63Va07bQBQF4OtAQtLYzsOxYzsBkjZeQvuzq+gGKrVVK1Ug8VgMv5FYDKtizp25PoClSJawZGZ8fb55hERzkBOR8UDcdS7hck9jSWXkmgj3d7GefylRKpGVGrxU1YSYnHx2fyZfxQY+IC0ydC06o6E+D9F19+kBS5ANTGNLOBMt4pr4IfAINj7wjRvwh2s/+fBZCE+bgS/KlGzqMxPfVfqXZaOxUgRi0pg0DvQfy0YTpQgkpAlpEugty0ZTpQikpClpGuiOZaMzpQjMSGeks0B/smx0rhSBOemcdO7bLkk+nLgF/mbZ6EIpAgvSBeki0BuWjS6VIrAkXZIuA71j2WimFIGMNCPNunvM2n/9EeJmu2bZ6EopAivSFekq0CuWjeZKEchJc9K8u9C8/bb0JEl/Mu1PsuPEfQz3LBstlCJQkBakRaD/WTa6VorAmnRNug70F8tGS6UIlKQladndY9l++EeIm+0Py0YrpQhUpBVp1Z2tan/dPUncnxTHidvTnmWjtVIEatKatEYLJ088JLYKhSeDHQVIS2PHhRvxVHhtdKrN26m2Htc2Kk+hLUMXPGwuR9q9DPldOMz2kQax0B1uXfGjf7Ltwuwbi51zYv9iEM7evbQzXKDFeA+vlvVuwd+isNvtF2y8fMb9At8RXb7PBwAA","debug_symbols":"zdy9ahtBFIDRd9lahLnzu+NXCSHIthwERjaWHAjC7x4pQUVI4fZ0Ozu3uNXpvjkvj7v79x/f94enl+Ny9/W8PL88bE/7l8PldF7Sl/nn5/F1e7iej6ft22m5a22OzbI7PF4+ex4fm+Vp/7xb7kpuH5v/p+ust+lW0mfTZabbdE39n+lvm8tGkbyVwlspeysVb6XqrdS8lbq30vBWWr2VPL2zp3f29M6e3tnTO3t6Z0/v7OmdPb2zp3f29C6e3sXTu3h6F0/v4uldPL2Lp3fx9C6e3sXTu3p6V0/v6uldPb2rp3f19K6e3tXTu3p6V0/v5undPL2bp3fz9G6e3s3Tu3l6N0/v5undPL27p3f39O6e3t3Tu3t6d0/v7undPb27p3f39B6e3sPTe3h6D0/v4ek9PL2Hp/fw9B6e3sPTe/X0Xj29V0/v1dN79fRePb1XT+/V03v19F49vaen9/T0np7e09N7enpPT+/p6T09vaen9xRrHTDXSWCvk8BgJ4HFTvIIjwQ2OwmMdhJY7SQw20mg42R2CTouhpdieSmml2J7KcaXYn0p5pdgfxlggBlggRlgghlggxlghBlghRlghhlghxlgiBlgiRlgihlgixlgjBlgjRlgjhlgjxlgkBlgkRlgkhlgkxlglBlglRlglhlglxlgmBlgmRlgmhlgmxlgnBlgnRlgnhlgnxlgoBlgoRlgohlgoxlgpBlgpRlgphlgpxlgqBlgqRlgqhlgqxlgrBlYrXk5/dy+7bf3z7vrq9PXy/fDw+0R6svx9Ov1781l9jc="},{"name":"sha256_hash","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"data","type":{"kind":"array","length":10,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/2WRwQ7CIBBEh0Jpi03PxsSkKty8evHg/8evcodd6EGSKQ8YloFmeGB+QtoV1laZwYYonaM+aCQwiNwG16YUB0qR9bxioBRHSpF1o+JEKc6U4kIpJkrxRBVGYcahWCj4XK/AXKEi3Ri5DgmAWClydJdPUft62Hfaj52TIptE9Xag5MeS4ehIrhoTp6gbvVlH3p6Ie1JptqgLoS8MFimhnzCxZ5bLCxZwPwKm0v6O1YKVxl9yzqa3b5fum2N/Fh4VKo3tKavPP4jnL/UDtbE6BxkCAAA=","debug_symbols":"nZBBCoMwEEXvMutQNKm1zVVKKaPGEggTMbFQgndvRvEAZjfv/3mbn2Aw3fJ5Wxp9AP1M4HyP0XrKlKC6qHZLw4TEQYg4R9C3tpYCDA18qmYVMFpnQCvZrC/B2r1MexRp16pMq8s0eVrL9MXZYucM78rlQv0xc8b4m/Ym//4B"},{"name":"get_args_hash","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"_a","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"_fields","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/02OsQ6AIBBDC8jhRBxdXBQ/wdX/j19le0jiJYXHcS00JGAuYG34ythB9S1INwYRIhUqwmh1jNKpOQV00nRykmdq/hKF7CgfTPfIVHHSR/LOZfGjYu1ShMkwer/heAjXR3oBKuTvN8wAAAA=","debug_symbols":"TclRCoAgDADQu+y7E3SViJimMZAtSoMYu7uCfvj5eApncOU6iKO8sG4KSTxmEm5SW+DDh9ClMBgL+2nzf/ex3So="},{"name":"emit_unencrypted_log","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"set_opcode_u64","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/z2MOQ6AMAwEJxdCFBElDQ0kT6Dl/+JV2CbG0tqrPdxIMAtgZ0wUhcokJyhunH0moRJc6mpaq48Y6ZC1dH8VLzWs18gr/2SLZEExVrRwKt0exQuJ8nvinAAAAA==","debug_symbols":"TclRCoAgDADQu+y7E3SViJimMZAtSoMYu7uCfvj5eApncOU6iKO8sG4KSTxmEm5SW+DDh9ClMBgL+2nzf/ex3So="},{"name":"nullifier_exists","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zVNQQ6AIAzrGBgSE+LRixeFk2ev/j++ynXAkm5N124VCuQIqwOjqKBgsSHEi8mMBIMUyJQal0yFNmxQZzTG09ra0HNZHy6UFzZq6Wbn82RYKoTxmHid7/vK425wRj1cpPtH/Fd77KjCAAAA","debug_symbols":"tZLbCoMwDIbfJddlND3Y6auMMarWUZAqWgdDfPe1m5MNd7jZ7vInH+SDZITS5MPxYF3V9JDtRqibQnvbuJBGoBvEa7dvtYuN3uvOQ4Y0VYqAcWWokVI2EahsbSDjTE5kxQsm6YwLlqiFTl/BCUc+wwnnT/CeRCX2RknggxL/ooSIYsEV/aykhJIzrCRu10r890pyvUX8e0sIJ91Zndcm3j/OBlfc3yFEf25vk8BeAA=="},{"name":"set_storage_map","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/83Y227TQBAG4HVilzRNQ0ntOHFOjuNDaSmCCxASlAsknoAnQOJww0HiIN6Rp2Jndsd/gltXexPV0tab8Xw7u+tG1TZXXaV6gdLXQtnL1xE1VAf65lF7raSnOx3dvKHyJDTkAbgVlEcDdAorlImR8bmn81SQ6R/HhTKD9fxn9MCnYXMaiyv0CpmMnkXXdnlsk0Nj38vxJFeB2r1owENehDo0rWtG42H6Rcc+6GPAvsnpmS7dm8RvJztTksUcvfS3cmi8o+Z86To28z2mFnC3bz8Oci6n7gd8H1BXt6Ep8kq3Ub1jJ9ix0e6OPcD0RnrAd/p+apJPbHLIizylHlhockamy/QXwkIjppQQgUagkaXfERY6ZkoJY9Ax6NjSHwgLjZlSQgwag8aWvkdY6IQpJUxAJ6ATSz8jLHTKlBKmoFPQqaUfERaaMKWEBDQBTSxNERY6Y0oJM9AZ6MzSnwgLnTOlhDnoHHRu6ReEhS6YUsICdAG6MPcmidxJ6E6SdqLX9ARhoUumlLAEXYIum9WWdbUWoqt9Q1joiiklrEBXoKtmtVW9g44kdCeJO4ndyXwv5JYd0+/nD8JCU6aUkIKmoGmzWlp/i1uIrvYBYaFrppSwBl2Dri19jLDQjCklZKAZaNacaFa/Ykdy6k5CdxK5k7E7id3JxJ1M9/JeZu5kvpf3Eu5lLbfsmP7efEVY6IYpJWxAN6AbS38jLDRnSgk5aA6aNyea12tzJKE7Se7qxGJ3Mr4LO6Z/Cz4hLLRgSgkFaAFaNKsV9ZocSeROMneStBO9DU8RFloypYQStAQtm9XK+k9WC6HH3lucZ64YKhxi5NRC2Vzf2JyPY3JVXKraLXVmcGm68oQOTGdIOse56OKAuxc2/5HeCMq49DjxkkLUeMZvzCdZLpnLQtIeorB50DFBeigVzume6pFebE3rvwk/9+xqr8zhMDCnQZl6VW9TgG2qdo99w3z7SdcOUtVvZ3Dt26nsLKozzwo+8OJYi9L9G0sPGqX7O6UP20tfR/x2gvmV9bG7soOY3yn6xP+N4KE6G+pO/lL7B7qE978NEQAA","debug_symbols":"5dzfahNBGIbxe8lxkXnfb/72VkQkapVAScVGQUrv3USzaaXV9KBuecxZk0x3vklYnj363Sw+XLz7+untav3x6npx/vpmcXn1frlZXa23r24W6ZXi57vXn5fr3RvXm+WXzeLcEeVscbH+sPuzxO3Z4uPq8mJxHi63Zw9Wj+j7xaP3w1rl/MhalbRfq3G31h6PXTePPF243JvCOd2+OdsNn8nDF/LwlTx8Iw/fwcM7kYcXeXiThydHyuRImRwpkyNlcqSMjtQADx/kwsYzFFapxjSRnI6MPw2fjly1pekrabvPD9es+8GDOnimDl6og1fq4I06eKcOPqCD50QdnBqgbOrg1HJmajkztZyZWs5MLWemljNTy1mo5SzUchZqOQu1nIVazkItZ6GWs1DLWajlLNRyVmo5K7WclVrOSi1npZazUstZqeWs1HJWajkrtZyNWs5GLWejlrNRy9mo5WzUcjZqORu1nI1azkYtZ6eWs1PL2anl7NRydmo5O7WcnVrOTi1np5azU8s5qOUc1HIOajkHtZyDWs5BLeeglnNQyzmo5RzUcipR06lEbacSNZ5K1HoqUfOpRO3ndlPs5NSCKlETqoRtqLANFbahwjZU2IY+B5DzQpNjGypsQ4VtqLANFbahxjbU2IYa21BjG/ocfs8LTY5tqLENNbahxjbU2IYGtqFYqkeBbShWGRKWGRLWGRIWGhJWGhKWGhLWGhIWGxJWGxKWGxLWGxIWHBJWHBKWHBLWHBIWHRJWHRKWHRLWHRIWHhJWHhKWHhLWHhIWHxJWHxKWHxLWHxIWIBJWIBKWIBLWIBIWIRJWIRKWIRLWIRIWIhJWIhKWIhLWIhIWIxJWIxKWIxLWIxIWJBJWJBKWJBLWJBIWJRJWJRKWJRLWJRIWJhJWJhKWJhLWJhIWJxJWJxKWJxLWJxIWKBJWKBKWKBLWKBIWKRJWKRKWKRLWKTLWKTLWKTLWKTLWKXKiNtRYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYp8hYpyiwTlFgnaLAOkWBdYoiURsaWKcosE5RYJ2iwDpFgXWKAusUBdYpCqxTFFinKLBOUWCdosA6RYF1igLrFAXWKQqsUxRYpyiwTlFgnaLAOkXxBKeotmOTb3s2TR61/7bLw9Wl5rZfXWrNh9XjsUuPov3acW+pI0/j1/nHV7obv/x9/JLbYXFJRxb36um36rWl+4v3h22ndNh+SocdJ3TYJ8BL/9FhdUqH9SkdNk7psPmUDltO6bCPP0FlTQ9pzj0fO+zQ9NVo3HvQ9WGTNscmfY5Nxgyb/IFVeuZNNMcmnmOTmGOTPMcmZY5N5rjj8xx3fJ7jjs9z3PHlH9/x2xffll9Wy3eXF9fbf9l99nX9frO6Wu9fbr5//vXJdu0P"},{"name":"get_storage_address","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zWMOw6AMAxDX38IMVSMLCxAj8DK/cWpiEMbyYnlTy4SzAbY6RNNoTLZCcLDYL9JqIQhNZneaj1GOmwtbbyKtwzvrdKyO9lQnBXlTtHtFT4vKO/ykwAAAA==","debug_symbols":"bc7RCsIgFAbgdznXEupRK18lItzmQhAd0wUhe/e0VhB1d/7zfxd/gcF2y/XiwhgT6FMBH3uTXQw1FaA7Rp/fNJnQHimbOYM+IJMEbBjaKehKYHTegkYuV/KjBZd004Kr/Ucf/2GFDDesEL/wuYabmZ3pvG3zWreE/r22xnyfXk21Dw=="},{"name":"assert_timestamp","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"expected_timestamp","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/63VWU7DMBQF0JfSuWmGNmlaOoihWQJ8shcESPDBIMEu+EZiTawK32e/XqBSpUhEcmxe7ontILlbORLpuyaylnChIol0XRehXYmN3KDlWpRIZKVE2q5rodXI4QV+hPSRjmDaZ+42uhCbrcKt04GWDp671t1ibpm7NqhtNT1dkF4D3HwGL+9v+WQr0Zvrhz7cC+FR3fJFGZGNfGbgh0ofWDYaK0UgJo1J40AfWTY6VorAmHRMOg70jmWjiVIEEtKENAn0lWWjqVIEUtKUNPX9PhkeJm62a5aNZkoRyEgz0mx/tmz3WQ4QN9sLy0ZzpQjkpDlpHugJy0YnShGYkE5IJ4Hesmx0qhSBKemUdBroM8tGC6UIFKQFabH/eYrdv74hSZqT/DBxe3pi2WipFIGStCQt92crd5+hIRk2J3lzEjcn6b/vxX3sG5aNzpQiMCOdkc4CvWfZaKUUgYq0IsXJOzjFqfnJM3ehUHjQ2smq53Rtp697Y1t4zXWq+e+pFh5X9lYe6guGljy7V10drkJ+7XaFxCbS4Cb8Mq11xR/+L9suzKa22DEn9g9avoiHNsMSPY6J9x/L+rPgyyjsdnGOjc+/0L4B+mjfEykHAAA=","debug_symbols":"ndnNasJAFIbhe8laynzze8ZbKaWkGktAomgsFPHem1QrLXX17vJzDsziWb1zbtbd2+n9tR82u2OzfD43292qHfvdML2dG/ckfX897tth/nAc28PYLGusadF0w3p6TIqXRbPpt12zDD5dFv+mo8nfpqP5cJ+uj4az5XAbzmb6PfyymA/kHx4oBd0PlP2fA13XAluLbC2xtczWClsztlbRmndsTWyNKfFMiWdKPFPimRLPlHimxDMlgSkJTElgSgJTEpiSwJQEpiQwJYEpCUxJZEoiUxKZksiURKYkMiWRKYlMSWRKIlOSmJLElCSmJDEliSlJTEliShJTkpiSxJRkpiQzJZkpyUxJZkoyU5KZksyUZKYkMyWFKSlMSWFKClNSmJLClBSmpDAlhSkpTIkxJcaUGFNiTIkxJcaUGFNiTIkxJcaUVKakMiWVKalMSWVKKlNSmZLKlFSmpDIlcg7uCe7BsOZgWXMwrTnY1hyMaw7WNQfzmoNeBL0IeqEhlpZYmmJpi6UxltZYmmNhjxUMsoJFVjDJCjZZwSgrWGUFs6xglxUMs4JlVjDNCrZZBXrRA73APCvYZwUDrWChFUy0go1WMNIKVlrBTKtIbwahF1hqBVOtYKsVjLWCtVYw1wr02untoz307du2m6+555+nYfVz6z29jp/7659p9gs="},{"name":"check_selector","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/82Yu28jVRTGx5P4Mdf2JHES52UnduLJa5LNhmhBouAf2AIoqGiQgAYhQCwFFfwJdBQUSEhUSAiBRA0SAiEkJGiQaKgoKVfQMt+559xvxo5G2qXB0th3vvl+9+XxOcczi5aiqBNHxWsc6as460Rp1Co+GjieiazlL0aNNGqYlOGiUJnaoqXD4i25F1nHM4wBImplNkYzEhGvFt6yWPtu0h3f5o6DG0pzgNMlz8S1jPcsF0c7K63UPO25mc54ZSYKVmmjwJzIJLD0hFjiPW3fxOf/FOF+Z7pZWGetu0VPFHYRluVJ8XbD/W212MQoUxj/RgvGp7KGDhjfNnSHQ3dklIaetehp3/Yl6xfYjBZf7dRPPiylXb3RktBfh/0lt/cnft9fEjYbrQ63xkl/zrbmPrcm4dbIxsrW/IoWjM+GrVlOgy/2g8l35VUxNINhiYvZeLy7+4XHvLsL9A3KhrqwJY6oI+oUfZWyoV1BYegS7RLtKvouZUN7gsLQI9oj2lP0LcqG9gWFoU+0T7S/+Bvrh4nWIMVoL1M2NBUUhpRoSjRV9B3Khq4ICsMK0RWiK4sTXQkTrUGK0V6hbOiqoDCsEl0luqrohLKha4LCsEZ0jeiaog8oGzoQFIYB0QHRweIaB2GNNUgx2uuUDV0XFIZ1outE1xdHWw+jPSLSf3QkrUeKNb1J2dANQWHYILpBdEPRtykbuikoDJtEN4luKjqlbOhQUBiGRIdEhyHc/cJ4JfYQr9qMV0PJ8ha5ih6XSyF4S4baqg617eGhb9oVLGWbpl3GvT0fiffUPypWBce4IUbUQiMcMuOf/ZktF8w4M9sOB/YXYi/ioo2wi0/8Tr4rTWtuwk9aots8ui0ztRcyk8V/15Cms7zS5hVERFnB72jJCFE1E/Q8nGgA7Hq4p1Jf4D/QIhwCbTukqzZn0/f72rUYJz38iRZ74FZ2JSBqBCzn1W7WsPwTi9jVC2kUcnlayb9NEgtZW0ZOfe+g0jgMlFaKAs2Cy5YwuJeS9GQxD9EqbUelDLr/36qbSage5qoRV/3aklKxUdy5vzEfdtRclw+dLg/o05QNrcuHTr9Xpwm8X0XrkpvT3Qb6BWVD65Kb00QE9APKhtZlKqeJCOjnlA2ty1ROExHQK8qG1mUqp1kF6BFlQ+vSjtPgDfR7yobWRXenoQVoQtnQuujuNBoD/ZCyoXXR3WkUc/o/aVhFfbSGYYvoFtEtRf+hbOh2CPTbC4HeadwEeo+yoTuCwrBDdIfojqIfUTZ0N0Tw3VLmILqr6EuUDd0TVKI90T2ie4q+SNnQUWapZUR0RHSk6MeUDfUpB4Yx0THRsaIPKRu6LygM+0T3ie4repeyoQeCwnBA9IDogaJnlA2dCArDhOiE6ETRrygbOhUUhinRKdGpoq9RNvRQUBgOiR4SPVT0ecqGHgkKQyk3HxE9UvQ9yobOBIVhRnRGdKboD5QNzQSFISOaEc0UfY6yoceCwnBM9JjosaKfUDb0RFAYToieED1R9H3Khp4KCsMp0VOip4p+StnQM0FhOCN6RvRM0b8oG3ouKAznRM+Jniv6gLKhuaAw5ERzonkU/sTKPdmqlFY57iVZTD5f23TUlmfaY7lEumA3F8VxKd18htZ8hQbLJWd24f/0txS8IyBS6Z1ido0vpW7AgnKcfhvKiJxlxGW1jLjLMuLaT+paTU9oPXzj6+EbSDhkyG/8mRVxYG4ys135C3m4EHsRF20EhJNrTPJrmenCY4Jc134VCrOr0sOLqPJ4aa5Gk6dNjR/RmitZ86j8tCtmh5dcyqUUbvYHL557xIXT7Z9w/AtjkpBVNxUAAA==","debug_symbols":"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"},{"name":"enqueue_public_from_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"7ZzbTttAEIbfxdcI7czOnniVqqoChCoSShAJlSrEu9cOsZ2jR7jbelaTKwiZ9c73YfC/Sbzv1eP8/u3nj8XyabWu7r69V8+rh9lmsVrWj94roO3P1i+zZfNwvZm9bqo7c1PNl4/114+b6mnxPK/uLLqPm5M6G7EttdH5rjrRx/ebCtw/PLY/d2wgE3E3CAg8N0dwwe3Kgzd9dbLbOUKeOTwOzBGzzOEB2jki2P05TosRrKddNYJLcKw2TdCSB9u15P1BS2dODepPDfL9sesez3USqGukP43g0z8aTbCgCRY1wVpNsKQJ1mmC9ZpggybYKB7W+bbaehNY2LAr3u8D/blGwIfUQgbEvhr8lzXKz2YlaLTyU18RGuXnySI0yk+qRWiUn4GL0EhXjTk0ys/tRWiUvyIoQqP8tUYRGjWvYoKjTmNwBxobNZpXJsNqSPNqg1GjeQXBqNG8KmDUaE76jBq6qrmkRnMiZ9RoTtmMGs3JOZr24xEQ0Z+o0ZyGGTWa0/CwGqc5DTNqNKdhRo3mNMyo0ZyGGTV0VXNJjeY0zKiRn4Y9xU6Nd4waS71HOFDTwMrPtxlh5SfWjLDyM2g+WC8/VWaElZ8TM8LKT34ZYeVnuYywpAlWft7KCDtJggrQwcaIw7BoI/i23EYX98sbglAAQegJErpjgiifINk2tCMZOPkdJPEEZKzvCUI4IghGPgEa7AgwmGMCKIAgxo7AOjwmQPkEyXdnkTNkjwmseALX94IOwvFfcpjiSp+6mxfq7+mkJSevpSmumil1EaH+T8BEhH0AA30xhO1lP4TSAWLpAKlwgHjhignBdADoiAOoi1oA8DgMYENXbKNJfUcNykl1otS+XZyc23ulsU7JTf9QeP/43/uvj92ebYQW/rJ/m6f/1PWPEPb7b+agPHN0H0s9N4fLMgdiG40C7akdtS9A9BO0NNX9ijFogo2aYJMi2GQ0wYImWNQEazXBkiZYJx62hBuTkvxsVoRG+amvCI3y82QRGuUn1RI0gpEfgsvwKD9fl+FRfnQvw6P8VUEZHunqMYtHzWuZ4bvowGheoHBuNK86ODealxKcG83rA8YNaM78nBvNOZ5zozmbc240523ODSl2M3w7HYDmXMy50ZyLOTeaczHnRnMu5txozsWMG9Scizk3mnMx50ZzLubcaM7FnBsS7ybfbY+A8pNuTlr52TUnrfw0mpNWfr7MSSs/MWaktfIzYE5a+akuJ638nJaTVn7yyklLU9Dm3FUBrCsAYXBbBbBePsLwvgpgg3gEZmMFsFE+wvDOCmBTAQiDWysAGfkIw3srAIF4BGZzBaAprvnDWxkAWYE9TXH9zHlzPJArncDfXngXeW+HAji4id1tx8XbCyvSAN3rT+nola3duDRu3IVVEj8ORo7DEeOiHeczunE+m3Fp3LhRPptxMHLc133Wj37NXhez++f5uh7TPPm2fNgsVsvdw83vl89n6to/"},{"name":"set_storage_list","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"a","type":{"kind":"field"},"visibility":"private"},{"name":"b","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/31PQQ7DIAwzUDpgUs+77LKBtA/suv9rr2qcgNpKVSMFnMTGoSIAaYLEEz2kSlgwy+WYPwwkwEu6BW60GodU+dZpCIpInBSJA+JLjvsXw6wi4hjkz+pqWbmZdnMbnBu0ycj2Ckt6prqfBOMqqTRvf0LZ6MU42eC5JF5LPq4rdPE3d3z8mStLICLzUwEAAA==","debug_symbols":"5ZfRCoMgFIbfxesYanq0XmWMYWVDCIuywYjefbq1GCzYA5w7/3M+hO/uPwtpbDXfrs63/UTK80K6vjbB9T6mhdATY6/pNBifBlMwYyAlp1JlxPomPQu6ZqR1nSVlzuWa/dAsZ7DRLAe900zAAS2B0Y2WAHKni6OvpVA7LOkfWAPXG6xB0W/4kiXXHJGrQOQqEbkCIleFyFUjci3wuHKKyBVRl+AckSui3sQFIldEvYkj6U0x3M3oTNXZdOGl3ezrz8EXY3gM701knw=="},{"name":"get_chain_id","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zWMOw6AMAxDX38IMXRiYGEBegRW7i9ORRzaSE4sf3KRYDbATp9oCpXJThAeBvtNQiUMqcn0Vusx0mFraeNVvGV4b5WW3cmG4qwod4pur/ABkH68nJMAAAA=","debug_symbols":"bc5BCoMwEAXQu8w6FG3iVHOVUkrUWAJhIiYWSvDuTVpLBd3Nn/8WP0Kv2/lxNzQ4D/IawbpOBeMopQjFqSw+Xz8qyg8f1BRA1peyYqCpzyfnC4PBWA2Sn6uF7bRAzlctUPx1c4QRsVkxYo1bfEvhqSajWqvzvNzN1P3Wphhe47dJ9g0="},{"name":"nested_static_call_to_add","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"arg_a","type":{"kind":"field"},"visibility":"private"},{"name":"arg_b","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"get_block_number","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zWMOw6AMAxDX38IMXRELCxAj8DK/cWpiEMbyYnlTy4SzAbY6RNNoTLZCcLDYL9JqIQhNZneaj1GOmwtbbyKtwzvrdKyO9lQnBXlTtHtFT7vVi1GkwAAAA==","debug_symbols":"bY5bCsIwFET3cr+LNLbNaysikrapBMJNaVJBgnv3RisK9m/OzPmYDKPt1+vF4RQi6FMGHwaTXECiDPWB1a82zgZLEZNZEmgpVVOBxZGiYt2jgsl5C7o5Uv6zW9GxzW4F/9pqT+ZCiU3mkslf+UxwM4szvbflXtlWHD5vCdN9fi/kPgE="},{"name":"debug_logging","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/73W2W7TQBQG4CldiOM0BZp9IU1it9na7DHigndhFSAEEosAIV6Qp2LOmTnz13JkaXrRSMHmzP+dccYTp5E6VKrwQOlXV9mX/l9BldWJPhzQ+4WSMzOoDsrqQEoxDbKKbUwdDvQ/wVZJ44jmUIF+n8Qyx5HiIr1OkCF9HGEkUgcf9fGhCR/ZcCF+YIqqAFYwmRN7OUR/oCw0YEqBADQADSz9hrLQIlMKFEGLoEVLv6MsNGRKgRA0BA0tvUBZaIkpBUqgJdCSOWZJMZ/o2d6iLPSUKQVOQU9BTy39hbLQMlMKlEHLoOXshZbdheaQ1G6Q0zO3j8rYR2fpffQokbkC2+vMDNJinrsGj9HgPN3gSXR75NBkOVRxW6GCeMVkzs3pflLKJ3plX6MstMqUAlXQKmjV0i8oC60xpUANtAZas/QzykLrTClQB62D1i19g7LQBlMKNEAboA1Ln6MstMmUAk3QJmgzu7JN9w3JIXq2PygLbTGlQAu0BdqydImy0DZTCrRB26BtS/+iLLTDlAId0A5ox1DZvbdOu27XdrBru+ld+xS7thepY5V+UeKCH+3qwrwP7Yw9/e7zldFAHw37JtMzp/uaEuqbpn0AaTrgpjQwQNMBmg72N6XhgWk6AJCmQ25KA0M0HaLpcH9TWsShaToEkKYRN6WBCE0jNI3omMitDK3smiw9fWJ3f3q4P3H6/kS4P7HeHz/18RJTUPiKL+OSzsCuTCY2p0zfoyx0xJQCI9AR6Mgcs6SaT/Rsn1AWOmZKgTHoGHScnW3sHoOeJMwn+gJfoix0wpQCE9AJ6MTSrygLnTKlwBR0CjrNXuidyTif6Av8jbLQGVMKzEBnoLPsbDP3cPUkoT9p+pN2PsFjcOa+ZjG+ZrP01+waX7MbNNKnau4ecnPE5yZzY073k74/GfiTYT5JZN3OZG1Mlp5NC7cuN1iXRXpd5tHtEWlNoaX7a2yJ+NJkFuZ0PxnnE719X6EsdMWUAivQFegqO9vK/dXlSUJ/MvYnNX9Sv5fPcocLK/mTS38yyid643xAWeiaKQXWoGvQdXa2tVsGT1LyJ0E+0Z+piLLQDVMKbEA3oBtLA5SFbplSYAu6Bd1aeo2y0B1TCuxAd6C77GfcuT2YQ/Rs71AWmjClQAKagCbZ2RJ3qz3JxJ8E/qToT9b+ZONPtv4kvJcVK/mTij+p+pOaP6nnE/zMJu5XeYFf5ST9q/wskQkiaTIk1vhH7/+zEl55pBMAAA==","debug_symbols":"zZzNTpxXEAXfZdYo+m6f+9PNq0RRhG0cIaHBMjhShPzuGScmUhQjL5J7UjsGPji9qZrNFM+nd7dvPv3y8935/cPj6frH59P9w9ubp7uH8+XV8+n4of745uOHm/OX149PNx+fTtdjZl2dbs/vLl+uHp+vTu/v7m9P14rx+eofT9fS14er8q9nQ/Mbz67x8odXrb89+9PV5Zp2sM5prHOCdY5Y53TWOYN1zmSds1jnJOsclpWDZeVgWTlYVg6WlYNl5WBZOVhWDpaVg2XlYFlZLCuLZWWxrCyWlcWyslhWFsvKYllZLCuLZeXOsnJnWbmzrNxZVu4sK3eWlTvLyp1l5c6ycmdZebCsPFhWHiwrD5aVB8vKg2XlwbLyYFl5sKw8WFaeLCtPlpUny8rz21ZeI17OycjvnPO9ib5/YuyfmPsn1v6J3D9R2yfWsX+i7Z+I/RP76V776V776V776V776V776V776c79dOd+unM/3bmf7txPd+6nO/fTnfvpzv105366az/dtZ/u2k937ae79tNd++mu/XTXfrprP921n+52HIaNZtgIw4YMG92wMQwb07CxDBtp2DBw3gycNwPnzcB5M3DeDJw3A+fNwHkzcN4MnDcD52HgPAych4HzMHAeBs7DwHkYOA8Dg2FgUAYGZWBQBgZl4EMGPmTgQ4b3QRkY7AY+uoGPbuCjG96juoHBbuCjG/joDj4M71HDwOArn69L5ctGtX+9EYYNGTa6YWMYNqZhYxk20rBR+zde+XDXf7th4HwaOJ8GzqeB82ngfBo4nwbOp4HzaeB8GThfBs6XgfNl4HwZOF8GzpeB82XgfBk4XwbO08B5GjhPA+dp4DwNnKeB8zRwngbO08B5GjgvA+dl4LwMnJeB8zJwXgbOy8B5GTgvA+e1n/M4DsNGM2yEYUOGjW7YGIaNadhYho00bBg4bwbOm4HzZuC8GThvBs6bgfNm4LwZOG8GzpuB8zBwHgbOw8B5GDgPA+dh4DwMnIeB8zBwHgbOZeBcBs5l4FwGzmXgXAbOZeBcBs5l4FwGzruB827gvBs47wbOX/msWsXLxjya9f9qD9g9E3bPgt2TsHuKdc8rnwv8/+5psHsCdo9g98D8PGB+HjA/D5ifB8zPA+bnCfPzhPl5wvw8YX6eMD9PmJ8nzM8T5ucJ8/OE+XnB/Lxgfl4wPy+YnxfMzwvm5wXz84L5ecH8vGB+TpifE+bnhPk5YX5OmJ8T5ueE+Tlhfk6YnxPm54L5uWB+LpifC+bngvm5YH4umJ8L5ueC+blYftbB8rMOlp91sPysg+VnHSw/62D5WQfLzzpYftbB8rMOmJ8bzM8N5ucG83OD+bnB/Nxgfm4wPzeYnxvMzw3m54D5OWB+DpifA+bngPk5YH4OmJ8D5ueA+TlgfhbMz4L5WTA/C+ZnwfwsmJ8F87NgfhbMz4L5ucP83GF+7jA/d5ifYf2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP2gYP1gh/WDHdYPdlg/2EH94OXVrzcf727e3N8+Xn7jyw8/nd8+3T2cv758+u3Dnz+5PPs7"},{"name":"add_args_return","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"arg_a","type":{"kind":"field"},"visibility":"private"},{"name":"arg_b","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zWOwQ6AIAxDCwzCwXD24kXlE7z6//GrbAcsGbx0ZeVGAmoG68Aso4KGwiuoXywiRHZoCEvqGupV7NOG5CSjOTEB+eSxdYwN1R4NTLugIGVCvyhukZKdpMVLuH/qHx2AjF+wAAAA","debug_symbols":"NYxRCoAgEETvst8RZkXQVSJiKwtB1kgNQrx7a9HfvJnhRVjVHPZJ02Yd9EMEYxf02hJTBFFW8m3dgZQL5/H00NdCdgUoWnNsRCpg00YxyDaNTBeeGmejsiSPgZbfyejv41v4+wA="},{"name":"helper_with_failed_assertion","is_unconstrained":false,"custom_attributes":[],"abi":{"error_types":{},"parameters":[],"return_type":null},"bytecode":"H4sIAAAAAAAA/33OQQrCMBAF0BS8hZt4g0xmppnZeQgvkNAJDRQLRu8vYtFV+zZ/8+H/wf0Nbt91SwwjkaVogJBD1CIciMsoIMDCUxREE5KkRVNQIDSorFjD12fj5I7t/ThveZtb97l3ezzbevd9Xl/L5Gtuy+XXfQP4jlSZ2AAAAA==","debug_symbols":"ZY3BCoMwEET/Zc85hCYpmF8ppawaSyBsxERBgv/uRvEg3ubNPJgCvWvn/8/TEBPYT4EQO8w+ElMBeVRpRKqUMk4ZrNGNFuCo52iU3AQMPjiw6mU28bRVIy9by/fN/jItOHlsg6t/dZypu+4Z8zqeC7s7"},{"name":"set_storage_single","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"a","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/1WOwQ7DIAxDTRldukPPu+yygbQf2HX/r35VY0PUNpLBSh44FRkwF/DCKHawYvYrUX+EczO50ooUrcYhX01tYMhyBG9vPx4/RERFwbXIF2VpVCrT1bUWzKyVVNZ/CeZez5PcWUFLUz7dgS+dsW5h3zReaIsPA58btQNK9qmcFgEAAA==","debug_symbols":"5ZZbCoMwEEX3km8peY6pWymlRI0lIFE0Foq49yatSqFCFzB/c2cOA+fvzqS25XS/Od90IykuM2m7ygTX+ZhmQk+Mvrdjb3xajMEMgRQMGMuI9XUahVwy0rjWkkJwtWS/tGCw0QL0TjMJB7QCRldaAaidPh+9VjLfYUX/wBq4XmENOf2Gr1ly5YhcBSJXichVIXIFRK45IleNyPWMx5Uj6hKc4XCN4WEGZ8rWpsaYbpOvtgIZY3j2n0tkXw=="},{"name":"add_u128","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"a","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"},"visibility":"private"},{"name":"b","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/52W3Y6TUBSFDy20jJ1C+SnQUpy2wiPope9iokYTjcYYfSivTXwGn8r9czZrlISkklB211nfWfswyez2bulcHDu6OuevFSkukUfA90tnFRULuoPEBSYNvMjUYvA2t5SKjaFUlOAiqULeXaqIPtZX+kgHp7vGsiDtrJ+zZaU6P0LtysWJlJy3kgZ1NdBFM/Yu8icJHK47Be74Dv0x5VuspXSksm3MO0YaGWm6qatoNMlKz327E92bwQLXchi5NvyhHm7pSY+V3gWv6Hmv5rU3b4eFim4LbKuejZaCfoVsaCIoGxKgCdBEnzcjlPYGsqGpoGxIgaZAU49+hGzoTlA27IDugO48+hmyoZmgbMiAZkCz6Rmz8YwzCKWdIRuaC8qGHGgONJ+m5WPaDEJpnyAbWgjKhgJoAbSYphVjgzci9/MINfgasqGloGwogZZAy2nafyPZPEINfods6F5QNuyB7oHuPfoesqGVoGyogFZAq2mj1finnkEo7R1kQ2tB2VADrYHW07R6fC03Ivk8Qg1+g2xoIygbGqAN0Gaa1oz/EGYQSvsC2dCDoGw4AD0APXj0LWRDj4Ky4Qj0CPTo0Q+QDW0FZUMLtAXaTs/Yjm/0RqScRy48EX5hnnQCOgwRmxrsdoNNFtoxfDToThJ1+juqU7i1XTGwOpgeMJfOKynP3n+hd8eOayBGHtzc7EU6/qnf7LjMXAezPUWwLixU5EVLeOAnFz8etfVPwy8Cf9pOzh3abwodyVJF9itERvTyGZfNb77/AHq77ZzmCAAA","debug_symbols":"vdzBattAFIXhd9HaFJ2ZuTP35lVKKUriFIORQ+wUivG7V2oTbZRdlH/nsQYOGH+7H127x/3966+fh/HpdO7uvl+74+lhuBxO43S6dv032b9vz8/DOH9xvgwvl+4ut1x33X58nD8W3Xbd0+G4nw7JbrvV7eJhb7dL9LHcLu32Yzdv1A02IvmykX290YAN32Kj9ctG+2AjttiosWx4W20kARvp8xvW6/23sj6V9UbeeCOn9UbZYsO0bNQPNgzYqFtsuC8bsf7vpgZsOLARX7+Re2BDwEYCNjKwUYANAzYA5xlwngHnGXBeAOcFcF4A5wVwXgDnBXBeAOcFcF4A5wVwboBzA5wb4NwA5wY4N8C5Ac4NcG6AcwOcV8B5BZxXwHkFnFfAeQWcV8B5BZxXwHkFnDfAeQOcN8B5A5w3wHkDnDfAeQOcN8B5A5w74NwB5w44d8C5A84dcO6AcwecO+DcAecBOA/AeQDOA3AegPMAnAfgPADnATgPwLn6nhgRMZKIkUyMFGLEiJFKjDRixIkRQrwI8SLEixAvQrwI8SLEixAvQrwI8SLEJ0J8IsQnQnwixCdCfCLEE6mciFZORCwnopYTkcuJ6OVEBHMiijkRyZyIZk5ENCeimhORzYno5kSEcyLKORHpnIh2TkQ8J6KeE5HPiejnRAR0Igo6EQmdiIZOREQnoqITkdGJ6OhEhHQiSjoRKZ2Ilk5ETCeiphOR04no6UQEdSKKOhFJnYimTkRUJ6KqE5HViejqRIR1Iso6EWmdiLZORFwnoq4TkdeJ6OtEBHYiCjsRiZ2+urGbDr+Hl8Nwf9zPb4CYn72OD+8vhJiOlz/P/59Md/8C"},{"name":"inner_helper_with_failed_assertion","is_unconstrained":false,"custom_attributes":[],"abi":{"error_types":{},"parameters":[],"return_type":null},"bytecode":"H4sIAAAAAAAA/33OQQrCMBAF0BS8hZt4g0xmppnZeQgvkNAJDRQLRu8vYtFV+zZ/8+H/wf0Nbt91SwwjkaVogJBD1CIciMsoIMDCUxREE5KkRVNQIDSorFjD12fj5I7t/ThveZtb97l3ezzbevd9Xl/L5Gtuy+XXfQP4jlSZ2AAAAA==","debug_symbols":"NYxJCoAwEAT/MmcPwQ3MV0Rk1CiBMJEsgoT83Ynirau7qQSbWuIxa9qtBzkmMHbFoC0xJRBv5U+kQj6gCyC7ZhAVKNo4tqLPFezaKJBN3eWJ6UKncTGqGMoYaf2FjOE+v4W/Dw=="},{"name":"read_storage_single","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/1VOQQ7DIAwz0KKVoR6nXXbYRrQXrMf+X31V4xSKiuRgYoe4IAA3BfBCPV47mBH1csSKxg4RboZrLaFoU1JtCB8tSdpX/k/B5gpGXA/9g+3CQBTmse4kzaMzodKJpXviz9dBvsZy+lL33KPRRKrIb+oPssX1HOHYY7YsFPKZgUujMcb0X9LnRuxCFTf9PgEAAA==","debug_symbols":"5ZZLCsIwEEDvknWRTCbTNL2KiEStUiip9CNI6d1ttCmCRXdCyC6TPMJ7uxnYqTj0l31pz3XL8u3AqvpourK20zQwvgH+vG2vxrqLtjNNx3JQIBJW2JM7Io4JO5dVwXIUNCafNFfK0yBgoUGmKzQhypkmTPVC67WvCTR6WMAPOCPuPTKS+A7vEtcqImrFiFplRK0UUWsaUav6fyvopVXx7/qgZeq/1kQLLFDO/lng/jpsf8ED94fA/UXg/hiu/zTdTFOaQ1W4rdY99vbol9xp7O7X18vEPgA="},{"name":"set_opcode_small_field","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zVNuQ2AQAzzfQhRXEFFQwN3G0DLGMzCGOzBJkjMwgrE4S6SE8uOkwQHtAJgRCkrCiIaGYbYUNlvwkSYKmWamsplDW6S1uV6yq40NJcQ+mU/zut56xTZ6y94QlNkQVngjZl0uIkP/vNj5a8AAAA=","debug_symbols":"TclRCoAgDADQu+y7E3SViJimMZAtSoMYu7uCfvj5eApncOU6iKO8sG4KSTxmEm5SW+DDh9ClMBgL+2nzf/ex3So="},{"name":"add_storage_map","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/+2ZWW/bRhDHV5djKzab2pQoURclkTrsSHQOBwVa96FA3wv0qY8Fejz0AtoG7Wfsp+rOzO7+RdNlsEVCGEEIrLmc/f/m2KVsj52qllLHHaWviTJXW1tUoI70rUHjc2VnetLUoxGohjUF7IBHRjpy0MwMocRGTJtnWqc6C/3lLFPi7Lh9QwttcpuSL45wnNlkdBYtM2XfoiHfj1KspKqjihc5POEi1ImMlnhjN92saRa6cNgVzbFM6V5G2tVIISVbzONP2wca8ve4nC9dZ5LvGY0OT7vm8TTlcOqjDt9PaapHIEE+0+Pc7dgT7Nh5ccc+Rnrn2uHX+n4h4idGHHKRFzQDFormXKaM/gmzRXuMkqAHtAe0Z9DfYLZon1ES9IH2gfYN+jvMFo0YJUEENAIaGfRbmC06YJQEA6ADoAOD/gizRYeMkmAIdAh0aNDvYbZozCgJYqAx0NigCcwWHTFKghHQEdCRQf+A2aJjRkkwBjoGOjbozzBbdMIoCSZAJ0Anci8jPX8k9EfiakTXdA2zRaeMkmAKdAp0Wo42ddEqEB3tV5gtOmOUBDOgM6CzcrSZ20FPJPRHYn8k8kfGtSBv2DF9Pn/BbNGEURIkQBOgSTla4j7FFYiO9h3MFp0zSoI50DnQuUH3MFt0wSgJFkAXQBflRBfuiD2RC38k9Ed6/kjfH4n8kYE/MqzlXEb+yLiWcwlrqeUNO6Y/N7/AbNEloyRYAl0CXRr0NcwWTRklQQo0BZqWE01dbZ5I6I/EDzWxyB/pP4Qd02/BDzBbNGOUBBnQDGhWjpa5mjyRnj+y8EfiakRvwzOYLbpilAQroCugq3K0lfuRVYHQcuNL9DO3DCo0MbZrITXHFzbldsxeaw61LobaCLySqV2hhmkD0SX6oqsjnl4Z/VO9EaTYNVi4IxMNzvgLebLlErPLrGyLwLLQFCMt2giXdE+0p08O0rqT8KuGqfa23DNyKyg946k0ia5st3sBdm9T7AbX66bpMBvYeoaPXFNLyJaL/YpmnIy5WuKcZVsum6rr8t8D2GsgmZFmLda1ch0zCaic9SP3SKsBx/qGZoiFTjpwZXVQVlAsq5serrRMnICztE3/FvItKtn+F9KuRpDf1nX6gXGy7bhNoD5+07FvJffvlzj3nSvtCqXtiqU9TQ9X7FtEor37nW0P+V40O5nej4T+SM8f6fsjkT8y8EeG/kjsj4z8kXEt5xLWUv6klijT92jHolpemHresVktn8rEH5nXcpQfvid/+J78rk9/VMuOLfyRZS21hA/1hQlr+Yj1H+qOpbXU0qvlTf4f5Wdv/UcSLTf/Rt9wy6AqtgTKqKVP3onHwz4551B5MdS1wHuZ2hVqTK4heo7+44X0iC+M/qXpk2+kT6Z/6b6kwRm/lidbLjE3mZU9Q2BZaIqRFm2E53RPtKefDtK6k/Ar23jfSttJ3eRBi5+7bVpjm/Jie3XwZ4BcuYY1d6ezufd0cpNFvmkYolFsCvP7evE7oTel0EEh9El16PuQdjWC/Pauac2NE3mn6In/a8+umkuaDv6h8S9WeLBgNSAAAA==","debug_symbols":"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"},{"name":"pedersen_hash","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"data","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/z1MSQ6AIAwclC0GOXvxovAETyb+P77KTgGbDEw7S8EMxBUyO/okuSDDy2eIB4MJmQQmw4xTpcjUVLsNc9FSOq1SuuGowwq8Ms/tkCfrKu6YLlYkBlpOfY0ulG7bg6FXRc2Gv96x6STdXuIDUgTHSd8AAAA=","debug_symbols":"vZBbCoMwEEX3Mt+hNKaRmq2UUqLGEggTMbFQgnvvTB9Q8Fv/7uPAhVugd+18v3kcYgJzKRBiZ7OPSK7A8SBP7zSNFjlI2U4ZTH2ulACHPUutFgGDDw6MqvQiVrRspP7SsvmjCb4K3tA7bNTbbpB52MnbNjh+jrsZu9+RZPNz/DTEvgA="},{"name":"new_nullifier","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/zWNMQ6AMAwDL22FEENnFhagGysr/xevalw1kexYtqPcZFgdcDBHDpXFlwkfoVwkh1UsrKZQV6nNGnkoFcvptL3Ei0dULuX7L3TI4i1AfwAAAA==","debug_symbols":"bc5NCsIwEAXgu8w6SKKp+bmKiKRtKoEwKU0qSOjdTWpFwe7mzfsWL0Nv2/l+cziECPqSwYfOJBewpAz0wOj6jaPB+ojJTAk0o4JLAhb79ZZ8ITA4b0Gfjs1C/jynUm2cM/bVag+LRogNizNVv/hawsNMzrTe1oG1m7H77C0xPcd3U+wL"},{"name":"modulo2","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"a","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/1VNuxKAMAhLX1wHj9nFRe0nuPr/51dJwA5ylzYEEk4UoFdYbfiKChRiXyJuTGYkG5IiTUlh5p6JwT0GBON2cUZP3e1ZBiKil4uDEmHCuUF4yTv5XQpJY8fQPKbR5Yx6PkjXh3gBK510vNUAAAA=","debug_symbols":"lY5dCoAgEITvss8S/SBEV4mIrSwEWSMtCPHurUYH6G2/mR1mAixqOrdR02oddH0AY2f02hJTgLKo6qy6HSkJzuPhoWvaqhSgaMmnjAJWbRRDLeMgUkz+jjFdeGicjErdyTxp/qYw+nt/Hf59AA=="},{"name":"set_read_storage_single","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"a","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/1VQQRLCIBALLK10qJy9eFBh9AN69P/jqyQLLWVnlqabLMmQIIB3KHVFK04QMZePYX+xoQJsaRNhtlEmyS2bmwyiiEJ3L0fIqHte3iSENyRMGIubk7oqNSVIm/q8aWYNp6WeXXNKR0aqVkVL1iREXb5Uja8Q/mXahhmtw27tunUYrf3Ttsz8cz3I2jXnWeFKWDreyPOIH9OfQFpQymImEfcMYX8IhrYPwsuP/QfkPBpcwwEAAA==","debug_symbols":"5ZjRasMwDEX/xc9hWJYl2/mVMUbapiMQktKkgxH670u22utYRt4KRm+WfRD3YBDGkzrUu8vba9Md+0GVz5Nq+301Nn03V5PSTwBfu8Op6paNYazOoyohGF2oujssS4vXQh2btlYlGroWf2kEjjSyTzRYXqGJIfYmZkp0WGtN1iWY9Abs2fgb7Nnpe/ilWFxRkKsV5EqCXFmQqxPk6gW5BjmuRgtyFfSWMEaQ6z/vJsLk6uyWq3Yu0mBgyxXRxvjIYcMVQgxCBjZgTzrm8HR3Q8nVCnIlQa4syNUJcvWPd4WQXH9Py5XWwaYRH+hnDhu0t/wh7/yoM88Pmec3mefHzPPbfPPP1Xt1bqpdWy+/gcvhpdvHz8G5HD9O3ycz+wk="},{"name":"pedersen_hash_with_index","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"data","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/z1Muw6AIAw8FIEYZHJwcVH4BCcT/z9+lb0CNjm49h4ZIxAWyOxoE+WCBCefIR50JmQQmATTT4UiU0NpNoxZS+m0SunGRB1W4JQ5boc8SVdxh3ixIjJQcyt9lc6UbtuCvlUFzfq/fmLTSbq9xAckRmVE3wAAAA==","debug_symbols":"nY9RCoMwEETvMt+haNpYmquUUlaNJRA2YmKhBO/eRPEA+vlm9sFOQm/a+fO2PPgA/UxwvqNoPWdKqC71bU3DSFyCEGmK0M1DSQHDPfS9quUiMFhnoK9SLS9RNHVOaw5rmb40WWqdKS+XcuZuX5Ax/satybd/"},{"name":"u128_from_integer_overflow","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/+1WS07EMAx1fs18MpktC5AGaMUeiVmwgOsjlpyAm0CfnTjTqhvEbtRIbZ34Pf8aye7JEW08jeuOyrLjCWXqxo/B80ZVEiWZTKYeDVAyaygwcg/jaz9UU6xgN+4FEFiwPQ5ghbqh+g2M4tXhNdjiLzS0XUJbRbsp2i2h+dvjZLIYz1kzwi3ZszUp8qfxdSuae5x1LPqidjijZ0gAngYjMZAXD17shp/ZmsUQWQxla9noE6SzqWFntsX2ckMb9VIyCBdZ6n8WAlfZlyJJcvWPUWDJ628KWgSO8VHzcipZq/HDVic1QhWs0VMv2V2WLHJ2r5BadlLVyoo9Gai2gfOIEHGjmPkOqTGb251egk27BLuGAWXfqyb1UqSDgHG3E+rM9+EAqdGyYJKI+K6U/1O2a8VWykpZKddNab0NzShxE/uAdL5o0tUqM7nHgh+lc0dpV/NJBr6zIOAoS0Ou2yjbVPjHpTC+/hyGWx6oUlZnyajoWhixjhLyOVYtFzBOp68j6cAAXGzzQ9SR6xtSi5xbf9R5DdubTzy/9L30GPgKAAA=","debug_symbols":"zZzRShtBGEbfZa9Dme+ff3ZmfJVSSqqxBCSKxkIR370bNatlF2VhcsiVbjJ/zkA4m1yczFN3tfn1+Pvndnd9+9BdfH/qbm4v1/vt7W64eurCN+nl0Ye79e7wwMN+fb/vLsKq2+yuhr/Pq+56e7PpLqKl5x+rw4AtHYhLB3zpQFo60C8dyEsHytKBOjfgNZW3Ga9Z/42tJqst5P5t9fBvHldbfGVYABgCGAYwHGCUBgy5jgx5nDLq6RmxxfuhYkeGuU0Zs3eRFMJxZynE/guGWz0yPKqMqz3PLM7j7nP16Xb8vLbTn9d28nltp5zXdmqD7cSYx+14+ridF4YHgKEWjOwjo4Qpw5ow4jujThl+ekYKp78NJwGMJrf6cbWpn/qRYpOPkzQyPrwfI8MBRgIYPcDIAKPJV6ESR0YNU0Y9PaMPAEMAwwBGBBgOMBLA6AFGBhiA5z3geQY8z4DnGfA8A55nwPMMeJ4BzzPgeQY8z4DnBfC8AJ4XwPMCeF4AzwvgeQE8L4DnBfC8AJ5XwPMKeF4BzyvgeQU8r4DnFfC8Ap5XwPMKeK4QCIgIiBGQSECcgCQC0hOQTEAKASGMF2G8CONFGC/CeBHGizBehPEijBdhvAjjjTDeCOONMN4I440w3gjjjTDeCOONMN4I4yNhfCSMj4TxkTA+EsZHwvhIGB8J4yNhfCSMd8J4J4x3wngnjHfCeCeMd8J4J4x3wngnjE+E8YkwPhHGJ8L4RBifCOMTYXwijCdSOhEtnYiYTkRNJyKnE9HTiQjqRBR1IpI6EU2diKhORFUnIqsT0dWJCOtElHUi0joRbZ2IuE5EXScirxPR14kI7EQUdiISOxGNnYjITkRlJyKzE9HZiQjtRJR2IlI7Ea2diNhORG0nIrcT0duJCO5EFHcikjsRzZ0RzZ0RzZ21b+7qDKSF8RaOv6s2k81AEgFpI+P7wRCaOeCiSQ43vPQIsTIDKQSkApAmOdyXEBEQawyJc8fZNJFR+XNIIiB9E8h4os3cKS3WqFSzzyGFgFQA0qhU+wIiAmIEJJ4WMlz8Wd9v179uNofj0Q7PPe4uj6elDZf7v3evzwxr/wE="},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2b3U7bQBCF18GhBoOb2HGckEAIBaTehRSScMfLtM/d60p9haqss6Mclmm0UcdLVool5LG9O+ebsz+EyERqfSSvP5GJ2+Z8rN4f1ObFnGf/dzwI5po1yRkFwtkKhPMoEM5YkDNiOPU5NrFed3rNfVLr9fjuIXbWA30Ez9W2RLZqYgJ8eC1V6Wr2fAzJEVwZ8Ng8o7PGSc0zBEtNkXUbuEeFtuAe6RzBPdrBSCcxpgjX+5RskOXyvs4+XcOJyUXcKcT4bAzWxQ3V2Jav8bGRMXn1rqExqVcx+d42uRO4pjE4NbHgb44H1I7Mz6k1F2KIR9CW2pEfLWDVx7narJfTLf1iq18GbY6hn7230DWNtfaqa2J9btOeAPkb8HCm86byed+MTWx5l0JNGXgioz1f6fxn6u0RWdfXEGfAcy7Os1578nWux+4zsMvkfXrUXnUsr84srzJogwydBvyLQJdy03WH0ZbzYrHS2l0HL7oMT9ezF11GW9CLZ62dO3iRMzy5Zy9yRlvOi+U3rV04eFEwPIVnLwpGW86Lef0ZoOfgRY/h6Xn2osdoC66Rel6UDl6UDE/p2YuS0Rb04ofW7jt40Wd4+p696DPagl5819qVgxcVw1N59qJitAX3zvrzxcDBiwHDM/DsxYDRFvRirrWHDl4MGZ6hZy+GjLbgGqm1Lxy8uGB4Ljx7QXq7MvcCZK4CZC72gDmxYhntRb1/jhy8GDE8I89e4HcuuzCXe8CcWLGM9uJJa48dvBgzPGPPXpDersx5gMxFgMz9AJnLAJmrAJn3YT4nViyjvaz30EsHLy4ZnkvPXpDersx5gMyjAJmLPWBOrFhGe1l/N3fl4MUVw3Pl2QvS25V5ECBzdw+YEyuW0V4utPbEwYsJwzPx7AXp7co8DJC5CpB5FCBzESBzP0DmMkDmwxr0w5zvATO+e/S7UZ75c2rxkGfKYlQWYwpxBozU9kXJva+SWbWT1lTcj/X42POFrqeNas9XOu+XBmrSeW/l89Z/I9yZXPQO3y3j1b2JI+FxuoO8EejQ/RjiX9CW2pEftB8Qu36X68bE91v6Tax+GbS5gX63Vj+6prHW3v00cVNzy2Ved9RmLX8Fngb2wUd8J1eBV8pipGMCPNfyPA8N1TnDd/j+KNm1N7W8OrG8yqAN7tEftW8emA/M/2LGzxMncA956F7LqgX/v2EKOf4CARQXTpY1AAA=","debug_symbols":"ndpRattAGIXRveg5FN/fmhkpWymlOIlTDMEJsVMoJnuv3dIF9LxpJN237+kwl+lp//Dx4/vh+Px6mu6/XqaX18fd+fB6vJ4u0+ZLLX/ent52x9uL03n3fp7ut33cTfvj0/Vp1Ofd9Hx42V+fq31+u7uNVhhtNzKKjEpGWxnNMmoy6jIaMpIitlLELEXMUsQsRcxSxCxFzFLELEXMUsQsRcxSRJMimhTRpIgmRTQpokkRTYpoUkSTIpoU0aWILkV0KaJLEV2K6FJElyK6FNGliC5FDCliSBFDihhSxJAihhQxpIghRQwpYkgRixSxSBGLFLFIEYsUsUgRixSxSBGLFLFIEasUsUoRqxSxShGrFLFKEasUsUoRqxSxShHZbGgVWhWttrSaadVo1Wk1aLXQitoItRFqI9RGqI1QG6E2Qm2E2gi1EWqjqI2iNoraKGqjqI2iNoraKGqDQDMkmiHSDJlmCDVDqhlizZBrhmAzJJsh2gzZZgg3Q7oZ4s2Qb4aAMyScIeIMGWcIOUPKGWLOkHOGoDMknSHqDFlnCDtD2hnizpB3hsAzJJ4h8gyZZwg9Q+oZYs+Qe4bgMySfIfoM2WcIP0P6GeLPkH+GADQkoCECDRloCEFDChpi0JCDhiA0JKEhCg1ZaAhDQxoa4tCQh4ZANCSiIRINmWgIRUMqGmLRkIsWuWiRixa5aJGLFrlokYsWuWiRixa5aJGLFrlokYsWuWiRixa5aJGLFrlokYsWuWiRixa5aJGLFrlokYsWuWiRixa5aJGLll30JBctctEiFy1y0SIXLXLRIhet/3bR6+nn7v2we3jZ3+723j5+HB//XfW9Hs+/3v5+uf77Gw=="},{"name":"get_function_selector","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zWMOw6AMAxDX38IMXRgYmEBegRW7i9ORRzaSE4sf3KRYDbATp9oCpXJThAeBvtNQiUMqcn0Vusx0mFraeNVvGV4b5WW3cmG4qwod4pur/ABUAB+KJMAAAA=","debug_symbols":"bc7RCsIgFAbgdznXEk6PtnyViHCbC0F0TBeE7N3TWhG0u/Of/7v4MwymW25X68cQQZ0zuNDrZIMvKQM9NPT1jZP29RGTnhOoVjBBwPihnshXAqN1BhRnYiV/GrFpN43Ij1992sNSMLphKVD+4ksJdz1b3TlT59Vu8f1nbYnpMb2bYp8="},{"name":"assert_same","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"arg_a","type":{"kind":"field"},"visibility":"private"},{"name":"arg_b","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/5WV3U6DQBCFB4TaCqWUAtb+JP7AI+ilj+G9F94ZjX83Xpv4bj6Ve2Z3eqpNmnSTLdsz52NmlzB0ciQyTMWNtYSROEUKGbhLhHkrtnKL2M2okMikHkFQcR9scqQrGBNduQySXrqfvBd/h2FyjUCCe6VIhJyCKgYdCpLazVFvBR2Lihgj/HgPUg07RjqJ7tz1xJuPgznrYy9KRizznpFfKnpP2dBcURhyojnRPKCPlA0dKwrDmOiY6DigH5QNLRSFoSBaEC0C+kDZ0ImiMEyITohOAvpG2dBSURhKoiXRMqDnlA2dKgrDlOiU6NRfd5FsP+KyvVI2tFIUhopoRbTazVZtjuVApNyPuAKfKBs6UxSGGdEZ0VlAnykbWisKQ020JloH9J2yoY2iMDREG6LN7h6bzR4PRIr9iCvwhbKhraIwtERbou1utnbzJhyIZIcj+X7kAh3mm/1J97HpTyP2J7ilt07l7pgIx6mmOv2bau7h1i8tgic5p2nBPrcc6HIZ/Ct33HCsIzWiia8wteIv/8+2C2bdm+2MiX0g9iKClmGBK975z62y/hV8E9nT77SFbw+EUv2UaCjVk0nty6CHE19hOf/B/AVp6frZjgYAAA==","debug_symbols":"ndlLahtBFIbRvfRYhLpdb20lhCDbchAIyVhyIAjvPVKCN3BmXd39z87oq9vysn/6+PXzcHo9X5bt99tyPD/vrofz6X66LelbrP/eXt52p8eLy3X3fl22LWJulv3p5fGY8+dmeT0c98s2r/Xzx+YxyzYrNqs2azbrNhs2mzRbk83CZqZkNSWrKVlNyWpKVlOympLVlGRTkk1JNiXZlGRTkk1JNiXZlGRTkk1JMSXFlBRTUkxJMSXFlBRTUkxJMSXFlFRTUk1JNSXVlFRTUk1JNSXVlFRTUk1JMyXNlDRT0kxJMyXNlDRT0kxJMyXNlHRT0k1JNyXdlHRT0k1JNyXdlHRT0k3JMCXDlAxTMkzJMCXDlAxTMkzJMCXDlExTMk3JNCXTlExTMk3JNCXTlExTMk1JpIS7wB2GtYRlLWFaS9jWEsa1hHUtYV5L6CXQS6AXDbFaYjXFaovVGKs1VnMs9tjAIBtYZAOTbGCTDYyygVU2MMsGdtnAMBtYZgPTbGCbjawXPegF8uz99Hv3ftg9HfeP26nHx4/T89dl1f14/fP2/8v9378="},{"name":"nested_static_call_to_set_storage","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"read_storage_map","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/83XyW7bMBAGYHmNlTiuI1m2vMu2FCcNULSH5tKmKNB7L32CAl0uXYAu6Dv2qcp/yNFvV4ADXowIkEUP5yOHVIyAedAIgk4zMNc8cBciQS9om0cN96tAW6ZRN3etF9Q0VKATql64tKAhLSQ21+bjrAis6zSeo6OBEXLMIoOdFDpvS6aW6wQfNgcjtnP25Mjbu1B9R+qVSjp2mJYbJizqriPkgKHNObFNPKukeZjslaSLOX3R3MnBeKfVenGd2XrPcLekGbqvzVymC85b8sR45+bu2klemrtf7liPO9bf37FHLK9vBnxnnhc2ueeSI1nkBVpkkc3p26bQXwwrjYUiISaNSWNHvzOsdCAUCQPSAenA0R8MK02EIiEhTUgTR98zrHQoFAlD0iHp0NHPDCsdCUXCiHREOnL0I8NKU6FISElT0tTRjGGlY6FIGJOOSceO/mRY6UQoEiakE9KJo18YVjoVioQp6ZR0ap9VEvuTyJ+kh4lZ01OGlc6EImFGOiOdVWeblbMdIGa2bwwrnQtFwpx0TjqvzjYvd9CTRP4k9SeJP5kchdyzY+b9/GFY6UIoEhakC9JFdbZF+Ss+QMxsHxhWuhSKhCXpknTp6BOGlWZCkZCRZqRZtdCsfMWe5MKfRP4k9icDf5L4k6E/GR3lvYz9yeQo7yU6ylru2THzu/nKsNKVUCSsSFekK0d/M6x0LRQJa9I16bpa6LpcmyeJ/En6UAtL/MngIeyY+Sv4xLDSjVAkbEg3pJvqbJtyTZ4k9ieZP0kPE7MNzxhWmgtFQk6ak+bV2fLyX9YBgp9X7Q3PM3cC9TzT53kG2UGhJxszYjPgVchUxf5Ulxbntqk9ODBdMumK56LrtjSvXf5jsxHIuKlJ4g1CuKXi1/abLhfmptC0LSe2HXUbRKfOcIWneXm1252y/iv4tuZWe1c9M8pR0J4ZsRHNnWWXu9fl7l3aLdScYouSQvetu4Pb5aEWZCuLfYuWFOOuhh1c0raybKwu7EkHRu3aypBT2CiKCqWyUN6Xvs36Bp/pX9z/AKGUSYt8EAAA","debug_symbols":"5dzLappRFIbhe3Ecyv6+tY+5lVKKORUhmBBNoYTce7Xx0BKpGQjhxVnUld+1nLyz52Vyc3v1/OP7bH73sJhcfn2Z3D9cT5ezh/nq1cskfZH+vLt4nM7XbyyW06fl5NJ99IvJ7fxm9eewXi8md7P728lluLxevJsesR0eve9mlfOBWZW0mdXYz9rj0HPzyNsHlxL76Zxev12slzd5+SAvn8nLF/Lylbx8Jy8/wMs7kZcnR8rkSJkcKZMjZXKkTI6UG3l5cmF9gsIq1dhuJKcj62+XT0ee2tJ2hbb+fPfM+rZ4iLq4qYsHdfFMXbxQF6/UxRt18U5dnBqgnKiLU8uZqeXM1HJmajkztZyZWs5MLWemljNTy1mo5SzUchZqOQu1nIVazkItZ6GWs1DLWajlLNRyVmo5K7WclVrOSi1npZazUstZqeWs1HJWajkrtZyNWs5GLWejlrNRy9mo5WzUcjZqORu1nI1azkYtZ6eWs1PL2anl7NRydmo5O7WcnVrOTi1np5azU8s5qOUc1HIOajkHtZyDWs5BLeeglnNQyzmo5RzUcipR06lEbacSNZ5K1HoqUfOpRO3n6kuxm1MLqkRNqBK2ocI2VNiGCttQYRt6ChjnkzbHNlTYhgrbUGEbKmxDjW2osQ01tqHGNvQUbs8nbY5tqLENNbahxjYUC/UosA3FGkPCIkPCKkPCMkPCOkPCQkPCSkPCUkPCWkPCYkPCakPCckPCekPCgkPCikPCkkPCmkPCokPCqkPCskPCukPCwkPCykPC0kPC2kPC4kPC6kPC8kPC+kPCAkTCCkTCEkTCGkTCIkTCKkTCMkTCOkTCQkTCSkTCUkTCWkTCYkTCakTCckTCekTCgkTCikTCkkTCmkTCokTCqkTCskTCukTCwkTCykTC0kTC2kTC4kTC6kTC8kTC+kTCAkXCCkXCEkXCGkXCIkXCKkXCMkXCOkXGOkXGOkXGOkXGOkVO1IYa6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQZ6xQF1ikKrFMUWKcosE5RJGpDA+sUBdYpCqxTFFinKLBOUWCdosA6RYF1igLrFAXWKQqsUxRYpyiwTlFgnaLAOkWBdYoC6xQF1imKjzhF/ejmre031z/f8n66ROTNdIk6dtPj0KOLxvZHKdaR4V7Sdo9ecvw9vDm2nNOx9ZyObed0bD+nY8cZHfsRH+nUx2rsjm3p//srjbp7dNrnxJG3B4h+gOkHBP2ATD+g0A+onAPkQwc0+gGde8Dq1c/p02x6dX+7WP3P+sPn+fVy9jDfvFz+enz7ZDX7Gw=="},{"name":"elliptic_curve_add_and_double","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/22TMVKEMBSGHwsEZlhCFrbYxkKF2UYrRyvH1cKx8gjaeAYvoLWdR/AoVjaexRuY/73Ag10y8+Al+fMl7w+0FBPlKfl2RKEt/AhZMv4VIW6oz2SSIktRP9Rhkld1QUbxiX8sux7FE7xNzFnis+QSYrDillKaNjAS3h9aSlSx+G2eX83X04vPjSg4vOJ8W97/berP9933x9tue+aHM1FkCGVEo51yUeRymB6Hrtnr0tDNpuvSVoh5ixI5iq7nZzKAVuAhGujN9W0oLw2gcZ6psBCECQjTDsSl7lgafi2R+rDHmMcp7NWo3DicHjLbYcKCqnuVSqyECFrlwzERpro5ImSOiQ5UweB2KyWuhAjaykfNxAtkc0TIaibWoKZsgAs2GaU2g9dOvW6mXmcHXhehdoaq0Or+Vm+Br1QN5lvgw98h2z+8CzLDhzdqxwhTBkzDmAdkc5iS64tCQeYAUwXMmjGPyOYwkK0ZswZKrGyCIxn7Zwcn2ZEufLt+WW+n/MTAyU8MVHKKdPOD+AfR+F+VSAQAAA==","debug_symbols":"zdrNasJAFIbhe5l1KDPnzF+8lVJKqrEEJIrGQhHvvYm1oSUWd/HdZWa+xbOZjxyYk1nVb8f316Zdbw9m8Xwym+2y6ppt269Oxj45uewedlU7bBy6at+Zhbeqhanb1eUznwuzbja1WaiEczFJh1Ku4Sg6ZsXdiKomd82qd/l3+KUYOJ7FiSxORnHEsjiOxWHdLFEWh3XRJbA4rN6RxOLAarBEcZTVyspqZZ25lb3KyPFxylEWx7M4gcWJLE5icTKLM3Mr+2hHTvITjrcsjmNxhMVRFsezOIHFmbmVg4ycoDc4icXJLE6J4gTL4jgWR1gcfSCnnHL+aeWxrbxNbr7BJgQWJ7I4icXJLE6J4kTL4rh5OXcGmygsjrI4nsUJLE5kcWZu5TuTRMwsToniJMviOBZHWJyZW/nOr3vyLE5gcSKLk1iczOKUD+T8nUL7xUe1b6q3TT285hnOju3y53FPv+w+d98nffYL"},{"name":"set_opcode_u32","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zWNOw6AMAxDX38IMXRmYYH2CKyI83MqkrSJ5MSK7aSRYBXAwawoGyqLjKB4cDZEQiX4qqtoqT5tpFPa1v1UvFWwXCO940c2OQuKsaLmS+n+KX42GuwemAAAAA==","debug_symbols":"TclRCoAgDADQu+y7E3SViJimMZAtSoMYu7uCfvj5eApncOU6iKO8sG4KSTxmEm5SW+DDh9ClMBgL+2nzf/ex3So="},{"name":"assert_nullifier_exists","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/5XVW07CQBQG4FMEFIG2QKEXL4DS+OCzProEV6EmJkYTL4m78NnEFbkq5z8zp79KQkKTaYfT/+uZllBWsiOy54bIkYQNFYml6w4RxpXYzE1abkSxRFaqcRKqVYeY7OgMwfaJ2+1fiLVIseucY9/GzI3uSiKgTgfXRFMtt1dYhhRu9Gpb2K6uTbcedj4DtrfiGXfBa7T14d0Q7tctX5Q+Wd9nen6q9I1lowOlCAxIB6SDQB9YNjpUisCQdEg69Metiet2z7LRWCkCMWlMGgd6x7LRRCkCCWlCmqwvNGm6bSCu2y3LRlOlCKSkKWka6DPLRkdKERiRjkhHgS5YNjpWisCYdEw6DvSGZaMTpQhMSCekk0CfWDaaKUUgI81Is/UnmzWPZwNx3V5YNjpVisCUdEo6DfSRZaMzpQjMSGeks0DPWDaaK0UgJ81J80BfWTZaKEWgIC1Ii/XHUzTf45Yk2UzcAt9ZNloqRaAkLUnL9W5l88vYkmTbk3wzcfe0ZNlopRSBirQirXCEky++izXevIt7fBcjLbW9ld0V28LtQFsd/G116HHlp3YGz/iQoWO+0+ddnc5DfhH+M5aRBrFQ/NwXuuJP/8luF2ZZW+yIjf2JVvjjW0rT4RhHXO/j17L+Lfgysod8ihsvvjF+AOOX7+dMBwAA","debug_symbols":"ndrbasJAFEbhd8m1lPlnz9FXKaXEUxEkiodCEd+9idpKUVq67kyyN4zwXa3k2Mzmk8Pb67JbrHfN+PnYrNbTdr9cd/3VsXFPcue7u03bDTd2+3a7b8aSLIyaeTc7/471NGoWy9W8GZuPp9HdfPDRXceDT/l7uj4aTia7DiezH8Mvo+FIenwkV8vtSMn9caR+5vYPsvv9SDnkeB3OUeX+SP7/R7osGl0MdDHSxUQXM10sdLHCRe/oougileOpHE/leCrHUzmeyvFUjqdyjMoxKseoHKNyjMoxKseoHKNyjMoxKidQOYHKCVROoHIClROonEDlBConUDmByolUTqRyIpUTqZxI5UQqJ1I5kcqJVE6kchKVk6icROUkKidROYnKSVROonISlZOonEzlZConUzmZyslUTqZyMpWTqZxM5WQqp1A5hcopVE6hcgqVU6icQuUUKqdQOYXKqVROpXIqlVOpnErlVCqnUjmVyqlUTqVy5BzeFN7EMdDhGuhwDnS4BzocBB0ugg4nQYcNCRsSNsSDMi/KPCnzpsyjMq/KPCvjriwcloXLsnBaFm7LwnFZuC4L52XhviwcmIULs3BiFm7MMv5iCxvCmVm4MwuHZuHSLJyahVuzcGwWrs3CuVmBvx3FhnBxFk7Ows1ZODoLV2fh7CzcnYXDs3B5Fk7PQu25v3pvt8t2spoP314MDw/d9OtTjP5y/7G5POlnPwE="},{"name":"get_fee_per_da_gas","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zWMSwqAMAxEX38iLroWwY3aI7j1/ngqM7ENTDLMJxcJZgPs9ImmUJnsBOFhsN8kVMKQmkxvtR4jHbaWNl7FW4b3NmnZnWwozopyp+j6Ch8urdj0kwAAAA==","debug_symbols":"bc5BCsMgEAXQu8xayhgjVq9SSjGJKYJoiKZQJHevtmmhJLv589/iZxhMt9xv1o8hgrpkcKHXyQZfUgY8UXx/46R9fcSk5wRKUiEJGD+Us0G2EhitM6BYw1ey063kfNOtFPSn5REWiOcNC2R/+FrCQ89Wd87UebVbfP9dW2J6Tp+m2Bc="},{"name":"get_l2_gas_left","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zWMOw6AMAxDX38IMXRmgQHoEVi5vzgVcWgjObH8yUWC2QAbfaIpVCY7QXgY7DcJlTCkJtNbrcdIh62ljVfxluG9XVp2JxuKs6LcKbq+wgeR+4uakwAAAA==","debug_symbols":"bc5BCsMgEAXQu8xaykQxVq9SSjGJKYJoiKZQJHevtmkpJLv589/iZxhMt9xv1o8hgrpkcKHXyQZfUgY8Nfj+xkn7+ohJzwmUpKIlYPxQTylWAqN1BhSjfCU7zZGyTXNk7U/LIyzwjBsWDeI/vpbw0LPVnTN1Xu0W33/Xlpie06cp9gU="},{"name":"to_radix_le","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"input","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":10,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/+1VPW/cMAylJeuss892L+mhWQr0wwK6Fy3QJT+qQ+fOBTp1KTp0bsf8jfyq6JGUaB+CZA9iQGdafKSoJ+rdQp4ojpSf16QPZmiiXX41GNdUrGy4PJqJmjKV4ESUSwojzxaA7bv8c7VwRo9vNqnPI4gJfCcmnrhjEwlDHvuFGiD6hoGI22O8BfaVfHktCjF9KrCdONrqcDIJZ1mhw/tN/hk/kRbYr6pKhQ/NRRpCnIvzGdrdh3YV7Q2N6ryZ7pEVOce1073sdGZVZ2/sDcLeoKCDsjcKezjkAwaz91G+vCZFzJgKLPIBM0n7c4zTQxipLoZ9DCDyg5XVirvTwjvb8T6w6TVPy+V8gfW5KQQsdqyVlNZIiYbhtSsmGmYwzDlNC8+U7cfN1sDQaGGrXY7yfg55IiGpqEabtL3QGQ+ie8NQ7TtAArr/66rH5SYG7fHIPf696M23pDdEpJKtlR7q7Q967QKjQxUZX0t27C0ZxAucf18XiNW9kgxlqy/Xt6rmqmxVQxaQQ6jyC04H3s0PWHZjLdJVyM8txJQkMHlNWd94myzNlMfMaX7BOtcGoGfb0hSqoCDwBQf+hgXC/6SiGixT/6teDKYX81YvLuyYL6WoSwW9VFZOIqsnTGHwkv/kqzQjYk6pwI7WU+JwMglnWeECbxT5lyu9tyFBz7E25NEw0TqHtbvbdGHPFd7AMjY5zbC5BatOma1T5vo3OrJFmlVaH59Xtxh3S+UbDlIIAAA=","debug_symbols":"vdvtahpBFIDhe9nfUvbMnK/xVkopJjFFEA3RFIrk3rtWXSixlA36/tLVObyo+7ADsofuafnw9uP7avO83XXzr4duvX1c7FfbzXB06PovRf+8untZbI4v7PaL130372fdcvM0PL7PuufVetnNa7H3b7PjgE0d8KkDMXUgpw60iQO1nzogUwfKtQGT2s4zJql/jc0+rBZJP6+WUuq4enh6alSgoUDDgIYDjQAaCTTa/RvaAw0BGoBzBZwr4FwB5wo4V8C5As4VcG6Ac5vs/DRWPjf2D41NL2NF5H+fKMpltURt42rVc0OBhgENBxpxi4bn2GjysZFAo92/4T3QEKBRgEYFGgo0DGg40ACcO+DcAecBOA/AeQDOA3AegPMAnAfgPADnATgPwHkCzhNwnoDzBJwn4DwB5wk4T8B5As4TcN4A5w1w3gDnDXDeAOcNcN4A5w1w3gDnDXAufU9EhIgUIlKJiBIRIyJORIKIJBEhxAshXm5xCqfEJZKSVyJGRG7xw2etY0SvfV0NiJSeiAgRKUQkgbOrNCBSeyIiRKQQkVtc41PH/5DSrpxdVYmIEREnIkFEkog0IKI9EREiUohIBa4nqkTEiIgTkSAixOZOic2dEZs7IzZ3RmzujBBvhHgjxBsh3gjxRog3QrwT4p0Q74R4J8Q7Id4J8U6Id0K8E+KdEB+E+CDEByE+CPFBiA9CfBDigxAfhPggxCchPu8sfjj4uXhdLR7Wy+M9g8f33jaPl1sIh8P9r5fTO8Pa3w=="},{"name":"get_sender","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zWMOw6AMAxDX38IMVRiY2EBegRW7i9ORRzaSE4sf3KRYDbATp9oCpXJThAeBvtNQiUMqcn0Vusx0mFraeNVvGV4b5WW3cmG4qwod4pur/ABMD8fcpMAAAA=","debug_symbols":"bY5BCoMwFETv8tdSYn6UNFcppUSNJRASMbFQQu/en9YWQXfzZt5iMgymW+4368cQQV0yuNDrZIMnysBONfu0cdK+FDHpOYGSom4qMH4oEZtXBaN1BhRyyjtbIBerLRD53z4fyS1KucqtYLiVrwQPPVvdOVPulW3x/e8tYXpO34XcNw=="},{"name":"get_timestamp","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zWMOw6AMAxDX38IMXSFhQXoEVi5vzgVcWgjObH8yUWC2QA7faIpVCY7QXgY7DcJlTCkJtNbrcdIh62ljVfxluG9VVp2JxuKs6LcKbq9wgfwQd3GkwAAAA==","debug_symbols":"bc7fCsIgGAXwd/muR/gv+fRVIsJtLgTRMV0QsndPa1FQl+ec38UpMNp+vV5cmGICfSrg42Cyi6GmAuRAybNNswmtSNksGTQqFB3YMIJWhPCtg8l5C5qz49b9aIGU7Vog+2j1D0uUfMcSkX7jcw03szjTe9vutW0Nw/ttjfk+v5ZqHw=="},{"name":"u128_addition_overflow","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/+2Zv68bRRDHb9f23p3tW5/t5x/PeS+xwU5BlQJeQYFEw7+ARIGEFBBIIBCKANGkARqUkgoKGkSD+A8QVZq0qSOlSZV/IjuzMzt3Pntf/OqzZHtv9/uZ2b21Pd87b5NOkmTdxD0uE3po15PYxLg3Bc/3Em75wUTZRHHXDgaR2pEs6bzhXgY7DoUDmKbzDkgggt5CB0RJzI7z9lCFDwMvO035eqLu7Sqz7AhI6k49tg7qjqhBl2w9tPfQuGpU6JC9c9O5pkFtRJ0ezo56nz1FVFPLbAOaYTw42d21e7nrR0oQGmx2idEbiPg/tED41uF0BxdL6cZh+imnu+dHNkfSJS843ds7RTvRxVbPn8PrpuBPZJdPo8UmQMaLcFThW4+ERqKqSuTqeezyDqWeMzQ1Ctyl0Y6VkV7IYWT3L9yzH/Yzk/3s+/3kPc9lu/rbRH0C3wQvzkg8xHM9gJZgQ6/p+yaiD6Sb0QJREBSCFoIW/v1kxGX7VLoZtYiCwApqBbWEfiXdjI4QBcFI0JGgI0K/kW5GS0RBUApaClo211iGNUYQl20t3YyOEQXBWNCxoONmtnHIFkFctq+lm9EJoiCYCDoRdNLMNgkTPBEZxBE3wfvSzegUURBMBZ0KOm1muzFSxhE3we+lm9EzREFwJuiZoGeEfiHdjM4QBcFM0Jmgs+ZEZ2GrI4jL9rl0MzpHFARzQeeCzpvZ5uG0nIiM44ib4HfSzegCURAsBF0IumhmW4QfhAjisn0r3YwuEQXBUtCloEtCP5NuRs8RBcG5oOeCnhP6pXQzukIUBCtBV4KummtchTN6IjKNI1gin0s9uUQwkSLCVWOFboIri4vYrVS2W5jqVj3VhYdXVKVWUrAuRHRb6tIdX73vkGjtzh0oNgqFMNE1PHHGz/wRLxeYzY5ll5LYD2ha2CYJGW7DO8R7WpnW3oSvFK32EtfdDUarh0vmCu7NHCy+82YwFqkPC44zV9jMKUSWBpOShx14Ca2rYBYELsJeDGQvinptH8o5dMVU3ZO6NyBxrO4VVNYA/UG6GY3VvYJ+FwD9QLoZjRWxgj7NRYu0SIu0SIu0yLVIpS6aUPxxFO8sPITWVeWSmxNkmEBVroLehbZJVOXiKMMYf0Nr7Ro/O9X7cCAqCJOTLRkqvkDGMj5w3R/BsQnd/YraKr5KRXWh8ZDXnlt/jU5x1qIoSJUnYRKoSsMhjFqc+W/QqnoIvMrvm5CKJwSjo15IOQoRfm9EAN9rTZg7TqVOlkj+Ca0a+SH0qJAbNjZP2Txgl9+zv+p7hnYHYsMtG/Uv2ZlM1ffAB2KjO8BA/0DraCC5oZPh5wCPNL5lNJDLDZkcdZoGe4HImreLSr9/hqhcYsJh434ZzZsdIOjS9MBNsv+gtbcaueUV7mSdZjPV40M2E7dIha8TflLS2ldniPATaB3yqDZ41KF4VFtPUIhHtbSpZDSHJI4ZTUsn2pJHLeto7LfD0rfbkkcd19HYrQ/rm2ymW6RFWqRFWqRFIkilLprafxITqKL6Y2jte1S2i5MdRQSngR51YoLVmXAZ179Aa+0a98mj9k3NEL2+R81u4lEL8qiDPUVwN14lJq1gh6kfHPSoZLGLyoSOeVT943UetTjiUfXDmEctmh41XFfonyIeVT8iO9NX9T1Ia5YVPar+NeJR9aPTPWrlz2AhXtej6phH1eJRddOj4qWS/gNaxzzqXThcPoHnK/UWAxvMHwAA","debug_symbols":"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"},{"name":"get_fee_per_l2_gas","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zWMOw6AMAxDX38IMXSGgQXoEVi5vzgVcWgjObH8yUWC2QA7faIpVCY7QXgY7DcJlTCkJtNbrcdIh62ljVfxluG9TVp2JxuKs6LcKbq+wgdOkrmukwAAAA==","debug_symbols":"bc7RCsIgFAbgdznXEpqb8/gqEeE2F4LomC4I2buntSKou/Of/7v4M4ymX68X66cQQZ0yuDDoZIMvKQM9MPr8xln7+ohJLwkU0g4JGD+Wk1G+EZisM6D4sd3Ij26kZLtuJHYfjf+wQM53LLAV3/hcwk0vVvfO1Hm1W/3wXltius+vptgH"},{"name":"get_da_gas_left","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zWMSwqAMAxEX38iLrp2I4LaI7j1/ngqM7ENTDLMJxcJZgNs9ImmUJnsBOFhsN8kVMKQmkxvtR4jHbaWNl7FW4b3dmnZnWwozopyp+j6Ch+O7HsakwAAAA==","debug_symbols":"bc7RCsIgFAbgdznXEseWmb5KRLjNhSDHMV0QsndPa0XQ7s5//u/iz9Dbdr5dHQ0hgj5n8KEzyQUqKQPuOL6+cTRUHzGZKYFWjUQGlvp6Kr4wGJy3oJu9WNifFniSqxYc8avVFpb8oFYs+VH94ksJdzM503pb59Vupu6ztsT0GN9NsU8="},{"name":"emit_nullifier_and_check","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/83X2W7TQBQG4HHapg1ZHMeO7SzO0tjhgnIJSFzQN+AdWCUQ4oJF8Iw8FfMfz/EPWHI1CEVEsj09/r+c8dJIU5ozY67sZkxh3AcVMzF9ewiwPTM6soOe3YKJCbRU4SRUr3IxcyYjBM+v7e7eI6MtbrA7n2J/8UDGGNmtX5oA9PwC34zW9akSkzGYwKDS6V3KDOUzwK7OgF2VPGO/8Dma1+FLFx5WvbpohmTDOjOoh0K/sqx0JBSBEemIdOToB5aVjoUiMCYdk47rozex3d6xrHQiFIEJ6YR04uhblpWGQhEISUPSsD3RsOnWQWy3NywrnQpFYEo6JZ06+ollpZFQBCLSiDRydMey0plQBGakM9KZo99YVhoLRSAmjUljR1+wrDQRikBCmpAmjn5mWelcKAJz0jnpvP1Q5s01dhDb7T3LSlOhCKSkKWna7pY2/xmeJOkmdoJfWFaaCUUgI81Is3a3rLkdHcR2e8Wy0lwoAjlpTpq3u+XNu+lJQn8S+5P0n0/M3rnXLCtdCEVgQbogXTh6w7LSpVAElqRL0mV7osvmEXcQ2+0ly0pXQhFYka5IV+1uq+aN9ySpP4n8yfgkE0tOci1hN7GP9DvLStdCEViTrknX7W7r5s55ksSfpP4k7Cb2NnxkWWkhFIGCtCAt2t2K5vfOk4T+JPInM38S+5PEn9xxk+3zuc+y0o1QBDakG9JNu9umeYE8SeRPcn8SnuRa/qJL9r9O7I6bbF+cPctKt0IR2JJuSbc4wgVPuYq6FWi4dNK1EtKmMmpLWXrpZyetdr+32td4Ww/1DJZpe4YOXI2VfRmWLl+51d4xkODRta9kxk/qv/RyYY6Vxq7ZuD7Rq4s4qR0OONoJBw9/mdYfE34cuKu9PaBz/gPbTxvPBwAMDwAA","debug_symbols":"pdzdSlxXHMbhe5ljKft91/7MrZRSTGKKEEyIplAk915N1KaYVHh65p5ZCxbO7+iZ/5rb09uL15//+P3y6t2H69OrX29P7z+8Ob+5/HB193R7mn7J9PXV64/nV/cvXN+cf7o5vUrGvJydLq7efv17z5ez07vL9xenV6PLl7Nn6+dpPx6Wz8n8tPr40eJt2baHxds6Hd8v/u3s/kj58ZHmeXo60rwuLx2py+Pyuev230daR8bD4nWM7fmR+pMjTfN3R1pfOFLuFj0t36YX/kvz9vgJbEv250caPznSPv450n7860jfNs66cdGNq27cdOOuGw/c2Ek3RjdWN2o51XKq5VTLqZZTLadaztByhpYztJyh5QwtZ2g5Q8sZWs7QcoaWM2s5s5YzazmzljNrObOWM2s5s5YzazmzlrNoOYuWs2g5i5azaDmLlrNoOYuWs2g5i5azajmrlrNqOauWs2o5q5azajmrlrNqOauWs2k5m5azaTmblrNpOZuWs2k5m5azaTmblrNrObuWs2s5u5azazm7lrNrObuWs2s5u5ZzaDmHlnNoOYeWc2g5h5ZzaDmHlnNoOYeWk2nineGd5Z2sgRNz4MQeODEITiyCE5PgxA2FGwo3FG7IRdlJ2U3ZUdlV2VmZXTkMy2FZDtNy2JbDuBzW5TAvh305DMxhYQ4Tc9iYw8gcVuYwM4edOQzNYWkOU3PYmsPYHNbmMDdn9m9HuSEW5zA5h805jM5hdQ6zc9idw/AclucwPYftOYzPYX0O83PYn8MAHRboMEGHDTqM0Fl9ToMbYocOQ3RYosMUHbboMEaHNTrM0WGPzubDPtwQk3TYpMMoHVbpMEuHXToM02GZDtN0dp8Y44ZYp8M8HfbpMFCHhTpM1GGjDiN1WKlz+Nihzx3y4CE7ddmpy05dduqyU5eduuzUZacuO3Xjw6vcEDt12anLTl126rJTl5267NT1+WcfgP4fE9DckM9A+xC0T0H7GLTPQfsgNDt12anLTt3hY/TcEDt12anLTl126rJTl5267NRlpy47dWe/i8ENsVOXnbrs1GWnLjt12anLTl126rJTl5267NRlpy47ddmpy05dduqyU5eduuzUZafu6rfCuCF26rJTl5267NRlpy47ddmpy05ddupufrWQG2KnLjt12anLTl126rJTl5267NRlp+7u91O5IXbqslOXnbrs1GWnLjt12anLTl126h5+ydlvOfM1Z3bqwU492KkHO/Vgpx7s1IOderBTD3bqEb8qzw2xUw9y6runP88/XZ6/fn9x/wst929+vnrz+IMtd483f3389s7d2r8B"},{"name":"create_same_nullifier_in_nested_call","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"nestedAddress","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"new_note_hash","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"note_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/zWNMQ6AMAwDL22FEENnFhagCzsr/xevalw1kexYtqPcZFgdcDBHDpXFlwkfoVwkh1UsrKZQV6nNGnkoFcvptL3Ei0dULuX7L3TAVRnnfwAAAA==","debug_symbols":"bY5bCoMwEEX3Mt+hRAfNYyullKixBEIiJhZKcO9N2loE/Ztz72G4CQbdLY+7caMPIK8JrO9VNN5lSkAvFf2kYVKuBCGqOYKsaMMoAe2GcrcUVwKjsRok1s1KDj5yhj8dueB/W5zJDNvtN0NR7+VbhqeajeqsLgNLt7h+25sxvqZvk903"},{"name":"test_get_contract_instance_raw","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/22Tu07DUAxAHZqEtmleTVu6dIAmAwtMZWBAYmFjYUDik/g1vop77CZWpHslp05sHx+lSi8LkeWNhHOS6wl3S6kkDz8J8SZjZkVJKknGRwNFnRqubbJ4CJfVRUZwzSXt2QRUVsO4KRN9yFlxsR4Y+TOjKT3+MJWJQSXvfdrp61xTeOsQxT31A9lLItNZ2HZtKwYKhUlmMj+U1pWRiWxa7/TTnO7ChWttTIstmxClDvKiypgWbaVqlVGt5AzHtMBtXMvpj3O6ufBaS9eqTIstFX+VDj6RxbRoq1Wrjmql33BMC1zlWk6/zOnmQtSu1ZgWW5oQrQ6+ksW0aGtVq41q3f7CMS1wjWs5/X1ONxdaWtfamhZbtiE6Hfwgi2nR1qlWF9NqWhhb09LUtZz+Oaf3E71zrZ1psWUXYq+DX2QxLdr2qrWPaR3ujjSaFqXMtbjNlf5D5vQzn/Txj/gHQ4qt8lIEAAA=","debug_symbols":"tdhha8IwEAbg/9LPZSR3l8vFvzLG6LSOglTROhjif187tRsYKb7Qb03zPtzBtbTkVKzqj+Pne9Out4di8XoqNttl1TXbtl+dCveSfm8edlU7rA9dte+KRWTyZVG3q+FS+FwW62ZTFwumcC7v0uJjuKbFm4zplAsrcbyGlQL/D7+VfT/eZRsi07+GZKIhC7fuLdGY9ZyuJfz8JWj+Ejx/CZm/RHi2xIUpxmKWBbEbCyFmmGEsQYwcxjzGCGOMMZlkmpkbKcYixgxjD8ZtNLLk7xk7jHmMEcYYY4KxgDGdYupchhnGEsTEYSw/bvXjM6mUed+EMMYYE4wFjCnGIsZskrHes+Aw5jFGGHsw7iAjU84wwVjAmGIsYswwliCmbpJFyjDCGGNMMPZg3MmNLKUMU4xFjBnGEsSiw5jHGE2x6DNf0ygYCxhTjOXHHSmNjC3DDGMJYuYw5jFGGGOMySQLmd8ZU4xFjNnTrF99Vfum+tjUw0HJsHlsl7dzk37Zfe8uO332Bw=="},{"name":"set_opcode_big_field","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/11OuxWDMBCTDTZ5KShSpUmT4A1CyxjMwhi0zMAmvMcsrMDpjPn5PfnuJJ3sChnwEAAfbMcKgxJeiiEapC6KMCVMogJF3QqbDdlXrmdIUbamoHsVHK5nEDh9SyUnjte/7fpxXlIV2keH4sgwp5wiOgrC7nEc3W3EPvrrXq4/zjlpR87+2L4nYgXWADZpKwEAAA==","debug_symbols":"TclRCoAgDADQu+y7E3SViJimMZAtSoMYu7uCfvj5eApncOU6iKO8sG4KSTxmEm5SW+DDh9ClMBgL+2nzf/ex3So="},{"name":"test_get_contract_instance","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/91WO48cRRDu6dnHeec9s4/ZvV1z57tJSIggICDhlyAekgNA4iHxB8icISFBxl/gHxCQQGI5cGyHzhw7cld1V3/TN7Mrr+XII/VuTXV9VdXV9ZhbFSt1oZV5Dso95u1C5Wpm/iJanymh7KaKchUJq6NNRnVOTMUPzM+9j5UoviUbhFBJJzYWipn0JPTTaad7AWk9Jq29NHEWhQLGOKwyj4mByUIv9Efa6lQxmM6E7Oi339GBG4ujbuReJoNMfkcGFnJYoKfAmcsZkxSK0qzqmvY/JOqTSKlePLxY1dFGRVphq+KoEjMDs4y8AyVfiY98506nSkjXdq+0pCr9rRqZqRo+NWcZy9ZTJnOB8iFeEnVlfj7t5RBCkoRBR0CT0YBO2SWFDZEpw6AXiPIRvyvrd2VX7MzwsX0Q6+NheZ8gneSmre3kDRKiCGVK9a5SzPeITjpFSsnzENevbamkbjvmLPubKBL8tnNVrVJvWh8vxk76YcxUBumpPaVI04HzeQC2+f0LUShSH8usc5nuGkkSOjKImDjSq+Yk8hWfoNOp0EfXOXTQOX4d6xyZE0PnSHr+QGM9C66nYY2PiBrTSGINa2xIK0q5hsal1UjalmatWONvRI1pJLEVa1yR1lsfhCU0rq1G0rY2a8Ma/yRqTCOJbVjjhrRaNRPCQmNrNZK21qwta/yLqDGNJLZljVvS2ksw3FnOaaVdrqISejecQTLj7id1Y2SiKEBNfBZNmaL7mzFFcZ8zRfG6YIrOeY/q4ZVPw9gr6DlQwAHO8C4KKmPhW/KdEq5QwhWXsMtpVfg6KiFC56/mAaLm+P5DFOKLeehysApy8N+xHMydGHKwl8o5ekXu1fwfqoF007vGaVDq1tvHRFFQn3RivaLX534gVRhITTiQVijeNTKtscnDV91GLNi627Mp/cy+SUpxdnYitlQ+SHZDu1xvIU0psSYnn7Kng5uvXHiWnXSQJWTc91fqrOt50Hlt/3sx0v+qY7OkQU404SwZtHvWGPtAT8anuLZTXAcTY+qpmafmnrrwlC0QF349ZZMTmQfW6b0fJHc+BNPwehNcb2oUfo7aXkj+8VmzsPxyFeQnQb8HW6CFHyrF4P5SF0CCfge2QE9N61Sq00B/Aluglc+IalD3qWSOgf4AtkBPfXWkrqQJ+gXYAm0YWofV2ADaOOiXYC+CFG7CFF4CurT/Q0h5GmKsXYEt0JWvtlWvygFdOehDsAW6ZugK8yeyxSrQ9dDRtb/HExBj7UewBbph6DocUxtAN0NrGx+WMyH1+ZDifEhzGmLC8DXYArXdkQRaQFtA26G1XkM9D1KcD8nPh5Tv/Cwmct+ALdAtQ/mjCNAtoNuhta0/0wmIsfYz2ALdMZQEdoDuAN0Nre180E9AjLWvwBboJUNJ4BLQS0AvHfQabIHuGUoCe0D3gPLoIFz0B+bJgYEKQ0Smxp6Hp0wWo3HSm3IHNnUITd1XfkLdxw6/QugKc+nafnZcO/kHbu7d2M+OG2LRYo9/t29yXOLddCL2AQzbDW2ZtCkWrujf/ESPbvteBg7zRwOd9nBDB2//o/UaRsXUH80SAAA=","debug_symbols":"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"}],"outputs":{"globals":{"storage":[{"fields":[{"name":"single","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"list","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"map","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"return_type","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}}],"kind":"struct","path":"AvmTest::u128_from_integer_overflow_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"nullifier","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::nullifier_collision_parameters"}}],"kind":"struct","path":"AvmTest::nullifier_collision_abi"},{"fields":[],"kind":"struct","path":"AvmTest::enqueue_public_from_private_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"nullifier","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::emit_nullifier_and_check_parameters"}}],"kind":"struct","path":"AvmTest::emit_nullifier_and_check_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"msg_hash","type":{"kind":"field"}},{"name":"msg_leaf_index","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::l1_to_l2_msg_exists_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"AvmTest::l1_to_l2_msg_exists_abi"},{"fields":[{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::read_storage_single_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"_a","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"_fields","type":{"kind":"array","length":3,"type":{"kind":"field"}}}],"kind":"struct","path":"AvmTest::get_args_hash_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::get_args_hash_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"data","type":{"kind":"array","length":10,"type":{"kind":"field"}}}],"kind":"struct","path":"AvmTest::poseidon2_hash_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::poseidon2_hash_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"AvmTest::add_storage_map_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::add_storage_map_abi"},{"fields":[],"kind":"struct","path":"AvmTest::emit_unencrypted_log_abi"},{"fields":[{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"AvmTest::set_opcode_u64_abi"},{"fields":[{"name":"return_type","type":{"kind":"array","length":3,"type":{"kind":"field"}}}],"kind":"struct","path":"AvmTest::variable_base_msm_abi"},{"fields":[],"kind":"struct","path":"AvmTest::assertion_failure_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"data","type":{"kind":"array","length":10,"type":{"kind":"field"}}}],"kind":"struct","path":"AvmTest::pedersen_hash_with_index_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::pedersen_hash_with_index_abi"},{"fields":[{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::get_version_abi"},{"fields":[{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"AvmTest::get_timestamp_abi"},{"fields":[{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}}],"kind":"struct","path":"AvmTest::get_function_selector_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"arg_a","type":{"kind":"field"}},{"name":"arg_b","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::add_args_return_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::add_args_return_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"data","type":{"kind":"array","length":10,"type":{"kind":"field"}}}],"kind":"struct","path":"AvmTest::pedersen_hash_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::pedersen_hash_abi"},{"fields":[{"name":"return_type","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}}],"kind":"struct","path":"AvmTest::u128_addition_overflow_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"AvmTest::set_storage_map_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::set_storage_map_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::new_note_hash_parameters"}}],"kind":"struct","path":"AvmTest::new_note_hash_abi"},{"fields":[{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"AvmTest::set_opcode_u32_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"input","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::to_radix_le_parameters"}},{"name":"return_type","type":{"kind":"array","length":10,"type":{"kind":"integer","sign":"unsigned","width":8}}}],"kind":"struct","path":"AvmTest::to_radix_le_abi"},{"fields":[{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::get_chain_id_abi"},{"fields":[{"name":"return_type","type":{"kind":"array","length":2,"type":{"kind":"field"}}}],"kind":"struct","path":"AvmTest::read_storage_list_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"nullifier","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::nullifier_exists_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"AvmTest::nullifier_exists_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"nullifier","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::assert_nullifier_exists_parameters"}}],"kind":"struct","path":"AvmTest::assert_nullifier_exists_abi"},{"fields":[{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::get_fee_per_l2_gas_abi"},{"fields":[{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AvmTest::get_sender_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"arg_a","type":{"kind":"field"}},{"name":"arg_b","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::nested_static_call_to_add_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::nested_static_call_to_add_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"a","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::set_read_storage_single_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::set_read_storage_single_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"a","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}},{"name":"b","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}}],"kind":"struct","path":"AvmTest::add_u128_parameters"}},{"name":"return_type","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}}],"kind":"struct","path":"AvmTest::add_u128_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"arg_a","type":{"kind":"field"}},{"name":"arg_b","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::assert_same_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::assert_same_abi"},{"fields":[],"kind":"struct","path":"AvmTest::check_selector_abi"},{"fields":[],"kind":"struct","path":"AvmTest::nested_static_call_to_set_storage_abi"},{"fields":[{"name":"return_type","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"AvmTest::elliptic_curve_add_and_double_abi"},{"fields":[{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::get_l2_gas_left_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"arg_a","type":{"kind":"field"}},{"name":"arg_b","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::nested_call_to_add_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::nested_call_to_add_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"a","type":{"kind":"field"}},{"name":"b","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::set_storage_list_parameters"}}],"kind":"struct","path":"AvmTest::set_storage_list_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AvmTest::read_storage_map_parameters"}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"AvmTest::read_storage_map_abi"},{"fields":[{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::set_opcode_small_field_abi"},{"fields":[{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::get_da_gas_left_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"nestedAddress","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"nullifier","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::create_same_nullifier_in_nested_call_parameters"}}],"kind":"struct","path":"AvmTest::create_same_nullifier_in_nested_call_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"a","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::set_storage_single_parameters"}}],"kind":"struct","path":"AvmTest::set_storage_single_abi"},{"fields":[{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":8}}],"kind":"struct","path":"AvmTest::set_opcode_u8_abi"},{"fields":[{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AvmTest::get_storage_address_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"note_hash","type":{"kind":"field"}},{"name":"leaf_index","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::note_hash_exists_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"AvmTest::note_hash_exists_abi"},{"fields":[],"kind":"struct","path":"AvmTest::test_get_contract_instance_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"nestedAddress","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"nullifier","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::create_different_nullifier_in_nested_call_parameters"}}],"kind":"struct","path":"AvmTest::create_different_nullifier_in_nested_call_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"expected_timestamp","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"AvmTest::assert_timestamp_parameters"}}],"kind":"struct","path":"AvmTest::assert_timestamp_abi"},{"fields":[{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::get_fee_per_da_gas_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"data","type":{"kind":"array","length":10,"type":{"kind":"integer","sign":"unsigned","width":8}}}],"kind":"struct","path":"AvmTest::sha256_hash_parameters"}},{"name":"return_type","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}],"kind":"struct","path":"AvmTest::sha256_hash_abi"},{"fields":[{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::set_opcode_big_field_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"a","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"AvmTest::modulo2_parameters"}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"AvmTest::modulo2_abi"},{"fields":[],"kind":"struct","path":"AvmTest::debug_logging_abi"},{"fields":[{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::get_block_number_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"arg_a","type":{"kind":"field"}},{"name":"arg_b","type":{"kind":"field"}},{"name":"l2_gas","type":{"kind":"field"}},{"name":"da_gas","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::nested_call_to_add_with_gas_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::nested_call_to_add_with_gas_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"nullifier","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::new_nullifier_parameters"}}],"kind":"struct","path":"AvmTest::new_nullifier_abi"},{"fields":[],"kind":"struct","path":"AvmTest::test_get_contract_instance_raw_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"data","type":{"kind":"array","length":10,"type":{"kind":"integer","sign":"unsigned","width":8}}}],"kind":"struct","path":"AvmTest::keccak_hash_parameters"}},{"name":"return_type","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}],"kind":"struct","path":"AvmTest::keccak_hash_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::send_l2_to_l1_msg_parameters"}}],"kind":"struct","path":"AvmTest::send_l2_to_l1_msg_abi"},{"fields":[{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::get_transaction_fee_abi"},{"fields":[{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AvmTest::get_address_abi"}]}},"file_map":{"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"125":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"139":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"140":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{\n    abis::{\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\n    utils::reader::Reader,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n}\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\n    let mut reader = Reader::new(fields);\n\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n    // WARNING: if updating, see comment in public_call_stack_item.ts's PublicCallStackItem.hash()\n    let item = PublicCallStackItem {\n        contract_address: AztecAddress::from_field(reader.read()),\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\n        public_inputs: PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            args_hash: reader.read(),\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            end_side_effect_counter: 0,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0\n        },\n        is_execution_request: true\n    };\n    reader.finish();\n\n    item\n}\n"},"144":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{hash::pedersen_hash, storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"146":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UnconstrainedContext> {\n    unconstrained pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"173":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item_compressed.nr","source":"use crate::abis::{call_context::CallContext, function_data::FunctionData, gas::Gas};\nuse crate::address::AztecAddress;\nuse crate::constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH};\nuse crate::traits::{Hash, Empty, Serialize, Deserialize};\nuse crate::utils::reader::Reader;\n\n/**\n * A compressed version of the PublicCallStackItem struct used to compute the \"hash\"\n * of a PublicCallStackItem.\n * \n * Historically, we have been zeroing most values in the PublicCallStackItem struct\n * to compute the hash involved when adding a PublicCallStackItem to the PublicCallStack.\n * \n * This struct is used to store the values that we did not zero out, and allow us to hash\n * only these, thereby skipping a lot of computation and saving us a lot of constraints\n * \n * Essentially this struct exists such that we don't have a `hash` function in the \n * PublicCallStackItem struct that practically throws away some values of the struct\n * without clearly indicating that it does so.\n */\nstruct PublicCallStackItemCompressed {\n    contract_address: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    revert_code: u8,\n    start_gas_left: Gas,\n    end_gas_left: Gas,\n}\n\nimpl Eq for PublicCallStackItemCompressed {\n    fn eq(self, other: PublicCallStackItemCompressed) -> bool {\n        (self.contract_address == other.contract_address)\n            & (self.call_context == other.call_context)\n            & (self.function_data == other.function_data)\n            & (self.args_hash == other.args_hash)\n            & (self.returns_hash == other.returns_hash)\n            & (self.revert_code == other.revert_code)\n            & (self.start_gas_left == other.start_gas_left)\n            & (self.end_gas_left == other.end_gas_left)\n    }\n}\n\nimpl Hash for PublicCallStackItemCompressed {\n    fn hash(self) -> Field {\n        std::hash::pedersen_hash_with_separator(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PublicCallStackItemCompressed {\n    fn empty() -> Self {\n        PublicCallStackItemCompressed {\n            contract_address: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n    fn serialize(self) -> [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.push(self.revert_code as Field);\n        fields.extend_from_array(self.start_gas_left.serialize());\n        fields.extend_from_array(self.end_gas_left.serialize());\n\n        assert_eq(fields.len(), PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n  fn deserialize(fields: [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH]) -> PublicCallStackItemCompressed {\n    let mut reader = Reader::new(fields);\n\n    let item = PublicCallStackItemCompressed {\n      contract_address: reader.read_struct(AztecAddress::deserialize),\n      call_context: reader.read_struct(CallContext::deserialize),\n      function_data: reader.read_struct(FunctionData::deserialize),\n      args_hash: reader.read(),\n      returns_hash: reader.read(),\n      revert_code: reader.read() as u8,\n      start_gas_left: reader.read_struct(Gas::deserialize),\n      end_gas_left: reader.read_struct(Gas::deserialize),\n    };\n    reader.finish();\n    item\n  }\n}\n"},"193":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"21":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    fn new(x: Field, y: Field, is_infinite: bool) -> Self {\n        Self { x, y, is_infinite }\n    }\n\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n// Scalar represented as low and high limbs\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    pub fn derive_public_key(self) -> EmbeddedCurvePoint {\n        let public_key = fixed_base_scalar_mul(self.lo, self.hi);\n        EmbeddedCurvePoint { x: public_key[0], y: public_key[1], is_infinite: false }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, key: EmbeddedCurveScalar) -> bool {\n        (key.hi == self.hi) & (key.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n#[foreign(multi_scalar_mul)]\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> [Field; 3]\n// docs:end:multi_scalar_mul\n{}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(\n    scalar_low: Field,\n    scalar_high: Field\n) -> [Field; 3]\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    let scalar = EmbeddedCurveScalar { lo: scalar_low, hi: scalar_high };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n"},"216":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n}\n// docs:end:call-context\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n"},"229":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"235":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<N> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<N> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<N> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<N> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"236":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"// Utility function to console.log data in the acir simulator\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<M, N>(_msg: str<M>, args: [Field]) {}\n\n/// NOTE: call this with a str<N> msg of form\n/// \"some string with {0} and {1} ... {N}\"\n/// and an array of N field which will be formatted\n/// into the string in the simulator.\n/// Example:\n/// debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n/// debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\nunconstrained pub fn debug_log_format<M, N>(msg: str<M>, args: [Field; N]) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n/// NOTE: call this with a str<N> msg of length > 1\n/// Example:\n/// `debug_log(\"blah blah this is a debug string\");`\nunconstrained pub fn debug_log<N>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"247":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"25":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n#[no_predicates]\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    let value = pedersen_commitment_with_separator(input, 0);\n    if (value.x == 0) & (value.y == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value.x, y: value.y, is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        points[i] = EmbeddedCurveScalar::from_field(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let values = multi_scalar_mul(generators, points);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: values[2] as bool }\n}\n\n#[no_predicates]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let v1 = pedersen_commitment_with_separator(input, separator);\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    multi_scalar_mul(\n        [length_generator[0], v1],\n        [EmbeddedCurveScalar { lo: N as Field, hi: 0 }, EmbeddedCurveScalar { lo: 1, hi: 0 }]\n    )[0]\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n#[test]\nfn assert_pedersen_noir() {\n    // TODO: make this a fuzzer test once fuzzer supports curve-specific blackbox functions.\n    let input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq(pedersen_hash_with_separator(input, 4), pedersen_hash_with_separator_noir(input, 4));\n    assert_eq(pedersen_commitment_with_separator(input, 4), pedersen_commitment_with_separator_noir(input, 4));\n}\n"},"263":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"273":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"319":{"path":"/usr/src/noir-projects/aztec-nr/compressed-string/src/compressed_string.nr","source":"use dep::aztec::protocol_types::{utils::field::field_from_bytes, traits::{Eq, Serialize, Deserialize}};\n\n// The general Compressed String.\n// Compresses M bytes into N fields.\n// Can be used for longer strings that don't fit in a single field.\n// Each field can store 31 characters, so N should be M/31 rounded up.\nstruct CompressedString<N, M> {\n  value: [Field; N]\n}\n\nimpl<N, M> CompressedString<N, M> {\n    pub fn from_string(input_string: str<M>) -> Self {\n        let mut fields = [0; N];\n        let byts = input_string.as_bytes();\n\n        let mut r_index = 0 as u32;\n\n        for i in 0..N {\n            let mut temp = [0 as u8; 31];\n            for j in 0..31 {\n                if r_index < M {\n                    temp[j] = byts[r_index];\n                    r_index += 1;\n                }\n            }\n\n            fields[i] = field_from_bytes(temp, true);\n        }\n\n        Self { value: fields }\n    }\n\n    pub fn to_bytes(self) -> [u8; M] {\n        let mut result = [0; M];\n        let mut w_index = 0 as u32;\n        for i in 0..N {\n            let bytes = self.value[i].to_be_bytes(31);\n            for j in 0..31 {\n                if w_index < M {\n                    result[w_index] = bytes[j];\n                    w_index += 1;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<N, M> Eq for CompressedString<N, M> {\n    fn eq(self, other: CompressedString<N, M>) -> bool {\n        self.value == other.value\n    }\n}\n\nimpl<N, M> Serialize<N> for CompressedString<N, M> {\n    fn serialize(self) -> [Field; N] {\n        self.value\n    \n    }\n}\n\nimpl<N, M> Deserialize<N> for CompressedString<N, M> {\n    fn deserialize(input: [Field; N]) -> Self {\n        Self { value: input }\n    }\n}\n\n#[test]\nfn test_short_string() {\n    let i = \"Hello world\";\n    let b = i.as_bytes();\n    let name: CompressedString<1,11> = CompressedString::from_string(i);\n    let p = b == name.to_bytes();\n    assert(p, \"invalid recover\");\n}\n\n#[test]\nfn test_long_string() {\n    let i = \"Hello world. I'm setting up a very long text of blibbablubb such that we can see if works as planned for longer names.\";\n    let b = i.as_bytes();\n    let name: CompressedString<4,118> = CompressedString::from_string(i);\n    let p = b == name.to_bytes();\n    assert(p, \"invalid recover\");\n}\n\n#[test]\nfn test_long_string_work_with_too_many_fields() {\n    let i = \"Hello world. I'm setting up a very long text of blibbablubb such that we can see if works as planned for longer names.\";\n    let b = i.as_bytes();\n    let name: CompressedString<5,118> = CompressedString::from_string(i);\n    let p = b == name.to_bytes();\n    assert(p, \"invalid recover\");\n}\n\n#[test]\nfn test_serde() {\n    let i = \"Hello world. I'm setting up a very long text of blibbablubb such that we can see if works as planned for longer names.\";\n    let name: CompressedString<5,118> = CompressedString::from_string(i);\n\n    assert_eq(name, CompressedString::deserialize(name.serialize()));\n}\n\n#[test(should_fail)]\nfn test_long_string_fail_with_too_few_fields() {\n    let i = \"Hello world. I'm setting up a very long text of blibbablubb such that we can see if works as planned for longer names.\";\n    let b = i.as_bytes();\n    let name: CompressedString<3,118> = CompressedString::from_string(i);\n    let p = b == name.to_bytes();\n    assert(p, \"invalid recover\");\n}\n"},"325":{"path":"/usr/src/noir-projects/noir-contracts/contracts/avm_test_contract/src/main.nr","source":"use dep::aztec::protocol_types::traits::{Serialize, Deserialize};\n\nstruct Note {\n    a: Field,\n    b: Field,\n}\n\nimpl Serialize<2> for Note {\n    fn serialize(self) -> [Field; 2] {\n        [self.a, self.b]\n    }\n}\n\nimpl Deserialize<2> for Note {\n    fn deserialize(wire: [Field; 2]) -> Note {\n        Note {a: wire[0], b: wire[1]}\n    }\n}\n\ncontract AvmTest {\n    use crate::Note;\n\n    global big_field_128_bits: Field = 0x001234567890abcdef1234567890abcdef;\n    global big_field_136_bits: Field = 0x991234567890abcdef1234567890abcdef;\n\n    // Libs\n    use std::embedded_curve_ops::multi_scalar_mul;\n    use dep::aztec::protocol_types::constants::CONTRACT_INSTANCE_LENGTH;\n    use dep::aztec::prelude::{Map, Deserialize};\n    use dep::aztec::state_vars::PublicMutable;\n    use dep::aztec::protocol_types::{address::{AztecAddress, EthAddress}, constants::L1_TO_L2_MESSAGE_LENGTH, point::Point, scalar::Scalar};\n    use dep::aztec::oracle::get_contract_instance::{get_contract_instance_avm, get_contract_instance_internal_avm};\n    use dep::aztec::protocol_types::abis::function_selector::FunctionSelector;\n    use dep::aztec::context::gas::GasOpts;\n    use dep::compressed_string::CompressedString;\n\n    #[aztec(storage)]\n    struct Storage {\n        single: PublicMutable<Field>,\n        list: PublicMutable<Note>,\n        map: Map<AztecAddress, PublicMutable<u32>>,\n    }\n\n    /************************************************************************\n     * Storage\n     ************************************************************************/\n    #[aztec(public)]\n    fn set_storage_single(a: Field) {\n        storage.single.write(a);\n    }\n\n    #[aztec(public)]\n    fn read_storage_single() -> Field {\n        storage.single.read()\n    }\n\n    // should still be able to use ` -> pub *` for return type even though macro forces `pub`\n    #[aztec(public)]\n    fn set_read_storage_single(a: Field) -> pub Field {\n        storage.single.write(a);\n        storage.single.read()\n    }\n\n    #[aztec(public)]\n    fn set_storage_list(a: Field, b: Field) {\n        storage.list.write(Note { a, b });\n    }\n\n    #[aztec(public)]\n    fn read_storage_list() -> [Field; 2] {\n        let note: Note = storage.list.read();\n        note.serialize()\n    }\n\n    #[aztec(public)]\n    fn set_storage_map(to: AztecAddress, amount: u32) -> Field {\n        storage.map.at(to).write(amount);\n        // returns storage slot for key\n        std::hash::pedersen_hash([storage.map.storage_slot, to.to_field()])\n    }\n\n    #[aztec(public)]\n    fn add_storage_map(to: AztecAddress, amount: u32) -> Field {\n        let new_balance = storage.map.at(to).read().add(amount);\n        storage.map.at(to).write(new_balance);\n        // returns storage slot for key\n        std::hash::pedersen_hash([storage.map.storage_slot, to.to_field()])\n    }\n\n    #[aztec(public)]\n    fn read_storage_map(address: AztecAddress) -> u32 {\n        storage.map.at(address).read()\n    }\n\n    #[aztec(public)]\n    fn add_args_return(arg_a: Field, arg_b: Field) -> Field {\n        arg_a + arg_b\n    }\n\n    /************************************************************************\n     * General Opcodes\n     ************************************************************************/\n    #[aztec(public)]\n    fn set_opcode_u8() -> u8 {\n        8 as u8\n    }\n\n    #[aztec(public)]\n    fn set_opcode_u32() -> u32 {\n        1 << 30 as u8\n    }\n\n    #[aztec(public)]\n    fn set_opcode_u64() -> u64 {\n        1 << 60 as u8\n    }\n\n    #[aztec(public)]\n    fn set_opcode_small_field() -> Field {\n        big_field_128_bits\n    }\n\n    #[aztec(public)]\n    fn set_opcode_big_field() -> Field {\n        big_field_136_bits\n    }\n\n    #[aztec(public)]\n    fn add_u128(a: U128, b: U128) -> U128 {\n        a + b\n    }\n\n    #[aztec(public)]\n    fn modulo2(a: u64) -> u64 {\n        a % 2\n    }\n\n    #[aztec(public)]\n    fn elliptic_curve_add_and_double() -> Point {\n        let g = Point { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n\n        let doubled = g + g;\n        let added = g + doubled;\n        added\n    }\n\n    #[aztec(public)]\n    fn variable_base_msm() -> [Field; 3] {\n        let g = Point { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n        let scalar = Scalar { lo: 3, hi: 0 };\n        let scalar2 = Scalar { lo: 20, hi: 0 };\n        let triple_g = multi_scalar_mul([g, g], [scalar, scalar2]);\n        triple_g\n    }\n\n    /************************************************************************\n     * Misc \n     ************************************************************************/\n\n    #[aztec(public)]\n    fn u128_addition_overflow() -> U128 {\n        let max_u128: U128 = U128::from_hex(\"0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\");\n        let one: U128 = U128::from_integer(1);\n        max_u128 + one\n    }\n\n    #[aztec(public)]\n    fn u128_from_integer_overflow() -> U128 {\n        let should_overflow: Field = 2.pow_32(128); // U128::max() + 1;\n        U128::from_integer(should_overflow)\n    }\n\n    #[aztec(public)]\n    fn to_radix_le(input: Field) -> [u8; 10] {\n        let result: [u8] = input.to_le_radix(/*base=*/ 2, /*limbs=*/ 10);\n        result.as_array()\n    }\n\n    // Helper functions to demonstrate an internal call stack in error messages\n    fn inner_helper_with_failed_assertion() {\n        let not_true = false;\n        assert(not_true == true, \"This assertion should fail!\");\n    }\n    fn helper_with_failed_assertion() {\n        inner_helper_with_failed_assertion();\n    }\n\n    #[aztec(public)]\n    fn assertion_failure() {\n        helper_with_failed_assertion()\n    }\n\n    #[aztec(public)]\n    fn debug_logging() {\n        dep::aztec::oracle::debug_log::debug_log(\"just text\");\n        dep::aztec::oracle::debug_log::debug_log_format(\"second: {1}\", [1, 2, 3, 4]);\n        dep::aztec::oracle::debug_log::debug_log_format(\"whole array: {}\", [1, 2, 3, 4]);\n        dep::aztec::oracle::debug_log::debug_log(\"tabs and newlines\\n\\t- first\\n\\t- second\");\n    }\n\n    #[aztec(public)]\n    fn assert_same(arg_a: Field, arg_b: Field) -> pub Field {\n        assert(arg_a == arg_b, \"Values are not equal\");\n        1\n    }\n\n    /************************************************************************\n     * Hashing functions\n     ************************************************************************/\n    #[aztec(public)]\n    fn keccak_hash(data: [u8; 10]) -> [u8; 32] {\n        std::hash::keccak256(data, data.len() as u32)\n    }\n\n    #[aztec(public)]\n    fn poseidon2_hash(data: [Field; 10]) -> Field {\n        std::hash::poseidon2::Poseidon2::hash(data, data.len())\n    }\n\n    #[aztec(public)]\n    fn sha256_hash(data: [u8; 10]) -> [u8; 32] {\n        std::hash::sha256(data)\n    }\n\n    #[aztec(public)]\n    fn pedersen_hash(data: [Field; 10]) -> Field {\n        std::hash::pedersen_hash(data)\n    }\n\n    #[aztec(public)]\n    fn pedersen_hash_with_index(data: [Field; 10]) -> Field {\n        std::hash::pedersen_hash_with_separator(data, /*index=*/ 20)\n    }\n\n    /************************************************************************\n     * Contract instance\n     ************************************************************************/\n    #[aztec(public)]\n    fn test_get_contract_instance_raw() {\n        let fields = get_contract_instance_internal_avm(context.this_address());\n        // The values here should match those in `avm_simulator.test.ts>Contract>GETCONTRACTINSTANCE deserializes correctly`\n        assert(fields.len() == CONTRACT_INSTANCE_LENGTH + 1);\n        assert(fields[0] == 0x1);\n        assert(fields[1] == 0x123);\n        assert(fields[2] == 0x456);\n        assert(fields[3] == 0x789);\n        assert(fields[4] == 0x101112);\n        assert(fields[5] == 0x161718);\n    }\n\n    #[aztec(public)]\n    fn test_get_contract_instance() {\n        let ci = get_contract_instance_avm(context.this_address());\n        assert(ci.is_some(), \"Contract instance not found!\");\n    }\n\n    /************************************************************************\n     * AvmContext functions\n     ************************************************************************/\n    #[aztec(public)]\n    fn get_address() -> AztecAddress {\n        context.this_address()\n    }\n\n    #[aztec(public)]\n    fn get_storage_address() -> AztecAddress {\n        context.storage_address()\n    }\n\n    #[aztec(public)]\n    fn get_sender() -> AztecAddress {\n        context.msg_sender()\n    }\n\n    #[aztec(public)]\n    fn get_function_selector() -> FunctionSelector {\n        context.selector()\n    }\n\n    #[aztec(public)]\n    fn get_transaction_fee() -> Field {\n        context.transaction_fee()\n    }\n\n    #[aztec(public)]\n    fn get_chain_id() -> Field {\n        context.chain_id()\n    }\n\n    #[aztec(public)]\n    fn get_version() -> Field {\n        context.version()\n    }\n\n    #[aztec(public)]\n    fn get_block_number() -> Field {\n        context.block_number()\n    }\n\n    #[aztec(public)]\n    fn get_timestamp() -> u64 {\n        context.timestamp()\n    }\n\n    #[aztec(public)]\n    fn get_fee_per_l2_gas() -> Field {\n        context.fee_per_l2_gas()\n    }\n\n    #[aztec(public)]\n    fn get_fee_per_da_gas() -> Field {\n        context.fee_per_da_gas()\n    }\n\n    #[aztec(public)]\n    fn get_l2_gas_left() -> Field {\n        context.l2_gas_left()\n    }\n\n    #[aztec(public)]\n    fn get_da_gas_left() -> Field {\n        context.da_gas_left()\n    }\n\n    #[aztec(public)]\n    fn assert_timestamp(expected_timestamp: u64) {\n        let timestamp = context.timestamp();\n        assert(timestamp == expected_timestamp, \"timestamp does not match\");\n    }\n\n    #[aztec(public)]\n    fn check_selector() {\n        assert(\n            context.selector() == FunctionSelector::from_signature(\"check_selector()\"), \"Unexpected selector!\"\n        );\n    }\n\n    #[aztec(public)]\n    fn get_args_hash(_a: u8, _fields: [Field; 3]) -> Field {\n        context.get_args_hash()\n    }\n\n    #[aztec(public)]\n    fn emit_unencrypted_log() {\n        context.emit_unencrypted_log(/*message=*/ [10, 20, 30]);\n        context.emit_unencrypted_log(/*message=*/ \"Hello, world!\");\n        let s: CompressedString<2,44> = CompressedString::from_string(\"A long time ago, in a galaxy far far away...\");\n        context.emit_unencrypted_log(/*message=*/ s);\n    }\n\n    #[aztec(public)]\n    fn note_hash_exists(note_hash: Field, leaf_index: Field) -> bool {\n        context.note_hash_exists(note_hash, leaf_index)\n    }\n\n    // Use the standard context interface to emit a new note hash\n    #[aztec(public)]\n    fn new_note_hash(note_hash: Field) {\n        context.push_note_hash(note_hash);\n    }\n\n    // Use the standard context interface to emit a new nullifier\n    #[aztec(public)]\n    fn new_nullifier(nullifier: Field) {\n        context.push_nullifier(nullifier, 0);\n    }\n\n    // Use the standard context interface to check for a nullifier\n    #[aztec(public)]\n    fn nullifier_exists(nullifier: Field) -> bool {\n        context.nullifier_exists(nullifier, context.storage_address())\n    }\n\n    #[aztec(public)]\n    fn assert_nullifier_exists(nullifier: Field) {\n        assert(context.nullifier_exists(nullifier, context.storage_address()), \"Nullifier doesn't exist!\");\n    }\n\n    // Use the standard context interface to emit a new nullifier\n    #[aztec(public)]\n    fn emit_nullifier_and_check(nullifier: Field) {\n        context.push_nullifier(nullifier, 0);\n        let exists = context.nullifier_exists(nullifier, context.storage_address());\n        assert(exists, \"Nullifier was just created, but its existence wasn't detected!\");\n    }\n\n    // Create the same nullifier twice (shouldn't work!)\n    #[aztec(public)]\n    fn nullifier_collision(nullifier: Field) {\n        context.push_nullifier(nullifier, 0);\n        // Can't do this twice!\n        context.push_nullifier(nullifier, 0);\n    }\n\n    #[aztec(public)]\n    fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> bool {\n        context.l1_to_l2_msg_exists(msg_hash, msg_leaf_index)\n    }\n\n    #[aztec(public)]\n    fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n        context.message_portal(recipient, content)\n    }\n\n    /************************************************************************\n     * Nested calls\n     ************************************************************************/\n    #[aztec(public)]\n    fn nested_call_to_add_with_gas(\n        arg_a: Field,\n        arg_b: Field,\n        l2_gas: Field,\n        da_gas: Field\n    ) -> pub Field {\n        AvmTest::at(context.this_address()).add_args_return(arg_a, arg_b).with_gas(GasOpts::new(l2_gas, da_gas)).call(&mut context)\n    }\n\n    // Use the `call_public_function` wrapper to initiate a nested call to the add function\n    #[aztec(public)]\n    fn nested_call_to_add(arg_a: Field, arg_b: Field) -> pub Field {\n        AvmTest::at(context.this_address()).add_args_return(arg_a, arg_b).call(&mut context)\n    }\n\n    // Indirectly call_static the external call opcode to initiate a nested call to the add function\n    #[aztec(public)]\n    fn nested_static_call_to_add(arg_a: Field, arg_b: Field) -> pub Field {\n        AvmTest::at(context.this_address()).add_args_return(arg_a, arg_b).view(&mut context)\n    }\n\n    // Indirectly call_static `set_storage_single`. Should revert since it's accessing storage.\n    #[aztec(public)]\n    fn nested_static_call_to_set_storage() {\n        AvmTest::at(context.this_address()).set_storage_single(20).view(&mut context);\n    }\n\n    #[aztec(public)]\n    fn create_same_nullifier_in_nested_call(nestedAddress: AztecAddress, nullifier: Field) {\n        context.push_nullifier(nullifier, 0);\n        AvmTest::at(nestedAddress).new_nullifier(nullifier).call(&mut context);\n    }\n\n    #[aztec(public)]\n    fn create_different_nullifier_in_nested_call(nestedAddress: AztecAddress, nullifier: Field) {\n        context.push_nullifier(nullifier, 0);\n        AvmTest::at(nestedAddress).new_nullifier(nullifier + 1).call(&mut context);\n    }\n\n    /**\n     * Enqueue a public call from private\n     */\n    #[aztec(private)]\n    fn enqueue_public_from_private() {\n        AvmTest::at(context.this_address()).set_opcode_u8().enqueue_view(&mut context);\n        AvmTest::at(context.this_address()).set_read_storage_single(5).enqueue(&mut context);\n    }\n}\n"},"35":{"path":"std/ops/arith.nr","source":"// docs:start:add-trait\ntrait Add {\n    fn add(self, other: Self) -> Self;\n}\n// docs:end:add-trait\n\nimpl Add for Field { fn add(self, other: Field) -> Field { self + other } }\n\nimpl Add for u64 { fn add(self, other: u64) -> u64 { self + other } }\nimpl Add for u32 { fn add(self, other: u32) -> u32 { self + other } }\nimpl Add for u16 { fn add(self, other: u16) -> u16 { self + other } }\nimpl Add for u8 { fn add(self, other: u8) -> u8 { self + other } }\n\nimpl Add for i8 { fn add(self, other: i8) -> i8 { self + other } }\nimpl Add for i16 { fn add(self, other: i16) -> i16 { self + other } }\nimpl Add for i32 { fn add(self, other: i32) -> i32 { self + other } }\nimpl Add for i64 { fn add(self, other: i64) -> i64 { self + other } }\n\n// docs:start:sub-trait\ntrait Sub {\n    fn sub(self, other: Self) -> Self;\n}\n// docs:end:sub-trait\n\nimpl Sub for Field { fn sub(self, other: Field) -> Field { self - other } }\n\nimpl Sub for u64 { fn sub(self, other: u64) -> u64 { self - other } }\nimpl Sub for u32 { fn sub(self, other: u32) -> u32 { self - other } }\nimpl Sub for u16 { fn sub(self, other: u16) -> u16 { self - other } }\nimpl Sub for u8 { fn sub(self, other: u8) -> u8 { self - other } }\n\nimpl Sub for i8 { fn sub(self, other: i8) -> i8 { self - other } }\nimpl Sub for i16 { fn sub(self, other: i16) -> i16 { self - other } }\nimpl Sub for i32 { fn sub(self, other: i32) -> i32 { self - other } }\nimpl Sub for i64 { fn sub(self, other: i64) -> i64 { self - other } }\n\n// docs:start:mul-trait\ntrait Mul {\n    fn mul(self, other: Self) -> Self;\n}\n// docs:end:mul-trait\n\nimpl Mul for Field { fn mul(self, other: Field) -> Field { self * other } }\n\nimpl Mul for u64 { fn mul(self, other: u64) -> u64 { self * other } }\nimpl Mul for u32 { fn mul(self, other: u32) -> u32 { self * other } }\nimpl Mul for u16 { fn mul(self, other: u16) -> u16 { self * other } }\nimpl Mul for u8 { fn mul(self, other: u8) -> u8 { self * other } }\n\nimpl Mul for i8 { fn mul(self, other: i8) -> i8 { self * other } }\nimpl Mul for i16 { fn mul(self, other: i16) -> i16 { self * other } }\nimpl Mul for i32 { fn mul(self, other: i32) -> i32 { self * other } }\nimpl Mul for i64 { fn mul(self, other: i64) -> i64 { self * other } }\n\n// docs:start:div-trait\ntrait Div {\n    fn div(self, other: Self) -> Self;\n}\n// docs:end:div-trait\n\nimpl Div for Field { fn div(self, other: Field) -> Field { self / other } }\n\nimpl Div for u64 { fn div(self, other: u64) -> u64 { self / other } }\nimpl Div for u32 { fn div(self, other: u32) -> u32 { self / other } }\nimpl Div for u16 { fn div(self, other: u16) -> u16 { self / other } }\nimpl Div for u8 { fn div(self, other: u8) -> u8 { self / other } }\n\nimpl Div for i8 { fn div(self, other: i8) -> i8 { self / other } }\nimpl Div for i16 { fn div(self, other: i16) -> i16 { self / other } }\nimpl Div for i32 { fn div(self, other: i32) -> i32 { self / other } }\nimpl Div for i64 { fn div(self, other: i64) -> i64 { self / other } }\n\n// docs:start:rem-trait\ntrait Rem{\n    fn rem(self, other: Self) -> Self;\n}\n// docs:end:rem-trait\n\nimpl Rem for u64 { fn rem(self, other: u64) -> u64 { self % other } }\nimpl Rem for u32 { fn rem(self, other: u32) -> u32 { self % other } }\nimpl Rem for u16 { fn rem(self, other: u16) -> u16 { self % other } }\nimpl Rem for u8 { fn rem(self, other: u8) -> u8 { self % other } }\n\nimpl Rem for i8 { fn rem(self, other: i8) -> i8 { self % other } }\nimpl Rem for i16 { fn rem(self, other: i16) -> i16 { self % other } }\nimpl Rem for i32 { fn rem(self, other: i32) -> i32 { self % other } }\nimpl Rem for i64 { fn rem(self, other: i64) -> i64 { self % other } }\n\n// docs:start:neg-trait\ntrait Neg {\n    fn neg(self) -> Self;\n}\n// docs:end:neg-trait\n\n// docs:start:neg-trait-impls\nimpl Neg for Field { fn neg(self) -> Field { -self } }\n\nimpl Neg for i8 { fn neg(self) -> i8 { -self } }\nimpl Neg for i16 { fn neg(self) -> i16 { -self } }\nimpl Neg for i32 { fn neg(self) -> i32 { -self } }\nimpl Neg for i64 { fn neg(self) -> i64 { -self } }\n// docs:end:neg-trait-impls\n\n"},"38":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"44":{"path":"std/slice.nr","source":"use crate::append::Append;\n\nimpl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::unsafe::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"},"47":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<N, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<N, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"95":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn block_number(self) -> Field {\n        block_number()\n    }\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<N>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<N>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, N>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N)\n}\n\nunconstrained fn storage_write<N>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<N>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<N>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}