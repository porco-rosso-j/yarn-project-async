{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"Claim","functions":[{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"target_contract","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"reward_token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"claim","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"proof_note","type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"npk_m_hash","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}},{"name":"header","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"nonce","type":{"kind":"field"}},{"name":"storage_slot","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::note::note_header::NoteHeader"}}],"kind":"struct","path":"value_note::value_note::ValueNote"},"visibility":"private"},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"pending_shields","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"target_contract","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"reward_token","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"target_contract","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"reward_token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Claim::constructor_parameters"}}],"kind":"struct","path":"Claim::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"proof_note","type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"npk_m_hash","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}},{"name":"header","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"nonce","type":{"kind":"field"}},{"name":"storage_slot","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::note::note_header::NoteHeader"}}],"kind":"struct","path":"value_note::value_note::ValueNote"}},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Claim::claim_parameters"}}],"kind":"struct","path":"Claim::claim_abi"}]}},"file_map":{"112":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__INNER_NOTE_HASH,\n    hash::{\n    pedersen_hash, compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_inner_note_hash_from_preimage(storage_slot: Field, note_content_hash: Field) -> Field {\n    pedersen_hash(\n        [storage_slot, note_content_hash],\n        GENERATOR_INDEX__INNER_NOTE_HASH\n    )\n}\n\nfn compute_inner_note_hash<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    compute_inner_note_hash_from_preimage(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N, M>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let (_, inner_nullifier) = note_with_header.compute_note_hash_and_nullifier(context);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\nfn compute_note_hash_for_read_request_from_innter_and_nonce(\n    inner_note_hash: Field,\n    nonce: Field\n) -> Field {\n    // TODO(#1386): This if-else can be nuked once we have nonces injected from public\n    if (nonce == 0) {\n        // If nonce is zero, that means we are reading a public note.\n        inner_note_hash\n    } else {\n        compute_unique_note_hash(nonce, inner_note_hash)\n    }\n}\n\npub fn compute_note_hash_for_read_request<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let inner_note_hash = compute_inner_note_hash(note);\n    let nonce = note.get_header().nonce;\n\n    compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, nonce)\n}\n\npub fn compute_note_hash_for_consumption<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    if (header.note_hash_counter != 0) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        inner_note_hash\n    } else {\n        // If a note is not transient, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the siloed_note_hash which has already been hashed with\n        // nonce and then contract address. This hash will match the existing leaf in the note hash\n        // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, header.nonce);\n        compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, N, M, S>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n    let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, note_header.nonce);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        let (_, nullifier) = note.compute_note_hash_and_nullifier_without_context();\n        nullifier\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [inner_note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"122":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::{compute_siloed_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_contract_initialization_nullifier(context.this_address());\n    let header = context.get_header();\n    header.prove_nullifier_inclusion(init_nullifier);\n}\n\nfn compute_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    compute_siloed_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(address)\n    )\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"123":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr","source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"},"125":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"128":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n"},"131":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_membership_witness.nr","source":"use dep::protocol_types::{constants::{ARCHIVE_HEIGHT, NOTE_HASH_TREE_HEIGHT}, utils::arr_copy_slice};\n\nglobal NOTE_HASH_TREE_ID = 1;\nglobal ARCHIVE_TREE_ID = 4;\n\n// Note: We have M here because we need to somehow set it when calling get_membership_witness function and one way to\n// do it is to set M here and then set type of the return param, e.g.:\n//\n// `let witness: MembershipWitness<NOTE_HASH_TREE_HEIGHT, NOTE_HASH_TREE_HEIGHT + 1> = get_membership_witness(...);`\n//\n// Another way to do it would be to add \"type_hint: [Field; T]\" as argument to `get_membership_witness` but that's\n// a bit too boilerplatey for my taste.\nstruct MembershipWitness<N, M> {\n    index: Field,\n    path: [Field; N],\n}\n\n#[oracle(getMembershipWitness)]\nunconstrained fn get_membership_witness_oracle<M>(\n    _block_number: u32,\n    _tree_id: Field,\n    _leaf_value: Field\n) -> [Field; M] {}\n\nunconstrained pub fn get_membership_witness<N, M>(\n    block_number: u32,\n    tree_id: Field,\n    leaf_value: Field\n) -> MembershipWitness<N, M> {\n    let fields: [Field; M] = get_membership_witness_oracle(block_number, tree_id, leaf_value);\n    MembershipWitness { index: fields[0], path: arr_copy_slice(fields, [0; N], 1) }\n}\n\n// Note: get_nullifier_membership_witness function is implemented in get_nullifier_membership_witness.nr\n\nunconstrained pub fn get_note_hash_membership_witness<N, M>(\n    block_number: u32,\n    leaf_value: Field\n) -> MembershipWitness<NOTE_HASH_TREE_HEIGHT, NOTE_HASH_TREE_HEIGHT + 1> {\n    get_membership_witness(block_number, NOTE_HASH_TREE_ID, leaf_value)\n}\n\n// There is no `get_public_data_membership_witness` function because it doesn't make sense to be getting a membership\n// witness for a value in the public data tree.\n\nunconstrained pub fn get_archive_membership_witness(\n    block_number: u32,\n    leaf_value: Field\n) -> MembershipWitness<ARCHIVE_HEIGHT, ARCHIVE_HEIGHT + 1> {\n    get_membership_witness(block_number, ARCHIVE_TREE_ID, leaf_value)\n}\n"},"139":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"140":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{\n    abis::{\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\n    utils::reader::Reader,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n}\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\n    let mut reader = Reader::new(fields);\n\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n    // WARNING: if updating, see comment in public_call_stack_item.ts's PublicCallStackItem.hash()\n    let item = PublicCallStackItem {\n        contract_address: AztecAddress::from_field(reader.read()),\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\n        public_inputs: PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            args_hash: reader.read(),\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            end_side_effect_counter: 0,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0\n        },\n        is_execution_request: true\n    };\n    reader.finish();\n\n    item\n}\n"},"149":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr","source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext}, oracle::storage::storage_read,\n    state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PublicContext> {\n    // Intended to be only called once. \n    pub fn initialize<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T> SharedImmutable<T, UnconstrainedContext> {\n    unconstrained pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PrivateContext> {\n    pub fn read_private<T_SERIALIZED_LEN>(self) -> T  where T: Deserialize<T_SERIALIZED_LEN> {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n"},"173":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item_compressed.nr","source":"use crate::abis::{call_context::CallContext, function_data::FunctionData, gas::Gas};\nuse crate::address::AztecAddress;\nuse crate::constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH};\nuse crate::traits::{Hash, Empty, Serialize, Deserialize};\nuse crate::utils::reader::Reader;\n\n/**\n * A compressed version of the PublicCallStackItem struct used to compute the \"hash\"\n * of a PublicCallStackItem.\n * \n * Historically, we have been zeroing most values in the PublicCallStackItem struct\n * to compute the hash involved when adding a PublicCallStackItem to the PublicCallStack.\n * \n * This struct is used to store the values that we did not zero out, and allow us to hash\n * only these, thereby skipping a lot of computation and saving us a lot of constraints\n * \n * Essentially this struct exists such that we don't have a `hash` function in the \n * PublicCallStackItem struct that practically throws away some values of the struct\n * without clearly indicating that it does so.\n */\nstruct PublicCallStackItemCompressed {\n    contract_address: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    revert_code: u8,\n    start_gas_left: Gas,\n    end_gas_left: Gas,\n}\n\nimpl Eq for PublicCallStackItemCompressed {\n    fn eq(self, other: PublicCallStackItemCompressed) -> bool {\n        (self.contract_address == other.contract_address)\n            & (self.call_context == other.call_context)\n            & (self.function_data == other.function_data)\n            & (self.args_hash == other.args_hash)\n            & (self.returns_hash == other.returns_hash)\n            & (self.revert_code == other.revert_code)\n            & (self.start_gas_left == other.start_gas_left)\n            & (self.end_gas_left == other.end_gas_left)\n    }\n}\n\nimpl Hash for PublicCallStackItemCompressed {\n    fn hash(self) -> Field {\n        std::hash::pedersen_hash_with_separator(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PublicCallStackItemCompressed {\n    fn empty() -> Self {\n        PublicCallStackItemCompressed {\n            contract_address: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n    fn serialize(self) -> [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.push(self.revert_code as Field);\n        fields.extend_from_array(self.start_gas_left.serialize());\n        fields.extend_from_array(self.end_gas_left.serialize());\n\n        assert_eq(fields.len(), PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n  fn deserialize(fields: [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH]) -> PublicCallStackItemCompressed {\n    let mut reader = Reader::new(fields);\n\n    let item = PublicCallStackItemCompressed {\n      contract_address: reader.read_struct(AztecAddress::deserialize),\n      call_context: reader.read_struct(CallContext::deserialize),\n      function_data: reader.read_struct(FunctionData::deserialize),\n      args_hash: reader.read(),\n      returns_hash: reader.read(),\n      revert_code: reader.read() as u8,\n      start_gas_left: reader.read_struct(Gas::deserialize),\n      end_gas_left: reader.read_struct(Gas::deserialize),\n    };\n    reader.finish();\n    item\n  }\n}\n"},"180":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point::new(fields[0], fields[1], fields[2] as bool),\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"192":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr","source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n  fn eq(self, other: Self) -> bool {\n    (self.nullifier == other.nullifier) &\n    (self.next_nullifier == other.next_nullifier) &\n    (self.next_index == other.next_index)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"193":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"216":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n}\n// docs:end:call-context\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n"},"22":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"235":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<N> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<N> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<N> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<N> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"238":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"246":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: Field = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point {\n            x: 0,\n            y: 0,\n            is_infinite: false\n        }\n    }\n}\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn pub_key_to_bytes(pk: Point) -> [u8; 64] {\n    assert(!pk.is_infinite, \"Point at infinity is not a valid public key.\");\n    let mut result = [0 as u8; 64];\n    let x_bytes = pk.x.to_be_bytes(32);\n    let y_bytes = pk.y.to_be_bytes(32);\n    for i in 0..32 {\n        result[i] = x_bytes[i];\n        result[i + 32] = y_bytes[i];\n    }\n    result\n}\n"},"247":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"25":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n#[no_predicates]\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    let value = pedersen_commitment_with_separator(input, 0);\n    if (value.x == 0) & (value.y == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value.x, y: value.y, is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        points[i] = EmbeddedCurveScalar::from_field(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let values = multi_scalar_mul(generators, points);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: values[2] as bool }\n}\n\n#[no_predicates]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let v1 = pedersen_commitment_with_separator(input, separator);\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    multi_scalar_mul(\n        [length_generator[0], v1],\n        [EmbeddedCurveScalar { lo: N as Field, hi: 0 }, EmbeddedCurveScalar { lo: 1, hi: 0 }]\n    )[0]\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n#[test]\nfn assert_pedersen_noir() {\n    // TODO: make this a fuzzer test once fuzzer supports curve-specific blackbox functions.\n    let input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq(pedersen_hash_with_separator(input, 4), pedersen_hash_with_separator_noir(input, 4));\n    assert_eq(pedersen_commitment_with_separator(input, 4), pedersen_commitment_with_separator_noir(input, 4));\n}\n"},"263":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"273":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"315":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr","source":"use dep::aztec::{\n    prelude::{AztecAddress, NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash},\n    note::utils::compute_note_hash_for_consumption, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app\n};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\nglobal TOKEN_NOTE_LEN: Field = 3; // 3 plus a header.\n// TOKEN_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TOKEN_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n#[aztec(note)]\nstruct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NoteInterface<TOKEN_NOTE_LEN, TOKEN_NOTE_BYTES_LEN> for TokenNote {\n    // docs:start:nullifier\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self {\n            amount,\n            npk_m_hash: owner_npk_m_hash,\n            randomness: unsafe_rand(),\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n"},"317":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr","source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::{note_getter_options::PropertySelector, utils::compute_note_hash_for_consumption},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash}\n};\n\nglobal TRANSPARENT_NOTE_LEN: Field = 2;\n// TRANSPARENT_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TRANSPARENT_NOTE_BYTES_LEN: Field = 2 * 32 + 64;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[aztec(note)]\nstruct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nstruct TransparentNoteProperties {\n    amount: PropertySelector,\n    secret_hash: PropertySelector,\n}\n\nimpl NoteInterface<TRANSPARENT_NOTE_LEN, TRANSPARENT_NOTE_BYTES_LEN> for TransparentNote {\n\n    // Custom serialization to avoid disclosing the secret field\n    fn serialize_content(self) -> [Field; TRANSPARENT_NOTE_LEN] {\n        [self.amount, self.secret_hash]\n    }\n\n    // Custom deserialization since we don't have access to the secret plaintext\n    fn deserialize_content(serialized_note: [Field; TRANSPARENT_NOTE_LEN]) -> Self {\n        TransparentNote {\n            amount: serialized_note[0],\n            secret_hash: serialized_note[1],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): Ensure nullifier collisions are prevented\n    fn compute_note_hash_and_nullifier(self, _context: &mut PrivateContext) -> (Field, Field) {\n        self.compute_note_hash_and_nullifier_without_context()\n    }\n\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit. \n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n\n    // CUSTOM FUNCTIONS FOR THIS NOTE TYPE\n    // Custom serialization forces us to manually create the metadata struct and its getter\n    pub fn properties() -> TransparentNoteProperties {\n        TransparentNoteProperties {\n            amount: PropertySelector { index: 0, offset: 0, length: 32 },\n            secret_hash: PropertySelector { index: 1, offset: 0, length: 32 }\n        }\n    }\n}\n// docs:end:token_types_all\n"},"32":{"path":"std/merkle.nr","source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n"},"330":{"path":"/usr/src/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Deserialize, Serialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n"},"338":{"path":"/usr/src/noir-projects/noir-contracts/contracts/claim_contract/src/main.nr","source":"contract Claim {\n    use dep::aztec::{\n        protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress},\n        state_vars::SharedImmutable\n    };\n    use dep::value_note::value_note::ValueNote;\n    use dep::token::Token;\n\n    #[aztec(storage)]\n    struct Storage {\n      // Address of a contract based on whose notes we distribute the rewards\n      target_contract: SharedImmutable<AztecAddress>,\n      // Token to be distributed as a reward when claiming\n      reward_token: SharedImmutable<AztecAddress>,\n    }\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(target_contract: AztecAddress, reward_token: AztecAddress) {\n        storage.target_contract.initialize(target_contract);\n        storage.reward_token.initialize(reward_token);\n    }\n\n    #[aztec(private)]\n    fn claim(proof_note: ValueNote, recipient: AztecAddress) {\n        // 1) Check that the note corresponds to the target contract and belongs to the sender\n        let target_address = storage.target_contract.read_private();\n        assert(\n            target_address == proof_note.header.contract_address, \"Note does not correspond to the target contract\"\n        );\n\n        // 2) Prove that the note hash exists in the note hash tree\n        let header = context.get_header();\n        header.prove_note_inclusion(proof_note);\n\n        // 3) Compute and emit a nullifier which is unique to the note and this contract to ensure the reward can be\n        // claimed only once with the given note.\n        // Note: Only the owner of the npk_m will be able to produce the nsk_app and compute this nullifier.\n        // The nullifier is unique to the note and THIS contract because the protocol siloes all nullifiers with\n        // the address of a contract it was emitted from.\n        let (_, nullifier) = proof_note.compute_note_hash_and_nullifier(&mut context);\n        context.push_nullifier(nullifier, 0);\n\n        // 4) Finally we mint the reward token to the sender of the transaction\n        Token::at(storage.reward_token.read_private()).mint_public(recipient, proof_note.value).enqueue(&mut context);\n    }\n}\n"},"38":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"47":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"65":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::PrivateContext,\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}},\n    state_vars::{shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter}\n};\n\nglobal DELAY = 5;\n\n// docs:start:key-getters\ntrait KeyGetters {\n  fn get_npk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ivpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ovpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_tpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_npk_m_hash(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Field;\n}\n\nimpl KeyGetters for Header {\n    fn get_npk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, NULLIFIER_INDEX, self)\n    }\n\n    fn get_ivpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, INCOMING_INDEX, self)\n    }\n\n    fn get_ovpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, OUTGOING_INDEX, self)\n    }\n\n    fn get_tpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, TAGGING_INDEX, self)\n    }\n\n    fn get_npk_m_hash(self, context: &mut PrivateContext, address: AztecAddress) -> Field {\n        get_master_key(context, address, NULLIFIER_INDEX, self).hash()\n    }\n}\n// docs:end:key-getters\n\nfn get_master_key(\n    context: &mut PrivateContext,\n    address: AztecAddress,\n    key_index: Field,\n    header: Header\n) -> Point {\n    let key = fetch_key_from_registry(context, key_index, address, header);\n    if is_empty(key) {\n        // Keys were not registered in registry yet --> fetch key from PXE\n        let keys = fetch_and_constrain_keys(address);\n        // Return the corresponding to index\n        keys.get_key_by_index(key_index)\n    } else {\n        // Keys were registered --> return the key\n        key\n    }\n}\n\nfn fetch_key_from_registry(\n    context: &mut PrivateContext,\n    key_index: Field,\n    address: AztecAddress,\n    header: Header\n) -> Point {\n    let x_coordinate_map_slot = key_index * 2 + 1;\n    let y_coordinate_map_slot = x_coordinate_map_slot + 1;\n    let x_coordinate_derived_slot = derive_storage_slot_in_map(x_coordinate_map_slot, address);\n    let y_coordinate_derived_slot = derive_storage_slot_in_map(y_coordinate_map_slot, address);\n\n    let x_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        x_coordinate_derived_slot\n    );\n    let y_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        y_coordinate_derived_slot\n    );\n    let x_coordinate = x_coordinate_registry.get_value_in_private(header);\n    let y_coordinate = y_coordinate_registry.get_value_in_private(header);\n\n    Point::new(x_coordinate, y_coordinate, false)\n}\n\n// Passes only when keys were not rotated - is expected to be called only when keys were not registered yet\nfn fetch_and_constrain_keys(address: AztecAddress) -> PublicKeys {\n    let (public_keys, partial_address) = get_public_keys_and_partial_address(address);\n\n    let computed_address = AztecAddress::compute(public_keys.hash(), partial_address);\n\n    assert(computed_address.eq(address));\n\n    public_keys\n}\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n"},"79":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/note_inclusion.nr","source":"use std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    note::{utils::compute_note_hash_for_consumption, note_interface::NoteInterface},\n    oracle::get_membership_witness::get_note_hash_membership_witness\n};\n\ntrait ProveNoteInclusion {\n    fn prove_note_inclusion<Note, N, M>(header: Header, note: Note) where Note: NoteInterface<N, M>;\n}\n\nimpl ProveNoteInclusion for Header {\n    fn prove_note_inclusion<Note, N, M>(self, note: Note) where Note: NoteInterface<N, M> {\n        // 1) Compute note_hash\n        let note_hash = compute_note_hash_for_consumption(note);\n\n        // 2) Get the membership witness of the note in the note hash tree\n        let witness = get_note_hash_membership_witness(self.global_variables.block_number as u32, note_hash);\n\n        // 3) Prove that the commitment is in the note hash tree\n        assert_eq(\n            self.state.partial.note_hash_tree.root, compute_merkle_root(note_hash, witness.index, witness.path), \"Proving note inclusion failed\"\n        );\n    }\n}\n"},"80":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n"},"81":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr","source":"use std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext, oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: Header, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for Header {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier);\n\n        // 2) Check that the witness we obtained matches the nullifier\n        assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n        // 3) Compute the nullifier tree leaf\n        let nullifier_leaf = witness.leaf_preimage.hash();\n\n        // 4) Prove that the nullifier is in the nullifier tree\n        assert(\n            self.state.partial.nullifier_tree.root\n            == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n        );\n        // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n        //     was included in the nullifier tree.\n    }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, N, M>(header: Header, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M>;\n}\n\nimpl ProveNoteIsNullified for Header {\n    // docs:start:prove_note_is_nullified\n    fn prove_note_is_nullified<Note, N, M>(self, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M> {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n    // docs:end:prove_note_is_nullified\n}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<N, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<N, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"95":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn block_number(self) -> Field {\n        block_number()\n    }\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<N>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<N>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, N>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N)\n}\n\nunconstrained fn storage_write<N>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<N>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<N>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}