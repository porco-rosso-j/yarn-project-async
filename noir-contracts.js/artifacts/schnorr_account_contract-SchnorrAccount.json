{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"SchnorrAccount","functions":[{"name":"constructor","is_unconstrained":false,"custom_attributes":["aztec(private)","aztec(initializer)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"signing_pub_key_x","type":{"kind":"field"},"visibility":"private"},{"name":"signing_pub_key_y","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"verify_private_authwit","is_unconstrained":false,"custom_attributes":["aztec(private)","aztec(noinitcheck)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"entrypoint","is_unconstrained":false,"custom_attributes":["aztec(private)","aztec(noinitcheck)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"},"visibility":"private"},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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jXV7QruUlpLY2o425fiEdiktNUQrrtAupaWGaJfSUtLL/uZ5k/SEdiktNUS7lJbKW9s7UA71STnGpbTUCG1aSksN0YJrqb4HGN7+W57LBxdHo/LB1U7v+w/tN5U6+KH9K9gtPF4c6l8/nqvcPPUdsDHIo0PH7TPYkMv2eOv2J9h/lZ9tl19sl19tl99sl99Nly+b7fKD7fKj7fKT7fJtd12x3XXFdtcV211XbHddsd11s+2um2133Wy762bbXffyK3yUy7fddbPtrpttd91su+tm21232O66xXbXLba7brHddS+/1kK5fNtdt9juusV21y22u26x3XWr7a5bbXfdarvrVttd9/L4ceXybXfdarvrVttdt9ruutV21222u26z3XWb7a7bbHfdy+Nylcu33XWb7a7bbHfdZrvrNttdt9vuut121+22u2633XUvj6VULt921+22u2633XW77a7bTXfdvpnuun0z3XX7Zrrr9s101+2b6a7bN9Ndt2+mu27fTHfdvpnuun2z3XWD7a4bbHfdYLvrBttd9/KgN+XybXfdYLvrBttdN9juusF21422u2603XWj7a4bbXfdyyPBlMu33XWj7a4bbXfdaLvrRttdN9nuusl21022u26y3XVtZ1N129lU3XY2VbedTdVtZ1N129lU3XY2VbedTdVtZ1N129lU3XY2VbedTdVtZ1N129lU3XY2VbedTdVtZ1N129lU3XY2VbedTdVtZ1N129lU3XY2VbedTdVtZ1N129lU3XY2VbedTdVtZ1N129lU3XY2VbedTdVtZ1N129lU3XY2VbedTdVtZ1N129lU3XY2VbedTdVtZ1N129lU3XY2VbedTdVtZ1N129lU3XY2VbedTdVtZ1N129lU3XY2VbedTdVtZ1N129lU3XY2VbedTdVtZ1N129lU3XY2VbedTdVtZ1N129lU3XY2VbedTdVtZ1N129lUYbMdTnWr33TfvdVvuvHe6jfdeW/1m269t/pN995b/aab761+0933Vr/p9nur33j/RY+painub92DPNcP3n+H9YP332H94P13WD94/x3WD95/h/WD999h/eD9d1g/dv8tW0r3ty5b2Z7rx+6/w/rBA6tKTftbl1rjc/3Y/XdcP3b/HdeP3X9L7Y/6W+rP9WP333H92P13XD92/x3Xj91/x/WD999h/eD9d1Q/eHRV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+sV4/dl4/cV4/dV4/c14/d12/ZfHmWvXH4zXH43Xb7z/Xh6zrV2/8f4rxvuvGO+/Yrz/ivH+m43332y8/2bj/Tcb77+XxxFr12+8/2bj/Tcb77/ZeP/NxvtvMd5/i/H+W4z332K8/14eXKtdv/H+W4z332K8/xbj/bcY77/VeP+txvtvNd5/q/H+e3nEqXb9xvtvNd5/q/H+W43332q8/zbj/bcZ77/NeP9txvvv5Vmb2vUb77/NeP9txvtvM95/m/H+24333268/3bj/bcb77+XZzZq12+8/3bj/bcb77/deP/ttvtv32z3377Z7r99s91/+2a7//bNdv/tm+3+2zfb/bdvtvtv32z3374Z77/BeP8NxvtvMN5/g/H+e3mGnHb9xvtvMN5/g/H+G4z332C8/0bj/Tca77/ReP+Nxvvv5Vlk2vUb77/ReP+NxvtvNN5/o/H+m4z332S8/ybj/dd4/lU3nn/VjedfdeP5V914/lU3nn/VjedfdeP5V914/lU3nn/VjedfdeP5V914/lU3nn/VjedfdeP5V914/lU3nn/VjedfdeP5V914/lU3nn/VjedfdeP5V914/lU3nn/VjedfdeP5V914/lU3nn/VjedfdeP5V914/lU3nn/VjedfdeP5V914/lU3nn/VjedfdeP5V914/lU3nn/VjedfdeP5V914/lU3nn/VjedfdeP5V914/lU3nn/VjedfdeP5V914/lU3nn/VjedfdeP5V914/lU3nn/VjedfdeP5V914/lU3nn/VjedfdeP5V914/lU3nn/Vbedfpc12/tWtftP991a/6f57q990/73Vb7r/3uo33X9v9Zvuv7f6TfffW/2m+++tfvD+21Lc6+9BnupHz78a1g/ef4f1g/ffYf3g/XdYP3j/HdYP3n+H9YP332H92P23bCnd37psZXuuH7v/juvH7r+lpl0/lFrjU/3g+Vfj+rH777h+7P5ban/U31J/rh+7/47rx+6/4/qx+++4fuz+O64fvP8O6wfvv8P6wftvy+1Rf3+uHzz/alw/eP8d1o/df+vNYO1vvbX0XD92/61hC/tbh5Kf68fuv+P6sfvvuH7s/ltr7ftbty/vvdeP3X/H9WP339r6Y//p/fn8GTz/alg/eP7VuH7s/ttSK/e3bi39sf+8atey71YlP8rOv7Fi92pdrNh9XRerOMKK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W33X2q2+a+1W37V2q+9au9V3rd3qu9Zu9V1rt/qutVt919qtvmvtVt+1dqvvWrvVd63d6rvWbvVda7f6rrVbfdfarb5r7VbftXar71q71Xet3eq71m71XWu3+q61W33X2q2+a+1W37V2q+9au9V3rd3qu9Zu9V1rt/qutVt919qtvmvtVt+1dqvvWrvVd63d6rvWbvVda7f6rrVbfdfarb5r7VbftXar71q71Xet3eq71m71XWu3+q61W33X2q2+a+1W37V2q+9au9V3rd3qu9Zu9V1rt/qutVt919qtvmvtVt+1dqvvWrvVd63d6rvWbvVda7f6rrVbfdfarb5r7VbftXar71q71Q+t3eqH1m71Q2u3+qG1W/24da1xpVzVobVb/dDarX5o7VY/tHarH1q71Q+t3eqH1m71Q2u3+qG1W/3Q2q1+aO1WP7R2qx9au9UPrd3qh9Zu9UNrt/qhtVv90NqtfmjtVj+0dqsfWrvVD63d6ofWbvVDa7f6obVb/dDarX5o7VY/tHarH1q71Q+t3eqH1m71Q2u3+qG1W/3Q2q1+aO1WP7R2qx9au9UPrd3qh9Zu9UNrt/qhtVv90NqtfmjtVj+0dqsfWrvVD63d6ofWbvVDa7f6obVb/dDarX5o7VY/tHarH1q71Q+t3eqH1m71Q2u3+qG1W/3Q2q1+aO1WP7R2qx9au9UPrd3qh9Zu9UNrt/qhtVv90NqtfmjtVj+0dqsfWrvVD63d6ofWbvVDa7f6obVb/dDarX5o7VY/tHarH1q71Q+t3eqH1m71Q2u3+qG1W/3Q2q1+aO1WP7R2qx9au9UPrd3qh9Zu9UNrt/qhtVv90NqtfmjtVj+0dqsfWrvVD6nd6ttNarf617hKruprXCVX9TWukqv6Grdrjavkqr7GVXJVX+MquaqvcZVc1de4Wq5Karf617harkpqt/rXuFquSmq3+te4Wq5Karf617harkpqt/rXuFquSmq3+te4Wq5Karf617harkpqt/rXuFquSmq3+te4Wq5Karf617harkpqt/rXuFquSmq3+te4Wq5Karf617harkpqt/rXuFquSmq3+te4Wq5Karf617harkpqt/rXuFquSmq3+te4Wq5Karf617harkpqt/rXuFquSmq3+te4Wq5Karf617harkpqt/rXuFquSmq3+te4Wq5Karf617harkpq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/irT9uSuesX8VaZNwV31ivmrTFtxu+oV81eZNsB21SvmrzJtO+2qV8xfZdrs2VWvmL/KtMWyq14xf5VpY2NXvWL+KtN2wq56xfxVpk18XfWK+atMW+e66hXzV5k2rHXVK+avMm0T66pXzF9l2pzVVa+Yv8q0JaqrXjF/lWkjUle9Yv4q0/afrnrF/FWmTTdd9Yr5q0xbXbrqFfNXmTaYdNUr5q8ybevoqlfMX2XaTNFVr5i/yrSFoateMX+VaeNAV71i/irT5P6uesX8Vabp+l31ivmrTBPwu+oV81eZptR31SvmrzJNku+qV8xfZZr23lWvmL8Sm9++i81v38Xmt+9i89t3sfntu9j89l1sfvsuNr99F5vfvovNb9/F5rfvYvPbd7H57bvY/PZdbH77Lja/fReb376LzW+vYvPbq9j89io2v72KzW+vtyJWr5a/qmLz26vY/PYqNr+9is1vr2Lz26vY/PYqNr+9is1vr2Lz26vY/PYqNr+9is1vr2Lz26vY/PYqNr+9is1vr2Lz26vY/PYqNr+9is1vr2Lz26vY/PYqNr+9is1vr2Lz26vY/PYqNr+9is1vr2Lz26vY/PYqNr+9is1vr2Lz26vY/PYqNr+9is1vr2Lz26vY/PYqNr+9is1vr2Lz26vY/PYqNr+9is1vr2Lz26vY/PYqNr+9is1vr2Lz26vY/PYqNr+9is1vr2Lz26vY/PYqNr+9is1vr2Lz26vY/PYqNr+9is1vr2Lz26vY/PYqNr+9is1vr2Lz26vY/PYqNr+9is1vr2Lz26vY/PYqNr+9is1vr2Lz26vY/PYqNr+9is1vr2Lz26vY/PYqNr+9is1vr2Lz26vY/PYqNr+9is1vr2Lz26vY/PYqNr+9is1vr2Lz26vY/PYqNr+9is1vr2Lz26vY/PYmNr+9ic1vb2Lz25vY/PZ2K2L1avmrJja/vYnNb29i89ub2Pz2Jja/vYnNb29i89ub2Pz2Jja/vYnNb29i89ub2Pz2Jja/vYnNb29i89ub2Pz2Jja/vYnNb29i89ub2Pz2Jja/vYnNb29i89ub2Pz2Jja/vYnNb29i89ub2Pz2Jja/vYnNb29i89ub2Pz2Jja/vYnNb29i89ub2Pz2Jja/vYnNb29i89ub2Pz2Jja/vYnNb29i89ub2Pz2Jja/vYnNb29i89ub2Pz2Jja/vYnNb29i89ub2Pz2Jja/vYnNb29i89ub2Pz2Jja/vYnNb29i89ub2Pz2Jja/vYnNb29i89ub2Pz2Jja/vYnNb29i89ub2Pz2Jja/vYnNb29i89ub2Pz2Jja/vYnNb29i89ub2Pz2Jja/vYnNb29i89ub2Pz2Jja/vYnNb29i89ub2Pz2Jja/vYnNb29i89ub2Pz2Jja/vYnNb29i89ub2Pz2Jja/vWnNb99vWvPb7/VK+at7vVL+6l6vlL+611vE6pXyV/d6pfzVvV4pf3WvV8pf3esV81da89vv9Yr5K6357fd6xfyV1vz2e71i/kprfvu9XjF/pTW//V6vmL/Smt9+r1fMX2nNb7/XK+avtOa33+sV81da89vv9Yr5K6357fd6xfyV1vz2e71i/kprfvu9XjF/pTW//V6vmL/Smt9+r1fMX2nNb7/XK+avtOa33+sV81da89vv9Yr5K6357fd6xfyV1vz2e71i/kprfvu9XjF/pTW//V6vmL/Smt9+r1fMX2nNb7/XK+avtOa33+sV81da89vv9Yr5K6357fd6xfyV1vz2e71i/kprfvu9XjF/pTW//V6vmL/Smt9+r1fMX2nNb7/XK+avtOa33+sV81da89vv9Yr5K6357fd6xfyV1vz2e71i/kprfvu9XjF/pTW//V6vmL/Smt9+r1fMX2nNb7/XK+avtOa33+sV81da89vv9Yr5K6357fd6xfyV1vz2e71i/kprfvu9XjF/pTW//V6vlr+axOa3T2Lz2yex+e2T2Pz2ezVi9Wr5q0lsfvskNr99EpvfPonNb5/E5rdPYvPbJ7H57ZPY/PZJbH77JDa/fRKb3z6JzW+fxOa3T2Lz2yex+e2T2Pz2SWx++yQ2v30Sm98+ic1vn8Tmt09i89snsfntk9j89klsfvskNr99EpvfPonNb5/E5rdPYvPbJ7H57ZPY/PZJbH77JDa/fRKb3z6JzW+fxOa3T2Lz2yex+e2T2Pz2SWx++yQ2v30Sm98+ic1vn8Tmt09i89snsfntk9j89klsfvskNr99EpvfPonNb5/E5rdPYvPbJ7H57ZPY/PZJbH77JDa/fRKb3z6JzW+fxOa3T2Lz2yex+e2T2Pz2SWx++yQ2v30Sm98+ic1vn8Tmt09i89snsfntk9j89klsfvskNr99EpvfPonNb5/E5rdPYvPbJ7H57ZPY/PZJbH77JDa/fRKb3z5lmu99v+rb86rn9uG9v7mOZVnWf168LHX6uY5W/st3nm/z48XzbX9l1/72zrU933n+8M5rmf957VqWI/UTuRHU/1r9RN4M9b9Wv6C+sPqJfDvqf61+ohSD+l+rnyjTof7X6idKuKj/tfqJvk9B/S/VnzNtV0H9r9Wn16esPr2+rOrXB4y1rUfq0+tTVr+gvrD69PqU1afXl1X9/Uf97Uh9en3K6tPrU1afXp+w+pk2/aH+1+rT61NWn15fVvXXxzO967YfqU+vT1n9gvrC6tPrU1afXp+y+vT6lNWn16esPr0+YfUzbZ1G/a/Vp9enrD69PmX16fUpq19QX1h9en3K6tPrU1afXp+y+vT6lNWn1yes/kKvT1l9en3K6tPrU1afXp+y+gX1hdWn16esPr0+ZfXp9SmrT69PWX16fcLqF3p9yurT61NWn16fsvr0+pTVL6gvrD69PmX16fUpq0+vT1l9en3K6tPrE1Z/pdenrD5531X9+zs8RJpaWyzV79jNsRbUF1afvK+sPnlfWX3yvrL65H1l9cn7wupv5H1l9Xm2R1l9nu1RVp9en7L6BfWTqt+xjXGj16esPr0+ZfXp9SmrT68vq/odG9k2en3C6u/0+pTVp9enrD69PmX16fUpq19QP6n6Hc/07vT6lNWn16esPr0+ZfXp9SmrT69PWP1Kr09ZfXp9yurT61NWn16fsvoF9YXVp9enrD69PmX16fUpq0+vT1l9en3C6jd6fcrq0+tTVp9en7L69PqU1S+oL6w+vT5l9en1KatPr09ZfXp9yurT69NVf7nR61NWn16fsvr0+pTVp9enrH5BfWH16fUpq0+vT1l9en3K6tPrU1afXp+w+hO9PmX16fUpq0+vT1l98r69+rYbNJaJVB5fI7JzfI1IuPE1IoeG12gmLcbXiEwXXyOSV3yNeBYivkYFjcJrRJ8hvkb0GXw1+rxVbZnpM8TXiD5DfI3oM4TXaKHP4KvR540/y0KfIb5G9Bnia0SfIb5GBY3Ca0SfIb5G9Bl8Nep4LmihzxBfI/oM8TWizxBeo0KfIb5G9Bnia0SfIb5G9Bnia1TQKLxG9Bnia0SfIb5G9Bnia0SfIb5G9BnCa7TSZ4ivEX2G+BrRZ4ivEX2G+BoVNAqvEX2G+BrRZ4ivEX2G+BrRZ4ivEX2G8Bpt9Bnia0SfIb5G9Bnia0SfIb5GBY3Ca0SfIb5G9Bnia0SfIb5G9Bnia0SfIbxGO32G+BrRZ4ivEX2G+BrRZ4ivUUGj8BqRj3o0muqDxzLPm6VGHXMgd/JRfI3IR+E1quSj+BqRj+JrRD6KrxH5KL5GBY3Ca8T3sPE14nvY+BrRZ4ivEX0GX406ZrBX+gzhNWr0GeJrRJ8hvkb0GXw16pgd3egzxNeooFF4jegzxNeIPkN8jegzxNeIPoOvRh3PBTX6DNE1Kjf6DPE1os8QXyP6DPE1os8QX6OCRuE1os8QXyP6DPE1os8QXyP6DPE1os8QXqOJPkN8jegzxNeIPkN8jegzxNeooFF4jegzxNeIPkN8jegzxNeIPkN8jegzhNdops8QXyP6DPE1os8QXyP6DPE1KmgUXiP6DPE1os8QXyP6DPE1os8QXyP6DOE1WugzxNeIPkN8jegzxNeIPkN8jQoahdeIPkN8jegzxNeIfNSl0e2BcpleKrxkDmQp5KP4GpGP4mtEPoqvEfkovkYFjcJrRD6KrxH5KL5GfA8bXyO+h42vEX2G8Bqt9Bl8Nfo8g72s9Bnia0SfIb5G9Bnia1TQyFWjz7Ojy0qfIb5G9Bnia0SfIb5G9Bnia0SfIbxGG30GX406ngva6DPE14g+Q3yN6DPE16igUXiN6DPE14g+Q3yN6DPE14g+Q3yN6DOE12inzxBfI/oM8TWizxBfI/oM8TUqaBReI/oM8TWizxBfI/oM8TWizxBfI/oM4TWq9Bnia0SfIb5G9Bnia0SfIb5GBY3Ca0SfIb5G9Bnia0SfIb5G9Bnia0SfIbxGjT5DfI3oM8TXiD5DfI3oM8TXqKBReI3oM8TXiD5DfI3oM8TXiD5DdI3WG/moR6Pbsj40utWbpUaf50CuN/JRfI3IR/E1KmgUXiPyUXyNyEfxNSIfxdeIfBRfI76HDa/RxPew8TWizxBfI/oMvhp9nsG+TvQZ4mtU0Ci8RvQZ4mtEn8FXo8+zo9eJPkN8jegzxNeIPkN4jWb6DPE1os8QXyP6DL4adTwXNNNniK9RQaPwGtFniK8RfYb4GtFniK8RfYb4GtFnCK/RQp8hvkb0GeJrRJ8hvkb0GeJrVNAovEb0GeJrRJ8hvkb0GeJrRJ8hvkb0GcJrVOgzxNeIPkN8jegzxNeIPkN8jQoahdeIPkN8jegzxNeIPkN8jegzxNeIPkN4jVb6DPE1os8QXyP6DPE1os8QX6OCRuE1os8QXyP6DPE1os8QXyP6DPE1os8QXqONPkN8jXTzkfG0xq1A0oikbtawJqmbCKxJ6vp2a5K67tqapK4HNia56zpVa5K631tZk9T9dsmaJBnHimSBpM0s5Z2MY0WSjGNFkoxjRZKM00OyYzbpTsYxIlnJOFYkyThWJMk4ViTJOFYkCyRtvlusZBwrkmQcK5JkHCuSZBwrkmQcI5KNjGNFkoxjRZKMY0WSjGNFskDSiCQZx4okGceKJBnHiiQZx4okGceG5HYj41iRJONYkSTjWJEk41iRLJA0IknGsSJJxrEiScaxIknGsSJJxjEiOZFxrEiScaxIknGsSJJxrEgWSBqRJONYkSTjWJEk41iRJONYkSTjGJGcyThWJMk4ViTJOFYkY/vJfX7MnGt1vn0geX/148X7clRvbNdnX29sb2Zfb2wHZV9vbJ9jXu8S2418Ve93J3+r9XlTOTrNl9gOw5tObNfgTSd2t9ObToHOGzqJXOQJdBJ5zhPoJHKo52W542t+IZnI+zqTTOSqfUkWWb9uTlLW25uTlM0B5iRlM4M5yQJJI5KyWcScpGxuMSdJxrEiScaxIknGMSIZfE/5SCTJOFYkyThWJMk4ViQLJI1IknGsSJJxrEiScaxIknGsSJJxjEgG35E8EkkyjhVJMo4VSTKOFckCSSOSZBwrkmQcK5JkHCuSZBwrkmQcI5LB9+8GIdmxf3cLvn93JJLccYx+6Rp81+lIJLnjGJEMvut0JJJ01axI0lWzIomf7CC5Tds/r92W+YhkgaQRSbpqViTpqlmRJONYkSTjWJEk4xiRDL7rdCSSZBwrkmQcK5JkHCuSBZJGJMk4ViR1M84X13Gv+1HhtGwvPGp5ZambcuxZ6uYce5a6Scea5R585+lYLHXTjj1L3bxjz1I38XzFsq5Plq0csSywNGOpm3rsWZJ77FiSe+xYknvsWJJ7zFgG34MakGW5TUcsyT12LMk9dizJPT0sy7w9WS7rEcsCSzOW5B47luQeO5bkHjuW5B47luQeM5bBd6O6sHyhQ5J5R4ds8o4OaeMdnQKdN3RIBO/o4PHf0cm0L/fz9rU91b7cnnoz7cvtqDfTvtyuehN5zq56E7nIrnoT+cKueotYvYm8W1e9idxYV71i/irTTtauesX8Vab9pl31ivmrTLtCu+oV81eZ9m521SvmrzLtsOyqV8xfZdoH2VWvmL/KtFuxq14xf5VpT2FXvWL+KtPOv656xfxVpv15XfWK+atMu+i66hXzV5n2unXVK+avMu1I66pXzF9l2jfWVa+Yv8q0u6urXjF/lWkPVle9Yv5qF/NXu5i/2sX8VaYdaV31FrF6xfzVLuavMu2T66pXzF9l2s3WU2+mDWpd9Yr5q0zbyLrqFfNXmTZ7ddUr5q8ybcnqqlfMX2XaONVVr5i/yrS9qateMX+VaRNSV71i/irTVqGuesX8VaYNPV31ivmrTJtuuurV8lc108aYrnq1/FXNtHmlq14tf1VvRaxeLX9VM20C6apXy1/VTBs1uuoV81eZNlN01SvmrzJteOiqV8xfZdqU0FWvmL/KtHGgq14xf5Vpcn9XvWL+KtME/K56xfxVpin1XfWK+atMk+S76hXzV5mmvXfVK+avxOa3V7H57VVsfnsVm99exea3V7H57VVsfnsVm99exea3V7H57VVsfnvNNN/7y+1QtT2vY/7w2rXM/7x2LcsRSd39ftYkdXcBWpMskDQiqbtj0Jqk7j5Ca5K6G8etSeruG7cmqbtt3Jhkpkn4ziTJOFYkyTg9JOvjjde2HpEk41iRLJA0IknGsSJJxukhuf+Q3I5IknGsSJJxrEiScYxIZtpG4UySjGNFkozTQ3J9fLe4bkffLWbazeFMskDSiCQZx4okGceKJBnHiiQZx4okGceIZKaNMM4kyThWJMk4ViTJOFYkCySNSJJxrEiScaxIknGsSJJxrEiScYxIZtrK5EySjGNFkoxjRZKMY0WyQNKIJBnHiiQZx4okGceKJBnHiiQZx4hkps1oziTJOFYkyThWJMk4ViQLJI1IknGsSJJxrEiScaxIknGsSJJxbEi2TNsJnUnG9pPb7Ulya+0DyTv3x4v35ajeIlZvbG9mX29sB2Vfb2yfY19vbDfyVb3fnfwdUzJb8C16znSC79zzphO72+lNJ3YH05tOIhd5Ap0CnTd0EjnU87Lc8TW/kEzkfZ1JJnLVziRl/bo5SVlvb00y+G7IkUjKZgZzkrL5wpykbBYxJ1kgaUSSjGNFkoxjRZKMY0WSjGNFkoxjRDL4ftaRSJJxrEiScaxIknGsSBZIGpEk41iRJONYkSTjWJEk41iRJOMYkSxkHCuSZBwrkmQcK5JkHCuSuKCeX8t83ivZgu/fHYhk8F2nUUh2/IIr+K7TkUhyx7EiWSBpRJKumhVJumpWJPGTHSS3afvntdsyH5HET1qRpKtmRDL4rtORSJJxrEiScaxIknGsSBZIGpEk41iRJONYkSTjWJEk41iRJOMYkQy+6/RMkl9cxx3CD4/1ZY7d1l5Z6qYce5a6OceepW7SsWdZYGnGUjft2LPUzTv2LHUTz1cs9+X5znU+YqmbeexZ6qYec5bB95+OxZLcY8eS3GPHktxjx7LA8luW7YgluceOJbnHjiW5581vR4JvOPWmQzZ5Qyf4JlJvOuSHd3RIBO/o4PHf0SmJduJ0TNAPvn/Tvt5MO5566s2046mn3kSes6veRC7yc731Fnx7o329iZxeV72JvFtXvZl2aPbUW8TqlfJX93ql/NW9Xil/da9Xyl/d6xXzV5n2XHbVK+avMu2i7KpXzF9l2hfZVa+Yv8q0p7GrXjF/lWnnYVe9Yv4q0/7ArnrF/FWmXXxd9Yr5q0x77brqFfNXmXbEddUr5q8y7VvrqlfMX2XaXdZVr5i/yrQHrKteMX+VaadWV71i/irTfqquesX8VaZdT131ivmrTHuTuuoV81eZdhB11Svmr0oRq1fMXxUxf5VpP1VXvWL+qoj5q1XMX2Xa5dVVr5i/yrQXq6veIlavmL/KtAmqq14xf5Vpq1JXvWL+KtOGoq56xfxVpm0/XfWK+atMm3O66hXzV5m20HTVK+avMm106apXzF9l2o7SVa+Yv8q0ZaSrXvbL/f8dm5/L/M9r17IckWS/nBVJ9stZkWS/nBVJ9ssZkRTes2BNkh3aViTZoW1Fkh3aViQLJI1IknGsSJJxekjWxxuvbT0iScaxIknGsSJJxjEiKbzd4RuS+w/J7YgkGceKJBnHiiQZx4pkgaQRSTKOFUkyTg/J9fHd4rodfbeYaTeHM0kyjhVJMo4NySnTphJnkmQcK5JkHCuSZBwrkgWSRiTJOFYkyThWJMk4ViTJOFYkyThGJDNtC3ImScaxIknGsSJJxrEiWSBpRJKMY0WSjGNFkoxjRZKMY0WSjGNEMtPGLmeSZBwrkmQcK5JkHCuSBZJGJMk4ViTJOFYkyThWJMk4ViTJOEYkM23NcyZJxrEiScaxIknGsSJZIGlEMrafLHN5kFz3+oFk2x+TAdq+HNUb2/XZ1xvbm5nXG3wvnn29sX2Ofb2x3chX9X538ndMyZyCb9HzplOg84ZO7G6nN53YHUxvOolc5Al0EnnOE+gkcqjnZbnja/4hGXxn4UgkE7lqZ5Kyft2cpKy3NydZIGlEUjYzmJOUzRfmJGWziDlJ2dxiTpKMY0Qy+N7QkUiScaxIknGsSJJxrEgWSBqRJONYkSTjWJEk41iRJONYkSTjGJEMvrt3JJJkHCuSZBwrkmQcK5IFkkYkyThWJMk4ViTJOFYkyThWJMk4RiSDb9ceiSQZx4okGceKJBnHimSBpBFJMo4VSTKOFUkyjhVJMo4VSTKOEcng+3eDkFzL41ffazkkWSBpRJI7Tg/JjskpwXedjkSSO44NyTn4rtORSNJVsyJJV82KJH6yg+Q2bf+8dlvmI5IFkkYk6apZkaSrZkWSjGNFkoxjRZKMY0Qy+K7TkUiScaxIknGsSJJxrEgWSBqRJONYkSTjWJEk41iRJONYkSTjGJEMvut0JJK6GeeL65iWZ4VTeeE+7e233HUTkS933fzky73A3YW7bjYz4v7CUjed2bPUzWf2LHUTmj1L3YxmzjL4ttaxWJLT7FiSvexYkqfsWBZYmrEk9/SwLNvzndeXV/89b0539I9XT+XlquvtlTwpyYs8mcqcvPFvHudM+5XTakQGDK9Rpj3WaTUis8bXiCwcXyMydnyNChqF14ieQHyN6B7E14g+Q3yN6DPE14g+Q3iNVvoM8TWizxBfI/oM8TWizxBfo4JG4TWizxBfI/oM8TWizxBfI/oM8TWizxBeo40+Q3yN6DPE14g+Q3yN6DPE16igUXiN6DPE14g+Q3yN6DPE14g+Q3yN6DOE12inzxBfI/oM8TWizxBfI/oM8TUiH7lq1LETc97JR+E1qvg6X4069tNVfF18jfB18TXC18XXqKBReI34/ii+RuQjV416ZmxX8lF8jfj+KL5GfH8UXqNGnyG+RvQZ4mtEnyG+RvQZ4mtU0Ci8RvQZ4mtEnyG+RvQZ4mtEn8Feo2/e+fZ88XSr2887/zEpv9FpiK/ScqPXMIJKdBtGUIl+wwgq0XEYQaWCSgOoRNfBWaVan9fc9iOV6DuMoBKdhxFUovcwgkr0HgZQaaL3MIJK9B5GUIneg7NK7Wd77K0eqUTvYQSVCioNoBK9hxFUovcwgkr0HkZQid7DCCrRe4ij0nT0zcVM72EEleg9jKASvQdflablR6VydF+a6T2MoFJBpQFUovcwgkr0HkZQid7DCCrRexhBJXoPF6r0w32hm+DDnf5AD/e1rE/ua/3A/d7aLM+TZilH5Mn8XuTJ8ebk5/mJo6xH3AvcXbiTtX24k559uJOHfbiTcH24k1ntua+PF8/7dMC9kFl9uJNZfbiTWH24k1d9uBe4u3Anr/pwJ6/6cCev+nAnr/pwJ6+6cF/Jqz7cyatd3Pfn8xlrKx+4933Tt5JYvciTWb3IF8g7kSe3epEnuXqRJ7t6kSe9epEnvzqR30iwXuTJsF7kybBe5MmwXuQL5J3Ik2G9yJNhvciTYb3Ik2G9yJNhncjvZFgv8mRYL/JkWC/yZFgv8gXyTuTJsF7kybBe5MmwXuTJsF7kybBO5CsZ1os8GdaLPBnWizwZ1ot8gbwTeTKsF3kyrBd5MqwXeTKsF3kyrBP5Rob1Ik+G9SJPhvUiT4b1Il8g70SeDOtFngzrRZ4M60WeDOtFngzrQ77cyLBe5MmwXuTJsF7kybBe5AvknciTYb3Ik2G9yJNhvciTYb3Ik2GdyE9kWC/yZFgv8mRYL/JkWC/yBfJO5MmwXuTJsF7kybBe5MmwXuTJsE7kZzKsF3kyrBd5MqwXeTKsF/kCeSfyZFgv8mRYL/JkWC/yZFgv8mRYJ/ILGdaLPBnWizwZ1os8GdaLfIG8E3kyrBd5MqwXeTKsF3kyrBd5MqwT+UKG9SJPhvUiT4b1Ik+G9SJfIO9EngzrRZ4M60WeDOtFngzrRZ4M60R+JcN6kSfDepEnw3qRJ8N6kS+QdyJPhvUiT4b1Ik+G9SJPhvUiT4Z1Ir+RYb3Ik2G9yJNhvciTYb3IF8g7kSfDepEnw3qRJ8N6kSfDepEnwzqR38mwXuTJsF7kybBe5MmwXuQL5J3Ik2G9yJNhvciTYb3Ik2G9yJNhnchXMqwXeTKsF3kyrBd5MqwX+QJ5J/JkWC/yZFgv8mRYL/JkWC/yZFgn8o0M60WeDOtFngzrRZ4M60W+QN6JPBnWizwZ1os8GdaLPBnWizwZ1of8eiPDepEnw3qRJ8N6kSfDepEvkHciT4b1Ik+G/Y/reKFDznxHhyz4jg557Q2diUz1jg655x0dssk7OuSHd3QKdN7QwYe/o4NXfkcHr/yOTiKv3Gp9vLjtR/Umcr899c6J/GxXvYkcale9iTxnV72JXGRXvUWs3kROr6veRN6tq95EbqyrXjF/NYv5q0XMXy1i/moR81eLmL9aili9Yv5qEfNXi5i/WsT81SLmr4qYvypi/qqI+asi5q9KEatXzF8VMX9VxPxVEfNXmTbU99SbaS98V71i/irTDvSuesX8VaZ93131ivmrTLutu+oV81eZ9jh31SvmrzLtLO6qV8xfZdrP21WvmL/KtIu2q14xf5Vp72pXvWL+KtOO0a56xfxVpn2aXfWK+atMuyO76hXzV5n2JHbVK+avMu0E7KpXzF9l2n/XVa+Yv8q0662rXjF/lWmvWVe9Yv4q0w6vrnrF/FWmfVVd9Yr5q0y7mbrqFfNXmfYQddUr5q8y7dzpqlfMX2XaL9NVr5i/yrRLpateMX+VaW9IV71a/mrLtCOjq14tf7Vl2gfRVa+Wv9puRaxeLX+1ZZrz31Wvlr/aMs3i76pXzF9lmpffVa+Yv8o0076rXjF/lWnufFe9Yv4q02z4rnrF/JXY/PZNbH77Jja/fROb376JzW/fxOa3b2Lz2zex+e2b2Pz2TWx++yY2v30Tm9++ic1v38Tmt29i89s3sfntm9j89k1sfvsmNr99E5vfvonNb9/E5rdvYvPbN7H57ZvY/PZNbH77Jja/fROb376JzW/fxOa3b2Lz2zex+e2b2Pz2TWx++yY2v30Tm9++ic1v38Tmt29i89s3sfntm9j89k1sfvsmNr99E5vfvonNb9/E5rdvYvPbN7H57ZvY/PZNbH77Jja/fROb376JzW/fxOa3b2Lz2zex+e2b2Pz2TWx++yY2v30Tm9++ic1v38Tmt29i89s3sfntm9j89k1sfvsmNr99E5vfvonNb9/E5rdvYvPbN7H57ZvY/PZNbH77Jja/fROb376JzW/fxOa3b5nme9+v+va86rl9eO9vrmMq2/Od15dXT3v72zvX9nzn+cM7r2X+57VrWY40SuQZkmq0Z5qjnlajRN4srUaJ/GRajRJ54LQaFTQKr1GirJFWo0T957QaJeqZp9WIPkN8jegz+GpUH2+8tvVAo0z7RNJqRJ8hvkb0GeJrRJ/BV6P9R6PtSKOCRuE1os8QXyP6DPE1os8QXyP6DPE1os/gq9H6eC5o3Q6eC9oz7dVKqxF9hvga0WeIrxF9hvgaFTQKrxF9hvga0WeIrxF9hvga0WeIrxF9hvAaZdovmVYj+gzxNaLPEF8j+gzxNSpoFF4j+gzxNaLPEF8j+gzxNaLPEF8j+gzhNcq0ZzmtRvQZ4mtEnyG+RvQZ4mtU0Ci8RvQZ4mtEnyG+RvQZ4mtEnyG+RvQZwmu00meIrxF9hvga0WeIrxF9hvgaFTQKrxF9hvga0WeIrxF9hvAabbr5yHha46abYqxJ6mYNa5K6icCaZIGkEUldd21NUtcDW5PUdarWJHW/t7ImqfvtkjHJnYxjRZKM00OyY5byTsaxIknGsSJZIGlEkozTQ7JjNulOxrEiScaxIknGsSJJxjEiWck4ViTJOEbfLVYyjhVJMo4VyQJJI5JkHCuSZBwrkmQcK5JkHCuSZBwjko2MY0WSjGNFkoxjRZKMY0WyQNKIJBnHiiQZx4okGceKJBnHiiQZx4ZkvZFxrEiScaxIknGsSJJxrEgWSBqRJONYkSTjWJEk41iRJONYkSTjGJGcyDhWJMk4ViTJOFYkyThWJAskjUiScaxIknGsSJJxrEiScaxIknGMSM6x/eT8LKEt++0DybY/JgO0fTmqN7brs6+3iNUb20HZ1xvb59jXG9uNfFXvdyd/q8+3boeneWyH4U0ntmtwprPE7nZ604ndwfSmk8hFnkAnkec8gU5RpfNNlju+5heSibyvM8lErtqZpKxfNycp6+3NScrmAGuSRTYzmJOUzRfmJGWziDlJ2dxiTrJA0ogkGceKJBnHiiQZx4okGceKJBnHiGTwzdwjkSTjWJEk41iRJONYkSyQNCJJxrEiScaxIknGsSJJxrEiScYxIhl8u/ZIJMk4ViTJOFYkcUE9v5b5vFeyBt+/OxDJ4LtOo5Ds+AVX8F2nI5HkjmNFkq6aFckCSSOSdNWsSOInO0hu0/bPa7dlPiKJn7QiSVfNiiRdNSOSwXedjkSSjGNFkoxjRZKMY0WyQNKIJBnHiiQZx4okGceKJBnHiqRuxvniOv71ds93Xl7n2G0vLINvOx2LpW7OsWepm3TsWepmHXuWBZZmLHXzjj1L3cTzFcvth8cf1/EHS93MY89SN/XYsyT3WLFswTegjsWS3GPHktxjx5Lc8zXL/YhlgaUZS3KPHUtyz/FvR1rwDafedMgm7+iQNt7QCb5d1JsOieAdHTz+OzqZdjx9nqDfgu/ftK83046nnnoz7XjqqTeR5+yqN5GL7Ko3kS/sqXdO5PS66k3k3brqzbRDs6deMX+VaodmT71i/irVDs2eesX8VaatmF31ivmrTJsru+oV81eZtkt21SvmrzJtgOyqV8xfZdqm2FWvmL/KtJmwq14xf5Vpy19XvWL+KtPGvK56xfxVpu1zXfWK+atMm9y66hXzV5m2onXVK+avMm0Y66pXzF9l2tbVVa+Yv8q0+aqrXjF/lWmLVFe9Yv4q00amrnrF/FWm7UZd9Yr5q0ybgrrqFfNXWxGrV8xfZdpP1VWvmL/axPzVJuavMu3y6qpXzF9l2ovVVa+Yv8q0Y6qrXjF/lWlfU1e9Yv4q0+6jrnrF/FWmPUJd9Yr5q0w7ebrqFfNXmfbbdNUr5q8y7YrpqlfMX2Xau9JVr5i/yrTBpKteMX8lvHHhm83PZf7ntWtZjkiyX86KJPvlrEiyX86KJPvlrEiyQ9uEZLsJb1mwJskObSuS7NC2IskObSuSBZJGJMk4PSTr443Xth6RJONYkSTjWJEk41iRJOP0kNx/SG4HJIU3QViTJONYkSTjWJEk41iRLJA0IknG6SH5vIx1249IknGsSJJxrEiScaxIknGMSGbageJMkoxjRZKMY0WSjGNFskDSiCQZx4okGceKJBnHiiQZx4okGceIZKY9RM4kyThWJMk4ViTJOFYkCySNSJJxrEiScaxIknGsSJJxrEiScYxIZtoF5kySjGNFkoxjRZKMY0WyQNKIJBnHiiQZx4okGceKJBnHiiQZx4hkpn18ziTJOFYkyThWJMk4ViRj+8np9nhxu3/KB5Jtf0wGaPtyVG9s12dfb2xvZl9vbAdlXm/wvXj29cZ2I1/V+93J/3lK5p1ObIfhTSe2a/CmU6Dzhk7sDqY3nUQu8gQ6iTznCXQSOdTzstzxNb+QTOR9fUkG34Y4EklZv25OUtbbm5OUzQHmJAskjUjK5gtzkrJZxJykbG4xJ0nGsSJJxjEiGXwj6UgkyThWJMk4ViTJOFYkCySNSJJxrEiScaxIknGsSJJxrEiScYxIBt8KPBJJMo4VSTKOFUkyjhXJAkkjkmQcK5JkHBuSU/D9u0FIduyVnILv3x2JJHccm19wTcF3nY5EkjuOFUm6alYk6apZkaSrZkQy+K7TICS3afvntdsyH5HET1qRpKtmRZKumhXJAkkjkmQcK5JkHCuSZBwrkmQcK5JkHCOSwXedjkSSjGNFkoxjRVI343xxHf96u+c7L/XlOrZXlgWWZix1c449S92kY89SN+vYs9RNO/YsdfOOOcvgm0/DsNx+ePwx2/cPlrqZx56lbuqxZ0nusWNZYGnGktxjx5LcY8eS3PM1y/2IJbnHjiW5x4xl8G2oLixf6JBk3tEhm7yjQ9p4R6dA5w0dEsE7Onj8d3Qy7Xj6PEF/Cr5/077eTDueOuoNvsvSvt5EnrOr3kQusqveRL6wq94iVm8i79ZVb6Ydmj31ivmrVDs0e+oV81epdmj21CvmrzJtxeyqV8xfZdpc2VWvmL/KtF2yq14xf5VpA2RXvWL+KtM2xa56xfxVps2EXfWK+atMW/666hXzV5k25nXVK+avMm2f66pXzF9l2uTWVa+Yv8q0Fa2rXjF/lWnDWFe9Yv4q07aurnrF/FWmzVdd9Yr5q0xbpLrqFfNXmTYyddUr5q8ybTfqqlfMX2XaFNRVr5i/amL+qmn5qznTfqquerX81XzT8lfzTctfzbciVq+Wv5oz7cXqqlfLX82Zdkx11SvmrzLta+qqV8xfZdp91FWvmL/KtEeoq14xf5VpJ09XvWL+KtN+m656xfxVpl0xXfWK+atMe1e66hXzV5k2mHTVK+avhDcufLP5ucz/vHYtyxFJ9ssZkRTetmBNkv1yViTZL2dFkh3aViQLJI1IskPbiiQ7tK1IskPbiiQZx4okGaeHZH288drWA5LCmxWsSZJxrEiScaxIknF6SO4/JLcjkgWSRiTJOFYkyThWJMk4ViTJOFYkyTg9JNfHd4vrdvTdYqbdHM4kyThWJMk4ViTJOFYkCySNSJJxrEiScaxIknGsSJJxrEiScYxIZtqP40ySjGNFkoxjRZKMY0WyQNKIJBnHiiQZx4okGceKJBnHiiQZx4hkph1VziTJOFYkyThWJMk4ViQLJI1IknGsSJJxrEiScaxIknGsSJJxjEhm2hPnTJKMY0WSjGNFkoxjRbJA0ogkGceKJBnHiiQZx4hk8L14t/lxHe221Q8kracIBN+h58smtufzZRPbxfmyKbA5ZBPbafmyie2dfNnEdkO+bGL3cH3ZxO7KerJZgu8z9GWj6os/T9RZgu9J9GWj6ot72BTYHLJR9cWfp4Aswfc6+rJR9cU9bFR9cQ8bVV/cwSb4HkpfNqq++PP3DEvw/Za+bFR9cQ+bAptDNqq+uIeNqi/uYaPqi3vYqPriHjaqvriDTfD9ob5s8MXHbPDFx2zwxcdsCmwO2eCLj9ngi4/Z4IuP2eCLj9ngiw/ZBN+R68sGX3zMBl98zAZffMymwOaQDb74mA2++JgNvviYDb74mA2++JBN8L2qvmzwxcds8MXHbPDFx2wKbA7Z4IuP2eCLj9ngi4/Z4IuP2eCLD9nE3ntY9/XxGHDdW7Fk0/G7u9ibDJ3ZFNgcsgntb5zZhPY3zmxC+xtnNqH9jTOb0P7Gl03sPXzObEL3/ZzZ4IuP2aj64o7fzsfeZ+fMRtUX97BR9cU9bFR9ccdvoGPvhXNmo+qLO9jE3t3mzEbVF/ewUfXFPWxUfXHH9wyxd6A5s1H1xT1sVH1xDxtVX9zDRtUX97BR9cUdbGLv+3Jmo+qLe9io+uIeNvjiYzYFNods8MXHbPDFx2zwxcds8MXHbPDFh2xi7y1zZoMvPmaDLz5mgy8+ZlNgc8gGX3zMBl98zAZffMwGX3zMBl98xKbE3lvmzAZffMwGX3zMBl98zKbA5pANvviYDb74mA2++JgNvviYDb74kE3svWXObPDFx2zK5Wxsfx1XHLZEWVewDV/BPnwFdfgK2ugVOOwYsq5gGr6CefgKluErGP6ePMe+J3/+DWyZY9+TeyqIfU/uqSD2Pbmngtj35M+/sStL7HtyTwWx78k9FcS+J/dUEPue3FNB7HtyTwWx78kdvYol9j25p4LY9+SeCmLfk3sqiH1P7qigxL4n91QQ+57cU0Hse3JPBbHvyT0VxL4n91Qw/D25DH9PLsPfk8vw9+Qy/D15Hf6evA5/T16Hvyevw9+THebUW1cw/D15Hf6evA5/T16Hvyevw9+Tt+Hvydvw9+Rt+HvyNvw92WFGtnUFw9+Tt+Hvydvw9+Rt+HvyNvw9eR/+nrwPf0/eh78n78Pfk23mrE6Pi5qnrVhW0PGMl800VNcK6vAVtNErsJn/6VrBNHwF8/AVLMNXUIavYB2+guHvyTX2Pbnjidka+57cU0Hse3JHBS32Pbmngtj35I6nNVvse3JPBbHvyT0VxL4n91QQ+57cU0Hse3JPBbHvyR29ihb7ntxTQex78ucK1lvse3JPBbHvyT0VxL4n91QQ+57cU0Hse3JPBbHvyT0VxL4n91Qw+j15vY1+T15vw9+Tp+HvydPw9+Rp+HvyNPw92WaGlGsFw9+Tp+HvydPw9+Rp+HvyNPw9eR7+njwPf0+eh78nz8Pfk21mSLlWMPw9eR7+njwPf0+eh78nz8Pfk5fh78nL8PfkZfh78jL8PdlmhpRrBcPfk03mF93K+qjg1m6WFXx+xms1mV/kWoHJ/CLfCqbhK5iHr2AZvoIyfAXr8BVsw1ewD1/B8PfkEvue/PmJ2XWNfU/uqSD2Pbmngtj35J4KYt+TPz+tuZrML/KtIPY9uaeC2Pfkngpi35N7Koh9T+6pIPY9uaNXscW+J/dUEPue3FNB7HtyTwWx78k9FcS+J/dUEPue3FNB7HtyTwWx78k9FcS+J/dUMPw9eR/+nrwPf0/eh78n78Pfk/fh78n78Pfkffh78j78PXkf/p68D39PrsPfk+vw9+Q6/D25Dn9PNpkh5VvB8PfkOvw9uQ5/T67D35Pr8PfkNvw9uQ1/T27D35Pb8PdkkxlSvhUMf09uw9+T28D35LbP//P3zb17fVz+/vot7rL9/Lv9l/+u/vLftd/9u78/0dzx76Zf/rv5l/9u+eW/K7/8d+sv/90v/17KL/9eyi//Xsov/17WX/69rL/8e1l/+fey/vLvZf3l38v6y7+X9Zd/L+sv/17WX/69rL/8e9l++ffy9+cv9rU9/93+9383/+Lftfl//j6NZd/K7edCf650mm5/u/O8vnqvf7z6+TnLRZ9TLvqc9aLP2S76nP2iz6kXfU675nP+Pr3ihM+ZLvqci86D+aLzYL7oPJgvOg/mi86D+aLzYL7oPJgvOg+Wi86D5aLzYLnoPFguOg+Wi86D5aLzYLnoPFguOg+Wi86D5aLzoFx0HpSLzoNy0XlQLjoPykXnQbnoPCgXnQflovOgXHQelIvOg/Wi82C96DxYLzoP1ovOg/Wi82C96DxYLzoP1ovOg/Wi82C96DzYDM6DZdkebcVlX15evfzte6K1Pn8dX3+uad7Xn2uaAl7THPCaloDXVAJe0xrwmraA17QHvKYa8JpavGvaA57je8BzfA94ju8Bz/E94Dm+BzzH94Dn+B7wHN8DnuN7wHO8BjzHa8BzvAY8x+vl5/g8zcs/r57Xafrj1c+rKiGvag15VVvIq9pDXlUNeVUt4lW1W8irmkJe1RzyqkKe7S3k2d5Cnu0t5NneQp7tLeTZ3kKe7dMt5OE+3UKe7tMt5PE+3UKe79Mt5AE/3UKe8NMt5BE/3UKe8dMt5CE/3WKe8lPMU36KecpPMU/5KeYpP8U85aeYp/wU85SfYp7yU8xTfop5ys8xT/k55ik/xzzl55in/BzzlJ9jnvJzzFN+jnnKzyef8j8f1C76IIsfMi37c87Esr8Mmvjzg6arPmi+6oOWqz6oXPVB61UftBl/0F4OPmi/6oPqVR9kcTLU+flBdTnQyOInTX0fNF31QfNVH7Rc9UHlqg+y+O+ortvzg+py8EH1og+y+OVM2ebyz6vLVurBB81XfdBy1QeVqz5oveqDOu5H7Y8P+vmn++//af39P22//qc9P0U5+qfT7//p/Pt/uvz+n5bf/9P19//0939N2+//mrbf/zVtv/9r2n//17T//q9p//1f0/77v6b9939N++//mvbf/zXtv/9r2n//17T//q+p/v6vqf7+r6n+/q+p/v6vqf7+r6n+/q+p/v6vqf7+r6n+/q+p/v6vqf3+r6n9/q+p/f6vqf3+r6n9/q+p/f6vqf3+r6n9/q+p/f6vqf36r2m+3X7/T6ff/9P59/90+f0/Lb//p+vv/+n2+3+6//6f1t//09//NU2//2uafv/X1PG8wP/zA/b/7y+vfvxAY99/1k2/pKm54+t/i08pl3zKesWnmDTHa9sfXY/2r1f8JejOFq3kcveVj0T97xnVf/2g9aoP2q76oP2qD6pXfVC76IMsWsl9HzRd9UHzVR9k0dS7d+w+f1C56oPWqz5ou+qD9qs+yOJkuN8Dnh+0Lgcf1C76IIs5WX0fNF31QfNVH7Rc9UEWJ8PcHl8ylWU6+qD1qg/arvqg/aoPqld9kMnJ0KafD/r799zzdrvqg6arPmi+6oOWqz6oXPVBq/EHzdPBB21XfdB+1QdZnAylPr5QL+vt6IPaRR9kMYOp74Omqz7I4mQo6/rzQfMfH/Sfr17r42HHtb78NzftLxe1RLyoEvGi1ogXtUW8qD3iRdWIF9UCXlS9RbyoKeJFRTzRa8QTvUY80WvEE71GPNFrxBO9RjzRa8QTvUU80VvEE71FPNFbxBO9RTzRW8QTvUU80VvAE325XX8kPHdqrvtPbH+dQ7nc5ogX5fCH/mli53LbIl7UHvGiasSLagEvajrZuvx80HTVB1mcJ+vy7Amv+/IB87Q8mpP3r5+fr13q/HJRS8SLKhEvao14UVvEi9ojXlSNeFHt8ovaHl8CT3X7+0VZTG+xv6gp4kXNES9qiXhRJeJFrREv6vITfb49Usc87wcXtUe8qBrxolrAi1puES9qinhRc8SLOvlE//mgctUHrVd90HbVB+1XfVC96oPaRR9Ubld90HTVB81XfdBVJ0O56mQoV50M5aqToVx1MpSrToZy1cmwXnUyrFedDOtVJ8N61clg8vOBtT5/KrX9P79t/MurO0b+LCY/NjjhsraYl7XHvKwa87JayMsy+UnFCZc1nXtZPx80X/VBy1UfVK76oPWqD7I4/7r+6varPqhe9UHtog8y+QFG1wdNV33QfNUHLVd9ULnqg9arPuiqk2G/6mTYrzoZ9qtOhnrVyVCvOhnqVSdDvepkqFedDPWqk6FedTLUq06GetXJUK86GdpVJ0O76mRoV50M7aqToV11MrSrToZ21cnQrjoZ2lUnQ7voZCi321UfNF31QfNVH7Rc9UHlqg9ar/qg7aoP2q/6oHrVB111MkxXnQzTVSfDdNXJMF11MkxXnQzTVSfDdNXJMF11MkxXnQzTVSfDfNXJMF91MsxXnQzzVSfDfNXJMF91MsxXnQzzVSfDfNXJMF91MixXnQzLVSfDctXJsFx1MixXnQzLVSfDctXJsFx1MixXnQzLVSdDuepkKFedDOWqk6FcdTKUq06GctXJUK46GcpVJ0O56mQoV50M61Unw1U7J8tVOyfLVTsny1U7J8tVOyfLetXJsF51MqxXnQzrVSfDdtXJsF11MmxXnQzbVSfDdtXJsF11Mlz1DGS56hnIctUzkOWqZyDLVc9AlquegSxXPQNZrnoGslz1DGS56hnIctUzkOWqZyDLVc9AlquegSxXPQNZrnoGslz1DGS56hnIctUzkOWqZyDLVc9AlquegSxXPQNZrnoGslz1DGS56hnIctUzkOWqZyDLVc9AlquegSxXPQNZrnoGslz1DGS56hnI9apnINernoFcr3oGcr3qGcj1Vq76oPWqD9qu+qD9qg+qV33QVSfDVc9Arlc9A7le9QzketUzkOtVz0CuVz0DuV71DOR61TOQ61XPQK5XPQO5XvUM5HrVM5DrVc9Arlc9A7le9QzketUzkOtVz0CuVz0DuV71DOR61TOQ61XPQK5XPQO5XvUM5HrVM5DrVc9Arlc9A7le9QzketUzkOtVz0CuVz0DuV71DOR61TOQ61XPQK5XPQO5XvUM5HrVM5DrVc9Arlc9A7le9QzketUzkOtVz0CuVz0DuV71DOR61TOQ61XPQK5XPQO5XvUM5HrVM5DrVc9Arlc9A7le9QzketUzkOtVz0CuVz0DuV71DOR61TOQ61XPQK5XPQO5XvUM5HrVM5DrVc9Arlc9A7le9QzketUzkOtVz0CuVz0DuV71DOR61TOQ61XPQK5XPQO5XvUM5HrVM5DrVc9Arlc9A7le9QzketUzkOtVz0CuVz0DuV71DOR61TOQ61XPQK5XPQO5XvUM5HrVM5DrVc9Arlc9A7le9QzketUzkOtVz0CuVz0DuV31DOR21TOQ21XPQG5XPQO53cpVH7Re9UHbVR+0X/VB9aoPuupkuOoZyO2qZyC3q56B3K56BnK76hnI7apnILernoHcrnoGcrvqGcjtqmcgt6uegdyuegZyu+oZyO2qZyC3q56B3K56BnK76hnI7apnILernoHcrnoGcrvqGcjtqmcgt6uegdyuegZyu+oZyO2qZyC3q56B3K56BnK76hnI7apnILernoHcrno0cbvq0cTtqkcTt6seTdyuejRxM3mQr6zr44PW2/zHB/3nq9e1/fPi+/fnz9fO+/pzUSYP/Zlf1BTxouaIF7VEvKhy+UW1x4vvbcODi1ojXtQW8aL2iBdVr7+o6XlR28FFtYAXtd0iXtQU8aLmiBe1RLyo60/0Oj9uM7UeXNQa8aK2iBe1R7yoGvGiWsCL2m8RL2qKeFFzxItaIl5UxBN9j3ii7xFP9D3iib5HPNH3iCd6jXii14gneo14oteIJ3qNeKLXiCd6jXii14gneo14oteIJ3qLeKK3iCd6i3iit4gneot4oreIJ3qLeKK3iCd6i3iit4An+n4LeKLvt4An+n6LdaLPt1v5n78/f1qeX16W9nNF6/L8Z39/mvTzP5t+98/m3/2z5et/dv9P7H/+/oTftE8P8FO77T/gy+3nX7bf/su/P4PX9S+nX//L+Tf/si7LXca/Htn1tvzzL1srL3+Z68s/rL/9h+2X//Dvf6k9/3D67T+cf/sPl9/+w/JXJW+3xxdW063Mf/zT/zwqprYtT93ry/dbt78dLNu0/fPibfl553lbXi5qjXhRW8SL2iNeVD33on4+qF30QQdn7AkfNF31QfNVH7Rc9UHlqg9ar/qg7aoP2q/6IIOTYb6Vh8uYb+324biapuerp2n/8SRze/EkSwt5WeV29WXt9WFw6/Tn4f6X1+7787XL328EZRq9gHn0ApbRCyijF7COXsA2egH76AXU0Qtogxewjn4nXke/E6+j34nX0e/E6+h34nX0O/E6+p14Hf1OvI5+J15HvxNvo9+Jt9HvxNvod+Jt9DvxNvqdeAt9H1jL85vvclRA6PtARwF76FNoXeujgG0/KCD0KdRTQOhTqKeA0KdQTwGh80BPAaHzQE8Boe8DHd9076HvAz0FhM4DHQXU0Hmgp4DQd+KeAkLfiXsKCH0n7ikg9J24p4DQd+KeAkLfiXsKGP1OXEe/E9fR78Tt+jvxYafhP187TdvjxdO0vzye9PrATZvGL2Eev4Rl/BLK+CWs45ewjV/CHqeEn4uqES/K4v45TY9b4jxt5cNFTdP8I+DLRNJ5/hFwud1iXtZ09WXZfoWw3ObRC1hGL6CMXsA6egHb6AXsoxdQRy+gDV7AdBu9gNHvxNPod+Jp9DvxNPqdeBr9TjyNfieeRr8TT6PfiafR78Tz6HfiefQ78Tz6nXge/U5sMU3Dt4DR78Tz6HfiefQ78Tz6nXge/U68hL4PfH46eVlC3wd6Cgh9Cn1+MnNZQp9CPQWEPoV6Cgh9CnUUUELngZ4CQueBngJC3wc+P1K0lND3gZ4CyugFhM4DPQWEvhP3FBD6TtxTQOg7cU8Boe/EHQWsoe/EPQWEvhP3FDD6nXgd/U5sMr3EtYDr78TfPMx4qz8Pnd1eHud7fehs3cYvYR+/hDp+CW34Erbb+CVM45cwxy7hmfHvJUx/lPC3dy7/vHh/Gb87tZd7yLZolVu0yo3tEP54LP3ov8fYDqGrhNgOoauE2A6hq4TYDqGnhD22Q+gqIbZD6CohtkPo+a3PHvuu31VC7Dt5VwmB7s4/FxXofvtzUSZ30PbYRjHP6/zhoqb1ubpiLQcXVSNeVLv6ooyfVDGZ3uNawDR6AfPoBSyjF1BGL2AdvYBt9AL20Quooxcw+p24jX4nbqPfidvod+I2+p3YZGqPawGj34nb6HfiNvqduI1+J26D34nLbfA7cbkNficut8HvxOU2+J243Aa/E5fb4Hfichv8Tlxug9+Jy23wO3G5jX4nnkLfBz7/DLFMoe8DPQWEPoU+/wSrTKFPoZ4CQp9CPQWEPoU6CphD54GeAkLngZ4CQt8HPv92oMyh7wM9BZTRCwidB3oKCH0n7ikg9J24p4DQd+KeAkLfiTsKWELfiXsKCH0n7ilg9DvxMvqdeBn9TryMfideRr8TL6PfiZfR78TL6Hficv2d+Ivnweu2P66jbu3n2d1pn3/XiCyTVrmzVrmLVrll1HJ/SljHL2Ebv4R9/BLq+CW04UtYh3UTPyUM6xB+Shj2rv9TwrB38p8SYt+d9/X2ePHeYUY+zUwoa+w7uXm5se/635Vr+7DHGttNuKKJ7VJc0cR2P55ottiuyhVNbLfmiia2C3RFE9tduqIpoDlCk8nhGqPBDR+iwQ0fosENH6LBDR+h2XHDh2hww4docMOHaHDDh2gKaI7Q4IYP0eCGD9Hghg/R4IYP0eCGj9BU3PAhGtzwIRrc8CEa3PAhmgKaIzS44UM0uOFDNLjhQzS44UM0uOEjNA03fIgGN3yIBjd8iAY3fIimgOYIDW74EA1u+BCNqK/5PL1tvYn6mh40oneoz9O21pvoHaoHjegdqgeN6B2qB41ov6YHjWi/pgeNqK/5PH1knUR9TQ8a0X5NDxrRfk0PGlE33IOmgOYIjagb7kEj6oZ70Ii64R40om64Bw1u+AjNjBs+RJPJDX/xzlNZHy+eSr39vHrafgkyk3d2BZnJabuCLIC0AZlqApMNyB84mXy8OZxMTt4cTiYvbw4nk5u3hrNk8vPmcHD0b+Dg0t/AUXXe6/q45mndtj/g/OXVdwqPV09L+btldNhBkhalqvv+CuU8Pwss6wFIVaduDlLV1ZuDVE0A5iBV04I1yOBbewYCqZpCzEGqJpbvQK7ro8B9OgBJujECWURB3r8geFS4vf7n+vtsE3xL01AoVdPNVyh7bjiq6cYcpGq6MQepmm6sQQbfIjYQSNV0Yw5SNd2Yg1RNN9+B/Jxucm2X8wSpmm322+OXi/c3myyyTaqdeM4oVdPNVyh7bjiq6cYcpGq6sQaZapufK0jVdGMOUjXdmINUTTfmIAsgO0B+Tjepdha6gpT93mZvPyDnDyA/L05fU+1DdAUp+72NNUjZZLM+GxH76/Cq37ctUu1mdEYpm26+QdnhJVNtfnQFKZturEEWQNqAlE031iBlv7mxBin7vY01SNnvbb4C+blxkWp3pifIVJs2fwty//OJix84pJU3cEggb+Copop6exw5U53q/xq0DFLt53RGqZosvkLZ4eNSbf90BamaLMxBqiYLc5CqycIaZKqtpa4gVVOIOUjVxPIdyM9Ng1T7U11BFkDagCTZGIEk2RiBJNkYgSTZGIEk2ZiA3FLtLf4tyPnPYUY/cEgrb+CQQN7AkUgVP+UWrXJjO/Q6PTc71ZdVJL8vN7aPNi83ttv9qtzPnaQt+F5o83JjO0frcoPvbzYvN7ZjMy83tgczLze2q/qu3M/ZLPg+ZPNyE7mqnnITuaqecjO5qo5yM7mqjnKDu6rtGQDrvvz3ESH4HmDzcoO7qm/K7bAZwTfwmpcb3FVZl1u0yg3uqqzLDe6qrMsN7qq+KvezzQi+6dW83ESuqqPc4NtYzcvN5Ko6ys3kqjrKje2q2vPeUtuy/fcRIfieUvNyY7uqr8rtsBnBN36alxvbVZmXG9tVmZcb21VZlxt8E6V5ubFd1XflfrYZwbc6mpebyFX1lFu0ys3kqjrKzeSqOsodx1WVPwPgTwnjOKXDEsZxP0clBN8+1/bpWUI1eNo0+I4483KDO5pvyu3wq8H3rZmXW7TKDe5orMsN7misyw3uaKzLDe5+vir3s18Nvk/LutzgW6/My03kqnrKzeSqOsrN5Ko6yi1a5Q7kqtrfM2zwbUVdJYR2P+02P66j3bb64Y+uzo+dxfXlmudpfyk3tPuxLze0+/mu3L0+n3af5g/v3NGhiL1DxxdNaFfliya0A/NFE9qt+aIpoDlCE9oF+qIJ7S590SRyrdZoEjlcazS44SM0sbeu+KLBDR+iwQ0fosENH6IpoDlCgxs+RIMbPkSDGz5Egxs+RIMbPkITe1OILxrc8CEa3PAhGtzwIZoCmiM0uOFDNLjhQzS44QM0e+w9AeehWcvjSYm1HKER9TU9aETvUOtaH2heF5v/gUb0DtWDRvQO1YNG9A7Vg0a0X9ODRrRf04Em9nz889Bs0/bPa7dlPkAj6mt60Ij2a3rQiPZretAU0ByhEXXDPWhE3XAPGlE33ING1A33oBF1wx1oYu818EWDGz5Egxs+RJPJDX/xzvv++BHvXn/e9/UHhnvsPQy+aDK5YWM0mdywMZpMbtgYTSY3bIwmkxu2RRN7H8UlaNp2gCaTGzZGk8kNG6MRdcMv4zaW9QBNAc0RGlE33ING1A33oBF1wz1oRN1wDxpRN9yBJvYekUvQHMzK2mPvHPFFI+qGe9BIuOGfcotWubFd63R7vLjdP+VDudNt+7nqfX959fZScGwvekLBsR3mCQXH9o0nFBzbDdoXHHuzyhkFx3ZuJxQc24+dUHBsl3VCwUWtYDWnFXvLyhkFqzmt2JtWzihYzWnF3rZyRsFqTiv2xpUzClZzWrG3rpxRsJrTir2l5YyC1ZxW8K0uJxSs5rSCb2s5oWA1pxV8s8oJBas5reBbUE4oWM1pBd9YckLBak4r+HaREwpWc1rBN4GcULCa0wq+teOEghPdh9v+eCSt7QcPLQXflGBebqITutXHrLPWDmadBZ9Nb15uotO5p9xEZ3NPuYkycE+5RavcTPfdjnIz3Xc7yk2UfXvKTZR8e8qVclU1+GR883KHdVU/JQzrlH5KiO1+5ufg5bbsN4MgXm9FreDYDuiEgmN7oBMKju2CTig4tg86oeDYTsi+4ODT9E8oOLYbOqHg2N7phILVnFbwKfUnFKzmtIJPlD+hYDWnFXz6+wkFqzmt4JPaTyhYzWkFn6p+QsFqTiv4BPQTClZzWsGnlZ9QsJrTCj5Z/ISC1ZxW8CngJxSs5rSCT+w+oWA1pxV8uvYJBas5reCTsE8oWM1pBZ9afULBak4r+ITpEwpWc1rBZwB/VfDn35fU4DOAzctNdEJ3PAkZfDqsdbnBZ8Oal5vobO4pN1EG7ik3UQLuKTfTfbej3Ez33Y5yE2XfnnITJd+ecrVcVfBJsNblBp8D+6bcnxKGdUo/JcR2P2UujxLW/dNumml9XMa0loM/utjux7zcolVubPdjXm5s92Nebmz3Y15ubPdjXm5s92NdbvDZrOblxnZK5uVquargU1nNyy1a5Wq5quDzWM3L1XJVwWexmper5aqCz2E1L1fLVQWfwWperparqkWrXC1XFXy+rnm5Wq6qarmq4NOTrcsNPj3ZvFwtVxV8erJ5uVquKvj0ZPNytVxV8OnJ5uVquarg05PNy5VyVS349GTzcqVcVQs+adm8XClX1W5Fq1wpV9WCz2M2L1fKVbXgs5jNy9VyVcHnMJuXq+Wqgs9gNi830Y3o86+oW/BhtdblBh9k+l25H3/v04KPMTUvN9FR1VNuogDYU27RKjdRAOwpN9N9t6PcTPfdjnITBcCechMFwI5ygw8tNS9Xy1UFH1j6ptyfEoZ1Sj8llNAlbLf1UcLWPi3+nG77M4ff6surt/ZScGz/c0LBsR3QCQXH9kAnFBzbBZ1QcGwfZF9w8KGiJxQc2wudUHBsN3RCwbG90wkFF7WC1ZxWUXNaRc1pBR8OfELBak4r+IDgEwpWc1rBhwSfULCa0wo+KPiEgtWcVvBhwScUrOa0gg8MPqFgNacVfGjwCQWrOa3gA4lPKFjNaQUfSnxCwWpOK/hg4hMKVnNawYcTn1CwmtMKPqD4hILVnFbwIcUnFJzoPtzx+5Lgg2zNy010Qnc8CRl81Kl5uYlO555yE53NPeUmysA95RatcjPddzvKzXTf7Sg3UfbtKTdR8u0pV8tVBR91al7usK7qp4RhndJPCbHdzz4/S6jzp8WfU5m3x1WXf13p49W1vBRc1AqO7YBOKDi2Bzqh4Ngu6ISCY/ugEwqO7YTMC75XFtsMnVFxbD90RsWx7dMZFYu5rXtlRa5iMb91r0zMcN0rE3Nc98rELNe9MjnPFXx+6RkVy3mu4FNMz6hYznNNRa5iOc8VfDzvGRXLea5JznNNcp4r+CDmMyqW81zBxzGfUbGc5wo+lPmMiuU8V/DRzGdULOe5gg9oPqNiOc8VfEzzGRXLea7gw5rPqFjOcwUfBX1GxXKeK/io4K8q/vxDsnu9ie7GPfUGHyP7Xb0fH3q+F5PolO6qN9EZ3VVvohO6q95Embir3kSJuKveTPffnnoz3X876g0+Pta+3kRJuKteMX8VfHasfb1l1HpfahjWM73UENsH1XV//inV9VMy/7gd+l5vbB9kX29sH2Rfb2wfZF5v8OGu9vXG9kH29cb2Qfb1xvZB9vUWsXpjeyb7esX8VfCprvb1ivmr4DNdzesNPtLVvl4xfxV8oKt9vWL+ai9i9Yr5q+ADe+3rFfNXu5i/Cj6R2bze4COZ7esV81fBhzLb1yvmr4KPZbavV8xfBR/MbF+vmL8KPprZvl4xfxV8OLN9vWL+KvgoZ/t6xfxV8LHP9vWK+avgQ5/t6xXzV8FHPtvXq+WvpuDznu3r1fJXU/BZz/b1avmrezVi9Wr5qyn4jGf7erX81RR8vrN9vWL+KvhsZ/t6xfxV8LnO9vWK+avgM53t6xXzV8HnOdvXK+avgs9ytq9XzF8Fn+NsX6+Yvwo+w9m+XjF/FXx+s329Yv4q+Oxm+3rF/FXwuc329Yr5q+Azm+3rFfNXwec129cr5q+Cz2q2r1fMXy1i/moR81fB53Db1yvmr4qYvypi/ir4nHX7esX8VfA56/b1ivmr4HPW7esV81fB56zb1yvmr4LPWbevV8xfBZ+zbl+vmL8KPmfdvl4xfyU2v30Sm98+ic1vn8Tmt09i89snsfntk9j89klsfvskNr99EpvfPonNb5/E5rdPYvPbJ7H57ZPY/PZJbH77JDa/fRKb3z6JzW+fxOa3T2Lz2yex+e2T2Pz2SWx++yQ2v30Sm98+ic1vn8Tmt09i89snsfntk9j89klsfvskNr99EpvfPonNb5/E5rdPYvPbJ7H57ZPY/PZJbH77JDa/fRKb3z6JzW+fxOa3z2Lz22ex+e2z2Pz2WWx++3wrYvVq+atZbH77LDa/fRab3z6LzW+fxea3z2Lz22ex+e2z2Pz2WWx++yw2v30Wm98+i81vn8Xmt89i89tnsfnts9j89llsfvssNr99FpvfPovNb5/F5rfPYvPbZ7H57bPY/PZZbH77LDa/fRab3z6LzW+fxea3z2Lz22ex+e2z2Pz2WWx++yw2v30Wm98+i81vn8Xmt89i89tnsfnts9j89llsfvssNr99FpvfPovNb5/F5rfPYvPbZ7H57bPY/PZZbH77LDa/fRab3z6LzW+fxea3z2Lz22ex+e2z2Pz2WWx++yw2v30Wm98+i81vn8Xmt89i89tnsfnts9j89llsfvssNr99FpvfPovNb5/F5rfPYvPbZ7H57bPY/PZZbH77LDa/fRab3z6LzW+fxea3z2Lz22ex+e2z2Pz2WWx++yw2v30Wm98+i81vn8Xmt89i89tnsfnts9j89llsfvssNr99FpvfPovNb5/F5rfPYvPbF7H57YvY/PZFbH77Ija/fbkVsXq1/NUiNr99EZvfvojNb1/E5rcvYvPbF7H57YvY/PZFbH77Ija/fRGb376IzW9fxOa3L2Lz25dM873bPj9evC9H9Sa6/3bVm+h8brU+X7wf1ZvofO6qN9H53FVvovO5q95E+ben3kzzn7vqzXT/7ak30/23p95E+ber3iJWr5i/yjT/uaveYf3VSw3DeqaXGkL7oPt1zOvzQm51+/CXd/zePxXHntR8SsWhvdApFYd2Q6dUHNoPnVJxkas4tCc6peLQruiUikP7olMqDu2iTqlYznPFnt58SsVyniv2BOdTKpbzXLGnOJ9SsZznij3J+ZSK5TxX7GnOp1Qs57liT3Q+pWI5zxV7qvMpFct5rtiTnU+pWM5zxZ7ufErFcp4r9oTnUyqW81yxp+J+W/FaHs/BruWw4lR3p66KU51c6/p4VmPdjp7ViD079ZSKU51cPRXHnp96SsWp0mJXxanSYlfFqe7H27T98+ptmY8qTnU/7qo4VVrsqjhVWuyqOJXn6qo4lefqqjiV5+qpOPZM1VMqTuW5uipO5bm6KpbzXLFnq55S8cCe66WKgX3USxXBvdG0/FzIVMqHv76eLmvsWainVBzcG31X8Tw/L6Ssf6+4xJ6HekrFwb3RCRUH90YnVBzcG51QcZGrOLg3+rLi9eFB5n06qji4jzqh4lSeq6viVJ6rq+Jcnquj4tgzUk+pOJfn6qk4l+fqqTi659qf0wRv894+VPyvSSGPly+vVzLvrzUXwZqj+64zao7uvM6oObr3OqPm6O7rjJqj+68Tap6jO7Azao7uwc6oOboLO6NmQR82F8GaBX1Y7OnIJ9Us6MNiT0k+qWZBHxZ7WvJJNQv6sNhTk0+qWdCHxZ6efFLNgj4s9hTlk2oW9GGxJy+fVLOgD4s+q/mUmgV9WPR5zafULOjDos9sPqVmQR8WfW7zKTUL+rDos5tPqVnQh0Wf33xKzYI+LPoM51NqFvRh0ec4n1KzoA+LPsv5lJoFfVj0ec5n1Bx92u93NXfsnC7Rp/2eUHGqM7tjL2KJPgn2hIpTndddFac6rbsqTpWZeyreUyXmropz3Y97Ks51P+6pOFVW7qq4yFUs57l2Oc8VfYb1u4pfqhjYR71UEdwbLfPteSHLsnz46+uYZlSiz5o+oeLg3uiEioN7o+8q7pn7En3W9AkVF7mKg3ujEyoO7o1OqDi4Nzqh4uA+6oSKU3muniko0WdNn1BxKs/VVXEuz9VTcS7P1VNxkas4l+fqqXgkz1VuB32N6HOpO6sYyRsdVxHd7+ztp4o2//f9hzX6/OgTKo7ud76quMPFr9HnR59QcXS/Y19xkas4ut+xrzi637GvOLo3+q7iz552jT4/+oSKU3munoqjz48+oeJcnqun4lyeq6fiXJ6rp+IyUsUHz1Ws0edBd1YxlDc6rCK43ynl50LW8ukJq1qfi9lqLS//FU3Ta83BHc8pNQf3PGfUHH1m8yk1B/c9p9Qc3PmcUnNw73NKzUWw5uBe6ZSagzurU2oW9GHRZzafUrOgD4s+s/mUmgV9WPSZzafULOjDos9sPqVmQR8WfWbzKTUL+rDoM5tPqVnQh0Wf2XxKzYI+LPrM5lNqFvRh0Wc2n1KzoA+LPrP5lJoFfVj0mc2n1Czow6LPbD6lZkEfFn1m8yk1C/qw6DObT6lZ0IdFn9l8Ss2CPiz6zOZTahb0YZugD4s+m/uUmgV92Cbow6JP6P6u5o4p7Gv0Cd32FUef3vxlxZ8ngq7RpzefUHGq87qr4lSndVfFRa7iVIm5q+Jc9+OeinPdj3sqTpWVuypOlZR7Ko4+FfqEiuU8V/Sp0O8qfqliYB/1UkWJXcVan0vgblv79NdX9uXx51f2sh9k9+jzm0+pObg/OqXm4A7plJqDe6RTag7uks6oOfok51NqDu6UTqk5uFc6pebgzuqUmotgzYI+LPpU51NqFvRh0SdGn1Kzng/bok+YPqVmPR+2RZ8yfUrNej5suxXBmvV82BZ92vQpNev5sC36xOlTahb0YdGnTp9Ss6APiz55+pSaBX1Y9OnTp9Qs6MOiT7Y+pWZBHxZ9DvYpNQv6sOhzsE+pWdCHRZ+DfUrNgj4s+hzsU2oW9GHR52CfUrOgD4s+B/uUmgV9WPQ52KfULOjDos/BPqVmQR8WfQ72KTUL+rDoc7BPqVnQh0Wfg31KzYI+LPoc7FNqFvRh0edgn1KzoA+LPgf7lJoFfVj0Odin1Czow6LPwT6lZkEfFn0O9ik1C/qw6HOwT6lZ0IdFn4N9Ss2CPiz6HOxTahb0YdHnYJ9Ss6APiz4H+5SaBX1Y9DnYp9Qs6MO2IlizoA+LPu/8lJoFfdgm6MM2QR8Wfe75dzV3TPPfos89P6HiVGd2x2TZLfpM7BMqTnVed1Wc6rTuqTj6TOwTKk6VmLsqznU/7qk41/24p+IiV3GqpNxVsZznyjVlu6vigT3XSxUD+6ifKqLPwf4J49Ot/uvT3/71TUu7PV6+vNT8Z3aPPgf7lJqD+6NTag7ukE6puQjWHNwlnVJzcJ90Ss3BndIpNQf3SqfUHNxZnVDzHn0O9ik16/mwPfoc7FNq1vNh+60I1qznw/boc7BPqVnPh+3R52CfUrOgD4s+B/uUmgV9WPQ52KfULOjDos/BPqVmQR8WfQ72KTUL+rDoc7BPqVnQh0Wfg31KzYI+LPoc7FNqFvRh0edgn1KzoA+LPgf7lJoFfVj0Odin1Czow6LPwT6lZkEfFn0O9ik1C/qw6HOwT6lZ0IdFn4N9Ss2CPiz6HOxTahb0YdHnYJ9Ss6APiz4H+5SaBX1Y9DnYp9Qs6MOiz8E+pWZBHxZ9DvYpNQv6sOhzsE+pWdCHRZ+DfUrNgj4s+hzsU2oW9GHR52CfUrOgD4s+B/uUmgV9WPT5yN/V3DGNcI8+HfmEilOd2R2TcfboE3NPqDjVed1VcarTuqfiPVVm7qo4VWLuqjjX/bin4lz3456Ki1zFqZJyV8Vyniv6zOsTKh7Yc71UMbCP+qki+mzquv1U0W77h7++tT5S3Vrrz3vv62vFwb3RCRUH90bfVbzX9nzv+cN7H1/HC53gPsqZToHOGzrB/ZkzneBezplOcN/nTCe4R3SmE9x7+tKJPlPcmU4q/2tOB6/8jg5e+R2dAp03dPDK7+jgld/RwSu/o4NXfkcHr3xMp0af++5MB6/8jg5e+R0dvPI7OgU6b+jgld/RwSu/o4NXfkcHr/yODl75DZ3os/md6eCV39HBK7+jI3tHX8vz+Z1ySEf2jt5DJ/qk7hPprI93Xrf9iI7sqdxFR/ZU7qIj28HoolOg84aObAeji46s39mm7Z/Xbst8REfW73TRke1gdNGR7WD00Ik+Td2ZjqxX7qIj65W76Mh65S46BTpv6Mh65S46eOV3dPDK7+jgld/RwSu/oRN94r0zHbzyOzp45Xd08Mrv6JRUdL557+3nrbftZfLi0l755HLL9nxy+WV7Prkcsz2fXJ7Znk8u1/zNe++3x+3rX+OP/uDzl+/BPk+mqdG3GQzFMpcj92WZy7/7sszl9n1ZFliasdTNEfYsdTOHPUvdfGLPUjfL2LMk95ix3Mg9dizJPXYsyT12LMk9diwLLM1YknvsWJJ77FiSe+xYknvsWJJ7zFhG38Q1FEv8ZR/L9fF8zrpPRywLLM1Ych+3+2+c+7gdS+7jZixzbY1yZkn/0o4l/cu/sHzhg2d8z6fA5y0f4d5he751XQ75CPcDu/gIZ4MuPsJ+v4uPsIfv4ZNs85U9H12vXZ/2eWql/sHnd1472aYsX5a6vtyeZYGlGUtdv2/PUjcb2LPUzRH2LHUzhz1L3XxizbIl20zmy5LcY8eS3GPHktxjx7LA0owluceOJbnHjiW5x44luceOJbnHjGWyLXO+LMk9dizJPXYsyT12LAsszViSe+xYknvsWJJ77FiSe+xYknvMWCbb4+rLssCyi+Xn3zO2ZJssfVly77H7b5x7jxnLZHsRfVnSc7NjSc/NjiU9t7+wfOFT4POWDz7wPR/dflfbHi+e7+Ue8dHtYfXx0c0GfXx0/X4Xn2T7Gu356PryPj6yXnu+LdOTTyt/8PmL1y63h9febj+vnV69drINj74sCyzNWMp6+BNYyvr9E1jKZoMTWMrmiBNYymYOe5a6uy5PYCmbZU5gSe6xY0nusWNZYGnGktxjx5LcY8eS3GPHktxjx5LcY8ZSd9flCSzJPXYsyT12LMk9diwLLM1YknvsWJJ77FiSe+xYknvsWJJ7zFjq7ro8gSW5x44luceOJbnHjmWBpRlLco8dS3KPHUtyjx1Lco8dS3KPGUvd3cAnsCT32LEk99ixJPfYsSywNGNJ7rFjSe6xY0nuMWOpu8P1S5Yd89h0d7iewJJ7Tx/LjllNursyT2DJvceOJT03O5b03IxYzjfdXZnvWL7wwTO+54MPfM9Ht981Tc+rnsohnwKft3x0s0EfH12/38dH18P38dH15X18dL32VNfnVZf2B5/f9B/nm+5+xhNY6vpye5a6Ht6epbDfN2dZYGnGUjhHmLMUzhzmLIXziTlL4SxjzpLcY8ZSdz/jCSzJPXYsyT12LMk9diwLLM1YknvsWJJ77FiSe+xYknvsWJJ7zFjq7gY+gSW5x44luceOJbnHjmWBpRlLco8dS3KPHUtyjx1Lco8dS3KPGUvdfconsCT32LEk99ixJPfYsSywNGNJ7rFjSe6xY0nusWNJ7rFjSe4xYym8p9meJbnHjiW5x44luceOZYGlGUs8UR/Lj/PY7izxRGYshXdlfseyY1aT8K5Me5bce+xY0nOzY0nPzY4lPbe/sHzhg2d8zwcf+JaP8J7K+fnW83K7HfHR7WH18dHNBn18dP1+H58Cn7d8dH15Hx9dr73MP3zKdsRH1z/38dH1z318dP1zFx/hfYd9fHT9cx8fXf+8tEf7Zy6l/sHnP19d2uM61unle4o/vj8T3ktoz7LA0oylroe3Zyns981ZCmcDc5bCOcKcpXDm+IblyzNF63LAsgnnE3OWwlnGnCW5x44luceOZYGlGUtyjx1Lcs+3LA+fsxbeiWvPktxjx1I395Tno4Dzunx6bnCvD5Z7e3nnZf9hOQnvxLVnqZt77Fnq5h57lrq5x55lgaUZS93c8xXLOj9KrMt2xFI399iz1M099ix1c489S3KPGUvh/cT2LMk9fSzX5zvvtyOW5B47luQeO5YFlmYsyT12LMk9dizJPXYsyT19LJ9fDrXbesSS3GPGUng/sT1Lco8dS3KPHUtyjx3LAkszlrq5Z90eX4fN2236wPIeah5vff+fL0/MlPZKUzf5nEFTN/ucQVM3/ZxBUzf/fEdznsrjQua6/0HzP1/dMVVvEt5q7E1eN1t5k9dNYt7kdXObN/kCeSfyZEIv8uRHL/JkTS/y5FIv8mRYJ/LCG6q9yZNhvciTYb3Ik2G9yBfIO5Enw3qRJ8N6kSfDepEnw3qRJ8M6kRfeNu5NHj9/BvnP22Qn4Y3R3uTxNl6nDd7Gizzexon8hrfxIk9/3os8/fn/mvwLTTy6Jc0CTUOa9Mb7aC637XEhSzmkSb/bkiY5z5Im2c2SJnnMkOZOxrKkSW7qpLk/mo1TWW9/0PzLq/fyZF/Ly5WU6ZU9ycmPPTnLj32BvRt7MpwfexKfH3vyoR970qQfe7KnG/tKUvVjT671Y0+u9WNPrvVjX2Dvxp5c68eeXOvHnlzrx55c68eeXOvGvpFr/diTa/3Yk2v92JNr/dgX2LuxJ9f6sSfX+rEn1/qxJ9f6sSfXerGfb+RaP/bkWj/25Fo/9uRaP/YF9m7sybV+7Mm1fuzJtX7sybVu7Cc85gnsOyagzRMO04s899kzyH+eSTRP3GW9yHOP9SJP59iJ/Ezf2Is8XeP/mvwLTTy6JU18dx/NdXrUOK17/XAqlPa46nV6eefpj1OhQN6JPF1dL/JkTS/yZE0v8mRNL/JkTSfyC1nzBPJrebz1ui5H5MmaXuTJpV7kybBe5AvknciTYb3Ik2G9yJNhzyW/3Y7Ik2G9yJNhncgXMmwf+e2HyLZOH8hPa3nu8FnX13n/r8/hFVKsH3tyrB97kqwf+wJ7N/akWT/25NlT2D8fvb770fmIPYnWjz2Z1o89qdaN/Uqu9WNPrvVjT649g31ptyf7+qfH/F3fbSUDj6FTQachdCJbn6HTtv+8upajew7Z2o892dqPPdnajz3Z2o39Rrb2Y0+29mNPtj6FfX3OLNpaO2JPXvZjX2Dvxp5c68eeXOvHnlzrx55c68eeXHsK++lxIdM+/envf9dv3snAY+hEXh5DJ7L1GTrV2/N7tj+u5I97zk629mNfYO/Gnmztx55s7ceebO3Hnmztx55sfQr7aX2yn+sB+0pe9mNPBvZjT671Y0+u9WNfYO/Gnlzrx55cewb7N3vNftdvrmTgMXQiL4+hk2623pbnVd+/4v+k09p+ngKY2st1/JXI+rjlzK+b7e7X8UO+6SZrb/K6udqbvG6q9iavm6nNyL/QLNA0pKmbe8+gqZtkz6CpmzfPoKmbCs+gSXazo7ncyGOWNMlYfTS37TkdaqvzHzT/ch3r46r39vL07vIKnojlBJ6EdQL4eX6+dVn/nm2XW4G8E3mSmxd5Up4XeRKhF3nSoxd5kuYZ5D/37ZeJVOpFngTbR36/PZ+v2qf63wepiQTrBJ4EewL4nvvrVCDvRJ4E60WeBOtFngTrRZ4E60WeBHsG+Y4cNZNgvciTYDvJ/zxVv6+fnrbsCFIzCdYJPAn2BPA999e5QN6JPAnWizwJ1os8CdaLPAnWizwJ9gzyHTlqIcF6kSfBdpKv5Um+7f99kFpIsE7gSbAngO+5vy4F8k7kSbBe5EmwXuRJsF7kSbBe5EmwZ5DvyFGFBOtFngT7Nfl6K3+Qf6FJLLWkSda0pFmg2UWzrk8idSv/+1+3TArx0Qk86fEE8D1OupAevciTHr3Ikx6dyK+kRy/ypEcv8iTNM8h3dExWUqkX+QL5PvJz/SG/fiDflsdggrb9PBMz1/a70LWSdgcQiWQ8gEiE6AFEIm8PIBLRPL5IGyl+AJEI/AOIRG9gAJFoIwwgUkGk+CLRcegTqU3PEZRtmT+I1AOeLoITeDoDJ4Dv+dplI+57kSfDO5HfCeZe5EnbXuSJ0F7kycVnkO/4en0vkHciT4L1Ik+E9SJPhu0kv+5P8h9/8vfu1S/sSbF+7MmxJ7Dfa3tex/zhOo6v+UelSuYdQSXy8QgqkaVHUIncPYJKBZUGUIk8P4JKZP8RVKJPMIJKdBRGUInewwAqNXoPI6hE72EEleg9jKASvYcRVCqoNIBK9B5GUInewwgq0XsYQSV6DyOoRO8hvkrlRu9hBJXoPYygEr2HEVSi9zCCSgWVBlCJ3sMIKtF7GEEleg8DqDSRl5xVWsv8z2vXcqgSeWkElQoqOav0HD2zbvuRSni8EVTC442gEh5vBJX4fmkElfh+aQCVZvKSs0rbtP3z2m2Zj1QiL42gEt8vjaAS3y+NoFJBpQFUovcwgkr0HkZQid7DCCrRexhBJXoPA6i00HsYQSV6DyOoRO9hBJXoPZyh0hfX0Z7PPbR1fXnf26tKBZUGUInewwgq0XsYQSV6DyOoRO9hBJXoPQygUqH34K3S843bXZkDleg9jKASvYcRVKL3MIJKBZUGUInewwgq0XsYQSV6D5eq9EKefoIXeXoETuRXcr8XebK8F3nyuRd5MrcX+aJB/qVikUz6UrFIvnupWCQrvVQsklFeKhbJBj8VbyKe/KXi4F64PW/e9/+9rx8qntbnq9dyVHFwD3pCxcG933cVW89p2wp03tAJ7uWc6QT3fc50gntEZzrB/aQzneDe05fOHtynOtNJ5WnN6aTyv+Z08Mrv6BTovKGDV35HB6/8jg5e+R0dvPI7OnjlN3QqXvkdHbzyOzp45Xd08Mrv6BTovKGDV35HB6/8jg5e+R0dvPI7OnjlN3QaXvkdHbzyOzp45Xd08Mrv6BTovKGDV35HB6/8jg5e+R0dvPI7OnjlYzrrDa/8jg5e+R0dvPI7Onjld3QKdN7QwSu/o4NXfkcHr/yODl75HR288hs6E175HR288js6eOV3dPDK7+gU6Lyhg1d+Rwev/I4OXvkdHbzyOzp45Td0ou/uPo/O+pyWv5ZDOrJ+p4uO7D1rXR+TUdZtP6Ije8/qoiN7z+qiI3vP6qETfX+qMx3Z/k4XHVm/07Gnc42+p9OZToHOGzqy/Z0uOrJeuYuOrFfuoiPrlbvoyHrlHjrR9/0505H1yl108Mrv6OCV39Ep0HlDB6/8jg5e+R0dvPI7Onjld3Twym/oRN+R9SWdb957XR9f903ryzvP5W+vvpN6lLhPRyxzOWtflrl8uC/LXK7dl2WB5X+yfOGTy+Xb88nl8+355HL69nxyeX17Prncvjmf6Pu33Png4d/z0fXl2/yI3tP2UuPfvWRP9k62NcyXZYFlD8t5fpZY1iOWuh7enqWu37dnqZsN7Fnq5gh7lrqZw5xlsr1rvix1s8x3LDv6vsl2uvmyFM492/pkuVeD3JNsX5wvS+Hc8w3LrnuPcO4xZymce8xZCucec5bCuceaZbIder4shXOPOUvh3PMVy47ck2ybny/LAkszluQeO5a6uWe/PSL2tK+3Dyyn9XkdazliqZt77Fnq5p6vWFrPmku2DXEY7sn2LI7DXTd7+XLXzWm+3HUznS/3AncX7rpZ0Zc7udKHOxnUhzt51Yc7edWD+5Zs1+k43MmrPtzJqz7cyas+3AvcXbiTV324k1d9uJNXfbiTV324k1dduCfbNzwOd/KqD3fyqg938qoP9wJ3F+7kVR/u5FUf7uRVH+7kVR/u5FUX7jN51Yc7edWHO3nVhzt51Yd7gbsLd/KqD3fyqg938qoPd/KqD3fyqgv3hbzqw5286sOdvOrDnbzqw73A3YU7edWHO3nVhzv+3Zz7Wh6LstZyxL3g332442fsua/1wX3bj7gXuLtwx8/4cMfP+HCn/+7Dnf67D3f8uzn3jl0w24p/9+FO/92HO/13H+7kVR/uBe4u3MmrPtzJqz7cyas+3MmrPtzJqy7cN/KqD3fyqg938qoPd/KqD/cCdxfu5FUf7uRVH+7k1T7uX7zzPC+3Hx4/r55a++qdX1Qi3Y6gEll4AJV2kvMIKpGzL1XphTxJ24s8WduLfIG8E3nythd5ErcXeTK3F3lytBd5srET+Ure9SJPhj2BfH2SX6btD/J/uY71Vh7Xsa4vr972V51IvGPoRD521sl6WkEtKJpMUfJ8NkXpE2RTlP5DNkXpa2RTlH5JMkUbfZhsitLfyaYonaBsitIzyqZoQdFkitIzyqYoPaNsitIzyqYoPaNsitIzyqXofqNnlE1RekbZFKVnlE1RekbZFC0omkxRekbZFKVnlE1RekbZFKVnlE1RekbJFJ3oGWVTlJ5RNkULio6jaMceyn0ij2ZTFK87kqKfd6vtE143maIzXjebonjdbIry/Wg2Rfl+NJuiBUXHUbRjrvs+k0ezKcr3o9kU5fvRbIrSM8qmKD2jZIou9IyyKUrPKJui9IyyKUrPKJuiBUWTKUrPKJui9IyyKUrPyFvRb655nZ441vlgrvm+0DXKpyl9o3SaFjpH+TSld5RPU7pH+TSlf5RP04Kmg2q6LEea0kPKpyldpHya0kcaStNlfWpa6pGm9JHyaUofKZ2mK32kfJrSR8qnKX2kfJrSR8qnaUHTQTVd1yNN6SPl05Q+Uj5N6SOF1fRFJTpDI6hEr8depWWqT5XW8kGlab2VnzPv6HvLjf7NGDrRk3HWyXpu5kZHJpui9GOyKVpQNJmi9GKyKUonJpui9GGyKUrPJpui9HeSKbrTCcqmKD2jbIrSM8qmKD2jbIoWFE2mKD2jbIrSM8qmKD2jbIrSM8qmKD2jZIpWekbZFKVnlE1RekbZFKVnlE3RgqLJFKVnlE1RekbZFKVnlE1RekbZFKVnlEzRRh4dSNG1zP+8di2HipJHsymK1x1J0Y6t6A2vm01RvG42RfG6uRStN74fzaYo349mU5Q8OpCiHXsF6408mk3RgqLJFOX70WyK0jPKpig9o2yK0jPKpig9o2SKTvSMsilKzyibovSMsilKzyibogVFkylKz8hb0W+uuWdvdp3oGuXTlL5RPk3pHOXTlN5ROk1nukf5NKV/lE9TOkijarosR5rSQ8qnaUHTdJrSRxpK04692XWmj5RPU/pI+TSlj5RPU/pI6TRd6CPl05Q+Uj5N6SONqum6HmlKHymfpgVN02lKHymspi8q0RkaQSV6PSeotG5Pldr2QaU2P57WbPv0Ut/tVSW6NyOoRD/GWSXjmZm10I3Jpii9mGyK0onJpih9mGyKFhRNpig9mGyK0q/Jpii9nWyK0gfKpig9o2SKrvSMsilKzyibovSMsilKzyibogVFkylKzyibovSMsilKzyibovSMsilKzyiZohs9o2yK0jPKpig9o2yK0jPKpmhB0WSK0jPKpig9o2yK0jNKpuhOHh1I0bXM/7x2LYeKkkezKVpQdCBFOzai73jdbIridbMpitfNpijfj2ZTlO9HkylayaMDKdqzU7CSR7Mpyvej2RTl+9FsihYUTaYoPaNsitIzyqYoPaNsitIzyqYoPaNkijZ6RtkUpWeUTVF6Rt6KfvHO7flUSnvdzfDHDOxGzyibogVFkylKzyibovSMsilKzyibovSMsilKz2gkRdfHa9t++7ui7UbPKJui9IyyKUrPKJui9IyyKVpQNJmi9IyyKUrPKKyiLyrRBxpBJXo7J6jUnruuyzR9UGm+v8nPq+c/Xv2iEx2bIXSa6MO46/Qj03pw6k30VkZQiX7JCCrRAxlBpYJKA6hEr2IEleg/eKu0ro8X79ORSvQfRlCJ/sMIKtF9GEClmd7DCCrRexhBJXoPI6hE72EElQoqDaASvYcRVKL3MIJK9B5GUInew3+p0gtLOgRmLBdyvB1L0rYdSzKxHUuSqx3LAkszlqRAO5ZkNTuWJCo7luQeO5bkHjOWhdzzF5YvfISzzD4/+dT9w9/adOfwePW0lKO/NuE0cwJN4TxzAs0CTUOawpnmBJrCqeYEmsK55gSawsnmBJrC2cae5iqcbk6gSRaypEkWsqRJFrKkWaBpSJMsZEmTLGRJkyxkSZMsZEmTLGRIcyMLWdIkC1nSJAtZ0iQLWdIs0DSkSRaypEkWsqRJFrKkSRaypEkWMqS5k4UsaZKFLGmShSxpkoUsaRZoGtIkC1nSJAtZ0iQLWdIkC1nSJAsZ0qxkIUuaZCFLmmQhS5pkIUuaBZqGNMlCljTJQpY0yUKWNMlCljTJQoY0G1nIkiZZyJImWciSJlnIkmaBpiFNspAlTbKQJU2ykCVNspAlTbKQGc3ldiMLWdIkC1nSJAtZ0iQLWdIs0DSkSRaypEkWsqRJFrKkSRaypEkWMqQ5kYUsaZKFLGmShSxpkoUsaRZoGtIkC1nSJAtZ0iQLWdIkC1nSJAsZ0pzJQpY0yUKWNMlCljTJQpY0CzQNaZKFLGmShSxpkoUsaZKFLGmShQxpLmQhS5pkIUuaZCFLmmQhS5oFmoY0yUKWNMlCljTJQpY0yUKWNMlChjQLWciSJlnIkiZZyJImWciSZoGmIU2ykCVNspAlTbKQJU2ykCVNspAhzZUsZEmTLGRJkyxkSZMsZEmzQNOQJlnIkiZZyJImWciSJlnIkiZZyJDmRhaypEkWsqRJFrKkSRaypFmgaUiTLGRJkyxkSZMsZEmTLGRJkyxkSHMnC1nSJAtZ0iQLWdIkC1nSLNA0pEkWsqRJFrKkSRaypEkWsqRJFjKkWclCljTJQpY0yUKWNMlCljQLNA1pkoUsaZKFLGmShSxpkoUsaZKFDGk2spAlTbKQJU2ykCVNspAlzQJNQ5pkIUuaIlnopWKRvPJSsUimeKlYxPc/K76XJlexiH9+qVjE475ULOJDXyouchWL+LmXitU816Syg/6l4oE910sVA/uonypG3ov+UsXAfuelioE9zEsVA/uSlypKiioG9g8vVQzsCV6qGPg+/1JFinv3yPuEf6oYeY/vSxUp7t0j7619qSLFvXvkPa0vVaS4d4+8l/SlihT37pH3cL5UkeLePfLeyZcqot+72+PV90bHNP9RxS+/FZ7Cb2U8o+bovuCMmotgzdE9xxk1R3coZ9Qc3c+cUXN093NGzdG90gk1h99id0bNgj4s/Ea4M2oW9GHht6udUbOgDwu/qeyMmgV9WPitX2fULOjDwm/QOqNmQR8WfhvVGTUL+rDwm53OqFnQh4XfknRGzYI+LPzGoTNqFvRh4bf3nFGzoA8LvwnnjJoFfVj4rTJn1Czow8JvaDmjZkEfFn7byRk1C/qw8JtDzqhZ0IeF38JxRs2CPiz8Roszahb0YeG3Q5xRs6APC79p4YyaBX1Y+K0FZ9Qs6MPCbwA4o2ZBHxZ+mv4ZNQv6sPCT6c+oWdCHhZ/yfkbNgj4s/MT0M2oW9GHhp4+fUbOgDws/yfuMmgV9WPip2GfULOjDwk/GPqNmPR82h5+OfUbNej5sDj8h+4ya9XzYfCuCNev5sDn8pOwzatbzYXP4adln1Czow8JP4j6jZkEfFn7K9xk1C/qw8BPEz6hZ0IeFn05+Rs2CPiz85PMzahb0YeGnqp9Rs6APCz+x/YyaBX1Y+GnwZ9Qs6MPCT5o/o2ZBHxZ+iv0ZNQv6sPAT8s+oWdCHCc7TnwXn6c+C8/RnwXn6s+A8/Vlwnv4sOE9/FpynPwvO058F5+nPgvP0Z8F5+rPgPP1ZcJ7+LDhPfxacpz8LztOfBefpz4Lz9GfBefqz4Dz9WXCe/iw4T38WnKc/C87TnwXn6c+C8/RnwXn6s+A8/Vlwnv4sOE9/FpynPwvO058F5+nPgvP0Z8F5+rPgPP1ZcJ7+LDhPfxacpz8LztOfBefpz4Lz9OdI8/RfriqQU3q5qkBe5uWqArmNl6sK5Ad+rirS5PWXqwp0T325qkB3vZerCnRfermqQHeOl6sKebZHmqL9clUhz/ZIk6hfrirk2R5pmvPLVYU82yNNRH65qpBne6Spwi9XFfJsjzSZ9+WqQp7tkabbvlxVxLN9iTQh9uWqIp7tS6Qpqy9XFfFsX24Rz/Yl0izRl6uKeLYvkeZxvlxVxLN9OXum5c8nnT1J8uWTpss+ab7sk5bLPqlc9knrZZ+0XfZJ+2WfVC/7pMvOiPmyM2K+7IyYLzsj5svOiPmyM2K+7IyYLzsj5svOiPmyM2K+7IxYLjsjlsvOiOWyM2K57IxYLjsjlsvOiOWyM2K57IxYLjsjlsvOiHLZGVEuOyPKZWdEueyMKJedEeWyM6JcdkaUy86IctkZUS47I9bLzoj1sjNiveyMWC87I0x+kTrv5flJtf3xSb98Sm4x+dXoGde1Bb2uPeh11aDX1WJel8kvDc+4rinodc1Br2sJel1Bz/st6Hm/BT3vt6Dn/Rb0vN+Cnvd70PN+D3re70HP+z3oeb8HPe/3oOf9HvS834Oe93vQ834Pet7XoOd9DXre16DnfQ163teg530Net7XoOd9DXre16DnfQ163reg530Let63oOd9C3ret6DnfQt63reg530Let63oOd9i3nel1vM877cYp735RbzvC+3mOd9ucU878st5nlfbjHP+3KLed6XW8zzvtyCnvdT0PN+CnreT0HP+ynoeT8FPe+noOf9FPS8n4Ke91PQ834Ket7PQc/7Oeh5Pwc97+eg5/0c9Lyfg573c9Dzfg563s9Bz/s56Hm/BD3vl6Dn/RL0vF+CnvdL0PN+CXreL0HP+yXoeb8EPe+XoOd9CXrel6DnfQl63peg530Jet6XoOd9CXrel6DnfQl63peg5/0a9Lxfg573a9Dzfg163gf9fW0J+vvaEvT3tSXo72tL0N/XlqC/ry1Bf19bgv6+tgT9fW0J+vvaEvT3tSXo72tL0N/XlqC/ry1Bf19bgv6+tgT9fW0J+vvaEvT3tSXo72tL0N/XlqC/ry1Bf19bgv6+tgT9fW0J+vvaEvT3tSXo72tL0N/XlqC/ry1Bf19bgv6+tgT9fW0J+vvaEvT3tSXo72tL0N/XlqC/ry1Bf19bgv6+tgT9fW0J+vvaEvT3tSXo72u3sydc/+erv9yAvizPC2n7+nMlf92A/tV777ft8db7evt5dVn+y3eel/XxzvPStp9rbu1v71zb853nD++8lvmf165lOVI00DY4FDVRNNAmPRQ1UbSgaDJFA21wRFETRQNtv0RRE0UDbQ5FURNFA21dRVETRQNtI0dRC0XP3sSDopcrSs8om6L0jEZStN4eirb1SFF6RtkULSiaTFF6RtkUpWc0kqL7j6LbkaL0jLIpSs8om6L0jJIputEzyqYoPaNsitIzGknRtT4U3fYjRekZZVO0oGgyRekZZVOUnlE2RekZZVOUnlE2RekZJVN0p2eUTVF6RtkUpWeUTVF6RtkULSiaTFF6RtkUpWeUTVF6RtkUpWeUTVF6RskUrfSMsilKzyibovSMsilKzyibogVFkylKzyibovSMsilKzyibovSMsilKzyiZoo2eUTZF6RllU5SeUTZF6RllU7SgaDJF6RllU5SeUTZF6RllU5SeUTZF6RnlUnS/0TPKpih59ARFp/pUdC2Win6egb3fCoomU5Q8mk1R8mg2Rcmj2RQlj2ZTlDyaTNGJPJpNUZ5hyKYozzBkU5SeUTZFC4oOpOjnDT77RM8om6L0jLIpSs8om6L0jEZS9PN2kH2iZ5RM0ZmeUTZF6RllU5SeUTZF6RllU7Sg6ECKdjwLONMzyqYoPaNsitIzyqYoPaNsitIzSqboQs8om6L0jLIpSs8om6L0jLIpWlA0maL0jLIpSs8om6L0jLIpSs8om6L0jJIpWugZZVOUnlE2RekZZVOUnlE2RQuKJlOUnlE2RekZZVOUnlE2RekZZVOUnlEyRVd6RtkUpWeUTVF6RtkUpWeUTdGCoskUpWeUTVF6RtkUpWeUTVF6RtkUpWeUTNGNnlE2RekZZVOUnlE2Rcmj9orOzxGbd3FNN+F1zMDeyKPZFCWPZlOUPJpNUfJoMkV38mg2Rcmj2RQlj2ZTlGcYsilaUDSZovSMsilKz2gkRTs2+Oz0jLIpSs8om6L0jJIpWukZjaRox3aQSs8om6L0jLIpSs8om6IFRZMpSs8om6L0jEZStONZwErPKJui9IyyKUrPKJmijZ5RNkXpGWVTlJ5RNkXpGWVTtKBoMkXpGWVTlJ5RNkXpGWVTlJ5RNkXpGeVStN7oGWVTlJ5RNkXpGWVTlJ5RNkULiiZTlJ5RNkXpGWVTlJ5RNkXpGWVTlJ5RMkUnekbZFKVnlE1RekbZFKVnlE3RgqLJFKVnlE1RekbZFKVnlE1RekbZFKVnlEzRmZ5RNkXpGWVTlJ5RNkXpGWVTtKBoMkXJo32K2k6qrjOp0Yc72c6F+0IC8+FOTvLhTprx4U7m8OFe4O7Cne98fbjzzawPd/KqD3fyqj33z5s46kJedeFeyKs+3MmrPtzJq/bcP0+fr4W86sO9wN2FO3nVhzt51Yc7edWHO3nVnnvH8wSFvOrCfSWv+nAnr/pwJ6/6cCev+nAvcHfhTl714U5e9eFOXvXhTl714U5edeG+kVd9uJNXfbiTV324k1d9uBe4u3Anr/pwJ6/6cCev+nAnr/pwJ6+6cN/Jqz7cyas+3MmrPtzJqz7cC9xduJNXfbiTV324k1d9uJNXfbiTV124V/KqD3fyqg938qoPd/KqD/cCdxfu5FUf7uRVH+65/LvxVKSWy2Vb08nlha3p5HKs1nRy+UprOgU6b+jk8mjWdHI5KWs6ufrz1nRyddGt6eCVj+m0m65X/jx/r910vXIPHV2v3ENH1yv30CmydD7PyWo3Xa/cQ0fXK/fQ0fXKPXR0vXIPHV2v3EFn0vXKn7+TaJOuV+6ho+uVe+joeuUeOgU6b+joeuUeOrpeuYeOrlfuoaPrlXvo6HrlDjozXvkdHbzyOzp45Xd08Mrv6BTovKGDV35HB6/8jg5e+R0dvPI7OnjlN3QWvPI7Onjld3Twyu/o4JXf0SnQeUMHr/yODl75HR288js6eOV3dPDKb+gk2wBvTQev/I4OXvkdHbzyOzoFOm/o4JXf0cErv6ODV35HB6/8hk70Pb91qz90bvsnOl+89/3/fV71Vl+eWF7a366krY+3nlp7vY71v1Wp4zeG0bcCo9K/VQru/1Dp3yoVVBpApeB+GJX+rVJwX45K/1YpeD5ApX+rFDynoNK/VQr+3QIq/Uul6FuYUenfKtF7GEEleg/eKnVMg4m+DxqV/q1SQaUBVKL3MIJK9B68VeqY+BJ9jzUq/Vsleg8jqETvYQCVom/URqV/q0TvYQSV6D14q9TxDFH03d6o9G+VCioNoBK9hxFUovcwgkr0HkZQid7DCCrRexhApejb0VHp3yrRexhBJXoPI6hE72EElQoqDaASvYcRVKL3MIJK9B5GUInewwgq0XsYQKVG72EEleg9jKASvYcRVKL3MIJKBZUGUInewwgq0XsYQSV6DyOoRO9hBJXoPYRXqdxu9B5GUInewwgq0XsYQSV6DyOoVFBpAJXoPYygEr2HEVSi9zCCSvQeRlCJ3sMAKk30HkZQSTcvrdvtqdJt+qTSsj/AT2W9/by6tL+Sf7x43V/e+a7oC/kCeSfyurnGm7xuVvEmr5s/vMnrZoozybf1nxdvt/WIvG5OcCY/63p/b/K63yV6k9f9fvBU8tOT/HZEngzrRb5A3ok8GdaLPBnWizwZ1os8GfYM8vW5ZajWI/JkWCfyCxnWizwZ1os8GdaLPBnWi3yBvBN5MqwXeTKsF3kyrBd5MqwXeTKsE/lChvUiT4b1Ik+G9SJPhvUiXyDvRJ4M60WeDOtFngzrRZ4M60WeDOtEfiXDepEnw3qRJ8N6kSfDepEvkHciT4b1Ik+G9SJPhvUiT4b1Ik+GdSK/kWG9yJNhvciTYb3Ik2G9yBfIO5Enw3qRJ8N6kcfP95Gfp/K4kLnun8h3zHTa8fNe5PHzXuTx817k8fNe5AvkTyDfMXFix897kcfPe5HnOykv8nwn5UWeDOtEvpJhzyDf0bepZFgv8mRYL/JkWC/yBfJO5MmwXuTJsF7kybBe5MmwXuTJsE7kGxnWizwZ1os8GdaLPBnWi3yBvBN5MqwXeTKsF3kyrBd5MqwXeTKsD/k7Ysg7kSfDepEnw3qRJ8N6kS+QdyJPhvUiT4b1Ik+G9SJPhvUiT4Z1Ij+RYb3Ik2G9yJNhvciTYb3IF8g7kSfDepEnw3qRJ8N6kSfDOpGfdf38VNfnVf+L31vyHdM7plnXoduz1PXc9iwLLM1Y6vpie5a6Tvc7lu3x4u22HrHU9a72LHXdqD1L3e9IzFkuut96fMny4zSaaSH32LEk99ixJPfYsSywNGNJ7rFjSe7pY9nRv1zIPXYsyT12LMk9ZiwLuceOJbnHjiW5x44luceOZYGlGUtyjx1Lco8dS3KPHUtyjx1Lco8Zy5XcY8eS3GPHktxjx5LcY8eywNKMJbnHjiW5x44luceOJbnHjiW5x4zlRu6xY0nusWNJ7rFjSe6xY1lgacaS3GPHktxjx5LcY8eS3GPHktxjxnIn99ixJPfYsST32LEk99ixLLA0Y6nrL2/Lo8b51sonlh1zDXZdf2nPUtdfmrOsuv7SnqWuv7Rnqesvv2PZMSOi6vpLe5YFlmYsdfvq9ix1++pfsvz8W/xK7rFjSe6xY0nuMWPZyD12LMk9dizJPX0sO/qXjdxjx7LA0owluceOJbnHjiW5x44luceOJbnHiuV8I/fYsST32LEk99ixJPfYsSywNGNJ7rFjSe6xY0nusWNJ7rFjSe4xYym8Hd6eJbnHjiW5x44luceOZYGlGUtyjx1Lco8dS3KPHUtyjx1Lco8Zy5ncY8eS3GPHktxjx5LcY8eywNKMJbnHjiW5x44luceOJbnHjiW5x4zlQu6xYynrL6f6xDO1Uj+x/DzXYNbdP34CS1l/eQJLWX95AktZf3kCS1l/+SXLzzMiZt394/YsdfePn8BStq9+AkvZvvq3LD/+Fn/W3T9+AssCSzOW5B47luQeO5bkHjuW5J4+lh39S9394/YsdfePn8CS3GPHktxjx5LcY8eywNKMJbnHjiW5x44luceOJbnHjiW5x4yl7v7xE1iSe+xYknvsWJJ77FgWWJqxJPfYsST32LEk99ixJPfYsST3mLHU3T9+Aktyjx1Lco8dS3KPHcsCSzOW5B47luQeO5bkHjuW5B47luQeM5aV3GPHktxjx5LcY8eS3GPHssDSjCW5x44luceOpa6/3G/b4633vX1i2THXQHf/+Aksdf2lPUtdf2nPUtdf2rMssOxi2fHbUt394yew1PWX9ix1++r2LHX76vYsyT1WLBfd/eNfsvycxxfd/eMnsCT32LEk99ixLLA0Y0nusWNJ7rFjSe6xY0nusWNJ7jFjqbt//ASW5B47luQeO5bkHjuWBZZmLMk9dizJPXYsyT12LMk9dizJPWYsdfePn8CS3GPHktxjx5LcY8eywNKMJbnHjiW5x44luceOJbnHjiW5x4yl7v7xE1iSe+xYknvsWJJ77FgWWJqxJPfYsST32LEk99ixJPeYsUy2f7y253vPH957LU865c/reKGTyzFa08nlAa3pFOi8oZPLp1nTyeW8rOnk8lLWdHK5I2s6ufq8xnSSbbi2poNXfkdH1yvX24NOW4/o6HrlHjoFOm/o6HrlHjq6Xnn/obMd0dH1yj10dL1yDx1dr9xBJ9lWZGs6ul65h46uV14f77xu+xEdXa/cQ6dA5w0dXa/cQ0fXK/fQ0fXKPXR0vXIPHV2v3EEn2SZdazq6XrmHDl75HR288js6BTpv6OCV39HBK7+jg1d+Rwev/I4OXvkNnWTbV63p4JXf0cErv6ODV35Hp0DnDR288js6eOV3dPDK7+jgld/RwSu/oZNsk6w1HbzyOzp45Xd08Mrv6BTovKGDV35HB6/8jg5e+R0dvPI7OnjlYzol2fZRazrB/c6+/NCpy/qBTtsfv9dr+3JUcZGrOLgvOaHi4F7jhIqD+4cTKg7uCb6r+H7dt+fL5/bh3Vt9vHdrhyd7cFfgzSf6dj53PsG7aO58gvfR3PmkcpYn8CnwecsnlWv9js83Ke/4ql9YpvLDzixTOW1nlsIe3pylsN+3Zhl9g91QLIVzhDlL4cxhzlI4n5izLLA0Y0nusWNJ7rFjSe6xY0nusWNJ7jFjGX2D3VAsyT12LMk9dizJPXYsCyzNWJJ77FiSe+xYknvsWJJ77FiSe8xYFnKPHUtyjx1Lco8dS3KPHcsCSzOW5B47luQeO5bkHjOW0TfoRWHZsW+vRN+3NxRL7j19LDt+SRt9H9tQLLn32LGk52bHkp6bGcvoe+SGYom/7GK5Tds/r92W+Ygl/tKOJT03O5YFlmYsyT12LMk9dizJPXYsyT12LMk9Ziyj7wQciiW5x44luceOJbnHjmURZvnNlSzz852X13eepleaysnHnqZy9rGnqZx+7Gkq5x97msoJyJxm9F2Pg9FUTkFf0VznJ81tOqKpnIPsaSonIXuaBZqGNMlCljTJQpY0yUKWNMlCv6BZj2iShQxpRt/lORhNslAnzfaTLNtRsoy+K3QwmmQhS5oFmoY0yUKWNMlCljTJQpY0yUL/591vdaNvU3Xms0bfp+rOhwTyng+Z4j0fUsJ7PgU+b/nk2vb7eVPcmmzbb0/Fubb99lScyrV2VZzKh/ZUnGsjb1fFqbxiV8Wp3F9Xxan8XFfFRa5iOc+Va6NsV8VynivXdtauiuU8V65Np10Vy3muXFtDuyqW81y5NnB2VSznuXJts+yqWM5z5doM2VWxnOfKtWWxq2I5z5VrY2FXxXKeK9f2v66K5TxXrk16XRXLea5cW+m6KpbzXLk2vHVVLOe5cm1L66pYznPl2jzWVbGc58q1xaurYjnPVeQ8V5HzXKuc58q1562rYjnPtcp5rrXIVSznuXJtr+uqWM5z5doE11WxnOfKtVWtq2I5z5VrQ1lXxXKeK9e2r66K5TxXrs1ZXRXLea5cW6i6KpbzXLk2OnVVLOe5cm1H6qpYznPl2jTUVbGc58q1saerYjnPlWvzTVfFcp4r1waZrorlPFeuTSxdFct5rlwbTboqlvNcuTaDdFUs57lybdjoqljOc+XaVNFVsZznyrXxoatiOc+Va3NCV8VynivXBoKuiuU8V65J/l0Vq3muLde0/a6K1TzXlmsiflfFap5ruxW5itU81yY3h36Tm0O/yc2h3+Tm0G9yc+g3uTn0m9wc+k1uDv0mN4d+k5tDv8nNod9yzSj/cv9Vbc8rmT+8di2PdeFrWQ5Y5pp+7sxSee+hNUvlHYnWLJX3KVqzLLA0Y6m8cd2apfK+dWuWytvWrVkq71q3ZknuMWOZawPBiSzr443Xth6xJPfYsST32LEk99ixLLDsYrn/sNyOWJJ77FiSe+xYknvsWJJ77FiSe8xY5toCciLL9XEd63b0PWSu/SLOLMk9dizJPXYsCyzNWJJ77FiSe+xYknvsWJJ77FiSe8xY5trE48yS3GPHktxjx5LcY8eywNKMJbnHjiW5x44luceOJbnHjiW5x4xlrm1YzizJPXYsyT12LMk9diwLLM1YknvsWJJ77FiSe+xYknvsWJJ7zFjm2kjnzJLcY8eS3GPHktxjx7LA0owluceOJbnHjiW5x44luceMZfS9fmvdnheytfaBZdsf0wfavhxVHNwFnlBxcK92QsVFruLgvueEioO7k+8q/u4u0DOpM/oWQHc+wV2EO5/gHVFvPtH3EbrzSeUsT+CTyoeewCeVaz0v5R1f9QvLAkszlqmctjNLYQ9vzlLY75uzFM4G5iyFc4Qxyz36Ps6hWArnE3OWwlnGnCW5x45lgaUZS3KPHUtyjx1Lco8dS3KPHUtyjxnL6Dtxh2JJ7rFjSe6xY0nusWNZYGnGktxjx5LcY8eS3GPHktxjx5LcY8Yy+obwoViSe+xYknvsWJJ77FgWWJqxJPfYsST32LEk99ixJPfYsST3mLGMvj04CsuObet79O3BQ7Hk3tPH8vPkgT36ltahWHLvMWMZfUvrUCzpudmxpOdmxxJ/2cVymx7XsS3zEcsCSzOW9NzsWNJzs2NJ7rFjSe6xY0nuMWMZfUvrUCzJPXYsyT12LMk9diwLLM1YknvsWCrnni+upGzLo8ayvRCZp+mVpnLysaepnH3saSqnH3Oa0be1DkZTOQHZ01TOQPY0lVPQVzS39UlzL0c0CzQNaSonIXuaZCFLmmQhS5pkIUuaZCFDmtE3uIakWacjmmQhS5pkIUuaZKE+mvvtmSz36ShZRt/kOhhNspAlTbKQJU2ykCVNspAlTbKQIc1KFuqk+Vx7/K8Hho9okoUsaZKFLGmShSxpFmga0iQLWdIkC1nSJAv9n3fTTJQ3TXfxIa+85aO8abqLD5niPR9Swns++P73fEomPh27x/dcO567Kk7liLsqTuVauypO5UO7Kk7lLDsqrrk2BHdVnMr9dVWcys91VZzKoXVVXOQqVvNcNdcW2K6K1TxXzbVRtatiOc+VaztpV8VynivXps+uiuU8V66tmV0Vy3muXBsouyqW81y5tjl2VSznuXJtRuyqWM5z5doy2FWxnOfKtbGvq2I5z5Vr+11XxXKeK9cmua6K5TzXIue5FjnPtch5rly7BrsqLnIVy3muRc5z5drN2FWxnOfKteewp+Jc2wi7KpbzXLk2+3VVLOe5cm3J66pYznPl2jjXVbGc58q1va2rYjnPlWsTWlfFcp4r11axrorlPFeuDV1dFct5rlzbrroqlvNcubZGdVUs57lybV/qqljOc+XaYtRVsZznyrUNqKtiOc+Va6tOV8VynivXdpquiuU8V64tL10Vy3muXNtSuiqW81y5to50VSznuXJt7+iqWM5z5dqC0VWxnOfKtU2iq2I5z5VrK0NXxXKeK9d2g66K5TxXri0BXRXLea5cs/m7KpbzXLnm53dVLOe5cs2476pYznPJzaGvcnPoq9wc+io3h77KzaGvcnPom9wc+iY3h77JzaFvcnPo263IVazmuZrcHPomN4e+yc2hb3Jz6JvcHPomN4e+yc2hb3Jz6JvcHPomN4e+yc2hb3Jz6JvcHPomN4e+yc2hb3Jz6JvcHPomN4e+yc2hb3Jz6JvcHPomN4e+yc2hb3Jz6JvcHPomN4e+yc2hb3Jz6JvcHPomN4e+yc2hb3Jz6JvcHPqWa0b5/bpvz5fP7cO777U9r2T+8Nq1zP+8di3LEctUd3pnlqk8hDPLAkszlql8jzPLVI7KmWUqr+bMMpULdGaZqqfnyzLXNH9nluQeO5bknj6W9fHGa1uPWJJ77FgWWJqxJPfYsST39LHcf1huRyzJPXYsyT12LMk9ZixzbdRwZknusWNJ7uljuT6+h1y3o+8hc+0XcWZZYGnGktxjx5LcY8eS3GPHktxjx5LcY8Yy11YbZ5bkHjuW5B47luQeO5YFlmYsyT12LMk9dizJPXYsyT12LMk9ZixzbZZyZknusWNJ7rFjSe6xY1lgacaS3GPHktxjx5LcY8eS3GPHktxjxjLXdjdnluQeO5bkHjuW5B47lgWWZizJPXYsyT12LMk9dizJPXYsyT1GLNdbrg2LziyD+8tSfi5kLR8n2O2P6QNtX44qLnIVB/dqJ1Qc3FGdUHFw33NCxcHdyXcVf3cX+Dyp884nuOPw5hN9Z6A7n+AdUXc+wbuc7nxSOcsT+BT4vOWTyrWel/KOr/qFZSo/7MwyldN2Zins4c1ZCvt9a5bRd1sOxVI4R5izFM4c5iyF84k5ywJLM5bkHjuW5B47luQeO5bkHjuW5B4zltH3yw7Fktxjx5LcY8eS3GPHssDSjCW5x44luceOJbnHjiW5x44luceMZSH32LEk99ixJPfYsST32LEssDRjSe6xY0nusWNJ7rFjSe6xY0nuMWMZfUP4UCzJPXYs8URdLD9vW7+zxBPZseTe08eyY/JA9C2tQ7Hk3mPHkp6bHUt6bnYsCyzNWOIvu1hu02OS0bbMRyzxl3Ys6bnZsaTnZseS3GPGMvqW1qFYknvsWJJ77FiSe+xYFliasST32LEk99ixJPfYsVTOPV9cSd2nR411n19qnKZXmsrJx5xm9E2tg9FUTj/2NJXzjz1N5QRkT7NA05Cmcgr6imZZnzTXckRTOQfZ01ROQvY0yUKWNMlChjSjb28djCZZyJImWeh7mtt0RJMsZEmzQNOQJlmok2b9SZbtKFlG3+Q6GE2ykCVNspAlTbKQHc0p+kbXwWiShSxpkoX6aNb56TfrUo5okoUsaRZoGtIkC1nSJAtZ0iQLWdIkC1nSJAt9T7McdOQm5b3UJ9AkC1nSJAv95Upe+JBu3vMp8HnLhwTyng+Z4j0fUsJ7Pvj+93xSOflWH5NgWjuYBDPl2vTcVXEqR9xVcSrX2lVxKh/aVXGRqziVV+yqOJX766o4lZ/rqjiVQ+uqWM5z5doy21WxnOfKtbG1q2I5z5Vr+2lXxXKeK9cm0a6K5TxXrq2cXRXLea5cGy67KpbzXLm2RXZVLOe5cm1e7KpYznPl2mLYVbGc58q1EbCrYjnPlWu7XlfFcp5rlfNcq5znWotcxXKeK9eWxK6K5TzXKue5cu2r7Kk411bJrorlPFeuDY1dFct5rlzbDrsqlvNcuTYHdlUs57lybeHrqljOc+XaaNdVsZznyrUdrqtiOc+Va9NaV8VynivX1rKuiuU8V64NYF0Vy3muXJu0uiqW81y5NlJ1VSznuXJtduqqWM5z5dqQ1FWxnOfKtWmoq2I5z5VrY09XxXKeK9fmm66K5TxXrg0yXRXLea5cm1i6KpbzXLk2mnRVrOa55lybQboqVvNcc64NG10Vq3mu+VbkKlbzXHOujQ9dFat5rjnX5oSuiuU8V64NBF0Vy3muXJP8uyqW81y5pu13VSznuXJNxO+qWM5z5Zpa31WxnOeSm0M/y82hn+Xm0M9yc+hnuTn0s9wc+lluDv0sN4d+lptDP8vNoZ/l5tDPcnPoZ7k59LPcHPpZbg79LDeHfpabQz/LzaGf5ebQz3Jz6Ge5OfSz3Bz6WW4O/Sw3h36Wm0M/y82hn+Xm0M9yc+hnuTn0s9wc+lluDv0sN4d+lptDP8vNoZ/l5tDPcnPoZ7k59LPcHPpZbg79LDeHfpabQz/LzaGf5ebQz3Jz6OdcM8rv1317vnxuH959r+15JfOH165l/ue1a1mOWKa60zuzTOUhnFmmcie+LHPNgndmmcpRObNM5dWcWaZygc4sCyzNWKbqFjqzJPfYsST39LGsjzde23rEktxjx5LcY8Yy1z4GZ5bknj6W+w/L7YgluceOJbnHjmWBpRlLco8dS3KPHUtyTx/L9fE95LodfQ+Za7+IM0tyjxnLXDtRnFmSe+xYknvsWJJ77FgWWJqxJPfYsST32LEk99ixJPfYsST3WLFccu0lcmZJ7rFjSe6xY0nusWNZYGnGktxjx5LcY8eS3GPHktxjx5LcY8Yy124wZ5bkHjuW5B47luQeO5YFlmYsyT12LMk9dizJPXYsyT12LMk9Zixz7edzZknusWNJ7rFjSe6xY1lgacaS3GPHMri/nPblB87+cYLd/pg+0PblqOLgLtC+4uh7/U6oOLijOqHi4L7nhIqDu5PvKv7uLtAxqXOJvgXQnU9wF+HOJ3hH1J1P8C6nO59UzvIEPql8qD2f6JsRz+TzTco7vuoXlqn8sDPLVE7bmaWwhzdnWWBpxlI4G5izFM4R5iyFM4c5S+F8Ys5SOMtYs4y+nXQoluQeO5bkHjuW5B47lgWWZizJPXYsyT12LMk9dizJPXYsyT1mLKNvCB6KJbnHjiW5x44luceOZYGlGUtyjx1Lco8dS3KPHUtyjx1Lco8Zy+gbwodiSe6xY0nusWOJJ+pi2bE9eIm+PXgkltG3tIZh2fFL2uhbWodiyb3HjiU9NzuWBZZmLOm52bHEX3ax3Kbtn9duy3zEEn9px5Kemx1Lem5mLKNvaR2KJbnHjiW5x44luceOZYGlGUtyjx1Lco8dS3KPHUtyjx1L5dzzzZXM+5PIXG8/r573H5ol+p7WwWgqZx97msrpx56mcv6xp1mgaUhTOQPZ01ROQV/RLPWH5vQHzf98dVsePrZtL1dR29+u4vkd3d7Kz2uXV5GU49UwIinntmFEIhDGFyn6XlxE+pdIxNcBRCIVDyASYXsAkQoixReJ1sAAItFxGEAkOg59V7LcyuOdl9dX/9Fki76IeTCaZHhDmtGXMQ9Gk1RsSZP4akmTnGlJs0Czj+ayPWmW9Ygmyc2SJhHLkiZZyJImWciSJlnIkGauZefuNMlC39N8rfFPmmQhS5pkIUuaBZpvRrgV5XXxXXzIK+/5kEDe8yFTvOdDSnjLR3pdfA+fVE6+1cfX363tRxWncttdFadyxF0VF7mKU/nQropTOcuuilN5xa6KU7m/ropT+bmeinMttu6qWM5z5VoS3VWxnOfKtXC5q2I5z5VreXFXxXKeK9ci4K6K5TxXrqW6XRXLea5cC2q7KpbzXLmWvXZVLOe5ci1O7apYznPlWkLaVbGc58q10LOrYjnPlWs5ZlfFcp5rL3IVy3muXItZuyqW81y7nOfa5TxXrkW2XRXLea5cS2G7KpbzXLkWrHZVLOe5ci0r7apYznPlWvzZVbGc58q1RLOrYjnPlWshZVfFcp4r13LHrorlPFeuRYldFct5rlxLB7sqVvNca671fV0Vq3muNdcavK6K1TzXeityFat5rjXXWrauitU815prYVhXxXKeK9cqq66K5TxXriVLXRXLea5c63+6KpbzXLkW03RVLOe5cm1i6apYznPl2mjSVbGc58q1GaSrYjnPlWvDRlfFcp4r16aKrorlPFeujQ9dFct5rlybE7oqlvNcuTYQdFUs57lyTfLvqljOc+Watt9VsZznyjURv6tiOc+Va2p9V8VynktuDv0qN4d+lZtDv8rNoV/l5tCvcnPoV7k59KvcHPpVbg79KjeHfpWbQ7/mmlH+5f6r2p5XMn947d2O//Pau009Yqm8y9CapfLeQ2uWyjsSrVkq71M0ZplryrwzS+WN69YslfetW7NU3rZuzbLA0owluceOJbmnj2V9vPHa1iOW5B47luQeO5bkHjOWuTY9nMhy/2G5HbEk99ixJPfYsST32LEssDRjSe6xY0nu6WO5Pr6HvMebI5bkHjuW5B47luQeM5a5tq04syT32LEk99ixJPfYsSywNGNJ7rFjSe6xY0nusWNJ7rFjSe4xY5lr45EzS3KPHUtyjx1Lco8dywJLM5bkHjuW5B47luQeO5bkHjuW5B4rlluurWPOLMk9dizJPXYsyT12LAsszViSe+xYknvsWJJ77FiSe+xYknvMWOba/OfMktxjx5LcY8eS3GPHssDSjGVwf3mb1+eF3Or2gWXH9IEt+l6/EyoO7tXsK46+1++EioP7nhMqDu5OTqg4uIc4oeLgd/oTKg7ehzyh4uDdwhMqlvNc0ff6fVnx55ktW/S9fvYVR9/rd0LFuTxXT8W5PNfnmQ1b9L1+J1Rc5CrO5bl6Ks7luXoqzuW5eirO5bk6epnR9/rZVxx9r98JFefyXD0V5/JcPRXn8lw9FRe5inN5rp6Kc3munopzea6eiuU8V/S9fvYVR9/rd0LFcp4r+l6/EyqW81xrkatYznNF37B4QsVyniv6tsITKpbzXNE3/51QsZznir5F74SK5TxX9I10J1Qs57mib3c7oWI5zxV9U9oJFct5ruhbx06oWM5zRd/gdULFcp4r+jasEyqW81zRN0udUHHo+3Gr6+PF7f6/P9Tb9scT9G0/eoI+9i6cE+oNfS8+od7Qd+IT6g19Hz6h3tB34e/qnb76xXqr9fnWR6d57G0r7nRC393d6YTuvrjTCd2pcaeTyEXa04m9h8SdTiKHOp02g+b4ml9IJvK+ziQTuWpnkgWSRiRlvb05SdkcYE5SNjOYk5TNF+YkZbOIMck99h6RoUiScaxIknGsSJJxrEgWSBqRJONYkSTjWJEk41iRJONYkSTjGJGMvTNkKJJkHCuSZBwrkmQcK5IFkkYkyThWJMk4ViTJOFYkyThWJMk4RiRjb/EZiiQZx4okLqiDZMdOkD323pehSHLH6SH5+VeFe+wdJkOR5I5jRZKumhVJumpWJAskjUjiJztIbtP2z2u3ZT4iiZ+0IklXzYokXTUrkmQcI5KxdwYNRZKMY0WSjGNFkoxjRbJA0ogkGceKJBnHiiQZx4okGceKJBnHiGTsHV1DkSTjWJEk41iR1M04X1zH3NbyqPB1LuXUym+5F7i7cNfNT77cddOWL3fdbGbE/YWlbjqzZ6mbz8xZxt7oNxhL3Yxmz1I3pdmzJKfZsSywNGNJnrJjSUayY0nu6biO5bY8lkktt3r7g+Xv8mbsbZaJuZOnzLlb/94x9hZQNPq3RuS/+BqRK+NrRF6Nr1FBo/Aaka/ja0Ruj68R/YD4GtE7iK8RfYbwGmXab55WI/oM8TWizxBfI/oM8TUqaBReI/oM8TWizxBfI/oM8TWizxBfI/oM4TVq9Bnia0SfIb5G9Bnia0SfIb5G5CNXjXrm6zfyUXSN6g1f56vR51nX9Yavi68Rvi6+Rvi6+BoVNAqvEd8fxdeIfOSqUcfv+OqNfBRfI74/iq8R3x+F12iizxBfI/oM8TWizxBfI/oM8TUqaBReI/oM8TWizxBfI/oM8TWizxBfI/oM9hp98c7TtD1ePE379vPqdntRaabTMIJK9BpGUIluwwgq0W8YQaWCSgOoRM9hBJXoOlyo0gt3Ogk+3OkO9HCfbo8Ho5bppcJfT9quM4nfhftChjfnbvwLrLqQ4ONrRH6PrxHpPb5GBY3Ca0Ryj68RuT2+RmT8+BrRD4ivEb2D8BoV+gzxNaLPEF8j+gzxNaLPEF+jgkbhNaLPEF8j+gzxNaLPEF8j+gzxNaLPEF6jlT5DfI3oM8TXiD5DfI3oM8TXqKBReI3oM8TXiD5DfI3oM8TXiD5DfI3oM4TXaKPPEF8j+gzxNaLPEF8j+gzxNSpoFF4j+gzxNaLPEF8j+gzxNaLPEF8j+gzhNdrpM8TXiHzkqlHP9tW9oFF4jfB1vhp1bLvb8XXxNcLXhdeo4uvia8T3R/E14vuj+BqRj1w16pkDWQsahdeI74/ia8T3R/E1os8QXyP6DPE1os8QXqNGnyG+RvQZ4mtEnyG+RvQZ4mtU0Ci8RvQZ4mtEn8Feoy/eeSrPCqfysnlqnrbfKkpXIpui9DCyKUrHI5ei7UZ/JKyiLyrRIRlBJXokI6hEl2QElQoqDaASnZIRVKJXMoJK9D9GUImehq9K6/pgN63b9odKf3n1XY3Hq6elHGVguhrpNJ3oawyk6Tw/QZf1SFF6INkUpV+STVF6K9kULSiaTFF6NtkUpb+TTVF6QSMpuq4P0Pt0pCh9o2yK0jXyVXRbHiOVpu31JP0vukYzXaN8mtI3GkjTHnc00zfKpih9o2yKFhRNpih9o2yK0jfKpih9o2yK0jcaSdGOvtFM3yiZogtdI19F9+c734ua/teia7TQNcqnKX2jgTTtcUcLfaNsihYUTaYofaNsitI3yqYofaNsitI3yqYofaORFO3oGxX6RtkUpWvk3Nvd24+i8wdF9/3RNNrr9nIVfyhKzyibovSMsilaUNT3Pro+u+/76xa0/6JXX+ga5dOUvtFAmvZk0kLfKJui9I2yKUrfKJmiK32jbIrSN8qmKH2jbIrSNxpJ0Y5u/VpQNJmidI3iKLr/+Wz9i0r0gUZQid7OCCrRr/FVqd4et6WpTvV/LfrkKx2bdJpu9GwG0rQnD270bLIpSs8mm6L0bLIpWlA0maL0bLIpSn8nm6L0gkZStKNTvtE3yqYoXaNkiu70jLIpSs8om6L0jLIpSs8om6IFRZMpSs8ojqLzn9t0XlSiDzSCSvR2RlCJfs2FKr1wp6viwr3S++jiXh88lnnePnDvcVaVDoUPd/oI5tz32p7vPP/6Kl40ojMQX6OCRuE1Ir3H14jsHl8jknt8jcjt8TUi44fXqNEPiK8RvYP4GtFniK8RfYb4GhU0Cq8RfYb4GtFniK8RfYb4GtFniK8RfYbgGm33qtAovEb0GeJrRJ8hvkb0GeJrVNAovEb0GeJrRJ8hvkb0GeJrRJ8hvkb0GcJrNNFniK8R+chVo7XM/7x2LYcaFTQKrxG+zlej9fHjvPV1y8afGuHr4muErwuv0Yyvi68R3x/F14jvj+JrRD5y1Wibtn9euy3zkUYFjcJrxPdH8TXi+6P4GtFniK8RfYb4GtFnCK/RQp8hvkb0GeJrRJ8hvkb0GeJrVNAovEb0Gew1+uKdp1t9vHi6X//Pq+fbq0p0GkZQiV7DCCrRbRhBJfoNA6hU6DiMoBI9hxFUouvgrNLz8Ya7StMfKv3tncs/L97r61W8ZqtCjyKbogVFkylK/8NX0Wn+uTeWw3sj/Y8RVKL/MYJK9D9GUIn+xwAqrfQ/RlCJ/scIKtH/CKRSPVKJnsYIKhVUGkAleg8XqvTCnW6CD3f6Az3c5/WH+1Y+cO95xmsl8ftwJ8Obc5/nJ46yHnDfSOU+3MnZPtxJzj7cycI+3AvcXbiTV+25r+sDxz4dcSev+nAnr/pwJ6/6cCevunDfyas+3MmrXdzbY5zvstxWg77YTl714U5eNefek5v2AncX7uRVH+7kVR/u5FUf7uRVH+7kVXvuHbmpkld9uJNXfbiTV324k1d9uBe4u3Anr/pwJ6/2cF+W9cm9Th+4T+sDx7SWI+7kVR/u5FVz7tZ7RivZNrxGjRwcXyMyc3yNyNfxNSKLx9eooFF4jcj48TWiHxBfI3oH8TWizxBfI/oM0TW6l4VG4TWizxBfI/oM8TWizxBfo4JG4TWizxBfI/oM8TWizxBfI/oM8TWizxBeo4k+Q3yN6DPE14g+Q3yN6DPE16igUXiN6DPE14g+Q3yN6DPE14g+Q3yN6DOE12imzxBfI/KRq0ZrefzIdS2HGhU0Cq8Rvs5Xo+fC8HXbjzTC18XXCF8XXqMFXxdfI74/iq8R3x/F14h85KpRx7zraSloFF4jvj+KrxHfH8XXiD5DfI3oM8TXiD5DeI0KfYb4GtFniK8RfYb4GtFniK9RQaPwGtFniK8RfYb4GtFniK8RfYb4GtFnCK/RSp8hvkb0Gew1+uKdp/p88VTb9sKu/VZRuhLZFKWHkU3RgqLJFKU/ElbRF5XokIygEj2SEVSiSzKCSvRJBlBpo1Mygkr0SkZQif7HCCrR0xhBpYJKA6hE78FXpVYeP3ibWlv+UOkvpD9vVJ82+hTZFKWnMZCi1tOANnolyurTgxFWf6e3o6w+PSNl9elFKatPj0tZ/YL6wurTk1NWn/6dsvr0+pTVp9enrD69PmH1K70+ZfXp9SmrT69PWX16fcrqF9QXVp9en7L69PqU1afXp6w+vT5l9en1Cavf6PUpq0+vT1n9gvo51e/ZSdvI+8rq4/mzqt+xt7Dh+XXVn294fmX18fzK6vP9vrL6fL+vrH5B/Zzqd8z2nW/kfWX1+X5fWX2+31dWn16fsvr0+oTVn+j1KatPr09ZfXp9yurT61NWv6C+sPr0+pTVp9enrD69vpHU/+adp+3x4mnaX/YotNur/nT7tPWn3yet/0zHT1t/en7a+tP109afvp+2/gX9M+j/oijdvGyK0qFzVXS+zY8Xz7d9/qBox2a8eabrlk1R+mgDKWo8G2Ge6aIJq7/QQ1NWnw6asvr0z5TVp3umrH5BfWH16bMpq09PTll9+nfK6tPrU1afXp+w+oVen7L69PqU1afXp6w+vT5l9QvqC6tPr09ZfXp9yurT61NWn16fsvr0+oTVX+n1KatPr09ZfXp9yuqT95Oq37Htbl7J+8rq4/mzqt+x9WbD8yurj+dXVh/Pr6w+3+8rq19QX1h98n5S9XtmIG/kfWX1+X5fWX2+31dWn16fsPo7vT5l9en1KatPr09ZfXp9yuoX1BdWn16fsvr0+pTVp9c3kvpfvHPftoudbp+2/vT7pPWvdPy09afnp60/XT9t/en7aetf0D+D/i+K0s3LpigdOmdF26ORNk9T+aDodFfjee4u5UhT+m75NKWXNpCmZXp00sty+/DOr6+tR+rTSRNWv9FHS6r+PD9FKeuR+nTRlNWnh6asPh00ZfUL6gurT69NWX36clnVXx+XPO/Tkfp08JTVp9enrD69Pl31lxu9PmX16fUpq0+vT1l9en2Dql+PFC0omkxRenLZFKXPlk1RemfZFKUflk1RelzJFJ3oW2VTlF5UNkXpL2VTlJ6Rr6LTz++xpvLp91hdv/RYpoKm6TSlb5RPUzpH+TSld5RPU7pH+TSlf5RO05kOUj5N6SHl05QuUj5N6SPl07SgaTpN6SPl05Q+Uj5N6SPl05Q+Uj5N6SOl03Shj5RPU/pI+TSlj5RPU/pI+TQtaJpOU/pI+TSlj5RPU/pI+TSlj5RPU/pI6TQt9JHyaUofKZ+m9JHyaUofKZ+mBU3TaUofKZ+m9JHyaUofKZ+m9JHyaUofKZ2mK32kfJrSR8qnKX2kfJrSR8qnaUHTdJrSR8qnKX2kfJrSR8qnKX2kfJrSR0qn6UYfKZ+m9JHyaUofKZ+m9JHyaVrQNJ2m9JHyaUofKZ+m9JHyaUofKZ+m9JHSabrTR8qnKX2kfJrSR8qnKX2kfJoWNE2nKX2kfJrSR8qnKX2kfJrSR8qnKX2kdJpW+kj5NKWPlE9T+kj5NKWPlE/TgqbpNKWPlE9T+kj5NKWPlE9T+kj5NKWPlE7TRh8pn6b0kfJpSh8pn6b0kfJpWtA0nab0kfJpSh8pn6b0kfJpSh8pn6b0kbJpWm70kfJpSh8pn6b0kfJpSh8pn6YFTdNpSh8pn6b0kfJpSh8pn6b0kfJpSh8pnaYTfaR8mtJHyqcpfaR8mtJHyqdpQdN0mtJHyqcpfaR8mtJHyqcpfaR8mtJHSqfpTB8pn6b0kfJpSh8pn6b0kfJpWtA0nab0kfJpSh8pn6b0kfJpSh8pn6b0kdJputBHyqcpfaR8mtJHyqcpfaR8mhY0TacpfaR8mtJHyqcpfaR8mtJHyqcpfaR0mhb6SPk0pY+UT1P6SPk0pY+UT9OCpuk0pY+UT1P6SPk0pY+UT1P6SPk0pY+UTtOVPlI+Tekj5dOUPlI+Tekj5dO0oGk6Tekj5dOUPlI+Tekj5dOUPlI+TekjpdN0o4+UT1P6SPk0pY+UT1P6SPk0LWiaTlP6SPk0pY+UT1P6SPk0pY90oaYv3On1uHDf6cf4cKdn4sOdvoYPd3oPPtwL3F24k+F7uJd5fnAvS/vAvc/B7yRtL/LkYXPy95c8XryWD++8Tds/r92W+Ugj8m18jcjC4TWq5GZXjeb5ia6sRxqRseNrRB6PrxHZPb5GBY3Ca0RPIL5GdA/ia0SfwVej9dEsnffpSCP6DPE1os8QXqNGnyG+RvQZ4mtEnyG+RvQZztRoO+Re4O7CnX6AD3cyvg93crsPd7J4F/e9Prm39QP3vidiGgnbh/x6Izebkzd+hmK9kZvja0RudtWo4/uQ9UZujq9RQaPwGpHH42tEdo+vETk/vkb0BHw1+vx9yHqjexBeo4k+Q3yN6DPE14g+Q3yN6DPE16igUXiN6DOcqdF2yJ3egQ93+gE+3Mn4PtzJ7S7cZ7K4D3fytQ93MrMPd3KwD/cCdxfu5NUe7uvzcaplXT7NEOx7inEmsXqRJ7N6kSe1epEntzqRX0iuXuTJrl7kSa9e5MmvXuQL5J3Ik2G9yJNhvciTYb3Ik2G9yJNhncgXMqwXeTKsF3kyrBd5MqwX+QJ5J/JkWC/yZFgv8mRYL/JkWC/yZFgn8isZ1os8GdaLPBnWizwZ1ot8gbwTeTKsF3kyrBd5MqwXeTKsF3kyrBP5jQzrRZ4M60WeDOtFngzrRb5A3ok8GdaLPBnWizwZ1os8GdaLPBnWifxOhvUiT4b1Ik+G9SJPhvUiXyDvRJ4M60WeDOtFngzrRZ4M60WeDOtEvpJhvciTYb3Ik2G9yJNhvcgXyDuRJ8N6kSfDepEnw3qRJ8N6kSfDOpFvZFgv8mRYL/JkWC/yZFgv8gXyTuTJsF7kybBe5MmwXuTJsF7kybA+5LcbGdaLPBnWizwZ1os8GdaLfIG8E3kyrBd5MqwXeTKsF3kyrBd5MqwT+YkM60WeDOtFngzrRZ4M60W+QN6JPBnWizwZ1os8GdaLPBnWizwZ1on8TIb1Ik+G9SJPhvUiT4b1Il8g70SeDOtFngzrRZ4M60WeDOtFngzrRH4hw3qRJ8N6kSfDepEnw3qRL5B3Ik+G9SJPhvUiT4b1Ik+G9SJPhnUiX8iwXuTJsF7kybBe5MmwXuQL5J3Ik2G9yJNhvciTYb3Ik2G9yJNhncivZFgv8mRYL/JkWC/yZFgv8gXyTuTJsF7kybBe5MmwXuTJsF7kybBO5DcyrBd5MqwXeTKsF3kyrBf5Ankn8mRYL/JkWC/yZFgv8mRYL/Jk2P+4jh86OznzHR2y4Ds65LV3dMhU7+gU6LyhQzZ5R4f88I4OHv8dHXz4Ozp45Td0Kl75HZ1EXrnV+nzxflRvIvfbVW8iP9tVbxGrN5Hn7Ko3kYvsqjeRL+yqN5HT66o3kXfrqbclcmNd9Yr5qybmr5qYv2pFrF4xf9XE/FUT81dNzF81LX+137T81X7T8lf7Tctf7Tctf7Xfili9Wv5qv2n5q/2m5a/2m5a/2m9i/moS81eTmL/KtKG+q14xf5VpG3tXvWL+KtPm8a56xfxVpi3bXfWK+atMG6W76hXzV5m2J3fVK+avMm0K7qpXzF9l2orbVa+Yv8q0AbarXjF/lWnbaVe9Yv4q02bPrnrF/FWmLZZd9Yr5q0wbG7vqFfNXmbYTdtUr5q8ybeLrqlfMX2XaOtdVr5i/yrRhrateMX+VaZtYV71i/irT5qyuesX8VaYtUV31ivmrTBuRuuoV81eZtv901SvmrzJtuumqV8xfZdrq0lWvmL/KtMGkq14xf5VpW0dXvWL+KtNmiq56xfxVpi0MXfWK+atMGwe66hXzV5km93fVK+avMk3X76pXzF9lmoDfVa+Yv8o0pb6rXjF/lWmSfFe9Yv4q07T3rnrF/JXY/PZdbH77Lja/fReb376LzW/fxea372Lz23ex+e272Pz2XWx++y42v30Xm9++i81v38Xmt+9i89t3sfntu9j89l1sfnsVm99exea3V7H57VVsfnu9FbF6tfxVFZvfXsXmt1ex+e1VbH57FZvfXsXmt1ex+e1VbH57FZvfXsXmt1ex+e1VbH57FZvfXsXmt1ex+e1VbH57FZvfXsXmt1ex+e1VbH57FZvfXsXmt1ex+e1VbH57FZvfXsXmt1ex+e1VbH57FZvfXsXmt1ex+e1VbH57FZvfXsXmt1ex+e1VbH57FZvfXsXmt1ex+e1VbH57FZvfXsXmt1ex+e1VbH57FZvfXsXmt1ex+e1VbH57FZvfXsXmt1ex+e1VbH57FZvfXsXmt1ex+e1VbH57FZvfXsXmt1ex+e1VbH57FZvfXsXmt1ex+e1VbH57FZvfXsXmt1ex+e1VbH57FZvfXsXmt1ex+e1VbH57FZvfXsXmt1ex+e1VbH57FZvfXsXmt1ex+e1VbH57FZvfXsXmt1ex+e1VbH57FZvfXsXmt1ex+e1VbH57FZvfXsXmt1ex+e1VbH57FZvfXsXmtzex+e1NbH57E5vf3sTmt7dbEatXy181sfntTWx+exOb397E5rc3sfntTWx+exOb397E5rc3sfntTWx+exOb397E5rc3sfntTWx+exOb397E5rc3sfntTWx+exOb397E5rc3sfntTWx+exOb397E5rc3sfntTWx+exOb397E5rc3sfntTWx+exOb397E5rc3sfntTWx+exOb397E5rc3sfntTWx+exOb397E5rc3sfntTWx+exOb397E5rc3sfntTWx+exOb397E5rc3sfntTWx+exOb397E5rc3sfntTWx+exOb397E5rc3sfntTWx+exOb397E5rc3sfntTWx+exOb397E5rc3sfntTWx+exOb397E5rc3sfntTWx+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7ZvZ/vbNbH/7Zra/fTPb376Z7W/fzPa3b2b72zez/e2b2f72zWx/+2a2v30z29++me1v38z2t29m+9s3s/3tm9n+9s1sf/tmtr99M9vfvpntb9/M9rdvZvvbN7P97ZvZ/vbNbH/7Zra/fTPb376Z7W/fzPa3b2b723ez/e272f723Wx/+262v32/NTO9XvlqN9vfvpvtb9/N9rfvZvvbd7P97bvZ/vbdbH/7bra/fTfb376b7W/fzfa372b723ez/e272f723Wx/+262v30329++m+1v3832t+9m+9t3s/3tu9n+9t1sf/tutr99N9vfvpvtb9/N9rfvZvvbd7P97bvZ/vbdbH/7bra/fTfb376b7W/fzfa372b723ez/e272f723Wx/+262v30329++m+1v3832t+9m+9t3s/3tu9n+9t1sf/tutr99N9vfvpvtb9/N9rfvZvvbd7P97bvZ/vbdbH/7bra/fTfb376b7W/fzfa372b723ez/e272f723Wx/+262v30329++m+1v3832t+9m+9t3s/3tu9n+9t1sf/tutr99N9vfvpvtb9/N9rfvZvvbd7P97bvZ/vbdbH/7bra/fTfb376b7W/fzfa372b723ez/e272f723Wx/+262v30329++m+1v3832t+9m+9t3s/3tu9f+9vXmtb/9rtcqX931WuWru16rfHXX28z0WuWru16rfHXXa5Wv7nqt8tVdr1m+8trfftdrlq+89rff9ZrlK6/97Xe9ZvnKa3/7Xa9ZvvLa337Xa5avvPa33/Wa5Suv/e13vWb5ymt/+12vWb7y2t9+12uWr7z2t9/1muUrr/3td71m+cprf/tdr1m+8trfftdrlq+89rff9ZrlK6/97Xe9ZvnKa3/7Xa9ZvvLa337Xa5avvPa33/Wa5Suv/e13vWb5ymt/+12vWb7y2t9+12uWr7z2t9/1muUrr/3td71m+cprf/tdr1m+8trfftdrlq+89rff9ZrlK6/97Xe9ZvnKa3/7Xa9ZvvLa337Xa5avvPa33/Wa5Suv/e13vWb5ymt/+12vWb7y2t9+12uWr7z2t9/1muUrr/3td71m+cprf/tdr1m+8trfftdrlq+89rff9ZrlK6/97Xe9ZvnKa3/7Xa9ZvvLa337Xa5avvPa33/Wa5Suv/e13vWb5ymt/+12vWb7y2t9+1+uVrwaz/e2D2f72wWx/+2C2v/2uxkyvV74azPa3D2b72wez/e2D2f72wWx/+2C2v30w298+mO1vH8z2tw9m+9sHs/3tg9n+9sFsf/tgtr99MNvfPpjtbx/M9rcPZvvbB7P97YPZ/vbBbH/7YLa/fTDb3z6Y7W8fzPa3D2b72wez/e2D2f72wWx/+2C2v30w298+mO1vH8z2tw9m+9sHs/3tg9n+9sFsf/tgtr99MNvfPpjtbx/M9rcPZvvbB7P97YPZ/vbBbH/7YLa/fTDb3z6Y7W8fzPa3D2b72wez/e2D2f72wWx/+2C2v30w298+mO1vH8z2tw9m+9sHs/3tg9n+9sFsf/tgtr99MNvfPpjtbx/M9rcPZvvbB7P97YPZ/vbBbH/7YLa/fTDb3z6Y7W8fzPa3D2b72wez/e2D2f72wWx/+2C2v30w298+mO1vH8z2tw9m+9sHs/3tQ6X93vd3fXu+63H/8LO/eR/TNM1/XjxN2/DzPvb2X/7k8TY+Xjze1ld2+z/95G1//uTxw0+e2/jntXObjtwvlEZw/2v3C2Uz3P/a/Yb7xu4Xyu24/7X7hVoM7n/tfqFOh/tfu1+o4eL+1+4X+n0K7n/p/ljpugruf+0+sz5n95n1VXV/e8CY9/nIfWZ9zu433Dd2n1mfs/vM+qq6v/64vxy5z6zP2X1mfc7uM+szdr/SpT/c/9p9Zn3O7jPrq+r+/Pib3nlZj9xn1ufsfsN9Y/eZ9Tm7z6zP2X1mfc7uM+tzdp9Zn7H7la5O4/7X7jPrc3afWZ+z+8z6nN1vuG/sPrM+Z/eZ9Tm7z6zP2X1mfc7uM+szdn9i1ufsPrM+Z/eZ9Tm7z6zP2f2G+8buM+tzdp9Zn7P7zPqc3WfW5+w+sz5j9xuzPmf3mfU5u8+sz9l9Zn3O7jfcN3afWZ+z+8z6nN1n1ufsPrM+Z/eZ9Rm7PzPrc3afvt/V/ftPeJg07PukdD9wm2NuuG/sPn3f2X36vrP79H1n9+n7zu7T943dX+j7zu7ztz3O7vO3Pc7uM+tzdr/hflH3A9cYF2Z9zu4z63N2n1mfs/vM+qq6H7jItjDrM3Z/Zdbn7D6zPmf3mfU5u8+sz9n9hvtF3Q/8Te/KrM/ZfWZ9zu4z63N2n1mfs/vM+ozd35j1ObvPrM/ZfWZ9zu4z63N2v+G+sfvM+pzdZ9bn7D6zPmf3mfU5u8+sz9j9nVmfs/vM+pzdZ9bn7D6zPmf3G+4bu8+sz9l9Zn3O7jPrc3afWZ+z+8z6fN2fbsz6nN1n1ufsPrM+Z/eZ9Tm733Df2H1mfc7uM+tzdp9Zn7P7zPqc3WfWZ+z+wKzP2X1mfc7uM+tzdp++r3dfe0FjGmjl+T2iO+f3iIab3yN6aHqPRtpifo/odPk9onnl94i/hcjvUcOj9B4xZ8jvEXOGvh59vqo2jcwZ8nvEnCG/R8wZ0ns0MWfo69Hniz/TxJwhv0fMGfJ7xJwhv0cNj9J7xJwhv0fMGfp6FPi7oIk5Q36PmDPk94g5Q3qPGnOG/B4xZ8jvEXOG/B4xZ8jvUcOj9B4xZ8jvEXOG/B4xZ8jvEXOG/B4xZ0jv0cycIb9HzBnye8ScIb9HzBnye9TwKL1HzBnye8ScIb9HzBnye8ScIb9HzBnSe7QwZ8jvEXOG/B4xZ8jvEXOG/B41PErvEXOG/B4xZ8jvEXOG/B4xZ8jvEXOG9B6tzBnye8ScIb9HzBnye8ScIb9HDY/Se0Q/ing0bA8e0zguSo8CeyBX+lF+j+hH6T3a6Ef5PaIf5feIfpTfI/pRfo8aHqX3iN/D5veI38Pm94g5Q36PmDP09Siwg31jzpDeo505Q36PmDPk94g5Q1+PArujd+YM+T1qeJTeI+YM+T1izpDfI+YM+T1iztDXo8DfBe3MGbJ71G7MGfJ7xJwhv0fMGfJ7xJwhv0cNj9J7xJwhv0fMGfJ7xJwhv0fMGfJ7xJwhvUcDc4b8HjFnyO8Rc4b8HjFnyO9Rw6P0HjFnyO8Rc4b8HjFnyO8Rc4b8HjFnSO/RyJwhv0fMGfJ7xJwhv0fMGfJ71PAovUfMGfJ7xJwhv0fMGfJ7xJwhv0fMGdJ7NDFnyO8Rc4b8HjFnyO8Rc4b8HjU8Su8Rc4b8HjFnyO8R/Sjk0e2BchpeFP7KHsjW6Ef5PaIf5feIfpTfI/pRfo8aHqX3iH6U3yP6UX6P+D1sfo/4PWx+j5gzpPdoZs7Q16PPO9jbzJwhv0fMGfJ7xJwhv0cNj7p69Hl3dJuZM+T3iDlDfo+YM+T3iDlDfo+YM6T3aGHO0NejwN8FLcwZ8nvEnCG/R8wZ8nvU8Ci9R8wZ8nvEnCG/R8wZ8nvEnCG/R8wZ0nu0MmfI7xFzhvweMWfI7xFzhvweNTxK7xFzhvweMWfI7xFzhvweMWfI7xFzhvQebcwZ8nvEnCG/R8wZ8nvEnCG/Rw2P0nvEnCG/R8wZ8nvEnCG/R8wZ8nvEnCG9RztzhvweMWfI7xFzhvweMWfI71HDo/QeMWfI7xFzhvweMWfI7xFzhuwezTf6UcSj2zQ/PLptN6VHn/dAzjf6UX6P6Ef5PWp4lN4j+lF+j+hH+T2iH+X3iH6U3yN+D5veo4Hfw+b3iDlDfo+YM/T16PMO9nlgzpDfo4ZH6T1izpDfI+YMfT36vDt6Hpgz5PeIOUN+j5gzpPdoZM6Q3yPmDPk9Ys7Q16PA3wWNzBnye9TwKL1HzBnye8ScIb9HzBnye8ScIb9HzBnSezQxZ8jvEXOG/B4xZ8jvEXOG/B41PErvEXOG/B4xZ8jvEXOG/B4xZ8jvEXOG9B415gz5PWLOkN8j5gz5PWLOkN+jhkfpPWLOkN8j5gz5PWLOkN8j5gz5PWLOkN6jmTlDfo+YM+T3iDlDfo+YM+T3qOFReo+YM+T3iDlDfo+YM+T3iDlDfo+YM6T3aGHOkN8j334k3ta4NEiKSPp2DTVJ30agJumb29UkfdO1mqRvBhaTXH2Tqpqk7++t1CR9f7ukJknHUZFskNTsUl7pOCqSdBwVSTqOiiQdJ0IysJt0peOISG50HBVJOo6KJB1HRZKOoyLZIKn53eJGx1GRpOOoSNJxVCTpOCqSdBwRyZ2OoyJJx1GRpOOoSNJxVCQbJEUk6TgqknQcFUk6jookHUdFko6jIbnc6DgqknQcFUk6jookHUdFskFSRJKOoyJJx1GRpOOoSNJxVCTpOCKSAx1HRZKOoyJJx1GRpOOoSDZIikjScVQk6TgqknQcFUk6jookHUdEcqTjqEjScVQk6Tgqkrnz5Do+ds7t23j7QPL+6seL1+lIb+7Up9ebO5vp9eZOUHq9uXOOXO+UO418pfe7T/59254PlaNP8yl3wuhNJ3dq6E0n97SzN50GnTd0CqXIE+gUypwn0CmUUM/rcsfv+YVkoezbmWShVN2XZLPN63KSttleTtK2B8hJ2nYGOckGSRFJ2y4iJ2nbW+Qk6TgqknQcFUk6johk8jvlVyJJx1GRpOOoSNJxVCQbJEUk6TgqknQcFUk6jookHUdFko4jIpn8RvKVSNJxVCTpOCqSdBwVyQZJEUk6jookHUdFko6jIknHUZGk44hIJr+/m4Rk4P7ukvz+7pVI8sQRfdM1+a3TK5HkiSMimfzW6ZVIMlVTkWSqpiJJngyQXIblz2uXaTwi2SApIslUTUWSqZqKJB1HRZKOoyJJxxGRTH7r9Eok6TgqknQcFUk6jopkg6SIJB1HRdK343zxPu66HwqHaXnhsbVXlr4tR8/St+foWfo2HTXLNfnN02ux9G07epa+fUfP0rfxfMVym58s93bEssFSxtK39ehZ0nt0LOk9Opb0Hh1Leo+MZfI7qAlZtttwxJLeo2NJ79GxpPdEWLZxebKc5iOWDZYylvQeHUt6j44lvUfHkt6jY0nvkbFMfhu1C8sXOjSZd3ToJu/o0Dbe0WnQeUOHRvCODhn/HZ1K93I/X19bS93LjeitdC83oLfSvdyQ3kKZM6S3UIoM6S2UC0N6m5neQtktpLdQGgvpNctXlW6yhvSa5atK901Des3yVaVboSG9Zvmq0t3NkF6zfFXphmVIr1m+qnQPMqTXLF9Vuq0Y0muWryrdKQzpNctXlW7+hfSa5atK9/NCes3yVaVbdCG9Zvmq0l23kF6zfFXpRlpIr1m+qnRvLKTXLF9Vut0V0muWryrdwQrpNctXq1m+Ws3y1WqWryrdSAvpbWZ6zfLVapavKt2TC+k1y1eVbrNF9Fa6oBbSa5avKl0jC+k1y1eVLnuF9Jrlq0pXskJ6zfJVpYtTIb1m+arS9aaQXrN8VekSUkivWb6qdFUopNcsX1W60BPSa5avKl26Cen1yldbpYsxIb1e+WqrdHklpNcrX223ZqbXK19tlS6BhPR65aut0kWNkF6zfFXpMkVIr1m+qnThIaTXLF9VupQQ0muWrypdHAjpNctXlTb3h/Sa5atKG/BDes3yVaUt9SG9Zvmq0ib5kF6zfFVp23tIr1m+Mtvfvpntb9/M9rdvZvvbN7P97ZvZ/vbNbH/7Zra/fTPb376Z7W/fzPa3b5X2e395HWrbn+9j/PDauY1/Xju36Yik730/NUnfW4Bqkg2SIpK+NwbVJH3vEapJ+l4cV5P0vTeuJul7bVxMstIm/M4k6TgqknScCMnt8YPnfT4iScdRkWyQFJGk46hI0nEiJNcfkssRSTqOiiQdR0WSjiMiWekaRWeSdBwVSTpOhOT8+N3ivBz9brHSbY7OJBskRSTpOCqSdBwVSTqOiiQdR0WSjiMiWekiTGeSdBwVSTqOiiQdR0WyQVJEko6jIknHUZGk46hI0nFUJOk4IpKVrjJ1JknHUZGk46hI0nFUJBskRSTpOCqSdBwVSTqOiiQdR0WSjiMiWekyWmeSdBwVSTqOiiQdR0WyQVJEko6jIknHUZGk46hI0nFUJOk4GpJ7peuEnUnmzpPL7Uly2fcPJO/cHy9epyO9zUxv7mym15s7Qen15s45er2508hXer/75A9sydyTX9HrTCf5zb3edHJPO3vTyT3B7E2nUIo8gU6Dzhs6hRLqeV3u+D2/kCyUfTuTLJSqO5O0zetykrbZXk0y+W3IK5G07Qxykrb9Qk7StovISTZIikjScVQk6TgqknQcFUk6jookHUdEMvl91iuRpOOoSNJxVCTpOCqSDZIiknQcFUk6jookHUdFko6jIknHEZFsdBwVSTqOiiQdR0WSjqMiSQqKfFvm813JPfn93QuRTH7rNAvJwDe4kt86vRJJnjgqkg2SIpJM1VQkmaqpSJInAySXYfnz2mUaj0iSJ1UkmaqJSCa/dXolknQcFUk6jookHUdFskFSRJKOoyJJx1GRpOOoSNJxVCTpOCKSyW+dnknyi/dxh/DDY37ZY7fsryx9W46epW/P0bP0bTp6lg2WMpa+bUfP0rfv6Fn6Np6vWK7T8ydv4xFL386jZ+nbeuQsk98/vRZLeo+OJb1Hx5Leo2PZYPkty/2IJb1Hx5Leo2NJ73nz3ZHkF05706GbvKGT/BJpbzr0h3d0aATv6JDx39FphW7iBDboJ7+/qddb6cZTRG+lG08RvYUyZ0hvoRT5We92S369Ua+3UNIL6S2U3UJ6K93QjOhtZnqt8tVdr1W+uuu1yld3vVb56q7XLF9VunMZ0muWryrdogzpNctXle5FhvSa5atKdxpDes3yVaWbhyG9Zvmq0v3AkF6zfFXpFl9Ir1m+qnTXLqTXLF9VuhEX0muWryrdWwvpNctXlW6XhfSa5atKd8BCes3yVaWbWiG9Zvmq0n2qkF6zfFXp1lNIr1m+qnQ3KaTXLF9VukEU0muWr1oz02uWr5pZvqp0nyqk1yxfNbN8NZvlq0q3vEJ6zfJVpbtYIb3NTK9Zvqp0CSqk1yxfVbqqFNJrlq8qXSgK6TXLV5Wu/YT0muWrSpdzQnrN8lWlKzQhvWb5qtJFl5Bes3xV6TpKSK9Zvqp0ZSSkl/ty/3fg8nMb/7x2btMRSe7LqUhyX05FkvtyKpLclxORNL6zoCbJDW0VSW5oq0hyQ1tFskFSRJKOoyJJx4mQ3B4/eN7nI5J0HBVJOo6KJB1HRNL4usM3JNcfkssRSTqOiiQdR0WSjqMi2SApIknHUZGk40RIzo/fLc7L0e8WK93m6EySjqMiScfRkBwqXSrpTJKOoyJJx1GRpOOoSDZIikjScVQk6TgqknQcFUk6jookHUdEstK1oM4k6TgqknQcFUk6jopkg6SIJB1HRZKOoyJJx1GRpOOoSNJxRCQrXezqTJKOoyJJx1GRpOOoSDZIikjScVQk6TgqknQcFUk6jookHUdEstLVvM4k6TgqknQcFUk6jopkg6SIZO482cb2IDmv2weS+/rYDLCv05He3KlPrzd3NpPrTX4XT683d87R682dRr7S+90nf2BL5pD8il5vOg06b+jknnb2ppN7gtmbTqEUeQKdQpnzBDqFEup5Xe74Pf+QTH6z8EokC6XqziRt87qcpG22l5NskBSRtO0McpK2/UJO0raLyEna9hY5STqOiGTyu6FXIknHUZGk46hI0nFUJBskRSTpOCqSdBwVSTqOiiQdR0WSjiMimfx275VI0nFUJOk4KpJ0HBXJBkkRSTqOiiQdR0WSjqMiScdRkaTjiEgmv659JZJ0HBVJOo6KJB1HRbJBUkSSjqMiScdRkaTjqEjScVQk6Tgiksnv7yYhObfHt77ndkiyQVJEkidOhGRgc0ryW6dXIskTR0NyTH7r9EokmaqpSDJVU5EkTwZILsPy57XLNB6RbJAUkWSqpiLJVE1Fko6jIknHUZGk44hIJr91eiWSdBwVSTqOiiQdR0WyQVJEko6jIknHUZGk46hI0nFUJOk4IpLJb51eiaRvx/nifQzTU+HQXrgP6/5vufs2or7cfftTX+4N7l24+3YzEfcXlr7tTM/St5/pWfo2ND1L344mZ5n8Wuu1WNLTdCzpXjqW9CkdywZLGUt6T4RlW54/eX559T/3zeGO/vHqob286+32Sp6W1Is8nUpOXvydx7HSfeWyHtEB03tU6Y51WY/orPk9ogvn94iOnd+jhkf/L3tnm+RIlivXvWgBMsaNG19aj7bx9q6cVpHJsqkgwWpEAhd+/slk7Cz68XkMd2QSSO8RM4H8HjE9yO8Rc4b8HjFnyO8Rc4b0Hi3MGfJ7xJwhv0fMGfJ7xJwhv0cdj9J7xJwhv0fMGfJ7xJwhv0fMGfJ7xJwhvUcrc4b8HjFnyO8Rc4b8HjFnyO9Rx6P0HjFnyO8Rc4b8HjFnyO8Rc4b8HjFnSO/Rxpwhv0fMGfJ7xJwhv0fMGfJ7RD8K9chwE7Nt9KP0Hu3kuliPDPfpdnJdfo/Idfk9Itfl96jjUXqP+P1Rfo/oR6EeWXZs7/Sj/B7x+6P8HvH7o/QeHcwZ8nvEnCG/R8wZ8nvEnCG/Rx2P0nvEnCG/R8wZ8nvEnCG/R8wZ/D365CffHi+ebvv6/ZN/25R/MGnI79J8Y9YwgktMG0ZwiXnDCC4xcRjBpY5LA7jE1CHYpX1/vOdjO3OJucMILjF5GMElZg8juMTsYQCXJmYPI7jE7GEEl5g9BLt0fF+Pve1nLjF7GMGljksDuMTsYQSXmD2M4BKzhxFcYvYwgkvMHvK4NJ395qIxexjBJWYPI7jE7CHWpWn+dqmfPZcas4cRXOq4NIBLzB5GcInZwwguMXsYwSVmDyO4xOzhB1365j4zTYjhznzAwn3py4P7sr/h/jXa7I9PmrmfkafzR5Gnx7uTb+2Boy9n3DvcQ7jTtWO4055juNOHY7jTcGO401n9uS/3F7dtOuHe6awx3OmsMdxprDHc6asx3DvcQ7jTV2O401djuNNXY7jTV2O401dDuC/01Rju9FUT9+3x9xnL0d9wt/2mb6GxRpGns0aR75APIk9vjSJPc40iT3eNIk97jSJPfw0iv9Jgo8jTYaPI02GjyNNho8h3yAeRp8NGkafDRpGnw0aRp8NGkafDBpHf6LBR5OmwUeTpsFHk6bBR5Dvkg8jTYaPI02GjyNNho8jTYaPI02GDyO902CjydNgo8nTYKPJ02CjyHfJB5OmwUeTpsFHk6bBR5OmwUeTpsEHkDzpsFHk6bBR5OmwUeTpsFPkO+SDydNgo8nTYKPJ02CjydNgo8nTYGPL9RoeNIk+HjSJPh40iT4eNIt8hH0SeDhtFng4bRZ4OG0WeDhtFng4bRH6iw0aRp8NGkafDRpGnw0aR75APIk+HjSJPh40iT4eNIk+HjSJPhw0i3+iwUeTpsFHk6bBR5OmwUeQ75IPI02GjyNNho8jTYaPI02GjyNNhg8jPdNgo8nTYKPJ02CjydNgo8h3yQeTpsFHk6bBR5OmwUeTpsFHk6bBB5DsdNoo8HTaKPB02ijwdNop8h3wQeTpsFHk6bBR5OmwUeTpsFHk6bBD5hQ4bRZ4OG0WeDhtFng4bRb5DPog8HTaKPB02ijwdNoo8HTaKPB02iPxKh40iT4eNIk+HjSJPh40i3yEfRJ4OG0WeDhtFng4bRZ4OG0WeDhtEfqPDRpGnw0aRp8NGkafDRpHvkA8iT4eNIk+HjSJPh40iT4eNIk+HDSK/02GjyNNho8jTYaPI02GjyHfIB5Gnw0aRp8NGkafDRpGnw0aRp8MGkT/osFHk6bBR5OmwUeTpsFHkO+SDyNNho8jTYaPI02GjyNNho8jTYWPILzc6bBR5OmwUeTpsFHk6bBT5Dvkg8nTYKPJ02P96H0906Jmv6NAFX9Ghr72gM9GpXtGh97yiQzd5RYf+8IpOh84LOuTwV3TIyq/okJVf0SmUlY99v7/42M70Fkq/Fr2tUJ416S2UUE16C2VOk95CKdKkt4vpLZT0THoLZTeT3kJpzKRXLF81sXw1i+WrWSxfzWL5ahbLV3MX0yuWr2axfDWL5atZLF/NYvmqi+WrLpavuli+6mL5qncxvWL5qovlqy6Wr7pYvqp0od6it9JdeJNesXxV6Qa6Sa9Yvqp079ukVyxfVbptbdIrlq8q3XE26RXLV5VuFpv0iuWrSvd5TXrF8lWlW7QmvWL5qtLdVZNesXxV6caoSa9Yvqp0T9OkVyxfVbodadIrlq8q3Uk06RXLV5VuApr0iuWrSvfvTHrF8lWlW28mvWL5qtJdM5NesXxV6YaXSa9Yvqp0r8qkVyxfVbrNZNIrlq8q3SEy6RXLV5Vu7pj0iuWrSvdlTHrF8lWlWyomvWL5qtLdEJNerXy1VrqRYdKrla/WSvcgTHq18tV662J6tfLVWmnPv0mvVr5aK+3iN+kVy1eV9uWb9Irlq0o77U16xfJVpb3zJr1i+arSbniTXrF8Jba/fRXb376K7W9fxfa3r2L721ex/e2r2P72VWx/+yq2v30V29++iu1vX8X2t69i+9tXsf3tq9j+9lVsf/sqtr99Fdvfvortb1/F9revYvvbV7H97avY/vZVbH/7Kra/fRXb376K7W9fxfa3r2L721ex/e2r2P72VWx/+yq2v30V29++iu1vX8X2t69i+9tXsf3tq9j+9lVsf/sqtr99Fdvfvortb1/F9revYvvbV7H97avY/vZVbH/7Kra/fRXb376K7W9fxfa3r2L721ex/e2r2P72VWx/+yq2v30V29++iu1vX8X2t69i+9tXsf3tq9j+9lVsf/sqtr99Fdvfvortb1/F9revYvvbV7H97avY/vZVbH/7Kra/fRXb376K7W9fxfa3r2L721ex/e1rpf3eX+/69njX7Xjzsz95H1NfHz95eXr1tB1/+sn78fjJ7c1PXnr79dqlz2ceFcoMRT3aKu1RL+tRoWxW1qNCebKsR4UycFmPOh6l96hQ1yjrUaH5c1mPCs3My3rEnCG/R8wZYj3a7z94OZYTjyrdEynrEXOG/B4xZ8jvEXOGWI+2b4/WM486HqX3iDlDfo+YM+T3iDlDfo+YM+T3iDlDrEfL/e+ClvXk74K2Sne1ynrEnCG/R8wZ8nvEnCG/Rx2P0nvEnCG/R8wZ8nvEnCG/R8wZ8nvEnCG9R5XuS5b1iDlDfo+YM+T3iDlDfo86HqX3iDlDfo+YM+T3iDlDfo+YM+T3iDlDeo8q3Vku6xFzhvweMWfI7xFzhvwedTxK7xFzhvweMWfI7xFzhvweMWfI7xFzhvQeLcwZ8nvEnCG/R8wZ8nvEnCG/Rx2P0nvEnCG/R8wZ8nvEnCG9R6tuP3Le1rjqthhvkrpdw5ukbiPwJtkh6URSN117k9TNwN4kdZOqN0nd31t5k9T97ZIzyY2O40WSjmMhadilvNFxvEjScbxIdkg6kaTjWEgadpNudBwvknQcL5J0HC+SdBwnkjsdx4skHcfpd4s7HceLJB3Hi2SHpBNJOo4XSTqOF0k6jhdJOo4XSTqOE8mDjuNFko7jRZKO40WSjuNFskPSiSQdx4skHceLJB3HiyQdx4skHceH5H6j43iRpON4kaTjeJGk43iR7JB0IknH8SJJx/EiScfxIknH8SJJx3EiOdFxvEjScbxI0nG8SNJxvEh2SDqRpON4kaTjeJGk43iRpON4kaTjOJFsufNke0g45u32huSx3TcDHNt8pjd36vPX28X05k5Q/npz5xx/vbnTyEd6P/vkP/bHjz5OP81zJ4xoOrlTQzCdOfe0M5pO7glmNJ1CKfICOoUy5wV0uiqdT7rc+Xt+Ilko+waTLJSqg0nK5nV3krLZ3p2kbA/wJtllO4M7Sdl+4U5Stou4k5TtLe4kOySdSNJxvEjScbxI0nG8SNJxvEjScZxIJr/MPRJJOo4XSTqOF0k6jhfJDkknknQcL5J0HC+SdBwvknQcL5J0HCeSya9rj0SSjuNFko7jRZIUZPm2zPu7knvy+7sDkUx+6zQLScM3uJLfOh2JJE8cL5JM1bxIdkg6kWSq5kWSPGkguU7rr9euczsjSZ70IslUzYskUzUnkslvnY5Eko7jRZKO40WSjuNFskPSiSQdx4skHceLJB3HiyQdx4ukbsf54H3858c9fvL8vMdufWKZ/NrpWCx1e44/S92m489St+v4s+ywdGOp23f8Weo2no9Yrt88fnsfv7HU7Tz+LHVbjz9Leo8XyyP5BdSxWNJ7/FjSe/xY0ns+ZrmdseywdGNJ7/FjSe85/+7IkfzCaTQduskrOrSNF3SSXxeNpkMjeEWHjP+KTqUbT+836B/J72/6661048mit9KNJ4veQpnTpLdQijTpLZQLLXpboaRn0lsou5n0VrqhadErlq9K3dC06BXLV6VuaFr0iuWrSlcxTXrF8lWly5UmvWL5qtJ1SZNesXxV6QKkSa9Yvqp0TdGkVyxfVbpMaNIrlq8qXfkz6RXLV5Uu5pn0iuWrStfnTHrF8lWlS24mvWL5qtJVNJNesXxV6cKYSa9Yvqp0rcukVyxfVbp8ZdIrlq8qXZEy6RXLV5UuMpn0iuWrSteNTHrF8lWlS0EmvWL5au1iesXyVaX7VCa9YvlqFctXq1i+qnTLy6RXLF9Vuotl0iuWryrdmDLpFctXle41mfSK5atKt49MesXyVaU7Qia9Yvmq0k0ek16xfFXpvo1Jr1i+qnQrxqRXLF9Vurti0iuWrypdMDHpFctXwhcXPrn83Nuv1y59PiPJfTkvktyX8yLJfTkvktyX8yLJDW0XksdN+MqCN0luaHuR5Ia2F0luaHuR7JB0IknHsZDc7z94OZYzknQcL5J0HC+SdBwvknQcC8ntm+R6QlL4EoQ3STqOF0k6jhdJOo4XyQ5JJ5J0HAvJx9tY1u2MJB3HiyQdx4skHceLJB3HiWSlGyjBJOk4XiTpOF4k6TheJDsknUjScbxI0nG8SNJxvEjScbxI0nGcSFa6QxRMko7jRZKO40WSjuNFskPSiSQdx4skHceLJB3HiyQdx4skHceJZKVbYMEk6TheJOk4XiTpOF4kOySdSNJxvEjScbxI0nG8SNJxvEjScZxIVrrHF0ySjuNFko7jRZKO40Uyd56cbvcXH1//yhuSx3bfDHBs85ne3KnPX2/ubOavN3eCcteb/C6ev97caeQjvZ998r/fkvlFJ3fCiKaTOzVE0+nQeUEn9wQzmk6hFHkBnUKZ8wI6hRLqdV3u/D0/kSyUfWNJJr+GOBJJ2bzuTlI227uTlO0B7iQ7JJ1IyvYLd5KyXcSdpGxvcSdJx/EiScdxIpn8IulIJOk4XiTpOF4k6TheJDsknUjScbxI0nG8SNJxvEjScbxI0nGcSCa/CjwSSTqOF0k6jhdJOo4XyQ5JJ5J0HC+SdBwfklPy+7tJSBruSk7J7++ORJInjs83uKbkt05HIskTx4skUzUvkkzVvEgyVXMimfzWaRKS67T+eu06tzOS5EkvkkzVvEgyVfMi2SHpRJKO40WSjuNFko7jRZKO40WSjuNEMvmt05FI0nG8SNJxvEjqdpwP3sd/ftzjJ8/70/tYn1l2WLqx1O05/ix1m44/S92u489St+34s9TtO+4sk18+TcNy/ebx227f31jqdh5/lrqtx58lvcePZYelG0t6jx9Leo8fS3rPxyy3M5b0Hj+W9B43lsmvoYawfKJDk3lFh27yig5t4xWdDp0XdGgEr+iQ8V/RqXTj6f0G/Sn5/U1/vZVuPBn0Jr9l6a+3UOY06S2UIk16C+VCk94uprdQdjPprXRD06JXLF+VuqFp0SuWr0rd0LToFctXla5imvSK5atKlytNesXyVaXrkia9Yvmq0gVIk16xfFXpmqJJr1i+qnSZ0KRXLF9VuvJn0iuWrypdzDPpFctXla7PmfSK5atKl9xMesXyVaWraCa9Yvmq0oUxk16xfFXpWpdJr1i+qnT5yqRXLF9VuiJl0iuWrypdZDLpFctXla4bmfSK5atKl4JMesXy1SGWrw6tfNUq3acy6dXKV+2mla/aTStftVsX06uVr1qlu1gmvVr5qlW6MWXSK5avKt1rMukVy1eVbh+Z9Irlq0p3hEx6xfJVpZs8Jr1i+arSfRuTXrF8VelWjEmvWL6qdHfFpFcsX1W6YGLSK5avhC8ufHL5ubdfr136fEaS+3JOJIWvLXiT5L6cF0nuy3mR5Ia2F8kOSSeS3ND2IskNbS+S3ND2IknH8SJJx7GQ3O8/eDmWE5LClxW8SdJxvEjScbxI0nEsJLdvkusZyQ5JJ5J0HC+SdBwvknQcL5J0HC+SdBwLyeX+u8VlPfvdYqXbHMEk6TheJOk4XiTpOF4kOySdSNJxvEjScbxI0nG8SNJxvEjScZxIVrqPE0ySjuNFko7jRZKO40WyQ9KJJB3HiyQdx4skHceLJB3HiyQdx4lkpRtVwSTpOF4k6TheJOk4XiQ7JJ1I0nG8SNJxvEjScbxI0nG8SNJxnEhWuhMXTJKO40WSjuNFko7jRbJD0okkHceLJB3HiyQdx4lk8rt4t3Z/H8dt3d+Q9N4ikPyGXiyb3Jkvlk3uFBfLpsPmlE3upBXLJnd2imWTOw3Fssk9w41lk3sqG8lmTn7PMJaNai5+v1FnTn4nMZaNai62sOmwOWWjmovfbwGZk991jGWjmostbFRzsYWNai42sEl+hzKWjWoufv97hjn5fctYNqq52MKmw+aUjWoutrBRzcUWNqq52MJGNRdb2KjmYgOb5PdDY9mQi8/ZkIvP2ZCLz9l02JyyIRefsyEXn7MhF5+zIRefsyEXn7JJfiM3lg25+JwNuficDbn4nE2HzSkbcvE5G3LxORty8TkbcvE5G3LxKZvkd1Vj2ZCLz9mQi8/ZkIvP2XTYnLIhF5+zIRefsyEXn7MhF5+zIRefssl993DflvufAe/b0T3ZGL53l/uSYTCbDptTNqnzTTCb1PkmmE3qfBPMJnW+CWaTOt/Essl9hy+YTeq5XzAbcvE5G9VcbPjufO57dsFsVHOxhY1qLrawUc3Fhu9A574LF8xGNRcb2OS+3RbMRjUXW9io5mILG9VcbPg9Q+4baMFsVHOxhY1qLrawUc3FFjaqudjCRjUXG9jkvvcVzEY1F1vYqOZiCxty8TmbDptTNuTiczbk4nM25OJzNuTiczbk4lM2ue+WBbMhF5+zIRefsyEXn7PpsDllQy4+Z0MuPmdDLj5nQy4+Z0MuPmPTc98tC2ZDLj5nQy4+Z0MuPmfTYXPKhlx8zoZcfM6GXHzOhlx8zoZcfMom992yYDbk4nM2/cfZ+H47rgdcifJWsA6vYBtewT68gmN0BQE3hrwVTMMraMMrmIdXMPwzueV+Jr//DmxvuZ/JFgW5n8kWBbmfyRYFuZ/J779j1+fcz2SLgtzPZIuC3M9ki4Lcz2SLgtzPZIuC3M9kw6xizv1MtijI/Uy2KMj9TLYoyP1MNijouZ/JFgW5n8kWBbmfyRYFuZ/JFgW5n8kWBcM/k/vwz+Q+/DO5D/9M7sM/k5fhn8nL8M/kZfhn8jL8MzlgT723guGfycvwz+Rl+GfyMvwzeRn+mbwO/0xeh38mr8M/k9fhn8kBO7K9FQz/TF6Hfyavwz+T1+Gfyevwz+Rt+GfyNvwzeRv+mbwN/0z22bM63d9Um9buqcDwN14+21BDFezDKzhGV+Cz/zNUwTS8gja8gnl4BX14BcvwCoZ/Ju+5n8mGv5jdcz+TLQpyP5MNCo7cz2SLgtzPZMNfax65n8kWBbmfyRYFuZ/JFgW5n8kWBbmfyRYFuZ/JhlnFkfuZbFGQ+5n8XsFyy/1MtijI/Uy2KMj9TLYoyP1MtijI/Uy2KMj9TLYoyP1MtigY/Zm83EZ/Ji+34Z/J0/DP5Gn4Z/I0/DN5Gv6Z7LNDKlTB8M/kafhn8jT8M3ka/pk8Df9MbsM/k9vwz+Q2/DO5Df9M9tkhFapg+GdyG/6Z3IZ/Jrfhn8lt+GfyPPwzeR7+mTwP/0yeh38m++yQClUw/DPZZX/RrS93Bbfj5qng/d94LS77i0IVuOwvilUwDa+gDa9gHl5BH17BMryCdXgF2/AKhn8m99zP5Pd/MbssuZ/JFgW5n8kWBbmfyRYFuZ/J7/9ac3HZXxSrIPcz2aIg9zPZoiD3M9miIPcz2aIg9zPZMKtYcz+TLQpyP5MtCnI/ky0Kcj+TLQpyP5MtCnI/ky0Kcj+TLQpyP5MtCnI/ky0Khn8mb8M/k7fhn8nb8M/kbfhn8jb8M3kb/pm8Df9M3oZ/Jm/DP5O34Z/J+/DP5H34Z/I+/DN5H/6Z7LJDKlbB8M/kffhn8j78M3kf/pm8D/9MPoZ/Jh/DP5OP4Z/Jx/DPZJcdUrEKhn8mH8M/k49xn8nL1Lf/ffItnG26v6PpuH3/l1O/ff+Xx9/+lyffOrH8l9Nf/5ftb/7LeZr+d/vz15/3231H+XH03wz+/g/3v/0Pj7/8D//8HVvLfzj97X/Y/vY/nP/2P3T43J6OdX74vq9v/i9undZfL17n9l//V/T/39SS8U2tGd/UlvFN7de+qe9/6Pihf8jjm322f2j6qX+o/dQ/NP/UP9R/6h9afuofWn/qH9p+6h/68YnFND1ePU3bU2o7njLJz3/VzPS2cn9/bNu2x2vnPz8Icn99zCIg9WTBIiD1YMEioI8uIPVYwSIg9VTBIiD1UMEiIPWc3yIg9ZjfICD3t8YsAkZ/Euf+zphFwOhP4tzfGLMIGP1JnPv7YhYBoz+Jc39bzCJg9Cdx7u+KWQSM/iTO/U0xi4DRn8S5vydmETDuKo9fAsbd5PH/BQz85ZhfAsb9m59fAsb9k59fAlJ/ClkEjPsHP78EjPv3Pr8EpH4OGH7TnftbMRYBqfuAQUDu78RYBKR+ElsEpH4SWwSkfhJbBKR+ElsEpH4SWwSkfhJbBIz+JM79XRiLgNGfxAHfhDmdNPz3a6dpvb94mranP096/oObgK/CuEto40uYx5fQx5ewjC9hHV/ClkfC95vaM76pHz8fM03t28C+f7+6fRs4//w9c9vbSn3o5b3dc+4b5RYBqc+8WAT00QWkPvJiEZD67ppFQOqzaxYBqa+uWQSkPrpmEJD7NrlFwOhP4tyXyS0CRn8S575LbhEw+pM491Vyi4DRn8S5b5JbBIz+JM59kdwiYPQnce575BYBoz+Jc18jtwgY/Umc+xa5RcDoT+Lcl8gtAkZ/Eie/gf32r5Pn5CewDQJSfwq9/8vMeU79KWQRkPpTyCIg9aeQQUBP3QcsAlL3AYuA1M+B939SNPfUzwGLgD66gNR9wCIg9ZPYIiD1k9giIPWT2CIg9ZPYIGBJ/SS2CEj9JLYIGP1JvIz+JHbZXhIq4OefxJ/8MeNt//6js9vTn/M9/9HZso4vYRtfwj6+hGN4CettfAnT+BJabgmPjv8lYfpNwp9+cv/14u1p/e50PD1D1llLbteSmzsh/PZn6Wf/95g7IZgk5E4IJgm5E4JJQu6EYJGw5U4IJgm5E4JJQu6EYPmuz5b7qW+SkPtJbpKQ6On8/aYSPW+/35TLE/S4X6NobWlv3tS0PE5XLP3kTe0Z39Tx02/K+S9VXLb3hAqYRhfQRhcwjy6gjy5gGV3AOrqAbXQB++gCRn8SH6M/iY/Rn8TH6E/iY/QnscvWnlABoz+Jj9GfxMfoT+Jj9CfxMfiTuN8GfxL32+BP4n4b/Encb4M/iftt8Cdxvw3+JO63wZ/E/Tb4k7jfBn8S99voT+Ip9XPg/dcQ+5T6OWARkPpT6P1XsPqU+lPIIiD1p5BFQOpPIYOAlroPWASk7gMWAamfA++/O9Bb6ueARUAfXUDqPmARkPpJbBGQ+klsEZD6SWwRkPpJbBAwp34SWwSkfhJbBIz+JJ5HfxLPoz+J59GfxPPoT+J59CfxPPqTeB79Sdx//kn8wd+D7+t2fx/7enz/7e60tb8bRPZJS27Tkjtrye2jyv2WsIwvYR1fwja+hH18CcfwEpZh08S3hGETwreEYZ/63xKGfZJ/S8j9dN6W2/3FmyGMvNuZ0JfcT3J3ubmf+p/J9f1jjyV3mghFkzulhKLJnX4i0ay5U1UomtxpLRRN7hQYiiZ3ugxF00FzhqZSwnVGQxo+RUMaPkVDGj5FQxo+Q7ORhk/RkIZP0ZCGT9GQhk/RdNCcoSENn6IhDZ+iIQ2foiENn6IhDZ+h2UnDp2hIw6doSMOnaEjDp2g6aM7QkIZP0ZCGT9GQhk/RkIZP0ZCGz9AcpOFTNKThUzSk4VM0pOFTNB00Z2hIw6doSMOnaERzzfvtbctNNNdY0Ig+od5v21puok8oCxrRJ5QFjegTyoJGdF5jQSM6r7GgEc0177ePLJNorrGgEZ3XWNCIzmssaETTsAVNB80ZGtE0bEEjmoYtaETTsAWNaBq2oCENn6FppOFTNJXS8Ac/eerL/cVT32/fr57WvwRZKTuHgqyUtENBdkD6gCy1gckH5DecSjneHU6lJO8Op1KWd4dTKc17w5kr5Xl3OCT6F3BI6S/gqCbvZbm/52lZ19/g/OHVXxTur57m/ufIGHCDpCxK1fT9EcrWHgL7cgJSNam7g1RN9e4gVRuAO0jVtuANMvnVnoFAqrYQd5CqjeUzkMtyF7hNJyBpN04guyjIr18Q3BWuz//n+vfdJvmVpqFQqrabj1BaHjiq7cYdpGq7cQep2m68QSa/IjYQSNV24w5Std24g1RtN5+BfN9ual2XiwSp2m222/2bi18/bPLoNqVu4gWjVG03H6G0PHBU2407SNV24w2y1DW/UJCq7cYdpGq7cQep2m7cQXZAGkC+bzelbhaGgpT9vc12fINsb0C+P5y+lLqHGApS9vc23iBlm83yGERsz8ur/n5sUeo2YzBK2XbzCUpDlix1+TEUpGy78QbZAekDUrbdeIOU/c2NN0jZ39t4g5T9vc1HIN8PLkrdzowEWerS5t+C3H7/i4tvOLSVF3BoIC/gqLaK/Xb/yJn2af8fh5FBqfucwShVm8VHKA05rtT1z1CQqs3CHaRqs3AHqdosvEGWuloaClK1hbiDVG0sn4F8PzQodT81FGQHpA9Imo0TSJqNE0iajRNImo0TSJqNC8i11N3ivwXZfl9m9A2HtvICDg3kBRyJVvEtt2vJzZ3Q9+lx2Wl/OkXy93Jz52h3ubnT7kdy30+S1uR3od3l5k6O3nKT3292l5s7sbnLzZ3B3OXmTlWfyX3fzZLfQ3aXWyhVWeQWSlUWuZVSlUFupVRlkJs8Va2PArhv87+vCMnvALvLTZ6qPpFriBnJL/C6y02eqrzldi25yVOVt9zkqcpbbvJU9ZHc9zEj+aVXd7mFUpVBbvJrrO5yK6Uqg9xKqcogN3eqOh7Plv2Y139fEZLfKXWXmztVfSTXEDOSX/x0l5s7VbnLzZ2q3OXmTlXecpNfonSXmztVfSb3fcxIftXRXW6hVGWR27XkVkpVBrmVUpVB7jipqv9eAL8ljJOUTiWMk37OJCS/Pnds00PC7vDXpslvxLnLTZ5oPpFryKvJ7625y+1acpMnGm+5yRONt9zkicZbbvL085Hc93k1+T0tb7nJr165yy2UqixyK6Uqg9xKqcogt2vJHShVHX/usMmvFZkkpE4/x63d38dxW/c3/6Pb2/1m8f70ntu0PclNnX785aZOP5/J3fbHX7tP7c1PNkwoct/QiUWTOlXFokmdwGLRpE5rsWg6aM7QpE6BsWhSp8tYNIVSqzeaQgnXGw1p+AxN7qsrsWhIw6doSMOnaEjDp2g6aM7QkIZP0ZCGT9GQhk/RkIZP0ZCGz9DkvhQSi4Y0fIqGNHyKhjR8iqaD5gwNafgUDWn4FA1p+ATNlvtOwHVoln7/S4mln6ERzTUWNKJPqGXZ72ieD5v/hkb0CWVBI/qEsqARfUJZ0IjOayxoROc1BjS59+Nfh2ad1l+vXed2gkY011jQiM5rLGhE5zUWNB00Z2hE07AFjWgatqARTcMWNKJp2IJGNA0b0OS+axCLhjR8ioY0fIqmUhr+4Cdv2/1LvNv+/XOfv2C45b7DEIumUhp2RlMpDTujqZSGndFUSsPOaCqlYV80ue9R/AiaYz1BUykNO6OplIad0Yim4ad1G/NygqaD5gyNaBq2oBFNwxY0omnYgkY0DVvQiKZhA5rcd0R+BM3Jrqwt982RWDSiadiCRiINf8vtWnJzp9bpdn/x8fWvvJE73dbvd71tT69enwTnzqIXCM6dMC8QnDs3XiA4dxr0F5z7ssoVgnMntwsE585jFwjOnbIuENzVBKslrdxXVq4QrJa0cl9auUKwWtLKfW3lCsFqSSv3xZUrBKslrdxXV64QrJa0cl9puUKwWtJKftXlAsFqSSv5tZYLBKslreSXVS4QrJa0kl9BuUCwWtJKfrHkAsFqSSv5dZELBKslreSXQC4QrJa0kl/tuEBwoefwsd3/JO3YTv5oKfmlBHe5hT6hj/2+6+w4TnadJd9N7y630KezRW6hz2aL3EId2CK3a8mt9Nw1yK303DXILdR9LXILNV+LXKlUtSffjO8ud9hU9S1h2KT0LSF3+mmPxcvHvN0civh+62qCcyegCwTnzkAXCM6dgi4QnDsHXSA4dxLyF5x8m/4FgnOnoQsE585OFwhWS1rJt9RfIFgtaSXfKH+BYLWklXz7+wWC1ZJW8k3tFwhWS1rJt6pfIFgtaSXfgH6BYLWklXxb+QWC1ZJW8s3iFwhWS1rJt4BfIFgtaSXf2H2BYLWklXy79gWC1ZJW8k3YFwhWS1rJt1ZfIFgtaSXfMH2BYLWklXwH8EeC33+/ZE++A9hdbqFPaMNfQibfDustN/luWHe5hT6bLXILdWCL3EIN2CK30nPXILfSc9cgt1D3tcgt1HwtcrVSVfJNsN5yk++BfSH3W8KwSelbQu7001u/S1i2d7dppuX+Nqaln/yPLnf6cZfbteTmTj/ucnOnH3e5udOPu9zc6cddbu704y03+W5Wd7m5k5K7XK1UlXwrq7vcriVXK1Ul38fqLlcrVSXfxeouVytVJd/D6i5XK1Ul38HqLlcrVe1dS65Wqkq+X9ddrlaq2rVSVfLtyd5yk29PdperlaqSb092l6uVqpJvT3aXq5Wqkm9PdperlaqSb092lyuVqo7k25Pd5UqlqiP5pmV3uVKp6rh1LblSqepIvo/ZXa5UqjqS72J2l6uVqpLvYXaXq5Wqku9gdpdb6EH0/lvUR/Jltd5yky8y/Uzu2+/7HMnXmLrLLfRRZZFbqABa5HYtuYUKoEVupeeuQW6l565BbqECaJFbqAAa5CZfWuouVytVJV9Y+kLut4Rhk9K3hJ5awnpb7hLW493hz+m2PXr4bX969Xo8Cc6dfy4QnDsBXSA4dwa6QHDuFHSB4Nw5yF9w8qWiFwjOnYUuEJw7DV0gOHd2ukBwVxOslrS6WtLqakkr+XLgCwSrJa3kC4IvEKyWtJIvCb5AsFrSSr4o+ALBakkr+bLgCwSrJa3kC4MvEKyWtJIvDb5AsFrSSr6Q+ALBakkr+VLiCwSrJa3ki4kvEKyWtJIvJ75AsFrSSr6g+ALBakkr+ZLiCwQXeg4bvl+SfJGtu9xCn9CGv4RMvurUXW6hT2eL3EKfzRa5hTqwRW7XklvpuWuQW+m5a5BbqPta5BZqvha5Wqkq+apTd7nDpqpvCcMmpW8JudPP1h4S9vbu8OfU23p/1/0/7/T+6r0/Ce5qgnMnoAsE585AFwjOnYIuEJw7B10gOHcSchf8pSx3GLpCce48dIXi3PHpCsViaetLWZdTLJa3vpSJBa4vZWKJ60uZWOT6UiaXuZLvL71CsVzmSr7F9ArFcplr6nKK5TJX8vW8VyiWy1yTXOaa5DJX8kXMVyiWy1zJ1zFfoVgucyVfynyFYrnMlXw18xWK5TJX8gXNVyiWy1zJ1zRfoVgucyVf1nyFYrnMlXwV9BWK5TJX8lXBHyl+/0WyL72FnsYWvcnXyH6m9+0fPX+JKfQpbdJb6DPapLfQJ7RJb6FObNJbqBGb9FZ6/lr0Vnr+GvQmXx/rr7dQEzbpFctXyXfH+uvto+p90jBsZnrSkDsH7cv2+J/Svrxr5m+vQ3/pzZ2D/PXmzkH+enPnIHe9yZe7+uvNnYP89ebOQf56c+cgf71dTG/uzOSvVyxfJd/q6q9XLF8l3+nqrjf5Sld/vWL5KvlCV3+9Yvlq62J6xfJV8oW9/nrF8tUmlq+Sb2R215t8JbO/XrF8lXwps79esXyVfC2zv16xfJV8MbO/XrF8lXw1s79esXyVfDmzv16xfJV8lbO/XrF8lXzts79esXyVfOmzv16xfJV85bO/Xq18NSXf9+yvVytfTcl3Pfvr1cpXX2rE9Grlqyn5jmd/vVr5akq+39lfr1i+Sr7b2V+vWL5KvtfZX69Yvkq+09lfr1i+Sr7P2V+vWL5KvsvZX69Yvkq+x9lfr1i+Sr7D2V+vWL5Kvr/ZX69Yvkq+u9lfr1i+Sr632V+vWL5KvrPZX69Yvkq+r9lfr1i+Sr6r2V+vWL6axfLVLJavku/h9tcrlq+6WL7qYvkq+Z51f71i+Sr5nnV/vWL5KvmedX+9Yvkq+Z51f71i+Sr5nnV/vWL5KvmedX+9Yvkq+Z51f71i+Upsf/sktr99EtvfPontb5/E9rdPYvvbJ7H97ZPY/vZJbH/7JLa/fRLb3z6J7W+fxPa3T2L72yex/e2T2P72SWx/+yS2v30S298+ie1vn8T2t09i+9snsf3tk9j+9klsf/sktr99EtvfPontb5/E9rdPYvvbJ7H97ZPY/vZJbH/7JLa/fRLb3z6J7W+fxPa3T2L72yex/e2T2P72SWx/+yS2v30S298+ie1vb2L725vY/vYmtr+9ie1vb7cuplcrXzWx/e1NbH97E9vf3sT2tzex/e1NbH97E9vf3sT2tzex/e1NbH97E9vf3sT2tzex/e1NbH97E9vf3sT2tzex/e1NbH97E9vf3sT2tzex/e1NbH97E9vf3sT2tzex/e1NbH97E9vf3sT2tzex/e1NbH97E9vf3sT2tzex/e1NbH97E9vf3sT2tzex/e1NbH97E9vf3sT2tzex/e1NbH97E9vf3sT2tzex/e1NbH97E9vf3sT2tzex/e1NbH97E9vf3sT2tzex/e1NbH97E9vf3sT2tzex/e1NbH97E9vf3sT2tzex/e1NbH97E9vf3sT2tzex/e1NbH97E9vf3sT2tzex/e1NbH97E9vf3sT2tzex/e1NbH97E9vf3sT2tzex/e1NbH97E9vf3sT2tzex/e1NbH97E9vf3sT2tzex/e1NbH97E9vf3sT2tzex/e1NbH97E9vf3sT2tzex/e1NbH/7LLa/fRbb3z6L7W+fxfa3z7cuplcrX81i+9tnsf3ts9j+9llsf/sstr99FtvfPovtb5/F9rfPYvvbZ7H97bPY/vZZbH/7LLa/fa603/vY2v3F23ymt9Dz16S30Ofzse+PF29negt9Ppv0Fvp8Nukt9Pls0luo/1r0Vtr/bNJb6flr0Vvp+WvRW6j/mvR2Mb1i+arS/meT3mHz1ZOGYTPTk4bUOejrfbTl8UZu+/rmf3nnP/tbce5NzZcoTp2FLlGcOg1dojh1HrpEcZdTnDoTXaI4dSq6RHHqXHSJ4tQp6hLFcpkr9/bmSxTLZa7cG5wvUSyXuXJvcb5EsVzmyr3J+RLFcpkr9zbnSxTLZa7cG50vUSyXuXJvdb5EsVzmyr3Z+RLFcpkr93bnSxTLZa7cG54vUSyXuXJvxf1U8dLvfwe79FPFpZ5OJsWlPrmW5f63Gst69rcauXenXqK41CeXRXHu/amXKC7VFk2KS7VFk+JSz+N1Wn+9ep3bmeJSz2OT4lJt0aS4VFs0KS6VuUyKS2Uuk+JSmcuiOPdO1UsUl8pcJsWlMpdJsVzmyr1b9RLFA2euJxUD56gnFcmz0TR/v5Gp9zf/67NMWXPvQr1EcfJs9Jni1h5vpC9/Vtxz70O9RHHybHSB4uTZ6ALFybPRBYq7nOLk2ehDxcs9g7RtOlOcPEddoLhU5jIpLpW5TIprZS6D4tw7Ui9RXCtzWRTXylwWxdkz1/bYJnhr2/FG8X82hdxfPj+/k7Y9a+6CmrPnris0Z09eV2jOnr2u0Jw9fV2hOXv+ukBzy57ArtCcPYNdoTl7CrtCs2AOa11Qs2AOy70d+SLNgjks95bkizQL5rDc25Iv0iyYw3JvTb5Is2AOy709+SLNgjks9xblizQL5rDcm5cv0iyYw7Lvar5Es2AOy76v+RLNgjks+87mSzQL5rDse5sv0SyYw7Lvbr5Es2AOy76/+RLNgjks+w7nSzQL5rDse5wv0SyYw7Lvcr5Es2AOy77P+QrN2bf9fqbZcHO6Z9/2e4HiUp/ZhruIPfsm2AsUl/q8Niku9WltUlyqM1sUb6Uas0lxreexRXGt57FFcamubFLc5RTLZa5NLnNl32H9SvGTioFz1JOK5NlobrfHG5nn+c3/+gzbjHr2XdMXKE6ejS5QnDwbfabYsvcl+67pCxR3OcXJs9EFipNnowsUJ89GFyhOnqMuUFwqc1m2oGTfNX2B4lKZy6S4VuayKK6VuSyKu5ziWpnLonikzNVvJ3ON7HupjSpGykbnKrLnne34VnG0fz9/WLLvj75Acfa885FiQ4pfsu+PvkBx9rzjr7jLKc6ed/wVZ887/oqzZ6PPFL/PtEv2/dEXKC6VuSyKs++PvkBxrcxlUVwrc1kU18pcFsV9JMUnf1exZN8HbVQxVDY6VZE87/T+/UaW/u4vrPb9cZht3/vT/xVN07Pm5InnEs3JM88VmrPvbL5Ec/Lcc4nm5MnnEs3Js88lmrug5uRZ6RLNyZPVJZoFc1j2nc2XaBbMYdl3Nl+iWTCHZd/ZfIlmwRyWfWfzJZoFc1j2nc2XaBbMYdl3Nl+iWTCHZd/ZfIlmwRyWfWfzJZoFc1j2nc2XaBbMYdl3Nl+iWTCHZd/ZfIlmwRyWfWfzJZoFc1j2nc2XaBbMYdl3Nl+iWTCHZd/ZfIlmwRyWfWfzJZoFc9gqmMOy7+a+RLNgDlsFc1j2Dd2faTZsYV+yb+j2V5x9e/OHit9vBF2yb2++QHGpz2uT4lKf1ibFXU5xqcZsUlzreWxRXOt5bFFcqiubFJdqyhbF2bdCX6BYLnNl3wr9SvGTioFz1JOKnlvFsj+OwN3W493/+vo23//n17e+nXT37PubL9GcPB9dojl5QrpEc/KMdInm5CnpCs3ZNzlfojl5UrpEc/KsdInm5MnqEs1dULNgDsu+1fkSzYI5LPvG6Es06+WwNfuG6Us06+WwNfuW6Us06+Ww9dYFNevlsDX7tulLNOvlsDX7xulLNAvmsOxbpy/RLJjDsm+evkSzYA7Lvn36Es2COSz7ZutLNAvmsOx7sC/RLJjDsu/BvkSzYA7Lvgf7Es2COSz7HuxLNAvmsOx7sC/RLJjDsu/BvkSzYA7Lvgf7Es2COSz7HuxLNAvmsOx7sC/RLJjDsu/BvkSzYA7Lvgf7Es2COSz7HuxLNAvmsOx7sC/RLJjDsu/BvkSzYA7Lvgf7Es2COSz7HuxLNAvmsOx7sC/RLJjDsu/BvkSzYA7Lvgf7Es2COSz7HuxLNAvmsOx7sC/RLJjDsu/BvkSzYA7Lvgf7Es2COWztgpoFc1j2feeXaBbMYatgDlsFc1j2veefaTZs81+z7z2/QHGpz2zDZtk1+07sCxSX+rw2KS71aW1RnH0n9gWKSzVmk+Jaz2OL4lrPY4viLqe4VFM2KZbLXLW2bJsUD5y5nlQMnKO+VWTfg/1dxqfb/p9//eX/+qb5uN1fPj9p/r27Z9+DfYnm5PnoEs3JE9Ilmrug5uQp6RLNyXPSJZqTJ6VLNCfPSpdoTp6sLtC8Zd+DfYlmvRy2Zd+DfYlmvRy23bqgZr0ctmXfg32JZr0ctmXfg32JZsEcln0P9iWaBXNY9j3Yl2gWzGHZ92Bfolkwh2Xfg32JZsEcln0P9iWaBXNY9j3Yl2gWzGHZ92Bfolkwh2Xfg32JZsEcln0P9iWaBXNY9j3Yl2gWzGHZ92Bfolkwh2Xfg32JZsEcln0P9iWaBXNY9j3Yl2gWzGHZ92Bfolkwh2Xfg32JZsEcln0P9iWaBXNY9j3Yl2gWzGHZ92Bfolkwh2Xfg32JZsEcln0P9iWaBXNY9j3Yl2gWzGHZ92Bfolkwh2Xfg32JZsEcln0P9iWaBXNY9v3In2k2bCPcsm9HvkBxqc9sw2acLfvG3AsUl/q8Niku9WltUbyV6swmxaUas0lxreexRXGt57FFcZdTXKopmxTLZa7sO68vUDxw5npSMXCO+laRfTf1vn6rOG7bm//1Lfu91S37/v2zt+VZcfJsdIHi5NnoM8Xbfjx+dnvzs8/fxxOd5DkqmE6Hzgs6yfNZMJ3kWS6YTvLcF0wneUYMppM8e8bSyb5TPJhOqfzrToes/IoOWfkVnQ6dF3TIyq/okJVf0SErv6JDVn5Fh6x8TmfPvvc9mA5Z+RUdsvIrOmTlV3Q6dF7QISu/okNWfkWHrPyKDln5FR2y8gs62XfzB9MhK7+iQ1Z+RUf2ib70x9/v9FM6sk90C53sm7ovpLPcf/Kybmd0ZD+VTXRkP5VNdGQnGCY6HTov6MhOMEx0ZPPOOq2/XrvO7YyObN4x0ZGdYJjoyE4wLHSyb1MPpiOblU10ZLOyiY5sVjbR6dB5QUc2K5vokJVf0SErv6JDVn5Fh6z8gk72jffBdMjKr+iQlV/RISu/otNL0fnkZ6/fP3pdnzYvzsczn1pp2Z9Prbzsz6dWYvbnUysz+/OplZo/+dnb7f74+s/6o9/4/OH3YO830+zZrxkMxbJWIo9lWSu/x7KslfZjWXZYurHU7RH+LHU7hz9L3X7iz1K3y/izpPe4sVzpPX4s6T1+LOk9fizpPX4sOyzdWNJ7/FjSe/xY0nv8WNJ7/FjSe9xYZr/ENRRL8qWN5XL/+5xlm85Ydli6seQ57vd/4zzH/VjyHHdjWetqVDBL5pd+LJlf/oHlEx8y42s+HT4v+QjPDo/Hj97nUz7C80ATH+FuYOIjnPdNfIQzvIVPsctX/nx0s/b+iM/T0fff+Pxd1i52KSuWpW4u92fZYenGUjfv+7PU7Qb+LHV7hD9L3c7hz1K3n3izPIpdJotlSe/xY0nv8WNJ7/Fj2WHpxpLe48eS3uPHkt7jx5Le48eS3uPGstiVuViW9B4/lvQeP5b0Hj+WHZZuLOk9fizpPX4s6T1+LOk9fizpPW4si91xjWXZYWli+f77jEexS5axLHn2+P3fOM8eN5bF7iLGsmTm5seSmZsfS2Zuf2D5xKfD5yUfcuBrPrrzrmO9v7h9yT3jozvDsvHR7QY2Prp538Sn2L1Gfz66udzGRzZrt9s8Pfgc/Tc+f8ja/XbP2uvt+7XTc9YuduExlmWHpRtL2Qx/AUvZvH8BS9lucAFL2R5xAUvZzuHPUvfW5QUsZbvMBSzpPX4s6T1+LDss3VjSe/xY0nv8WNJ7/FjSe/xY0nvcWOreuryAJb3HjyW9x48lvcePZYelG0t6jx9Leo8fS3qPH0t6jx9Leo8bS91blxewpPf4saT3+LGk9/ix7LB0Y0nv8WNJ7/FjSe/xY0nv8WNJ73FjqXsb+AKW9B4/lvQeP5b0Hj+WHZZuLOk9fizpPX4s6T1uLHVvuH7I0rCPTfeG6wUsefbYWBp2NeneyryAJc8eP5bM3PxYMnNzYtluurcyX7F84kNmfM2HHPiaj+68a5oe73rqp3w6fF7y0e0GNj66ed/GRzfD2/jo5nIbH92sPe3L41334zc+fzN/bDfd+4wXsNTN5f4sdTO8P0vhvO/OssPSjaVwj3BnKdw53FkK9xN3lsJdxp0lvceNpe59xgtY0nv8WNJ7/FjSe/xYdli6saT3+LGk9/ixpPf4saT3+LGk97ix1L0NfAFLeo8fS3qPH0t6jx/LDks3lvQeP5b0Hj+W9B4/lvQeP5b0HjeWuveUL2BJ7/FjSe/xY0nv8WPZYenGkt7jx5Le48eS3uPHkt7jx5Le48ZS+E6zP0t6jx9Leo8fS3qPH8sOSzeWZCIby7f72L5YkoncWArfyvyMpWFXk/CtTH+WPHv8WDJz82PJzM2PJTO3P7B84kNmfM2HHPiSj/Cdyvb40W2+3c746M6wbHx0u4GNj27et/Hp8HnJRzeX2/joZu25ffPp6xkf3fxs46Obn218dPOziY/wvUMbH938bOOjm5/n4z7+ab3vv/H571f34/4+lunp9xS//f5M+C6hP8sOSzeWuhnen6Vw3ndnKdwN3FkK9wh3lsKd4xOWT39TtMwnLA/hfuLOUrjLuLOk9/ixpPf4seywdGNJ7/FjSe/5lOXp31kL38T1Z0nv8WOp23v6408B2zK/+7vBbb+z3I6nnzxv3ywn4Zu4/ix1e48/S93e489St/f4s+ywdGOp23s+Yrm3u8R9Xs9Y6vYef5a6vcefpW7v8WdJ73FjKXyf2J8lvcfGcnn85O12xpLe48eS3uPHssPSjSW9x48lvcePJb3HjyW9x8by8cuh47acsaT3uLEUvk/sz5Le48eS3uPHkt7jx7LD0o2lbu9Z1vuvw9p6m96w/Co19x/99f98+ouZfjzT1G0+V9DU7T5X0NRtP1fQ1O0/n9FsU7+/kbZvv9H871cbtupNwleNo8nrdqto8rpNLJq8bm+LJt8hH0SeThhFnv4YRZ6uGUWeXhpFng4bRF74QnU0eTpsFHk6bBR5OmwU+Q75IPJ02CjydNgo8nTYKPJ02CjydNgg8sLXxqPJk+evIP/+muwkfDE6mjzZJurThmwTRZ5sE0R+JdtEkWc+H0We+fy/Jv9Ek4zuSbND05Ems3Ebzfm23t/I3E9pMu/2pEnP86RJd/OkSR9zpLnRsTxp0puMNLf7sHHqy+03mn949dYf7Pf+9E769Mye5hTHnp4Vx77DPow9HS6OPY0vjj39MI49bTKOPd0zjP1OU41jT6+NY0+vjWNPr41j32Efxp5eG8eeXhvHnl4bx55eG8eeXhvG/qDXxrGn18axp9fGsafXxrHvsA9jT6+NY0+vjWNPr41jT6+NY0+vjWLfbvTaOPb02jj29No49vTaOPYd9mHs6bVx7Om1cezptXHs6bVh7Ccy5gXsDRvQ2kTCjCLPc/YK8u93ErWJp2wUeZ6xUeSZHAeRb8yNo8gzNf7X5J9oktE9aZK7bTSX6a5xWrb9zadCP+7vepmefvL026dCh3wQeaa6UeTpmlHk6ZpR5OmaUeTpmkHkZ7rmBeSXfv/RyzKfkadrRpGnl0aRp8NGke+QDyJPh40iT4eNIk+HvZb8ejsjT4eNIk+HDSLf6bA28us3kXWZ3pCflv644bMsz/v+n/8Or9Ni49jTY+PY02Tj2HfYh7Gnzcaxp89ewv7xp9dfebSdsafRxrGn08axp9WGsV/otXHs6bVx7Om1V7Dvx+3Bfv89Y/7d3G2hA4/hU8enIXyiW1/h07p9v3rvZ88cunUce7p1HHu6dRx7unUY+5VuHceebh3Hnm59Cfv9sbNoPY4z9vTlOPYd9mHs6bVx7Om1cezptXHs6bVx7Om1l7Cf7m9k2qbf8/3fzZs3OvAYPtGXx/CJbn2FT/vt8Xu2397Jb8+cjW4dx77DPow93TqOPd06jj3dOo493TqOPd36EvbT8mDf9hP2O305jj0dOI49vTaOPb02jn2HfRh7em0ce3rtFexf3DX7u3nzTgcewyf68hg+6XbrdX68669f8b/zaTm+/wpgOp7exx+JLPdHTnu+bPf1Pr7JH7rNOpq8bq+OJq/bqqPJ63ZqN/JPNDs0HWnq9t4raOo22Sto6vbNK2jqtsIraNLd/GjON/qYJ006lo3muj62Q617+43mH97Hcn/X2/H017vzM3gqVhB4GtYF4Ft7/Oi+/LnbzrcO+SDyNLco8rS8KPI0wijytMco8jTNK8i/n9vPE600ijwN1kZ+uz3+vmqb9n9fpCYabBB4GuwF4C3P16lDPog8DTaKPA02ijwNNoo8DTaKPA32CvKGHtVosFHkabBG8t9/Vb8t7/7a0lCkGg02CDwN9gLwludr65APIk+DjSJPg40iT4ONIk+DjSJPg72CvKFHzTTYKPI0WCP5vT/IH9u/L1IzDTYIPA32AvCW5+vcIR9EngYbRZ4GG0WeBhtFngYbRZ4GewV5Q4/qNNgo8jTYj8nvt/4b+Sea1FJPmnRNT5odmiaa+/Igsq/9f/71yKRTH4PA0x4vAG9J0p32GEWe9hhFnvYYRH6hPUaRpz1GkadpXkHeMDFZaKVR5DvkbeTb/k1+eUP+mO+LCY71+29i2n78XelaaLsDmEQzHsAkSvQAJtG3BzCJap7fpJUWP4BJFP4BTGI2MIBJjBEGMKljUn6TmDjYTDqmxwrKY25vTLKAZ4oQBJ7JwAXgLb92Wan7UeTp8EHkN4p5FHnadhR5KnQUeXrxFeQNv17fOuSDyNNgo8hTYaPI02GN5JftQf7tV/5evfqJPS02jj099gL223483kd78z7O3/O3SzuddwSX6McjuESXHsElevcILnVcGsAl+vwILtH9R3CJOcEILjFRGMElZg8DuHQwexjBJWYPI7jE7GEEl5g9jOBSx6UBXGL2MIJLzB5GcInZwwguMXsYwSVmD/ld6jdmDyO4xOxhBJeYPYzgErOHEVzquDSAS8weRnCJ2cMILjF7GMClib4U7NLS26/XLv3UJfrSCC51XAp26bF6Zlm3M5fIeCO4RMYbwSUy3ggu8fulEVzi90sDuNToS8EurdP667Xr3M5coi+N4BK/XxrBJX6/NIJLHZcGcInZwwguMXsYwSVmDyO4xOxhBJeYPQzg0szsYQSXmD2M4BKzhxFcYvZwhUsfvI/j8XcPx7I8/dzbs0sdlwZwidnDCC4xexjBJWYPI7jE7GEEl5g9DOBSZ/YQ7dLjBx9fzpy4xOxhBJeYPYzgErOHEVzquDSAS8weRnCJ2cMILjF7+FGXnsgzT4giz4wgiPxC748iT5ePIk8/jyJP544i3zXIPykW6aRPikX63ZNika70pFikozwpFukG34pXkUz+pDh5Fj4eD++v//e2vFE8LY9XL/1McfIMeoHi5NnvM8Xee9rWDp0XdJJnuWA6yXNfMJ3kGTGYTvI8GUwnefaMpbMlz6nBdEplWnc6pfKvOx2y8is6HTov6JCVX9EhK7+iQ1Z+RYes/IoOWfkFnZ2s/IoOWfkVHbLyKzpk5Vd0OnRe0CErv6JDVn5Fh6z8ig5Z+RUdsvILOgdZ+RUdsvIrOmTlV3TIyq/odOi8oENWfkWHrPyKDln5FR2y8is6ZOVzOsuNrPyKDln5FR2y8is6ZOVXdDp0XtAhK7+iQ1Z+RYes/IoOWfkVHbLyCzoTWfkVHbLyKzpk5Vd0yMqv6HTovKBDVn5Fh6z8ig5Z+RUdsvIrOmTlF3Sy3+6+js7y2Ja/9FM6snnHREf2mbUs980oy7qd0ZF9ZpnoyD6zTHRkn1kWOtnvpwbTkZ3vmOjI5h3Dnc4l+53OYDodOi/oyM53THRks7KJjmxWNtGRzcomOrJZ2UIn+72/YDqyWdlEh6z8ig5Z+RWdDp0XdMjKr+iQlV/RISu/okNWfkWHrPyCTvYbWR/S+eRnL8v9133T8vSTW//Tq79I3SVu0xnLWsk6lmWtHB7LslZqj2XZYfnfLJ/41Er5/nxq5Xx/PrWSvj+fWlnfn0+ttO/OJ/v9rXA+ZPjXfHRz+dru1XtanzT+OUtaunexq2GxLDssLSxbe0jsyxlL3Qzvz1I37/uz1O0G/ix1e4Q/S93O4c6y2N21WJa6XeYzloa5b7GbbrEshXvPujxYbrtD7yl2Ly6WpXDv+YSl6dkj3HvcWQr3HneWwr3HnaVw7/FmWeyGXixL4d7jzlK493zE0tB7il3zi2XZYenGkt7jx1K392y3e8WetuX2huW0PN7H0s9Y6vYef5a6vecjlt675opdQxyGe7E7i+Nw1+1esdx1e1osd91OF8u9wz2Eu25XjOVOr4zhTgeN4U5fjeFOX43gvha7dToOd/pqDHf6agx3+moM9w73EO701Rju9NUY7vTVGO701Rju9NUQ7sXuDY/Dnb4aw52+GsOdvhrDvcM9hDt9NYY7fTWGO301hjt9NYY7fTWEe6OvxnCnr8Zwp6/GcKevxnDvcA/hTl+N4U5fjeFOX43hTl+N4U5fDeE+01djuNNXY7jTV2O401djuHe4h3Cnr8Zwp6/GcCe/u3Nf+v1Q1tLPuHfyewx38ow/92W/c1+3M+4d7iHcyTMx3MkzMdyZv8dwZ/4ew5387s7dcAtmXcjvMdyZv8dwZ/4ew52+GsO9wz2EO301hjt9NYY7fTWGO301hjt9NYT7Sl+N4U5fjeFOX43hTl+N4d7hHsKdvhrDnb4aw52+auP+wU9ubb598/h+9XQcH/3kJ5dotyO4RBcewKWN5jyCS/TsH3XpiTxNO4o8XTuKfId8EHn6dhR5GncUeTp3FHl6dBR5unEQ+Z2+G0WeDnsB+f1Bfp7W38j/4X0st35/H8vy9Op1e/aJxjuGT/TjYJ+8txXsHUeLOUqfr+Yoc4JqjjJ/qOYoc41qjjIvKebowRymmqPMd6o5yiSomqPMjKo52nG0mKPMjKo5ysyomqPMjKo5ysyomqPMjGo5ut2YGVVzlJlRNUeZGVVzlJlRNUc7jhZzlJlRNUeZGVVzlJlRNUeZGVVzlJlRMUcnZkbVHGVmVM3RjqPjOGq4Q7lN9NFqjpJ1R3L0/W21bSLrFnO0kXWrOUrWreYovx+t5ii/H63maMfRcRw17HXfGn20mqP8frSao/x+tJqjzIyqOcrMqJijMzOjao4yM6rmKDOjao4yM6rmaMfRYo4yM6rmKDOjao4yM4p29JP3vEwPHEs72Wu+zUyN6nnK3Kicp53JUT1PmR3V85TpUT1PmR/V87Tj6aCezvOZp8yQ6nnKFKmep8yRhvJ0Xh6e9v3MU+ZI9TxljlTO04U5Uj1PmSPV85Q5Uj1PmSPV87Tj6aCeLsuZp8yR6nnKHKmep8yR0nr65BKToRFcYtbj79I87Q+Xlv7GpWm59e/PvLPfW67Mb8bwiZlMsE/eezNXJjLVHGUeU83RjqPFHGUWU81RJjHVHGUOU81RZjbVHGW+U8zRjUlQNUeZGVVzlJlRNUeZGVVztONoMUeZGVVzlJlRNUeZGVVzlJlRNUeZGRVzdGdmVM1RZkbVHGVmVM1RZkbVHO04WsxRZkbVHGVmVM1RZkbVHGVmVM1RZkbFHD3oowM5uvT267VLP3WUPlrNUbLuSI4arqIfZN1qjpJ1qzlK1q3l6H7j96PVHOX3o9UcpY8O5KjhruB+o49Wc7TjaDFH+f1oNUeZGVVzlJlRNUeZGVVzlJlRMUcnZkbVHGVmVM1RZkbVHGVmVM3RjqPFHGVmFO3oJ+/Zcjd7n5ga1fOUuVE9T5kc1fOU2VE5TxvTo3qeMj+q5ykTpFE9neczT5kh1fO042k5T5kjDeWp4W723pgj1fOUOVI9T5kj1fOUOVI5T2fmSPU8ZY5Uz1PmSKN6uixnnjJHqudpx9NynjJHSuvpk0tMhkZwiVnPBS4t68OlY33j0tHuf615bNOTvtuzS0xvRnCJeUywS847M/fONKaao8xiqjnKJKaao8xhqjnacbSYo8xgqjnKvKaao8x2qjnKHKiao8yMijm6MDOq5igzo2qOMjOq5igzo2qOdhwt5igzo2qOMjOq5igzo2qOMjOq5igzo2KOrsyMqjnKzKiao8yMqjnKzKiaox1HiznKzKiao8yMqjnKzKiYoxt9dCBHl95+vXbpp47SR6s52nF0IEcNF9E3sm41R8m61Rwl61ZzlN+PVnOU348Wc3Snjw7kqOWm4E4freYovx+t5ii/H63maP9fOFrLUWZG1RxlZlTNUWZG1RxlZlTNUWZGxRw9mBlVc5SZUTVHmRlFO/rBTz4ef5VyPN9m+G0H9sHMqJqjHUeLOcrMqJqjzIyqOcrMqJqjzIyqOcrMaCRHl/trj+32Z0ePGzOjao4yM6rmKDOjao4yM6rmaMfRYo4yM6rmKDOjtI4+ucQcaASXmO1c4NLxuHXdp+mNS+3rh3y/uv326iefmNgM4dPEHCbcp2+blpNPvYnZygguMS8ZwSVmICO41HFpAJeYVYzgEvOHaJeW5f7ibTpzifnDCC4xfxjBJaYPA7jUmD2M4BKzhxFcYvYwgkvMHkZwqePSAC4xexjBJWYPI7jE7GEEl5g9/EuXnlgyIXBjOdPj/VjStv1Y0on9WNJc/Vh2WLqxpAX6saSr+bGkUfmxpPf4saT3uLHs9J4/sHziI9xltvbgs29v/rc2fXG4v3qa+9n/2oTbzAU0hfvMBTQ7NB1pCneaC2gKt5oLaAr3mgtoCjebC2gKdxt/motwu7mAJl3IkyZdyJMmXciTZoemI026kCdNupAnTbqQJ026kCdNupAjzZUu5EmTLuRJky7kSZMu5EmzQ9ORJl3IkyZdyJMmXciTJl3IkyZdyJHmRhfypEkX8qRJF/KkSRfypNmh6UiTLuRJky7kSZMu5EmTLuRJky7kSHOnC3nSpAt50qQLedKkC3nS7NB0pEkX8qRJF/KkSRfypEkX8qRJF3KkedCFPGnShTxp0oU8adKFPGl2aDrSpAt50qQLedKkC3nSpAt50qQLudGcbze6kCdNupAnTbqQJ026kCfNDk1HmnQhT5p0IU+adCFPmnQhT5p0IUeaE13IkyZdyJMmXciTJl3Ik2aHpiNNupAnTbqQJ026kCdNupAnTbqQI81GF/KkSRfypEkX8qRJF/Kk2aHpSJMu5EmTLuRJky7kSZMu5EmTLuRIc6YLedKkC3nSpAt50qQLedLs0HSkSRfypEkX8qRJF/KkSRfypEkXcqTZ6UKeNOlCnjTpQp406UKeNDs0HWnShTxp0oU8adKFPGnShTxp0oUcaS50IU+adCFPmnQhT5p0IU+aHZqONOlCnjTpQp406UKeNOlCnjTpQo40V7qQJ026kCdNupAnTbqQJ80OTUeadCFPmnQhT5p0IU+adCFPmnQhR5obXciTJl3IkyZdyJMmXciTZoemI026kCdNupAnTbqQJ026kCdNupAjzZ0u5EmTLuRJky7kSZMu5EmzQ9ORJl3IkyZdyJMmXciTJl3IkyZdyJHmQRfypEkX8qRJF/KkSRfypNmh6UiTLuRJU6QLPSkW6StPikU6xZNikdz/UPwlTU6xSH5+UiyScZ8Ui+TQJ8VdTrFInntSrJa5JpUb9E+KB85cTyoGzlHfKka+i/6kYuC886Ri4AzzpGLgXPKkopdQMXB+eFIxcCZ4UjHwc/5JRYln98j3hL9VjHzH90lFiWf3yHdrn1SUeHaPfKf1SUWJZ/fId0mfVJR4do98h/NJRYln98h3J59UZH92H/dXfw06pvabir/8rfCU/irjFZqz54IrNHdBzdkzxxWasyeUKzRnzzNXaM6efq7QnD0rXaA5/RW7KzQL5rD0F+Gu0CyYw9JfV7tCs2AOS3+p7ArNgjks/dWvKzQL5rD0F7Su0CyYw9Jfo7pCs2AOS3/Z6QrNgjks/ZWkKzQL5rD0F4eu0CyYw9Jf77lCs2AOS38J5wrNgjks/VWZKzQL5rD0F1qu0CyYw9JfO7lCs2AOS3855ArNgjks/RWOKzQL5rD0Fy2u0CyYw9Jfh7hCs2AOS39p4QrNgjks/dWCKzQL5rD0FwCu0CyYw9Jv079Cs2AOS7+Z/grNgjks/Zb3KzQL5rD0G9Ov0CyYw9JvH79Cs2AOS7/J+wrNgjks/VbsKzQL5rD0m7Gv0KyXw1r67dhXaNbLYS39huwrNOvlsHbrgpr1clhLvyn7Cs16Oayl35Z9hWbBHJZ+E/cVmgVzWPot31doFsxh6TeIX6FZMIel305+hWbBHJZ+8/kVmgVzWPqt6ldoFsxh6Te2X6FZMIel3wZ/hWbBHJZ+0/wVmgVzWPot9ldoFsxh6TfkX6FZMIcJ7tNvgvv0m+A+/Sa4T78J7tNvgvv0m+A+/Sa4T78J7tNvgvv0m+A+/Sa4T78J7tNvgvv0m+A+/Sa4T78J7tNvgvv0m+A+/Sa4T78J7tNvgvv0m+A+/Sa4T78J7tNvgvv0m+A+/Sa4T78J7tNvgvv0m+A+/Sa4T78J7tNvgvv0m+A+/Sa4T78J7tNvgvv0m+A+/Sa4T78J7tNvgvv0m+A+/ZZpn/7Tu0qUlJ7eVaIs8/SuEqWNp3eVKA98v6tMm9ef3lWiZ+rTu0r01Ht6V4meS0/vKtGT4+ldpfxsz7RF++ldpfxsz7SJ+uldpfxsz7TN+eldpfxsz7QR+eldpfxsz7RV+Oldpfxsz7SZ9+ldpfxsz7Td9uldZfxsnzNtiH16Vxk/2+dMW1af3lXGz/b5lvGzfc60S/TpXWX8bJ8z7eN8elcZP9vnq3dafv9LV2+SfPqXph/7l9qP/Uvzj/1L/cf+peXH/qX1x/6l7cf+pf3H/qUf+4xoP/YZ0X7sM6L92GdE+7HPiPZjnxHtxz4j2o99RrQf+4xoP/YZ0X7sM2L+sc+I+cc+I+Yf+4yYf+wzYv6xz4j5xz4j5h/7jJh/7DNi/rHPiPnHPiP6j31G9B/7jOg/9hnRf+wzov/YZ0T/sc+I/mOfEf3HPiP6j31G9B/7jFh+7DNi+bHPiOXHPiOWH/uMcPlGatv641/aj9/+pb/8K7nZ5VujV7yvNen72pK+rz3p+zpyvi+Xbxpe8b6mpO+rJX1fc9L3lfTzfk36eb8m/bxfk37er0k/79ekn/db0s/7Lenn/Zb0835L+nm/Jf2835J+3m9JP++3pJ/3W9LP+y3p5/2e9PN+T/p5vyf9vN+Tft7vST/v96Sf93vSz/s96ef9nvTzfk/6eX8k/bw/kn7eH0k/74+kn/dH0s/7I+nn/ZH08/5I+nl/JP28P3J+3vdbzs/7fsv5ed9vOT/v+y3n532/5fy877ecn/f9lvPzvt9yft73W87P+35L+nk/Jf28n5J+3k9JP++npJ/3U9LP+ynp5/2U9PN+Svp5PyX9vJ+Sft63pJ/3LennfUv6ed+Sft63pJ/3LennfUv6ed+Sft63pJ/3Lenn/Zz0835O+nk/J/28n5N+3s9JP+/npJ/3c9LP+znp5/2c9PN+Tvp535N+3vekn/c96ed9T/p535N+3vekn/c96ed9T/p535N+3vekn/dL0s/7Jenn/ZL0835J+nmf9Pu1Pen3a3vS79f2pN+v7Um/X9uTfr+2J/1+bU/6/dqe9Pu1Pen3a3vS79f2pN+v7Um/X9uTfr+2J/1+bU/6/dqe9Pu1Pen3a3vS79f2pN+v7Um/X9uTfr+2J/1+bU/6/dqe9Pu1Pen3a3vS79f2pN+v7Um/X9uTfr+2J/1+bU/6/dqe9Pu1Pen3a3vS79f2pN+v7Um/X9uTfr+2J/1+bU/6/dqe9Pu1Pen3a3vS79f2pN+vXa/ecP3fr/7wAvo8P97IsS3f7+SPF9A/+tnbbb3/6G25fb+6z//yJ7d5uf/kNh/r93s+jj/95P14/OT25icvvf167dLnM0cTXYPDURdHE13Sw1EXRzuOFnM00QVHHHVxNNH1Sxx1cTTR5VAcdXE00dVVHHVxNNE1chz1cPTqSzw4+uOOMjOq5igzo5Ec3W93R4/lzFFmRtUc7ThazFFmRtUcZWY0kqPbt6PrmaPMjKo5ysyomqPMjIo5ujIzquYoM6NqjjIzGsnRZb87um5njjIzquZox9FijjIzquYoM6NqjjIzquYoM6NqjjIzKuboxsyomqPMjKo5ysyomqPMjKo52nG0mKPMjKo5ysyomqPMjKo5ysyomqPMjIo5ujMzquYoM6NqjjIzquYoM6NqjnYcLeYoM6NqjjIzquYoM6NqjjIzquYoM6Nijh7MjKo5ysyomqPMjKo5ysyomqMdR4s5ysyomqPMjKo5ysyomqPMjKo5ysyolqPbjZlRNUfpoxc4Ou0PR5fu6ej7HdjbreNoMUfpo9UcpY9Wc5Q+Ws1R+mg1R+mjxRyd6KPVHOVvGKo5yt8wVHOUmVE1RzuODuTo+ws+28TMqJqjzIyqOcrMqJqjzIxGcvT9dZBtYmZUzNHGzKiao8yMqjnKzKiao8yMqjnacXQgRw1/C9iYGVVzlJlRNUeZGVVzlJlRNUeZGRVzdGZmVM1RZkbVHGVmVM1RZkbVHO04WsxRZkbVHGVmVM1RZkbVHGVmVM1RZkbFHO3MjKo5ysyomqPMjKo5ysyomqMdR4s5ysyomqPMjKo5ysyomqPMjKo5ysyomKMLM6NqjjIzquYoM6NqjjIzquZox9FijjIzquYoM6NqjjIzquYoM6NqjjIzKuboysyomqPMjKo5ysyomqP0UX9H22PF5pe5rpfwDDuwV/poNUfpo9UcpY9Wc5Q+WszRjT5azVH6aDVH6aPVHOVvGKo52nG0mKPMjKo5ysxoJEcNF3w2ZkbVHGVmVM1RZkbFHN2ZGY3kqOE6yM7MqJqjzIyqOcrMqJqjHUeLOcrMqJqjzIxGctTwt4A7M6NqjjIzquYoM6Nijh7MjKo5ysyomqPMjKo5ysyomqMdR4s5ysyomqPMjKo5ysyomqPMjKo5ysyolqP7jZlRNUeZGVVzlJlRNUeZGVVztONoMUeZGVVzlJlRNUeZGVVzlJlRNUeZGRVzdGJmVM1RZkbVHGVmVM1RZkbVHO04WsxRZkbVHGVmVM1RZkbVHGVmVM1RZkbFHG3MjKo5ysyomqPMjKo5ysyomqMdR4s5Sh+1Oeq7qXpvtMYY7nS7EO4zDSyGOz0phjttJoY7nSOGe4d7CHd+5xvDnd/MxnCnr8Zwp6/6c39/iWOf6ash3Dt9NYY7fTWGO33Vn/v77fN7p6/GcO9wD+FOX43hTl+N4U5fjeFOX/Xnbvh7gk5fDeG+0FdjuNNXY7jTV2O401djuHe4h3Cnr8Zwp6/GcKevxnCnr8Zwp6+GcF/pqzHc6asx3OmrMdzpqzHcO9xDuNNXY7jTV2O401djuNNXY7jTV0O4b/TVGO701Rju9NUY7vTVGO4d7iHc6asx3OmrMdzpqzHc6asx3OmrIdx3+moMd/pqDHf6agx3+moM9w73EO701Rju9NUY7rXyu/NWpKNWyvamUysLe9OplVi96dTKld50OnRe0KmV0bzp1EpS3nRqzee96dSaonvTISuf0zluuln5/f6946ablS10dLOyhY5uVrbQ6bJ03u/JOm66WdlCRzcrW+joZmULHd2sbKGjm5UNdCbdrPz+dxLHpJuVLXR0s7KFjm5WttDp0HlBRzcrW+joZmULHd2sbKGjm5UtdHSzsoFOIyu/okNWfkWHrPyKDln5FZ0OnRd0yMqv6JCVX9EhK7+iQ1Z+RYes/ILOTFZ+RYes/IoOWfkVHbLyKzodOi/okJVf0SErv6JDVn5Fh6z8ig5Z+QWdYhfgvemQlV/RISu/okNWfkWnQ+cFHbLyKzpk5Vd0yMqv6JCVX9DJfud3X/dvOrftHZ0PfvbX/+/jXa/7018sz8ef3smx3H/0dBzP72P5ty4ZvmOY/SowLv3jUvL8h0v/uNRxaQCXkudhXPrHpeS5HJf+cSl5P8Clf1xK3lNw6R+Xkv9uAZf+41L2K8y49I9LzB5GcInZQ7RLhm0w2e9B49I/LnVcGsAlZg8juMTsIdolw8aX7Hescekfl5g9jOASs4cBXMp+URuX/nGJ2cMILjF7iHbJ8DdE2W9749I/LnVcGsAlZg8juMTsYQSXmD2M4BKzhxFcYvYwgEvZr6Pj0j8uMXsYwSVmDyO4xOxhBJc6Lg3gErOHEVxi9jCCS8weRnCJ2cMILjF7GMClg9nDCC4xexjBJWYPI7jE7GEElzouDeASs4cRXGL2MIJLzB5GcInZwwguMXtI71K/3Zg9jOASs4cRXGL2MIJLzB5GcKnj0gAuMXsYwSVmDyO4xOxhBJeYPYzgErOHAVyamD2M4JJuX1rW28Ol2/TOpXm7g5/6cvt+dT/+SP7+4mV7+slfjj6R75APIq/ba6LJ63aVaPK6/SOavG6nuJL8sfx68Xpbzsjr9oRg8k03+0eT1/1dYjR53d8PXkp+epBfz8jTYaPId8gHkafDRpGnw0aRp8NGkafDXkF+f1wZ2vcz8nTYIPIzHTaKPB02ijwdNoo8HTaKfId8EHk6bBR5OmwUeTpsFHk6bBR5OmwQ+U6HjSJPh40iT4eNIk+HjSLfIR9Eng4bRZ4OG0WeDhtFng4bRZ4OG0R+ocNGkafDRpGnw0aRp8NGke+QDyJPh40iT4eNIk+HjSJPh40iT4cNIr/SYaPI02GjyNNho8jTYaPId8gHkafDRpGnw0aRJ8/byLep399I27d35A07nTbyfBR58nwUefJ8FHnyfBT5DvkLyBs2Tmzk+Sjy5Pko8vxOKoo8v5OKIk+HDSK/02GvIG+Y2+x02CjydNgo8nTYKPId8kHk6bBR5OmwUeTpsFHk6bBR5OmwQeQPOmwUeTpsFHk6bBR5OmwU+Q75IPJ02CjydNgo8nTYKPJ02CjydNgY8l+IIR9Eng4bRZ4OG0WeDhtFvkM+iDwdNoo8HTaKPB02ijwdNoo8HTaI/ESHjSJPh40iT4eNIk+HjSLfIR9Eng4bRZ4OG0WeDhtFng4bRL7p5vlpXx7v+j/8XpI3bO+Ymm5C92epm7n9WXZYurHUzcX+LHWT7mcsj/uL19tyxlI3u/qz1E2j/ix1f0fiznLW/a3HhyzfbqOZZnqPH0t6jx9Leo8fyw5LN5b0Hj+W9B4bS8P8cqb3+LGk9/ixpPe4sez0Hj+W9B4/lvQeP5b0Hj+WHZZuLOk9fizpPX4s6T1+LOk9fizpPW4sF3qPH0t6jx9Leo8fS3qPH8sOSzeW9B4/lvQeP5b0Hj+W9B4/lvQeN5YrvcePJb3HjyW9x48lvcePZYelG0t6jx9Leo8fS3qPH0t6jx9Leo8by43e48eS3uPHkt7jx5Le48eyw9KNpW6+vM13je129HcsDXsNNt186c9SN1+6s9x186U/S9186c9SN19+xtKwI2LXzZf+LDss3VjqztX9WerO1T9k+f67+Du9x48lvcePJb3HjeVB7/FjSe/xY0nvsbE0zC8Peo8fyw5LN5b0Hj+W9B4/lvQeP5b0Hj+W9B4vlu1G7/FjSe/xY0nv8WNJ7/Fj2WHpxpLe48eS3uPHkt7jx5Le48eS3uPGUvg6vD9Leo8fS3qPH0t6jx/LDks3lvQeP5b0Hj+W9B4/lvQeP5b0HjeWjd7jx5Le48eS3uPHkt7jx7LD0o0lvcePJb3HjyW9x48lvcePJb3HjeVM7/FjKZsvp/2BZzr6/o7l+70GTff++AUsZfPlBSxl8+UFLGXz5QUsZfPlhyzf74houvfH/Vnq3h+/gKXsXP0ClrJz9U9Zvv0uftO9P34Byw5LN5b0Hj+W9B4/lvQeP5b0HhtLw/xS9/64P0vd++MXsKT3+LGk9/ixpPf4seywdGNJ7/FjSe/xY0nv8WNJ7/FjSe9xY6l7f/wClvQeP5b0Hj+W9B4/lh2WbizpPX4s6T1+LOk9fizpPX4s6T1uLHXvj1/Akt7jx5Le48eS3uPHssPSjSW9x48lvcePJb3HjyW9x48lvceN5U7v8WNJ7/FjSe/xY0nv8WPZYenGkt7jx5Le48dSN19ut/X+o7fteMfSsNdA9/74BSx186U/S9186c9SN1/6s+ywNLE0fLdU9/74BSx186U/S925uj9L3bm6P0t6jxfLWff++Ics3/fxWff++AUs6T1+LOk9fiw7LN1Y0nv8WNJ7/FjSe/xY0nv8WNJ73Fjq3h+/gCW9x48lvcePJb3Hj2WHpRtLeo8fS3qPH0t6jx9Leo8fS3qPG0vd++MXsKT3+LGk9/ixpPf4seywdGNJ7/FjSe/xY0nv8WNJ7/FjSe9xY6l7f/wClvQeP5b0Hj+W9B4/lh2WbizpPX4s6T1+LOk9fizpPW4si90f34/Hz25vfvbSH3T67+/jiU6txOhNp1YG9KbTofOCTq2c5k2nVvLyplMrS3nTqZWOvOnUmvM60yl24dqbDln5FR3drLzf7nSO5YyObla20OnQeUFHNytb6Ohm5e2bznpGRzcrW+joZmULHd2sbKBT7CqyNx3drGyho5uVl/tPXtbtjI5uVrbQ6dB5QUc3K1vo6GZlCx3drGyho5uVLXR0s7KBTrFLut50dLOyhQ5Z+RUdsvIrOh06L+iQlV/RISu/okNWfkWHrPyKDln5BZ1i11e96ZCVX9EhK7+iQ1Z+RadD5wUdsvIrOmTlV3TIyq/okJVf0SErv6BT7JKsNx2y8is6ZOVXdMjKr+h06LygQ1Z+RYes/IoOWfkVHbLyKzpk5XM6vdj1UW86yfPONn/T2eflDZ1ju39f79jmM8VdTnHyXHKB4uRZ4wLFyfPDBYqTZ4LPFH+979vj5e1489OP/f6zj+P0kz15Kojmk/06Xzif5FO0cD7J52jhfEolywv4dPi85FMqtX7G55OWd/6un1iWysPBLEsl7WCWwhnenaVw3vdmmf2C3VAshXuEO0vhzuHOUrifuLPssHRjSe/xY0nv8WNJ7/FjSe/xY0nvcWOZ/YLdUCzpPX4s6T1+LOk9fiw7LN1Y0nv8WNJ7/FjSe/xY0nv8WNJ73Fh2eo8fS3qPH0t6jx9Leo8fyw5LN5b0Hj+W9B4/lvQeN5bZL+hlYWm4t9ez39sbiiXPHhtLwzdps99jG4olzx4/lszc/Fgyc3Njmf2O3FAsyZcmluu0/nrtOrczluRLP5bM3PxYdli6saT3+LGk9/ixpPf4saT3+LGk97ixzH4TcCiW9B4/lvQeP5b0Hj+WXZjlJ+9kbo+fPD//5Gl6pqncfPxpKncff5rK7cefpnL/8aep3IDcaWa/9TgYTeUW9BHNpT1ortMZTeUe5E9TuQn50+zQdKRJF/KkSRfypEkX8qRJF/oLmvsZTbqQI83stzwHo0kXMtI8vpvlcdYss98KHYwmXciTZoemI026kCdNupAnTbqQJ0260P999V3d7NdUg/ks2e+phvOhgbzmQ6d4zYeW8JpPh89LPrWu/b6/FLcUu/ZrUVzr2q9FcanUalJcKodaFNe6yGtSXCormhSXSn8mxaXynElxl1Msl7lqXZQ1KZbLXLWus5oUy2WuWpdOTYrlMletq6EmxXKZq9YFTpNiucxV65qlSbFc5qp1GdKkWC5z1bqyaFIsl7lqXSw0KZbLXLWu/5kUy2WuWpf0TIrlMletq3QmxXKZq9aFN5NiucxV61qaSbFc5qp1ecykWC5z1briZVIsl7m6XObqcplrkctcte68mRTLZa5FLnMtXU6xXOaqdb3OpFguc9W6BGdSLJe5al1VMymWy1y1LpSZFMtlrlrXvkyK5TJXrctZJsVymavWFSqTYrnMVeuik0mxXOaqdR3JpFguc9W6NGRSLJe5al3sMSmWy1y1Lt+YFMtlrloXZEyK5TJXrUssJsVymavWRROTYrnMVesyiEmxXOaqdWHDpFguc9W6VGFSLJe5al18MCmWy1y1LieYFMtlrloXCEyK5TJXrU3+JsVqmWuttW3fpFgtc621NuKbFKtlrvXW5RSrZa5Vbg/9KreHfpXbQ7/K7aFf5fbQr3J76Fe5PfSr3B76VW4P/Sq3h36V20O/1tpR/uH9q/14vJP25rVLv58LX/p8wrLW9vNglsp3D71ZKt9I9GapfE/Rm2WHpRtL5Yvr3iyV7617s1S+tu7NUvnWujdLeo8by1oXCC5kud9/8HIsZyzpPX4s6T1+LOk9fiw7LE0st2+W6xlLeo8fS3qPH0t6jx9Leo8fS3qPG8taV0AuZLnc38eynv0estZ9kWCW9B4/lvQeP5Ydlm4s6T1+LOk9fizpPX4s6T1+LOk9bixrXeIJZknv8WNJ7/FjSe/xY9lh6caS3uPHkt7jx5Le48eS3uPHkt7jxrLWNaxglvQeP5b0Hj+W9B4/lh2WbizpPX4s6T1+LOk9fizpPX4s6T1uLGtdpAtmSe/xY0nv8WNJ7/Fj2WHpxpLe48eS3uPHkt7jx5Le48Yy+12/ZV8fb2Q9jjcsj+2+feDY5jPFyVPgBYqTZ7ULFHc5xclzzwWKk6eTzxR/9hSwbOrMfgUwnE/yFBHOJ/lENJpP9nuE4XxKJcsL+JTKoRfwKZVar2t55+/6iWWHpRvLUkk7mKVwhndnKZz33VkKdwN3lsI9wpnllv0e51AshfuJO0vhLuPOkt7jx7LD0o0lvcePJb3HjyW9x48lvcePJb3HjWX2m7hDsaT3+LGk9/ixpPf4seywdGNJ7/FjSe/xY0nv8WNJ7/FjSe9xY5n9QvhQLOk9fizpPX4s6T1+LDss3VjSe/xY0nv8WNJ7/FjSe/xY0nvcWGa/HpyFpeHa+pb9evBQLHn22Fi+3zywZb/SOhRLnj1uLLNfaR2KJTM3P5bM3PxYki9NLNfp/j7WuZ2x7LB0Y8nMzY8lMzc/lvQeP5b0Hj+W9B43ltmvtA7Fkt7jx5Le48eS3uPHssPSjSW9x4+lcu/54J30db5r7OsTkTZNzzSVm48/TeXu409Tuf2408x+rXUwmsoNyJ+mcgfyp6ncgj6iuS4Pmls/o9mh6UhTuQn506QLedKkC3nSpAt50qQLOdLMfsE1Jc19OqNJF/KkSRfypEkXstHcbo9muU1nzTL7JdfBaNKFPGnShTxp0oU8adKFPGnShRxp7nQhI83H2eP//MHwGU26kCdNupAnTbqQJ80OTUeadCFPmnQhT5p0of/7apuJ8qVpEx/6yks+ypemTXzoFK/50BJe8yH3v+bTK/Ex3B7fat14NikulYhNikulVpPiUjnUpLhUsjQo3mtdCDYpLpX+TIpL5TmT4lIJzaS4yylWy1x7rSuwJsVqmWuvdVHVpFguc9W6TmpSLJe5al36NCmWy1y1rmaaFMtlrloXKE2K5TJXrWuOJsVymavWZUSTYrnMVevKoEmxXOaqdbHPpFguc9W6fmdSLJe5al2SMymWy1yzXOaa5TLXLJe5at0aNCnucorlMtcsl7lq3WY0KZbLXLXuHFoU17pGaFIsl7lqXfYzKZbLXLWu5JkUy2WuWhfnTIrlMlet620mxXKZq9YlNJNiucxV66qYSbFc5qp1ocukWC5z1bp2ZVIsl7lqXY0yKZbLXLWuL5kUy2WuWleMTIrlMleta0AmxXKZq9ZVHZNiucxV6zqNSbFc5qp15cWkWC5z1bqWYlIsl7lqXR0xKZbLXLWud5gUy2WuWlcwTIrlMletaxImxXKZq9ZVBpNiucxV67qBSbFc5qp1JcCkWC5z1drNb1Isl7lq7c83KZbLXLV23JsUy2UuuT30u9we+l1uD/0ut4d+l9tDv8vtoT/k9tAfcnvoD7k99IfcHvrj1uUUq2WuQ24P/SG3h/6Q20N/yO2hP+T20B9ye+gPuT30h9we+kNuD/0ht4f+kNtDf8jtoT/k9tAfcnvoD7k99IfcHvpDbg/9IbeH/pDbQ3/I7aE/5PbQH3J76A+5PfSH3B76Q24P/SG3h/6Q20N/yO2hP+T20B9ye+gPuT30h9we+kNuD/1Ra0f51/u+PV7ejjc/fduPxztpb1679PbrtUufz1iWetIHsyyVIYJZdli6sSyVe4JZlkpUwSxLZbVglqVSYDDLUjO9WJa1tvkHs6T3+LGk99hY7vcfvBzLGUt6jx/LDks3lvQeP5b0HhvL7ZvlesaS3uPHkt7jx5Le48ay1kWNYJb0Hj+W9B4by+X+e8hlPfs9ZK37IsEsOyzdWNJ7/FjSe/xY0nv8WNJ7/FjSe9xY1rpqE8yS3uPHkt7jx5Le48eyw9KNJb3HjyW9x48lvcePJb3HjyW9x41lrctSwSzpPX4s6T1+LOk9fiw7LN1Y0nv8WNJ7/FjSe/xY0nv8WNJ73FjWuu4WzJLe48eS3uPHkt7jx7LD0o0lvcePJb3HjyW9x48lvcePJb3HieVyq3VhMZhl8nzZ+/cbWfrbDXbbffvAsc1niruc4uRZ7QLFyRPVBYqT554LFCdPJ58p/uwp8H5T5xef5Ikjmk/2m4HhfJJPRMP5JJ9yhvMplSwv4NPh85JPqdR6Xcs7f9dPLEvl4WCWpZJ2MEvhDO/OUjjve7PMfttyKJbCPcKdpXDncGcp3E/cWXZYurGk9/ixpPf4saT3+LGk9/ixpPe4scx+X3YolvQeP5b0Hj+W9B4/lh2WbizpPX4s6T1+LOk9fizpPX4s6T1uLDu9x48lvcePJb3HjyW9x49lh6UbS3qPH0t6jx9Leo8fS3qPH0t6jxvL7BfCh2JJ7/FjSSYysXx/bf2LJZnIjyXPHhtLw+aB7Fdah2LJs8ePJTM3P5bM3PxYdli6sSRfmliu032T0Tq3M5bkSz+WzNz8WDJz82NJ73Fjmf1K61As6T1+LOk9fizpPX4sOyzdWNJ7/FjSe/xY0nv8WCr3ng/eyb5Nd4371p40TtMzTeXm404z+6XWwWgqtx9/msr9x5+mcgPyp9mh6UhTuQV9RLMvD5pLP6Op3IP8aSo3IX+adCFPmnQhR5rZr7cORpMu5EmTLvQ5zXU6o0kX8qTZoelIky5kpLl/N8ujndGkC3nSpAt50qQLedKkC/nRnLJfdB2MJl3IkyZdyEZzb4+8uc/9jCZdyJNmh6YjTbqQJ026kCdNupAnTbqQJ0260Oc0+8lEblK+S30BTbqQJ0260B/eyRMf2s1rPh0+L/nQQF7zoVO85kNLeM2H3P+aT6kkf+z3TTDHcbIJZqp16dmkuFQiNikulVpNikvlUJPiLqe4VFY0KS6V/kyKS+U5k+JSCc2kWC5z1boya1Isl7lqXWw1KZbLXLWun5oUy2WuWpdETYrlMletq5wmxXKZq9aFS5NiucxV61qkSbFc5qp1edGkWC5z1bpiaFIsl7lqXQQ0KZbLXLWu65kUy2WuRS5zLXKZa+lyiuUyV60riSbFcplrkctcte5VWhTXuippUiyXuWpdaDQplstcta4dmhTLZa5alwNNiuUyV60rfCbFcpmr1kU7k2K5zFXrOpxJsVzmqnVpzaRYLnPVulpmUiyXuWpdADMplstctS5pmRTLZa5aF6lMiuUyV63LTibFcpmr1oUkk2K5zFXr0pBJsVzmqnWxx6RYLnPVunxjUiyXuWpdkDEplstctS6xmBTLZa5aF01MitUyV6t1GcSkWC1ztVoXNkyK1TJXu3U5xWqZq9W6+GBSrJa5Wq3LCSbFcpmr1gUCk2K5zFVrk79JsVzmqrVt36RYLnPV2ohvUiyXuWptrTcplstccnvom9we+ia3h77J7aFvcnvom9we+ia3h77J7aFvcnvom9we+ia3h77J7aFvcnvom9we+ia3h77J7aFvcnvom9we+ia3h77J7aFvcnvom9we+ia3h77J7aFvcnvom9we+ia3h77J7aFvcnvom9we+ia3h77J7aFvcnvom9we+ia3h77J7aFvcnvom9we+ia3h77J7aFvcnvom9we+ia3h77J7aFvtXaUf73v2+Pl7Xjz07f9eLyT9ua1S2+/Xrv0+YxlqSd9MMtSGSKYZal0Esuy1i74YJalElUwy1JZLZhlqRQYzLLD0o1lqWlhMEt6jx9Leo+N5X7/wcuxnLGk9/ixpPe4sax1jyGYJb3HxnL7ZrmesaT3+LGk9/ix7LB0Y0nv8WNJ7/FjSe+xsVzuv4dc1rPfQ9a6LxLMkt7jxrLWTZRglvQeP5b0Hj+W9B4/lh2WbizpPX4s6T1+LOk9fizpPX4s6T1eLOdad4mCWdJ7/FjSe/xY0nv8WHZYurGk9/ixpPf4saT3+LGk9/ixpPe4sax1GyyYJb3HjyW9x48lvcePZYelG0t6jx9Leo8fS3qPH0t6jx9Leo8by1r3+YJZ0nv8WNJ7/FjSe/xYdli6saT3+LFMni+nbf6Gs73dYLfdtw8c23ymOHkK9Fec/a7fBYqTJ6oLFCfPPRcoTp5OPlP82VPAsKlzzn4FMJxP8hQRzif5RDScT/IpZzifUsnyAj6lcqg/n+yXEa/k80nLO3/XTyxL5eFglqWSdjBL4QzvzrLD0o2lcDdwZyncI9xZCncOd5bC/cSdpXCX8WaZ/TrpUCzpPX4s6T1+LOk9fiw7LN1Y0nv8WNJ7/FjSe/xY0nv8WNJ73FhmvxA8FEt6jx9Leo8fS3qPH8sOSzeW9B4/lvQeP5b0Hj+W9B4/lvQeN5bZL4QPxZLe48eS3uPHkkxkYmm4Hjxnvx48EsvsV1rTsDR8kzb7ldahWPLs8WPJzM2PZYelG0tmbn4syZcmluu0/nrtOrczluRLP5bM3PxYMnNzY5n9SutQLOk9fizpPX4s6T1+LDss3VjSe/xY0nv8WNJ7/FjSe/xYKveeT95J2x5E2n77fnXbvmn27HdaB6Op3H38aSq3H3+ayv3Hn2aHpiNN5Q7kT1O5BX1Es+/fNKffaP73q4/5nmOP9eld7Mef3sXjd3Tb0b9fOz+bpFyvhjFJubcNYxKFML9J2e/iYtJ/TKK+DmASrXgAkyjbA5jUMSm/SYwGBjCJicMAJjFxsL2T+dbvP3l+fvVvQ7bsh5gHo0mHd6SZ/RjzYDRpxZ40qa+eNOmZnjQ7NG005/VBsy9nNGlunjSpWJ406UKeNOlCnjTpQo40ax07D6dJF/qc5rPG32nShTxp0oU8aXZovljh1pXPxZv40Fde86GBvOZDp3jNh5bwko/0uXgLn1JJ/tjvv/4+ju1Mcam0bVJcKhGbFHc5xaVyqElxqWRpUlwqK5oUl0p/JsWl8pxFca3D1ibFcpmr1pFok2K5zFXr4LJJsVzmqnW82KRYLnPVOgRsUiyXuWod1TUplstctQ7UmhTLZa5ax15NiuUyV63DqSbFcpmr1hFSk2K5zFXroKdJsVzmqnUc06RYLnNtXU6xXOaqdZjVpFguc21ymWuTy1y1DtmaFMtlrlpHYU2K5TJXrQOrJsVymavWsVKTYrnMVevwp0mxXOaqdUTTpFguc9U6SGlSLJe5ah13NCmWy1y1DiWaFMtlrlpHB02K1TLXUut8n0mxWuZaap3BMylWy1zLrcspVstcS62zbCbFaplrqXUwzKRYLnPVOmVlUiyXuWodWTIplstctc7/mBTLZa5ah2lMiuUyV61LLCbFcpmr1kUTk2K5zFXrMohJsVzmqnVhw6RYLnPVulRhUiyXuWpdfDAplstctS4nmBTLZa5aFwhMiuUyV61N/ibFcpmr1rZ9k2K5zFVrI75JsVzmqrW13qRYLnPJ7aFf5PbQL3J76Be5PfSL3B76RW4P/SK3h36R20O/yO2hX+T20C9ye+iXWjvKP7x/tR+Pd9LevPYrjv967VdMPWOpfMvQm6Xy3UNvlso3Er1ZKt9TdGZZa8t8MEvli+veLJXvrXuzVL627s2yw9KNJb3HjyW9x8Zyv//g5VjOWNJ7/FjSe/xY0nvcWNa69HAhy+2b5XrGkt7jx5Le48eS3uPHssPSjSW9x48lvcfGcrn/HvKr3pyxpPf4saT3+LGk97ixrHVtJZglvcePJb3HjyW9x49lh6UbS3qPH0t6jx9Leo8fS3qPH0t6jxvLWhePglnSe/xY0nv8WNJ7/Fh2WLqxpPf4saT3+LGk9/ixpPf4saT3eLFca10dC2ZJ7/FjSe/xY0nv8WPZYenGkt7jx5Le48eS3uPHkt7jx5Le48ay1uW/YJb0Hj+W9B4/lvQeP5Ydlm4sk+fLW1seb+S2r29YGrYPrNnv+l2gOHlW81ec/a7fBYqT554LFCdPJxcoTp4hLlCc/El/geLkc8gLFCefFl6gWC5zZb/r96Hi9ztb1ux3/fwVZ7/rd4HiWpnLorhW5nq/s2HNftfvAsVdTnGtzGVRXCtzWRTXylwWxbUyl2GWmf2un7/i7Hf9LlBcK3NZFNfKXBbFtTKXRXGXU1wrc1kU18pcFsW1MpdFsVzmyn7Xz19x9rt+FyiWy1zZ7/pdoFgucy1dTrFc5sp+YfECxXKZK/u1wgsUy2Wu7Jf/LlAsl7myX9G7QLFc5sp+ke4CxXKZK/t1twsUy2Wu7JfSLlAsl7myXx27QLFc5sp+wesCxXKZK/s1rAsUy2Wu7JelLlCc+nl87Mv9xcfX//uN3mO7/wX9sZ39BX3uWzgX6E39LL5Ab+on8QV6Uz+HL9Cb+in8md7po2+sH/v++NFnn+a5r62E00n9dA+nk3r6Ek4n9aQmnE6hFOlPJ/cdknA6hRLqdNkOmvP3/ESyUPYNJlkoVQeT7JB0Iimb7d1JyvYAd5KyncGdpGy/cCcp20WcSW6574gMRZKO40WSjuNFko7jRbJD0okkHceLJB3HiyQdx4skHceLJB3HiWTumyFDkaTjeJGk43iRpON4keyQdCJJx/EiScfxIknH8SJJx/EiScdxIpn7is9QJOk4XiRJQQaShpsgW+67L0OR5IljIfn+W4Vb7hsmQ5HkieNFkqmaF0mmal4kOySdSJInDSTXaf312nVuZyTJk14kmap5kWSq5kWSjuNEMvfNoKFI0nG8SNJxvEjScbxIdkg6kaTjeJGk43iRpON4kaTjeJGk4ziRzH2jayiSdBwvknQcL5K6HeeD99GOpd8VPu+lnI7+t9w73EO46/anWO66bSuWu243c+L+xFK3nfmz1O1n7ixzX/QbjKVuR/NnqdvS/FnS0/xYdli6saRP+bGkI/mxpPcY3sd8m+/HpObbfvuN5d/1zdzXLAtzp0+5c/f+vmPuK6B49I9H9L/8HtEr83tEX83vUcej9B7Rr/N7RG/P7xHzgPweMTvI7xFzhvQeVbpvXtYj5gz5PWLOkN8j5gz5Pep4lN4j5gz5PWLOkN8j5gz5PWLOkN8j5gzpPTqYM+T3iDlDfo+YM+T3iDlDfo/oR6EeWfbrH/Sj7B7tN3JdrEfvd13vN3Jdfo/Idfk9Itfl96jjUXqP+P1Rfo/oR6EeGb7Ht9/oR/k94vdH+T3i90fpPZqYM+T3iDlDfo+YM+T3iDlDfo86HqX3iDlDfo+YM+T3iDlDfo+YM+T3iDmDv0cf/ORpWu8vnqZt/X71cXtyqTFpGMElZg0juMS0YQSXmDeM4FLHpQFcYuYwgktMHX7QpSfuTBJiuDMdsHCfbvc/jJqnJ4V/vWl7bzT+EO4zHd6du/M3sPaZBp/fI/p7fo9o7/k96niU3iOae36P6O35PaLj5/eIeUB+j5gdpPeoM2fI7xFzhvweMWfI7xFzhvwedTxK7xFzhvweMWfI7xFzhvweMWfI7xFzhvQeLcwZ8nvEnCG/R8wZ8nvEnCG/Rx2P0nvEnCG/R8wZ8nvEnCG/R8wZ8nvEnCG9RytzhvweMWfI7xFzhvweMWfI71HHo/QeMWfI7xFzhvweMWfI7xFzhvweMWdI79HGnCG/R/SjUI8s11e3jkfpPSLXxXpkuHa3kevye0SuS+/RTq7L7xG/P8rvEb8/yu8R/SjUI8seyL3jUXqP+P1Rfo/4/VF+j5gz5PeIOUN+j5gzpPfoYM6Q3yPmDPk9Ys6Q3yPmDPk96niU3iPmDPk9Ys7g79EHP3nqD4VTf7o81ab1bx1lKlHNUWYY1Rxl4lHL0ePGfCSto08uMSEZwSVmJCO4xJRkBJc6Lg3gEpOSEVxiVjKCS8w/RnCJmUasS8tyZzct6/qbS3949Zcb91dPcz/rwEw1ynk6MdcYyNPWHqD7cuYoM5BqjjIvqeYos5VqjnYcLeYoM5tqjjLfqeYos6CRHF2WO+htOnOUuVE1R5kaxTq6zveVStP6/En6L6ZGjalRPU+ZGw3kqSUdNeZG1RxlblTN0Y6jxRxlblTNUeZG1RxlblTNUeZGIzlqmBs15kbFHJ2ZGsU6uj1+8peo6X88pkYzU6N6njI3GshTSzqamRtVc7TjaDFHmRtVc5S5UTVHmRtVc5S5UTVHmRuN5KhhbtSZG1VzlKlR8Gx3O74dbW8c3bb70Gjb16d38ZujzIyqOcrMqJqjHUdjn6PLY/q+PV9B+xez+s7UqJ6nzI0G8tTSSTtzo2qOMjeq5ihzo2KOLsyNqjnK3Kiao8yNqjnK3GgkRw3T+qXjaDFHmRrlcXT7/W/rn1xiDjSCS8x2RnCJeU2sS/vt/lia9mn/H485+cLEppynKzObgTy19MGVmU01R5nZVHOUmU01RzuOFnOUmU01R5nvVHOUWdBIjhom5Stzo2qOMjUq5ujGzKiao8yMqjnKzKiao8yMqjnacbSYo8yM8jjafr+m8+QSc6ARXGK2M4JLzGt+0KUn7kxVQrjvzD5M3Pc7j7m19Q13S7LamVDEcGeO4M5924/HT25//S6ePGIykN+jjkfpPaK95/eI7p7fI5p7fo/o7fk9ouOn9+hgHpDfI2YH+T1izpDfI+YM+T3qeJTeI+YM+T1izpDfI+YM+T1izpDfI+YMyT1av1ThUXqPmDPk94g5Q36PmDPk96jjUXqPmDPk94g5Q36PmDPk94g5Q36PmDOk92hizpDfI/pRqEdLb79eu/RTjzoepfeIXBfr0XL/ct7yfGXjd4/Idfk9Itel96iR6/J7xO+P8nvE74/ye0Q/CvVondZfr13nduZRx6P0HvH7o/we8fuj/B4xZ8jvEXOG/B4xZ0jv0cycIb9HzBnye8ScIb9HzBnye9TxKL1HzBn8PfrgJ0+3/f7i6ev9f7+63Z5dYtIwgkvMGkZwiWnDCC4xbxjApc7EYQSXmDmM4BJTh2CXHn/e8OXS9JtLf/rJ/deLt/35XTx3q86MopqjHUeLOcr8I9bRqX0/G/vps5H5xwguMf8YwSXmHyO4xPxjAJcW5h8juMT8YwSXmH8kcmk/c4mZxggudVwawCVmDz/o0hN3pgkx3JkPWLi35Zv72t9wt/yN10Ljj+FOh3fn3toDR19OuK+08hju9OwY7jTnGO504RjuHe4h3Omr/tyX5Y5jm86401djuNNXY7jTV2O401dDuG/01Rju9FUT9+O+zneeb4vDXGyjr8Zwp6+6c7f0pq3DPYQ7fTWGO301hjt9NYY7fTWGO33Vn7uhN+301Rju9NUY7vTVGO701RjuHe4h3OmrMdzpqxbu87w8uO/TG+7TcscxLf2MO301hjt91Z27953RnW6b3qODHpzfIzpzfo/o1/k9oovn96jjUXqP6Pj5PWIekN8jZgf5PWLOkN8j5gzZPfqShUfpPWLOkN8j5gz5PWLOkN+jjkfpPWLOkN8j5gz5PWLOkN8j5gz5PWLOkN6jiTlDfo+YM+T3iDlDfo+YM+T3qONReo+YM+T3iDlDfo+YM+T3iDlDfo+YM6T3qDFnyO8R/SjUo6Xfv+S69FOPOh6l94hcF+vR42D4sm5nHpHr8ntErkvv0Uyuy+8Rvz/K7xG/P8rvEf0o1CPDvutp7niU3iN+f5TfI35/lN8j5gz5PWLOkN8j5gzpPerMGfJ7xJwhv0fMGfJ7xJwhv0cdj9J7xJwhv0fMGfJ7xJwhv0fMGfJ7xJwhvUcLc4b8HjFn8Pfog5887Y8XT/uxPrE7/tZRphLVHGWGUc3RjqPFHGU+ktbRJ5eYkIzgEjOSEVxiSjKCS8xJBnBpZVIygkvMSkZwifnHCC4x0xjBpY5LA7jE7CHWpaPfv/A2Hcf8m0t/IP3+ovq0Mqeo5igzjYEc9d4GtDIrUXafGYyw+xuzHWX3mRkpu88sStl9ZlzK7nfcF3afmZyy+8zvlN1n1qfsPrM+ZfeZ9Qm7vzPrU3afWZ+y+8z6lN1n1qfsfsd9YfeZ9Sm7z6xP2X1mfcruM+tTdp9Zn7D7B7M+ZfeZ9Sm733G/pvuWm7QHfV/ZfTJ/VfcNdwsPMr+u++1G5ld2n8yv7D6/31d2n9/vK7vfcb+m+4bdvu1G31d2n9/vK7vP7/eV3WfWp+w+sz5h9ydmfcruM+tTdp9Zn7L7zPqU3e+4L+w+sz5l95n1KbvPrG8k9z/5ydN6f/E0bU93FI7bs/9M+7T9Z94n7X9j4qftPzM/bf+Z+mn7z9xP2/+O/xX8f3KUaV41R5nQhTrabu3+4nbb2htHDZfxWmPqVs1R5mgDOeq8G6E1pmjC7s/M0JTdZ4Km7D7zM2X3mZ4pu99xX9h95mzK7jOTU3af+Z2y+8z6lN1n1ifsfmfWp+w+sz5l95n1KbvPrE/Z/Y77wu4z61N2n1mfsvvM+pTdZ9an7D6zPmH3F2Z9yu4z61N2n1mfsvv0/aLuG67dtYW+r+w+mb+q+4arNyuZX9l9Mr+y+2R+Zff5/b6y+x33hd2n7xd137IDeaXvK7vP7/eV3ef3+8ruM+sTdn9j1qfsPrM+ZfeZ9Sm7z6xP2f2O+8LuM+tTdp9Zn7L7zPpGcv+Dn2y7drEx7dP2n3mftP87Ez9t/5n5afvP1E/bf+Z+2v53/K/g/5OjTPOqOcqELtjR4z5Ia9PU3zg6fbnx+Nyd+5mnzN3qecosbSBP+3SfpPf59uYnP792P3OfSZqw+wdztKLut/YwpS9n7jNFU3afGZqy+0zQlN3vuC/sPrM2ZfeZy1V1f7m/5bZNZ+4zwVN2n1mfsvvM+nTdn2/M+pTdZ9an7D6zPmX3mfUN6v5+5mjH0WKOMpOr5ihztmqOMjur5ijzsGqOMuMq5ujE3Kqao8yiqjnKfKmao8yMYh2dvr+PNfV338cyfdNjnjqelvOUuVE9T5kc1fOU2VE9T5ke1fOU+VE5TxsTpHqeMkOq5ylTpHqeMkeq52nH03KeMkeq5ylzpHqeMkeq5ylzpHqeMkcq5+nMHKmep8yR6nnKHKmep8yR6nna8bScp8yR6nnKHKmep8yR6nnKHKmep8yRynnamSPV85Q5Uj1PmSPV85Q5Uj1PO56W85Q5Uj1PmSPV85Q5Uj1PmSPV85Q5UjlPF+ZI9TxljlTPU+ZI9TxljlTP046n5TxljlTPU+ZI9TxljlTPU+ZI9TxljlTO05U5Uj1PmSPV85Q5Uj1PmSPV87TjaTlPmSPV85Q5Uj1PmSPV85Q5Uj1PmSOV83RjjlTPU+ZI9TxljlTPU+ZI9TzteFrOU+ZI9TxljlTPU+ZI9TxljlTPU+ZI5TzdmSPV85Q5Uj1PmSPV85Q5Uj1PO56W85Q5Uj1PmSPV85Q5Uj1PmSPV85Q5UjlPD+ZI9TxljlTPU+ZI9TxljlTP046n5TxljlTPU+ZI9TxljlTPU+ZI9TxljlTN035jjlTPU+ZI9TxljlTPU+ZI9TzteFrOU+ZI9TxljlTPU+ZI9TxljlTPU+ZI5TydmCPV85Q5Uj1PmSPV85Q5Uj1PO56W85Q5Uj1PmSPV85Q5Uj1PmSPV85Q5UjlPG3Okep4yR6rnKXOkep4yR6rnacfTcp4yR6rnKXOkep4yR6rnKXOkep4yRyrn6cwcqZ6nzJHqecocqZ6nzJHqedrxtJynzJHqecocqZ6nzJHqecocqZ6nzJHKedqZI9XzlDlSPU+ZI9XzlDlSPU87npbzlDlSPU+ZI9XzlDlSPU+ZI9XzlDlSOU8X5kj1PGWOVM9T5kj1PGWOVM/TjqflPGWOVM9T5kj1PGWOVM9T5kj1PGWOVM7TlTlSPU+ZI9XzlDlSPU+ZI9XztONpOU+ZI9XzlDlSPU+ZI9XzlDnSD3r6xJ1ZTwj3jXlMDHdmJjHcmWvEcGf2EMO9wz2EOx3ewr23dufe5+MNd1uC32jaUeTpw+7kv15yf/HS3/zkdVp/vXad25lH9Nv8HtGF03u005tDPWrtga4vZx7RsfN7RB/P7xHdPb9HHY/Se8RMIL9HTA/ye8ScIdaj5T4sbdt05hFzhvweMWdI79HBnCG/R8wZ8nvEnCG/R8wZrvRoPeXe4R7CnXlADHc6fgx3ensMd7q4ifu2P7gfyxvutr+IOWjYMeSXG73Znbzz31AsN3pzfo/ozaEeGX4fstzozfk96niU3iP6eH6P6O75PaLn5/eImUCsR+9/H7LcmB6k92hizpDfI+YM+T1izpDfI+YM+T3qeJTeI+YMV3q0nnJndhDDnXlADHc6fgx3ensI90YXj+FOv47hTmeO4U4PjuHe4R7Cnb5q4b48/pxq/gL3hrvtrxgbjTWKPJ01ijytNYo8vTWI/ExzjSJPd40iT3uNIk9/jSLfIR9Eng4bRZ4OG0WeDhtFng4bRZ4OG0S+02GjyNNho8jTYaPI02GjyHfIB5Gnw0aRp8NGkafDRpGnw0aRp8MGkV/osFHk6bBR5OmwUeTpsFHkO+SDyNNho8jTYaPI02GjyNNho8jTYYPIr3TYKPJ02CjydNgo8nTYKPId8kHk6bBR5OmwUeTpsFHk6bBR5OmwQeQ3OmwUeTpsFHk6bBR5OmwU+Q75IPJ02CjydNgo8nTYKPJ02CjydNgg8jsdNoo8HTaKPB02ijwdNop8h3wQeTpsFHk6bBR5OmwUeTpsFHk6bBD5gw4bRZ4OG0WeDhtFng4bRb5DPog8HTaKPB02ijwdNoo8HTaKPB02hvx6o8NGkafDRpGnw0aRp8NGke+QDyJPh40iT4eNIk+HjSJPh40iT4cNIj/RYaPI02GjyNNho8jTYaPId8gHkafDRpGnw0aRp8NGkafDRpGnwwaRb3TYKPJ02CjydNgo8nTYKPId8kHk6bBR5OmwUeTpsFHk6bBR5OmwQeRnOmwUeTpsFHk6bBR5OmwU+Q75IPJ02CjydNgo8nTYKPJ02CjydNgg8p0OG0WeDhtFng4bRZ4OG0W+Qz6IPB02ijwdNoo8HTaKPB02ijwdNoj8QoeNIk+HjSJPh40iT4eNIt8hH0SeDhtFng4bRZ4OG0WeDhtFng4bRH6lw0aRp8NGkafDRpGnw0aR75APIk+HjSJPh40iT4eNIk+HjSJPh/2v9/FNZ6NnvqJDF3xFh772ig6d6hWdDp0XdOgmr+jQH17RIeO/okMOf0WHrPyCzk5WfkWnUFY+9v3x4u1Mb6H0a9JbKM+a9HYxvYUyp0lvoRRp0lsoF5r0Fkp6Jr2FsptF71EojZn0iuWrQyxfHWL56uhiesXy1SGWrw6xfHWI5atDK19tN618td208tV208pX200rX223LqZXK19tN618td208tV208pX200sX01i+WoSy1eVLtSb9Irlq0rX2E16xfJVpcvjJr1i+arSlW2TXrF8VemitEmvWL6qdD3ZpFcsX1W6FGzSK5avKl3FNekVy1eVLsCa9Irlq0rXTk16xfJVpcueJr1i+arSFUuTXrF8Velio0mvWL6qdJ3QpFcsX1W6xGfSK5avKl2dM+kVy1eVLqyZ9Irlq0rXxEx6xfJVpctZJr1i+arSlSiTXrF8VekikkmvWL6qdP3HpFcsX1W6dGPSK5avKl11MekVy1eVLpiY9Irlq0rXOkx6xfJVpcsUJr1i+arSFQaTXrF8VenigEmvWL6qtLnfpFcsX1Xarm/SK5avKm3AN+kVy1eVttSb9Irlq0qb5E16xfJVpW3vJr1i+Upsf/smtr99E9vfvontb9/E9rdvYvvbN7H97ZvY/vZNbH/7Jra/fRPb376J7W/fxPa3b2L72zex/e2b2P72TWx/+ya2v30X29++i+1v38X2t+9i+9v3WxfTq5WvdrH97bvY/vZdbH/7Lra/fRfb376L7W/fxfa372L723ex/e272P72XWx/+y62v30X29++i+1v38X2t+9i+9t3sf3tu9j+9l1sf/sutr99F9vfvovtb9/F9rfvYvvbd7H97bvY/vZdbH/7Lra/fRfb376L7W/fxfa372L723ex/e272P72XWx/+y62v30X29++i+1v38X2t+9i+9t3sf3tu9j+9l1sf/sutr99F9vfvovtb9/F9rfvYvvbd7H97bvY/vZdbH/7Lra/fRfb376L7W/fxfa372L723ex/e272P72XWx/+y62v30X29++i+1v38X2t+9i+9t3sf3tu9j+9l1sf/sutr99F9vfvovtb9/F9rfvYvvbd7H97bvY/vZdbH/7Lra/fRfb376L7W/fxfa372L723ex/e272P72XWx/+y62v30X29++i+1v38X2t+9i+9t3sf3tu9j+9l1sf/sutr99F9vfvovtbz/E9rcfYvvbD7H97YfY/vbj1sX0auWrQ2x/+yG2v/0Q299+iO1vP8T2tx9i+9sPsf3th9j+9kNsf/shtr/9ENvffojtbz/E9rcfYvvbD7H97YfY/vZDbH/7Iba//RDb336I7W8/xPa3H2L72w+x/e2H2P72Q2x/+yG2v/0Q299+iO1vP8T2tx9i+9sPsf3th9j+9kNsf/shtr/9ENvffojtbz/E9rcfYvvbD7H97YfY/vZDbH/7Iba//RDb336I7W8/xPa3H2L72w+x/e2H2P72Q2x/+yG2v/0Q299+iO1vP8T2tx9i+9sPsf3th9j+9kNsf/shtr/9ENvffojtbz/E9rcfYvvbD7H97YfY/vZDbH/7Iba//RDb336I7W8/xPa3H2L72w+x/e2H2P72Q2x/+yG2v/0Q299+iO1vP8T2tx9i+9sPsf3th9j+9kNsf/shtr/9ENvffojtbz/E9rcfYvvbD7H97YfY/vZDbH/7Iba//RDb336I7W8/xPa3H1r727eb1v72L71S+epLr1S++tIrla++9HYxvVL56kuvVL760iuVr770SuWr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5At7/fWK5atNLF8l38jsrjf5SmZ/vWL5KvlSZn+9Yvkq+Vpmf71i+Sr5YmZ/vWL5KvlqZn+9Yvkq+XJmf71i+Sr5Kmd/vWL5KvnaZ3+9Yvkq+dJnf71i+Sr5ymd/vVr5akq+79lfr1a+mpLvevbXq5WvvtSI6dXKV1PyHc/+erXy1ZR8v7O/XrF8lXy3s79esXyVfK+zv16xfJV8p7O/XrF8lXyfs79esXyVfJezv16xfJV8j7O/XrF8lXyHs79esXyVfH+zv16xfJV8d7O/XrF8lXxvs79esXyVfGezv16xfJV8X7O/XrF8lXxXs79esXw1i+WrWSxfJd/D7a9XLF91sXzVxfJV8j3r/nrF8lXyPev+esXyVfI96/56xfJV8j3r/nrF8lXyPev+esXyVfI96/56xfJV8j3r/nrF8pXY/vZJbH/7JLa/fRLb3z6J7W+fxPa3T2L72yex/e2T2P72SWx/+yS2v30S298+ie1vn8T2t09i+9snsf3tk9j+9klsf/sktr99EtvfPontb5/E9rdPYvvbJ7H97ZPY/vZJbH/7JLa/fRLb3z6J7W+fxPa3T2L72yex/e2T2P72SWx/+yS2v30S298+ie1vn8T2t09i+9snsf3tk9j+9klsf/sktr99Etvf3sT2tzex/e1NbH97E9vf3m5dTK9Wvmpi+9ub2P72Jra/vYntb29i+9ub2P72Jra/vYntb29i+9ub2P72Jra/vYntb29i+9ub2P72Jra/vYntb29i+9ub2P72Jra/vYntb29i+9ub2P72Jra/vYntb29i+9ub2P72Jra/vYntb29i+9ub2P72Jra/vYntb29i+9ub2P72Jra/vYntb29i+9ub2P72Jra/vYntb29i+9ub2P72Jra/vYntb29i+9ub2P72Jra/vYntb29i+9ub2P72Jra/vYntb29i+9ub2P72Jra/vYntb29i+9ub2P72Jra/vYntb29i+9ub2P72Jra/vYntb29i+9ub2P72Jra/vYntb29i+9ub2P72Jra/vYntb29i+9ub2P72Jra/vYntb29i+9ub2P72Jra/vYntb29i+9ub2P72Jra/vYntb29i+9ub2P72Jra/vYntb29i+9ub2P72Jra/vYntb29i+9ub2P72WWx/+yy2v30W298+i+1vn29dTK9WvprF9rfPYvvbZ7H97bPY/vZZbH/7LLa/fRbb3z6L7W+fxfa3z2L722ex/e2z2P72WWx/+1xpv/extfuLt/lMb6Hnr0lvoc/nY98fL97O9Bb6fDbpLfT5bNJb6PPZpLdQ/7XorbT/2aS30vPXorfS89eit1D/NentYnrF8lWl/c8mvcPmqycNw2amJw2pc9DX+2jL443c9vXNf3nnP/tbce5NzZcoTp2FLlGcOg1dojh1HrpEcZdTnDoTXaI4dSq6RHHqXHSJ4tQp6hLFcpkr9/bmSxTLZa7cG5wvUSyXuXJvcb5EsVzmyr3J+RLFcpkr9zbnSxTLZa7cG50vUSyXuXJvdb5EsVzmyr3Z+RLFcpkr93bnSxTLZa7cG54vUSyXuXJvxf1U8dLvfwe79FPFpZ5OJsWlPrmW5f63Gst69rcauXenXqK41CeXRXHu/amXKC7VFk2KS7VFk+JSz+N1Wn+9ep3bmeJSz2OT4lJt0aS4VFs0KS6VuUyKS2Uuk+JSmcuiOPdO1UsUl8pcJsWlMpdJsVzmyr1b9RLFA2euJxUD56gnFcmz0TR/v5Gp9zf/9VmmrLl3oV6iOHk2+kxxa4830pc/K+6596Feojh5NrpAcfJsdIHi5NnoAsVdTnHybPSh4uWeQdo2nSlOnqMuUFwqc5kUl8pcJsW1MpdBce4dqZcorpW5LIprZS6L4uyZa3tsE7y17Xij+B+bQu4vn5/fSdueNXdBzdlz1xWasyevKzRnz15XaM6evq7QnD1/XaC5ZU9gV2jOnsGu0Jw9hV2hWTCHtS6oWTCH5d6OfJFmwRyWe0vyRZoFc1jubckXaRbMYbm3Jl+kWTCH5d6efJFmwRyWe4vyRZoFc1juzcsXaRbMYdl3NV+iWTCHZd/XfIlmwRyWfWfzJZoFc1j2vc2XaBbMYdl3N1+iWTCHZd/ffIlmwRyWfYfzJZoFc1j2Pc6XaBbMYdl3OV+iWTCHZd/nfIXm7Nt+P9NsuDnds2/7vUBxqc9sw13Enn0T7AWKS31emxSX+rQ2KS7VmS2Kt1KN2aS41vPYorjW89iiuFRXNinucorlMtcml7my77B+pfhJxcA56klF8mw0t9vjjczz/Oa/PsM2o5591/QFipNnowsUJ89Gnym27H3Jvmv6AsVdTnHybHSB4uTZ6ALFybPRBYqT56gLFJfKXJYtKNl3TV+guFTmMimulbksimtlLoviLqe4VuayKB4pc/XbyVwj+15qo4qRstG5iux5Zzu+VRzt358/LNn3R1+gOHve+UixIcUv2fdHX6A4e97xV9zlFGfPO/6Ks+cdf8XZs9Fnit9n2iX7/ugLFJfKXBbF2fdHX6C4VuayKK6VuSyKa2Uui+I+kuKTv6tYsu+DNqoYKhudqkied3r/fiNLf/cXVvv+OMy27/3pf0XT9Kw5eeK5RHPyzHOF5uw7my/RnDz3XKI5efK5RHPy7HOJ5i6oOXlWukRz8mR1iWbBHJZ9Z/MlmgVzWPadzZdoFsxh2Xc2X6JZMIdl39l8iWbBHJZ9Z/MlmgVzWPadzZdoFsxh2Xc2X6JZMIdl39l8iWbBHJZ9Z/MlmgVzWPadzZdoFsxh2Xc2X6JZMIdl39l8iWbBHJZ9Z/MlmgVzWPadzZdoFsxh2Xc2X6JZMIdl39l8iWbBHLYK5rDsu7kv0SyYw1bBHJZ9Q/dnmg1b2JfsG7r9FWff3vyh4vcbQZfs25svUFzq89qkuNSntUlxl1NcqjGbFNd6HlsU13oeWxSX6somxaWaskVx9q3QFyiWy1zZt0K/UvykYuAc9aSi51ax7I8jcLf1ePdfX9/m+39+fevbSXfPvr/5Es3J89ElmpMnpEs0J89Il2hOnpKu0Jx9k/MlmpMnpUs0J89Kl2hOnqwu0dwFNQvmsOxbnS/RLJjDsm+MvkSzXg5bs2+YvkSzXg5bs2+ZvkSzXg5bb11Qs14OW7Nvm75Es14OW7NvnL5Es2AOy751+hLNgjks++bpSzQL5rDs26cv0SyYw7Jvtr5Es2AOy74H+xLNgjks+x7sSzQL5rDse7Av0SyYw7Lvwb5Es2AOy74H+xLNgjks+x7sSzQL5rDse7Av0SyYw7Lvwb5Es2AOy74H+xLNgjks+x7sSzQL5rDse7Av0SyYw7Lvwb5Es2AOy74H+xLNgjks+x7sSzQL5rDse7Av0SyYw7Lvwb5Es2AOy74H+xLNgjks+x7sSzQL5rDse7Av0SyYw7Lvwb5Es2AOy74H+xLNgjks+x7sSzQL5rDse7Av0SyYw9YuqFkwh2Xfd36JZsEctgrmsFUwh2Xfe/6ZZsM2/zX73vMLFJf6zDZsll2z78S+QHGpz2uT4lKf1hbF2XdiX6C4VGM2Ka71PLYorvU8tijucopLNWWTYrnMVWvLtknxwJnrScXAOepbRfY92N9lfLrt//i3v/yvb5qP2/3l85Pm37t79j3Yl2hOno8u0Zw8IV2iuQtqTp6SLtGcPCddojl5UrpEc/KsdInm5MnqAs1b9j3Yl2jWy2Fb9j3Yl2jWy2HbrQtq1sthW/Y92Jdo1sthW/Y92JdoFsxh2fdgX6JZMIdl34N9iWbBHJZ9D/YlmgVzWPY92JdoFsxh2fdgX6JZMIdl34N9iWbBHJZ9D/YlmgVzWPY92JdoFsxh2fdgX6JZMIdl34N9iWbBHJZ9D/YlmgVzWPY92JdoFsxh2fdgX6JZMIdl34N9iWbBHJZ9D/YlmgVzWPY92JdoFsxh2fdgX6JZMIdl34N9iWbBHJZ9D/YlmgVzWPY92JdoFsxh2fdgX6JZMIdl34N9iWbBHJZ9D/YlmgVzWPY92JdoFsxh2fdgX6JZMIdl34/8mWbDNsIt+3bkCxSX+sw2bMbZsm/MvUBxqc9rk+JSn9YWxVupzmxSXKoxmxTXeh5bFNd6HlsUdznFpZqySbFc5sq+8/oCxQNnricVA+eobxXZd1Pv67eK47a9+a9v2e+tbtn375+9Lc+Kk2ejCxQnz0afKd724/Gz25ufff4+nugkz1HBdDp0XtBJns+C6STPcsF0kue+YDrJM2IwneTZM5ZO9p3iwXRK5V93OmTlV3TIyq/odOi8oENWfkWHrPyKDln5FR2y8is6ZOVzOnv2ve/BdMjKr+iQlV/RISu/otOh84IOWfkVHbLyKzpk5Vd0yMqv6JCVX9DJvps/mA5Z+RUdsvIrOrJP9KU//n6nn9KRfaJb6GTf1H0hneX+k5d1O6Mj+6lsoiP7qWyiIzvBMNHp0HlBR3aCYaIjm3fWaf312nVuZ3Rk846JjuwEw0RHdoJhoZN9m3owHdmsbKIjm5VNdGSzsolOh84LOrJZ2USHrPyKDln5FR2y8is6ZOUXdLJvvA+mQ1Z+RYes/IoOWfkVnV6Kzic/e/3+0ev6tHlxPp751ErL/nxq5WV/PrUSsz+fWpnZn0+t1PzJz95u98fXP9Yf/cbnD78He7+ZZs9+zWAolrUSeSzLWvk9lmWttB/LssPSjaVuj/Bnqds5/Fnq9hN/lrpdxp8lvceN5Urv8WNJ7/FjSe/xY0nv8WPZYenGkt7jx5Le48eS3uPHkt7jx5Le48Yy+yWuoViSL20sl/vf5yzbdMayw9KNJc9xv/+N8xz3Y8lz3I1lratRwSyZX/qxZH75B5ZPfMiMr/l0+LzkIzw7PB4/ep9P+QjPA018hLuBiY9w3jfxEc7wFj7FLl/589HN2vsjPk9H33/j83dZu9ilrFiWurncn2WHpRtL3bzvz1K3G/iz1O0R/ix1O4c/S91+4s3yKHaZLJYlvcePJb3HjyW9x49lh6UbS3qPH0t6jx9Leo8fS3qPH0t6jxvLYlfmYlnSe/xY0nv8WNJ7/Fh2WLqxpPf4saT3+LGk9/ixpPf4saT3uLEsdsc1lmWHpYnl++8zHsUuWcay5Nnj979xnj1uLIvdRYxlyczNjyUzNz+WzNz+wPKJT4fPSz7kwNd8dOddx3p/cfuSe8ZHd4Zl46PbDWx8dPO+iU+xe43+fHRzuY2PbNZut3l68Dn6b3z+kLX77Z6119v3a6fnrF3swmMsyw5LN5ayGf4ClrJ5/wKWst3gApayPeIClrKdw5+l7q3LC1jKdpkLWNJ7/FjSe/xYdli6saT3+LGk9/ixpPf4saT3+LGk97ix1L11eQFLeo8fS3qPH0t6jx/LDks3lvQeP5b0Hj+W9B4/lvQeP5b0HjeWurcuL2BJ7/FjSe/xY0nv8WPZYenGkt7jx5Le48eS3uPHkt7jx5Le48ZS9zbwBSzpPX4s6T1+LOk9fiw7LN1Y0nv8WNJ7/FjSe9xY6t5w/ZClYR+b7g3XC1jy7LGxNOxq0r2VeQFLnj1+LJm5+bFk5ubEst10b2W+YvnEh8z4mg858DUf3XnXND3e9dRP+XT4vOSj2w1sfHTzvo2Pboa38dHN5TY+ull72pfHu+7Hb3z+Zv7Ybrr3GS9gqZvL/VnqZnh/lsJ5351lh6UbS+Ee4c5SuHO4sxTuJ+4shbuMO0t6jxtL3fuMF7Ck9/ixpPf4saT3+LHssHRjSe/xY0nv8WNJ7/FjSe/xY0nvcWOpexv4Apb0Hj+W9B4/lvQeP5Ydlm4s6T1+LOk9fizpPX4s6T1+LOk9bix17ylfwJLe48eS3uPHkt7jx7LD0o0lvcePJb3HjyW9x48lvcePJb3HjaXwnWZ/lvQeP5b0Hj+W9B4/lh2WbizJRDaWb/exfbEkE7mxFL6V+RlLw64m4VuZ/ix59vixZObmx5KZmx9LZm5/YPnEh8z4mg858CUf4TuV7fGj23y7nfHRnWHZ+Oh2Axsf3bxv49Ph85KPbi638dHN2nP75tPXMz66+dnGRzc/2/jo5mcTH+F7hzY+uvnZxkc3P8/HffzTet9/4/Ovr+7H/X0s09PvKX77/ZnwXUJ/lh2Wbix1M7w/S+G8785SuBu4sxTuEe4shTvHJyyf/qZomU9YHsL9xJ2lcJdxZ0nv8WNJ7/Fj2WHpxpLe48eS3vMpy9O/sxa+ievPkt7jx1K39/THnwK2ZX73d4Pbfme5HU8/ed6+WU7CN3H9Wer2Hn+Wur3Hn6Vu7/Fn2WHpxlK393zEcm93ifu8nrHU7T3+LHV7jz9L3d7jz5Le48ZS+D6xP0t6j43l8vjJ2+2MJb3HjyW9x49lh6UbS3qPH0t6jx9Leo8fS3qPjeXjl0PHbTljSe9xYyl8n9ifJb3HjyW9x48lvcePZYelG0vd3rOs91+HtfU2vWH5VWruP/rr//j0FzP9eKap23yuoKnbfa6gqdt+rqCp238+o9mmfn8jbd9+o/mvrzZs1ZuErxpHk9ftVtHkdZtYNHnd3hZNvkM+iDydMIo8/TGKPF0zijy9NIo8HTaIvPCF6mjydNgo8nTYKPJ02CjyHfJB5OmwUeTpsFHk6bBR5OmwUeTpsEHkha+NR5Mnz19B/v012Un4YnQ0ebJN1KcN2SaKPNkmiPxKtokiz3w+ijzz+X+b/BNNMronzQ5NR5rMxm0059t6fyNzP6XJvNuTJj3PkybdzZMmfcyR5kbH8qRJbzLS3O7Dxqkvt99o/uHVW3+w3/vTO+nTM3uaUxx7elYc+w77MPZ0uDj2NL449vTDOPa0yTj2dM8w9jtNNY49vTaOPb02jj29No59h30Ye3ptHHt6bRx7em0ce3ptHHt6bRj7g14bx55eG8eeXhvHnl4bx77DPow9vTaOPb02jj29No49vTaOPb02in270Wvj2NNr49jTa+PY02vj2HfYh7Gn18axp9fGsafXxrGn14axn8iYF7A3bEBrEwkzijzP2SvIv99J1CaeslHkecZGkWdyHES+MTeOIs/U+N8m/0STjO5Jk9xto7lMd43Tsu1vPhX6cX/Xy/T0k6ffPhU65IPIM9WNIk/XjCJP14wiT9eMIk/XDCI/0zUvIL/0+49elvmMPF0zijy9NIo8HTaKfId8EHk6bBR5OmwUeTrsteTX2xl5OmwUeTpsEPlOh7WRX7+JrMv0hvy09McNn2V53vf//Hd4nRYbx54eG8eeJhvHvsM+jD1tNo49ffYS9o8/vf7Ko+2MPY02jj2dNo49rTaM/UKvjWNPr41jT6+9gn0/bg/2++8Z8+/mbgsdeAyfOj4N4RPd+gqf1u371Xs/e+bQrePY063j2NOt49jTrcPYr3TrOPZ06zj2dOtL2O+PnUXrcZyxpy/Hse+wD2NPr41jT6+NY0+vjWNPr41jT6+9hP10fyPTNv2e7/9u3rzRgcfwib48hk906yt82m+P37P99k5+e+ZsdOs49h32Yezp1nHs6dZx7OnWcezp1nHs6daXsJ+WB/u2n7Df6ctx7OnAcezptXHs6bVx7Dvsw9jTa+PY02uvYP/irtnfzZt3OvAYPtGXx/BJt1uv8+Ndf/2K/51Py/H9VwDT8fQ+/khkuT9y2vNlu6/38U3+0G3W0eR1e3U0ed1WHU1et1O7kX+i2aHpSFO3915BU7fJXkFTt29eQVO3FV5Bk+7mR3O+0cc8adKxbDTX9bEdat3bbzT/8D6W+7vejqe/3p2fwVOxgsDTsC4A39rjR/flz912vnXIB5GnuUWRp+VFkacRRpGnPUaRp2leQf793H6eaKVR5GmwNvLb7fH3Vdu0//tFaqLBBoGnwV4A3vJ8nTrkg8jTYKPI02CjyNNgo8jTYKPI02CvIG/oUY0GG0WeBmsk//1X9dvy7q8tDUWq0WCDwNNgLwBveb62Dvkg8jTYKPI02CjyNNgo8jTYKPI02CvIG3rUTIONIk+DNZLf+4P8sf37RWqmwQaBp8FeAN7yfJ075IPI02CjyNNgo8jTYKPI02CjyNNgryBv6FGdBhtFngb7Mfn91n8j/0STWupJk67pSbND00RzXx5E9rX/x789MunUxyDwtMcLwFuSdKc9RpGnPUaRpz0GkV9oj1HkaY9R5GmaV5A3TEwWWmkU+Q55G/m2f5Nf3pA/5vtigmP9/puYth9/V7oW2u4AJtGMBzCJEj2ASfTtAUyimuc3aaXFD2AShX8Ak5gNDGASY4QBTOqYlN8kJg42k47psYLymNsbkyzgmSIEgWcycAF4y69dVup+FHk6fBD5jWIeRZ62HUWeCh1Fnl58BXnDr9e3Dvkg8jTYKPJU2CjydFgj+WV7kH/7lb9Xr35iT4uNY0+PvYD9th+P99HevI/z9/zt0k7nHcEl+vEILtGlR3CJ3j2CSx2XBnCJPj+CS3T/EVxiTjCCS0wURnCJ2cMALh3MHkZwidnDCC4xexjBJWYPI7jUcWkAl5g9jOASs4cRXGL2MIJLzB5GcInZQ36X+o3ZwwguMXsYwSVmDyO4xOxhBJc6Lg3gErOHEVxi9jCCS8weBnBpoi8Fu7T09uu1Sz91ib40gksdl4JdeqyeWdbtzCUy3ggukfFGcImMN4JL/H5pBJf4/dIALjX6UrBL67T+eu06tzOX6EsjuMTvl0Zwid8vjeBSx6UBXGL2MIJLzB5GcInZwwguMXsYwSVmDwO4NDN7GMElZg8juMTsYQSXmD1c4dIH7+N4/N3DsSxPP/f27FLHpQFcYvYwgkvMHkZwidnDCC4xexjBJWYPA7jUmT1Eu/T4wceXMycuMXsYwSVmDyO4xOxhBJc6Lg3gErOHEVxi9jCCS8weftSlJ/LME6LIMyMIIr/Q+6PI0+WjyNPPo8jTuaPIdw3yT4pFOumTYpF+96RYpCs9KRbpKE+KRbrBt+JVJJM/KU6ehY/Hw/vr/7wtbxRPy+PVSz9TnDyDXqA4efb7TLH3nra1Q+cFneRZLphO8twXTCd5RgymkzxPBtNJnj1j6WzJc2ownVKZ1p1OqfzrToes/IpOh84LOmTlV3TIyq/okJVf0SErv6JDVn5BZycrv6JDVn5Fh6z8ig5Z+RWdDp0XdMjKr+iQlV/RISu/okNWfkWHrPyCzkFWfkWHrPyKDln5FR2y8is6HTov6JCVX9EhK7+iQ1Z+RYes/IoOWfmcznIjK7+iQ1Z+RYes/IoOWfkVnQ6dF3TIyq/okJVf0SErv6JDVn5Fh6z8gs5EVn5Fh6z8ig5Z+RUdsvIrOh06L+iQlV/RISu/okNWfkWHrPyKDln5BZ3st7uvo7M8tuUv/ZSObN4x0ZF9Zi3LfTPKsm5ndGSfWSY6ss8sEx3ZZ5aFTvb7qcF0ZOc7Jjqyecdwp3PJfqczmE6Hzgs6svMdEx3ZrGyiI5uVTXRks7KJjmxWttDJfu8vmI5sVjbRISu/okNWfkWnQ+cFHbLyKzpk5Vd0yMqv6JCVX9EhK7+gk/1G1od0PvnZy3L/dd+0PP3k1v/06i9Sd4nbdMayVrKOZVkrh8eyrJXaY1l2WP4ryyc+tVK+P59aOd+fT62k78+nVtb351Mr7bvzyX5/K5wPGf41H91cvrZ79Z7WJ41/zpKW7l3salgsyw5LC8vWHhL7csZSN8P7s9TN+/4sdbuBP0vdHuHPUrdzuLMsdnctlqVul/mMpWHuW+ymWyxL4d6zLg+W2+7Qe4rdi4tlKdx7PmFpevYI9x53lsK9x52lcO9xZynce7xZFruhF8tSuPe4sxTuPR+xNPSeYtf8Yll2WLqxpPf4sdTtPdvtXrGnbbm9YTktj/ex9DOWur3Hn6Vu7/mIpfeuuWLXEIfhXuzO4jjcdbtXLHfdnhbLXbfTxXLvcA/hrtsVY7nTK2O400FjuNNXY7jTVyO4r8VunY7Dnb4aw52+GsOdvhrDvcM9hDt9NYY7fTWGO301hjt9NYY7fTWEe7F7w+Nwp6/GcKevxnCnr8Zw73AP4U5fjeFOX43hTl+N4U5fjeFOXw3h3uirMdzpqzHc6asx3OmrMdw73EO401djuNNXY7jTV2O401djuNNXQ7jP9NUY7vTVGO701Rju9NUY7h3uIdzpqzHc6asx3Mnv7tyXfj+UtfQz7p38HsOdPOPPfdnv3NftjHuHewh38kwMd/JMDHfm7zHcmb/HcCe/u3M33IJZF/J7DHfm7zHcmb/HcKevxnDvcA/hTl+N4U5fjeFOX43hTl+N4U5fDeG+0ldjuNNXY7jTV2O401djuHe4h3Cnr8Zwp6/GcKev2rh/8JNbm2/fPL5fPR3HRz/5ySXa7Qgu0YUHcGmjOY/gEj37R116Ik/TjiJP144i3yEfRJ6+HUWexh1Fns4dRZ4eHUWebhxEfqfvRpGnw15Afn+Qn6f1N/J/eB/Lrd/fx7I8vXrdnn2i8Y7hE/042CfvbQV7x9FijtLnqznKnKCao8wfqjnKXKOao8xLijl6MIep5ijznWqOMgmq5igzo2qOdhwt5igzo2qOMjOq5igzo2qOMjOq5igzo1qObjdmRtUcZWZUzVFmRtUcZWZUzdGOo8UcZWZUzVFmRtUcZWZUzVFmRtUcZWZUzNGJmVE1R5kZVXO04+g4jhruUG4TfbSao2TdkRx9f1ttm8i6xRxtZN1qjpJ1qznK70erOcrvR6s52nF0HEcNe923Rh+t5ii/H63mKL8freYoM6NqjjIzKubozMyomqPMjKo5ysyomqPMjKo52nG0mKPMjKo5ysyomqPMjKId/eQ9L9MDx9JO9ppvM1Ojep4yNyrnaWdyVM9TZkf1PGV6VM9T5kf1PO14Oqin83zmKTOkep4yRarnKXOkoTydl4enfT/zlDlSPU+ZI5XzdGGOVM9T5kj1PGWOVM9T5kj1PO14Oqiny3LmKXOkep4yR6rnKXOktJ4+ucRkaASXmPX4uzRP+8Olpb9xaVpu/fsz7+z3livzmzF8YiYT7JP33syViUw1R5nHVHO042gxR5nFVHOUSUw1R5nDVHOUmU01R5nvFHN0YxJUzVFmRtUcZWZUzVFmRtUc7ThazFFmRtUcZWZUzVFmRtUcZWZUzVFmRsUc3ZkZVXOUmVE1R5kZVXOUmVE1RzuOFnOUmVE1R5kZVXOUmVE1R5kZVXOUmVExRw/66ECOLr39eu3STx2lj1ZzlKw7kqOGq+gHWbeao2Tdao6SdWs5ut/4/Wg1R/n9aDVH6aMDOWq4K7jf6KPVHO04WsxRfj9azVFmRtUcZWZUzVFmRtUcZWZUzNGJmVE1R5kZVXOUmVE1R5kZVXO042gxR5kZRTv6yXu23M3eJ6ZG9TxlblTPUyZH9TxldlTO08b0qJ6nzI/qecoEaVRP5/nMU2ZI9TzteFrOU+ZIQ3lquJu9N+ZI9TxljlTPU+ZI9TxljlTO05k5Uj1PmSPV85Q50qieLsuZp8yR6nna8bScp8yR0nr65BKToRFcYtZzgUvL+nDpWN+4dLT7X2se2/Sk7/bsEtObEVxiHhPskvPOzL0zjanmKLOYao4yianmKHOYao52HC3mKDOYao4yr6nmKLOdao4yB6rmKDOjYo4uzIyqOcrMqJqjzIyqOcrMqJqjHUeLOcrMqJqjzIyqOcrMqJqjzIyqOcrMqJijKzOjao4yM6rmKDOjao4yM6rmaMfRYo4yM6rmKDOjao4yMyrm6EYfHcjRpbdfr136qaP00WqOdhwdyFHDRfSNrFvNUbJuNUfJutUc5fej1Rzl96PFHN3powM5arkpuNNHqznK70erOcrvR6s52nG0mKPMjKo5ysyomqPMjKo5ysyomqPMjIo5ejAzquYoM6NqjjIzinb0g598PP4q5Xi+zfDbDuyDmVE1RzuOFnOUmVE1R5kZVXOUmVE1R5kZVXOUmdFIji731x7b7c+OHjdmRtUcZWZUzVFmRtUcZWZUzdGOo8UcZWZUzVFmRmkdfXKJOdAILjHbucCl43Hruk/TG5fa1w/5fnX77dVPPjGxGcKniTlMuE/fNi0nn3oTs5URXGJeMoJLzEBGcKnj0gAuMasYwSXmD9EuLcv9xdt05hLzhxFcYv4wgktMHwZwqTF7GMElZg8juMTsYQSXmD2M4FLHpQFcYvYwgkvMHkZwidnDCC4xe/g3XXpiyYTAjeVMj/djSdv2Y0kn9mNJc/Vj2WHpxpIW6MeSrubHkkblx5Le48eS3uPGstN7/sDyiY9wl9nag8++vflvbfricH/1NPez/9qE28wFNIX7zAU0OzQdaQp3mgtoCreaC2gK95oLaAo3mwtoCncbf5qLcLu5gCZdyJMmXciTJl3Ik2aHpiNNupAnTbqQJ026kCdNupAnTbqQI82VLuRJky7kSZMu5EmTLuRJs0PTkSZdyJMmXciTJl3IkyZdyJMmXciR5kYX8qRJF/KkSRfypEkX8qTZoelIky7kSZMu5EmTLuRJky7kSZMu5Ehzpwt50qQLedKkC3nSpAt50uzQdKRJF/KkSRfypEkX8qRJF/KkSRdypHnQhTxp0oU8adKFPGnShTxpdmg60qQLedKkC3nSpAt50qQLedKkC7nRnG83upAnTbqQJ026kCdNupAnzQ5NR5p0IU+adCFPmnQhT5p0IU+adCFHmhNdyJMmXciTJl3IkyZdyJNmh6YjTbqQJ026kCdNupAnTbqQJ026kCPNRhfypEkX8qRJF/KkSRfypNmh6UiTLuRJky7kSZMu5EmTLuRJky7kSHOmC3nSpAt50qQLedKkC3nS7NB0pEkX8qRJF/KkSRfypEkX8qRJF3Kk2elCnjTpQp406UKeNOlCnjQ7NB1p0oU8adKFPGnShTxp0oU8adKFHGkudCFPmnQhT5p0IU+adCFPmh2ajjTpQp406UKeNOlCnjTpQp406UKONFe6kCdNupAnTbqQJ026kCfNDk1HmnQhT5p0IU+adCFPmnQhT5p0IUeaG13IkyZdyJMmXciTJl3Ik2aHpiNNupAnTbqQJ026kCdNupAnTbqQI82dLuRJky7kSZMu5EmTLuRJs0PTkSZdyJMmXciTJl3IkyZdyJMmXciR5kEX8qRJF/KkSRfypEkX8qTZoelIky7kSVOkCz0pFukrT4pFOsWTYpHc/1D8JU1OsUh+flIsknGfFIvk0CfFXU6xSJ57UqyWuSaVG/RPigfOXE8qBs5R3ypGvov+pGLgvPOkYuAM86Ri4FzypKKXUDFwfnhSMXAmeFIx8HP+SUWJZ/fI94S/VYx8x/dJRYln98h3a59UlHh2j3yn9UlFiWf3yHdJn1SUeHaPfIfzSUWJZ/fIdyefVGR/dh/3V38NOqb2m4q//K3wlP4q4xWas+eCKzR3Qc3ZM8cVmrMnlCs0Z88zV2jOnn6u0Jw9K12gOf0Vuys0C+aw9BfhrtAsmMPSX1e7QrNgDkt/qewKzYI5LP3Vrys0C+aw9Be0rtAsmMPSX6O6QrNgDkt/2ekKzYI5LP2VpCs0C+aw9BeHrtAsmMPSX++5QrNgDkt/CecKzYI5LP1VmSs0C+aw9BdartAsmMPSXzu5QrNgDkt/OeQKzYI5LP0Vjis0C+aw9BctrtAsmMPSX4e4QrNgDkt/aeEKzYI5LP3Vgis0C+aw9BcArtAsmMPSb9O/QrNgDku/mf4KzYI5LP2W9ys0C+aw9BvTr9AsmMPSbx+/QrNgDku/yfsKzYI5LP1W7Cs0C+aw9Juxr9Csl8Na+u3YV2jWy2Et/YbsKzTr5bB264Ka9XJYS78p+wrNejmspd+WfYVmwRyWfhP3FZoFc1j6Ld9XaBbMYek3iF+hWTCHpd9OfoVmwRyWfvP5FZoFc1j6repXaBbMYek3tl+hWTCHpd8Gf4VmwRyWftP8FZoFc1j6LfZXaBbMYek35F+hWTCHCe7Tb4L79JvgPv0muE+/Ce7Tb4L79JvgPv0muE+/Ce7Tb4L79JvgPv0muE+/Ce7Tb4L79JvgPv0muE+/Ce7Tb4L79JvgPv0muE+/Ce7Tb4L79JvgPv0muE+/Ce7Tb4L79JvgPv0muE+/Ce7Tb4L79JvgPv0muE+/Ce7Tb4L79JvgPv0muE+/Ce7Tb4L79JvgPv0muE+/Ce7Tb4L79JvgPv2WaZ/+07tKlJSe3lWiLPP0rhKljad3lSgPfL+rTJvXn95Vomfq07tK9NR7eleJnktP7yrRk+PpXaX8bM+0RfvpXaX8bM+0ifrpXaX8bM+0zfnpXaX8bM+0EfnpXaX8bM+0VfjpXaX8bM+0mffpXaX8bM+03fbpXWX8bJ8zbYh9elcZP9vnTFtWn95Vxs/2+Zbxs33OtEv06V1l/GyfM+3jfHpXGT/b56t3Wn7/m67eJPn0b5p+7N/UfuzfNP/Yv6n/2L9p+bF/0/pj/6btx/5N+4/9m37sM6L92GdE+7HPiPZjnxHtxz4j2o99RrQf+4xoP/YZ0X7sM6L92GdE+7HPiPnHPiPmH/uMmH/sM2L+sc+I+cc+I+Yf+4yYf+wzYv6xz4j5xz4j5h/7jOg/9hnRf+wzov/YZ0T/sc+I/mOfEf3HPiP6j31G9B/7jOg/9hnRf+wzYvmxz4jlxz4jlh/7jFh+7DPC5RupbeuPf9N+/PZv+su/kptdvjV6xftak76vLen72pO+ryPn+3L5puEV72tK+r5a0vc1J31fST/v16Sf92vSz/s16ef9mvTzfk36eb8l/bzfkn7eb0k/77ekn/db0s/7Lenn/Zb0835L+nm/Jf2835J+3u9JP+/3pJ/3e9LP+z3p5/2e9PN+T/p5vyf9vN+Tft7vST/v96Sf90fSz/sj6ef9kfTz/kj6eX8k/bw/kn7eH0k/74+kn/dH0s/7I+fnfb/l/Lzvt5yf9/2W8/O+33J+3vdbzs/7fsv5ed9vOT/v+y3n532/5fy877ekn/dT0s/7Kenn/ZT0835K+nk/Jf28n5J+3k9JP++npJ/3U9LP+ynp531L+nnfkn7et6Sf9y3p531L+nnfkn7et6Sf9y3p531L+nnfkn7ez0k/7+ekn/dz0s/7Oenn/Zz0835O+nk/J/28n5N+3s9JP+/npJ/3PennfU/6ed+Tft73pJ/3PennfU/6ed+Tft73pJ/3PennfU/6eb8k/bxfkn7eL0k/75ekn/dJv1/bk36/tif9fm1P+v3anvT7tT3p92t70u/X9qTfr+1Jv1/bk36/tif9fm1P+v3anvT7tT3p92t70u/X9qTfr+1Jv1/bk36/tif9fm1P+v3anvT7tT3p92t70u/X9qTfr+1Jv1/bk36/tif9fm1P+v3anvT7tT3p92t70u/X9qTfr+1Jv1/bk36/tif9fm1P+v3anvT7tT3p92t70u/X9qTfr+1Jv1/bk36/tif9fm1P+v3a9eoN1//66g8voM/z440c2/L9Tv54Af2jn73d1vuP3pbb96v7/G/+5DYv95/c5mP9fs/H8aefvB+Pn9ze/OSlt1+vXfp85miia3A46uJookt6OOriaMfRYo4muuCIoy6OJrp+iaMujia6HIqjLo4murqKoy6OJrpGjqMejl59iQdHf9xRZkbVHGVmNJKj++3u6LGcOcrMqJqjHUeLOcrMqJqjzIxGcnT7dnQ9c5SZUTVHmRlVc5SZUTFHV2ZG1RxlZlTNUWZGIzm67HdH1+3MUWZG1RztOFrMUWZG1RxlZlTNUWZG1RxlZlTNUWZGxRzdmBlVc5SZUTVHmRlVc5SZUTVHO44Wc5SZUTVHmRlVc5SZUTVHmRlVc5SZUTFHd2ZG1RxlZlTNUWZG1RxlZlTN0Y6jxRxlZlTNUWZG1RxlZlTNUWZG1RxlZlTM0YOZUTVHmRlVc5SZUTVHmRlVc7TjaDFHmRlVc5SZUTVHmRlVc5SZUTVHmRnVcnS7MTOq5ih99AJHp/3h6NI9HX2/A3u7dRwt5ih9tJqj9NFqjtJHqzlKH63mKH20mKMTfbSao/wNQzVH+RuGao4yM6rmaMfRgRx9f8Fnm5gZVXOUmVE1R5kZVXOUmdFIjr6/DrJNzIyKOdqYGVVzlJlRNUeZGVVzlJlRNUc7jg7kqOFvARszo2qOMjOq5igzo2qOMjOq5igzo2KOzsyMqjnKzKiao8yMqjnKzKiaox1HiznKzKiao8yMqjnKzKiao8yMqjnKzKiYo52ZUTVHmRlVc5SZUTVHmRlVc7TjaDFHmRlVc5SZUTVHmRlVc5SZUTVHmRkVc3RhZlTNUWZG1RxlZlTNUWZG1RztOFrMUWZG1RxlZlTNUWZG1RxlZlTNUWZGxRxdmRlVc5SZUTVHmRlVc5Q+6u9oe6zY/DLX9RKeYQf2Sh+t5ih9tJqj9NFqjtJHizm60UerOUofreYofbSao/wNQzVHO44Wc5SZUTVHmRmN5Kjhgs/GzKiao8yMqjnKzKiYozszo5EcNVwH2ZkZVXOUmVE1R5kZVXO042gxR5kZVXOUmdFIjhr+FnBnZlTNUWZG1RxlZlTM0YOZUTVHmRlVc5SZUTVHmRlVc7TjaDFHmRlVc5SZUTVHmRlVc5SZUTVHmRnVcnS/MTOq5igzo2qOMjOq5igzo2qOdhwt5igzo2qOMjOq5igzo2qOMjOq5igzo2KOTsyMqjnKzKiao8yMqjnKzKiaox1HiznKzKiao8yMqjnKzKiao8yMqjnKzKiYo42ZUTVHmRlVc5SZUTVHmRlVc7TjaDFH6aM2R303Ve+N1hjDnW4Xwn2mgcVwpyfFcKfNxHCnc8Rw73AP4c7vfGO485vZGO701Rju9FV/7u8vcewzfTWEe6evxnCnr8Zwp6/6c3+/fX7v9NUY7h3uIdzpqzHc6asx3OmrMdzpq/7cDX9P0OmrIdwX+moMd/pqDHf6agx3+moM9w73EO701Rju9NUY7vTVGO701Rju9NUQ7it9NYY7fTWGO301hjt9NYZ7h3sId/pqDHf6agx3+moMd/pqDHf6agj3jb4aw52+GsOdvhrDnb4aw73DPYQ7fTWGO301hjt9NYY7fTWGO301hPtOX43hTl+N4U5fjeFOX43h3uEewp2+GsOdvhrDvVZ+d96KdNRK2d50amVhbzq1Eqs3nVq50ptOh84LOrUymjedWknKm06t+bw3nVpTdG86ZOVzOsdNNyu/37933HSzsoWObla20NHNyhY6XZbO+z1Zx003K1vo6GZlCx3drGyho5uVLXR0s7KBzqSbld//TuKYdLOyhY5uVrbQ0c3KFjodOi/o6GZlCx3drGyho5uVLXR0s7KFjm5WNtBpZOVXdMjKr+iQlV/RISu/otOh84IOWfkVHbLyKzpk5Vd0yMqv6JCVX9CZycqv6JCVX9EhK7+iQ1Z+RadD5wUdsvIrOmTlV3TIyq/okJVf0SErv6BT7AK8Nx2y8is6ZOVXdMjKr+h06LygQ1Z+RYes/IoOWfkVHbLyCzrZ7/zu6/5N57a9o/PBz/76f32863V/+ovl+fjTOzmW+4+ejuP5fSz/rkuG7xhmvwqMS/90KXn+w6V/utRxaQCXkudhXPqnS8lzOS7906Xk/QCX/ulS8p6CS/90KfnvFnDpHy5lv8KMS/90idnDCC4xe4h2ybANJvs9aFz6p0sdlwZwidnDCC4xe4h2ybDxJfsda1z6p0vMHkZwidnDAC5lv6iNS/90idnDCC4xe4h2yfA3RNlve+PSP13quDSAS8weRnCJ2cMILjF7GMElZg8juMTsYQCXsl9Hx6V/usTsYQSXmD2M4BKzhxFc6rg0gEvMHkZwidnDCC4xexjBJWYPI7jE7GEAlw5mDyO4xOxhBJeYPYzgErOHEVzquDSAS8weRnCJ2cMILjF7GMElZg8juMTsIb1L/XZj9jCCS8weRnCJ2cMILjF7GMGljksDuMTsYQSXmD2M4BKzhxFcYvYwgkvMHgZwaWL2MIJLun1pWW8Pl27TO5fm7Q5+6svt+9X9+CP5+4uX7eknfzn6RL5DPoi8bq+JJq/bVaLJ6/aPaPK6neJK8sfy68XrbTkjr9sTgsk33ewfTV73d4nR5HV/P3gp+elBfj0jT4eNIt8hH0SeDhtFng4bRZ4OG0WeDnsF+f1xZWjfz8jTYYPIz3TYKPJ02CjydNgo8nTYKPId8kHk6bBR5OmwUeTpsFHk6bBR5OmwQeQ7HTaKPB02ijwdNoo8HTaKfId8EHk6bBR5OmwUeTpsFHk6bBR5OmwQ+YUOG0WeDhtFng4bRZ4OG0W+Qz6IPB02ijwdNoo8HTaKPB02ijwdNoj8SoeNIk+HjSJPh40iT4eNIt8hH0SeDhtFng4bRZ48byPfpn5/I23f3pE37HTayPNR5MnzUeTJ81HkyfNR5DvkLyBv2DixkeejyJPno8jzO6ko8vxOKoo8HTaI/E6HvYK8YW6z02GjyNNho8jTYaPId8gHkafDRpGnw0aRp8NGkafDRpGnwwaRP+iwUeTpsFHk6bBR5OmwUeQ75IPI02GjyNNho8jTYaPI02GjyNNhY8h/IYZ8EHk6bBR5OmwUeTpsFPkO+SDydNgo8nTYKPJ02CjydNgo8nTYIPITHTaKPB02ijwdNoo8HTaKfId8EHk6bBR5OmwUeTpsFHk6bBD5ppvnp315vOt/8HtJ3rC9Y2q6Cd2fpW7m9mfZYenGUjcX+7PUTbqfsTzuL15vyxlL3ezqz1I3jfqz1P0diTvLWfe3Hh+yfLuNZprpPX4s6T1+LOk9fiw7LN1Y0nv8WNJ7bCwN88uZ3uPHkt7jx5Le48ay03v8WNJ7/FjSe/xY0nv8WHZYurGk9/ixpPf4saT3+LGk9/ixpPe4sVzoPX4s6T1+LOk9fizpPX4sOyzdWNJ7/FjSe/xY0nv8WNJ7/FjSe9xYrvQeP5b0Hj+W9B4/lvQeP5Ydlm4s6T1+LOk9fizpPX4s6T1+LOk9biw3eo8fS3qPH0t6jx9Leo8fyw5LN5a6+fI23zW229HfsTTsNdh086U/S9186c5y182X/ix186U/S918+RlLw46IXTdf+rPssHRjqTtX92epO1f/kOX77+Lv9B4/lvQeP5b0HjeWB73HjyW9x48lvcfG0jC/POg9fiw7LN1Y0nv8WNJ7/FjSe/xY0nv8WNJ7vFi2G73HjyW9x48lvcePJb3Hj2WHpRtLeo8fS3qPH0t6jx9Leo8fS3qPG0vh6/D+LOk9fizpPX4s6T1+LDss3VjSe/xY0nv8WNJ7/FjSe/xY0nvcWDZ6jx9Leo8fS3qPH0t6jx/LDks3lvQeP5b0Hj+W9B4/lvQeP5b0HjeWM73Hj6Vsvpz2B57p6Ps7lu/3GjTd++MXsJTNlxewlM2XF7CUzZcXsJTNlx+yfL8jouneH/dnqXt//AKWsnP1C1jKztU/Zfn2u/hN9/74BSw7LN1Y0nv8WNJ7/FjSe/xY0ntsLA3zS9374/4sde+PX8CS3uPHkt7jx5Le48eyw9KNJb3HjyW9x48lvcePJb3HjyW9x42l7v3xC1jSe/xY0nv8WNJ7/Fh2WLqxpPf4saT3+LGk9/ixpPf4saT3uLHUvT9+AUt6jx9Leo8fS3qPH8sOSzeW9B4/lvQeP5b0Hj+W9B4/lvQeN5Y7vcePJb3HjyW9x48lvcePZYelG0t6jx9Leo8fS918ud3W+4/etuMdS8NeA9374xew1M2X/ix186U/S9186c+yw9LE0vDdUt374xew1M2X/ix15+r+LHXn6v4s6T1eLGfd++Mfsnzfx2fd++MXsKT3+LGk9/ix7LB0Y0nv8WNJ7/FjSe/xY0nv8WNJ73FjqXt//AKW9B4/lvQeP5b0Hj+WHZZuLOk9fizpPX4s6T1+LOk9fizpPW4sde+PX8CS3uPHkt7jx5Le48eyw9KNJb3HjyW9x48lvcePJb3HjyW9x42l7v3xC1jSe/xY0nv8WNJ7/Fh2WLqxpPf4saT3+LGk9/ixpPe4sSx2f3w/Hj+7vfnZS3/Q6b+/jyc6tRKjN51aGdCbTofOCzq1cpo3nVrJy5tOrSzlTadWOvKmU2vO60yn2IVrbzpk5Vd0dLPyfrvTOZYzOrpZ2UKnQ+cFHd2sbKGjm5W3bzrrGR3drGyho5uVLXR0s7KBTrGryN50dLOyhY5uVl7uP3lZtzM6ulnZQqdD5wUd3axsoaOblS10dLOyhY5uVrbQ0c3KBjrFLul609HNyhY6ZOVXdMjKr+h06LygQ1Z+RYes/IoOWfkVHbLyKzpk5Rd0il1f9aZDVn5Fh6z8ig5Z+RWdDp0XdMjKr+iQlV/RISu/okNWfkWHrPyCTrFLst50yMqv6JCVX9EhK7+i06Hzgg5Z+RUdsvIrOmTlV3TIyq/okJXP6fRi10e96STPO9v8TWeflzd0ju3+fb1jm88UdznFyXPJBYqTZ40LFCfPDxcoTp4JPlP89b5vj5e3481PP/b7zz6O00/25Kkgmk/263zhfJJP0cL5JJ+jhfMplSwv4NPh85JPqdT6GZ9PWt75u35iWSoPB7MslbSDWQpneHeWwnnfm2X2C3ZDsRTuEe4shTuHO0vhfuLOssPSjSW9x48lvcePJb3HjyW9x48lvceNZfYLdkOxpPf4saT3+LGk9/ix7LB0Y0nv8WNJ7/FjSe/xY0nv8WNJ73Fj2ek9fizpPX4s6T1+LOk9fiw7LN1Y0nv8WNJ7/FjSe9xYZr+gl4Wl4d5ez35vbyiWPHtsLA3fpM1+j20oljx7/Fgyc/NjyczNjWX2O3JDsSRfmliu0/rrtevczliSL/1YMnPzY9lh6caS3uPHkt7jx5Le48eS3uPHkt7jxjL7TcChWNJ7/FjSe/xY0nv8WHZhlp+8k7k9fvL8/JOn6ZmmcvPxp6ncffxpKrcff5rK/cefpnIDcqeZ/dbjYDSVW9BHNJf2oLlOZzSVe5A/TeUm5E+zQ9ORJl3IkyZdyJMmXciTJl3oL2juZzTpQo40s9/yHIwmXchI8/hulsdZs8x+K3QwmnQhT5odmo406UKeNOlCnjTpQp406UL/5dV3dbNfUw3ms2S/pxrOhwbymg+d4jUfWsJrPh0+L/nUuvb7/lLcUuzar0VxrWu/FsWlUqtJcakcalFc6yKvSXGprGhSXCr9mRSXynMmxV1OsVzmqnVR1qRYLnPVus5qUiyXuWpdOjUplstcta6GmhTLZa5aFzhNiuUyV61rlibFcpmr1mVIk2K5zFXryqJJsVzmqnWx0KRYLnPVuv5nUiyXuWpd0jMplstcta7SmRTLZa5aF95MiuUyV61raSbFcpmr1uUxk2K5zFXripdJsVzm6nKZq8tlrkUuc9W682ZSLJe5FrnMtXQ5xXKZq9b1OpNiucxV6xKcSbFc5qp1Vc2kWC5z1bpQZlIsl7lqXfsyKZbLXLUuZ5kUy2WuWleoTIrlMleti04mxXKZq9Z1JJNiucxV69KQSbFc5qp1scekWC5z1bp8Y1Isl7lqXZAxKZbLXLUusZgUy2WuWhdNTIrlMletyyAmxXKZq9aFDZNiucxV61KFSbFc5qp18cGkWC5z1bqcYFIsl7lqXSAwKZbLXLU2+ZsUq2Wutda2fZNitcy11tqIb1KslrnWW5dTrJa5Vrk99KvcHvpVbg/9KreHfpXbQ7/K7aFf5fbQr3J76Fe5PfSr3B76VW4P/VprR/mH96/24/FO2pvXLv1+Lnzp8wnLWtvPg1kq3z30Zql8I9GbpfI9RW+WHZZuLJUvrnuzVL637s1S+dq6N0vlW+veLOk9bixrXSC4kOV+/8HLsZyxpPf4saT3+LGk9/ix7LA0sdy+Wa5nLOk9fizpPX4s6T1+LOk9fizpPW4sa10BuZDlcn8fy3r2e8ha90WCWdJ7/FjSe/xYdli6saT3+LGk9/ixpPf4saT3+LGk97ixrHWJJ5glvcePJb3HjyW9x49lh6UbS3qPH0t6jx9Leo8fS3qPH0t6jxvLWtewglnSe/xY0nv8WNJ7/Fh2WLqxpPf4saT3+LGk9/ixpPf4saT3uLGsdZEumCW9x48lvcePJb3Hj2WHpRtLeo8fS3qPH0t6jx9Leo8by+x3/ZZ9fbyR9TjesDy2+/aBY5vPFCdPgRcoTp7VLlDc5RQnzz0XKE6eTj5T/NlTwLKpM/sVwHA+yVNEOJ/kE9FoPtnvEYbzKZUsL+BTKodewKdUar2u5Z2/6yeWHZZuLEsl7WCWwhnenaVw3ndnKdwN3FkK9whnllv2e5xDsRTuJ+4shbuMO0t6jx/LDks3lvQeP5b0Hj+W9B4/lvQeP5b0HjeW2W/iDsWS3uPHkt7jx5Le48eyw9KNJb3HjyW9x48lvcePJb3HjyW9x41l9gvhQ7Gk9/ixpPf4saT3+LHssHRjSe/xY0nv8WNJ7/FjSe/xY0nvcWOZ/XpwFpaGa+tb9uvBQ7Hk2WNj+X7zwJb9SutQLHn2uLHMfqV1KJbM3PxYMnPzY0m+NLFcp/v7WOd2xrLD0o0lMzc/lszc/FjSe/xY0nv8WNJ73Fhmv9I6FEt6jx9Leo8fS3qPH8sOSzeW9B4/lsq954N30tf5rrGvT0TaND3TVG4+/jSVu48/TeX2404z+7XWwWgqNyB/msodyJ+mcgv6iOa6PGhu/Yxmh6YjTeUm5E+TLuRJky7kSZMu5EmTLuRIM/sF15Q09+mMJl3IkyZdyJMmXchGc7s9muU2nTXL7JdcB6NJF/KkSRfypEkX8qRJF/KkSRdypLnThYw0H2eP//EHw2c06UKeNOlCnjTpQp40OzQdadKFPGnShTxp0oX+y6ttJsqXpk186Csv+ShfmjbxoVO85kNLeM2H3P+aT6/Ex3B7fKt149mkuFQiNikulVpNikvlUJPiUsnSoHivdSHYpLhU+jMpLpXnTIpLJTST4i6nWC1z7bWuwJoUq2WuvdZFVZNiucxV6zqpSbFc5qp16dOkWC5z1bqaaVIsl7lqXaA0KZbLXLWuOZoUy2WuWpcRTYrlMletK4MmxXKZq9bFPpNiucxV6/qdSbFc5qp1Sc6kWC5zzXKZa5bLXLNc5qp1a9CkuMsplstcs1zmqnWb0aRYLnPVunNoUVzrGqFJsVzmqnXZz6RYLnPVupJnUiyXuWpdnDMplstcta63mRTLZa5al9BMiuUyV62rYibFcpmr1oUuk2K5zFXr2pVJsVzmqnU1yqRYLnPVur5kUiyXuWpdMTIplstcta4BmRTLZa5aV3VMiuUyV63rNCbFcpmr1pUXk2K5zFXrWopJsVzmqnV1xKRYLnPVut5hUiyXuWpdwTAplstcta5JmBTLZa5aVxlMiuUyV63rBibFcpmr1pUAk2K5zFVrN79JsVzmqrU/36RYLnPV2nFvUiyXueT20O9ye+h3uT30u9we+l1uD/0ut4f+kNtDf8jtoT/k9tAfcnvoj1uXU6yWuQ65PfSH3B76Q24P/SG3h/6Q20N/yO2hP+T20B9ye+gPuT30h9we+kNuD/0ht4f+kNtDf8jtoT/k9tAfcnvoD7k99IfcHvpDbg/9IbeH/pDbQ3/I7aE/5PbQH3J76A+5PfSH3B76Q24P/SG3h/6Q20N/yO2hP+T20B9ye+gPuT30R60d5V/v+/Z4eTve/PRtPx7vpL157dLbr9cufT5jWepJH8yyVIYIZtlh6cayVO4JZlkqUQWzLJXVglmWSoHBLEvN9GJZ1trmH8yS3uPHkt5jY7nff/ByLGcs6T1+LDss3VjSe/xY0ntsLLdvlusZS3qPH0t6jx9Leo8by1oXNYJZ0nv8WNJ7bCyX++8hl/Xs95C17osEs+ywdGNJ7/FjSe/xY0nv8WNJ7/FjSe9xY1nrqk0wS3qPH0t6jx9Leo8fyw5LN5b0Hj+W9B4/lvQeP5b0Hj+W9B43lrUuSwWzpPf4saT3+LGk9/ix7LB0Y0nv8WNJ7/FjSe/xY0nv8WNJ73FjWeu6WzBLeo8fS3qPH0t6jx/LDks3lvQeP5b0Hj+W9B4/lvQeP5b0HieWy63WhcVglsnzZe/fb2TpbzfYbfftA8c2nynucoqTZ7ULFCdPVBcoTp57LlCcPJ18pvizp8D7TZ1ffJInjmg+2W8GhvNJPhEN55N8yhnOp1SyvIBPh89LPqVS63Ut7/xdP7EslYeDWZZK2sEshTO8O0vhvO/NMvtty6FYCvcId5bCncOdpXA/cWfZYenGkt7jx5Le48eS3uPHkt7jx5Le48Yy+33ZoVjSe/xY0nv8WNJ7/Fh2WLqxpPf4saT3+LGk9/ixpPf4saT3uLHs9B4/lvQeP5b0Hj+W9B4/lh2WbizpPX4s6T1+LOk9fizpPX4s6T1uLLNfCB+KJb3HjyWZyMTy/bX1L5ZkIj+WPHtsLA2bB7JfaR2KJc8eP5bM3PxYMnPzY9lh6caSfGliuU73TUbr3M5Yki/9WDJz82PJzM2PJb3HjWX2K61DsaT3+LGk9/ixpPf4seywdGNJ7/FjSe/xY0nv8WOp3Hs+eCf7Nt017lt70jhNzzSVm487zeyXWgejqdx+/Gkq9x9/msoNyJ9mh6YjTeUW9BHNvjxoLv2MpnIP8qep3IT8adKFPGnShRxpZr/eOhhNupAnTbrQ5zTX6YwmXciTZoemI026kJHm/t0sj7Nmmf2S62A06UKeNOlCnjTpQn40p+wXXQejSRfypEkXstHc2yNv7nM/o0kX8qTZoelIky7kSZMu5EmTLuRJky7kSZMu9DnNfjKRm5TvUl9Aky7kSZMu9Id38sSHdvOaT4fPSz40kNd86BSv+dASXvMh97/mUyrJH/t9E8xxnGyCmWpdejYpLpWITYpLpVaT4lI51KS4yykulRVNikulP5PiUnnOpLhUQjMplstcta7MmhTLZa5aF1tNiuUyV63rpybFcpmr1iVRk2K5zFXrKqdJsVzmqnXh0qRYLnPVuhZpUiyXuWpdXjQplstcta4YmhTLZa5aFwFNiuUyV63reibFcplrkctci1zmWrqcYrnMVetKokmxXOZa5DJXrXuVFsW1rkqaFMtlrloXGk2K5TJXrWuHJsVymavW5UCTYrnMVesKn0mxXOaqddHOpFguc9W6DmdSLJe5al1aMymWy1y1rpaZFMtlrloXwEyK5TJXrUtaJsVymavWRSqTYrnMVeuyk0mxXOaqdSHJpFguc9W6NGRSLJe5al3sMSmWy1y1Lt+YFMtlrloXZEyK5TJXrUssJsVymavWRROTYrXM1WpdBjEpVstcrdaFDZNitczVbl1OsVrmarUuPpgUq2WuVutygkmxXOaqdYHApFguc9Xa5G9SLJe5am3bNymWy1y1NuKbFMtlrlpb602K5TKX3B76JreHvsntoW9ye+ib3B76JreHvsntoW9ye+ib3B76JreHvsntoW9ye+ib3B76JreHvsntoW9ye+ib3B76JreHvsntoW9ye+ib3B76JreHvsntoW9ye+ib3B76JreHvsntoW9ye+ib3B76JreHvsntoW9ye+ib3B76JreHvsntoW9ye+ib3B76JreHvsntoW9ye+ib3B76JreHvsntoW9ye+hbrR3lX+/79nh5O9789G0/Hu+kvXnt0tuv1y59PmNZ6kkfzLJUhghmWSqdxLKstQs+mGWpRBXMslRWC2ZZKgUGs+ywdGNZaloYzJLe48eS3mNjud9/8HIsZyzpPX4s6T1uLGvdYwhmSe+xsdy+Wa5nLOk9fizpPX4sOyzdWNJ7/FjSe/xY0ntsLJf77yGX9ez3kLXuiwSzpPe4sax1EyWYJb3HjyW9x48lvcePZYelG0t6jx9Leo8fS3qPH0t6jx9Leo8Xy7nWXaJglvQeP5b0Hj+W9B4/lh2WbizpPX4s6T1+LOk9fizpPX4s6T1uLGvdBgtmSe/xY0nv8WNJ7/Fj2WHpxpLe48eS3uPHkt7jx5Le48eS3uPGstZ9vmCW9B4/lvQeP5b0Hj+WHZZuLOk9fiyT58tpm7/hbG832G337QPHNp8pTp4C/RVnv+t3geLkieoCxclzzwWKk6eTzxR/9hQwbOqcs18BDOeTPEWE80k+EQ3nk3zKGc6nVLK8gE+pHOrPJ/tlxCv5fNLyzt/1E8tSeTiYZamkHcxSOMO7s+ywdGMp3A3cWQr3CHeWwp3DnaVwP3FnKdxlvFlmv046FEt6jx9Leo8fS3qPH8sOSzeW9B4/lvQeP5b0Hj+W9B4/lvQeN5bZLwQPxZLe48eS3uPHkt7jx7LD0o0lvcePJb3HjyW9x48lvcePJb3HjWX2C+FDsaT3+LGk9/ixJBOZWBquB8/ZrwePxDL7ldY0LA3fpM1+pXUoljx7/Fgyc/Nj2WHpxpKZmx9L8qWJ5Tqtv167zu2MJfnSjyUzNz+WzNzcWGa/0joUS3qPH0t6jx9Leo8fyw5LN5b0Hj+W9B4/lvQeP5b0Hj+Wyr3nk3fStgeRtt++X922b5o9+53WwWgqdx9/msrtx5+mcv/xp9mh6UhTuQP501RuQR/R7Ps3zek3mv/66mO+59hjfXoX+/Gnd/H4Hd129O/Xzs8mKderYUxS7m3DmEQhzG9S9ru4mPQPk6ivA5hEKx7AJMr2ACZ1TMpvEqOBAUxi4jCASUwcbO9kvvX7T56fX/3bkC37IebBaNLhHWlmP8Y8GE1asSdN6qsnTXqmJ80OTRvNeX3Q7MsZTZqbJ00qlidNupAnTbqQJ026kCPNWsfOw2nShT6n+azxd5p0IU+adCFPmh2aL1a4deVz8SY+9JXXfGggr/nQKV7zoSW85CN9Lt7Cp1SSP/b7r7+PYztTXCptmxSXSsQmxV1OcakcalJcKlmaFJfKiibFpdKfSXGpPGdRXOuwtUmxXOaqdSTapFguc9U6uGxSLJe5ah0vNimWy1y1DgGbFMtlrlpHdU2K5TJXrQO1JsVymavWsVeTYrnMVetwqkmxXOaqdYTUpFguc9U66GlSLJe5ah3HNCmWy1xbl1Msl7lqHWY1KZbLXJtc5trkMletQ7YmxXKZq9ZRWJNiucxV68CqSbFc5qp1rNSkWC5z1Tr8aVIsl7lqHdE0KZbLXLUOUpoUy2WuWscdTYrlMletQ4kmxXKZq9bRQZNitcy11DrfZ1KslrmWWmfwTIrVMtdy63KK1TLXUussm0mxWuZaah0MMymWy1y1TlmZFMtlrlpHlkyK5TJXrfM/JsVymavWYRqTYrnMVesSi0mxXOaqddHEpFguc9W6DGJSLJe5al3YMCmWy1y1LlWYFMtlrloXH0yK5TJXrcsJJsVymavWBQKTYrnMVWuTv0mxXOaqtW3fpFguc9XaiG9SLJe5am2tNymWy1xye+gXuT30i9we+kVuD/0it4d+kdtDv8jtoV/k9tAvcnvoF7k99IvcHvql1o7yD+9f7cfjnbQ3r/2K479e+xVTz1gq3zL0Zql899CbpfKNRG+WyvcUnVnW2jIfzFL54ro3S+V7694sla+te7PssHRjSe/xY0nvsbHc7z94OZYzlvQeP5b0Hj+W9B43lrUuPVzIcvtmuZ6xpPf4saT3+LGk9/ix7LB0Y0nv8WNJ77GxXO6/h/yqN2cs6T1+LOk9fizpPW4sa11bCWZJ7/FjSe/xY0nv8WPZYenGkt7jx5Le48eS3uPHkt7jx5Le48ay1sWjYJb0Hj+W9B4/lvQeP5Ydlm4s6T1+LOk9fizpPX4s6T1+LOk9XizXWlfHglnSe/xY0nv8WNJ7/Fh2WLqxpPf4saT3+LGk9/ixpPf4saT3uLGsdfkvmCW9x48lvcePJb3Hj2WHpRvL5Pny1pbHG7nt6xuWhu0Da/a7fhcoTp7V/BVnv+t3geLkuecCxcnTyQWKk2eICxQnf9JfoDj5HPICxcmnhRcolstc2e/6faj4/c6WNftdP3/F2e/6XaC4VuayKK6Vud7vbFiz3/W7QHGXU1wrc1kU18pcFsW1MpdFca3MZZhlZr/r5684+12/CxTXylwWxbUyl0VxrcxlUdzlFNfKXBbFtTKXRXGtzGVRLJe5st/181ec/a7fBYrlMlf2u34XKJbLXEuXUyyXubJfWLxAsVzmyn6t8ALFcpkr++W/CxTLZa7sV/QuUCyXubJfpLtAsVzmyn7d7QLFcpkr+6W0CxTLZa7sV8cuUCyXubJf8LpAsVzmyn4N6wLFcpkr+2WpCxSnfh4f+3J/8fH1f36j99juf0F/bGd/QZ/7Fs4FelM/iy/Qm/pJfIHe1M/hC/Smfgp/pnf66Bvrx74/fvTZp3nuayvhdFI/3cPppJ6+hNNJPakJp1MoRfrTyX2HJJxOoYQ6XbaD5vw9P5EslH2DSRZK1cEkOySdSMpme3eSsj3AnaRsZ3AnKdsv3EnKdhFnklvuOyJDkaTjeJGk43iRpON4keyQdCJJx/EiScfxIknH8SJJx/EiScdxIpn7ZshQJOk4XiTpOF4k6TheJDsknUjScbxI0nG8SNJxvEjScbxI0nGcSOa+4jMUSTqOF0lSkIGk4SbIlvvuy1AkeeJYSL7/VuGW+4bJUCR54niRZKrmRZKpmhfJDkknkuRJA8l1Wn+9dp3bGUnypBdJpmpeJJmqeZGk4ziRzH0zaCiSdBwvknQcL5J0HC+SHZJOJOk4XiTpOF4k6TheJOk4XiTpOE4kc9/oGookHceLJB3Hi6Rux/ngfbRj6XeFz3spp6P/LfcO9xDuuv0plrtu24rlrtvNnLg/sdRtZ/4sdfuZO8vcF/0GY6nb0fxZ6rY0f5b0ND+WHZZuLOlTfizpSH4s6T2G9zHf5vsxqfm2335j+Xd9M/c1y8Lc6VPu3L2/75j7Cige/dMj+l9+j+iV+T2ir+b3qONReo/o1/k9orfn94h5QH6PmB3k94g5Q3qPKt03L+sRc4b8HjFnyO8Rc4b8HnU8Su8Rc4b8HjFnyO8Rc4b8HjFnyO8Rc4b0Hh3MGfJ7xJwhv0fMGfJ7xJwhv0f0o1CPLPv1D/pRdo/2G7ku1qP3u673G7kuv0fkuvwekevye9TxKL1H/P4ov0f0o1CPDN/j22/0o/we8fuj/B7x+6P0Hk3MGfJ7xJwhv0fMGfJ7xJwhv0cdj9J7xJwhv0fMGfJ7xJwhv0fMGfJ7xJzB36MPfvI0rfcXT9O2fr/6uD251Jg0jOASs4YRXGLaMIJLzBtGcKnj0gAuMXMYwSWmDj/o0hN3Jgkx3JkOWLhPt/sfRs3Tk8K/3rS9Nxp/CPeZDu/O3fkbWPtMg8/vEf09v0e09/wedTxK7xHNPb9H9Pb8HtHx83vEPCC/R8wO0nvUmTPk94g5Q36PmDPk94g5Q36POh6l94g5Q36PmDPk94g5Q36PmDPk94g5Q3qPFuYM+T1izpDfI+YM+T1izpDfo45H6T1izpDfI+YM+T1izpDfI+YM+T1izpDeo5U5Q36PmDPk94g5Q36PmDPk96jjUXqPmDPk94g5Q36PmDPk94g5Q36PmDOk92hjzpDfI/pRqEeW66tbx6P0HpHrYj0yXLvbyHX5PSLXpfdoJ9fl94jfH+X3iN8f5feIfhTqkWUP5N7xKL1H/P4ov0f8/ii/R8wZ8nvEnCG/R8wZ0nt0MGfI7xFzhvweMWfI7xFzhvwedTxK7xFzhvweMWfw9+iDnzz1h8KpP12eatP6t44ylajmKDOMao4y8ajl6HFjPpLW0SeXmJCM4BIzkhFcYkoygksdlwZwiUnJCC4xKxnBJeYfI7jETCPWpWW5s5uWdf3NpT+8+suN+6unuZ91YKYa5TydmGsM5GlrD9B9OXOUGUg1R5mXVHOU2Uo1RzuOFnOUmU01R5nvVHOUWdBIji7LHfQ2nTnK3Kiao0yNYh1d5/tKpWl9/iT9N6ZGjalRPU+ZGw3kqSUdNeZG1RxlblTN0Y6jxRxlblTNUeZG1RxlblTNUeZGIzlqmBs15kbFHJ2ZGsU6uj1+8peo6T88pkYzU6N6njI3GshTSzqamRtVc7TjaDFHmRtVc5S5UTVHmRtVc5S5UTVHmRuN5KhhbtSZG1VzlKlR8Gx3O74dbW8c3bb70Gjb16d38ZujzIyqOcrMqJqjHUdjn6PLY/q+PV9B+zdm9Z2pUT1PmRsN5Kmlk3bmRtUcZW5UzVHmRsUcXZgbVXOUuVE1R5kbVXOUudFIjhqm9UvH0WKOMjXK4+j2+9/WP7nEHGgEl5jtjOAS85pYl/bb/bE07dP+Hx5z8oWJTTlPV2Y2A3lq6YMrM5tqjjKzqeYoM5tqjnYcLeYoM5tqjjLfqeYos6CRHDVMylfmRtUcZWpUzNGNmVE1R5kZVXOUmVE1R5kZVXO042gxR5kZ5XG0/X5N58kl5kAjuMRsZwSXmNf8oEtP3JmqhHDfmX2YuO93HnNr6xvulmS1M6GI4c4cwZ37th+Pn9z++l08ecRkIL9HHY/Se0R7z+8R3T2/RzT3/B7R2/N7RMdP79HBPCC/R8wO8nvEnCG/R8wZ8nvU8Si9R8wZ8nvEnCG/R8wZ8nvEnCG/R8wZknu0fqnCo/QeMWfI7xFzhvweMWfI71HHo/QeMWfI7xFzhvweMWfI7xFzhvweMWdI79HEnCG/R/SjUI+W3n69dumnHnU8Su8RuS7Wo+X+5bzl+crG7x6R6/J7RK5L71Ej1+X3iN8f5feI3x/l94h+FOrROq2/XrvO7cyjjkfpPeL3R/k94vdH+T1izpDfI+YM+T1izpDeo5k5Q36PmDPk94g5Q36PmDPk96jjUXqPmDP4e/TBT55u+/3F09f7/351uz27xKRhBJeYNYzgEtOGEVxi3jCAS52JwwguMXMYwSWmDsEuPf684cul6TeX/vST+68Xb/vzu3juVp0ZRTVHO44Wc5T5R6yjU/t+NvbTZyPzjxFcYv4xgkvMP0ZwifnHAC4tzD9GcIn5xwguMf9I5NJ+5hIzjRFc6rg0gEvMHn7QpSfuTBNiuDMfsHBvyzf3tb/hbvkbr4XGH8OdDu/OvbUHjr6ccF9p5THc6dkx3GnOMdzpwjHcO9xDuNNX/bkvyx3HNp1xp6/GcKevxnCnr8Zwp6+GcN/oqzHc6asm7sd9ne883xaHudhGX43hTl91527pTVuHewh3+moMd/pqDHf6agx3+moMd/qqP3dDb9rpqzHc6asx3OmrMdzpqzHcO9xDuNNXY7jTVy3c53l5cN+nN9yn5Y5jWvoZd/pqDHf6qjt37zujO902vUcHPTi/R3Tm/B7Rr/N7RBfP71HHo/Qe0fHze8Q8IL9HzA7ye8ScIb9HzBmye/QlC4/Se8ScIb9HzBnye8ScIb9HHY/Se8ScIb9HzBnye8ScIb9HzBnye8ScIb1HE3OG/B4xZ8jvEXOG/B4xZ8jvUcej9B4xZ8jvEXOG/B4xZ8jvEXOG/B4xZ0jvUWPOkN8j+lGoR0u/f8l16acedTxK7xG5Ltajx8HwZd3OPCLX5feIXJfeo5lcl98jfn+U3yN+f5TfI/pRqEeGfdfT3PEovUf8/ii/R/z+KL9HzBnye8ScIb9HzBnSe9SZM+T3iDlDfo+YM+T3iDlDfo86HqX3iDlDfo+YM+T3iDlDfo+YM+T3iDlDeo8W5gz5PWLO4O/RBz952h8vnvZjfWJ3/K2jTCWqOcoMo5qjHUeLOcp8JK2jTy4xIRnBJWYkI7jElGQEl5iTDODSyqRkBJeYlYzgEvOPEVxipjGCSx2XBnCJ2UOsS0e/f+FtOo75N5f+QPr9RfVpZU5RzVFmGgM56r0NaGVWouw+Mxhh9zdmO8ruMzNSdp9ZlLL7zLiU3e+4L+w+Mzll95nfKbvPrE/ZfWZ9yu4z6xN2f2fWp+w+sz5l95n1KbvPrE/Z/Y77wu4z61N2n1mfsvvM+pTdZ9an7D6zPmH3D2Z9yu4z61N2v+N+TfctN2kP+r6y+2T+qu4b7hYeZH5d99uNzK/sPplf2X1+v6/sPr/fV3a/435N9w27fduNvq/sPr/fV3af3+8ru8+sT9l9Zn3C7k/M+pTdZ9an7D6zPmX3mfUpu99xX9h9Zn3K7jPrU3afWd9I7n/yk6f1/uJp2p7uKBy3Z/+Z9mn7z7xP2v/GxE/bf2Z+2v4z9dP2n7mftv8d/yv4/+Qo07xqjjKhC3W03dr9xe22tTeOGi7jtcbUrZqjzNEGctR5N0JrTNGE3Z+ZoSm7zwRN2X3mZ8ruMz1Tdr/jvrD7zNmU3Wcmp+w+8ztl95n1KbvPrE/Y/c6sT9l9Zn3K7jPrU3afWZ+y+x33hd1n1qfsPrM+ZfeZ9Sm7z6xP2X1mfcLuL8z6lN1n1qfsPrM+Zffp+0XdN1y7awt9X9l9Mn9V9w1Xb1Yyv7L7ZH5l98n8yu7z+31l9zvuC7tP3y/qvmUH8krfV3af3+8ru8/v95XdZ9Yn7P7GrE/ZfWZ9yu4z61N2n1mfsvsd94XdZ9an7D6zPmX3mfWN5P4HP9l27WJj2qftP/M+af93Jn7a/jPz0/afqZ+2/8z9tP3v+F/B/ydHmeZVc5QJXbCjx32Q1qapv3F0+nLj8bk79zNPmbvV85RZ2kCe9uk+Se/z7c1Pfn7tfuY+kzRh9w/maEXdb+1hSl/O3GeKpuw+MzRl95mgKbvfcV/YfWZtyu4zl6vq/nJ/y22bztxngqfsPrM+ZfeZ9em6P9+Y9Sm7z6xP2X1mfcruM+sb1P39zNGOo8UcZSZXzVHmbNUcZXZWzVHmYdUcZcZVzNGJuVU1R5lFVXOU+VI1R5kZxTo6fX8fa+rvvo9l+qbHPHU8Lecpc6N6njI5qucps6N6njI9qucp86NynjYmSPU8ZYZUz1OmSPU8ZY5Uz9OOp+U8ZY5Uz1PmSPU8ZY5Uz1PmSPU8ZY5UztOZOVI9T5kj1fOUOVI9T5kj1fO042k5T5kj1fOUOVI9T5kj1fOUOVI9T5kjlfO0M0eq5ylzpHqeMkeq5ylzpHqedjwt5ylzpHqeMkeq5ylzpHqeMkeq5ylzpHKeLsyR6nnKHKmep8yR6nnKHKmepx1Py3nKHKmep8yR6nnKHKmep8yR6nnKHKmcpytzpHqeMkeq5ylzpHqeMkeq52nH03KeMkeq5ylzpHqeMkeq5ylzpHqeMkcq5+nGHKmep8yR6nnKHKmep8yR6nna8bScp8yR6nnKHKmep8yR6nnKHKmep8yRynm6M0eq5ylzpHqeMkeq5ylzpHqedjwt5ylzpHqeMkeq5ylzpHqeMkeq5ylzpHKeHsyR6nnKHKmep8yR6nnKHKmepx1Py3nKHKmep8yR6nnKHKmep8yR6nnKHKmap/3GHKmep8yR6nnKHKmep8yR6nna8bScp8yR6nnKHKmep8yR6nnKHKmep8yRynk6MUeq5ylzpHqeMkeq5ylzpHqedjwt5ylzpHqeMkeq5ylzpHqeMkeq5ylzpHKeNuZI9TxljlTPU+ZI9TxljlTP046n5TxljlTPU+ZI9TxljlTPU+ZI9TxljlTO05k5Uj1PmSPV85Q5Uj1PmSPV87TjaTlPmSPV85Q5Uj1PmSPV85Q5Uj1PmSOV87QzR6rnKXOkep4yR6rnKXOkep52PC3nKXOkep4yR6rnKXOkep4yR6rnKXOkcp4uzJHqecocqZ6nzJHqecocqZ6nHU/LecocqZ6nzJHqecocqZ6nzJHqecocqZynK3Okep4yR6rnKXOkep4yR6rnacfTcp4yR6rnKXOkep4yR6rnKXOkH/T0iTuznhDuG/OYGO7MTGK4M9eI4c7sIYZ7h3sIdzq8hXtv7c69z8cb7rYEv9G0o8jTh93Jf73k/uKlv/nJ67T+eu06tzOP6Lf5PaILp/dopzeHetTaA11fzjyiY+f3iD6e3yO6e36POh6l94iZQH6PmB7k94g5Q6xHy31Y2rbpzCPmDPk9Ys6Q3qODOUN+j5gz5PeIOUN+j5gzXOnResq9wz2EO/OAGO50/Bju9PYY7nRxE/dtf3A/ljfcbX8Rc9CwY8gvN3qzO3nnv6FYbvTm/B7Rm0M9Mvw+ZLnRm/N71PEovUf08fwe0d3ze0TPz+8RM4FYj97/PmS5MT1I79HEnCG/R8wZ8nvEnCG/R8wZ8nvU8Si9R8wZrvRoPeXO7CCGO/OAGO50/Bju9PYQ7o0uHsOdfh3Dnc4cw50eHMO9wz2EO33Vwn15/DnVvMzvdgja/oqx0VijyNNZo8jTWqPI01uDyM801yjydNco8rTXKPL01yjyHfJB5OmwUeTpsFHk6bBR5OmwUeTpsEHkOx02ijwdNoo8HTaKPB02inyHfBB5OmwUeTpsFHk6bBR5OmwUeTpsEPmFDhtFng4bRZ4OG0WeDhtFvkM+iDwdNoo8HTaKPB02ijwdNoo8HTaI/EqHjSJPh40iT4eNIk+HjSLfIR9Eng4bRZ4OG0WeDhtFng4bRZ4OG0R+o8NGkafDRpGnw0aRp8NGke+QDyJPh40iT4eNIk+HjSJPh40iT4cNIr/TYaPI02GjyNNho8jTYaPId8gHkafDRpGnw0aRp8NGkafDRpGnwwaRP+iwUeTpsFHk6bBR5OmwUeQ75IPI02GjyNNho8jTYaPI02GjyNNhY8ivNzpsFHk6bBR5OmwUeTpsFPkO+SDydNgo8nTYKPJ02CjydNgo8nTYIPITHTaKPB02ijwdNoo8HTaKfId8EHk6bBR5OmwUeTpsFHk6bBR5OmwQ+UaHjSJPh40iT4eNIk+HjSLfIR9Eng4bRZ4OG0WeDhtFng4bRZ4OG0R+psNGkafDRpGnw0aRp8NGke+QDyJPh40iT4eNIk+HjSJPh40iT4cNIt/psFHk6bBR5OmwUeTpsFHkO+SDyNNho8jTYaPI02GjyNNho8jTYYPIL3TYKPJ02CjydNgo8nTYKPId8kHk6bBR5OmwUeTpsFHk6bBR5OmwQeRXOmwUeTpsFHk6bBR5OmwU+Q75IPJ02CjydNgo8nTYKPJ02CjydNh/eR/fdDZ65is6dMFXdOhrr+jQqV7R6dB5QYdu8ooO/eEVHTL+Kzrk8Fd0yMov6Oxk5Vd0CmXlY98fL97O9BZKvya9hfKsSW8X01soc5r0FkqRJr2FcqFJb6GkZ9JbKLtZ9B6F0phJr1i+OsTy1SGWr44uplcsXx1i+eoQy1eHWL46tPLVdtPKV9tNK19tN618td208tV262J6tfLVdtPKV9tNK19tN618td3E8tUklq8msXxV6UK9Sa9Yvqp0jd2kVyxfVbo8btIrlq8qXdk26RXLV5UuSpv0iuWrSteTTXrF8lWlS8EmvWL5qtJVXJNesXxV6QKsSa9Yvqp07dSkVyxfVbrsadIrlq8qXbE06RXLV5UuNpr0iuWrStcJTXrF8lWlS3wmvWL5qtLVOZNesXxV6cKaSa9Yvqp0TcykVyxfVbqcZdIrlq8qXYky6RXLV5UuIpn0iuWrStd/THrF8lWlSzcmvWL5qtJVF5NesXxV6YKJSa9Yvqp0rcOkVyxfVbpMYdIrlq8qXWEw6RXLV5UuDpj0iuWrSpv7TXrF8lWl7fomvWL5qtIGfJNesXxVaUu9Sa9Yvqq0Sd6kVyxfVdr2btIrlq/E9rdvYvvbN7H97ZvY/vZNbH/7Jra/fRPb376J7W/fxPa3b2L72zex/e2b2P72TWx/+ya2v30T29++ie1v38T2t29i+9t3sf3tu9j+9l1sf/sutr99v3UxvVr5ahfb376L7W/fxfa372L723ex/e272P72XWx/+y62v30X29++i+1v38X2t+9i+9t3sf3tu9j+9l1sf/sutr99F9vfvovtb9/F9rfvYvvbd7H97bvY/vZdbH/7Lra/fRfb376L7W/fxfa372L723ex/e272P72XWx/+y62v30X29++i+1v38X2t+9i+9t3sf3tu9j+9l1sf/sutr99F9vfvovtb9/F9rfvYvvbd7H97bvY/vZdbH/7Lra/fRfb376L7W/fxfa372L723ex/e272P72XWx/+y62v30X29++i+1v38X2t+9i+9t3sf3tu9j+9l1sf/sutr99F9vfvovtb9/F9rfvYvvbd7H97bvY/vZdbH/7Lra/fRfb376L7W/fxfa372L723ex/e272P72XWx/+y62v30X29++i+1v38X2t+9i+9t3sf3tu9j+9l1sf/sutr99F9vfvovtb9/F9rfvYvvbd7H97bvY/vZDbH/7Iba//RDb336I7W8/bl1Mr1a+OsT2tx9i+9sPsf3th9j+9kNsf/shtr/9ENvffojtbz/E9rcfYvvbD7H97YfY/vZDbH/7Iba//RDb336I7W8/xPa3H2L72w+x/e2H2P72Q2x/+yG2v/0Q299+iO1vP8T2tx9i+9sPsf3th9j+9kNsf/shtr/9ENvffojtbz/E9rcfYvvbD7H97YfY/vZDbH/7Iba//RDb336I7W8/xPa3H2L72w+x/e2H2P72Q2x/+yG2v/0Q299+iO1vP8T2tx9i+9sPsf3th9j+9kNsf/shtr/9ENvffojtbz/E9rcfYvvbD7H97YfY/vZDbH/7Iba//RDb336I7W8/xPa3H2L72w+x/e2H2P72Q2x/+yG2v/0Q299+iO1vP8T2tx9i+9sPsf3th9j+9kNsf/shtr/9ENvffojtbz/E9rcfYvvbD7H97YfY/vZDbH/7Iba//RDb336I7W8/xPa3H2L72w+x/e2H2P72Q2x/+6G1v327ae1v/9Irla++9Erlqy+9UvnqS28X0yuVr770SuWrL71S+epLr1S++tIrlq+09rd/6RXLV1r727/0iuUrrf3tX3rF8pXW/vYvvWL5Smt/+5desXyltb/9S69YvtLa3/6lVyxfae1v/9Irlq+09rd/6RXLV1r727/0iuUrrf3tX3rF8pXW/vYvvWL5Smt/+5desXyltb/9S69YvtLa3/6lVyxfae1v/9Irlq+09rd/6RXLV1r727/0iuUrrf3tX3rF8pXW/vYvvWL5Smt/+5desXyltb/9S69YvtLa3/6lVyxfae1v/9Irlq+09rd/6RXLV1r727/0iuUrrf3tX3rF8pXW/vYvvWL5Smt/+5desXyltb/9S69YvtLa3/6lVyxfae1v/9Irlq+09rd/6RXLV1r727/0iuUrrf3tX3rF8pXW/vYvvWL5Smt/+5desXyltb/9S69YvtLa3/6lVyxfae1v/9Irlq+09rd/6RXLV1r727/0iuUrrf3tX3rF8pXW/vYvvWL5Smt/+5derXw1ie1vn8T2t09i+9snsf3tX2rE9Grlq0lsf/sktr99EtvfPontb5/E9rdPYvvbJ7H97ZPY/vZJbH/7JLa/fRLb3z6J7W+fxPa3T2L72yex/e2T2P72SWx/+yS2v30S298+ie1vn8T2t09i+9snsf3tk9j+9klsf/sktr99EtvfPontb5/E9rdP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"},{"name":"lookup_validity","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"consumer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"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","debug_symbols":"5Z3tjiTHcUXfhb8FoyIrIz/0KoZh0LZsEBAow6INGILe3UVrumdXrEUmS6XucyN/iZS6tuOSPffE7E4c/em7f/vdv/z3f/zzDz/++x/++N1v//FP3/3+D//6/U8//OHH4+/+9N32D/X//8s//uf3P/7893/86fv/+um7326/+e53P/7b8Z9//s13//7D73/33W/3Zn/+zS9eV1P9eGXN7fna1v78T785fun2N/3SzT5e2bbyi1+6/y2/dNufv/TJ1Lb9Tb92TY9fu5382nb2a++t7h8P7d1s8A773p+vzlafr7aSPt4kveJN9le8SX7Fm/gr3qS84k3qK96kveJN+gveJG2veJNXfMWnV3zFp1d8xadXfMWnV3zFp1d8xadXfMWnV3zFp1d8xe+v+IrfX/EVv9/xFZ+9Pt+kfv0mv3x1Sttja0op7Z+vtvIx0s4bKfNGct5IhTdS5Y3UeCN13Eh5441kvJF47Z157Z157Z157Z157Z157Z157Z157e289nZeezuvvZ3X3s5rb+e1t/Pa23nt7bz2dl57F157F157F157F157F157F157F157F157F157F157V157V157V157V157V157V157V157V157V157V157N157N157N157N157N157N157N157N157N157N157d157d157d157d157d157d157d157d157d157d15728arb9t4/W0br8Bt4zW4bbwKt43X4bbxStw2Xovbxqtx24A9bsAeN2CPG7DHDdjjBuxxA/a4AXvcgD1uwB43YI8nYI8nYI8nYI8nYI8nYI8nYI8nYI8nYI8nYI8nYI/vwB7fgT0OPMY04DWmAc8xDXiPacCDTANeZBrwJNOAN5kGPMo04FWmAc8yDXiXacDDTANeZhrwNNOAt5kGPM404HWmAc8zDXifacADTQNeaBrwRNOAN5oGPNI04JWmAc80DXinacBDTQNeahrwVNOAt5oGPNY04LWmAc81DXivacCDTQNebBrwZNOAN5sGPNo04NWmAc82DXi3acDDTQNebhrwdNOAt5sGPN404PWmAc83DXi/acADTgNecBrwhNOAN5wGPOI04BWnAc84DXjHacBDTgNechrwlNPuueVMX8zUBjP1Uh+v7jXlL2baTl5tW8uPUX7+669f/5GhBMhQA2RoATJ0fIbaPzO07ZcZ0j33q2/OYAEypAAZ9gAZcoAMfE6PM/A5Pc7A5/Q4A5/T4wwBOG0BOG0BOG0BOG0BOH3PffWbMwTgtAXgtAXgtAXgtAXgdArA6RSA0ykAp1MATt9zP//3zNDtM0NPpxnwnJ7IgOf0RAY8pycy4Dk9kQHP6XGGHc/piQx4Tk9kwHN6IgOe0xMZAnB6D8DpPQCn9wCc3gNweg/A6RyA0zkAp3MATucAnL7Hf/HmDAE4nQNwOgfgdA7A6czntH+RoZxlcD6nxxn4nB5n4HN6nIHP6XEGPqfHGficHmfgc3qcgc/pcQY+p8cZAnC6BOB0CcDpEoDTJQCn7/HXvDlDAE6XAJwuAThdAnC6BOB0DcDpGoDTNQCnawBO3+Mn+rtm6P6ZoZezDHxOjzPwOT3OwOf0OAOf0+MMfE4PMzQ+p8cZ+JweZ+BzepyBz+lxhgCcbgE43QJwugXgdAvA6RaA0z0Ap3sATvcAnO4BOH2PX+zNGQJwmu8jm8gQgNN8H9lEBjqnbdvLI8Px1/WXGXa8j2wmA53TMxnonJ7JQOf0TAY6p2cy0Dk9k4HO6ZkMdE7PZKBzeiZDAE7jfWQzGQJwGu8jm8kQgNN4H9lMhgCcxvvIZjIE4DTeRzaTIQCn8T6ymQwBOI33kc1kCMBpvAfLSmnPDKX0swx4PkxkwPNhIgOeD+MMeA/WTAY8HyYy4PkwkQHPh4kMOUAG/PdxExkCcBrvwZrJEIDTeA/WRAa8B2smQwBO4z1YMxkCcBrvwZrJEIDTeA/WTIYAnMZ7sGYyBOA03oM1kyEAp/EeLKvb5+9V1u3s9yrxHqyZDHhOT2TAc3oiA57TExnwnJ7IgOf0RAY8p8cZ8B6smQx4Tk9kCMBpvAdrJkMATuM9WDMZAnAa78GayRCA03gP1kQGvAdrJkMATuM9WDMZAnAa78GayRCA03gP1kwGPqdz/syQ/SwDn9PjDHxODzPgPVgzGficHmfgc3qcgc/pcQY+p8cZ+JweZ+BzepwhAKfxHqyZDAE4jfdgzWQIwGm8B2smQwBO4z1YMxkCcBrvwZrJEIDTeA/WTAZ9Tme+B2sigz6nM9+DVZ8v//mv21kGPqfHGficHmfgc3qcgc/pcQY+p8cZ+JweZ+BzepiB78GayMDn9DhDAE7zPVgTGQJwmu/BmsgQgNN8D9ZEhgCc5nuwxhn4HqyJDAE4zfdgTWQIwOkUgNMpAKf5PrJxhjc4pPrz1bYdf6Y5CJH640fhUv/8QTh/jG/a4yft8Xft8bP2+K49ftEev2qP37TH79LjZ23qZm3qZm3qZm3qvsH+dOv42tTN2tTN2tTN2tTN2tR1beq6NnVdm7quTd03uJxuHV+buq5NXdemrmtT17WpW7SpW7SpW7SpW7Sp+wYz063ja1O3aFO3aFO3aFO3aFO3alO3alO3alO3alP3DZ6lW8fXpm7Vpm7Vpm7Vpm7Vpm7Tpm7Tpm7Tpm7Tpu4brEm3jq9N3aZN3aZN3aZN3aZN3a5N3a5N3a5N3a5N3Tc4kG4dX5u6XZu6XZu6XZu6XZq6vklT1zdp6vomTV3fpKnrmzR1fZOmrm/S1PVNmrq+SVPXN23qmjZ1TZu6pk1d06buG/xEt46vTV3Tpq5pU9e0qWva1E3a1E3a1E3a1E3a1H2DbejW8bWpm7Spm7Spm7Spm7Spq+2mcm03lWu7qVzbTeXabirXdlO5tpvKtd1Uru2mcm03lWu7qVzbTeXabirXdlO5tpvKtd1Uru2mcm03lWu7qVzbTeXabirXdlO5tpvKtd1Uru2mcm03lWu7qVzbTeXabirXdlO5tpvKtd1Uru2mcm03lWu7qVzbTeXabirXdlO5tpvKtd1Uru2mcm03lWu7qVzbTeXabirXdlO5tpvKtd1Uru2mcm03lWu7qVzbTeXabirXdlO5tpvKtd1Uru2mcm03lWu7qVzbTeXabirXdlO5tpvKtd1Uru2mcm03lWu7qVzbTeXabirXdlMVbTdV0XZTFW03VdF2U5VNmrpF201VtN1URdtNVbTdVEXbTVW03VRF201VtN1URdtNVbTdVEXbTVW03VRF201VtN1URdtNVbTdVEXbTVW03VRF201VtN1URdtNVbTdVEXbTVW03VRF201VtN1URdtNVbTdVEXbTVW03VRF201VtN1URdtNVbTdVEXbTVW03VRF201VtN1URdtNVbTdVEXbTVW03VRF201VtN1URdtNVbTdVEXbTVW03VRF201VtN1URdtNVbTdVEXbTVW03VRF201VtN1URdtNVbTdVEXbTVW03VRF201VtN1URdtNVbTdVEXbTVW03VRF201VtN1URdtNVbTdVEXbTVW03VRF201VtN1URdtNVbTdVEXbTVW03VRF201VtN1URdtNVbTdVEXbTVW0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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"7d3RbiS3mYbhe5ljY1Fk/VXFyq0sFgsncRYGDDuInQUWRu595UTVGscUWia/+ZoS37M46Z5hPylV/y/bav786c/f/PHv//Pf337/lx9+/PSH//z503c//Onrn7794funf/r50/Ifufzzv/3xr19//8t/8eNPX//tp09/2Jbjq0/ffP/np/9Uln989ekv3373zac/rCX947+++uVJZ8OT1lx7UlmX5yeVdas8aW15UrQ8aWt50t7ypKPlSaXlSWfDk2JpeVJqeVLLFREtV0S0XBHRckVEyxURLVdEtFwR0XJFbC1XxNZyRWwtV8TWckVsLVfE1nJFbC1XxNZyRWwtV8TWckXsLVfE3nJF7C1XxN5yRewtV8TeckXsLVfE3nJF7C1XxN5yRRwtV8TRckUcLVfE0XJFHC1XxNFyRRwtV8TRckUcLVfE0XJFlJYrorRcEaXliigtV0RpuSJKyxVRWq6I0nJFlJYrorRcEWfLFXG2XBFnyxVxtlwRZ8sVcbZcEWfLFXG2XBFnyxVxtlwRaVmanpWanpWbnrU2PSuanrU1PWtvetbR9KzS9KymayM1XRup6dpITddGaro2UtO1kZqujdR0baSmayM1XRup6drITddGbro2ctO1kZuujdx0beSmayM3XRu56drITddGbro21qZrY226Npo2NVPTrmZq2tZMTfuaqWljMzXtbKamrc3UtLeZmjY3U9PuZmra3kxN+5upaYMzNe1wpqYtztS0x5maNjlT0y5natrmTE37nKlpozM17XSmpq3O1LTXmZo2O1M94PfletZxrL961le/eWysqTw/ONb95dOnp8Gu8ugzznh+9LltL392juVa0TrcimK4FW3DrWgfbkXHcCsqw63oHG1F9Y2qh64oDbei4e7Z53D37HO4e/Y53D37HO6efQ53zz6Hu2efo92z8zLaPTsvo92z8zLaPTsvo92z8zLaPTsvo92z8zLaPTsvo92z8zLaPTsvw92zk/mnf9vO5wdvR3pZz7Fd64nB1mO+qreSr/WUUltPGWw951jryctg60mDrScPtp51sPX033/y+dl60p31PH3M8/zgp03iz/7kfK1nG2w9+2DrOQZbTxlsPedY61mXwdaTzOvZrwc/bZXX1pMHW8862HpisPVsg61nH2w9x2DrMd+fn5Lv+cFPb1W19ZxjrSeWwdaTBltPHmw9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"}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000aad5fd6b"},{"kind":"string","value":"PublicKeyNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"signing_public_key","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"signing_pub_key_x","type":{"kind":"field"}},{"name":"signing_pub_key_y","type":{"kind":"field"}}],"kind":"struct","path":"SchnorrAccount::constructor_parameters"}}],"kind":"struct","path":"SchnorrAccount::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"inner_hash","type":{"kind":"field"}}],"kind":"struct","path":"SchnorrAccount::verify_private_authwit_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"SchnorrAccount::verify_private_authwit_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"}},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"}}],"kind":"struct","path":"SchnorrAccount::entrypoint_parameters"}}],"kind":"struct","path":"SchnorrAccount::entrypoint_abi"}]}},"file_map":{"102":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::{Point, pub_key_to_bytes},\n    constants::{GENERATOR_INDEX__IVSK_M, GENERATOR_INDEX__OVSK_M}, hash::poseidon2_hash\n};\n\nuse std::field::bytes32_to_field;\n\nuse crate::oracle::unsafe_rand::unsafe_rand;\n\nuse crate::event::event_interface::EventInterface;\nuse crate::note::note_interface::NoteInterface;\n\nuse crate::encrypted_logs::{\n    header::EncryptedLogHeader, incoming_body::EncryptedLogIncomingBody,\n    outgoing_body::EncryptedLogOutgoingBody\n};\n\npub fn compute_encrypted_event_log<Event, NB, MB, OB>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    event: Event\n) -> [u8; OB] where Event: EventInterface<NB, MB> {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    let eph_sk: Scalar = fr_to_fq(unsafe_rand());\n    let eph_pk = eph_sk.derive_public_key();\n\n    // TODO: (#7177) This value needs to be populated!\n    let recipient = AztecAddress::from_field(0);\n\n    let ivpk_app = compute_ivpk_app(ivpk, contract_address);\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_Header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_event(event, randomness).compute_ciphertext(eph_sk, ivpk_app);\n    let outgoing_body_ciphertext: [u8; 176] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk_app).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; OB] = [0; OB];\n    // @todo We ignore the tags for now \n\n    let eph_pk_bytes = pub_key_to_bytes(eph_pk);\n    for i in 0..64 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[128 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[176 + i] = outgoing_Header_ciphertext[i];\n    }\n    for i in 0..176 {\n        encrypted_bytes[224 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = OB - 400;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[400 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (64 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (176 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\npub fn compute_encrypted_note_log<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> [u8; M] where Note: NoteInterface<N, NB> {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    let eph_sk: Scalar = fr_to_fq(unsafe_rand());\n    let eph_pk = eph_sk.derive_public_key();\n\n    // TODO: (#7177) This value needs to be populated!\n    let recipient = AztecAddress::from_field(0);\n\n    let ivpk_app = compute_ivpk_app(ivpk, contract_address);\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_Header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_note(note, storage_slot).compute_ciphertext(eph_sk, ivpk_app);\n    let outgoing_body_ciphertext: [u8; 176] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk_app).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now \n\n    let eph_pk_bytes = pub_key_to_bytes(eph_pk);\n    for i in 0..64 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[128 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[176 + i] = outgoing_Header_ciphertext[i];\n    }\n    for i in 0..176 {\n        encrypted_bytes[224 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 400;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[400 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (64 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (176 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field elememt to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let r_bytes = r.to_be_bytes(32);\n\n    let mut high_bytes = [0; 32];\n    let mut low_bytes = [0; 32];\n\n    for i in 0..16 {\n        high_bytes[16 + i] = r_bytes[i];\n        low_bytes[16 + i] = r_bytes[i + 16];\n    }\n\n    let low = bytes32_to_field(low_bytes);\n    let high = bytes32_to_field(high_bytes);\n\n    Scalar::new(low, high)\n}\n\nfn compute_ivpk_app(ivpk: Point, contract_address: AztecAddress) -> Point {\n    // It is useless to compute this, it brings no value to derive fully.\n    // Issue(#6955)\n    ivpk\n    /*\n    // @todo Just setting infinite to false, but it should be checked.\n    // for example user could define ivpk = infinity using the registry\n    assert((ivpk.x != 0) & (ivpk.y != 0), \"ivpk is infinite\");\n\n    let i = fr_to_fq(poseidon2_hash([contract_address.to_field(), ivpk.x, ivpk.y, GENERATOR_INDEX__IVSK_M]));\n    let I = i.derive_public_key();\n\n    let embed_I = Point { x: I.x, y: I.y, is_infinite: false };\n    let embed_ivpk = Point { x: ivpk.x, y: ivpk.y, is_infinite: false };\n\n    let embed_result = embedded_curve_add(embed_I, embed_ivpk);\n\n    Point::new(embed_result.x, embed_result.y)*/\n}\n"},"103":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    encrypted_logs::payload::compute_encrypted_note_log, oracle::logs_traits::LensForEncryptedLog\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field, address::AztecAddress, point::Point, abis::note_hash::NoteHash,\n    constants::MAX_NOTE_HASHES_PER_CALL, utils::arrays::find_index\n};\n\nunconstrained fn compute_unconstrained<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    compute(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note)\n}\n\nfn compute<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let encrypted_log: [u8; M] = compute_encrypted_note_log(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note);\n    let log_hash = sha256_to_field(encrypted_log);\n    (encrypted_log, log_hash)\n}\n\nfn emit_with_keys<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    note: Note,\n    ovpk: Point,\n    ivpk: Point,\n    inner_compute: fn(AztecAddress, Field, Field, Point, Point, Note) -> ([u8; M], Field)\n) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    let note_exists_index = find_index(\n        context.note_hashes.storage,\n        |n: NoteHash| n.counter == note_hash_counter\n    );\n    assert(\n        note_exists_index as u32 != MAX_NOTE_HASHES_PER_CALL, \"Can only emit a note log for an existing note.\"\n    );\n\n    let contract_address: AztecAddress = context.this_address();\n    let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n    let (encrypted_log, log_hash) = inner_compute(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n\npub fn encode_and_encrypt_note<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let header = context.get_header();\n        let ovpk = header.get_ovpk_m(context, ov);\n        let ivpk = header.get_ivpk_m(context, iv);\n        emit_with_keys(context, e.note, ovpk, ivpk, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let header = context.get_header();\n        let ovpk = header.get_ovpk_m(context, ov);\n        let ivpk = header.get_ivpk_m(context, iv);\n        emit_with_keys(context, e.note, ovpk, ivpk, compute_unconstrained);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ovpk: Point,\n    ivpk: Point\n) -> fn[(&mut PrivateContext, Point, Point)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys_unconstrained<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ovpk: Point,\n    ivpk: Point\n) -> fn[(&mut PrivateContext, Point, Point)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, compute_unconstrained);\n    }\n}\n"},"104":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/outgoing_body.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash\n};\n\nuse std::aes128::aes128_encrypt;\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nstruct EncryptedLogOutgoingBody {\n    eph_sk: Scalar,\n    recipient: AztecAddress,\n    recipient_ivpk_app: Point,\n}\n\nimpl EncryptedLogOutgoingBody {\n    pub fn new(eph_sk: Scalar, recipient: AztecAddress, recipient_ivpk_app: Point) -> Self {\n        Self { eph_sk, recipient, recipient_ivpk_app }\n    }\n\n    pub fn compute_ciphertext(self, ovsk_app: Scalar, eph_pk: Point) -> [u8; 176] {\n        // Again, we could compute `eph_pk` here, but we keep the interface more similar\n        // and also make it easier to optimise it later as we just pass it along\n\n        let mut buffer: [u8; 160] = [0; 160];\n\n        let serialized_eph_sk_high = self.eph_sk.hi.to_be_bytes(32);\n        let serialized_eph_sk_low = self.eph_sk.lo.to_be_bytes(32);\n\n        let address_bytes = self.recipient.to_field().to_be_bytes(32);\n        let serialized_recipient_ivpk_app = self.recipient_ivpk_app.serialize();\n        let serialized_recipient_ivpk_app_x = serialized_recipient_ivpk_app[0].to_be_bytes(32);\n        let serialized_recipient_ivpk_app_y = serialized_recipient_ivpk_app[1].to_be_bytes(32);\n\n        for i in 0..32 {\n            buffer[i] = serialized_eph_sk_high[i];\n            buffer[i + 32] = serialized_eph_sk_low[i];\n            buffer[i + 64] = address_bytes[i];\n            buffer[i + 96] = serialized_recipient_ivpk_app_x[i];\n            buffer[i + 128] = serialized_recipient_ivpk_app_y[i];\n        }\n\n        // We compute the symmetric key using poseidon.\n        let full_key: [u8; 32] = poseidon2_hash(\n            [\n            ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y,\n            GENERATOR_INDEX__SYMMETRIC_KEY as Field\n        ]\n        ).to_be_bytes(32).as_array();\n\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(buffer, iv, sym_key).as_array()\n    }\n}\n\nmod test {\n    use crate::encrypted_logs::outgoing_body::EncryptedLogOutgoingBody;\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, hash::poseidon2_hash\n    };\n\n    use crate::context::PrivateContext;\n\n    #[test]\n    fn test_encrypted_log_outgoing_body() {\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        );\n        let recipient_ivsk_app = Scalar::new(\n            0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        );\n        let sender_ovsk_app = Scalar::new(\n            0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        );\n\n        let eph_pk = eph_sk.derive_public_key();\n        let recipient_ivpk_app = recipient_ivsk_app.derive_public_key();\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let body = EncryptedLogOutgoingBody::new(eph_sk, recipient, recipient_ivpk_app);\n\n        let ciphertext = body.compute_ciphertext(sender_ovsk_app, eph_pk);\n\n        let expected_outgoing_body_ciphertext = [\n            127, 84, 96, 176, 101, 107, 236, 57, 68, 8, 53, 202, 138, 74, 186, 54, 74, 193, 245, 7, 109, 59, 218, 33, 1, 31, 205, 225, 241, 209, 64, 222, 94, 245, 4, 150, 47, 241, 187, 64, 152, 20, 102, 158, 200, 217, 213, 82, 1, 240, 170, 185, 51, 80, 27, 109, 63, 231, 235, 120, 174, 44, 133, 248, 10, 97, 60, 40, 222, 190, 147, 76, 187, 48, 91, 206, 48, 106, 56, 118, 38, 127, 82, 4, 182, 188, 44, 224, 31, 129, 47, 107, 134, 252, 20, 25, 122, 191, 158, 69, 35, 255, 215, 171, 196, 45, 91, 184, 83, 80, 238, 201, 1, 233, 235, 159, 171, 130, 158, 64, 176, 165, 132, 30, 84, 81, 71, 195, 145, 47, 82, 247, 210, 192, 23, 4, 220, 90, 56, 109, 46, 105, 79, 251, 165, 141, 185, 233, 191, 118, 219, 153, 191, 162, 99, 238, 241, 249, 9, 74, 210, 241, 54, 28, 126, 226, 85, 235, 174, 75, 239, 207, 100, 184, 248, 194\n        ];\n\n        for i in 0..expected_outgoing_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_outgoing_body_ciphertext[i]);\n        }\n        assert_eq(expected_outgoing_body_ciphertext.len(), ciphertext.len());\n    }\n}\n"},"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\nstruct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext(self, secret: Scalar, point: Point) -> [u8; 48] {\n        let full_key = point_to_symmetric_key(secret, point);\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes(32).as_array();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nfn test_encrypted_log_header() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar::new(\n        0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    );\n    let point = Point::new(\n        0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        false\n    );\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    let expected_header_ciphertext = [\n        228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 23, 131, 32, 226, 26, 176, 43, 39, 239, 177, 177, 192, 85, 216, 17, 15, 18, 187, 35, 225, 135, 192, 63, 88, 29, 173, 232, 46, 72, 82, 187, 139\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext);\n}\n"},"106":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/incoming_body.nr","source":"use crate::note::note_interface::NoteInterface;\nuse crate::event::event_interface::EventInterface;\nuse dep::protocol_types::{scalar::Scalar, point::Point};\n\nuse std::aes128::aes128_encrypt;\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nstruct EncryptedLogIncomingBody<M> {\n    plaintext: [u8; M]\n}\n\nimpl<M> EncryptedLogIncomingBody<M> {\n    pub fn from_note<T, N>(note: T, storage_slot: Field) -> Self where T: NoteInterface<N, M> {\n        let mut plaintext = note.to_be_bytes(storage_slot);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn from_event<T, MR>(event: T, randomness: Field) -> Self where T: EventInterface<M, MR> {\n        let mut plaintext = event.private_to_be_bytes(randomness);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn compute_ciphertext(self, eph_sk: Scalar, ivpk_app: Point) -> [u8] {\n        let full_key = point_to_symmetric_key(eph_sk, ivpk_app);\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(self.plaintext, iv, sym_key)\n    }\n}\n\nmod test {\n    use crate::encrypted_logs::incoming_body::EncryptedLogIncomingBody;\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, traits::Serialize, abis::event_selector::EventSelector\n    };\n\n    use crate::{\n        note::{note_header::NoteHeader, note_interface::NoteInterface},\n        event::event_interface::EventInterface, oracle::unsafe_rand::unsafe_rand,\n        context::PrivateContext\n    };\n\n    struct AddressNote {\n        address: AztecAddress,\n        owner: AztecAddress,\n        randomness: Field,\n        header: NoteHeader,\n    }\n\n    global ADDRESS_NOTE_LEN: Field = 3;\n    global ADDRESS_NOTE_BYTES_LEN = 32 * 3 + 64;\n\n    impl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n        fn compute_note_content_hash(self) -> Field {1}\n\n        fn get_note_type_id() -> Field {\n            1\n        }\n\n        fn get_header(self) -> NoteHeader { self.header}\n\n        fn set_header(&mut self, header: NoteHeader) {self.header = header; }\n\n        fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n            (1, 1)\n        }\n\n        fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {(1,1)}\n\n        fn serialize_content(self) -> [Field; ADDRESS_NOTE_LEN] { [self.address.to_field(), self.owner.to_field(), self.randomness]}\n\n        fn deserialize_content(fields: [Field; ADDRESS_NOTE_LEN]) -> Self {\n            AddressNote { address: AztecAddress::from_field(fields[0]), owner: AztecAddress::from_field(fields[1]), randomness: fields[2], header: NoteHeader::empty() }\n        }\n\n        fn to_be_bytes(self, storage_slot: Field) -> [u8; ADDRESS_NOTE_BYTES_LEN] {\n            let serialized_note = self.serialize_content();\n\n            let mut buffer: [u8; ADDRESS_NOTE_BYTES_LEN] = [0; ADDRESS_NOTE_BYTES_LEN];\n\n            let storage_slot_bytes = storage_slot.to_be_bytes(32);\n            let note_type_id_bytes = AddressNote::get_note_type_id().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = storage_slot_bytes[i];\n                buffer[32 + i] = note_type_id_bytes[i];\n            }\n\n            for i in 0..serialized_note.len() {\n                let bytes = serialized_note[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n            buffer\n        }\n    }\n\n    impl AddressNote {\n        pub fn new(address: AztecAddress, owner: AztecAddress, randomness: Field) -> Self {\n            AddressNote { address, owner, randomness, header: NoteHeader::empty() }\n        }\n    }\n\n    #[test]\n    fn test_encrypted_note_log_incoming_body() {\n        let note = AddressNote::new(\n            AztecAddress::from_field(0x1),\n            AztecAddress::from_field(0x2),\n            3\n        );\n\n        let storage_slot = 2;\n\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        );\n        let ivpk_app = Point::new(\n            0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            false\n        );\n\n        let body = EncryptedLogIncomingBody::from_note(note, storage_slot);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk_app);\n\n        let expected_note_body_ciphertext = [\n            228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 63, 127, 188, 251, 150, 188, 238, 205, 3, 86, 102, 164, 175, 12, 137, 158, 163, 111, 205, 10, 229, 230, 46, 202, 110, 107, 156, 180, 67, 192, 161, 201, 48, 153, 169, 1, 25, 182, 93, 39, 39, 207, 251, 218, 234, 147, 156, 13, 110, 180, 190, 199, 41, 6, 211, 203, 176, 110, 165, 186, 110, 127, 199, 22, 201, 149, 92, 249, 219, 68, 145, 68, 179, 29, 233, 34, 98, 123, 197, 234, 169, 53, 44, 14, 81, 60, 92, 27, 250, 134, 49, 248, 57, 119, 236, 118, 158, 104, 82, 243, 98, 164, 60, 72, 74, 27, 177, 194, 221, 225, 193, 150, 67, 235, 205, 106, 150, 24, 126, 186, 220, 178, 199, 189, 113, 54, 181, 55, 46, 15, 236, 236, 9, 159, 5, 172, 237, 154, 110, 50, 241, 64, 92, 13, 37, 53, 20, 140, 42, 146, 229, 63, 97, 25, 159, 63, 235, 104, 68, 100\n        ];\n\n        assert_eq(expected_note_body_ciphertext.len(), ciphertext.len());\n\n        for i in 0..expected_note_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_note_body_ciphertext[i]);\n        }\n    }\n\n    struct TestEvent {\n        value0: Field,\n        value1: Field,\n        value2: Field,\n    }\n\n    impl Serialize<3> for TestEvent {\n        fn serialize(self) -> [Field; 3] {\n            [self.value0, self.value1, self.value2]\n        }\n    }\n\n    global TEST_EVENT_LEN: Field = 3;\n    global TEST_EVENT_BYTES_LEN = 32 * 3 + 64;\n    global TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS = 32 * 3 + 32;\n\n    impl EventInterface<TEST_EVENT_BYTES_LEN, TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS> for TestEvent {\n        fn get_event_type_id() -> EventSelector {\n            EventSelector::from_signature(\"TestEvent(Field,Field,Field)\")\n        }\n\n        fn private_to_be_bytes(self, randomness: Field) -> [u8; TEST_EVENT_BYTES_LEN] {\n            let mut buffer: [u8; TEST_EVENT_BYTES_LEN] = [0; TEST_EVENT_BYTES_LEN];\n\n            let randomness_bytes = randomness.to_be_bytes(32);\n            let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = randomness_bytes[i];\n                buffer[32 + i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes = serialized_event[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn to_be_bytes(self) -> [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] {\n             let mut buffer: [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] = [0; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS];\n\n             let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n             for i in 0..32 {\n                 buffer[i] = event_type_id_bytes[i];\n            }\n\n             let serialized_event = self.serialize();\n\n             for i in 0..serialized_event.len() {\n                 let bytes = serialized_event[i].to_be_bytes(32);\n                 for j in 0..32 {\n                     buffer[32 + i * 32 + j] = bytes[j];\n                }\n            }\n\n             buffer\n        }\n\n        fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n            _emit(self);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_event_incoming_body() {\n        let test_event = TestEvent { value0: 1, value1: 2, value2: 3 };\n\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        );\n\n        let ivpk_app = Point::new(\n            0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            false\n        );\n\n        let randomness = 2;\n\n        let body = EncryptedLogIncomingBody::from_event(test_event, randomness);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk_app);\n\n        let expected_event_body_ciphertext = [\n            228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 63, 127, 188, 251, 150, 188, 238, 205, 3, 86, 102, 164, 175, 12, 137, 158, 163, 111, 205, 10, 229, 230, 46, 202, 110, 107, 156, 180, 67, 192, 161, 201, 66, 122, 29, 35, 42, 33, 153, 216, 199, 208, 103, 207, 126, 153, 189, 136, 19, 220, 238, 15, 169, 29, 255, 11, 123, 107, 70, 192, 53, 40, 36, 93, 187, 32, 123, 136, 104, 23, 229, 245, 152, 90, 84, 2, 136, 112, 42, 27, 82, 214, 104, 14, 250, 48, 199, 245, 88, 22, 200, 77, 38, 51, 127, 56, 138, 255, 16, 46, 179, 129, 215, 185, 185, 116, 148, 16, 133, 62, 56, 180, 10, 132, 109, 77, 206, 199, 21, 167, 7, 163, 171, 158, 244, 23, 18, 121, 108, 42, 107, 7, 48, 84, 212, 104, 39, 16, 109, 7, 108, 129, 60, 80, 112, 241, 223, 140, 186, 158, 38, 74, 230, 213, 159, 175, 142, 228, 128, 160\n        ];\n\n        assert_eq(expected_event_body_ciphertext.len(), ciphertext.len());\n\n        for i in 0..expected_event_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_event_body_ciphertext[i]);\n        }\n    }\n}\n"},"110":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr","source":"use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus, PropertySelector},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\n\nmod test;\n\nfn extract_property_value_from_selector<N>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note. \n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value = serialized_note[selector.index].to_be_bytes(32);\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, N, M>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<N>(serialized_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let is_equal = value_field == select.value.to_field();\n        let is_lt = value_field.lt(select.value.to_field());\n\n        if (select.comparator == Comparator.EQ) {\n            assert(is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(is_lt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(is_lt | is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!is_lt & !is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!is_lt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N, M> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    context.push_note_hash_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, M, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> where Note: NoteInterface<N, M> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nfn constrain_get_notes_internal<Note, N, M, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> where Note: NoteInterface<N, M> {\n    let mut returned_notes = BoundedVec::new();\n\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        let opt_note = filtered_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n\n            // The below code is used to collapse a sparse array into one where the values are guaranteed to be at the \n            // front of the array. This is highly useful because the caller knows that the returned array won't have\n            // more than option.limits notes, and can therefore loop over this limit value instead of the entire array,\n            // resulting in a smaller circuit and faster proving times.\n            // We write at returned_notes[num_notes] because num_notes is only advanced when we have a value in \n            // filtered_notes.\n            returned_notes.push(note);\n        };\n    }\n\n    // As long as we only loop till `options.limit` the array will be guaranteed to be at most of length `options.limit`.\n    assert(returned_notes.len() <= options.limit, \"Got more notes than limit.\");\n    // We will however check that nothing else was returned after the limit.\n    for i in options.limit..filtered_notes.len() {\n        assert(filtered_notes[i].is_none(), \"Got more notes than limit.\");\n    }\n\n    assert(returned_notes.len() != 0, \"Cannot return zero notes\");\n\n    returned_notes\n}\n\nunconstrained fn get_note_internal<Note, N, M>(storage_slot: Field) -> Note where Note: NoteInterface<N, M> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, M, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N, M> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained pub fn view_notes<Note, N, M>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N, M>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N, M> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n"},"112":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__INNER_NOTE_HASH,\n    hash::{\n    pedersen_hash, compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_inner_note_hash_from_preimage(storage_slot: Field, note_content_hash: Field) -> Field {\n    pedersen_hash(\n        [storage_slot, note_content_hash],\n        GENERATOR_INDEX__INNER_NOTE_HASH\n    )\n}\n\nfn compute_inner_note_hash<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    compute_inner_note_hash_from_preimage(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N, M>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let (_, inner_nullifier) = note_with_header.compute_note_hash_and_nullifier(context);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\nfn compute_note_hash_for_read_request_from_innter_and_nonce(\n    inner_note_hash: Field,\n    nonce: Field\n) -> Field {\n    // TODO(#1386): This if-else can be nuked once we have nonces injected from public\n    if (nonce == 0) {\n        // If nonce is zero, that means we are reading a public note.\n        inner_note_hash\n    } else {\n        compute_unique_note_hash(nonce, inner_note_hash)\n    }\n}\n\npub fn compute_note_hash_for_read_request<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let inner_note_hash = compute_inner_note_hash(note);\n    let nonce = note.get_header().nonce;\n\n    compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, nonce)\n}\n\npub fn compute_note_hash_for_consumption<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    if (header.note_hash_counter != 0) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        inner_note_hash\n    } else {\n        // If a note is not transient, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the siloed_note_hash which has already been hashed with\n        // nonce and then contract address. This hash will match the existing leaf in the note hash\n        // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, header.nonce);\n        compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, N, M, S>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n    let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, note_header.nonce);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        let (_, nullifier) = note.compute_note_hash_and_nullifier_without_context();\n        nullifier\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [inner_note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"113":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_inner_note_hash, compute_note_hash_for_consumption}, note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let inner_note_hash = compute_inner_note_hash(*note);\n\n    let serialized_note = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash,\n        note_hash_counter\n    )\n        == 0\n    );\n\n    context.push_note_hash(inner_note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, N, M>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let inner_note_hash = compute_inner_note_hash(*note);\n\n    context.push_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let (note_hash, nullifier) = note.compute_note_hash_and_nullifier(context);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let note_hash_for_consumption = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a non-transient note and we don't populate the note_hash with real\n        // value (if we did so the `notifyNullifiedNote` oracle would throw).\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a transient note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can find it and squash both\n        // the note and the nullifier.\n        note_hash\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    assert(notify_nullified_note(nullifier, note_hash_for_consumption, nullifier_counter) == 0);\n\n    context.push_nullifier(nullifier, note_hash_for_consumption)\n}\n"},"114":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\nstruct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting  \n * a change note in a token's transfer function only when there is \"change\" left).\n */\nstruct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(self) {}\n}\n"},"116":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_viewer_options.nr","source":"use std::option::Option;\nuse crate::note::note_getter_options::{PropertySelector, Select, Sort, Comparator, NoteStatus};\nuse dep::protocol_types::traits::ToField;\nuse crate::note::note_interface::NoteInterface;\nuse crate::note::constants::MAX_NOTES_PER_PAGE;\n\n// docs:start:NoteViewerOptions\nstruct NoteViewerOptions<Note, N, M> {\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n    limit: u32,\n    offset: u32,\n    status: u8,\n}\n// docs:end:NoteViewerOptions\n\nimpl<Note, N, M> NoteViewerOptions<Note, N, M> {\n    pub fn new() -> NoteViewerOptions<Note, N, M> where Note: NoteInterface<N, M> {\n        NoteViewerOptions {\n            selects: BoundedVec::new(),\n            sorts: BoundedVec::new(),\n            limit: MAX_NOTES_PER_PAGE as u32,\n            offset: 0,\n            status: NoteStatus.ACTIVE\n        }\n    }\n\n    // This method adds a `Select` criterion to the options.\n    // It takes a field_index indicating which field to select,\n    // a value representing the specific value to match in that field, and\n    // a comparator (For possible values of comparators, please see the Comparator enum from note_getter_options)\n    pub fn select<T>(\n        &mut self,\n        property_selector: PropertySelector,\n        value: T,\n        comparator: Option<u8>\n    ) -> Self where T: ToField {\n        self.selects.push(\n            Option::some(\n                Select::new(\n                    property_selector,\n                    value.to_field(),\n                    comparator.unwrap_or(Comparator.EQ)\n                )\n            )\n        );\n        *self\n    }\n\n    pub fn sort(&mut self, property_selector: PropertySelector, order: u8) -> Self {\n        self.sorts.push(Option::some(Sort::new(property_selector, order)));\n        *self\n    }\n\n    pub fn set_limit(&mut self, limit: u32) -> Self {\n        assert(limit <= MAX_NOTES_PER_PAGE as u32);\n        // By requesting that the limit is a constant, we guarantee that it will be possible to loop over it, reducing\n        // gate counts when a limit has been set. This isn't required in unconstrained code, but we still keep this\n        // requirement here for API consistency.\n        assert_constant(limit);\n        self.limit = limit;\n        *self\n    }\n\n    pub fn set_offset(&mut self, offset: u32) -> Self {\n        self.offset = offset;\n        *self\n    }\n\n    // This method sets the status value, which determines whether to retrieve active or nullified notes.\n    pub fn set_status(&mut self, status: u8) -> Self {\n        self.status = status;\n        *self\n    }\n}\n"},"117":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_header.nr","source":"use dep::protocol_types::address::AztecAddress;\nuse dep::protocol_types::traits::{Empty, Eq, Serialize};\n\nstruct NoteHeader {\n    contract_address: AztecAddress,\n    nonce: Field,\n    storage_slot: Field,\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386)\n    // Check the nonce to see whether a note is transient or not.\n    note_hash_counter: u32, // a note_hash_counter of 0 means non-transient\n}\n\nimpl Empty for NoteHeader {\n    fn empty() -> Self {\n        NoteHeader { contract_address: AztecAddress::zero(), nonce: 0, storage_slot: 0, note_hash_counter: 0 }\n    }\n}\n\nimpl Eq for NoteHeader {\n    fn eq(self, other: Self) -> bool {\n        (self.contract_address == other.contract_address) & \n        (self.nonce == other.nonce) & \n        (self.storage_slot == other.storage_slot)& \n        (self.note_hash_counter == other.note_hash_counter)\n    }\n}\n\nimpl NoteHeader {\n    pub fn new(contract_address: AztecAddress, nonce: Field, storage_slot: Field) -> Self {\n        NoteHeader { contract_address, nonce, storage_slot, note_hash_counter: 0 }\n    }\n}\n\nimpl Serialize<4> for NoteHeader {\n    fn serialize(self) -> [Field; 4] {\n        [self.contract_address.to_field(), self.nonce, self.storage_slot, self.note_hash_counter as Field]\n    }\n}\n"},"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"122":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::{compute_siloed_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_contract_initialization_nullifier(context.this_address());\n    let header = context.get_header();\n    header.prove_nullifier_inclusion(init_nullifier);\n}\n\nfn compute_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    compute_siloed_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(address)\n    )\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"123":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr","source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"},"124":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::{address::AztecAddress, point::Point};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<M>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<M>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<M>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32\n) {}\n\nunconstrained pub fn emit_encrypted_event_log<M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<N, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<N, M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\n}\n"},"127":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle<N>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<N>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<N>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n"},"128":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n"},"132":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<N>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field\n) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number as Field, N)\n}\n\nunconstrained pub fn storage_read<T, N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"133":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/unsafe_rand.nr","source":"#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n\n// Called `unsafe_rand` because we do not constrain in circuit that we are dealing with an actual random value.\n// Instead we just trust our PXE.\nunconstrained pub fn unsafe_rand() -> Field {\n    rand_oracle()\n}\n"},"135":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n"},"136":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use crate::keys::PublicKeys;\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained fn get_public_keys_and_partial_address_oracle_wrapper(address: AztecAddress) -> [Field; 13] {\n    get_public_keys_and_partial_address_oracle(address)\n}\n\nfn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle_wrapper(address);\n\n    let keys = PublicKeys {\n        npk_m: Point::new(result[0], result[1], result[2] as bool),\n        ivpk_m: Point::new(result[3], result[4], result[5] as bool),\n        ovpk_m: Point::new(result[6], result[7], result[8] as bool),\n        tpk_m: Point::new(result[9], result[10], result[11] as bool)\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"138":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        inner_note_hash,\n        counter\n    )\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field, _counter: u32) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(\n    nullifier: Field,\n    inner_note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash, counter)\n}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, NB, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N, NB> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n// Only ever use this in private!\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n// Only ever use this in private!\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n"},"139":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"140":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{\n    abis::{\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\n    utils::reader::Reader,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n}\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\n    let mut reader = Reader::new(fields);\n\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n    // WARNING: if updating, see comment in public_call_stack_item.ts's PublicCallStackItem.hash()\n    let item = PublicCallStackItem {\n        contract_address: AztecAddress::from_field(reader.read()),\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\n        public_inputs: PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            args_hash: reader.read(),\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            end_side_effect_counter: 0,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0\n        },\n        is_execution_request: true\n    };\n    reader.finish();\n\n    item\n}\n"},"155":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_delay_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initally equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation \n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the \n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a \n// reduced delay, invalidating prior private reads.\nstruct ScheduledDelayChange<INITIAL_DELAY> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option, \n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pre: Option<u32>,\n    post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numeric value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\nimpl<INITIAL_DELAY> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior contraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This \n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is \n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in \n            //                             which to scheduled value change\n\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY)\n            )\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Serialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn serialize(self) -> [Field; 1] {\n        // We pack all three u32 values into a single U128, which is made up of two u64 limbs.\n        // Low limb: [ pre_inner: u32 | post_inner: u32 ]\n        // High limb: [ empty | pre_is_some: u8 |  post_is_some: u8 | block_of_change: u32 ]\n\n        let lo = ((self.pre.unwrap_unchecked() as u64) * (1 << 32))\n            + (self.post.unwrap_unchecked() as u64);\n\n        let hi = (self.pre.is_some() as u64) * (1 << 33) \n            + (self.post.is_some() as u64 * (1 << 32)) \n            + self.block_of_change as u64;\n\n        let packed = U128::from_u64s_le(lo, hi);\n\n        [packed.to_integer()]\n    }\n}\n\nimpl<INITIAL_DELAY> Deserialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn deserialize(input: [Field; 1]) -> Self {\n        let packed = U128::from_integer(input[0]);\n\n        // We use division and modulo to clear the bits that correspond to other values when unpacking.\n\n        let pre_is_some = ((packed.hi as u64) / (1 << 33)) as bool;\n        let pre_inner = ((packed.lo as u64) / (1 << 32)) as u32;\n\n        let post_is_some = (((packed.hi as u64) / (1 << 32)) % (1 << 1)) as bool;\n        let post_inner = ((packed.lo as u64) % (1 << 32)) as u32;\n\n        let block_of_change = ((packed.hi as u64) % (1 << 32)) as u32;\n\n        Self {\n            pre: if pre_is_some { Option::some(pre_inner) } else { Option::none() },\n            post: if post_is_some { Option::some(post_inner) } else { Option::none() },\n            block_of_change,\n            _dummy: [0; INITIAL_DELAY],\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"157":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable_private_getter.nr","source":"use dep::protocol_types::{\n    hash::{pedersen_hash, poseidon2_hash}, traits::{FromField, ToField}, address::AztecAddress,\n    header::Header\n};\n\nuse crate::context::PrivateContext;\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{\n    shared_mutable::SharedMutable, scheduled_delay_change::ScheduledDelayChange,\n    scheduled_value_change::ScheduledValueChange\n}\n};\n\nstruct SharedMutablePrivateGetter<T, INITIAL_DELAY> {\n    context: &mut PrivateContext,\n    // The contract address of the contract we want to read from\n    other_contract_address: AztecAddress,\n    // The storage slot where the SharedMutable is stored on the other contract\n    storage_slot: Field,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numberic value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\n// We have this as a view-only interface to reading Shared Mutables in other contracts.\n// Currently the Shared Mutable does not support this. We can adapt SharedMutable at a later date\nimpl<T, INITIAL_DELAY> SharedMutablePrivateGetter<T, INITIAL_DELAY> {\n    pub fn new(\n        context: &mut PrivateContext,\n        other_contract_address: AztecAddress,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        assert(other_contract_address.to_field() != 0, \"Other contract address cannot be 0\");\n        Self { context, other_contract_address, storage_slot, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    pub fn get_value_in_private(self, header: Header) -> T where T: FromField + ToField + Eq {\n        // We create a dummy SharedMutable state variable so that we can reuse its historical_read_from_public_storage\n        // method, greatly reducing code duplication. \n        let dummy: SharedMutable<T, INITIAL_DELAY, ()> = SharedMutable::new((), self.storage_slot);\n        let (value_change, delay_change, historical_block_number) = dummy.historical_read_from_public_storage(header, self.other_contract_address);\n\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // If our context has the same header as the one we pass in via the parameter, we are trying to read the \"current\" value\n        // and thus need to set the tx max block number below. If the context header is not the same as the one we pass in, this means\n        // we are trying to read a historical value and thus have no constraint on the max block number that this transaction can be included in.\n        if (self.context.historical_header.global_variables.block_number.eq(header.global_variables.block_number)) {\n            self.context.set_tx_max_block_number(block_horizon);\n        }\n\n        value_change.get_current_at(historical_block_number)\n    }\n}\n"},"159":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_value_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\nstruct ScheduledValueChange<T> {\n    pre: T,\n    post: T,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Serialize<3> for ScheduledValueChange<T> {\n    fn serialize(self) -> [Field; 3] where T: ToField {\n        [self.pre.to_field(), self.post.to_field(), self.block_of_change.to_field()]\n    }\n}\n\nimpl<T> Deserialize<3> for ScheduledValueChange<T> {\n  fn deserialize(input: [Field; 3]) -> Self  where T: FromField {\n    Self {\n        pre: FromField::from_field(input[0]),\n        post: FromField::from_field(input[1]),\n        block_of_change: FromField::from_field(input[2]),\n    }\n  }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>  {\n    fn eq(self, other: Self) -> bool where T: Eq {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"160":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable.nr","source":"use dep::protocol_types::{\n    hash::{pedersen_hash, poseidon2_hash}, header::Header, address::AztecAddress,\n    traits::{FromField, ToField}\n};\n\nuse crate::context::{PrivateContext, PublicContext};\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{scheduled_value_change::ScheduledValueChange, scheduled_delay_change::ScheduledDelayChange}\n};\nuse crate::oracle::storage::storage_read;\nuse dep::std::unsafe::zeroed;\n\nmod test;\n\nstruct SharedMutable<T, INITIAL_DELAY, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Serialize<N> trait, and allocate N storage slots to\n// this state variable. This is incorrect, since what we actually store is:\n//  - a ScheduledValueChange<T>, which requires 1 + 2 * M storage slots, where M is the serialization length of T\n//  - a ScheduledDelayChange, which requires another storage slot\n//\n// TODO https://github.com/AztecProtocol/aztec-packages/issues/5736: change the storage allocation scheme so that we\n// can actually use it here\nimpl<T, INITIAL_DELAY, Context> Storage<T> for SharedMutable<T, INITIAL_DELAY, Context> {}\n\n// TODO: extract into a utils module once  we can do arithmetic on generics, i.e. https://github.com/noir-lang/noir/issues/4784\nfn concat_arrays<N, M, O>(arr_n: [Field; N], arr_m: [Field; M]) -> [Field; O] {\n    assert_eq(N + M, O);\n    let mut out: [Field; O] = [0; O];\n    for i in 0..N {\n        out[i] = arr_n[i];\n    }\n    for i in 0..M {\n        out[N+i] = arr_m[i];\n    }\n    out\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, INITIAL_DELAY, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    fn hash_scheduled_data(\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) -> Field where T: ToField {\n        // TODO(#5491 and https://github.com/noir-lang/noir/issues/4784): update this so that we don't need to rely on\n        // ScheduledValueChange serializing to 3 and ScheduledDelayChange serializing to 1\n        let concatenated: [Field; 4] = concat_arrays(value_change.serialize(), delay_change.serialize());\n        poseidon2_hash(concatenated)\n    }\n\n    // Since we can't rely on the native storage allocation scheme, we hash the storage slot to get a unique location in\n    // which we can safely store as much data as we need.\n    // See https://github.com/AztecProtocol/aztec-packages/issues/5492 and\n    // https://github.com/AztecProtocol/aztec-packages/issues/5736\n    // We store three things in public storage:\n    //  - a ScheduledValueChange\n    //  - a ScheduledDelaChange\n    //  - the hash of both of these (via `hash_scheduled_data`)\n    fn get_value_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 0], 0)\n    }\n\n    fn get_delay_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 1], 0)\n    }\n\n    fn get_hash_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 2], 0)\n    }\n\n    // It may seem odd that we take a header and address instead of reading from e.g. a PrivateContext, but this lets us\n    // reuse this function in SharedMutablePrivateGetter.\n    fn historical_read_from_public_storage(\n        self,\n        header: Header,\n        address: AztecAddress\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) where T: FromField + ToField + Eq {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for both the ScheduledValueChange and\n        // ScheduledDelayChange, but that'd require one full sibling path per storage slot (since due to kernel siloing\n        // the storage is not contiguous), and in the best case in which T is a single field that'd be 4 slots.\n        // Instead, we get an oracle to provide us the correct values for both the value and delay changes, and instead\n        // prove inclusion of their hash, which is both a much smaller proof (a single slot), and also independent of\n        // the size of T.\n        let (value_change_hint, delay_change_hint) = get_public_storage_hints(address, self.storage_slot, historical_block_number);\n\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let hash = header.public_storage_historical_read(self.get_hash_storage_slot(), address);\n\n        // @todo This is written strangely to bypass a formatting issue with the if that is breaking ci.\n        let (a, b, c) = if hash != 0 {\n            let a = SharedMutable::hash_scheduled_data(value_change_hint, delay_change_hint);\n            (a, value_change_hint, delay_change_hint)\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized, meaning no value or delay change was ever\n            // scheduled. Therefore, the hints must then correspond to uninitialized scheduled changes.\n            let b = ScheduledValueChange::deserialize(zeroed());\n            let c = ScheduledDelayChange::deserialize(zeroed());\n            (hash, b, c)\n        };\n\n        assert_eq(hash, a, \"Hint values do not match hash\");\n        assert_eq(value_change_hint, b, \"Non-zero value change for zero hash\");\n        assert_eq(delay_change_hint, c, \"Non-zero delay change for zero hash\");\n\n        (value_change_hint, delay_change_hint, historical_block_number)\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PublicContext> {\n    pub fn schedule_value_change(self, new_value: T) where T: ToField {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) where T: ToField {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value_in_public(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay_in_public(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value_in_public(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay_in_public(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        self.context.storage_read(self.get_delay_change_storage_slot())\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) where T: ToField {\n        // Whenever we write to public storage, we write both the value change and delay change as well as the hash of\n        // them both. This guarantees that the hash is always kept up to date.\n        // While this makes for more costly writes, it also makes private proofs much simpler because they only need to\n        // produce a historical proof for the hash, which results in a single inclusion proof (as opposed to 4 in the\n        // best case scenario in which T is a single field). Private shared mutable reads are assumed to be much more\n        // frequent than public writes, so this tradeoff makes sense.\n        self.context.storage_write(self.get_value_change_storage_slot(), value_change);\n        self.context.storage_write(self.get_delay_change_storage_slot(), delay_change);\n        self.context.storage_write(\n            self.get_hash_storage_slot(),\n            SharedMutable::hash_scheduled_data(value_change, delay_change)\n        );\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext> {\n    pub fn get_current_value_in_private(self) -> T where T: FromField + ToField + Eq {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n\n        let (value_change, delay_change, historical_block_number) = self.historical_read_from_public_storage(self.context.get_header(), self.context.this_address());\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n}\n\nunconstrained fn get_public_storage_hints<T, INITIAL_DELAY>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>) {\n    // This function cannot be part of the &mut PrivateContext impl because that'd mean that by passing `self` we'd also\n    // be passing a mutable reference to an unconstrained function, which is not allowed. We therefore create a dummy\n    // state variable here so that we can access the methods to compute storage slots. This will all be removed in the\n    // future once we do proper storage slot allocation (#5492).\n    let dummy = SharedMutable::new((), storage_slot);\n\n    (\n        storage_read(address, dummy.get_value_change_storage_slot(), block_number), storage_read(address, dummy.get_delay_change_storage_slot(), block_number)\n    )\n}\n"},"162":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr","source":"use dep::protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::pedersen_hash};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::create_note, note_getter::{get_note, view_notes}, note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions, note_emission::NoteEmission\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateImmutable<T, Context> {}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor. \n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        pedersen_hash(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<N, M>(\n        self,\n        note: &mut Note\n    ) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier, 0);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<N, M>(self) -> Note where Note: NoteInterface<N, M> {\n        let storage_slot = self.storage_slot;\n        get_note(self.context, storage_slot)\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UnconstrainedContext> {\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    unconstrained pub fn view_note<N, M>(self) -> Note  where Note: NoteInterface<N, M> {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"},"167":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{GAS_LENGTH, FIXED_DA_GAS, FIXED_L2_GAS}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\n    abis::gas_fees::GasFees\n};\nuse std::ops::{Add, Sub};\n\nstruct Gas {\n    da_gas: u32,\n    l2_gas: u32,\n}\n\nimpl Gas {\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\n        Self { da_gas, l2_gas }\n    }\n\n    pub fn tx_overhead() -> Self {\n        Self { da_gas: FIXED_DA_GAS, l2_gas: FIXED_L2_GAS }\n    }\n\n    pub fn compute_fee(self, fees: GasFees) -> Field {\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.da_gas == 0) & (self.l2_gas == 0)\n    }\n\n    pub fn within(self, limits: Gas) -> bool {\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\n    }\n}\n\nimpl Add for Gas {\n    fn add(self, other: Gas) -> Self {\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\n    }\n}\n\nimpl Sub for Gas {\n    fn sub(self, other: Gas) -> Self {\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\n    }\n}\n\nimpl Serialize<GAS_LENGTH> for Gas {\n    fn serialize(self) -> [Field; GAS_LENGTH] {\n        [self.da_gas as Field, self.l2_gas as Field]\n    }\n}\n\nimpl Deserialize<GAS_LENGTH> for Gas {\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\n    }\n}\n\nimpl Eq for Gas {\n    fn eq(self, other : Gas) -> bool {\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\n    }\n}\n\nimpl Empty for Gas {\n    fn empty() -> Self {\n        Gas::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Gas::empty();\n    let serialized = item.serialize();\n    let deserialized = Gas::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n"},"169":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr","source":"use crate::{\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct NoteHash {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for NoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteHash {\n    fn eq(self, other: NoteHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter) \n    }\n}\n\nimpl Empty for NoteHash {\n    fn empty() -> Self {\n        NoteHash {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl NoteHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNoteHash {\n        ScopedNoteHash { note_hash: self, contract_address }\n    }\n}\n\nstruct ScopedNoteHash {\n    note_hash: NoteHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<NoteHash> for ScopedNoteHash {\n    fn inner(self) -> NoteHash {\n        self.note_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNoteHash {\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNoteHash {\n    fn value(self) -> Field {\n        self.note_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl Eq for ScopedNoteHash {\n    fn eq(self, other: ScopedNoteHash) -> bool {\n        (self.note_hash == other.note_hash)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedNoteHash {\n    fn empty() -> Self {\n        ScopedNoteHash {\n            note_hash: NoteHash::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\n        array_concat(self.note_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            note_hash: reader.read_struct(NoteHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNoteHash {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.note_hash.value, read_request.value(), \"Value of the note hash does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the note hash does not match read request\");\n        assert(\n            read_request.counter() > self.note_hash.counter, \"Read request counter must be greater than the counter of the note hash\"\n        );\n    }\n}\n\nimpl ScopedNoteHash {\n    pub fn expose_to_public(self) -> NoteHash {\n        // Hide the actual counter when exposing it to the public kernel.\n        NoteHash { value: self.note_hash.value, counter: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = NoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"170":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"172":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr","source":"use crate::{\n    abis::{\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    transaction::tx_context::TxContext, utils::arrays::validate_array\n};\n\nstruct PrivateCircuitPublicInputsArrayLengths {\n    note_hash_read_requests: u32,\n    nullifier_read_requests: u32,\n    key_validation_requests_and_generators: u32,\n    note_hashes: u32,\n    nullifiers: u32,\n    l2_to_l1_msgs: u32,\n    private_call_requests: u32,\n    public_call_stack_hashes: u32,\n    note_encrypted_logs_hashes: u32,\n    encrypted_logs_hashes: u32,\n    unencrypted_logs_hashes: u32,\n}\n\nimpl PrivateCircuitPublicInputsArrayLengths {\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\n        PrivateCircuitPublicInputsArrayLengths {\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\n            note_hashes: validate_array(public_inputs.note_hashes),\n            nullifiers: validate_array(public_inputs.nullifiers),\n            l2_to_l1_msgs: validate_array(public_inputs.l2_to_l1_msgs),\n            private_call_requests: validate_array(public_inputs.private_call_requests),\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\n        }\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    note_hashes: [NoteHash; MAX_NOTE_HASHES_PER_CALL],\n    nullifiers: [Nullifier; MAX_NULLIFIERS_PER_CALL],\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs: [L2ToL1Message; MAX_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    tx_context: TxContext,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.returns_hash == other.returns_hash) &\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\n        (self.is_fee_payer == other.is_fee_payer) &\n        (self.max_block_number == other.max_block_number) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\n        (self.note_hashes == other.note_hashes) &\n        (self.nullifiers == other.nullifiers) &\n        (self.private_call_requests == other.private_call_requests) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.l2_to_l1_msgs == other.l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\n        self.historical_header.eq(other.historical_header) &\n        self.tx_context.eq(other.tx_context)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\n\n        fields.extend_from_array(self.max_block_number.serialize());\n\n        for i in 0..self.note_hash_read_requests.len() {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..self.nullifier_read_requests.len() {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..self.key_validation_requests_and_generators.len() {\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\n        }\n        for i in 0..self.note_hashes.len() {\n            fields.extend_from_array(self.note_hashes[i].serialize());\n        }\n        for i in 0..self.nullifiers.len() {\n            fields.extend_from_array(self.nullifiers[i].serialize());\n        }\n        for i in 0..self.private_call_requests.len() {\n            fields.extend_from_array(self.private_call_requests[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n        fields.push(self.public_teardown_function_hash);\n        for i in 0..self.l2_to_l1_msgs.len() {\n            fields.extend_from_array(self.l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        for i in 0..self.note_encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.unencrypted_logs_hashes.len() {\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.tx_context.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            is_fee_payer: reader.read() == 1,\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL]),\n            nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL]),\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            public_teardown_function_hash: reader.read(),\n            l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            tx_context: reader.read_struct(TxContext::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PrivateCircuitPublicInputs {\n    fn empty() -> Self {\n        PrivateCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter : 0 as u32,\n            end_side_effect_counter : 0 as u32,\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            tx_context: TxContext::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PrivateCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PrivateCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x15c9b0a92b9b541598e24c9f0b0b4b04b7f2408599751c45aa12de671fd9b363;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"173":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item_compressed.nr","source":"use crate::abis::{call_context::CallContext, function_data::FunctionData, gas::Gas};\nuse crate::address::AztecAddress;\nuse crate::constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH};\nuse crate::traits::{Hash, Empty, Serialize, Deserialize};\nuse crate::utils::reader::Reader;\n\n/**\n * A compressed version of the PublicCallStackItem struct used to compute the \"hash\"\n * of a PublicCallStackItem.\n * \n * Historically, we have been zeroing most values in the PublicCallStackItem struct\n * to compute the hash involved when adding a PublicCallStackItem to the PublicCallStack.\n * \n * This struct is used to store the values that we did not zero out, and allow us to hash\n * only these, thereby skipping a lot of computation and saving us a lot of constraints\n * \n * Essentially this struct exists such that we don't have a `hash` function in the \n * PublicCallStackItem struct that practically throws away some values of the struct\n * without clearly indicating that it does so.\n */\nstruct PublicCallStackItemCompressed {\n    contract_address: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    revert_code: u8,\n    start_gas_left: Gas,\n    end_gas_left: Gas,\n}\n\nimpl Eq for PublicCallStackItemCompressed {\n    fn eq(self, other: PublicCallStackItemCompressed) -> bool {\n        (self.contract_address == other.contract_address)\n            & (self.call_context == other.call_context)\n            & (self.function_data == other.function_data)\n            & (self.args_hash == other.args_hash)\n            & (self.returns_hash == other.returns_hash)\n            & (self.revert_code == other.revert_code)\n            & (self.start_gas_left == other.start_gas_left)\n            & (self.end_gas_left == other.end_gas_left)\n    }\n}\n\nimpl Hash for PublicCallStackItemCompressed {\n    fn hash(self) -> Field {\n        std::hash::pedersen_hash_with_separator(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PublicCallStackItemCompressed {\n    fn empty() -> Self {\n        PublicCallStackItemCompressed {\n            contract_address: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n    fn serialize(self) -> [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.push(self.revert_code as Field);\n        fields.extend_from_array(self.start_gas_left.serialize());\n        fields.extend_from_array(self.end_gas_left.serialize());\n\n        assert_eq(fields.len(), PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n  fn deserialize(fields: [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH]) -> PublicCallStackItemCompressed {\n    let mut reader = Reader::new(fields);\n\n    let item = PublicCallStackItemCompressed {\n      contract_address: reader.read_struct(AztecAddress::deserialize),\n      call_context: reader.read_struct(CallContext::deserialize),\n      function_data: reader.read_struct(FunctionData::deserialize),\n      args_hash: reader.read(),\n      returns_hash: reader.read(),\n      revert_code: reader.read() as u8,\n      start_gas_left: reader.read_struct(Gas::deserialize),\n      end_gas_left: reader.read_struct(Gas::deserialize),\n    };\n    reader.finish();\n    item\n  }\n}\n"},"175":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n"},"176":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr","source":"use crate::{\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for ReadRequest {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\n        ScopedReadRequest { read_request: self, contract_address }\n    }\n}\n\nstruct ScopedReadRequest {\n    read_request: ReadRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<ReadRequest> for ScopedReadRequest {\n    fn inner(self) -> ReadRequest {\n        self.read_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ScopedReadRequest {\n    fn eq(self, other: ScopedReadRequest) -> bool {\n        (self.read_request == other.read_request)\n        & (self.contract_address.eq(other.contract_address))\n    }\n}\n\nimpl Empty for ScopedReadRequest {\n    fn empty() -> Self {\n        ScopedReadRequest {\n            read_request: ReadRequest::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            read_request: reader.read_struct(ReadRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedReadRequest {\n    pub fn value(self) -> Field {\n        self.read_request.value\n    }\n    pub fn counter(self) -> u32 {\n        self.read_request.counter\n    }\n}\n\n#[test]\nfn serialization_of_empty_read() {\n    let item = ReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"179":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr","source":"use crate::{\n    address::AztecAddress,\n    abis::validation_requests::{\n    key_validation_request::KeyValidationRequest,\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\n},\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct KeyValidationRequestAndGenerator {\n    request: KeyValidationRequest,\n    sk_app_generator: Field,\n}\n\nimpl Eq for KeyValidationRequestAndGenerator {\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\n    }\n}\n\nimpl Empty for KeyValidationRequestAndGenerator {\n    fn empty() -> Self {\n        KeyValidationRequestAndGenerator {\n            request: KeyValidationRequest::empty(),\n            sk_app_generator: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\n        array_concat(self.request.serialize(), [self.sk_app_generator])\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\n        let mut reader = Reader::new(fields);\n        let res = Self {\n            request: reader.read_struct(KeyValidationRequest::deserialize),\n            sk_app_generator: reader.read(),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl KeyValidationRequestAndGenerator {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = KeyValidationRequestAndGenerator::empty();\n    let serialized = item.serialize();\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"180":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point::new(fields[0], fields[1], fields[2] as bool),\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"184":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr","source":"use crate::{\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH},\n    hash::compute_siloed_nullifier, traits::{Empty, Hash, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct Nullifier {\n    value: Field,\n    counter: u32,\n    note_hash: Field,\n}\n\nimpl Ordered for Nullifier {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for Nullifier {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for Nullifier {\n    fn eq(self, other: Nullifier) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.note_hash == other.note_hash) \n    }\n}\n\nimpl Empty for Nullifier {\n    fn empty() -> Self {\n        Nullifier {\n            value: 0,\n            counter: 0,\n            note_hash: 0,\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\n        [self.value, self.counter as Field, self.note_hash]\n    }\n}\n\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            note_hash: values[2],\n        }\n    }\n}\n\nimpl Readable for Nullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        // Public kernels output Nullifier instead of ScopedNullifier.\n        // The nullifier value has been siloed.\n        let siloed_request_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.value, siloed_request_value, \"Value of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl Nullifier {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\n        ScopedNullifier { nullifier: self, contract_address }\n    }\n}\n\nstruct ScopedNullifier {\n    nullifier: Nullifier,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<Nullifier> for ScopedNullifier {\n    fn inner(self) -> Nullifier {\n        self.nullifier\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNullifier {\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNullifier {\n    fn value(self) -> Field {\n        self.nullifier.value\n    }\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl Eq for ScopedNullifier {\n    fn eq(self, other: ScopedNullifier) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedNullifier {\n    fn empty() -> Self {\n        ScopedNullifier {\n            nullifier: Nullifier::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            nullifier: reader.read_struct(Nullifier::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.nullifier.value, read_request.value(), \"Value of the nullifier does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.nullifier.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl ScopedNullifier {\n    pub fn nullified_note_hash(self) -> Field {\n        self.nullifier.note_hash\n    }\n\n    pub fn expose_to_public(self) -> Nullifier {\n        // Hide the actual counter and note hash when exposing it to the public kernel.\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Nullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = Nullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"192":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr","source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n  fn eq(self, other: Self) -> bool {\n    (self.nullifier == other.nullifier) &\n    (self.next_nullifier == other.next_nullifier) &\n    (self.next_index == other.next_index)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"193":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"194":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr","source":"use crate::{\n    abis::{\n    private_call_stack_item::PrivateCallStackItem, call_context::CallContext,\n    function_data::FunctionData, caller_context::CallerContext,\n    side_effect::{Ordered, RangeOrdered, Scoped}\n},\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PrivateCallRequest {\n    target: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Ordered for PrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.start_side_effect_counter\n    }\n}\n\nimpl RangeOrdered for PrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.start_side_effect_counter\n    }\n    fn counter_end(self) -> u32 {\n        self.end_side_effect_counter\n    }\n}\n\nimpl Eq for PrivateCallRequest {\n    fn eq(self, other: PrivateCallRequest) -> bool {\n        (self.target == other.target) \n            & (self.call_context == other.call_context) \n            & (self.function_data == other.function_data) \n            & (self.args_hash == other.args_hash) \n            & (self.returns_hash == other.returns_hash)\n            & (self.caller_context == other.caller_context)\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\n    }\n}\n\nimpl Empty for PrivateCallRequest {\n    fn empty() -> Self {\n        PrivateCallRequest {\n            target: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.push(self.target.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.extend_from_array(self.caller_context.serialize());\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = PrivateCallRequest {\n            target: reader.read_struct(AztecAddress::deserialize),\n            call_context: reader.read_struct(CallContext::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            caller_context: reader.read_struct(CallerContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            end_side_effect_counter: reader.read_u32(),\n        };\n        reader.finish();\n        item\n    }\n}\n\nimpl PrivateCallRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\n        ScopedPrivateCallRequest { call_request: self, contract_address }\n    }\n\n    pub fn matches_stack_item(self, stack_item: PrivateCallStackItem) -> bool {\n        (self.target == stack_item.contract_address)\n            & (self.call_context == stack_item.public_inputs.call_context)\n            & (self.function_data == stack_item.function_data)\n            & (self.args_hash == stack_item.public_inputs.args_hash)\n            & (self.returns_hash == stack_item.public_inputs.returns_hash)\n            & (self.start_side_effect_counter\n                                == stack_item.public_inputs.start_side_effect_counter)\n            & (self.end_side_effect_counter\n                                    == stack_item.public_inputs.end_side_effect_counter)\n    }\n}\n\nstruct ScopedPrivateCallRequest {\n    call_request: PrivateCallRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\n    fn inner(self) -> PrivateCallRequest {\n        self.call_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedPrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.call_request.counter_start()\n    }\n}\n\nimpl RangeOrdered for ScopedPrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.call_request.counter_start()\n    }\n    fn counter_end(self) -> u32 {\n        self.call_request.counter_end()\n    }\n}\n\nimpl Eq for ScopedPrivateCallRequest {\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\n        (self.call_request == other.call_request)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedPrivateCallRequest {\n    fn empty() -> Self {\n        ScopedPrivateCallRequest {\n            call_request: PrivateCallRequest::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.call_request.serialize());\n        fields.extend_from_array(self.contract_address.serialize());\n\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = ScopedPrivateCallRequest {\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        item\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = ScopedPrivateCallRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"199":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\n    abis::gas_fees::GasFees,\n    constants::{\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\n    DEFAULT_INCLUSION_FEE\n},\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    utils::reader::Reader\n};\n\nstruct GasSettings {\n    gas_limits: Gas,\n    teardown_gas_limits: Gas,\n    max_fees_per_gas: GasFees,\n    inclusion_fee: Field,\n}\n\nimpl GasSettings {\n    pub fn new(\n        gas_limits: Gas,\n        teardown_gas_limits: Gas,\n        max_fees_per_gas: GasFees,\n        inclusion_fee: Field\n    ) -> Self {\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\n    }\n\n    pub fn default() -> Self {\n        GasSettings::new(\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\n            DEFAULT_INCLUSION_FEE\n        )\n    }\n}\n\nimpl Eq for GasSettings {\n    fn eq(self, other: Self) -> bool {\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\n    }\n}\n\nimpl Empty for GasSettings {\n    fn empty() -> Self {\n        GasSettings::new(\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\n        )\n    }\n}\n\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\n\n        serialized.extend_from_array(self.gas_limits.serialize());\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\n        serialized.push(self.inclusion_fee);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\n        let mut reader = Reader::new(serialized);\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasSettings::empty();\n    let serialized = item.serialize();\n    let deserialized = GasSettings::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"208":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr","source":"use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PrivateCallStackItem {\n    fn empty() -> Self {\n        PrivateCallStackItem {\n            contract_address: AztecAddress::empty(),\n            function_data: FunctionData::empty(),\n            public_inputs: PrivateCircuitPublicInputs::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = PrivateCallStackItem::empty();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item = PrivateCallStackItem::empty();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x065f2831db9ac0db5e710bd3a865b5facd8cf83f1585e1af8fd1d6ce9c47f685;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr","source":"use crate::address::AztecAddress;\nuse crate::traits::{Empty, Serialize, Deserialize};\nuse crate::constants::CALLER_CONTEXT_LENGTH;\nuse crate::utils::reader::Reader;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n    is_static_call: bool,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, other: CallerContext) -> bool {\n        other.msg_sender.eq(self.msg_sender)\n            & other.storage_contract_address.eq(self.storage_contract_address)\n            & other.is_static_call == self.is_static_call\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n            is_static_call: false,\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\n    }\n\n    // Different to an empty context, a hidden context won't reveal the caller's msg_sender and storage_contract_address,\n    // but will still propagate the is_static_call flag.\n    pub fn is_hidden(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array(self.msg_sender.serialize());\n    fields.extend_from_array(self.storage_contract_address.serialize());\n    fields.push(self.is_static_call as Field);\n\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\n    let mut reader = Reader::new(fields);\n\n    let item = CallerContext {\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\n      is_static_call: reader.read_bool(),\n    };\n    reader.finish();\n    item\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = CallerContext::empty();\n    let serialized = item.serialize();\n    let deserialized = CallerContext::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"21":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    fn new(x: Field, y: Field, is_infinite: bool) -> Self {\n        Self { x, y, is_infinite }\n    }\n\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n// Scalar represented as low and high limbs\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    pub fn derive_public_key(self) -> EmbeddedCurvePoint {\n        let public_key = fixed_base_scalar_mul(self.lo, self.hi);\n        EmbeddedCurvePoint { x: public_key[0], y: public_key[1], is_infinite: false }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, key: EmbeddedCurveScalar) -> bool {\n        (key.hi == self.hi) & (key.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n#[foreign(multi_scalar_mul)]\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> [Field; 3]\n// docs:end:multi_scalar_mul\n{}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(\n    scalar_low: Field,\n    scalar_high: Field\n) -> [Field; 3]\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    let scalar = EmbeddedCurveScalar { lo: scalar_low, hi: scalar_high };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n"},"211":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr","source":"use crate::{\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\n    constants::{\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\n},\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct LogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n}\n\nimpl Ordered for LogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for LogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for LogHash {\n    fn eq(self, other: LogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n    }\n}\n\nimpl Empty for LogHash {\n    fn empty() -> Self {\n        LogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n        }\n    }\n}\n\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length]\n    }\n}\n\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n        }\n    }\n}\n\nimpl LogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\n        ScopedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedLogHash {\n    log_hash: LogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<LogHash> for ScopedLogHash {\n    fn inner(self) -> LogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedLogHash {\n    fn eq(self, other: ScopedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedLogHash {\n    fn empty() -> Self {\n        ScopedLogHash {\n            log_hash: LogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(LogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the counter when exposing to public.\n        // The log hash must already be siloed when we call this.\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nstruct EncryptedLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    randomness: Field,\n}\n\nimpl Ordered for EncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for EncryptedLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for EncryptedLogHash {\n    fn eq(self, other: EncryptedLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.randomness == other.randomness) \n    }\n}\n\nimpl Empty for EncryptedLogHash {\n    fn empty() -> Self {\n        EncryptedLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            randomness: 0,\n        }\n    }\n}\n\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.randomness]\n    }\n}\n\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            randomness: values[3],\n        }\n    }\n}\n\nimpl EncryptedLogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedEncryptedLogHash {\n    log_hash: EncryptedLogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\n    fn inner(self) -> EncryptedLogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl ScopedEncryptedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the secret randomness and counter when exposing to public\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\n        // The log hash will already be silo'd when we call this\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nimpl Ordered for ScopedEncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedEncryptedLogHash {\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedEncryptedLogHash {\n    fn empty() -> Self {\n        ScopedEncryptedLogHash {\n            log_hash: EncryptedLogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct NoteLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    note_hash_counter: u32,\n}\n\nimpl NoteLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\n        LogHash { value: self.value, counter: 0, length: self.length }\n    }\n}\n\nimpl Ordered for NoteLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for NoteLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteLogHash {\n    fn eq(self, other: NoteLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.note_hash_counter == other.note_hash_counter) \n    }\n}\n\nimpl Empty for NoteLogHash {\n    fn empty() -> Self {\n        NoteLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            note_hash_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            note_hash_counter: values[3] as u32,\n        }\n    }\n}\n"},"215":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr","source":"struct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n"},"216":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n}\n// docs:end:call-context\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n"},"217":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"22":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"220":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize, Empty}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        (self.is_private == other.is_private)\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nimpl Empty for FunctionData {\n    fn empty() -> Self {\n        FunctionData {\n            selector: FunctionSelector::empty(),\n            is_private: false\n        }\n    }\n\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data = FunctionData::empty();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data = FunctionData::empty();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty function data hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"227":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n    counter: u32,\n}\n\nimpl Ordered for L2ToL1Message {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content, self.counter as Field]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\nimpl L2ToL1Message {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\n        ScopedL2ToL1Message { message: self, contract_address }\n    }\n}\n\nstruct ScopedL2ToL1Message {\n    message: L2ToL1Message,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\n    fn inner(self) -> L2ToL1Message {\n        self.message\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedL2ToL1Message {\n    fn counter(self) -> u32 {\n        self.message.counter\n    }\n}\n\nimpl Eq for ScopedL2ToL1Message {\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\n        (self.message == other.message)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedL2ToL1Message {\n    fn empty() -> Self {\n        ScopedL2ToL1Message {\n            message: L2ToL1Message::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            message: reader.read_struct(L2ToL1Message::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\n#[test]\nfn serialization_of_empty_l2() {\n    let item = L2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = L2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped_l2() {\n    let item = ScopedL2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"229":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"235":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<N> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<N> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<N> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<N> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"236":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"// Utility function to console.log data in the acir simulator\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<M, N>(_msg: str<M>, args: [Field]) {}\n\n/// NOTE: call this with a str<N> msg of form\n/// \"some string with {0} and {1} ... {N}\"\n/// and an array of N field which will be formatted\n/// into the string in the simulator.\n/// Example:\n/// debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n/// debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\nunconstrained pub fn debug_log_format<M, N>(msg: str<M>, args: [Field; N]) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n/// NOTE: call this with a str<N> msg of length > 1\n/// Example:\n/// `debug_log(\"blah blah this is a debug string\");`\nunconstrained pub fn debug_log<N>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n"},"237":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr","source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  num_txs: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.num_txs);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let num_txs = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      num_txs,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      num_txs: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.num_txs == other.num_txs)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n"},"238":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"239":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr","source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"241":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n"},"243":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr","source":"use crate::{\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    abis::gas_settings::GasSettings\n};\n\n// docs:start:tx-context\nstruct TxContext {\n    chain_id : Field,\n    version : Field,\n    gas_settings: GasSettings,\n}\n// docs:end:tx-context\n\nimpl TxContext {\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\n        TxContext { chain_id, version, gas_settings }\n    }\n}\n\nimpl Eq for TxContext {\n    fn eq(self, other: Self) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.gas_settings.eq(other.gas_settings))\n    }\n}\n\nimpl Empty for TxContext {\n    fn empty() -> Self {\n        TxContext {\n            chain_id: 0,\n            version: 0,\n            gas_settings: GasSettings::empty(),\n        }\n    }\n}\n\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\n\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.extend_from_array(self.gas_settings.serialize());\n\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let context = Self {\n            chain_id: reader.read(),\n            version: reader.read(),\n            gas_settings: reader.read_struct(GasSettings::deserialize),\n        };\n\n        reader.finish();\n        context\n    }\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context = TxContext::empty();\n    let serialized = context.serialize();\n    let deserialized = TxContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let context = TxContext::empty();\n    let hash = context.hash();\n\n    // Value from tx_context.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"246":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: Field = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point {\n            x: 0,\n            y: 0,\n            is_infinite: false\n        }\n    }\n}\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn pub_key_to_bytes(pk: Point) -> [u8; 64] {\n    assert(!pk.is_infinite, \"Point at infinity is not a valid public key.\");\n    let mut result = [0 as u8; 64];\n    let x_bytes = pk.x.to_be_bytes(32);\n    let y_bytes = pk.y.to_be_bytes(32);\n    for i in 0..32 {\n        result[i] = x_bytes[i];\n        result[i + 32] = y_bytes[i];\n    }\n    result\n}\n"},"247":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"249":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n"},"25":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n#[no_predicates]\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    let value = pedersen_commitment_with_separator(input, 0);\n    if (value.x == 0) & (value.y == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value.x, y: value.y, is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        points[i] = EmbeddedCurveScalar::from_field(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let values = multi_scalar_mul(generators, points);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: values[2] as bool }\n}\n\n#[no_predicates]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let v1 = pedersen_commitment_with_separator(input, separator);\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    multi_scalar_mul(\n        [length_generator[0], v1],\n        [EmbeddedCurveScalar { lo: N as Field, hi: 0 }, EmbeddedCurveScalar { lo: 1, hi: 0 }]\n    )[0]\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n#[test]\nfn assert_pedersen_noir() {\n    // TODO: make this a fuzzer test once fuzzer supports curve-specific blackbox functions.\n    let input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq(pedersen_hash_with_separator(input, 4), pedersen_hash_with_separator_noir(input, 4));\n    assert_eq(pedersen_commitment_with_separator(input, 4), pedersen_commitment_with_separator_noir(input, 4));\n}\n"},"263":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"273":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"289":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"292":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\n    address::{\n    eth_address::EthAddress, salted_initialization_hash::SaltedInitializationHash,\n    aztec_address::AztecAddress\n},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::pedersen_hash, traits::{ToField, FromField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH = 1;\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n       PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            pedersen_hash(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"293":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\n    address::{eth_address::EthAddress, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            pedersen_hash(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"32":{"path":"std/merkle.nr","source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n"},"38":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"381":{"path":"/usr/src/noir-projects/noir-contracts/contracts/schnorr_account_contract/src/main.nr","source":"mod public_key_note;\n\n// Account contract that uses Schnorr signatures for authentication.\n// The signing key is stored in an immutable private note and should be different from the encryption/nullifying key.\ncontract SchnorrAccount {\n    use dep::std;\n\n    use dep::aztec::prelude::{AztecAddress, FunctionSelector, NoteHeader, PrivateContext, PrivateImmutable};\n    use dep::aztec::encrypted_logs::encrypted_note_emission::encode_and_encrypt_note;\n    use dep::authwit::{\n        entrypoint::{app::AppPayload, fee::FeePayload}, account::AccountActions,\n        auth_witness::get_auth_witness, auth::{compute_authwit_nullifier, compute_authwit_message_hash}\n    };\n    use dep::aztec::hash::compute_siloed_nullifier;\n    use dep::aztec::oracle::get_nullifier_membership_witness::get_low_nullifier_membership_witness;\n\n    use crate::public_key_note::{PublicKeyNote, PUBLIC_KEY_NOTE_LEN};\n\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage\n        signing_public_key: PrivateImmutable<PublicKeyNote>,\n        // docs:end:storage\n    }\n\n    // Constructs the contract\n    #[aztec(private)]\n    #[aztec(initializer)]\n    fn constructor(signing_pub_key_x: Field, signing_pub_key_y: Field) {\n        let this = context.this_address();\n        let header = context.get_header();\n        let this_npk_m_hash = header.get_npk_m_hash(&mut context, this);\n        // Not emitting outgoing for msg_sender here to not have to register keys for the contract through which we\n        // deploy this (typically MultiCallEntrypoint). I think it's ok here as I feel the outgoing here is not that\n        // important.\n\n        // docs:start:initialize\n        let mut pub_key_note = PublicKeyNote::new(signing_pub_key_x, signing_pub_key_y, this_npk_m_hash);\n        storage.signing_public_key.initialize(&mut pub_key_note).emit(encode_and_encrypt_note(&mut context, this, this));\n        // docs:end:initialize\n    }\n\n    // Note: If you globally change the entrypoint signature don't forget to update default_entrypoint.ts file\n    #[aztec(private)]\n    #[aztec(noinitcheck)]\n    fn entrypoint(app_payload: AppPayload, fee_payload: FeePayload) {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.entrypoint(app_payload, fee_payload);\n    }\n\n    #[aztec(private)]\n    #[aztec(noinitcheck)]\n    #[aztec(view)]\n    fn verify_private_authwit(inner_hash: Field) -> Field {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.verify_private_authwit(inner_hash)\n    }\n\n    #[contract_library_method]\n    fn is_valid_impl(context: &mut PrivateContext, outer_hash: Field) -> bool {\n        // docs:start:entrypoint\n        // Load public key from storage\n        let storage = Storage::init(context);\n        // docs:start:get_note\n        let public_key = storage.signing_public_key.get_note();\n        // docs:end:get_note\n        // Load auth witness\n        let witness: [Field; 64] = get_auth_witness(outer_hash);\n        let mut signature: [u8; 64] = [0; 64];\n        for i in 0..64 {\n            signature[i] = witness[i] as u8;\n        }\n\n        // Verify signature of the payload bytes\n        let verification = std::schnorr::verify_signature_slice(\n            public_key.x,\n            public_key.y,\n            signature,\n            outer_hash.to_be_bytes(32)\n        );\n        assert(verification == true);\n        // docs:end:entrypoint\n        true\n    }\n\n    /**\n    * @notice Helper function to check validity of private authwitnesses\n    * @param consumer The address of the consumer of the message\n    * @param message_hash The message hash of the message to check the validity\n    * @return True if the message_hash can be consumed, false otherwise\n    */\n    unconstrained fn lookup_validity(consumer: AztecAddress, inner_hash: Field) -> pub bool {\n        let public_key = storage.signing_public_key.view_note();\n\n        let message_hash = compute_authwit_message_hash(consumer, context.chain_id(), context.version(), inner_hash);\n\n        let witness: [Field; 64] = get_auth_witness(message_hash);\n        let mut signature: [u8; 64] = [0; 64];\n        for i in 0..64 {\n            signature[i] = witness[i] as u8;\n        }\n        let valid_in_private = std::schnorr::verify_signature_slice(\n            public_key.x,\n            public_key.y,\n            signature,\n            message_hash.to_be_bytes(32)\n        );\n\n        // Compute the nullifier and check if it is spent\n        // This will BLINDLY TRUST the oracle, but the oracle is us, and\n        // it is not as part of execution of the contract, so we are good.\n        let nullifier = compute_authwit_nullifier(context.this_address(), inner_hash);\n        let siloed_nullifier = compute_siloed_nullifier(consumer, nullifier);\n        let lower_wit = get_low_nullifier_membership_witness(context.block_number(), siloed_nullifier);\n        let is_spent = lower_wit.leaf_preimage.nullifier == siloed_nullifier;\n\n        !is_spent & valid_in_private\n    }\n}\n"},"382":{"path":"/usr/src/noir-projects/noir-contracts/contracts/schnorr_account_contract/src/public_key_note.nr","source":"use dep::aztec::prelude::{AztecAddress, NoteHeader, NoteInterface, PrivateContext};\nuse dep::aztec::{\n    note::utils::compute_note_hash_for_consumption, keys::getters::get_nsk_app,\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash}\n};\n\nglobal PUBLIC_KEY_NOTE_LEN: Field = 3;\n// PUBLIC_KEY_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal PUBLIC_KEY_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// Stores a public key composed of two fields\n// TODO: Do we need to include a nonce, in case we want to read/nullify/recreate with the same pubkey value?\n#[aztec(note)]\nstruct PublicKeyNote {\n    x: Field,\n    y: Field,\n    // We store the npk_m_hash only to get the secret key to compute the nullifier\n    npk_m_hash: Field,\n}\n\nimpl NoteInterface<PUBLIC_KEY_NOTE_LEN, PUBLIC_KEY_NOTE_BYTES_LEN> for PublicKeyNote {\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl PublicKeyNote {\n    pub fn new(x: Field, y: Field, npk_m_hash: Field) -> Self {\n        PublicKeyNote { x, y, npk_m_hash, header: NoteHeader::empty() }\n    }\n}\n"},"4":{"path":"std/cmp.nr","source":"// docs:start:eq-trait\ntrait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\nimpl Eq for Field { fn eq(self, other: Field) -> bool { self == other } }\n\nimpl Eq for u64 { fn eq(self, other: u64) -> bool { self == other } }\nimpl Eq for u32 { fn eq(self, other: u32) -> bool { self == other } }\nimpl Eq for u8 { fn eq(self, other: u8) -> bool { self == other } }\nimpl Eq for u1 { fn eq(self, other: u1) -> bool { self == other } }\n\nimpl Eq for i8 { fn eq(self, other: i8) -> bool { self == other } }\nimpl Eq for i32 { fn eq(self, other: i32) -> bool { self == other } }\nimpl Eq for i64 { fn eq(self, other: i64) -> bool { self == other } }\n\nimpl Eq for () { fn eq(_self: Self, _other: ()) -> bool { true } }\nimpl Eq for bool { fn eq(self, other: bool) -> bool { self == other } }\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3) & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\nstruct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n// docs:start:ord-trait\ntrait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"47":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"5":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\nstruct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len);\n        self.get_unchecked(index)\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Responds with undefined data for `index` where `self.len < index < self.max_len()`.\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Does not check whether the passed `index` is a valid index within the vector.\n    ///\n    /// Silently writes past the end of the vector for `index` where `self.len < index < self.max_len()`\n    /// Panics if the given index points beyond the maximum length of the vector (`self.max_len()`).\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        \n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen>  {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n    // TODO: Allow imports from \"super\"\n    use crate::collections::bounded_vec::BoundedVec;\n\n    #[test]\n    fn empty_equality() {\n        let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n        let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n        assert_eq(bounded_vec1, bounded_vec2);\n    }\n\n    #[test]\n    fn inequality() {\n        let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n        let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n        bounded_vec1.push(1);\n        bounded_vec2.push(2);\n\n        assert(bounded_vec1 != bounded_vec2);\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n}\n"},"53":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/auth_witness.nr","source":"#[oracle(getAuthWitness)]\nunconstrained fn get_auth_witness_oracle<N>(_message_hash: Field) -> [Field; N] {}\n\n/**\n * Oracle wrapper to fetch an `auth_witness` for a given `message_hash` from the PXE.\n * \n * @param message_hash The hash of the message for which the `auth_witness` is to be fetched.\n * @return The `auth_witness` for the given `message_hash` as Field array.\n */\nunconstrained pub fn get_auth_witness<N>(message_hash: Field) -> [Field; N] {\n    get_auth_witness_oracle(message_hash)\n}\n"},"54":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n    GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER, GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    CANONICAL_AUTH_REGISTRY_ADDRESS\n},\n    hash::pedersen_hash\n};\nuse dep::aztec::{prelude::Deserialize, context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties \n * (e.g. protocols or other users) to execute an action on their behalf.\n * \n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be \n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few \n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can \n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be \n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n * \n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer. \n * \n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is \n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n * \n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline \n * how this would look in private, and then in public later. \n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX). \n * `Alice` would make a `deposit` transaction, that she is executing using her account contract. \n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token` \n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to \n * convince the `Token` contract that it is allowed to do so. \n * \n * This is where the authentication witness comes in! The `Token` contract computes a `message_hash` from the \n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to \n * execute that call.\n * \n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her \n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n * \n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n * \n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts. \n * \n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *  \n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store \n * the messages that we have approved. \n * \n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `keccak256(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a colission and we return \n *      a success flag.\n * \n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be \n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the \n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n * \n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains. \n */\n\nglobal IS_VALID_SELECTOR = 0xabf64ad4; // 4 first bytes of keccak256(\"IS_VALID()\")\n\n/** \n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n * \n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([context.msg_sender().to_field(), context.selector().to_field(), context.args_hash]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/** \n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n * \n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n * \n * @param on_behalf_of The address that have authorized the current call\n * @param inner_hash The hash of the message to authorize  \n */\npub fn assert_inner_hash_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context.static_call_private_function(\n        on_behalf_of,\n        FunctionSelector::from_signature(\"verify_private_authwit(Field)\"),\n        [inner_hash]\n    ).unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier, 0);\n}\n\n/** \n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n * \n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n * \n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub fn assert_current_call_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash(\n        [(*context).msg_sender().to_field(), (*context).selector().to_field(), (*context).get_args_hash()]\n    );\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/** \n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n * \n * @param on_behalf_of The address that have authorized the the `inner_hash`\n */\npub fn assert_inner_hash_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    let result: Field = context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"consume((Field),Field)\"),\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default()\n    ).deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness \n * \n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n * \n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<N>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N]\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash = compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n * \n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n * \n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<N>(args: [Field; N]) -> Field {\n    pedersen_hash(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/** \n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n * \n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n * \n * @param on_behalf_of The address that have authorized the the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    pedersen_hash(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n * \n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(consumer: AztecAddress, chain_id: Field, version: Field, inner_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        consumer.to_field(),\n        chain_id,\n        version,\n        inner_hash\n    ],\n        GENERATOR_INDEX__AUTHWIT_OUTER\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n * \n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n * \n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"set_authorized(Field,bool)\"),\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n * \n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise \n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"set_reject_all(bool)\"),\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n"},"55":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/account.nr","source":"use dep::aztec::context::{PrivateContext, PublicContext};\nuse dep::aztec::protocol_types::{address::AztecAddress, abis::function_selector::FunctionSelector, hash::pedersen_hash};\n\nuse crate::entrypoint::{app::AppPayload, fee::FeePayload};\nuse crate::auth::{IS_VALID_SELECTOR, compute_authwit_message_hash};\n\nstruct AccountActions<Context> {\n  context: Context,\n  is_valid_impl: fn(&mut PrivateContext, Field) -> bool,\n}\n\nimpl<Context> AccountActions<Context> {\n    pub fn init(context: Context, is_valid_impl: fn(&mut PrivateContext, Field) -> bool) -> Self {\n        AccountActions { context, is_valid_impl }\n    }\n}\n\n/**\n * An implementation of the Account Action struct for the private context.\n * \n * Implements logic to verify authorization and execute payloads.\n */\nimpl AccountActions<&mut PrivateContext> {\n\n    /** \n     * Verifies that the `app_hash` and `fee_hash` are authorized and then executes them.\n     * \n     * Executes the `fee_payload` and `app_payload` in sequence.\n     * Will execute the `fee_payload` as part of the setup, and then enter the app phase.\n     * \n     * @param app_payload The payload that contains the calls to be executed in the app phase.\n     * @param fee_payload The payload that contains the calls to be executed in the setup phase.\n     */\n    // docs:start:entrypoint\n    pub fn entrypoint(self, app_payload: AppPayload, fee_payload: FeePayload) {\n        let valid_fn = self.is_valid_impl;\n\n        let fee_hash = fee_payload.hash();\n        assert(valid_fn(self.context, fee_hash));\n        fee_payload.execute_calls(self.context);\n        self.context.end_setup();\n\n        let app_hash = app_payload.hash();\n        assert(valid_fn(self.context, app_hash));\n        app_payload.execute_calls(self.context);\n    }\n    // docs:end:entrypoint\n\n    /**\n     * Verifies that the `msg_sender` is authorized to consume `inner_hash` by the account.\n     * \n     * Computes the `message_hash` using the `msg_sender`, `chain_id`, `version` and `inner_hash`.\n     * Then executes the `is_valid_impl` function to verify that the message is authorized.\n     * \n     * Will revert if the message is not authorized. \n     * \n     * @param inner_hash The hash of the message that the `msg_sender` is trying to consume.\n     */\n    // docs:start:verify_private_authwit\n    pub fn verify_private_authwit(self, inner_hash: Field) -> Field {\n        // The `inner_hash` is \"siloed\" with the `msg_sender` to ensure that only it can \n        // consume the message.\n        // This ensures that contracts cannot consume messages that are not intended for them.\n        let message_hash = compute_authwit_message_hash(\n            self.context.msg_sender(),\n            self.context.chain_id(),\n            self.context.version(),\n            inner_hash\n        );\n        let valid_fn = self.is_valid_impl;\n        assert(valid_fn(self.context, message_hash) == true, \"Message not authorized by account\");\n        IS_VALID_SELECTOR\n    }\n    // docs:end:verify_private_authwit\n}\n"},"56":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/entrypoint/app.nr","source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD, hash::pedersen_hash, traits::{Hash, Serialize}};\n\nuse crate::entrypoint::function_call::{FunctionCall, FUNCTION_CALL_SIZE_IN_BYTES};\n\n// FUNCTION_CALL_SIZE * ACCOUNT_MAX_CALLS + 1\nglobal APP_PAYLOAD_SIZE: u64 = 21;\n// FUNCTION_CALL_SIZE_IN_BYTES * ACCOUNT_MAX_CALLS + 32\nglobal APP_PAYLOAD_SIZE_IN_BYTES: u64 = 424;\n\nglobal ACCOUNT_MAX_CALLS: u64 = 4;\n\n// Note: If you change the following struct you have to update default_entrypoint.ts\n// docs:start:app-payload-struct\nstruct AppPayload {\n  function_calls: [FunctionCall; ACCOUNT_MAX_CALLS],\n  nonce: Field,\n}\n// docs:end:app-payload-struct\n\nimpl Serialize<APP_PAYLOAD_SIZE> for AppPayload {\n  // Serializes the entrypoint struct\n  fn serialize(self) -> [Field; APP_PAYLOAD_SIZE] {\n    let mut fields: BoundedVec<Field, APP_PAYLOAD_SIZE> = BoundedVec::new();\n    for call in self.function_calls {\n      fields.extend_from_array(call.serialize());\n    }\n    fields.push(self.nonce);\n    fields.storage\n  }\n}\n\nimpl Hash for AppPayload {\n  fn hash(self) -> Field {\n    pedersen_hash(\n      self.serialize(),\n      GENERATOR_INDEX__SIGNATURE_PAYLOAD\n    )\n  }\n}\n\nimpl AppPayload {\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n    fn to_be_bytes(self) -> [u8; APP_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, APP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..ACCOUNT_MAX_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_slice(self.nonce.to_be_bytes(32));\n\n        bytes.storage\n    }\n\n    // Executes all private and public calls\n    // docs:start:entrypoint-execute-calls\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                }\n            }\n        }\n    }\n    // docs:end:entrypoint-execute-calls\n}\n"},"58":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/entrypoint/fee.nr","source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{constants::GENERATOR_INDEX__FEE_PAYLOAD, hash::pedersen_hash, traits::{Hash, Serialize}};\nuse crate::entrypoint::function_call::FunctionCall;\n\n// 2 * 5 (FUNCTION_CALL_SIZE) + 2\nglobal FEE_PAYLOAD_SIZE: Field = 12;\n\n// 2 * 98 (FUNCTION_CALL_SIZE_IN_BYTES) + 32\nglobal FEE_PAYLOAD_SIZE_IN_BYTES: Field = 228;\n\nglobal MAX_FEE_FUNCTION_CALLS = 2;\n\n// docs:start:fee-payload-struct\nstruct FeePayload {\n  function_calls: [FunctionCall; MAX_FEE_FUNCTION_CALLS],\n  nonce: Field,\n  is_fee_payer: bool,\n}\n// docs:end:fee-payload-struct\n\nimpl Serialize<FEE_PAYLOAD_SIZE> for FeePayload {\n  // Serializes the entrypoint struct\n  fn serialize(self) -> [Field; FEE_PAYLOAD_SIZE] {\n    let mut fields: BoundedVec<Field, FEE_PAYLOAD_SIZE> = BoundedVec::new();\n    for i in 0..MAX_FEE_FUNCTION_CALLS {\n      fields.extend_from_array(self.function_calls[i].serialize());\n    }\n    fields.push(self.nonce);\n    fields.push(self.is_fee_payer as Field);\n    fields.storage\n  }\n}\n\nimpl Hash for FeePayload {\n  fn hash(self) -> Field {\n    pedersen_hash(\n      self.serialize(),\n      GENERATOR_INDEX__FEE_PAYLOAD\n    )\n  }\n}\n\nimpl FeePayload {\n    fn to_be_bytes(self) -> [u8; FEE_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, FEE_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_slice(self.nonce.to_be_bytes(32));\n        bytes.push(self.is_fee_payer as u8);\n\n        bytes.storage\n    }\n\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                }\n            }\n        }\n        if self.is_fee_payer {\n            context.set_as_fee_payer();\n        }\n    }\n}\n"},"64":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::{Point, pub_key_to_bytes},\n    utils::arr_copy_slice\n};\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret_fields = multi_scalar_mul([point], [secret]);\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/6061): make the func return Point struct directly\n    let shared_secret = pub_key_to_bytes(Point::new(shared_secret_fields[0], shared_secret_fields[1], false));\n    let mut shared_secret_bytes_with_separator = [0 as u8; 65];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[64] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nfn check_point_to_symmetric_key() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar::new(\n        0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    );\n    let point = Point::new(\n        0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        false\n    );\n\n    let key = point_to_symmetric_key(secret, point);\n    // The following value gets updated when running encrypt_buffer.test.ts with AZTEC_GENERATE_TEST_DATA=1\n    let expected_key = [\n        49, 167, 146, 222, 151, 129, 138, 184, 87, 210, 245, 249, 99, 100, 1, 59, 223, 180, 5, 99, 14, 7, 177, 236, 159, 203, 231, 72, 220, 180, 241, 23\n    ];\n    assert_eq(key, expected_key);\n}\n"},"65":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::PrivateContext,\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}},\n    state_vars::{shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter}\n};\n\nglobal DELAY = 5;\n\n// docs:start:key-getters\ntrait KeyGetters {\n  fn get_npk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ivpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ovpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_tpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_npk_m_hash(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Field;\n}\n\nimpl KeyGetters for Header {\n    fn get_npk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, NULLIFIER_INDEX, self)\n    }\n\n    fn get_ivpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, INCOMING_INDEX, self)\n    }\n\n    fn get_ovpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, OUTGOING_INDEX, self)\n    }\n\n    fn get_tpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, TAGGING_INDEX, self)\n    }\n\n    fn get_npk_m_hash(self, context: &mut PrivateContext, address: AztecAddress) -> Field {\n        get_master_key(context, address, NULLIFIER_INDEX, self).hash()\n    }\n}\n// docs:end:key-getters\n\nfn get_master_key(\n    context: &mut PrivateContext,\n    address: AztecAddress,\n    key_index: Field,\n    header: Header\n) -> Point {\n    let key = fetch_key_from_registry(context, key_index, address, header);\n    if is_empty(key) {\n        // Keys were not registered in registry yet --> fetch key from PXE\n        let keys = fetch_and_constrain_keys(address);\n        // Return the corresponding to index\n        keys.get_key_by_index(key_index)\n    } else {\n        // Keys were registered --> return the key\n        key\n    }\n}\n\nfn fetch_key_from_registry(\n    context: &mut PrivateContext,\n    key_index: Field,\n    address: AztecAddress,\n    header: Header\n) -> Point {\n    let x_coordinate_map_slot = key_index * 2 + 1;\n    let y_coordinate_map_slot = x_coordinate_map_slot + 1;\n    let x_coordinate_derived_slot = derive_storage_slot_in_map(x_coordinate_map_slot, address);\n    let y_coordinate_derived_slot = derive_storage_slot_in_map(y_coordinate_map_slot, address);\n\n    let x_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        x_coordinate_derived_slot\n    );\n    let y_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        y_coordinate_derived_slot\n    );\n    let x_coordinate = x_coordinate_registry.get_value_in_private(header);\n    let y_coordinate = y_coordinate_registry.get_value_in_private(header);\n\n    Point::new(x_coordinate, y_coordinate, false)\n}\n\n// Passes only when keys were not rotated - is expected to be called only when keys were not registered yet\nfn fetch_and_constrain_keys(address: AztecAddress) -> PublicKeys {\n    let (public_keys, partial_address) = get_public_keys_and_partial_address(address);\n\n    let computed_address = AztecAddress::compute(public_keys.hash(), partial_address);\n\n    assert(computed_address.eq(address));\n\n    public_keys\n}\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n"},"66":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr","source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH, hash::poseidon2_hash,\n    point::Point, traits::{Deserialize, Serialize, Empty, is_empty}\n};\nuse crate::keys::constants::{NUM_KEY_TYPES, NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX};\n\nglobal PUBLIC_KEYS_LENGTH = 12;\n\nstruct PublicKeys {\n    npk_m: Point,\n    ivpk_m: Point,\n    ovpk_m: Point,\n    tpk_m: Point,\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m : Point::empty(),\n            ivpk_m : Point::empty(),\n            ovpk_m : Point::empty(),\n            tpk_m : Point::empty()\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        ( self.npk_m == other.npk_m ) &\n        ( self.ivpk_m == other.ivpk_m ) &\n        ( self.ovpk_m == other.ovpk_m ) &\n        ( self.tpk_m == other.tpk_m )\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash(\n                [\n                self.npk_m.x,\n                self.npk_m.y,\n                self.npk_m.is_infinite as Field,\n                self.ivpk_m.x,\n                self.ivpk_m.y,\n                self.ivpk_m.is_infinite as Field,\n                self.ovpk_m.x,\n                self.ovpk_m.y,\n                self.ovpk_m.is_infinite as Field,\n                self.tpk_m.x,\n                self.tpk_m.y,\n                self.tpk_m.is_infinite as Field,\n                GENERATOR_INDEX__PUBLIC_KEYS_HASH\n            ]\n            )\n        }\n        )\n    }\n\n    pub fn get_key_by_index(self, index: Field) -> Point {\n        assert(index as u8 < NUM_KEY_TYPES, \"Invalid key index\");\n        if index == NULLIFIER_INDEX {\n            self.npk_m\n        } else if index == INCOMING_INDEX {\n            self.ivpk_m\n        } else if index == OUTGOING_INDEX {\n            self.ovpk_m\n        } else {\n            self.tpk_m\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.x,\n            self.npk_m.y,\n            self.npk_m.is_infinite as Field,\n            self.ivpk_m.x,\n            self.ivpk_m.y,\n            self.ivpk_m.is_infinite as Field,\n            self.ovpk_m.x,\n            self.ovpk_m.y,\n            self.ovpk_m.is_infinite as Field,\n            self.tpk_m.x,\n            self.tpk_m.y,\n            self.tpk_m.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: Point::new(serialized[0], serialized[1], serialized[2] as bool),\n            ivpk_m: Point::new(serialized[3], serialized[4], serialized[5] as bool),\n            ovpk_m: Point::new(serialized[6], serialized[7], serialized[8] as bool),\n            tpk_m: Point::new(serialized[9], serialized[10], serialized[11] as bool)\n        }\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: Point { x: 1, y: 2, is_infinite: false },\n        ivpk_m: Point { x: 3, y: 4, is_infinite: false },\n        ovpk_m: Point { x: 5, y: 6, is_infinite: false },\n        tpk_m: Point { x: 7, y: 8, is_infinite: false }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x146f68c0e0ba4067d61a3304bbfdec0797d5df1357db6c01247c48bfb345c7d7;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nfn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nfn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: Point { x: 1, y: 2, is_infinite: false },\n        ivpk_m: Point { x: 3, y: 4, is_infinite: false },\n        ovpk_m: Point { x: 5, y: 6, is_infinite: false },\n        tpk_m: Point { x: 7, y: 8, is_infinite: false }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.x, deserialized.npk_m.x);\n    assert_eq(keys.npk_m.y, deserialized.npk_m.y);\n    assert_eq(keys.ivpk_m.x, deserialized.ivpk_m.x);\n    assert_eq(keys.ivpk_m.y, deserialized.ivpk_m.y);\n    assert_eq(keys.ovpk_m.x, deserialized.ovpk_m.x);\n    assert_eq(keys.ovpk_m.y, deserialized.ovpk_m.y);\n    assert_eq(keys.tpk_m.x, deserialized.tpk_m.x);\n    assert_eq(keys.tpk_m.y, deserialized.tpk_m.y);\n}\n"},"80":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n"},"88":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::storage::{raw_storage_read, storage_read};\n\nstruct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = block_number_oracle();\n        let contract_address = contract_address_oracle();\n        let chain_id = chain_id_oracle();\n        let version = version_oracle();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<N>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n\n#[oracle(getContractAddress)]\nunconstrained fn contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn version_oracle() -> Field {}\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"}}}