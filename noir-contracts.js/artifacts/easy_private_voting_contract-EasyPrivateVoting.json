{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"EasyPrivateVoting","functions":[{"name":"cast_vote","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"candidate","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"7L3djiy/zt53L/v4xYZEUV++lSAInMQJDBh2EDtHxnvvaVWvqpm1p3pqprvIflji0V7/jep5fhJVlIoSxf/5j//zP/3v/9///b/95//6f/23//6P//C//M9//Jf/9n/8x//xn//bf7391//8R+Tl//vv/89//K/jP//7//iP/+//+Md/CP/2j//0X//P2//++7/94//6z//lP/3jP6Qc//3fvjxHJfY/j1LhuD0dae9pDo3/PM0xHz3dua9P95zT9jRx+Pf/9d/+EbNV8KIIHmtcwSm9Cl5fAU+N1kdTy2V7uvPyt5vg3+6v/O0Y69opkVL/1IW09zRvJDGncvA0lbY+TS2Evzr81+ah8FIzaRviMSU6AM8bSUl5e7bFhSOCcBAIRwLhYBCODMJRQDgqCEcD4egYHEnTn5Z1mi5c/5UjgnAo+tOayp+Hawv/yqHoT3vYZtxPz7a9P1xS2LruYyjFvrtKyK2uECWUv54eLeTLtzBfvoXFfgtLjFsLU/7Swnr5FrbLt7BfoIW8fXGVEv61hRwu38J4+RbSFWaL8tHC+KWFoGuavjqPmtJRC3vMK0T/HJ3ISwP56g1UXNHE0DanHjl/38Sc2p9nc+EPjAeTxfpnW/toX1raVy7evnrx9rWLt69fu305XLx98eLto4u3L128fXzx9l18/ZIvvn7JF1+/5IuvX/LF1y/l4uuXcvH1S7n4+qVcfP1S+OLtu/j6pVx8/VIuvn4pF1+/lIuvX+rF1y/14uuXevH1S734+qXyxdt38fVLRV2/VFp39Wqqn9s3oFEXJd9Co6402rZf3lo8GEnf7rVW1LXGaS1sqKuN81qIut44r4WoK47zWoi65jivhXz5FqKuO85rIerK47wWoi5Tzmvh5dc07fJrmn75NU2//JqmX35N0y+/pul8+RZefk3TL7+m6Zdf0/TLr2n65dc0MVx+URPD5Vc1MVx+WRPD5dc1MfD1m3j5lU0Ml1/axHD5tc1N9fpNvP7qJl5/dROvv7qJ11/dxOuvbl67qNFGE6+/uonXX93E669u4vVXN/H6qxu6/uqGrr+6oeuvbuj6qxvNy0nf1cTrr27o+qsbuv7qhq6/uqHrr27S9Vc36fqrm3T91U26/upG80LfdzXx+qubdP3VTbr+6iZdf3WTrr+64euvbvj6qxu+/uqGr7+60bzb911NvP7qBvaC3xObeP3VDew1vyc28fqrG9jLfk9s4vVXN7BX/p7YxOuvbmAv/j2xiddf3cBe/3tiE6+/uoG9BPjEJl5/dQN7FfCJTbz+6gb2QuATm3j91Q3stcAnNvH6qxvYy4FPbOL1VzewVwSf2MTrr25gLwo+sYnXX93AXhd8YhOvv7qBvTT4xCZef3UDe3XwiU28/urm+tcSx+vfSxx1Lyam+qCJC8ruKuQWI+zrjwrVAyBKmwRxKx9A3Heerpm3bvyAb2Hn0c59fbbnz93I4Q5PluGTNnwv6xC7jXv+TL/wMBhP1ua57RhvQDn3780b6eMVJ/r401TTHkjmtQAA5frhPWjv4cRbmfN0G0QfD++93ylu1bdv/6yfH156sXgvntCL1XvxhF5s3osn9GL3XvxJL9I2/aYUw7/24v49yt6Lv+zF6L34k15MW6WZlDh8/zC1bVlErdLBw2nrDkrxi6/o5PZ5s322ak6UWv/+4ZrX9tXPxOluyuSmvIop2U15FVP6R+q7Tdn71nlUXzGlfylfxpT+uf5mU/LW1ZQ/t/DPstQDAdj28RADsn0oePAC2z4eFnmzfQrR+nAp8fuHbztNae2OVvmLMT2GciFjehTFkjF73/5yiO35LwIK7Haf0u4en5nT7h7MMWT32xqLN7tnesXuHvmZ0+4eURKwe1//MvVw4I2/34im4BGld9vnpC0vih58uowpPU71blOetOVF0aNUlzGlx6jebMrvo/vRY0nY9vGYD7Z9PDaDbR+PobzZPidueEUPjFzImB5FsWTM03YzyEMuc9rd4zNz2t2DOYbsft4uFnnkZ067s9v9dLv3umUuh1BfWneTR5Sw7eMRpTfb57yljwefLmNKDz1dxpQeeLqKKZPHkt5ryvM+G5KHhy5jSo/4/MyUW4fcLMlHX/6nXaREySMz77bPWYceE7spr2JKj8tcxpQewnm3Kc86v5o8hHMZU3oI582m/P6oXvK4DLR92IMt2PbxCAq2fTws8mb7nHh6lT2GciFjshvTkDFP2z5iD7nMaXePz8xpdw/mGLL7eRuS7JGfOe3uESUBu593kVL2iNK77XPWllf24NNlTOlxqneb8qwtr+xRqsuYkt2U7zXl99H97LEkbPt4zAfbPh6bwbaPx1DebJ8TN7yyB0auY8ziURRLxjxtN6N4yGVOu3t8Zk67ezDHkN3P28Uq7Haf0u4eUTrf7ide1FM8ooRtH48ovdk+5y19PPh0GVN66OkqpqweeLqMKT2W9F5TnvfZUD08dBlTviHis30Xx1KCEVPGvh59u/3zyynTyt6LJ/Ri9l48oReL9+IJvVi9F3/Si9S3WSvF8KUXm/fiCb3YvRd/tNwSK9L+fY5JC26fN9vnrMSEFt2UVzEluSmvYkr/SH23Kc/KMWnspryKKf1z/c2m/P44ffNAALZ9PMSAbR8PXmDbx8Mib7bPiRkm3WMoFzKmR1EsGfO0Ix7dQy5z2t3jM3Pand3udux+3qGh7pGfOe3uESUBu5932WH3iNK77XPWllf34NNlTOlxqneb8qQtr5v3dVNexZQeo3qzKb+N7qfgsSRs+3jMB9s+7PaBto/HUN5sn/M2vFLwwMiFjOlRFEvGPGs3IwUPucxpd4/PTGn36MEcQ3Y/bRcrRY/8zGl3jyidb/fzLtNL0SNK2PZht8977XPe0seDT5cxpYeeLmNKDzxdxpQeS3qvKU/8bPDw0FVMSR7x+ZkpxYq0f3t+NZFHZt5tn5MOPSbyYMtlTOlxmcuYkt2UbzblWedXyUM4lzGlh3DebMrvj+qRx2Ww7ePBFmz7eAQF2j7JwyJvts+Jp1eTx1AuZEyPolgy5mnbR8lDLnPand3uU9rdgzmG7H7ehmTyyM+cdveIkoDdT7tI6abr9nmzfc7a8koefLqKKdnjVO825VlbXuxRqsuY0mNUbzbl99F99lgStn3Y7QNtH4/NYNvHYyhvts+JG17sgZELGdOjKJaMedpuBnvIZUq7Z4/PzGl3D+YYsvt5u1jZIz9z2t0jSufb/cSLejK7faDt4xGlN9vnvKWPB58uY0oPPV3GlB54uowpPZb0XlOe99lQPDx0GVPqR3xK26xTQ/9sygWI0IASGhCrA9XIG1CqX4AyGlBBA9JfkdbWtg/X+BWooQHprw5qqR9A7V+BakAD0vfUPaznfW/LwPgFiNCAEhoQowGpe2r6uEySPl8mubtw477C5/Bp2ZbazrN9ezaGkP96eGlpmaaldZqWtsu0NIYYtqbSTlP7NE1tYZ6mxgu9qh8tzeFrS+mSLa07Nk3QLc153VcunI+Gb/+Im/ScPp7O95byNC19wzIpfLS0HrU0rV9SuXwEdNJu+HbL2Iut/Wvsp5U5mlnnaGabo5l9imb2MEcz4xzNpDmameZoJs/RzDlWQX2OVVCfYxXU51gF9SlWQRymWAVxmGIVxGGKVRCHKVZBHHiOZk6xCuIwxSqIwxSrIA5TrII4zLEKinOsguIcq6A4xyoozrEKijxHM+dYBcU5VkFxjlVQnGMVFOdYBdEcqyCaYxVEc6yCaI5VkH412vc0c45VEM2xCqI5VkE0xyqI5lgFpTlWQWmOVVCaYxWU5lgF6dd8e08z51gFpTlWQWmOVVCaYxWU5lgF8RyrIJ5jFcRzrIJ4jlWQfhWU9zRzjlUQY6+C6pYg+PnWlUR3duylzffs2OuVltak2NbiwfD6NteSGXvFcl5DM/aa5cSGYq9aTmwo9rrlxIZir1xObCjP0lDs1cuJDcVev5zYUOzFzokNnWVllGdZGZVZVkZllpVRmWVlVGZZGelfOvuuhs6yMiqzrIzKLCujMsvKqMyyMqqzrIzqLCujOsvKqM6yMtK/5PldDZ1lZVRnWRnVWVZGdZaVUZ1lZdRmWRm1WVZGbZaVUZtlZfSOC6Pf09BZVkbgN0af2NBZVkbgt0af2NBZVkbgN0ef2NBZVkbgt0ef2NBZVkbgN0if2NBZVkbgt0if2NBZVkbgN0mf2NBJVkYZ/DbpExs6ycoog98ofWJDJ1kZ5cCzNHSSlVEGv1n6xIZOsjLK4LdLn9jQWVZG4DdMn9jQWVZG4LdMn9jQWVZG4DdNn9jQWVZG4LdNn9jQWVZG4DdOn9jQWVZG4LdOn9jQWVZG4DdPn9jQWVZG4LdPn9jQWVZG4DdQn9jQWVZG4LdQn9jQWVZG4DdRn9jQWVZG4LdRn9jQWVZG4DdSn9jQWVZG4LdSn9jQWVZG4DdTn9jQWVZG4LdTn9jQWVZG4DdUn9jQWVZG4LdUn9jQWVZG4DdVn9jQWVZGs9yBnWe5AzvPcgd2nuUO7DzLHdh5ljuw8yx3YOdZ7sDOs9yBnWe5AzvPcgd2nuUO7DzLHdh5ljuw8yx3YOdZ7sDOs9yBnWe5AzvPcgd2nuUO7DzLHdh5ljuw8yx3YOdZ7sDOs9yBnWe5AzvPcgd2nuUO7DzLHdh5ljuw8yx3YOdZ7sDOs9yBnWe5AzvPcgd2nuUO7DzLHdh5ljuw8yx3YOdZ7sDOs9yBnWe5AzvPcgd2nuUO7DzLHdh5ljuw8yx3YOdZ7sDOs9yBnWe5AzvPcgd2nuUO7DLLHdhlljuwyyx3YJdZ7sAugWdp6CQrozLLHdhlljuwyyx3YJdZ7sAus9yBXWa5A7vMcgd2meUO7DLLHdhlljuwyyx3YJdZ7sAus9yBXWa5A7vMcgd2meUO7DLLHdhlljuwyyx3YJdZ7sAus9yBXWa5A7vMcgd2meUO7DLLHdhlljuwyyx3YJdZ7sAus9yBXWa5A7vMcgd2meUO7DLLHdhlljuwyyx3YJdZ7sAus9yBXWa5A7vMcgd2meUO7DLLHdhlljuwyyx3YJdZ7sAub7gDm7g/aOgCdMYKJoeySmRqB0Ax9PXpGCN99FDiOxHBESU4IoYjynBEBY6owhE1OKKORnTK5bznEj3w2aV+ELUDolvAMP55+haA4e3pznsPV/7zbKWPGSSuOISFk7BwGAsnK+NEIlr/NOXyFaigAVVtoLxZLJaYvwI1NKAOBvToltD3AUU0IG0fHWvfgG6fT1+BEhoQowFlNKCCBlTRgBoakLqn7nH70/1fgL4+neL2dIq1flro7i2LO2+N7flzaIXvoYymPQtQoBWIQk9fer9pzwJEZQNKxAe9n1P783AuH8/uR7VK3IZZ+2SmezNpjmamOZrJczQzz9HMMkcz6xzNbHM0s0/RzB7maOYcq6A+xyqoz7EK6nOsgvocq6A+xyqoz7EK6nOsgvoUq6AaplgF1TDFKqiGKVZBNUyxCqqB52jmFKugGqZYBdWAvQqqtJ4Pral+bubCjr20+Z4de71y2hneGrFXLCc2FHvNcmJDsVctJzYUe91yYkN5loZir11ObCj26uXbqTEaXpJE7CXJiQNslvULzbJ+oVnWLzTL+oVmWb/QLOsXwl6/fDs1kuElCWEvSU4cYLOsX2iW9UuaZf2SZlm/pFnWL2mW9UvCXr98OzUmw0uShL0kOXGAzbJ+SbOsX9Is6xeeZf3Cs6xfeJb1C2OvX76dGtnwkoRn2eXhWdYvPMv6hWdZv/As65c8y/olz7J+ydjrl2+nxmx4SZKxlyQnDrBZ1i95lvVLnmX9kmdZv+RZ1i9llvVLwV6/fDs1FsNLkjLLLo/63ZZva+gs65cyy/qlzLJ+KbOsX8os65eKvX75dmqshpckdZZdnjrL+kX9zte3NXSW9UudZf1SZ1m/1FnWLxV7/fLt1NgML0nAb+k9b4CB39N7YkNnWb+A39V7YkNnWb+A39d7YkNnWb+A39n7/dRoeEkCfrvueQMM/H7dExs6y/oF/I7dExvKszR0lvUL+E27JzbU8JUu4Bfofs8+yS5PA78X98SGTrJ+aeB3457Y0EnWLy3wLA2dZP3SwO/I/W5qbIYvvm3gF9+eOMBmWb/Mcktum+WW3DbLLbltllty2yy35DbwW3K/nRoNX3zbwC++PXGAzbJ+meWW3DbLLbltllty2yy35LZZbslt4Lfkfjs1Gr74toFffHviAJtl/TLLLbltllty2yy35LZZbslts9yS28Bvyf12ajR88W0Dv/j2xAE2y/plllty2yy35LZZbslts9yS22a5JbeB35L77dRo+OLbBn7x7YkDbJb1yyy35LZZbslts9yS22a5JbfNcktue8MtuSE/augCRGhACQ2Id4FKKStQZToAuo2KsI2Kkrenxz+/AsW8jU2KfPDwLRq9Ptxa+f7hmD8oPvqQqO8827mvFD1/Hsgc7t2SvVv2uqVAd0un7eHeSLFbqnfLXrc05G5JIfc/D6fDh2Pa3rib5/zAiLnem9qnaeqDO3Mv2dQ4T1MJuqnU17+cmPOLTU3zNJXnaSr0iu3cpkKvwhLXramZwsFfDrx+y1CM/a+mfn2aeetFzuljwRHLfcFRoNdh7+wY7JXYGzsGe932vo6p2Ku8N3YM9prwjR2DvYJ8Y8dgrzff2DHsHbPfMdhr2Td2jK98H3SMr3wfdIyvfB90zKwr3xzb2sRM5WvHtFlXvocdM+vK97BjZl35HnbMrCvfw45h75j9jpl15XvYMbOufDOnNRieuZS/OmZn1RPCtuoJHA6ePtrAbrOuqjNv3Zi5HnV63aDbp+MF7aken3W5/r4en/Y74Fc93svWwvDpzF27d2Kf9pvhzE6c9vviV50Y8/Z0zLl///ZH+jiwS/Txp6mmPezM27nCXD/OAlPa7ZBtxZK4f/Qe7R0cTjfDrA/HXj8/vJh+2i8oN/2034huenbTz2r6ab/zJzA9bV8cKcXwxfTzRjKmN73HU65r+rQlnqfE4fuHqW1fgtQqHTyctu6gFL9OJR4y8kH1xKAqW1en1r9/uOa1ffUzcbqPPw+g+fh73/jrwWOPPv7eOf48bOvj74nx19fkRWKqr4w/jx37+Hvn+PMAto+/348/btv4y59bSPdBxT6ofFCdPag86O6D6vRB5eF8H1SnDyrfKPBB9ftBVYjWh0uJ3z8cW05rd7TKX0ag7yr4CHzvCPR9BR+BwiOwbzmiFGJ7IQgSfRPCB6uZweo7Fj5YzQxW397wwSo7WCl8XBAcMr0yWH0vxAermcHKPlh9sC6Dta9/mW6Bn4OHvz2N2qPvsfigemJQnXUaK/p2jI+/d44/37nx8ffE+DvrNFb0fRsff+8cf75r4+Pv9+Pv++MQ5LsrPqhOH1S+C+KD6vRB5bsVPqhOH1S+q+CD6veD6sSzWMQ+An0EvnUE+r6Cj0DhEXjamRXyTQgfrGYGq+9Y+GA1M1h9e8MHq+xgPe+AFfleiA9WK4M1+R6LD9YFo9ftDtMQ6ktf7cn3WHxQnT6ofI/FB9XvB9Vp3yDJt2N8/L1z/LGPPx9/bxx/vhXj4++d4893V3z8/Xr8nRgp8Q0TH3/vHH++B3Lh8bedBLwNv4OHT6wi05PvVfigemJQnZU3yb794OPvnePPdyp8/L1z/Pmmho+/J8bfWXm77JsaPv7eOf7Yx5+Pv1+Pv+8T59h3KnxQnT6ofPvBB9Xpg8r3FHxQnT6ofKPAB9XvB9WJWbvsuwo+At86ArPvK/gIFB6Bp51syr4J4YPVzGD1HQsfrGYGq29v+GCVHaznHfDL7IPVB6uVwep7LD5Y74P1vCoy2fdYfFA9MajOOo2VfTvGx987x5/v3Pj4e2L8nXUaK/u+jY+/N46/4rs2Pv5+P/6+Pw5RfHfFB9Xpg8p3QXxQnT6ofLfCB9Xpg4p9UPmg+vWgOvEsVvGtAh+B7x2Bvq/gI1B4BJ52ZqX4JoQPVjOD1XcsfLCaGay+veGDVXawnnfAqvpeiA9WM4PV91h8sC4YJxb8qL7H4oPq9EHleyw+qH4/qE77Bqns48/H3xvHn2/G+Ph75/jzrRgff+8cf7674uPv1+PvxEiJb5j4+Hvn+PM9kJ+Nvy3oeuubYGT83QyzPhz7l+za5jsK05re4/PTmt6j6NOa3mPd1zU99W35mGL4Ynp2089qeo/wXtf0v6pTemKdyOZhWx9UTwyqs25GaR629fH3zvHnYVsff+8cfx629fH3xPg762ae7rFjH3/vHH8ewPbx9/vx9/3VGN1D4z6oTh9UHnT3QXX6oGIfVD6ozh5UvlHgg+r3g+rEe3m67yr4CHzvCPR9BR+BwiPwtNyF7psQPljNDFbfsfDBamSwxhB8f8NHq+xoPS2H5zZafTfER6ud0erbLD5a76P1tFKRt1Hl+yw+qp4YVSedyLoNQPYB6APwnQPQ9298AD4xAE86k3UbgL594wPwrQPQd298AP5+AH57LOI2qnybxUfV+aPK90N8VJ0+qqLvW/ioOn9U+f6Cj6rfj6rzzmXdhqBvGvgQfPMQ9B0GH4LCQ/C8EyyRfbT6aDUzWn3vwkerndHqGx0+WmVH64nnraLvivhotTNafbfFR+uCcV6Vv9uo8t0WH1Wnjyry3RYfVb8fVed9iJBvzPgAfOsA9G0ZH4BvHYC+KeMD8K0DkH0A+gD87QA8MWBCvnXiA/CtA9B3Qy48AH9TwvS8AjO3UeW7Fj6qnhhVp6VTkm9E+AB86wD0PQsfgO8cgMm3N3wAPjEAT8vnTb694QPwrQPQtzd8AP5+AB6k0yXfs/BRdf6oYh9VPqpOH1W+u+Cj6vxR5VsGPqp+P6rOzOZNvr/gQ/DNQ9B3GHwICg/B8w46Jd+O8NFqZrSy7134aLUzWn2jw0er7Gg98cAf+66Ij1Y7o9V3W3y03kfrieVmmH1U+aj6/ag67XAW+8aMD8C3DkDfw/EB+MQAPO1wFvsOjg/Atw5A37/xAfj7AXhwNoJ9n8VH1emjKvt+iI+q80eV71v4qDp/VPn+go+q34+qM49mZd808CH45iHIPgR9CMoOwfNOsGTfjvDRame0+t6Fj1Y7o9U3Ony0yo7WE89bZd8V8dFqZ7T6bouP1gXjzMIgxXdbfFSdP6p8t8VH1e9H1XkfIsU3ZnwAvnUA+raMD8C3DkD2AegD8J0D0PdZfAD+egCeGDApvnXiA/CtA9B3Q340AEvbxlQN/fMAvHejh+lP6UaPH5/RjdUDpj/qxhp565BUv3ajRwhP6UaPc53SjR6t+Vk3tnW9E1vc6Ub2bjyjG/3L+WfdWOpHN7av3ejff6d0o3/F/Kgbe4hbE3v82o3+FXNKN/pXzBnd2Pwr5pRu9K+Yn3QjfRSHps/FoXdDjNxXjhw+BRhT23m2b8/GEPJfD9/t459H2Pbx7y5s+7Db5532ieGj7wLtGcg/FcEN5B+h4Abyz9s3T0Ef9slhxz7+3Qxjn7r3/vgH+en2yXnNMCqcjxxc/ziR0XP6eDrf7dP9Sx/bPh5C+Jl9wod96pF90rq/kstHA9PugcftluHYPh13/HOCp3v8ANg4HjwANg67cXCN41EDYON4xADYOB4tADaOhwqAjeNxAljj3DZ/3Di4xvEIAbBxPEIAbByPEAAbh904uMbxCAGwcTxCAGwcjxAAG8cjBMDG8QgBrnGiRwiAjeMRAmDjeIQA2DgeIQA2DrtxcI3jEQJg43iEANg4HiEANo5HCICN4xECXOOQRwiAjeMRAmDjeIQA2DgeIQA2DrtxcI3jEQJg43iEANg4HiEANo5HCICN4xECXOMkjxAAG8cjBMDG8QgBsHE8QgBsHHbj4BrHIwTAxvEIAbBxPEIAbByPEAAbxyMEuMZhjxAAG8cjBMDG8QgBsHE8QgBsHHbj4BrHIwTAxvEIAbBxPEIAbByPEAAbxyMEuMbJHiEANo5HCICN4xGC041Tt6Ihn6vK34xz73H/7NfucfYeP7vHW1r/cmvxwAF9X+smZv+ahzaPf89Dm8e/6KHN49/00Obxr3pk8xT/roc2j3/ZQ5vHv+2hzeOBAGjzsJsH2TweNYA2j0cNoM3jUQNo83jUANo8HjVANk/1qAG0eTxqAG0ejxpAm8ejBtDmYTcPsnk8agBtHo8aQJvHowbQ5vGoAbR5PGqAbJ7mUQNo83jUANo8HjWANo9HDaDNw24eZPN41ADaPB41gDaPRw2gzeNRA2jzeNQA2TzdowbQ5vGoAbR5PGoAbR6PGkCbh908yObxqAG0eTxqAG0ejxpAm8ejBtDm8agBsHkoeNQA2jweNYA2j0cNoM3jUQNo87CbB9k8HjWANo9HDaDN41EDaPN41ADaPB41QDZP9KgBtHk8agBtHo8aQJvHowbQ5mE3D7J5PGoAbR6PGkCbx6MG0ObxqAG0eTxqgGwe8qgBtHk8agBtHo8aQJvHowbQ5mE3D7J5PGoAbR6PGkCbx6MG0ObxqAG0eTxqgGye5FEDaPN41ADaPB41gDaPRw2gzcNuHmTzeNQA2jweNYA2j0cNoM3jUQNo83jUANk87FEDaPN41ADaPB41gDaPRw2gzcNuHmTzeNQA2jweNYA2j0cNoM3jUQNo83jUANk82aMG0ObxqAG0eTxqAG0ejxpAm4fdPMjm8agBtHk8agBtHo8aQJvHowbQ5vGoAbJ5ikcNoM3jUQNo83jUANo8HjWANg+7eZDN41EDaPN41ADaPB41gDaPRw2gzeNRA2TzVI8aQJvHowbQ5vGoAbR5PGoAbR528yCbx6MG0ObxqAG0eTxqAG0ejxpAm8ejBsjmaR41gDaPRw2gzeNRA2jzeNQA2jzs5kE2j0cNoM3jUQNo83jUANo8HjWANo9HDZDN0z1qAG0ejxpAm8ejBtDm8agBtHnYzYNsHo8aQJvHowbQ5vGoAbR5PGoAbR6PGgCbJwWPGkCbx6MG0ObxqAG0eTxqAG0edvMgm8ejBtDm8agBtHk8agBtHo8aQJvHowbI5okeNYA2j0cNoM3jUQNo83jUANo87OZBNo9HDaDN41EDaPN41ADaPB41gDaPRw2QzUMeNYA2j0cNoM3jUQNo83jUANo87OZBNo9HDaDN41EDaPN41ADaPB41gDaPRw2QzZM8agBtHo8aQJvHowbQ5vGoAbR52M2DbB6PGkCbx6MG0ObxqAG0eTxqAG0ejxogm4c9agBtHo8aQJvHowbQ5vGoAbR52M2DbB6PGkCbx6MG0ObxqAG0eTxqAG0ejxogmyd71ADaPB41gDaPRw2gzeNRA2jzsJsH2TweNYA2j0cNfmQe4v7APPdu9K/7U7rRv8JP6cZpv5ZLXJ/O5dOfHt249EyZ9kP1sGem/UY87JlpP88Oe2baL6PCae2ZGvOBu063P7KCxE8Ltv2nW6X1b7daPz2d/yzZCnuvv6HXp/2Oke112r5kiHd6fdrPk7f2+rRfM2/t9Wk/ft7a6/N+K72x1+u832GCvd54bWPrqe/0+rzfeO/s9Xm/H9/Z6/5t+o5eZ+/1N/S6f5sK93qjnV73b9N39Lp/m76j1/3b9B297t+mb+j15t+mP+v1vn7jJ/qX3aGvT/cSVxv18qlDiHf/dl37mmP96Or9R/vWHy2m7x++2Xjt6VsX5IOHQ9kejn//5fs48a9pHyc/GSf+/W9onDBtf5gpHYwTugU61/64fZq9OE48YuHj5CfjhH2c+Dj5wTjxqJCPk5+ME49j6Y6Te69PG8eKbW1ippL+6sd7z0wbazrsmWnjQUc906eN2Rz2zLRRisOemfa7/LBnpv0SPewZ9p550DOzfm2U2NZVZKHEOz0z6/r6uGdmXQMf98ysa+BC2+5cSXGvZ2ZdAx/1DIdZ18DHPTPrGrgk+uiZ/nfP7AWK4paFfPs3/Z0FtbMmCGm9WyCH8pG0nNqfbp91gf3mbp919f7mbmfv9nd0+7TfHbLdHuP2vRc5fe72HfC+rmZT+LAQ/zHQtJ8/Vgw07VeYFQNN+zFoxUDTfpMaMVCc9tPYioH8Cx3cQP4tD24g/+oHNxC7gbAN5JGEHxqIyoeBuL8YwIkeH3hLt/tX/1u63b/l39Lt/oUu0u2nTb7kX+jgBvIvdHAD+Rc6uIH8Cx3cQOwGwjaQf6GDG8i/5cEN5F/94Aby+AC4gTyS8NVAS88k/4R/1DP+7fyoZ/yj9VHP+Nfio57h6/TMrVHbX6Z21DNhq8dUQm5/TXn3nrnQ99HJPXOhD5OTe+ZCXwQn94zfQ7Kf683J7yF50DPs95A86hm/h+RRz/g9JI96xu8hedQz7D3zoGdmXQO3mNai0C1+OgKzrWd41jXwcc/MugZuMeaPnqk7PXOhNfDJPXOhNfC5PZN9Dfxgbsq+Bn7UM74GftQzvgZ+1DPsPfOgZ6a9+fuwZ6a96/qwZ/w+6kc943HgRz3jceAHPVN8DfyoZ3wN/KhnfA38qGd8DfyoZ9h75kHPTBsHpo2jpRi+xmfKtHHgw56ZNg582DPTxoEPe2baOPBRz9QLrYFP7pkLrYF/uXfQaOsZ4r96ZufpslU5u/3zY0XAu9BbPkDi1D49e+/xC62tjfT4hdbsRnqcvceVe3zesybv6vF5z7DI9XhrG3QIX3p83rMx7+rxec/cvKvH5z3L86Yev1Kt+7f0+L0X2XvxhF70VdwZvegrszN60SPQD2JmV6oKfnLPeAT6Qc9cqSr4yT0zbQT6sGemjRQf9sy0a/bDnmHvmQc946cwHvWMn8J41DO+Bn7UM74GftQzvgbe75k8bVXwoxOCedqq4Mc94yeRH/WMn0R+1DPsPfOgZzwb71HPXGgNTHnd76KUjmZtjnF9muMn6Jj7n5650Br45J650Br45J650Br43J65UvnfX/VMjqVtHjjUnZ650Br45J650Br45J650Br45J7hSXumlg26lsQ7PXOhNfDJPTPrGrjmtt7KVmv4e9beiXOddoY4X6nyqZEen3XN/r4en/Vb4G09fqUCpkZ6fNZvF8ke/+7Udr5SiVEjPT7rt9b7epy9x5V73FeHr/X4vRd9xXdCL16pht0be9FXZmf04rSrrZJpi5n1+DVmdqXaeCf3DHvPPOiZeSPQRz0zbQT6sGemjRQf9sy0a/bDnpl2HX7UM1eqjXdyz0y7Xj7sGV8DP+oZXwM/6hn2nnnQM74GftQzvgZ+1DOzroEPT3tdqTbeyT0z6xr4sGeuVBvv5J7xk8iPesZPIj/qmQutgWtJ619uhQ96Jm6T9ud8hz/7Bleqi3dir1xo7Xtir1xo3Xtir1xozXtir/h699E85OvdBz0DXgfvFhHZeqYf/eVzc5/B6+C9s2ew17vv7Bns9e47e4a9Zx70DPa69509g732fWfPYK9/BXuG07ae4VL+6pmvT3MIaxM5cDh4unNf29hvkYvtaeK117HX15K9vvXjbbvhqNfrx4Vn7aM72nNdjr1wR+nyvt1IF0Pjz32+9CJ4oT8rvTjtB8GvenHcaLg2Mef+vQOItzauDxN9/GmqaQ/7tqW3Yt/M8fF02v2qbh/Jif2j94j2Hr4ZZn049vr54bvtp/3kcduDF0p020vant3209p+2g/zCWxP24dH+nwr82b7aUMPbnvwgppu+1dsn2jrvcTh+4dv+7FrC6lVOng4bd1BKe7MJh488lH1xKgqW1en1r9/uG47w/UzcfozAD2U5gPwnQOweRTSB+BbB6AHcH0APjEA+3plCDHVlwagR5F9AL51AHoo2wfg7wcgb5cmUf7cwj+ftuBV7n1U2RxVHn73UXX+qPLAvo+q80eVbxn4qPr9qCq0ZnNRKfH7h2PLa55YbJW/DkHfX/Ah+OYh6DsMPgSFh2Dv218Osb0SC+m+HeGj1c5o9b0LH612RqtvdPholR2tFGizeMj00mj1XREfrXZGK/to9dG6jNa+/mXq4WC+Pjqe2n23xUfVE6PqtMNZ3TdmfAC+dQD6Ho4PwCcG4GmHs7rv4PgAfOsA9P0bH4C/H4Dfn40owfdZfFSdP6p8P8RH1fmjyvctfFSdP6p8f8FH1e9H1YlHs0pgH4I+BN87BH2HwYeg8BA87QRLCb4d4aPVzmj1vQsfrXZGq290+GiVHa3nnbcqwXdFfLSaGa3Rd1t8tC4YvW63nIZQX/t2j77b4qPq/FHluy0+qn4/qs77EIm+MeMD8K0DkH0A+gB85wD0TRkfgG8dgL7P4gPw1wPwzICJb534AHzrAPTdkAsPwO1k4G38HTx8ZrmZEn3XwkfVE6PqrHTKQr4R4QPwrQPQ9yx8AL51APr2hg/AJwbgWfm8hXx7wwfgWwcg+wD0AfjrAXiQTke+Z+Gj6vxR5RsRPqrOH1W+u+Cj6vxR5VsGPqp+P6rOzOYl31/wIfjeIZh8h8GHoPAQPO+gU/LtCB+tdkar7134aLUzWn2jw0er7Gg98cBfYh+tPlrNjFbfbfHReh+t55WbKcl3W3xUPTGqTjuclXxjxgfgWweg7+H4AHxiAJ52OCv5Do4PwHcOQPb9Gx+Avx+AB2cj2PdZfFSdP6p8P8RH1fmjyvctfFSdP6rYR5WPql+PqjOPZrFvGvgQfPMQ9B0GH4LCQ/C8Eyzs2xE+Wu2MVt+78NFqZ7T6RoePVtnReuJ5q+y7Ij5a7YxW323x0bpgnFkYJPtui4+q80eV77b4qPr9qDrvQySzD0AfgO8cgL4t4wPwrQPQN2V8AL51APo+iw/AXw/AMwMmvnXiA/CtA9B3Q342ALfo661vgpEBeDPM+nDsX7Nui+8tzGt7j9TPa3uPp89re496X9f21Lc1ZIrhq+3ZbT+t7T3We13b/6qu6ZllJYsHcH1UPTGqTrs2pXgA1wfgWwegB3B9AL51AHoA1wfgEwPwtHt7qkeRfQC+dQB6KNsH4O8H4MG1GdWD5D6qzh9VHn73UXX+qGIfVT6qTh9VvmXgo+r3o+rMW3uq7y/4EHzzEPQdBh+CwkPwvISG6tsRPlrtjFbfu/DRama0Nt/o8NEqO1pPTOxpvivio9XOaPXdFh+t99F6YlnJ5rstPqqeGFWnHc5q7APQB+A7B6Dv4fgAfGIAnnY4q/kOjg/Atw5A37/xAfj7AXhwNqL5PouPqvNHle+H+Kg6fVR137fwUXX+qPL9BR9Vvx9VZx7N6r5p4EPwzUPQdxh8CAoPwfNOsHT20eqj1cxo9b0LH612RqtvdPholR2tJ5636r4r4qPVzmj13RYfrQvGmQUAu++2+Kg6e1TV4LstPqp+P6pO+xCpwTdmfAC+dQD6towPwLcOQN+U8QH41gHIPgB9AP52AJ4XMKnBt058AL51APpuyIUH4G/qmp5YbqYG37XwUfXEqDornbIG34jwAfjWAeh7Fj4A3zkAo29v+AB8YgCelc9bo29v+AB86wD07Q0fgL8fgN+n09XoexY+qs4fVeyjykfV6aPKdxd8VJ0/qnzLwEfV70fVidm8Nfr+gg/BNw9B32HwISg8BM876BR9O8JHq5nRSr534aPVzmj1jQ4frbKj9cQDf+S7Ij5a7YxW323x0XofreeVm6nEPqp8VP1+VJ12OIt8Y8YH4FsHoO/h+AB8YgCedjiLfAfHB+BbB6Dv3/gA/P0APDgbQb7P4qPq9FGVfD/ER9X5o8r3LXxUnT+qfH/BR9XvR9WZR7OSbxr4EHzzEGQfgj4EZYfgeSdYkm9H+Gi1M1p978JHq53R6hsdPlplR+uJ562S74r4aLUzWn23xUfrgnFmYRD23RYfVeePKt9t8VH1+1F13ocI+8aMD8C3DkDflvEB+NYByD4AfQC+cwD6PosPwF8PwBMDJuxbJz4A3zoAfTfkRwOwtG1M1dA/D8B7N3qY/pRu9PjxGd2YPWD6o26skbcOSfVrN3qE8JRu9DjXKd3o0ZqfdWNb1zuxxZ1uZO/GM7rRv5x/1o2lfnRj+9qN/v13Sjf6V8yPurGHuDWxx6/d6F8xp3Sjf8Wc0Y3Fv2JO6Ub/ivlJN9JHcWj6XBx6N8TIfeXI4VOAMbWdZ/v2bAwh//Xw3T7+eYRtH//uwrYPu33eaZ8YPvou0J6B/FMR3ED+EQpuIP+8ffMU9GGfHHbs49/NMPape++Pf5Cfbp+c1wyjwvnIwfWPExk9p4+n890+1b/0se3jIYSf2Sd82Kce2Set+yu5fDQw7R543G4Zju3Tccc/J3iqxw+AjePBA2DjsBsH1zgeNQA2jkcMgI3j0QJg43ioANg4HifANU7zIAGwcTxCAGwcjxAAG8cjBMDGYTcOrnE8QgBsHI8QABvHIwTAxvEIAbBxPEKAa5zuEQJg43iEANg4HiEANo5HCICNw24cXON4hADYOB4hADaORwiAjeMRAmDjeIQA1jgteIQA2DgeIQA2jkcIgI3jEQJg47AbB9c4HiEANo5HCICN4xECYON4hADYOB4hwDVO9AgBsHE8QgBsHI8QABvHIwTAxmE3Dq5xPEIAbByPEAAbxyMEwMbxCAGwcTxCgGsc8ggBsHE8QgBsHI8QABvHIwTAxmE3Dq5xPEIAbByPEAAbxyMEwMbxCAGwcTxCgGuc5BECYON4hADYOB4hON04dSsa8rmq/M049x73z37tHmfv8bN7/Dbl/nm2tXjggL6vddOSf81Dm8e/56HN41/00Obxb3po8/hXPbJ52L/roc3jX/bQ5vFve2jzeCAA2jzs5kE2j0cNoM3jUQNo83jUANo8HjWANo9HDZDNkz1qAG0ejxpAm8ejBtDm8agBtHnYzYNsHo8aQJvHowbQ5vGoAbR5PGoAbR6PGiCbp3jUANo8HjWANo9HDaDN41EDaPOwmwfZPB41gDaPRw2gzeNRA2jzeNQA2jweNUA2T/WoAbR5PGoAbR6PGkCbx6MG0OZhNw+yeTxqAG0ejxpAm8ejBtDm8agBtHk8aoBsnuZRA2jzeNQA2jweNYA2j0cNoM3Dbh5k83jUANo8HjWANo9HDaDN41EDaPN41ADZPN2jBtDm8agBtHk8agBtHo8aQJuH3TzI5vGoAbR5PGoAbR6PGkCbx6MG0ObxqAGweXrwqAG0eTxqAG0ejxpAm8ejBtDmYTcPsnk8agBtHo8aQJvHowbQ5vGoAbR5PGqAbJ7oUQNo83jUANo8HjWANo9HDaDNw24eZPN41ADaPB41gDaPRw2gzeNRA2jzeNQA2TzkUQNo83jUANo8HjWANo9HDaDNw24eZPN41ADaPB41gDaPRw2gzeNRA2jzeNQA2TzJowbQ5vGoAbR5PGoAbR6PGkCbh908yObxqAG0eTxqAG0ejxpAm8ejBtDm8agBsnnYowbQ5vGoAbR5PGoAbR6PGkCbh908yObxqAG0eTxqAG0ejxpAm8ejBtDm8agBsnmyRw2gzeNRA2jzeNQA2jweNYA2D7t5kM3jUQNo83jUANo8HjWANo9HDaDN41EDZPMUjxpAm8ejBtDm8agBtHk8agBtHnbzIJvHowbQ5vGoAbR5PGoAbR6PGkCbx6MGyOapHjWANo9HDaDN41EDaPN41ADaPOzmQTaPRw2gzeNRA2jzeNQA2jweNYA2j0cNkM3TPGoAbR6PGkCbx6MG0ObxqAG0edjNg2wejxpAm8ejBtDm8agBtHk8agBtHo8aIJune9QA2jweNYA2j0cNoM3jUQNo87CbB9k8HjWANo9HDaDN41EDaPN41ADaPB41wDUPheBRA2jzeNQA2jweNYA2j0cNoM3Dbh5k83jUANo8HjWANo9HDaDN41EDaPN41ADZPNGjBtDm8agBtHk8agBtHo8aQJuH3TzI5vGoAbR5PGoAbR6PGkCbx6MG0ObxqAGyecijBtDm8agBtHk8agBtHo8aQJuH3TzI5vGoAbR5PGoAbR6PGkCbx6MG0ObxqAGyeZJHDaDN41EDaPN41ADaPB41gDYPu3mQzeNRA2jzeNTgR+Yh7g/Mc+/Gab/uS1yfzoXCX91475lpP6wPe2bab9qjnuFpPycPe2baL7nCae2ZGvOBu063P7KCxE9T5P7TrdL6t1utn57OfyZJnvYD7a29Pu13l2yv07Z2JN7pdfZef0OvT/uV9NZen/bj5629Pu+30jt7fd7vMMFeb7y2sfXUd3p93m+8N/Z6nvf78Z297t+m7+h1/zZ9R6/7t6lwrzfa6XX2Xn9Dr/u36Tt63b9N39Hr/m36jl73b9Of9Xpfv/ET/cvu0Nene4mrjXr51CHEu3+7rn3NsX509f6jfe3p1GL6/uGbjdeevnVBPng4lO3h+Pdfvo8T/5o2NE6Ytj/MlA7GCd0CWGt/3Jbcr42T4t//Pk5+Mk48YuHj5CfjxGMsPk5+Mk48KqQ7Tu69zrP2emxrEzOV9Fc/3ntm2sjNYc9MG1057JlpIyCHPTNtlOKwZ6b9Lj/qmTrtl+hhz0z77XXYM7N+bZTY1lVkocQ7PTPr+vq4Z9h75kHPzLoGLrTtupQU93pm1jXwcc/MugY+7plZ18Al0UfP9L97Zi9QFLfs0tu/6e/slp01QUgreL59m350YPvT7bMusN/b7W3W1fubu33WT4M3d/u03x2y3R7j9r0XOX3u9h3wvq5mU/iwEP8x0LSfP1YMxG4gbANN+zFoxUDTfpNaMdC0n8ZWDORf6OAG8m95bAN1/+oHN5DHB8AN5JGEHxqIyoeBuL8YwOkeH3hLt7N3+zu63b/l39Lt/oUu0u3nTb7+hQ5uIP9CBzeQf6FDG+j2WeMGwjaQf6GDG8i/0MEN5N/y4AZiNxC2gTw+AG4gjyR8NdC9Z/wT/lHP+Lfzo57xj9YHPRP9a/FRz1zoM+3WqO0vUzvqmbDV2Skht7+mvHvPXOj76OSeudCHyck9w94zD3rG7yHZz/W+raW9Zx70jN9D8qhn/B6SRz3j95A86Bnye0ge9YzfQ/KoZ2ZdA7e41UxusdSv6xmadQ183DPsPfOgZ3wN/MjP+Br4Uc/4GvhRz/ga+FHP+Br4Qc8kXwM/6hlfAz/qmWlv/j7smWnvuj7sGfaeedAzvgZ+1DO+Bn7UM74GftQzvgZ+1DO+Bn7QM3yhNfDv4jO0cbQUw9f4DM96FuK4Z6aNAx/2zLRx4MOeYe+ZBz1zoTXwyT1zoTXwL/cOGm09Q/xXz+w8XbaKVbd/fqwIeA+at7PdiVP79Oy9xy+0tjbS4xdasxvp8Qt9C9jo8TztN8bbenzabxfBHm9tgw7hS4/PezbmXT0+75mbd/U4e48r97ivDl/r8Xsv+orvhF4svoo7oxd9ZXZGL3oE+kHM7EoVx0/uGfaeedAzHoF+1DPTRqAPe2baSPFhz0y7Zj/smWnX4Uc9c6Wq4Cf3jJ/CeNQzvgZ+1DO+Bn7UM+w986Bn/CTygxOC01YFP+4ZP4n8qGf8JPKjnvGTyA96Ztra2sc9c6E1MOV1v4tSOpq1Ocb1aY6foG87On965kJr4JN75kJr4JN7hr1nHvTMhdbAv+qZfAvabR441J2eudAa+OSeudAa+OSeudAa+OSeudAa+Fc9U8sGXUvirz1zpUqzJ/fMrGvgmltfe6aGv2ftnTjXeWeIr1Sz1UiPz7pmf1+Ps/e4co/P+o3xvh6f9dtFsse/PbV9pYKrRnp81m+t9/X4tN9wb+pxulIBwLf0+L0X2XvxhF70VdwZvegrszN6cdrVVsm0xcx6/BIzoyvVxju5Z+aNQB/0zJVq453cM9NGoA97ZtpI8WHPTLtmP+wZ9p550DPTrq0Pe2ba9fJhz/ga+FHP+Br4Uc/4GvhBz1ypNt7JPeNr4Ec9M+sa+Oi0F12pNt7JPcPeMw96xk8iP+oZP4n8qGf8JPKjnrnQGri1Leu3p3jQM62W+ufp1lLZnu5726+xpbUbY8sfaVi3j6s/3XihBfMbu/FKVffe2Y0XWoq/sxsvtG7/VTfGTmmDzu3rrHGlen4n9wx7zzzomQut20/umQut20/umQut20/umVnX7cc9M+tS/LBnrlTP7+SemXXBfNwzvgZ+1DO+Bn7UM+zRtv1o25Xq+Z3cMx67ftQzHrt+1DN+i8ajnpn1/MZhz1yp3tzJPTPr+Y3jnvHzG496xs9vPOoZ9p550DO+nnnUM76eedQzvp550DNXqrx2cs/4euZRz/h65lHPqK9naIuljX3A7x+OgdaDxjHwR5jutrW693TcuibG+unp+KetPFFb80RtLRO1tU7U1jZRW/uV2lo36tj6l7bq1/d6Y1vjRG2lidp6qXXTQVt5oraqr5tS2tqaykFbU9tO+6Ye4/cP57Q+m/vH3423/ry3tFympaWu30+l005L6zQtbdO0tM/SUv1KUG9raZympTRNS9M0LeVpWnqdNdJRS6+zRqq8BqRriTstvc4a6ail11kjHbX0Omukg5b266yRjlp6nTXSUUuvs0Y6aul11khHLeVpWnqdNdJRS6+zRmpx/cMthZ2WXmeNdNTS66yRjlp6nTXS9y1N4TprpKOWXmeNdNTS66yRjlp6nTXSUUt5mpZeZ4101NILrZHautvaw15LL7RGOmjphdZIBy290Brp+5bGC62RDlp6oTXSQUsvtEY6aOmF1kgHLeVpWnqhNdJBS7HXSL2kraXtoKUxfGAE+pT9UXYf/s35tbrd4FhLOvjD3x85ThF7qXbBDsdeMV6ww7EXrhY7/NvTs4mw188X7HDsZfwFOxz7a8Jih8e+dXgPXzsc+6MGpcPr2uHtUwXhpyZN/Toss3c49ifeBTvcvzTP7vCDSdO/NJU73L80lTvcvzTP7vDvl4XJvzR/tA4vW4fXz3/43of+8fh6H/r34A/6sNH6lxvX1xZvyb8HlTucvcN1O9y/B8/u8O8Xb8m/B5U73L8HlTvcvwfP7vCDzxP/Hvzd0pr7l6U1+yfe633on3g/efHL+nBrLy7e2L8HlTvcvweVO5y9w0/u8O8Xb+zfg8od7t+Dyh3u34Nnd/j3nyfs34O/W1q3naW1f+K93If5SqvlumEUOjj01ktc8yZ6+cRMHPY4Nu/J8ePFT/uP9pUitZi+fzjmrUhFzDUfPBzK9nD8+y/fTXmldfjkpmQ35VVMeaVvh8lNeaWvkslNeaXvnclNeaUvqclNeaUPurlNWa60dTi5Ka+0gzm5KT3acxlTerTnMqZkN+VVTOnRnsuY0qM955qSafvDfGvr9w9Tq+seF7WeXjSlR3suY0qP9nwx5b1jwGMnHLeO6f2gYzjmzY1/6hjqYY5BXsGDJ27LX9gSPHritvyFLcHDJ27LX9gSOn7CYbvOnj8f8bo9fKdn0/TQX8mH9Bcq253XP1zK1+Kb6Upluw9aeqGy3ZvfKzXttPTs74RKR/Db2xQ/zxyTfLCeXjzc+/v7/o7e36r9Td7fqv2dvL9V+5u9v1X7O3t/q/Z38f5W7e/9b6r60d8tHvV3T3lNLuz86Uq8znsP17z1YW3p+4dnN057p3F6+fzwHaiDAfWABhTRgEgZKIZY1sBvDBT694+XLYm5xo9HI/U/+Mk2Pqvj5y20dPv3p9nPHexXB9vze83T8tf3teAhVTykpo5UwkdKfPl0Dc6G1NGQOAQ8pIiHRHhICQ9pfyZr2w3usXM+/jDbdnl7/rTLm/9oZAWNff/a+6pBIfGBRu5hXSLkTuH7rqWcwjq93f6dyteurXhIu/6VwrbaoVjC0QDMaavvmfOnhUjaXS7w+vBtj+LzSmr3T3Pnjz+d/lqK3Pm7Mv9tkRM/1jDxVf79utO/5f+or1o+O4D0RyOeoVH6txp0gkaJ64vQG8Xv7UC3nUXe/nbuXx3ZflFkUaSy7eDf/l3iwZKct1tnE38qlhZ3l9m1rq2t7eM1jlv/80yNzTM1tszU2DpTY9tMje0TNZbCTI2NMzWWwBubPzJBPq/THjV2/Tr4nONGZQ8klrrdLFnpY5V8g3qiG9HXZka6kb0bz+hG9PWkkW5EX6ka6Ub0NbCRbkRfXRvpRvR1u41uTOhfBEa6Ef1bw0g3zvsVUz+u6qifruoY3Xjvmnm/TA67hr1rHnXNvF8Qh10z71fBYdfMu9I/7Jp5V++HXTPvivyoa3jeVfZh18y7cm5hOyjUqOx0zbyr4cOumXc1fNg17F3zqGvmXQ0fds28q+HDrpl3NXzYNfOuhg+7Zt7V8FHX5HlXw4ddg74aLty2rvmUgrXfNYk/+jH+1TX3xqKvb09tLPqK9dTG8kyNRV9VntpY9HXiqY1FX/md2lj0tdypjUVfnZ3Z2IK+3jq1sW9YQW2ZVxRbO0h4HzeyrUmU43af9vnxewsIvgX1owWd8tcWJPQW9LSlH3KIOzZg8BZw2MqYj/zN+rUFGb0FFDYUphq+tqDAt6BtCbK3nXb62oKK3oK+JXRTDpy+tqCBtyCHLceUcqw7b7L+TN+3vI7bv/krUg14SPqzZu/bEuHmCQ6WCJ8bED7d+Bvrn2m/kukGpPDPB4f9Y8oflvuclr79rjz5u/rk79qTv+vP/e7BCdXj38Unf7c/kmiL3BF9cvXjd1+t/XFRUan94NnYP90u0T+uWbiNmJUowRExHFGGIypwRBWOqMERdTSiB2eH3kkU4YjgfDbD+WyG89kM57MZzmcznM9mOJ/NcD47w/nsDOezM5zPznA+O8P57AznszOcz85wPrsov/15u/kxf7rJkWpeeQiMR3lUf1yMl1vb4ylgPBWMp4HxdCyeKrr++KMRFTRO8BN1u461Eu9pJAUNVtDIChpFQaMqaDQFjRN8Qt1uIf/7Str9VQB9rAJS3VkFtABHFOGICI4owRExHFHWJsofd3yXvRV3K3BEFY6owRF1NKIe4IgiHJG6z/70vd32/FFPcEQMR5ThiAocUYUjanBE/Y1Eu9G2GAIeUsRDOsFtN9qqP3w6A/vbZ1eghAbEaEAZDaigAVU0oIYG1MGAYkADimhAaJ46onnqiOapI5qnjmieOqJ56ojmqSOapyY0T01onprQPDWheWpC89SE5qlJ2Q8dHc6I1MGAkvJbdrTdH1NCA2I0oIwGVNCARNdDq0hTEMkE5i9yQgNiNKCMBlTQgJQ/V3Jf/3AJeReooQF1MKAS0IAiGpC2p+5xAyq7QAkNiNGAMhpQQQOqaEANbKlZOhhQDWhAEQ0I7ZO3on3yVkYDQvvkrWifvLWiAaF56ormqRuap25onrqheeqG5qkbmqduaJ66oXnqhuapG5qnbmieuqN56o7mqTuap+5onrqjeeqO5qk7mqfuaJ66o3nqDuapKYB5agpgnpoCmKemAOapKYB5agpgnpoCmKemoH1pxcEWJ8WABgR2bQ5FsHtzKCY0IFYGOtjipJjRgAoaUEUDamhA2p76YEeRKKABRTQgQgNKaECMBgR2CRwR2C1wRGDXwBGB3QNHBHYRHKWABhTRgAgNKKEBMRoQmqdOaJ46oXnqhOapE5qnZjRPzWiemtE8NaN5akbz1IzmqRnNUzOap2Y0T81onjqjeeqM5qkzmqfOaJ46o3nqjOapM5qnzmieOiN56tjSg1KUdauqWWv6JNG2n9Xnftae+1l/6mf7gZTjn8XnfkbP/WzXzbXIf37WaP9n/NzP8nM/K8/9rD73s/bcz/pTP9v/iGttuzix0+7P4nM/o+d+lp77GT/3s/zcz8pzP9sdJT2ssf8ew+7P2nM/60/9bH8Befyz+NzP6Lmfped+tjtKOq0vTk+7L87+8uP4Z+W5n9Xnftae+1l/6mf76ePHP4sHP+Ndu+2nYh//LD33s/1Rsl0w28vu272ffHz8s/Lcz+pzP2vP/aw/9bP91NXjn+2PkrYWKY8ht79+92+/eXgVIQ2RpCHCGiJZQ6RoiFQNkaYh0hVE9pMazxbReOObxhvfNN74pvHGN403vmm88U3jjW8ab3zTeOO7xhvfNd74rvHGd403vmu88f319+TbM9CLRpPXeFBQ4nciR/HEByUizhZJGiKsIZI1RH47nWw/rE/+kJLCeCbWEMkaIkVDpGqInODIvjtbfxfpCiIpaIhEDRHSEDnhjf/uuPddhDVEsoZI0RCpGiJNQ6QrTJMcNEQ0FmGssQhjjUUYayzCWGMRxkVDpGqINA0RjTc+a7zxWeONzxpvfNZ447PGG5813vis8cZnjTc+a7zxWeONLxpvfNF444vGG1803vii8cYXjTe+aLzxReONLxpvfNF446vGG1813viq8cZXjTe+arzxVeONrxpvfBV/4/s/dyVui7H1rPFtNfNxfRHRjkTLq0Rr8ftHY2xl/bv06VgmpRWnYeF0LJz9a5feyBPBeAiMJ4HxMBhPBuMpYDxg3jmCuecI5p8JzD8TmH8mMP9MYP6ZwPwzgflnEvTPq0SVl3jdi37K7Ujh5V7tWDwpgPFEMB4C40lgPAzGk8F4ChhPBeMB888JzD8zmH9mMP/MYP6Zwfwzg/lnBvPPDOafWdA/rxJNXqKLS+QgLxHlJUheIslLsLxElpco8hLyb3d5fdDGENY06Rgi7YmQhsjrJo/EH/627MUHSldoSQ0aIhqGr3yCSOmbSCt7IllDpGiIVA2RpiFyxntS4odI3RFpQUMkaoiQhkjSEGENkawhUjREqoZI0xA54Y2P28Vgt3/trVZ60BCJGiKkIZI0RFhDJGuIFA2RqiFywhsfK20in8+nfYh0BZEYgopKUvh4eJC+frpKVlEpKipdQ+WEs3s/UYkqKqSiIv6+9Lh//rVuv6r1IHzKYb3olSl//2jbPEQP/O+f4qy/DsreuJtR7m6Ue//1tQAerYKTVfBkFZytgmer4MUquNV5M1qdOKPVmZOszpxkdeYkqzMnWZ05yerMSVZnThKbOVeBKi3w8ky03RzOmfcEurBACtICUVqApAVe9mhbAi+3tCfA0gJZWqBIC7z6JuewRpxyaHsCTVqgCwtwkBaI0gKvDtNM66OZdgWKtMCrRi5pPTBRMu0I5CAtIN1F+eU3eYsd51z3BJq0QBcWKEFaIEoLkLRAkhZgaYEsLVCkBU58k0vZE2jSAq+/yZuzq3sC9eU3OfXvBaK0AEkLvPoml+1waQl9T4ClBbK0QJEWqNICL7/JH5dYx7An0IUFWpAWiNICJC2QpAVYWiBLCxRpgXqiwN6b3Jq0wOtv8nrordCeQH/5Td7img8EorQASQu8PCcffGV2lhbI0gJFWqBKCzRpAelgyIMznycpUHhwsiyWtB2rLflgwyTyVh8+cow7Gg8OFf5OhNsmUo+2cM66zWeBj5bhyTJ8sgzPluGzZfhiGb5ahm+W4btheLI8w5LlGZYsz7BkeYYlyzMsWZ5hyfIMS5ZnWLI8wxLKDPuHJ6FMmiuP8jx42vVbCzxZhk+W4dkyfLYMXyzDV8vwzTJ8NwzPwTK85RmWLc+wbHmGZcszLFueYdnyDMuWZ1i2PMOy5Rk2o8ywKw/KpLnyoMyDKw/K1LbyoMxWKw/KBLTyoMwpKw/KNLHyoHj+lQfFmf/hKWD+uSi/79/fdbwQZTgi5TH9/Y1ey7mriNZHleCIEhxR0Sb67nrphajCETU4oo5G1AIckbo/+u4a5YWI4IgSHBHDEWU4ogJHVOGIGhxRRyPqAY5I22d/e9v2QkRwRAmOiOGIMhxRgSOqcEQNjqijET26M18Q6bsL9u9IEQ+J8JAyWsTm0T3/b0WqeEhwobaoncL3EyTCQ0p4SIyHBOaXmsnaEIPb4hXXg9viDdeD22RtiAXc4g3XC7jFG64XcIs3XC/gbBXc4g3XC7jF2hALuNV502RtiAXc6sxpsjbEAm515jRZG2IBtzpzmqwNsYBbnTlFa0MsAlVaQLI2xCLQhQVEa0MsAlFagKQFJGtDLAIsLZClBYq0gGRtiEWgSQt0YQHR2hCLQJQWkKwNsQgUaQHJ6xCHQA7SAtJdJFobYhFo0gJdWEC0NsQiEKUFSFogSQuwtECWFijSApK1IRaBJi0gWRti2ZmSrA2xCERpAZIWkKwNsQiwtECWFijSAlVaQLI2xCLQhQVEa0MsAlFagKQFkrQASwtkaYEiLSBZG2IRaNICkrUhltMLkrUhFoEoLUDSApK1IRYBlhbI0gJFWqBKCzRpAelgiHBtiFjla0PcNOzWhhjwZm+uHvBmb64e8GZvrh7wbBne7M3VA97szdUD3uzN1QPe7M3VA95sbYgbvN3aEAPe8gxrtzbEgLc8w9qtDTHgLc+wdmtDDHjLM6zd2hADHqk2xI0HqjbE4DF7c/WAN3tz9YA3e3P1gGfL8GZvrh7wZm+uHvBmb64e8GZvrh7wZm+uvsHbrQ0x4C3PsHZrQwx4yzOs3doQA97yDGu3NsSAtzzD2q0NMeAtz7BQtSEGD1JtiMGDVBti8CDVhhg8KLPVyoNUG2LwINWGGDxItSEGD1JtiMGDVBvixgNVG2LwKL/vBzfoDyKs2hCDCOvCunHuCqs2xCDCqg0xiLBqQwwirNoQgwirNsQgwqoNMYiwakPciMBqQwwirNoQgwirNsQgwqoNMYgYjgirNsQgwqoNMYiwakMMIqzaEIMIqzbEjQisNsQgwqoNMYiwakMMIqzaEIOI4YiwakMMIqzaEIMIqzbEIMKqDTGIsGpDLJlHWLUhFiSs2hALElZtiAUJ6w72BQmrNsSChFUbYkGCC7Wh1YZYkLBqQyxIWLUhFiTGQ8LyS8TyGbw3DbsZvAPebH7RgDebXzTgzeYXDXi2DG82v2jAm80vGvBm84sGvNn8ogFvNoP3Bm83g3fAW55h7WbwDnjLM6zdDN4Bb3mGtZvBO+Atz7B2M3gHPFIG740HKoN38JjNLxrwZvOLBrzZ/KIBz5bhzeYXDXiz+UUD3mx+0YA3m1804M3mF93g7WbwDnjLM6zdDN4Bb3mGtZvBO+Atz7B2M3gHvOUZ1m4G74C3PMNCZfAOHqQM3sGDlME7eJAyeAcPymy18iBl8A4epAzewYOUwTt4kDJ4Bw9SBu+NByqDd/Aov+8HeY6DCCuDdxBhHSsc566wMngHEVYG7yDCyuAdRFgZvIMIK4N3EGFl8A4irAzeGxFYBu8gwsrgHURYGbyDCCuDdxAxHBFWBu8gwsrgHURYGbyDCCuDdxBhZfDeiMAyeAcRVgbvIMLK4B1EWBm8g4jhiLAyeAcRVgbvIMLK4B1EWBm8gwgrg3fJPMLK4F2QsDJ4FySsDN4FCS5TDi2Dd0HCyuBdkOBCbWgZvAsSVgbvgoSVwbsgMR4Sll9K9M9X6yBzWGmYDmDa5rZ74I9H0+/3uW/czSh3N8odg1XwaBWcrIInq+BsFTxbBS9Wwa3Om9HqxBmtzpxkdeYkqzMnWZ05yerMSVZnTrI6c5LYzLkKVGmBl2eivJ634cx7Al1YIAVpgSgtQNICL3u0tr403NKeAEsLZGmBIi3w6pucQ/3zaA5tT6BJC3RhAQ7SAlFa4NVhmml9NNOuQJEWeNXIJa2n1EqmHYEcpAWkuyi//CbzNopy3RNo0gJdWKAEaYEoLUDSAklagKUFsrRAkRY48U0uZU+gSQu8/iZvzq7uCdSX3+TNXT8QiNICJC3w6ptctpSFEvqeAEsLZGmBIi1QpQVefpP7esNyiWFPoAsLtCAtEKUFSFogSQuwtECWFijSAvVEgb03uTVpgdff5PUgSqE9gf7ym7zFNR8IRGkBkhZ4eU4++MrsLC2QpQWKtECVFmjSAtLBkAdnm89SYJKvDcFkuDYEk+HaEEyGa0MwGa4NwWS4NgST4doQTIZrQzAZrg3BZLg2BJPh2hBMhmtDMBmuDcFkuDYEk+HaEEyGa0MwGa4NwWS4NgST4doQTIZrQzBh1YZgwqoNwWS4NgST4doQTIZrQzAZrg3BZLg2BJPh2hBMhmtDMBmuDcFkuDYEk+HaEEyGa0MMeMszrN3aEAPe8gxrtzYEk+HaEAPe8gxrtzYEk+HaEExYtSEGD1JtiMGDVBti8CDVhhg8KLPVyoNUG4IJqzYEE1ZtCCas2hBMWLUhmLBqQzCh1YZgQqsNwYRWG4IJrTYEE1ptCCa02hBMaLUhmNBqQzCh1YZgQqsNwYRWG4IJrTYEE1ptCCa02hBMaLUhmNBqQzCh1YZgQqsNwYRWG4IJrTYEE1ptCCa02hBMaLUhmNBqQzCh1YZgQqsNwYRWG4IJrTYEE1ptCCa02hBMcLUhFiSs2hALElZtiAUJ6w72BQmrNsSChFUbYkGCC7Wh1YZYkLBqQyxIWLUhFiTGQwLzS91mbYgbt8krrm/cJm+4vnHbrA0xwE3ecD3ATd5wPcBN3nA9wNkquMkbrge4ydoQA9zqvGmzNsQAtzpz2qwNMcCtzpw2a0MMcKszp83aEAPc6swpWxtiCFRpAdHaEEOgCwvI1oYYAlFagKQFRGtDDAGWFsjSAkVaQLQ2xBBo0gJdWEC2NsQQiNICorUhhkCRFhC9DvEmIFsbYghId5FsbYgh0KQFurCAbG2IIRClBUhaIEkLsLRAlhYo0gKitSGGQJMWEK0NMXamRGtDDIEoLUDSAqK1IYYASwtkaYEiLVClBURrQwyBLiwgWxtiCERpAZIWSNICLC2QpQWKtIBobYgh0KQFRGtDjNMLorUhhkCUFiBpAdHaEEOApQWytECRFqjSAk1aQDoYIlwbIjf52hA3Dbu1IQa82ZurB7zZm6sHvNmbqwc8W4Y3e3P1gDd7c/WAN3tz9YA3e3P1gDdbG+IGb7c2xIC3PMParQ0x4C3PsHZrQwx4yzOs3doQA97yDGu3NsSAR6oNceOBqg0xeMzeXD3gzd5cPeDN3lw94NkyvNmbqwe82ZurB7zZm6sHvNmbqwe82Zurb/B2a0MMeMszrN3aEAPe8gxrtzbEgLc8w9qtDTHgLc+wdmtDDHjLMyxUbYjBg1QbYvAg1YYYPEi1IQYPymy18iDVhhg8SLUhBg9SbYjBg1QbYvAg1Ya48UDVhhg8yu/7wQ36gwirNsQgwrqwbpy7wqoNMYiwakMMIqzaEIMIqzbEIMKqDTGIsGpDDCKs2hA3IrDaEIMIqzbEIMKqDTGIsGpDDCKGI8KqDTGIsGpDDCKs2hCDCKs2xCDCqg1xIwKrDTGIsGpDDCKs2hCDCKs2xCBiOCKs2hCDCKs2xCDCqg0xiLBqQwwirNoQS+YRVm2IBQmrNsSChFUbYkHCuoN9QcKqDbEgYdWGWJDgQm1otSEWJKzaEAsSVm2IBYnxkLD8UsnyGbw3DbsZvAPebH7RgDebXzTgzeYXDXi2DG82v2jAm80vGvBm84sGvNn8ogFvNoP3Bm83g3fAW55h7WbwDnjLM6zdDN4Bb3mGtZvBO+Atz7B2M3gHPFIG740HKoN38JjNLxrwZvOLBrzZ/KIBz5bhzeYXDXiz+UUD3mx+0YA3m1804M3mF93g7WbwDnjLM6zdDN4Bb3mGtZvBO+Atz7B2M3gHvOUZ1m4G74C3PMNCZfAOHqQM3sGDlME7eJAyeAcPymy18iBl8A4epAzewYOUwTt4kDJ4Bw9SBu+NByqDd/Aov+8HeY6DCCuDdxBhHSsc566wMngHEVYG7yDCyuAdRFgZvIMIK4N3EGFl8A4irAzeGxFYBu8gwsrgHURYGbyDCCuDdxAxHBFWBu8gwsrgHURYGbyDCCuDdxBhZfDeiMAyeAcRVgbvIMLK4B1EWBm8g4jhiLAyeAcRVgbvIMLK4B1EWBm8gwgrg3fJPMLK4F2QsDJ4FySsDN4FCS5TDi2Dd0HCyuBdkOBCbWgZvAsSVgbvgoSVwbsgMR4Sll+q9UEGb+a6/iyX+r3Geae8bzgNC6dj4TxIhX4fTwTjITCeBMbDYDwZjKeA8YB55wjmniOYfyYw/0xg/pnA/DOB+WcC888E5p9J0D+vElVe4nUvet6R0cHTsXhSAOOJYDwExpPAeBiMJ4PxFDCeCsYD5p8TmH9mMP/MYP6Zwfwzg/lnBvPPDOafGcw/s6B/XiWavEQXl8hBXiLKS5C8RJKXYHmJLC9R5CXk3+7y+qA9OFw/REhD5HWTH2/Jla7Qkho0RDQMX/kEkW8PuA+RrCFSNESqhkjTEDnjPfn2lOzYkA4aIlFDhDREkoYIa4hkDZGiIVI1RJqGyAlv/PenPseZj6AhEjVESEMkaYiwhkjWECkaIlVD5IQ3/vuTvEOkK4g8Oud9tkpS+HiIgVVUsopKUVHpGionnN37iUpUUSEVFfn3pe+ff63br2o9CJ9yWE/jMh0cxm2bh+iB//1TnPX3Qdm+f1DWAHc3yr3/+loAj1bBySp4sgrOVsGzVfBiFdzqvBmtTpzR6sxJVmdOsjpzktWZk6zOnGR15iSrMyeJzZyrQJUWeHkmyuvOKGfeE+jCAilIC0RpAZIWeNmjtfWl4Zb2BFhaIEsLFGmBV9/kHNaIUw5tT6BJC3RhAQ7SAlFa4NVhmml9NNOuQJEWeNXIJa0HJkqmHYEcpAWkuyi//CZvseOc655AkxbowgIlSAtEaQGSFkjSAiwtkKUFirTAiW9yKXsCTVrg9Td5c3Z1T6C+/CZv7vqBQJQWIGmBV9/ksh0uLaHvCbC0QJYWKNICVVrg5Te551Ughj2BLizQgrRAlBYgaYEkLcDSAllaoEgL1BMF9t7k1qQFXn+T10NvhfYE+stv8hbXfCAQpQVIWuDlOfngK7OztECWFijSAlVaoEkLSAdDHpz5PEuhPThZ9surHsPq7yLHuKMRUYrQ/3oLpz06mWQFnizDJ8vwbBk+W4YvluGrZfhmGb4bhifLMyxZnmHJ8gxLlmdYsjzDkuUZlizPsGR5hiXLMyyhzLB/eBLKpLnyoBShf8a4CaVi/VPwKOXtn4Jny/DZMnyxDF8twzfL8N0wPAfL8JZnWLY8w7LlGZYtz7BseYZlyzMsW55h2fIMy5Zn2Iwyw648KJPmyoMyD648KFPbyoMyW608KBPQyoMyp6w8KNPEyoPi+VceFGf+h6eA+eei/L4f3HXcHiV+vJUIq2Bze5TW8M4+qgRHlOCItMujf3+9dHuU2PBWogZH1NGIWoAjUvdH316j3B5lc7yVKMERMRxRhiMqcEQVjqjBEXU0oh7giLR99ve3bbdHeTtvJUpwRAxHlOGIChxRhSNqcEQdjejRnfmCSN9esL8gRTwkwkPKaBGbR/f8vxWp4iHBhdqidgrfT5AIDynhITEeEpZf6sVmbYgbt8krrm/cJm+4vnHbrA0xwE3ecD3ATd5wPcBN3nA9wNkquMkbrge4ydoQA9zqvGmzNsQAtzpz2qwNMcCtzpw2a0MMcKszp83aEAPc6swpWxtiCFRpAdHaEEOgCwvI1oYYAlFagKQFRGtDDAGWFsjSAkVaQLQ2xBBo0gJdWEC2NsQQiNICorUhhkCRFhC9DvEmIFsbYghId5FsbYgh0KQFurCAbG2IIRClBUhaIEkLsLRAlhYo0gKitSGGQJMWEK0NMXamRGtDDIEoLUDSAqK1IYYASwtkaYEiLVClBURrQwyBLiwgWxtiCERpAZIWSNICLC2QpQWKtIBobYgh0KQFRGtDjNMLorUhhkCUFiBpAdHaEEOApQWytECRFqjSAk1aQDoYIlsbIoUsXhtiaJitDbHAW725eoG3enP1Am/15uoFni3DW725eoG3enP1Am/15uoF3urN1Qu81doQA95sbYgF3vIMa7Y2xAJveYY1Wxtigbc8w5qtDbHAW55hzdaGWOCBakMMHqTaEAuP1ZurF3irN1cv8FZvrl7g2TK81ZurF3irN1cv8FZvrl7grd5cvcBbvbl6wJutDbHAW55hzdaGWOAtz7Bma0Ms8JZnWLO1IRZ4yzOs2doQC7zlGRapNsTCA1QbYuEBqg2x8ADVhlh4UGarlQeoNsTCA1QbYuEBqg2x8ADVhlh4gGpDDB6k2hALj/L7/v0N+gsRVG2IhQjqwrrl3BVUbYiFCKo2xEIEVRtiIYKqDbEQQdWGWIigakMsRFC1IQYRVm2IhQiqNsRCBFUbYiGCqg2xEDEcEVRtiIUIqjbEQgRVG2IhgqoNsRBB1YYYRFi1IRYiqNoQCxFUbYiFCKo2xELEcERQtSEWIqjaEAsRVG2IhQiqNsRCBFUb4p55BFUb4o4EVRvijgRVG+KOBHUH+x0JqjbEHQmqNsQdCS7UBlYb4o4EVRvijgRVG+KOxHhIWH4pknwG703DbgbvgDebXzTgzeYXDXiz+UUDni3Dm80vGvBm84sGvNn8ogFvNr9owJvN4L3B283gHfCWZ1i7GbwD3vIMazeDd8BbnmHtZvAOeMszrN0M3gGPlMF744HK4B08ZvOLBrzZ/KIBbza/aMCzZXiz+UUD3mx+0YA3m1804M3mFw14s/lFN3i7GbwD3vIMazeDd8BbnmHtZvAOeMszrN0M3gFveYa1m8E74C3PsFAZvIMHKYN38CBl8A4epAzewYMyW608SBm8gwcpg3fwIGXwDh6kDN7Bg5TBe+OByuAdPMrv+0Ge4yDCyuAdRFjHCse5K6wM3kGElcE7iLAyeAcRVgbvIMLK4B1EWBm8gwgrg/dGBJbBO4iwMngHEVYG7yDCyuAdRAxHhJXBO4iwMngHEVYG7yDCyuAdRFgZvDcisAzeQYSVwTuIsDJ4BxFWBu8gYjgirAzeQYSVwTuIsDJ4BxFWBu8gwsrgXTKPsDJ4FySsDN4FCSuDd0GCy5RDy+BdkLAyeBckuFAbWgbvgoSVwbsgYWXwLkiMh4Tllyj889U6yBxWGqYDmLa57R7449H0+33uG3czyt2NcsdgFTxaBSer4MkqOFsFz1bBi1Vwq/NmtDpxRqszJ1mdOcnqzElWZ06yOnOS1ZmTrM6cJDZzrgJVWuDlmSiv5204855AFxZIQVogSguQtMDLHq2tLw23tCfA0gJZWqBIC7z6JudQ/zyaQ9sTaNICXViAg7RAlBZ4dZhmWh/NtCtQpAVeNXJJ6ym1kmlHIAdpAekuyi+/ybyNolz3BJq0QBcWKEFaIEoLkLRAkhZgaYEsLVCkBU58k0vZE2jSAq+/yZuzq3sC9eU3eXPXDwSitABJC7z6JpctZaGEvifA0gJZWqBIC1RpgZff5L7esFxi2BPowgItSAtEaQGSFkjSAiwtkKUFirRAPVFg701uTVrg9Td5PYhSaE+gv/wmb3HNBwJRWoCkBV6ekw++MjtLC2RpgSItUKUFmrSAdDDkwdnmsxRSkK8NkYLh2hApGK4NkYLh2hApGK4NkYLh2hApGK4NkYLh2hApGK4NkYLh2hApGK4NkYLh2hApGK4NkYLh2hApGK4NkYLh2hApGK4NkYLh2hApGK4NkYLh2hApYNWGSAGrNkQKhmtDpGC4NkQKhmtDpGC4NkQKhmtDpGC4NkQKhmtDpGC4NkQKhmtDpGC4NkQKhmtDDHjLM6zd2hAD3vIMa7c2RAqGa0MMeMszrN3aECkYrg2RAlZtiMGDVBti8CDVhhg8SLUhBg/KbLXyINWGSAGrNkQKWLUhUsCqDZECVm2IFLBqQ6SAVhsiBbTaECmg1YZIAa02RApotSFSQKsNkQJabYgU0GpDpIBWGyIFtNoQKaDVhkgBrTZECmi1IVJAqw2RAlptiBTQakOkgFYbIgW02hApoNWGSAGtNkQKaLUhUkCrDZECWm2IFNBqQ6SAVhsiBbTaECmg1YZIAa02RApotSFSQKsNkQJcbYgFCas2xIKEVRtiQcK6g31BwqoNsSBh1YZYkOBCbWi1IRYkrNoQCxJWbYgFifGQwPxStVkb4sZt8orrG7fJG65v3DZrQwxwkzdcD3CTN1wPcJM3XA9wtgpu8obrAW6yNsQAtzpv2qwNMcCtzpw2a0MMcKszp83aEAPc6sxpszbEALc6c8rWhhgCVVpAtDbEEOjCArK1IYZAlBYgaQHR2hBDgKUFsrRAkRYQrQ0xBJq0QBcWkK0NMQSitIBobYghUKQFRK9DvAnI1oYYAtJdJFsbYgg0aYEuLCBbG2IIRGkBkhZI0gIsLZClBYq0gGhtiCHQpAVEa0OMnSnR2hBDIEoLkLSAaG2IIcDSAllaoEgLVGkB0doQQ6ALC8jWhhgCUVqApAWStABLC2RpgSItIFobYgg0aQHR2hDj9IJobYghEKUFSFpAtDbEEGBpgSwtUKQFqrRAkxaQDoYI14bgIl8b4qZhtzbEgDd7c/WAN3tz9YA3e3P1gGfL8GZvrh7wZm+uHvBmb64e8GZvrh7wZmtD3ODt1oYY8JZnWLu1IQa85RnWbm2IAW95hrVbG2LAW55h7daGGPBItSFuPFC1IQaP2ZurB7zZm6sHvNmbqwc8W4Y3e3P1gDd7c/WAN3tz9YA3e3P1gDd7c/UN3m5tiAFveYa1WxtiwFueYe3WhhjwlmdYu7UhBrzlGdZubYgBb3mGhaoNMXiQakMMHqTaEIMHqTbE4EGZrVYepNoQgwepNsTgQaoNMXiQakMMHqTaEDceqNoQg0f5fT+4QX8QYdWGGERYF9aNc1dYtSEGEVZtiEGEVRtiEGHVhhhEWLUhBhFWbYhBhFUb4kYEVhtiEGHVhhhEWLUhBhFWbYhBxHBEWLUhBhFWbYhBhFUbYhBh1YYYRFi1IW5EYLUhBhFWbYhBhFUbYhBh1YYYRAxHhFUbYhBh1YYYRFi1IQYRVm2IQYRVG2LJPMKqDbEgYdWGWJCwakMsSFh3sC9IWLUhFiSs2hALElyoDa02xIKEVRtiQcKqDbEgMR4Sll/KST6D96ZhN4N3wJvNLxrwZvOLBrzZ/KIBz5bhzeYXDXiz+UUD3mx+0YA3m1804M1m8N7g7WbwDnjLM6zdDN4Bb3mGtZvBO+Atz7B2M3gHvOUZ1m4G74BHyuC98UBl8A4es/lFA95sftGAN5tfNODZMrzZ/KIBbza/aMCbzS8a8Gbziwa82fyiG7zdDN4Bb3mGtZvBO+Atz7B2M3gHvOUZ1m4G74C3PMPazeAd8JZnWKgM3sGDlME7eJAyeAcPUgbv4EGZrVYepAzewYOUwTt4kDJ4Bw9SBu/gQcrgvfFAZfAOHuX3/SDPcRBhZfAOIqxjhePcFVYG7yDCyuAdRFgZvIMIK4N3EGFl8A4irAzeQYSVwXsjAsvgHURYGbyDCCuDdxBhZfAOIoYjwsrgHURYGbyDCCuDdxBhZfAOIqwM3hsRWAbvIMLK4B1EWBm8gwgrg3cQMRwRVgbvIMLK4B1EWBm8gwgrg3cQYWXwLplHWBm8CxJWBu+ChJXBuyDBZcqhZfAuSFgZvAsSXKgNLYN3QcLK4F2QsDJ4FyTGQ4LyS6XSg2PVHFcPy/wR74mJ15/tn34+/ll87mf03M/Scz/j536Wn/vZ7rzA22lvrv2vn+0YuZRtRJTyqeJ46ptI1RBpGiJdQWT/mOLZIvFlkRq2t7vWv0W+Pp3b+pfz50XTzYWsQIQGlNCAGA0oowEVNKCKBtTQgDoYUA5oQGieOqN56ozmqTOap85onjqjeeqM5qkzmqfOaJ66oHnqguapC5qnLtp+KK9HR3KNu0AFDQjtLatob1lFe8sq2ltW0dZDlSWBVpGsIVI0RE5Yi/QtANTSvkjTEOkKIi1oiEQNEdIQed07tO2Fj53bq96hMRpQRgMqaEAVDaihAXUwoB7QgCIaEKEBoXnqjuapO5qn7mieuqN56o7mqTuap35w8O+tRGi++sGxv7cSoXnrGNDc9YOTkW8lQnPYD85FvpUIzWXHAOezI5zPjnA+O8L57Kj99h+F/2OsaEQEN7IJbmQT3MgmuNUIwa1GSHQ1sqkUFZWqovL6SqCX+udhCiHuq3QNlRRUVKKKCqmoJBWVl/0EhRQ3lc5HfoLD6ifKpzy8+OEnUoYjKnBEFY6owRF1NKLXUw1OJ4pwRARHlOCI4Hw2w/lshvPZDOezGc5nM5zPznA+O8P57AznszOcz85wPjvD+ewM57MznM/OcD47w/nsAuezC5zPLnA+u8D57ALnswuczy5wPrvA+ewC57MLnM+ucD67wvnsCuezK5zPrnA+u8L57Arnsyucz65wPrvC+eym/fYfnp5oDEekPbIP9+FbgyPqaEQ9wBFFOCLR1cimklRUWEXl9ZVAjGvdEbptA+2rFBWVqqLSVFS6ggq9nmfwI5XX/URseVUh7q+uEuj13IHTiRIcEcMRZTiiAkdU4YgaHFFHI4oBjgjOZ0c4nx3hfHaE89kRzmdHOJ8d4Xx2hPPZEc5nE5zPJjifTXA+m+B8NsH5bILz2QTnswnOZxOczyY4n53gfHaC89kJzmcnOJ+d4Hx2gvPZCc5nJzifneB8doLz2QznsxnOZzOcz2Y4n81wPpvhfDbD+eys/fYfnZ6gHOGItEf20T485QxHVOCIKhxRgyMSXY2sKiWoqEQVlddXArSVjrt9L4d9laSiwioqWUWlqKhUFZXX/USiD5VPdSn/UukaKiec8f+JSlRRIRWVpKLy+ruf+vrwbe1/dFcUb7fm5xh3V6InnJk/m6jAEVU4ogZH1NGIWoAjirpEn75Dc9onIjiiBEfEcEQZjqjAEVU4ovY2ogdRqNbRiHqAI3rdZ/MWEKCcjqIHta1EtX8aR6l+EBEcUYIjYjiiDEdU4IiqLlGjNcmjpbJP1OCIOhhROiHb5myiCEdEcETKPrvl9YLcVsM+EcMRZTiiAkdU4YgaHFFHI4raPntblPeQ94kiHBHBESU4IoYjynBEBY7odZ99+1xeicq/3Hf/9ekYt9vxb//89E3O/YOpATJ1PKYT8nPOZ4rKTBR5ZboF+v5ieuI8Rjohn+e9/Mk4Pxvnz8b5i3H+apy/GefvtvlTMM5vfP5NxuffZHz+PSHv6738xuffZHz+Tcbn32R8/k3G5182Pv+y8fmXjc+/jO3/jzKdEmP7/2N+4/4nG/c/2bj/ycb9Tza+/j8h0/I0/o0JyKdvTEB+emPSXnunUFamxA+YGiBTx2MqAZApAjIRIJO2z091XYZFzuHA58fKWwsafzptyfGjBWy+Bdl8C4r5FlTzLWjmW9Ctt6AG8y2I5ltA5ltgfk4+IT/83S0wPydX83NyNT8nV/NzcjU/Jzfzc3IzPyc383NyMz8nn5D//+4WmJ+Tm/k5uZmfk5v5ObmZn5O7+Tm5m5+Tu/k5uZufk0+43+HdLTA/J3fzc3I3Pyd383Nytz4nc7A+J3OA9qaH5884QPvSH/BDv8WH54c4QL/Dx/wR+g3+AT/0mvoH/NAr6h/wA62nNyYgn74xafvpvFVxj7m2Azsf3t/KsRjnr8b5m3H+bptf/e6Js/mjcX5C5j+8AZfV76k4m5+N80PPvz/gh55/f8APPf/+gB96/v0BP/T8e3gXNSfo+fcH/NDz7w/4teff2yMrf8nxgD9m3rKFcv6ctfAR6VO/qeL8FrD5FmTzLSjmW1DNt6Bht2ALet88L+23oFtvgfq9Fee3IJpvAfic/IMWgM/JP2gB9pzMPWwtaH9702dWgYw9f5/dWuy5/uzWYq8LSv14uvH+u4i9LvhJC7DXBT9oQcZeF/ykBdjrgp+0AHtd8JMWYK8LftICxm5B205Gld73W4A91/+kBdjz909aAD4n/6AF4HPyD1oAPicft6CAz8k/aAH4nBy3OhE1/j0fPLMSL+Dz98mtBZ/rT24tQ7e2he2bssX9E9MFe13wkxZgrwt+0gLsdcFPWoC9LvhJC7DXBT9oQcVeF/ykBdjrghbz1gJq+y3Anut/0gLs+fsnLQCfk3/QAvA5+QctAJ+Tf9AC8Dn5By3AnpO/yeZ7ZiVesefvk1vbsOf6s1v7+rqgpLS1tpWj1ub+EcOIn/52zbs9ub6K9DkrsqQPfjLOn4zzs3H+jMO/MRVApgrI1ACZOh7TCfcBnc8ENO9sTEBzycakPT+Usp3kKo0O/GtP68O9fNqPaB/ZvJ2N82dkfqLtT3Pend96Mc5fjfM34/zdNH8OwTh/hOY/Wl/nQMb5teffGrboU43t1fkrBzbOn5H5f/D+FuP81Th/M87fbfPHYJw/QvMfzl+RjPOrz78f8fWaj+KLx/PXCTdsvZc/I/P/4P0txvmrcf5mnL/b5qdgnD9C8x/OX0TG+dXn37bdalB7fXn+OuE2rvfyZ2T+H7y/xTh/Nc7fjPN32/wpGOeP0PyH81ci4/xvnH9b4L/4NyYGZMqATNpzX8vbScJW+OW1R6rG+Rsy/w98b7fNz8E4fzTOT8b5k3F+huY/XHtwNs6vPv9S++DPT89fX5+tef3DtX/KrP7U1DpPU9s8Te3TNDWHeZoa52kqzdPUNE9TeZ6m5nmaOs9qKWuvlnrcDqX29HJSQs7NOH9H5j/+sCvBOH80zk/G+ZNxfjbOn6H5DwMbpRjnh55/f8APPf/+gF99/s3b1YD9+FAMbeuHT/yxho2/BuP8EZm/tpW/Rfpr/Ow8W+v2bNoda5UmamuaqK08UVvzRG0tE7W1TtTWNlFbodc357a1Qa+FTm7rROumNtG6qU20blK/MO2dbZ1o3dQmWje1idZNbaJ1U5to3dQnWjf1idZNfaJ1U59o3aR+keA72zrRuqlPtG7qE62b+kTrpj7PuqmEy8yvmVfmzA/aepn59QdtvYwfztvxv1zqflsv44d/0NbL+OEftPUyfvi4rfEy368/aOtlvl9/0NbLzK8lrjcRlUT7bb3M/PqDtvJEbb3M9+sP2nqZddMP2nqZddMP2nqZddMP2nqZddNxW+ky66YftPUy66YftHWidRNNtG5Sv8DxnW3FXjc9jA1+fbZv8aaeP6d2ho+2Yq+bzm0r9rrp3LZir5vObSv2uunUtibsddO5bcVeN53bVux102/auv3hXsN+W7HXTee2lSdq63XWTcdtvc666bit11k3Hbf1Ouum47YaXTet/Gx0LbTxG13fbPxG1ywbv9F1yMbPxvmNrhdW/uuc+z0+l3Sdc78/aOtl9k1/0NbrnDc7but1zpsdt/U6582O23qd82ZHba3hOufNjtt6nfNmx22d5zx3neg8dw18mba2sLa15/22XmfddNzW66ybjtt6nXXTcVuvs26qH20t+229zrrpsK0XOqd/3NbrrJuO23qdddNxW6+zbjpuK0+Ta1Kvc07/B22dJ7+xXuec/g/aOk9+Y73OOf3jtl7nnP4P2jpPfmO9zjn9H7T1Ouum47byRG2daN0Efk7/3LZOtG4CP6d/blsnWjeBn9M/t60TrZvAz+mf29aJ1k3g5/TPbetE6ybwc/rntnWidRP4Of1z2zrRugn8TP+5bZ1o3QSeK3BuWydaN4HnIJzb1onWTTzRuoknWjfxROsmnmjdlCdaN+WJ1k15onVTfn1+zSVsbQ3xqK2pbvWcOX/kSBP3Xf714fy5nvOtXzb+Ypy/Gudvxvm7bf4SoPn7Wo+9hLzPH43zk3H+ZJyfsfnjxl/2+bHn32N+7Pn3mB97/j3mx55/j/mx599D/oo9/7YtV7K1fX7s+feYH3v+PebHnn+P+bHn32N+7Pn3mB97/j3mx55/j/mx599jfuz595C/GZ9/m/H5txmff5vx+bcZn3+b8fm3GZ9/m/H5txmff5vx+bcbn3+78fm3G59/u/H594Q7Ot/Lb3z+7cbn3258/u3G599ue/5twfb824Lt+bcF2/NvC7bn3xZsz78t2J5/W7A9/7Zge/5twfb826K2/6fIKz+1esR/dP6qRTLOn4zzs3H+bJy/QPMfnd9osRrnb8b5u21+Csb5seffY37s+fdw/UPY8+8xP/b8e8yPPf8e82PPv8f82PPvMT/2/HvMjz3/HvIn7Pn3mB97/j3mNz7/JuPz7wl3aL2X3/j8m4zPv8n4/JuMz7/J+PzLxudfNj7/svH5l43PvyfcxfRefuPzLxuff9n4/MvG5182Pv9m4/NvNj7/ZuPzbzY+/2bj8282Pv9m4/NvNj7/ZuPzbzY+/xbj8+8J9//Etl7SQwvFt/zHJ0pOuNHnbKIMR1TgiCocUVMmOrqrqp1w183JRCfcXnM2UYQjIm2iozMvNcERMRxRhiMqcEQVjkjbZx+uj2pHI2oBjijCEREcUYIjYjiiDEdU4IgqHBGcz25wPrvD+ewO57M7nM/ucD67w/nsDuezO5zP7nA+u8P57I7ms3tA89k9oPnsHtB8dg9oPrsHNJ/dA5rP7gHNZ/eA5rN7QPPZPcD57AjnsyOcz45wPjvC+ewI57MjnM+OcD77hFzykNYQNYXOR0RHe5D9hOzws4kiHBHBESU4IlYmOtoV7SfkTZ9NVOCIKhxR0yY62PHr1NGIUoAjinBEBEeU4Ii0ffbh+ihlOKICR1ThiBocUUcj4gBHFOGICI4owRHB+WyG89kM57MZzmcznM9mOJ+d4Xx2hvPZGc5nZzifneF8dobz2RnOZ2c4n53hfHaG89kFzmcXOJ9d4Hx2gfPZBc5nFzifXeB8doHz2QXOZxc4n13hfHaF89kVzme/nr8W2yYSbx+kR0SHe5Cv56+dTlThiBocUUcjej1/7ZdEh7uir+evnU5EcEQJjoi1iY52/FqGIypwRBWOqMERdTSiru2zD9dHPcIRERxRgiNiOKIMR1TgiCocUYMj6mBEMQQ0p31DQvPaNyQ0t31DQvPbNyQ0x31DQvPcNyQ0131DQvPdNyQ0531DwvPeEc97RzzvHfG8d8Tz3hHPe0c87x3xvHfE894Rz3tHPO9NeN6b8Lw34XlvwvPehOe9Cc97E573JjzvTXje+/XstlhDWZHqp6ef3KG8IREeUsJDYjykjIdUlJGONnNuSBUPqeEhdTik19PczkeKeEja3vt4juOEh8R4SBkPqeAhVTykhofU4ZBywEOKeEh43jvjee+M570znvfOeN4743nvjOe9M573Lnjeu+B574LnvQue9y543rvgee+C570LnvcueN674Hnviue9K573rnjeu+J574rnvSue96543rviee+K570rnvduUN67hX/uH1yIrddVpBf6hBT3kMLGH2Msfz29yiQdGdaRyToyRUem6sg0HZmuIrN/t+4vZSL3TSa3XZmoI0M6MklHhnVkso5M0ZE5wwvEss1NsfcXnl6hGiJUB4TigAgVEaEIESohQjEiVEaEKohQiB6dET06I3r0jOjRM6JHz4gePSN69Izo0TOiR8+IHj0jevSM6NEzokcviB69qPup74+aDyTGQ1J/8w4jt6XhIXU4pBrwkCIekvAKapVJKjItwvmPRnhIeI6/4Tn+lvGQ1Jem319hOZAqHlLDQ+pwSD3gIel7728zsQYS4SElPCTGQ8p4SAUPCe/jpuN93HS8j5sY8L5uYsD7vImBAJkSIBMDMmVApgLIhOfFY8Bz4zEA+vEI6McjoB+PgH48AvrxCOjHI6Afj4B+PAL68QjoxyOgHydAP06AfpwA/TgB+nEC9OME6McJ0I8ToB8nQD9OgH48YfnxVvujhBOi1FYVovpRrjGWsCNDtz2lP4/TZ6Hx9CoUtYRISyhpCbGWUNYSKlpCVUuoaQl1JSHW8gys5RlYyzOwlmdgLc/AWp6BtTwDa3kG1vIMrOUZspZnyFqeIWt5hqzlGbKWZ8haniFreYas5RmylmfIWp6haHmGouUZipZnKFqeoWh5hqLlGYqWZyhanqFoeYai5RmqlmeoWp6hanmGquUZqpZnqFqeoWp5hqrlGaqWZ6hanqFpeYam5RmalmdoWp6haXmGpuUZmpZnaFqeoWl5hqblGbqWZ+hanqFreYau5Rm6lmfoWp6ha3mGruUZupZn6Fqe4dEJdQmlqKZEakpJTYnVlLKaUlFTqmpKTU1JzUdENR8R1XxEVPMRUc1HRDUfEdV8RFTzEVHNR0Q1HxHVfASp+QhS8xGk5iNIzUeQmo8gNR9Baj6C1HwEqfkIUvMRakcko9oZyah2SDKqnZKMascko9o5yah2UDKqnZSMakclo9pZyah2WDKqnZaMasclo9p5yah2YDKqnZiMakcmo9qZyah2aDKqnZqMascmo9q5yah2cDKqnZyMakcno9rZyah2eDKqnZ6Mascno9r5yah2gDKqnaCMakcoo9oZyqh2iDKqnaKMascoo9o5yqh2kDKqnaSMakcpo9pZyqh2mDKqnaaMascpo9p5yqh2oDKqnaiMakcqo9qZyqh2qDKqnaqMascqo9q5yqh2sDKqnayMakcro9rZyqh2uDKqna6Mascro9r5yqh2wDKqnbCMakcso9oZy6h2yDKqnbKMascso9o5S1I7Z0lq5yxJ7ZwlqZ2zpMBqSllNqagpVTWlpqak5iPUzlmS2jlLUjtnSWrnLEntnCWpnbMktXOWpHbOktTOWZLaOUtSO2dJaucsSe2cJamdsyS1c5akds6S1M5Zkto5S1I7Z0lq5yxJ7ZwlqZ2zJLVzlqR2zpLUzlmS2jlLUjtnSWrnLEntnCWpnbMktXOWpHbOktTOWZLaOUtSO2dJaucsSe2cJamdsyS1c5akds6S1M5Zkto5S1I7Z0lq5yxJ7ZwlqZ2zJLVzlqR2zpLUzlmS2jlLUjtnSWrnLEntnCWpnbMktXOWpHbOktTOWZLaOUtSO2dJaucsSe2cJamdsyS1c5akds6S1M5Zkto5S1I7Z0lq5yxJ7ZwlqZ2zJLVzlqR2zpLUzlmS2jlLUjtnSWrnLEntnCWpnbMktXOWpHbOktTOWZLaOUtSO2dJaucsSe2cJamdsyS1c5akds6S1M5Zkto5y6R2zjKpnbNMaucsk9o5yxRYTUmtFp/aOcukds4yqZ2zTGrnLFPUK9Wp5iPUzlkmtXOWSe2cZVI7Z5nUzlkmtXOWSe2cZVI7Z5nUzlkm0qvnq+YjHp2zvDmPTSnlcKCUalvBUqN28HTnzn+e7jmn7WniT1wMypVBuQooVwXlaqBcHZPr0UnVt3NFUC4C5QL19wnU3ydQf59A/X0C9fcJ1N8/PEfc4wdXyQdKJdGfp0v79GyinWc5lT/Pcq5/PbsyPTxxLMZ068yVqcR9pgjIRIBMCZCJAZkyIFM5hSnWjakcMLWSVw/VSqGPp3P/oKqQVA2SqiNS5QBJFSGpSJ2qhvVP3/7Z96kSJBVDUmVIqgJJVSGpGiSVvm+vuW9Upe5SlQBJFSGpCJIqQVIxJFWGpHqDb0/1g6r9RbWzD8TbthHxpxjHLeDx0YZ6gTa0C7ThUfy/9a0NTOWgDbentzhVT2fEqR5lhrydK4JyEShXAuViUK4MylVAuSooVwPlAvX3DdTfN1B/30D9fQP19w3U3z/KZbotkD+4OB6tIU/dF3iU9fRWpgrI1ACZOh7To+ysXzL94jupU1pf6078+Sv648vnUSbXm6kIkipBUjEkVYakKvpUFD6o2l9UO6dEqG9uJMWPp0dzvjxc8zoL186fwhofra1TtbZN1do+UWs5hKlaG8Fbm7b4KyfOn1u7NYHsNyHZbwKjN6Hy1oQWdpuQ4ZuQPprQd5uAvuj4QRP0VxK3WMXahJv731vNcWiQVB2RKoY3UKWNKqZ9qghJRW+goo2KaJ8qQVIxJJX+rMG8fX1y7ftUBZKqvoGqbVSt7lPp+/Yct77K/KCv+huotr7KnyOLn6goQFLFN1DVjaruz4Ok79vztlvSC7V9qgRJxW+g2ixYUtmn0vftpW7L6fpgfUUFkkrft5fSP6i+jqs2btbdg6qbR6n107LsNjTXn9Xnftae+1l/6mf7CdvHP4vP/Yye+9mut2lxS9Og/Z/xcz/Lz/2sPPez+tzP2nM/60/9bD/Vs21fJq3T7s/icz+j536WnvsZP/ez/NzPynM/2x0lfUtH6DHs/qw997P+1M/2E8iOfxaf+xk997P03M92R8ktWLX+LO2+OPtZRsc/K8/9rD73s/bcz/pTP9tPRTn+WTz4Ge/abT+Z4/hn6bmf7Y+SnD5Wrrs/y8/9rDz3s/rcz9pzP+tP/Wz/IPnxz/ZHSVsXnjHk9tfv/u03D68ipCGSNERYQyRriBQNkaoh0jREuoLI/uHgs0U03vim8cY3jTe+abzxTeONbxpvfNN445vGG9803viu8cZ3jTe+a7zxXeON7xpvfH/9PclbBm2uHwE+qlsYrjd5jRheH1x52+77fJvqXyKkIZI0RFhDJGuI/HY62X5Yn/whJYXxTKwhkjVEioZI1RA5wZH1vO5whLwv0hVEUtAQiRoipCFywhu/XVJQQtkXYQ2RrCFSNESqhkjTEOkK0yQHDRGNRRhrLMJYYxHGGosw1liEcdEQqRoiTUNE443PGm981njjs8YbnzXe+KzxxmeNNz5rvPFZ443PGm981njji8YbXzTe+KLxxheNN75ovPFF440vGm980Xjji8YbXzTe+KrxxleNN75qvPFV442vGm981Xjjq8YbX6Xf+J7/uX84OfN2Njl/uvqTdm+CzKtEa/H7R2NsawWOUdHt4+G04jQsnI6F8yCB8H08EYyHwHgSGA+D8WQwngLGA+adI5h7jmD+mcD8M4H5ZwLzzwTmnwnMPxOYfyZB/7xKVHmJ173op9yOFF7u1Y7FkwIYTwTjITCeBMbDYDwZjKeA8VQwHjD/nMD8M4P5ZwbzzwzmnxnMPzOYf2Yw/8xg/pkF/fMq0eQlurhEDvISUV6C5CWSvATLS2R5iSIvIf92l9cHbQxhq1YfIu2JkIbI6yaPxB/+tuzFB0pXaEkNGiIahq98gsh2YVIMn65X+iSSNUSKhkjVEGkaIme8JyV+iNQdkRY0RKKGCGmIJA0R1hDJGiJFQ6RqiDQNkRPe+LhdDHb7195qpQcNkaghQhoiSUOENUSyhkjREKkaIie88bHSJvL5fNqHSFcQiSGoqCSFj4cH6eunq2QVlaKi0jVUTji79xOVqKJCKiry70vdP/9at1/VehA+5bBe9MqUv3+0bR6ih79qDv0+KFv3D8oa4O5GufdfXwvg0So4WQVPVsHZKni2Cl6sgludN6PViTNanTnJ6sxJVmdOsjpzktWZk6zOnGR15iSxmXMVqNICL89E283hnHlPoAsLpCAtEKUFSFrgZY+2JfByS3sCLC2QpQWKtMCrb3IOa8Qph7Yn0KQFurAAB2mBKC3w6jDNtD6aaVegSAu8auSS1gMTJdOOQA7SAtJdlF9+k7fYcc51T6BJC3RhgRKkBaK0AEkLJGkBlhbI0gJFWuDEN7mUPYEmLfD6m7w5u7onUF9+k1P/XiBKC5C0wKtvctkOl5bQ9wRYWiBLCxRpgSot8PKb/HGJdQx7Al1YoAVpgSgtQNICSVqApQWytECRFqgnCuy9ya1JC7z+Jq+H3grtCfSX3+QtrvlAIEoLkLTAy3PywVdmZ2mBLC1QpAWqtECTFpAOhjw483mSQg8PTpbFkrZjtSUfbJhEDqu/ixzjjsaDQ4W/E+G2idSjLZyzbvNZ4KNleLIMnyzDs2X4bBm+WIavluGbZfhuGJ4sz7BkeYYlyzMsWZ5hyfIMS5ZnWLI8w5LlGZYsz7CEMsP+4Ukok+bKozwPnnb91gJPluGTZXi2DJ8twxfL8NUyfLMM3w3Dc7AMb3mGZcszLFueYdnyDMuWZ1i2PMOy5RmWLc+wbHmGzSgz7MqDMmmuPCjz4MqDMrWtPCiz1cqDMgGtPChzysqDMk2sPCief+VBceZ/eAqYfy7K7/v3dx0vRBmOSHlMf3+j13LuKqL1USU4ogRHVLSJvrteeiGqcEQNjqijEbUAR6Tuj767RnkhIjiiBEfEcEQZjqjAEVU4ogZH1NGIeoAj0vbZ3962vRARHFGCI2I4ogxHVOCIKhxRgyPqaESP7swXRPrugv07UsRDIjykjBaxeXTP/1uRKh4SXKgtaqfw/QSJ8JASHhLjIWH5pcgma0MMbotXXA9uizdcD26TtSEWcIs3XC/gFm+4XsAt3nC9gLNVcIs3XC/gFmtDLOBW502TtSEWcKszp8naEAu41ZnTZG2IBdzqzGmyNsQCbnXmFK0NsQhUaQHJ2hCLQBcWEK0NsQhEaQGSFpCsDbEIsLRAlhYo0gKStSEWgSYt0IUFRGtDLAJRWkCyNsQiUKQFJK9DHAKitSEWAekuEq0NsQg0aYEuLCBaG2IRiNICJC2QpAVYWiBLCxRpAcnaEItAkxaQrA2x7ExJ1oZYBKK0AEkLSNaGWARYWiBLCxRpgSotIFkbYhHowgKitSEWgSgtQNICSVqApQWytECRFpCsDbEINGkBydoQy+kFydoQi0CUFiBpAcnaEIsASwtkaYEiLVClBZq0gHQwRLg2BCX52hA3Dbu1IQa82ZurB7zZm6sHvNmbqwc8W4Y3e3P1gDd7c/WAN3tz9YA3e3P1gDdbG+IGb7c2xIC3PMParQ0x4C3PsHZrQwx4yzOs3doQA97yDGu3NsSAR6oNceOBqg0xeMzeXD3gzd5cPeDN3lw94NkyvNmbqwe82ZurB7zZm6sHvNmbqwe82Zurb/B2a0MMeMszrN3aEAPe8gxrtzbEgLc8w9qtDTHgLc+wdmtDDHjLMyxUbYjBg1QbYvAg1YYYPEi1IQYPymy18iDVhhg8SLUhBg9SbYjBg1QbYvAg1Ya48UDVhhg8yu/7wQ36gwirNsQgwrqwbpy7wqoNMYiwakMMIqzaEIMIqzbEIMKqDTGIsGpDDCKs2hA3IrDaEIMIqzbEIMKqDTGIsGpDDCKGI8KqDTGIsGpDDCKs2hCDCKs2xCDCqg1xIwKrDTGIsGpDDCKs2hCDCKs2xCBiOCKs2hCDCKs2xCDCqg0xiLBqQwwirNoQS+YRVm2IBQmrNsSChFUbYkHCuoN9QcKqDbEgYdWGWJDgQm1otSEWJKzaEAsSVm2IBYnxkLD8UgryGbw3DbsZvAPebH7RgDebXzTgzeYXDXi2DG82v2jAm80vGvBm84sGvNn8ogFvNoP3Bm83g3fAW55h7WbwDnjLM6zdDN4Bb3mGtZvBO+Atz7B2M3gHPFIG740HKoN38JjNLxrwZvOLBrzZ/KIBz5bhzeYXDXiz+UUD3mx+0YA3m1804M3mF93g7WbwDnjLM6zdDN4Bb3mGtZvBO+Atz7B2M3gHvOUZ1m4G74C3PMNCZfAOHqQM3sGDlME7eJAyeAcPymy18iBl8A4epAzewYOUwTt4kDJ4Bw9SBu+NByqDd/Aov+8HeY6DCCuDdxBhHSsc566wMngHEVYG7yDCyuAdRFgZvIMIK4N3EGFl8A4irAzeGxFYBu8gwsrgHURYGbyDCCuDdxAxHBFWBu8gwsrgHURYGbyDCCuDdxBhZfDeiMAyeAcRVgbvIMLK4B1EWBm8g4jhiLAyeAcRVgbvIMLK4B1EWBm8gwgrg3fJPMLK4F2QsDJ4FySsDN4FCS5TDi2Dd0HCyuBdkOBCbWgZvAsSVgbvgoSVwbsgMR4SmF9q/3y1DjKHlYbpAKZtbrsH/ng0PbHP3f7ZjHJ3o9wxWAWPVsHJKniyCs5WwbNV8GIV3Oq8Ga1OnNHqzElWZ06yOnOS1ZmTrM6cZHXmJKszJ4nNnKtAlRZ4eSbK63kbzrwn0IUFUpAWiNICJC3wskdr60vDLe0JsLRAlhYo0gKvvsk51D+P5tD2BJq0QBcW4CAtEKUFXh2mmdZHM+0KFGmBV41c0npKrWTaEchBWkC6i/LLbzJvoyjXPYEmLdCFBUqQFojSAiQtkKQFWFogSwsUaYET3+RS9gSatMDrb/Lm7OqeQH35Td7c9QOBKC1A0gKvvsllS1kooe8JsLRAlhYo0gJVWuDlN7mvNyyXGPYEurBAC9ICUVqApAWStABLC2RpgSItUE8U2HuTW5MWeP1NXg+iFNoT6C+/yVtc84FAlBYgaYGX5+SDr8zO0gJZWqBIC1RpgSYtIB0MeXC2+SwFbvK1IbgZrg3BzXBtCG6Ga0NwM1wbgpvh2hDcDNeG4Ga4NgQ3w7UhuBmuDcHNcG0IboZrQ3AzXBuCm+HaENwM14bgZrg2BDfDtSG4Ga4Nwc1wbQhuhmtDcMOqDcENqzYEN8O1IbgZrg3BzXBtCG6Ga0NwM1wbgpvh2hDcDNeG4Ga4NgQ3w7UhuBmuDcHNcG2IAW95hrVbG2LAW55h7daG4Ga4NsSAtzzD2q0Nwc1wbQhuWLUhBg9SbYjBg1QbYvAg1YYYPCiz1cqDVBuCG1ZtCG5YtSG4YdWG4IZVG4IbVm0Ibmi1Ibih1YbghlYbghtabQhuaLUhuKHVhuCGVhuCG1ptCG5otSG4odWG4IZWG4IbWm0Ibmi1Ibih1YbghlYbghtabQhuaLUhuKHVhuCGVhuCG1ptCG5otSG4odWG4IZWG4IbWm0Ibmi1Ibih1YbghlYbghtabQhuaLUhuKHVhuAGVxtiQcKqDbEgYdWGWJCw7mBfkLBqQyxIWLUhFiS4UBtabYgFCas2xIKEVRtiQWI8JCy/lLPN2hA3bpNXXN+4Td5wfeO2WRtigJu84XqAm7zheoCbvOF6gLNVcJM3XA9wk7UhBrjVedNmbYgBbnXmtFkbYoBbnTlt1oYY4FZnTpu1IQa41ZlTtjbEEKjSAqK1IYZAFxaQrQ0xBKK0AEkLiNaGGAIsLZClBYq0gGhtiCHQpAW6sIBsbYghEKUFRGtDDIEiLSB6HeJNQLY2xBCQ7iLZ2hBDoEkLdGEB2doQQyBKC5C0QJIWYGmBLC1QpAVEa0MMgSYtIFobYuxMidaGGAJRWoCkBURrQwwBlhbI0gJFWqBKC4jWhhgCXVhAtjbEEIjSAiQtkKQFWFogSwsUaQHR2hBDoEkLiNaGGKcXRGtDDIEoLUDSAqK1IYYASwtkaYEiLVClBZq0gHQwRLg2RGH52hA3Dbu1IQa82ZurB7zZm6sHvNmbqwc8W4Y3e3P1gDd7c/WAN3tz9YA3e3P1gDdbG+IGb7c2xIC3PMParQ0x4C3PsHZrQwx4yzOs3doQA97yDGu3NsSAR6oNceOBqg0xeMzeXD3gzd5cPeDN3lw94NkyvNmbqwe82ZurB7zZm6sHvNmbqwe82Zurb/B2a0MMeMszrN3aEAPe8gxrtzbEgLc8w9qtDTHgLc+wdmtDDHjLMyxUbYjBg1QbYvAg1YYYPEi1IQYPymy18iDVhhg8SLUhBg9SbYjBg1QbYvAg1Ya48UDVhhg8yu/7wQ36gwirNsQgwrqwbpy7wqoNMYiwakMMIqzaEIMIqzbEIMKqDTGIsGpDDCKs2hA3IrDaEIMIqzbEIMKqDTGIsGpDDCKGI8KqDTGIsGpDDCKs2hCDCKs2xCDCqg1xIwKrDTGIsGpDDCKs2hCDCKs2xCBiOCKs2hCDCKs2xCDCqg0xiLBqQwwirNoQS+YRVm2IBQmrNsSChFUbYkHCuoN9QcKqDbEgYdWGWJDgQm1otSEWJKzaEAsSVm2IBYnxkLD8Uo3yGbw3DbsZvAPebH7RgDebXzTgzeYXDXi2DG82v2jAm80vGvBm84sGvNn8ogFvNoP3Bm83g3fAW55h7WbwDnjLM6zdDN4Bb3mGtZvBO+Atz7B2M3gHPFIG740HKoN38JjNLxrwZvOLBrzZ/KIBz5bhzeYXDXiz+UUD3mx+0YA3m1804M3mF93g7WbwDnjLM6zdDN4Bb3mGtZvBO+Atz7B2M3gHvOUZ1m4G74C3PMNCZfAOHqQM3sGDlME7eJAyeAcPymy18iBl8A4epAzewYOUwTt4kDJ4Bw9SBu+NByqDd/Aov+8HeY6DCCuDdxBhHSsc566wMngHEVYG7yDCyuAdRFgZvIMIK4N3EGFl8A4irAzeGxFYBu8gwsrgHURYGbyDCCuDdxAxHBFWBu8gwsrgHURYGbyDCCuDdxBhZfDeiMAyeAcRVgbvIMLK4B1EWBm8g4jhiLAyeAcRVgbvIMLK4B1EWBm8gwgrg3fJPMLK4F2QsDJ4FySsDN4FCS5TDi2Dd0HCyuBdkOBCbWgZvAsSVgbvgoSVwbsgMR4Sll9q6UEGb+a6/iyX+r3Geae8bzgNC6dj4TxIhX4fTwTjITCeBMbDYDwZjKeA8YB55wjmniOYfyYw/0xg/pnA/DOB+WcC888E5p9J0D+vElVe4nUvet6R0cHTsXhSAOOJYDwExpPAeBiMJ4PxFDCeCsYD5p8TmH9mMP/MYP6Zwfwzg/lnBvPPDOafGcw/s6B/XiWavEQXl8hBXiLKS5C8RJKXYHmJLC9R5CXk3+7y+qA9OFw/REhD5HWTH2/Jla7Qkho0RDQMX/kEkW8PuA+RrCFSNESqhkjTEDnjPfn2lOzYkA4aIlFDhDREkoYIa4hkDZGiIVI1RJqGyAlv/PenPseZj6AhEjVESEMkaYiwhkjWECkaIlVD5IQ3/vuTvEOkK4g8Oud9tkpS+HiIgVVUsopKUVHpGionnN37iUpUUSEVFfn3Je+ff63br2o9CJ9yWE/jMh0cxm2bh+iB//1TnPX3Qdm8f1DWAHc3yr3/+loAj1bBySp4sgrOVsGzVfBiFdzqvBmtTpzR6sxJVmdOsjpzktWZk6zOnGR15iSrMyeJzZyrQJUWeHkmyuvOKGfeE+jCAilIC0RpAZIWeNmjtfWl4Zb2BFhaIEsLFGmBV9/kHNaIUw5tT6BJC3RhAQ7SAlFa4NVhmml9NNOuQJEWeNXIJa0HJkqmHYEcpAWkuyi//CZvseOc655AkxbowgIlSAtEaQGSFkjSAiwtkKUFirTAiW9yKXsCTVrg9Td5c3Z1T6C+/CZv7vqBQJQWIGmBV9/ksh0uLaHvCbC0QJYWKNICVVrg5Te551Ughj2BLizQgrRAlBYgaYEkLcDSAllaoEgL1BMF9t7k1qQFXn+T10NvhfYE+stv8hbXfCAQpQVIWuDlOfngK7OztECWFijSAlVaoEkLSAdDHpz5PEuhPzhZ9surHsPq7yLHuKMRUYrQ/3oLpz86mWQFnizDJ8vwbBk+W4YvluGrZfhmGb4bhifLMyxZnmHJ8gxLlmdYsjzDkuUZlizPsGR5hiXLMyyhzLB/eBLKpLnyoBShf8a4CaVi/VPwKOXtn4Jny/DZMnyxDF8twzfL8N0wPAfL8JZnWLY8w7LlGZYtz7BseYZlyzMsW55h2fIMy5Zn2Iwyw648KJPmyoMyD648KFPbyoMyW608KBPQyoMyp6w8KNPEyoPi+VceFGf+h6eA+eei/L4f3HXcHyV+vJUIq2Bzf5TW8M4+qgRHlOCItMujf3+9dH+U2PBWogZH1NGIWoAjUvdH316j3B9lc7yVKMERMRxRhiMqcEQVjqjBEXU0oh7giLR99ve3bfdHeTtvJUpwRAxHlOGIChxRhSNqcEQdjejRnfmCSN9esL8gRTwkwkPKaBGbR/f8vxWp4iHBhdqidgrfT5AIDynhITEeEpRfus1vZLI4xAJu8ZLrBdziJdcLuMn6EHdyi9dc38kt3nN9J7d40fWdnM2SW7zq+k5usUrEndzsDGqyTsSd3OwcarJSxJ3c7BxqslbEndzsHGqyWsSd3OwcKlov4q5QxRUkK0bcFbq0gmjNiLtCFFcgcQXJshF3BRZXyOIKRVxBsnTEXaGJK3RpBdHqEXeFKK4gWT/irlDEFSQvTVwUREtI3BXEe0m0iMRdoYkrdGkF0ToSd4UorkDiCklcgcUVsrhCEVeQLCdxV2jiCpIFJe7bWZIVJe4KUVyBxBUki0rcFVhcIYsrFHGFKq4gWVnirtClFURrS9wVorgCiSskcQUWV8jiCkVcQbLExF2hiStIFpm4H4KQrDJxV4jiCiSuIFlo4q7A4gpZXKGIK1RxhSauIB45ka03EUOM4gUnFhGzFSfu9FYvxL7TW70R+05v9UrsOz2bprd6Kfad3uqt2Hd6q9di3+mt3ot9p7daemKhN1t74k5veq41W33iTm96rjVbf+JOb3quNVuB4k5veq41W4PiTg9UhGIBQqpCcQeyekn2nd7qLdl3eqvXZN/p2TS91Yuy7/RWb8q+01u9KvtOb/Wu7Du91cuyF3qz9Sju9KbnWrMVKe70pudaszUp7vSm51qzVSnu9KbnWrN1Ke70pudapMoUdyCg0hR3IKDaFHcgoOIUdyCUeWsDAipPcQcCqk9xBwIqUHEHAqpQcQcCKlGxACHVqLgDKb/231/lf0eCqlJxR4K6O+9+XAuqTsUdCapQxR0JqlLFHQmqVMUdCapWxR0JqljFHQmqWsWChFWu4o4EVa/ijgRVsOKOBFWx4o7EeEhQNSvuSFBFK+5IUFUr7khQZSvuSFB1KxYkrMIVdySoyhV3JKjSFXckqNoVdyTGQ4KqXnFHgipfcUeCql9xR4IqYHFHgqpg8SeVCaqExR8mqBoWf5igilj8YQK7LX5hgipj8YcJqo7FHya8YBxYJYs/TFClLP4wQdWy+MPEgExo/qlp5Ac30/nBzXR+cDOdH9xM5wc30/nBzXR+cDOdH9xM5wc30/nBzXR+cDOdH9xM5wc30/nBzXR+cDOdH9xM5wc30/nBzXR+cDOdH9zQ8oMbWn5wM50f3EznBzfT+cHNdH5wM50f3EznBzfT+cHNdH5wM50f3EznBzfT+cHNdH5wM50f3EznBzfT+cHNdH5wM50f3EznBzfT+cENLT+4oeUHN7T84IaWH9zQ8oMbWn5wQ8sPbmj5wQ0tP7ih5Qc3tPzghpcf3PDygxtefnDDyw9uePnBDS8/uOHlBze8/OCGlx/c8PKDG15+cMPLD254+cENLz+44eUHN7z84IaXH9zw8oMbXn5ww8sPbnj5wQ0vP7jh5Qc3vPzghpcf3PDygxtefnDDyw9uePnBDS8/uAHmBzfA/OAGmB/cAPODG2B+cAPMD26A+cENMD+4AeYHN8D84AaYH9zw8oOp/PPVOs4cVhymA5q2OfAe+OPR9MTu+A28WQXvVsFjMEsezZKTWfJklpzNkmez5MUsudkZNJqdQqPZOZTMzqFkdg4ls3MomZ1DyewcSmbnUBKbQzeFKq7w8pyU15M6nHlXoUsrpCCuEMUVSFzhZd/W1peHW9pVYHGFLK5QxBVefadzqH8ezaHtKjRxhS6twEFcIYorvDpaM62PZtpXKOIKr1q6pPWoW8m0p5CDuIJ4L+WX32nexlKuuwpNXKFLK5QgrhDFFUhcIYkrsLhCFlco4gonvtOl7Co0cYXX3+nN89VdhfryO71570cKUVyBxBVefafLlg9RQt9VYHGFLK5QxBWquMLL73RfL38uMewqdGmFFsQVorgCiSskcQUWV8jiCkVcoZ6osPtOtyau8Po7vZ5oKbSr0F9+p7dw6COFKK5A4govz9NH36KdxRWyuEIRV6jiCk1cQTxy8uDo9GkSqShUs0jFcjWLVCxXs0jFcjWLVCxXs0jFcjWLVCxXs0jFcjWLVCxXs0jFcjWLVCxXs0jFcjWLVCxXs0jFcjWLVCxXs0jFcjWLVCxXs0jFcjWLVCxXs0jFcjWLVMCqWaQCVs0iFcvVLFKxXM0iFcvVLFKxXM0iFcvVLFKxXM0iFcvVLFKxXM0iFcvVLFKxXM0iFcvVLAa96bnWcDWLQW96rjVczSIVy9UsBr3pudZwNYtULFezSAWsmsUAgqpmMYCgqlkMIKhqFgMIZd7agKCqWaQCVs0iFbBqFqmAVbNIBayaRSpg1SxSgatmkQpcNYtU4KpZpAJXzSIVuGoWqcBVs0gFrppFKnDVLFKBq2aRClw1i1TgqlmkAlfNIhW4ahapwFWzSAWumkUqcNUsUoGrZpEKXDWLVOCqWaQCV80iFbhqFqnAVbNIBa6aRSpw1SxSgatmkQpcNYtU4KpZpAJXzSIVuGoWqcBVs0gFr5rFwgRWzWJhAqtmsTCB3Ra/MIFVs1iYwKpZLEx4wTi4ahYLE1g1i4UJrJrFwsSATGD+iZPRahY3cJtXcd/Abd7EfQM3Ws1ikNu8iXuQ27yJe5DbvIl7kLNZcps3cQ9ym9UsBrnZGdRoNYtBbnYONVrNYpCbnUONVrMY5GbnUKPVLAa52TlUuJrFUKjiCrLVLIZCl1YQrmYxFKK4AokryFazGAosrpDFFYq4gmw1i6HQxBW6tIJwNYuhEMUVZKtZDIUiriB7J+NNQbiaxVAQ7yXhahZDoYkrdGkF4WoWQyGKK5C4QhJXYHGFLK5QxBVkq1kMhSauIFvNYmxnyVazGApRXIHEFWSrWQwFFlfI4gpFXKGKK8hWsxgKXVpBuJrFUIjiCiSukMQVWFwhiysUcQXZahZDoYkryFazGIcgZKtZDIUorkDiCrLVLIYCiytkcYUirlDFFZq4gnjkRLqaRSaFahY3EcPVLAa93Ru2B73dG7YHvd0btgc9m6a3e8P2oLd7w/agt3vD9qC3e8P2oLdbzeJGb7iaxaA3PdcarmYx6E3PtYarWQx603Ot4WoWg970XGu4msWgh6pmcQPCqmYxgOzesD3o7d6wPejt3rA96Nk0vd0btge93Ru2B73dG7YHvd0btge93Ru2b/SGq1kMetNzreFqFoPe9FxruJrFoDc91xquZjHoTc+1hqtZDHrTcy1WNYsBBFXNYgBBVbMYQFDVLAYQyry1AUFVsxhAUNUsBhBUNYsBBFXNYgBBVbO4AWFVsxhAyq/90XX/AwmsmsVAArtAbxzXAqtmMZDAqlkMJLBqFgMJrJrFQAKrZjGQwKpZDCSwahY3JLRqFgMJrJrFQAKrZjGQwKpZDCTGQwKrZjGQwKpZDCSwahYDCayaxUACq2ZxQ0KrZjGQwKpZDCSwahYDCayaxUBiPCSwahYDCayaxUACq2YxkMCqWQwksGoWSyoTWDWLhQmsmsXCBFbNYmECuy1+YQKrZrEwgVWzWJjwgnFw1SwWJrBqFgsTWDWLhYkBmdD8U9fID+6m84O76fzgbjo/uJvOD+6m84O76fzgbjo/uJvOD+6m84O76fzgbjo/uJvOD+6m84O76fzgbjo/uJvOD+6m84O76fzgbjo/uKPlB3e0/OBuOj+4m84P7qbzg7vp/OBuOj+4m84P7qbzg7vp/OBuOj+4m84P7qbzg7vp/OBuOj+4m84P7qbzg7vp/OBuOj+4m84P7qbzgztafnBHyw/uaPnBHS0/uKPlB3e0/OCOlh/c0fKDO1p+cEfLD+5o+cEdLz+44+UHd7z84I6XH9zx8oM7Xn5wx8sP7nj5wR0vP7jj5Qd3vPzgjpcf3PHygztefnDHyw/uePnBHS8/uOPlB3e8/OCOlx/c8fKDO15+cMfLD+54+cEdLz+44+UHd7z84I6XH9zx8oM7Xn5wB8wP7oD5wR0wP7gD5gd3wPzgDpgf3AHzgztgfnAHzA/ugPnBHTA/uMPlB+cSHp2Hvm1JbzJElbefxhJ2hCjX9RuE8ifnPJ7elKKaEqkpJTUlVlPKakpFTamqKTU1pa6lxGo+gtV8BKv5CFbzEazmI1jNR7Caj2A1H8FqPoLVfERW8xFZzUdkNR+R1XxEVvMRWc1HZDUfkdV8RFbzEVnNRxQ1H1HUfERR8xFFzUcUNR9R1HxEUfMRRc1HFDUfUdR8RFXzEVXNR1Q1H1HVfERV8xFVzUdUNR9R1XxEVfMRVc1HNDUf0dR8RFPzEU3NRzQ1H9HUfERT8xFNzUc0NR/R1HxEV/MRXc1HdDUf0dV8RFfzEV3NR3Q1H9HVfERX8xFdzUc8OusjIhX1pEhPKulJsZ5U1pMqelJVT6rpSel5i6jnLaKet4h63iLqeYuo5y2inreIet4i6nmLqOctop63ID1vQXregvS8Bel5C9LzFqTnLUjPW5CetyA9b0F63kLvGGbUO4cZ9Q5iRr2TmFHvKGbUO4sZ9Q5jRr3TmFHvOGbUO48Z9Q5kRr0TmVHvSGbUO5MZ9Q5lRr1TmVHvWGbUO5cZ9Q5mRr2TmVHvaGbUO5sZ9Q5nRr3TmVHveGbUO58Z9Q5oRr0TmlHviGbUO6MZ9Q5pRr1TmlHvmGbUO6cZ9Q5qRr2TmlHvqGbUO6sZ9Q5rRr3TmlHvuGbUO68Z9Q5sRr0Tm1HvyGbUO7MZ9Q5tRr1Tm1Hv2GbUO7cZ9Q5uRr2Tm1Hv6GbUO7sZ9Q5vRr3Tm1Hv+GbUO78Z9Q5wRr0TnFHvCGfUO8MZ9Q5xRr1TnFHvGGfUO8cZ9Q5yRr2TnFHvKGfUO8tJemc5Se8sJ+md5SS9s5wUWE8q60kVPamqJ9X0pPS8hd5ZTtI7y0l6ZzlJ7ywn6Z3lJL2znKR3lpP0znKS3llO0jvLSXpnOUnvLCfpneUkvbOcpHeWk/TOcpLeWU7SO8tJemc5Se8sJ+md5SS9s5ykd5aT9M5ykt5ZTtI7y0l6ZzlJ7ywn6Z3lJL2znKR3lpP0znKS3llO0jvLSXpnOUnvLCfpneUkvbOcpHeWk/TOcpLeWU7SO8tJemc5Se8sJ+md5SS9s5ykd5aT9M5ykt5ZTtI7y0l6ZzlJ7ywn6Z3lJL2znKR3lpP0znKS3llO0jvLSXpnOUnvLCfpneUkvbOcpHeWk/TOcpLeWU7SO8tJemc5Se8sJ+md5SS9s5ykd5aT9M5ykt5ZTtI7y0l6ZzlJ7ywn6Z3lJL2znKR3lpP0znKS3llO0jvLSXpnOUnvLCfpneUkvbOcpHeWk/TOcpLeWU7SO8uZ9M5yJr2znEnvLGfSO8uZAutJ6VUm1DvLmfTOcia9s5xJ7yxnioolTPW8hd5ZzqR3ljPpneVMemc5k95ZzqR3ljPpneVMemc5k95ZzkSKFY/1vMWjs5w3N7JJpRwOpFJtK1lq1A6e7tzXEtk957Q9TfwZjFHBMipYQQWrqGANFayDgj06Dft+sIgKRqhgqJ7/0Sne94Ohev6E6vkTqudPqJ7/4VnlHj/ASj6QKon+PF3ap2cT7TzLqfx5lnP969kN6uGpZjGoW3euUCU+gIqIUIQIlRChGBEqI0KVU6Bi3aDKAVQrefVUrRT6eDr3T1gVE6thYnVIrBwwsSImFqlj1bD+6ds/+wOshInFmFgZE6tgYlVMrIaJpe/la+4bVqn7WCVgYkVMLMLESphYjImVMbHe4OVT/cBqf2Ht7BnxtsVE/Cn+cQuGfGpEvUIj2hUa8WifoPWtEUzloBG3p7cwVk+nhLEeZZ+8HyyighEqWEIFY1SwjApWUMEqKlhDBUP1/A3V8zdUz99QPX9D9fwN1fM/ype6LZk/wDgeLSrP3T94lFn1XqiKCNUQoTog1KMMsF9C/eLrqVNaX+5O/Pnz+tP30KNssXdjESZWwsRiTKyMiVX0sSh8YLW/sHaOl1DfvEmKH0+P9nx5uOZ1Rq6dP4U8PjW3ztXcNldz+0zN5RDmam4Eb27aArScOH9u7kcb6AJtSBdoA6O3ofLWhhb225Dh25A+2tD324C+/PhJG/TXFLcQxtqG2yywu7Lj0DCxOiRWDG/AShtWTA+wIiYWvQGLNiyiB1gJE4sxsfTnD+bti5Rrf4BVMLHqG7DahtXqAyx9L5/j1luZH/VWfwPW1lv5c9zxMxYFTKz4Bqy6YdUHcyLpe/m87an0Qu0BVsLE4jdgbUYsqTzA0vfypW4r7PpovUUFE0vfy5fSP7D2xlb/535n1c2z1PppnXYbn9vv6pO/a0/+rj/3u/208B/8Lj75O3ryd7uep8Ut9YMe/I6f/F1+8nflyd/VJ3/Xnvxdf+53+wmlbftwaZ32fxef/B09+bv05O/4yd/lJ39Xnvzd7njpW6ZDj2H/d+3J3/XnfrefpvaD38Unf0dP/i49+bvd8XILb62/S/vv0X4u0w9+V578XX3yd+3J3/Xnfref8PKD38WD3/G+/fZTRn7wu/Tk7/bHS04fi9z93+Unf1ee/F198nftyd/15363f1z9B7/bHy9tXafGkNtfP/y33zy8qZCKSlJRYRWVrKJSVFSqikpTUekaKvtHkE9XUXn3m8q731Te/aby7jeVd7+pvPtN5d1vKu9+U3n3u8q731Xe/a7y7neVd7+rvPv99fclb1m8uX6ECal+BPN6UxCJ4fUhlrc9xM/Xv/6tQioqSUWFVVSyispvp5ePX9Znf0lJY1wTq6hkFZWiolJVVE7waj2vuyYhP1DpGiopqKhEFRVSUTnh3d8uTiihPFBhFZWsolJUVKqKSlNR6RozJwcVFZXVGauszlhldcYqqzNWWZ1xUVGpKipNRUXl3c8q735WefezyrufVd79rPLuZ5V3P6u8+1nl3c8q735WefeLyrtfVN79ovLuF5V3v6i8+0Xl3S8q735RefeLyrtfVN79qvLuV5V3v6q8+1Xl3a8q735Veferyrtfxd/9mv+5f0Q683ZCOn+6vpR2r7LMq0Zr8ftHY2xrfZFRwO7j4bTxNDCeDsbzILXxjUARDYjQgBIaEKMBZTSgggaE5qcjmqOOaJ6a0Dw1oXlqQvPUhOapCc1TE5qnJkFPvWlUBY3X/emn1JIUXu/YDgaUAhpQRAMiNKCEBsRoQBkNqKABVTQgNE+d0Dw1o3lqRvPUjOapGc1TM5qnZjRPzWiemgU99abRFDS6vEYOChpRQYMUNJKCBitoZAWNoqCh8J6X18duDGFN2Y4h0q4Kqai8bvdI/OF9y24AoXSNttSgoqJi/conqGz3PcXw6XaozypZRaWoqFQVlaaicsb7UuKHSt1TaUFFJaqokIpKUlFhFZWsolJUVKqKSlNROeHdj9vFZrd/7a5helBRiSoqpKKSVFRYRSWrqBQVlaqicsK7HyttKp9PvH1S6RoqMQQdmaTxbfEgnf58mawjU3RkuorMCScCfyQTdWRIR0bhvan7h2vr9rNaD4KuHNZLbJny94+2zVf08FfFpSdCuXX/FK4F8G4VfP8tNkEezZKTWfJklpzNkmez5MUsudkZNJqdQqPZOZTMzqFkdg4ls3MomZ1DyewcSmbnUBKbQzeFKq7w8py0XYLOmXcVurRCCuIKUVyBxBVe9m1b4jC3tKvA4gpZXKGIK7z6TuewBqRyaLsKTVyhSytwEFeI4gqvjtZM66OZ9hWKuMKrli5pPXVRMu0p5CCuIN5L+eV3egsy51x3FZq4QpdWKEFcIYorkLhCEldgcYUsrlDEFU58p0vZVWjiCq+/05vnq7sK9eV3OvUDhSiuQOIKr77TZTu5WkLfVWBxhSyuUMQVqrjCy+/0x2XcMewqdGmFFsQVorgCiSskcQUWV8jiCkVcoZ6osPtOtyau8Po7vZ6kK7Sr0F9+p7dw6COFKK5A4govz9NH36KdxRWyuEIRV6jiCk1cQTxy8uBA6WkS7cFptVjSdm635IMtl8hhdX6RY9wTeXBa8Xcq3DaVerQLdN5tQ+3RWScz9GSaPpmmZ9P02TR9MU1fTdM30/TdMj2ZnmvJ9FxLpudaMj3Xkum5lkzPtWR6riXTcy2ZnmsJZa5dgRLK9LkBKc+IJ14P1h6dejNDn0zTs2n6bJq+mKavpumbafpumZ6DaXrTcy2bnmvZ9FzLpudaNj3Xsum5lk3PtWx6rmXTc21GmWs3IJTpcwNCmRE3IJRJbgNCmbc2IJSpaANCmV02IJQJYwNCmQM2IBS3vgIVNE9dlF/7o4uZ26OMkvciKQ/so8vF2qNcibf2UiU8pISHVLSRvr8Muz3KlXgvUsND6nBILeAhqful7+97bo8SRN6LlPCQGA8p4yEVPKSKh9TwkDocUg94SNre++Be8PYoFei9SAkPifGQMh5SwUOqeEgND6nDIT2641+Q6fuCAAtTBGQiQKYMF9B5VJfgvUwVkAkvGBe1MwN/xESATAmQiQGZwPxTZ6PVLG7gNq/ivoHbvIn7Bm60msUgt3kT9yC3eRP3ILd5E/cgZ7PkNm/iHuQ2q1kMcrMzqNFqFoPc7BxqtJrFIDc7hxqtZjHIzc6hRqtZDHKzc6hwNYuhUMUVZKtZDIUurSBczWIoRHEFEleQrWYxFFhcIYsrFHEF2WoWQ6GJK3RpBeFqFkMhiivIVrMYCkVcQfZOxpuCcDWLoSDeS8LVLIZCE1fo0grC1SyGQhRXIHGFJK7A4gpZXKGIK8hWsxgKTVxBtprF2M6SrWYxFKK4AokryFazGAosrpDFFYq4QhVXkK1mMRS6tIJwNYuhEMUVSFwhiSuwuEIWVyjiCrLVLIZCE1eQrWYxDkHIVrMYClFcgcQVZKtZDAUWV8jiCkVcoYorNHEF8ciJcDWL21pHvprFELFbzWKhN3vD9kJv9obthd7sDdsLPZumN3vD9kJv9obthd7sDdsLvdkbthd6s9UsBr3dahYLvem51m41i4Xe9Fxrt5rFQm96rrVbzWKhNz3X2q1msdAjVbMYQFDVLBYgszdsL/Rmb9he6M3esL3Qs2l6szdsL/Rmb9he6M3esL3Qm71he6E3e8P2oLdbzWKhNz3X2q1msdCbnmvtVrNY6E3PtXarWSz0pudau9UsFnrTcy1UNYsFCKmaxQKEVM1iAUKqZrEAocxbGxBSNYsFCKmaxQKEVM1iAUKqZrEAIVWzGEBQ1SwWIOXX/uC6/wUJq5rFgoR1gd5yXAurmsWChFXNYkHCqmaxIGFVs1iQsKpZLEhY1SwWJKxqFgMJrJrFgoRVzWJBwqpmsSBhVbNYkBgPCauaxYKEVc1iQcKqZrEgYVWzWJCwqlkMJLBqFgsSVjWLBQmrmsWChFXNYkFiPCSsahYLElY1iwUJq5rFgoRVzWJBwqpmcU9lwqpmcWfCqmZxZ8KqZnFnwrot/s6EVc3izoRVzeLOhBeMQ6tmcWfCqmZxZ8KqZnFnYkAmMP8Ug0J+8E3EcH7woLebszTo7eYsDXq7OUuDnk3T281ZGvR2c5YGvd2cpUFvN2dp0NvND77RG84PHvSm51rD+cGD3vRcazg/eNCbnmsN5wcPetNzreH84EEPlR98A8LKDx5AdnOWBr3dnKVBbzdnadCzaXq7OUuD3m7O0qC3m7M06O3mLA16uzlLN3rD+cGD3vRcazg/eNCbnmsN5wcPetNzreH84EFveq41nB886E3PtVj5wQMIKj94AEHlBw8gqPzgAYQyb21AUPnBAwgqP3gAQeUHDyCo/OABBJUffAPCyg8eQMqv/VEC5UACyw8eSGBHEsdxLbD84IEElh88kMDygwcSWH7wQALLDx5IYPnBAwksP/iGhJYfPJDA8oMHElh+8EACyw8eSIyHBJYfPJDA8oMHElh+8EACyw8eSGD5wTcktPzggQSWHzyQwPKDBxJYfvBAYjwksPzggQSWHzyQwPKDBxJYfvBAAssPXlKZwPKDFyaw/OCFCSw/eGHCy7+Dyw9emMDygxcmvGAcXH7wwgSWH7wwgeUHL0wMyITmn9o/X63jzGHFYTqgaZsD74E/Hk3P7I63fzar4N0qeAxmyaNZcjJLnsySs1nybJa8mCU3O4NGs1NoNDuHktk5lMzOoWR2DiWzcyiZnUPJ7BxKYnPoplDFFV6ek/J6Uocz7yp0aYUUxBWiuAKJK7zs29r68nBLuwosrpDFFYq4wqvvdA71z6M5tF2FJq7QpRU4iCtEcYVXR2um9dFM+wpFXOFVS5e0HnUrmfYUchBXEO+l/PI7zdtYynVXoYkrdGmFEsQVorgCiSskcQUWV8jiCkVc4cR3upRdhSau8Po7vXm+uqtQX36nN+/9SCGKK5C4wqvvdNnyIUrouwosrpDFFYq4QhVXePmd7uvlz7cd7F2FLq3QgrhCFFcgcYUkrsDiCllcoYgr1BMVdt/p1sQVXn+n1xMthXYV+svv9BYOfaQQxRVIXOHlefroW7SzuEIWVyjiClVcoYkriEdOHhydPk2CmkI1C2qWq1lQs1zNgprlahbULFezoGa5mgU1y9UsqFmuZkHNcjULaparWVCzXM2CmuVqFtQsV7OgZrmaBTXL1SyoWa5mQc1yNQtqlqtZULNczYKa5WoW1MCqWVADq2ZBzXI1C2qWq1lQs1zNgprlahbULFezoGa5mgU1y9UsqFmuZkHNcjULaparWVCzXM1i0Jueaw1Xsxj0pudaw9UsqFmuZjHoTc+1hqtZULNczYIaWDWLAQRVzWIAQVWzGEBQ1SwGEMq8tQFBVbOgBlbNghpYNQtqYNUsqIFVs6AGVs2CGlw1C2pw1SyowVWzoAZXzYIaXDULanDVLKjBVbOgBlfNghpcNQtqcNUsqMFVs6AGV82CGlw1C2pw1SyowVWzoAZXzYIaXDULanDVLKjBVbOgBlfNghpcNQtqcNUsqMFVs6AGV82CGlw1C2pw1SyowVWzoAZXzYIaXDULanDVLKjhVbNYmMCqWSxMYNUsFiaw2+IXJrBqFgsTWDWLhQkvGAdXzWJhAqtmsTCBVbNYmBiQCcw/pWy0msUN3OZV3Ddwmzdx38CNVrMY5DZv4h7kNm/iHuQ2b+Ie5GyW3OZN3IPcZjWLQW52BjVazWKQm51DjVazGORm51Cj1SwGudk51Gg1i0Fudg4VrmYxFKq4gmw1i6HQpRWEq1kMhSiuQOIKstUshgKLK2RxhSKuIFvNYig0cYUurSBczWIoRHEF2WoWQ6GIK8jeyXhTEK5mMRTEe0m4msVQaOIKXVpBuJrFUIjiCiSukMQVWFwhiysUcQXZahZDoYkryFazGNtZstUshkIUVyBxBdlqFkOBxRWyuEIRV6jiCrLVLIZCl1YQrmYxFKK4AokrJHEFFlfI4gpFXEG2msVQaOIKstUsxiEI2WoWQyGKK5C4gmw1i6HA4gpZXKGIK1RxhSauIB45ka5mwaxQzeImYriaxaC3e8P2oLd7w/agt3vD9qBn0/R2b9ge9HZv2B70dm/YHvR2b9ge9HarWdzoDVezGPSm51rD1SwGvem51nA1i0Fveq41XM1i0Jueaw1Xsxj0UNUsbkBY1SwGkN0btge93Ru2B73dG7YHPZumt3vD9qC3e8P2oLd7w/agt3vD9qC3e8P2jd5wNYtBb3quNVzNYtCbnmsNV7MY9KbnWsPVLAa96bnWcDWLQW96rsWqZjGAoKpZDCCoahYDCKqaxQBCmbc2IKhqFgMIqprFAIKqZjGAoKpZDCCoahY3IKxqFgNI+bU/uu5/IIFVsxhIYBfojeNaYNUsBhJYNYuBBFbNYiCBVbMYSGDVLAYSWDWLgQRWzeKGhFbNYiCBVbMYSGDVLAYSWDWLgcR4SGDVLAYSWDWLgQRWzWIggVWzGEhg1SxuSGjVLAYSWDWLgQRWzWIggVWzGEiMhwRWzWIggVWzGEhg1SwGElg1i4EEVs1iSWUCq2axMIFVs1iYwKpZLExgt8UvTGDVLBYmsGoWCxNeMA6umsXCBFbNYmECq2axMDEgE5h/ylEhP/gmYjg/eNDbzVka9HZzlga93ZylQc+m6e3mLA16uzlLg95uztKgt5uzNOjt5gff6A3nBw9603Ot4fzgQW96rjWcHzzoTc+1hvODB73pudZwfvCgh8oPvgFh5QcPILs5S4Pebs7SoLebszTo2TS93ZylQW83Z2nQ281ZGvR2c5YGvd2cpRu94fzgQW96rjWcHzzoTc+1hvODB73pudZwfvCgNz3XGs4PHvSm51qs/OABBJUfPICg8oMHEFR+8ABCmbc2IKj84AEElR88gKDygwcQVH7wAILKD74BYeUHDyDl1/4ogXIggeUHDySwI4njuBZYfvBAAssPHkhg+cEDCSw/eCCB5QcPJLD84IEElh98Q0LLDx5IYPnBAwksP3gggeUHDyTGQwLLDx5IYPnBAwksP3gggeUHDySw/OAbElp+8EACyw8eSGD5wQMJLD94IDEeElh+8EACyw8eSGD5wQMJLD94IIHlBy+pTGD5wQsTWH7wwgSWH7ww4eXfweUHL0xg+cELE14wDi4/eGECyw9emMDygxcmBmQC808lPcgPzlzX3+VSvxc58cD4jaeB8XQwngep1m8EimhAhAaU0IAYDSijARU0IDQ/HdEcdUTz1ITmqQnNUxOapyY0T01onprQPDUJeupNoypovO5PTzx9OoA6GFAKaEARDYjQgBIaEKMBZTSgggZU0YDQPHVC89SM5qkZzVMzmqdmNE/NaJ6a0Tw1o3lqFvTUm0ZT0OjyGjkoaEQFDVLQSAoarKCRFTSKgobCe15eH7tHh/aHCqmovG73H2zkla7RlhpUVFSsX/kEle9Pzg+VrKJSVFSqikpTUTnjffn+5O3Yzg4qKlFFhVRUkooKq6hkFZWiolJVVJqKygnv/sFR0nF0JKioRBUVUlFJKiqsopJVVIqKSlVROeHdPzgkPFS6hsqjY+SnyySNb4sYWEcm68gUHZmuInPCicAfyUQdGdKRUXhv8v7h2rr9rNaDoCuH9awv08FR37b5ih743z9FZ58I5eb9U7gWwLtV8P232AR5NEtOZsmTWXI2S57Nkhez5GZn0Gh2Co1m51AyO4eS2TmUzM6hZHYOJbNzKJmdQ0lsDt0UqrjCy3NSXvdUOfOuQpdWSEFcIYorkLjCy76trS8Pt7SrwOIKWVyhiCu8+k7nsAakcmi7Ck1coUsrcBBXiOIKr47WTOujmfYVirjCq5YuaT11UTLtKeQgriDeS/nld3oLMudcdxWauEKXVihBXCGKK5C4QhJXYHGFLK5QxBVOfKdL2VVo4gqvv9Ob56u7CvXld3rz3o8UorgCiSu8+k6X7eRqCX1XgcUVsrhCEVeo4govv9M9rwox7Cp0aYUWxBWiuAKJKyRxBRZXyOIKRVyhnqiw+063Jq7w+ju9nqQrtKvQX36nt3DoI4UorkDiCi/P00ffop3FFbK4QhFXqOIKTVxBPHLy4EDpaRL1wWm1X15OGVbnFznGPZGofL3yibcN1UdnnczQk2n6ZJqeTdNn0/TFNH01Td9M03fL9GR6riXTcy2ZnmvJ9FxLpudaMj3Xkum5lkzPtWR6riWUuXYFSijT5wakPCOeeD1YfXTqzQx9Mk3Ppumzafpimr6apm+m6btleg6m6U3PtWx6rmXTcy2bnmvZ9FzLpudaNj3Xsum5lk3PtRllrt2AUKbPDQhlRtyAUCa5DQhl3tqAUKaiDQhldtmAUCaMDQhlDtiAUNz6ClTQPHVRfu2PLmaujzJK3osEVp26PsqVeGsvVcJDSnhI2hXhDy7Dro9yJd6L1PCQOhxSC3hI6n7p+/ue66MEkfciJTwkxkPKeEgFD6niITU8pA6H1AMekrb3PrgXvD5KBXovUsJDYjykjIdU8JAqHlLDQ+pwSI/u+Bdk+r4gwMIUAZkIkCnDBXQe1SV4L1MFZMILxkXtzMAfMREgUwJkYkAmMP/UyGg1ixu4zau4b+A2b+K+gRutZjHIbd7EPcht3sQ9yG3exD3I2Sy5zZu4B7nNahaD3OwMarSaxSA3O4carWYxyM3OoUarWQxys3Oo0WoWg9zsHCpczWIoVHEF2WoWQ6FLKwhXsxgKUVyBxBVkq1kMBRZXyOIKRVxBtprFUGjiCl1aQbiaxVCI4gqy1SyGQhFXkL2T8aYgXM1iKIj3knA1i6HQxBW6tIJwNYuhEMUVSFwhiSuwuEIWVyjiCrLVLIZCE1eQrWYxtrNkq1kMhSiuQOIKstUshgKLK2RxhSKuUMUVZKtZDIUurSBczWIoRHEFEldI4gosrpDFFYq4gmw1i6HQxBVkq1mMQxCy1SyGQhRXIHEF2WoWQ4HFFbK4QhFXqOIKTVxBPHIiXc2iR4VqFjcRw9UsBr3dG7YHvd0btge93Ru2Bz2bprd7w/agt3vD9qC3e8P2oLd7w/agt1vN4kZvuJrFoDc91xquZjHoTc+1hqtZDHrTc63hahaD3vRca7iaxaCHqmZxA8KqZjGA7N6wPejt3rA96O3esD3o2TS93Ru2B73dG7YHvd0btge93Ru2B73dG7Zv9IarWQx603Ot4WoWg970XGu4msWgNz3XGq5mMehNz7WGq1kMetNzLVY1iwEEVc1iAEFVsxhAUNUsBhDKvLUBQVWzGEBQ1SwGEFQ1iwEEVc1iAEFVs7gBYVWzGEDKr/3Rdf8DCayaxUACu0BvHNcCq2YxkMCqWQwksGoWAwmsmsVAAqtmMZDAqlkMJLBqFjcktGoWAwmsmsVAAqtmMZDAqlkMJMZDAqtmMZDAqlkMJLBqFgMJrJrFQAKrZnFDQqtmMZDAqlkMJLBqFgMJrJrFQGI8JLBqFgMJrJrFQAKrZjGQwKpZDCSwahZLKhNYNYuFCayaxcIEVs1iYQK7LX5hAqtmsTCBVbNYmPCCcXDVLBYmsGoWCxNYNYuFiQGZ0PxT08gPbqbzg5vp/OBmOj+4mc4Pbqbzg5vp/OBmOj+4mc4Pbqbzg5vp/OBmOj+4mc4Pbqbzg5vp/OBmOj+4mc4Pbqbzg5vp/OBmOj+4oeUHN7T84GY6P7iZzg9upvODm+n84GY6P7iZzg9upvODm+n84GY6P7iZzg9upvODm+n84GY6P7iZzg9upvODm+n84GY6P7iZzg9upvODG1p+cEPLD25o+cENLT+4oeUHN7T84IaWH9zQ8oMbWn5wQ8sPbmj5wQ0vP7jh5Qc3vPzghpcf3PDygxtefnDDyw9uePnBDS8/uOHlBze8/OCGlx/c8PKDG15+cMPLD254+cENLz+44eUHN7z84IaXH9zw8oMbXn5ww8sPbnj5wQ0vP7jh5Qc3vPzghpcf3PDygxtefnADzA9ugPnBDTA/uAHmBzfA/OAGmB/cAPODG2B+cAPMD26A+cENMD+4weUH11D++WodZw4rDtMBTdsceA/88Wj6/e74AG9WwbtV8BjMkkez5GSWPJklZ7Pk2Sx5MUtudgaNZqfQaHYOJbNzKJmdQ8nsHEpm51AyO4eS2TmUxObQTaGKK7w8J+X1pA5n3lXo0gopiCtEcQUSV3jZt7X15eGWdhVYXCGLKxRxhVff6Rzqn0dzaLsKTVyhSytwEFeI4gqvjtZM66OZ9hWKuMKrli5pPepWMu0p5CCuIN5L+eV3mrexlOuuQhNX6NIKJYgrRHEFEldI4gosrpDFFYq4wonvdCm7Cv9/dee2GscVBdFf6svpS32OE/JgCE5InED+Pl17rBkZepA9M3WoehTyoRYWpzdqTe21yxOev9PXJ992mrA9faevT+97CaM8YZInPHun12sfYh1wmtDkCYs8YZUnbPKEp+803pY/r+NwmgB1wj7IE0Z5wiRPmOUJTZ6wyBNWecL2woTTO73v8oTn7/TbJ1rW6TQBT9/p6+vQewmjPGGSJzw9pz/6XRRNnrDIE1Z5wiZP2OUJ8jcndz46/bKIcdXbLBiSa7Mo+tgN20Ufu2G76GM3bBd9i6aP3bBd9LEbtos+dsN20cdu2C76WJsF6XNtFkUfPWtzbRZFHz1rc20WRR89a3NtFkUfPWtzbRZF72SzIJCVzaKAYjdsF33shu2ij92wXfQtmj52w3bRx27YLvrYDdtFH7thu+hjN2yTPtdmUfTRszbXZlH00bM212ZR9NGzNtdmUfTRszbXZlH00bPWymZRQE42iwJyslkUkJPNooBc5tYVyMlmUUBONosCcrJZFJCTzaKAnGwWBLKyWRRQ52v/wbr/QvKyWRSS1wK9+riWl82ikLxsFoXkZbMoJC+bRSF52SwKyctmUUheNgsimdksCsnLZlFIXjaLQvKyWRRS80PyslkUkpfNopC8bBaF5GWzKCQvmwWRzGwWheRlsygkL5tFIXnZLAqp+SF52SwKyctmUUheNotC8rJZFJKXzeJSZfKyWVyYvGwWFyYvm8WFyWxbfDF52SwuTF42iwuT38s4N5vFhcnLZnFh8rJZXJiaIZPZ82maQ20WB3jmKu4DPHMT9wEearMgeeYmbpJnbuImeeYmbpK3WPLMTdwkz7RZkDx2gobaLEgeO0NDbRYkj52hoTYLksfO0FCbBcljZ6jYZsGETZ6gtVkwAeoEsc2CCaM8YZInaG0WTGjyhEWesMoTtDYLJuzyBKgTxDYLJozyBK3NggmrPEG7k/FIENssmCD/XxLbLJiwyxOgThDbLJgwyhMmecIsT2jyhEWesMoTtDYLJuzyBK3Ngn/O0tosmDDKEyZ5gtZmwYQmT1jkCas8YZMnaG0WTIA6QWyzYMIoT5jkCbM8ockTFnnCKk/Q2iyYsMsTtDYLfghCa7NgwihPmOQJWpsFE5o8YZEnrPKETZ6wyxPkb07UNot56mCzOEKCbRakz92wTfrcDdukz92wTfoWTZ+7YZv0uRu2SZ+7YZv0uRu2SZ9rszjog20WpI+etcE2C9JHz9pgmwXpo2dtsM2C9NGzNthmQXorm8UB5GWzIFDuhm3S527YJn3uhm3St2j63A3bpM/dsE363A3bpM/dsE363A3bB32wzYL00bM22GZB+uhZG2yzIH30rA22WZA+etYG2yxIHz1rvWwWBLKyWRDIymZBICubBYFc5tYVyMpmQSArmwWBrGwWBLKyWRDIymZxAHnZLAjU+dp/tO6fSGY2CyKZLdDjx7XMbBZEMrNZEMnMZkEkM5sFkcxsFkQys1kQycxmcSC52SyIZGazIJKZzYJIZjYLIjU/JDObBZHMbBZEMrNZEMnMZkEkM5vFgeRmsyCSmc2CSGY2CyKZ2SyI1PyQzGwWRDKzWRDJzGZBJDObBZHMbBZVZTKzWRSTmc2imMxsFsVkti2+mMxsFsVkZrMoJr+XcXY2i2Iys1kUk5nNopiaIZPb8wk9+sGI7gcjuh+M6H4wovvBiO4HI7ofjOh+MKL7wYjuByO6H4zofjCi+8GI7gcjuh+M6H4wovvBiO4HI7ofjOh+MNz6wXDrByO6H4zofjCi+8GI7gcjuh+M6H4wovvBiO4HI7ofjOh+MKL7wYjuByO6H4zofjCi+8GI7gcjuh+M6H4wovvBcOsHw60fDLd+MNz6wXDrB8OtHwy3fjDc+sFw6wfDrR8Mt34w/PrB8OsHw68fDL9+MPz6wfDrB8OvHwy/fjD8+sHw6wfDrx8Mv34w/PrB8OsHw68fDL9+MPz6wfDrB8OvHwy/fjD8+sHw6wfDrx8Mv34w/PrB8OsHw68fDL9+MPz6wfDrB8OwHwzDfjAM+8Ew7AfDsB8Mw34wDPvBMOwHw7AfDMN+MAz7wXDrB0/TttwpQ83XF0Jtuo3JcV6v585rSD9wbnzw3PTgufnnz824pzxuy1sVennXhB4n3M6ND56bHjw3P3iuPXhuefDc+uC501G1jNvbuWX/7tzZ78fbdvZ2c9yHW8reJQU9Us5v5stTxi4pU5eUuUtKez5lvz77B2znKUuXlLVLytYlZe+Sgh4p89Al5QV3H9e/OB2J5ylTl5S5S0rrkrJ0SVm7pGxdUvaXpoznT/4ZPVLa0CXl+bs/zreUdv5zaVOXlLlLSuuSsnRJWbukbOqUNg73Vg8N++0144B3Ocu3k3eVzdt43ZOF4d3kbMPtJB49eae3/CMnx4dPTj998vjq309/ff70y++//X2c4Tf/+fLr189/fPn25df//rx85/i3/wM="},{"name":"add_to_tally_public","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"candidate","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"5Z3Rjl23kUX/Rc/G4LCKrGL5VwaDgZI4AwGGHMTKAAPD/z5U0rdbhm7c3rRoZ+U+BbYPTxdVVb06W1dLP7z50zd/+Nv//Pe793/+7vs3X//nD2++/e6Pbz+8++79+qcf3lz/0a6//9vv//L2/cd/8f2Ht3/98Obr66s337z/0/rfH7968+d3337z5msf7cevPnuuxnh6sjKfn21md57tLW8P9zb789M17jwc5vn0cNjwTx/+r68+lt1+Tdntcnt6tF2j/6aF26/69a72Uvd4pe7WWr893fL6+bqzP18yR5uf1+2H6v7H2/vRt4+jb4+jb8+jb59H314n327X0be3o2+3o28/uqt2dFft6K7a0V21o7tqR3fVju6qH91VP7qrfnRX/eiu+tFd9aO76kd31Y/uqh/dVT+6q/3orvaju9qP7mo/uqv96K72o7vaj+5qP7qr/eiu9qO7Oo7u6ji6q+Poro6juzqO7uo4uqvj6K6Oo7s6ju7qOLqrcXRX4+iuxtFdjaO7Gkd3NY7uahzd1Ti6q3F0V+PorubRXc2ju5pHdzWP7moe3dU8uqt5dFfz6K7m0V3No7s6j+7qPLqr8+iuzqO7Oo/u6jy6q/Pors6juzqP7uo8uqt1dFfr6K7W0V2to7taR3e1ju5qHd3VOrqrdXRX6+iutus6+/p29vV29vVnPw9x9bOvP/uJiOvsRyKus5+JuM5+KOI6u7Xt7Na2s1vbzm7t4U8xHf4Y0+HPMf26DzJ1t9unzbq7PT99/1NyPufTw9Gvex/v+1Ur/oU/aih8P3g6UeoJ5cNMTyeafMLkEy6f6PKJIZ8I+UTKJ+Sem9xzl3vucs9d7rnLPXe55y733OWeu9xzl3vucs+73PMu97zLPe9yz7vc8y73vMs973LPu9zzLvd8yD0fcs+H3PMh93zIPR9yz4fc8yH3fMg9H3LPQ+55yD0Puech9zzknofc85B7HnLPQ+55yD1Puecp9zzlnqfc85R7nnLPU+55yj1Puecp93zKPZ9yz6fc8yn3fMo9n3LPp9zzKfd8yj2fcs9L7nnJPS+55yX3vOSel9zzkntecs9L7nmpPbfrkk80+YTJJ1w+0eUTQz4R8omUT0z5hNzzJve8yT1vcs+b3PMm97zJPW9yz5vcczmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHMzmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmHczmH8/s53Prt6Ho6tH4PuP/k3D2/et7+SFVr1p6fbj3uPD3WT8xPT4/1beb56bt/Wmu08tvD1l55eI7rVscc/fM/2uX3A8F/18v6I122P9JlxyNdNh7psvlIl52//WVbPV/2tb8iYzzXMfrLX5Bh3m/lF7n8fv+3VjjlN3b5xi7f2eV3dvmDUv6Ie+Vjvu/fLx/zff9u+e317zzpn/8fxd5881zfPDc2z8Xmudw8NzfP1d45uzbPtc1zm/Nim/Nim/Nim/Nim/Nim/Nim/Nim/Pim/Pim/Pim/Pim/Pim/Pim/Pim/Pim/Pim/Pim/PSN+elb85L35yXvjkvfXNe+ua89M156Zvz0jfnpW/Oy9icl7E5L2NzXsbmvIzNeRmb8zI252VszsvYnJexOS+xOS+xOS+xOS+xOS+xOS+xOS+xOS+xOS+xOS+xOS+5OS+5OS+5OS+5OS+5OS+5OS+5OS+5OS+5OS+5OS9zc17m5rzMzXmZm/MyN+dlbs7L3JyXuTkvc3Ne5ua81Oa81Oa81Oa81Oa81Oa81Oa81Oa81Oa81Oa81N68jOva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"},{"name":"get_vote","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"candidate","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2c20/bMBTGk1IgUO70mhZIuTOYVOgoe0GC7WnStgce9l7awtC2VmqLtP3z1XDqQw/WGXLYiVVLRAo5Dvb5fv7suC1gXGd4uPIUxyS6px5w70JeK/93HDPmqrgqp/iS1OiMq8RwfEaFgrxedrv1P8Fdu9n6HXTu+0HnJrju3LebvceWVzLwUKaAq5vvKydTKLnaq9TDmYCCrDP9cE6h77vyPtRbRvcg3+zDuSDj21b/w89O48fX+1/XrS5WnHCetoKeqofItjLK9rHT7nfrjf5ls9lt9Xq4NTVag39knEUZv9fv2p+auNXkyzJ9a3V7d502bjWlmUlYOCPjwGGb1idizKYVLXXcAxTPIB6Pn+c4pn5WRN5Z5C+Xf8KrlOLVtOLVAqozi/xLxeCfi3QhN5RBLypzYgyY45wXc/x5Txad4ViDr3OKv7hf8zJmnJcVPG6TSG8e6S7K2HV4XyZhbU/K3MCxiLRX2D2vNkQfl5ynx3Nr2QriWWbnGa5l/P0cztlVxM6T97QqvEorXi0pXi2gOpghHYN/LtKF3FBOE9p8Xpy9E9oZDS8yBE/GsBcZQpvPi9qN0M5qeJEleLKGvcgS2ozzIny9z2l4kSN4coa9yBHajPMi1M5reJEnePKGvcgT2oxenAntgoYXBYKnYNiLAqHN6MWp0PY1vPAJHt+wFz6hzefFSfh+qKjhRZHgKRr2okhoM66d4fuLkoYXJYKnZNiLEqHN+Iw0hPaahhdrBM+aYS9ALypzxkLmtIXM/hgwe0rMo10N1891DS/WCZ51w16AXlRmfwyYPSXm0a61hPaGhhcbBM+GYS9ALypzxkLmtIXMvoXMOQuZS6/MRpjHYd3wlJhH+yz8PBxoeBEQPIFhL0AvKnNhDJg9JebRroU//yxreFEmeMqGvSgT2oyf4cP3MJsaXmwSPJuGvQC9qMy+hcyrFjKnLWTOWMictZA5ZyFz3kLmgoXMNq7PRQuZSxYy27g+2/g6aON8Hod1w1NiHu1a+BeZWxpebBE8W4a92CK0GT9vh79z3dbwYpvg2TbsBehFZS5ayJy2kNm3kPl1bphhzlnInLWQ+XXdeBmzp8Q82rWa0N7R8GKH4Nkx7AXoRWXOWsicsZB500JmfwyYPSXm0a6G2rsaXuwSPLuGvQC9qMzlMWBOOqO9IRdunDzVZkrhAc8chdFRGFMoXkGe7QG3w7ePA4/PHtLaZ/ejQs5xKO/Hql1tiLxvYuiTyHvInzf8m7MjmWtS5j4kvHorY5d5nI5QXhfpwP0kis/dUV2oB37AegDsYu/XgYwxu9puV2m3gOocoHaHSjsow1gL76roOY9jbunMa+EDPMvn8ppwRvvSYKfxQHLi8gUL53CuxvFcp5zRmuqgsXEUTxzFE7ymcfKIPY+w17DX73Trt62rVv1x87SLcF3iitEHqJxE93GMt7EmUDxB1B08c/VQ3cDhfZz3EEOAyqAX57Za8ASWMXX7aRLV+SLNVrdQigPnAk4YR8g5j/qUQDpqf/G/EdhDOf4CFKrWnC5CAAA=","debug_symbols":"7dzdSltRFEXhd8m1lD3n2r++SiklbW0JSCw1For47o3tSaJ4qIJSGW2uJGZnZ511M/Tmu158Ovtw9eX9av354nJx+vZ6cX7xcblZXay3r64X6U399cvLr8v17evLzfLbZnGaThZn60/bnzcni8+r87PFaRTdnDw419ymky33/dneb96dbK9uz7q6azrZU31wdX/O1T32V89MPZ51dfPu6v7waqW5uz3ymD7k0eoj3zCiT4fHnW9QzjNnVXZzaxzO2mPu3jzy7uJS4nA6p2l4kYc3efggD5/Jwxfy8JU8fCMP38nDD/DwJhfW5MKaXFiTC2tyYU0urMmF9QsUVqnGbiI5PTL+k//1S7uVNJc7d9Zp8E4dfEAHj0QdXNTBTR08qINn6uCFOnilDk4tZ1DLGdRyZmo5M7WcmVrOTC1nppYzU8uZqeXM1HJmajkztZyFWs5CLWehlrNQy1mo5SzUchZqOQu1nIVazkItZ6WWs1LLWanlrNRyVmo5K7WclVrOSi1npZazUsvZqOVs1HI2ajkbtZyNWs5GLWejlrNRy9mo5WzUcnZqOTu1nJ1azk4tZ6eWs1PL2anl7NRydmo5O7Wcg1rOQS3noJZzUMs5qOUc1HIOajkHtZyDWs5BLacSNZ1K1HYqUeOpRK2nEjWfStR+br8UOzm1oErUhCphGypsQ4VtqLANFbahL8EQvdLk2IYK21BhGypsQ4VtqLENNbahxjbU2Ia+BDT0SpNjG2psQ7G+kLDAkLDCkLDEkLDGkLDIkLDKkLDMkLDOkLDQkLDSkLDUkLDWkLDYkLDakLDckLDekLDgkLDikLDkkLDmkLDokLDqkLDskLDukLDwkLDykLD0kLD2kLD4kLD6kLD8kLD+kLAAkbACkbAEkbAGkbAIkbAKkbAMkbAOkbAQkbASkbAUkbAWkbAYkbAakbAckbAekbAgkbAikbAkkbAmkbAokbAqkbAskbAukbAwkbAykbA0kbA2kbA4kbA6kbA8kbA+kbBAkbBCkbBEkbBGkbBIkbBKkbBMkbBOkbFOkbFOkbFOkbFOkRO1ocY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RcY6RYF1igLrFAXWKQqsUxSJ2tDAOkWBdYoC6xQF1ikKrFMUWKcosE5RYJ2iwDpFgXWKAusUBdYpCqxTFFinKLBOUTzBKerx2OSl78ZRdb73LXOnY3+61MNMvc8djtgvJSf9+XANT2drv/Os4ZmzOep0Npd27+y0F/2fe4m+O5ur5vbi415m9xLHvczuJR/3MruXctzL7F7qcS+ze2n/0F7U9nupz91LP+5ldi/j7+9F5bCX+sheRt79/aVRDkt05OkBItEfQPQHMP0Bgv4AmfsA21ffl99Wyw/nZ5fbz9y+ebX+uFldrKeXmx9ff7+zPfsT"},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2b3U7bQBCF18GhBoOb2HGckEAIBaTehRSScMfLtM/d60p9haqss6Mclmm0UcdLVool5LG9O+ebsz+EyERqfSSvP5GJ2+Z8rN4f1ObFnGf/dzwI5po1yRkFwtkKhPMoEM5YkDNiOPU5NrFed3rNfVLr9fjuIXbWA30Ez9W2RLZqYgJ8eC1V6Wr2fAzJEVwZ8Ng8o7PGSc0zBEtNkXUbuEeFtuAe6RzBPdrBSCcxpgjX+5RskOXyvs4+XcOJyUXcKcT4bAzWxQ3V2Jav8bGRMXn1rqExqVcx+d42uRO4pjE4NbHgb44H1I7Mz6k1F2KIR9CW2pEfLWDVx7narJfTLf1iq18GbY6hn7230DWNtfaqa2J9btOeAPkb8HCm86byed+MTWx5l0JNGXgioz1f6fxn6u0RWdfXEGfAcy7Os1578nWux+4zsMvkfXrUXnUsr84srzJogwydBvyLQJdy03WH0ZbzYrHS2l0HL7oMT9ezF11GW9CLZ62dO3iRMzy5Zy9yRlvOi+U3rV04eFEwPIVnLwpGW86Lef0ZoOfgRY/h6Xn2osdoC66Rel6UDl6UDE/p2YuS0Rb04ofW7jt40Wd4+p696DPagl5819qVgxcVw1N59qJitAX3zvrzxcDBiwHDM/DsxYDRFvRirrWHDl4MGZ6hZy+GjLbgGqm1Lxy8uGB4Ljx7QXq7MvcCZK4CZC72gDmxYhntRb1/jhy8GDE8I89e4HcuuzCXe8CcWLGM9uJJa48dvBgzPGPPXpDersx5gMxFgMz9AJnLAJmrAJn3YT4nViyjvaz30EsHLy4ZnkvPXpDersx5gMyjAJmLPWBOrFhGe1l/N3fl4MUVw3Pl2QvS25V5ECBzdw+YEyuW0V4utPbEwYsJwzPx7AXp7co8DJC5CpB5FCBzESBzP0DmMkDmwxr0w5zvATO+e/S7UZ75c2rxkGfKYlQWYwpxBozU9kXJva+SWbWT1lTcj/X42POFrqeNas9XOu+XBmrSeW/l89Z/I9yZXPQO3y3j1b2JI+FxuoO8EejQ/RjiX9CW2pEftB8Qu36X68bE91v6Tax+GbS5gX63Vj+6prHW3v00cVNzy2Ved9RmLX8Fngb2wUd8J1eBV8pipGMCPNfyPA8N1TnDd/j+KNm1N7W8OrG8yqAN7tEftW8emA/M/2LGzxMncA956F7LqgX/v2EKOf4CARQXTpY1AAA=","debug_symbols":"ndpRattAGIXRveg5FN/fmhkpWymlOIlTDMEJsVMoJnuv3dIF9LxpJN237+kwl+lp//Dx4/vh+Px6mu6/XqaX18fd+fB6vJ4u0+ZLLX/ent52x9uL03n3fp7ut33cTfvj0/Vp1Ofd9Hx42V+fWz6/3d1GK4y2GxlFRiWjrYxmGTUZdRkNGUkRWyliliJmKWKWImYpYpYiZililiJmKWKWImYpokkRTYpoUkSTIpoU0aSIJkU0KaJJEU2K6FJElyK6FNGliC5FdCmiSxFdiuhSRJcihhQxpIghRQwpYkgRQ4oYUsSQIoYUMaSIRYpYpIhFilikiEWKWKSIRYpYpIhFilikiFWKWKWIVYpYpYhVililiFWKWKWIVYpYpYhsNrQKrYpWW1rNtGq06rQatFpoRW2E2gi1EWoj1EaojVAboTZCbYTaCLVR1EZRG0VtFLVR1EZRG0VtFLVBoBkSzRBphkwzhJoh1QyxZsg1Q7AZks0QbYZsM4SbId0M8WbIN0PAGRLOEHGGjDOEnCHlDDFnyDlD0BmSzhB1hqwzhJ0h7QxxZ8g7Q+AZEs8QeYbMM4SeIfUMsWfIPUPwGZLPEH2G7DOEnyH9DPFnyD9DABoS0BCBhgw0hKAhBQ0xaMhBQxAaktAQhYYsNIShIQ0NcWjIQ0MgGhLREImGTDSEoiEVDbFoyEWLXLTIRYtctMhFi1y0yEWLXLTIRYtctMhFi1y0yEWLXLTIRYtctMhFi1y0yEWLXLTIRYtctMhFi1y0yEWLXLTIRYtctMhFyy56kosWuWiRixa5aJGLFrlokYvWf7vo9fRz937YPbzsb3d7bx8/jo//rvpej+dfb3+/XP/9DQ=="},{"name":"end_vote","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/72W247TMBCGnW67u6Vt0vMpPeaw3YpruOQR4BkQBwmJk7QICW54Px6JK/yPPfnTBlWKtMJSEmf8f5nxuPY0M1fG3DaMbWvjm327NaG5to8A1wujPTdogtAEasoxKFTuZeYqsbf2M6MfjnBryr31VPro2es6MwGAVgvfg0MxNzMEJVg716BujBjR2rg5DbDbjCP2gy/t84kT33hxJ284o+kQ6zhN23UF/UKzol1BIegS7RLtevQbzYr2BIWgR7RHtOfRHc2KhoJCEBINiYYe/UCzopGgEEREI6KRRz/TrGhfUAj6RPtE++5ZRcL6SPfRvdg5vaZZ0YGgEAyIDogOPPqRZkWHgkIwJDokOqwGOiwCvYBYbz9pVnQkKAQjoiOiI4++o1nRsaAQjImOiY49+pZmRSeCQjAhOiE6wXOPrfXAjdkX0HA36vaD2uS6Re0Xm4ZtKq6mp65mDp64ro7gJzijaMENvryW7tLrY3+ArAIRrmDCJRF/dW86XTCrXGVzOnYDDWfEoHpY4Ind+b4U1lnAzwP9DWZydpWbnGlyjrqrNO0ie01mb3Z6rE0PDQ8GTD3avJQZl465Bivz/oWexOXblT9yIVtKBiR/A1mVlriY+aXxbqCMixiXjDE+jbG0MliKV6f5g3gtiUXG18TWThP7ohP/C4nqI4PLiA3wB82KbgSFYEN0Q3RT9bYpTueaSL8+Mr6M2Dl9olnRraAQbIluiW6r3rbFyVUTieojvcuIndMbmhXdCQrBjuiO6K7qbVckvSYS1Ud69ZHRfwls/OhzsevznWZF94JCsCe6J7qvetsX/61qIt36yOgyYuf0QLOiiaAQJEQToonWmuCGZ+dCQMMDU0/IpKiOsftiuTqm4io9dZU5OHFdHcHhnFF0xzP44MrBwevvfXU8uup4hAmXRNx0bzpdMMdcZTkdu4GGD/1oCg93eGK9/5TCOgtYqlDsCsV5dYRw6qojKs+UM0qL7M2YvfS08pTqYepEM81frnWzumipDy69938+XKUVh/PfuP4Ch/caMBANAAA=","debug_symbols":"5ZzdSlxZEIXfpa9l2FW7fnb5KsMwdBIzCNKGaAaC5N1zTPp05+d0GlZYgfZcSWvVdpd8n8o6pU+bNzevPvz37+3u7f3D5vrvp83d/evt4+39bnr1tGl/1Zd3Przb7p5fPzxu3z9urtvV5mb3Znr76Wrz9vbuZnPdXT5d/VRX7vvKyjzUiupCrUnOxSbDDtXlC8WhPffFod6/Lf7narq1tN+5trSu+1Jpbn/04vJbX++S4739zL1FxOZqyfbre6cdhkyX8fO9lXTvr6d36ulGPd2ppwf19KSePqinF/N0bdTThXo61VWluqpUV5XqqlJdVaqrSnVVqa52qqud6mqnutqprnaqq53qaqe62qmudqqrneqqUV01qqtGddWorhrVVaO6alRXjeqqUV01qqtOddWprjrVVae66lRXneqqU111qqtOddWprgbV1aC6GlRXg+pqUF0NqqtBdTWorgbV1aC6mlRXk+pqUl1NqqtJdTWpribV1aS6mlRXk+rqoLo6qK4OqquD6uqgujqorg6qq4Pq6qC6OqiuFtXVorpaVFeL6mpRXS2qq0V1taiuFtXVoroqrXGPF+7x3HWIxt2HaMY9nrsR0bgrEY27E9G4SxGNa61wrRWuteQlJvIWE3mNaXmPSSP7vk+j+plPMskzb79NX2w5fhaLhWrvfV5Q8x51qF5cUHOp+SKucqZ4eJvvMdyWtvByTcOONQ1bKxp2eUvtpQ4raxpW//ywUodhz60Li8Tx6IxDsVabB+iXPoBd+gB+6QPEpQ+Qlz7AuPQBTvw2UHOfpuSZAazr/FPAetdfXyn6GPvisLbwjb2f/ZGd3/z5xfON9n0C9inY18E+A/sc7AuwL8G+AfYV1mcgLwbyYiAvBvJiIC8G8mIgLwbyYiAvBvLiIC8O8uIgLw7y4iAvDvLiIC8O8uIgLw7yEiAvAfISIC8B8hIgLwHyEiAvAfISIC8B8pIgLwnykiAvCfKSIC8J8pIgLwnykiAvCfIyQF4GyMsAeRkgLwPkZYC8DJCXAfIyQF4GyEuBvBTIS4G8FMhLgbwUyEuBvBTIS4G8FMaLtgb2CdinYF8H+wzsc7AvwL4E+wbYB/IiIC8C8iIgLwLyIiAvAvIiIC8C8iIgLwLyoiAvCvKiIC8K8qIgLwryoiAvCvKiIC8K8gLmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmuwrmu3oi383D41QdP/QtPA/uEvvq6bngsfrEo+aQeXnSI44rkcvbPZaHYm9nikfofOsR3z/E3g/raxo21jRsrmnYsaZha0XDnnjK80KHlTUNq2sadk2/VJx4cvnihp1e/L99f7t9dXfz/D+snz/2Yfd6/pfW08vHj+++fmSq/Qw="}],"outputs":{"globals":{"storage":[{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"tally","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"vote_ended","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"active_at_block","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[],"kind":"struct","path":"EasyPrivateVoting::end_vote_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"candidate","type":{"kind":"field"}}],"kind":"struct","path":"EasyPrivateVoting::cast_vote_parameters"}}],"kind":"struct","path":"EasyPrivateVoting::cast_vote_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"EasyPrivateVoting::constructor_parameters"}}],"kind":"struct","path":"EasyPrivateVoting::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"candidate","type":{"kind":"field"}}],"kind":"struct","path":"EasyPrivateVoting::add_to_tally_public_parameters"}}],"kind":"struct","path":"EasyPrivateVoting::add_to_tally_public_abi"}]}},"file_map":{"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"122":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::{compute_siloed_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_contract_initialization_nullifier(context.this_address());\n    let header = context.get_header();\n    header.prove_nullifier_inclusion(init_nullifier);\n}\n\nfn compute_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    compute_siloed_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(address)\n    )\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"123":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr","source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"},"125":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"128":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n"},"131":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_membership_witness.nr","source":"use dep::protocol_types::{constants::{ARCHIVE_HEIGHT, NOTE_HASH_TREE_HEIGHT}, utils::arr_copy_slice};\n\nglobal NOTE_HASH_TREE_ID = 1;\nglobal ARCHIVE_TREE_ID = 4;\n\n// Note: We have M here because we need to somehow set it when calling get_membership_witness function and one way to\n// do it is to set M here and then set type of the return param, e.g.:\n//\n// `let witness: MembershipWitness<NOTE_HASH_TREE_HEIGHT, NOTE_HASH_TREE_HEIGHT + 1> = get_membership_witness(...);`\n//\n// Another way to do it would be to add \"type_hint: [Field; T]\" as argument to `get_membership_witness` but that's\n// a bit too boilerplatey for my taste.\nstruct MembershipWitness<N, M> {\n    index: Field,\n    path: [Field; N],\n}\n\n#[oracle(getMembershipWitness)]\nunconstrained fn get_membership_witness_oracle<M>(\n    _block_number: u32,\n    _tree_id: Field,\n    _leaf_value: Field\n) -> [Field; M] {}\n\nunconstrained pub fn get_membership_witness<N, M>(\n    block_number: u32,\n    tree_id: Field,\n    leaf_value: Field\n) -> MembershipWitness<N, M> {\n    let fields: [Field; M] = get_membership_witness_oracle(block_number, tree_id, leaf_value);\n    MembershipWitness { index: fields[0], path: arr_copy_slice(fields, [0; N], 1) }\n}\n\n// Note: get_nullifier_membership_witness function is implemented in get_nullifier_membership_witness.nr\n\nunconstrained pub fn get_note_hash_membership_witness<N, M>(\n    block_number: u32,\n    leaf_value: Field\n) -> MembershipWitness<NOTE_HASH_TREE_HEIGHT, NOTE_HASH_TREE_HEIGHT + 1> {\n    get_membership_witness(block_number, NOTE_HASH_TREE_ID, leaf_value)\n}\n\n// There is no `get_public_data_membership_witness` function because it doesn't make sense to be getting a membership\n// witness for a value in the public data tree.\n\nunconstrained pub fn get_archive_membership_witness(\n    block_number: u32,\n    leaf_value: Field\n) -> MembershipWitness<ARCHIVE_HEIGHT, ARCHIVE_HEIGHT + 1> {\n    get_membership_witness(block_number, ARCHIVE_TREE_ID, leaf_value)\n}\n"},"132":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<N>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field\n) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number as Field, N)\n}\n\nunconstrained pub fn storage_read<T, N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"134":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/header.nr","source":"use std::merkle::compute_merkle_root;\nuse dep::protocol_types::{constants::HEADER_LENGTH, header::Header};\n\nuse crate::{context::PrivateContext, oracle::get_membership_witness::get_archive_membership_witness};\n\n#[oracle(getHeader)]\nunconstrained fn get_header_at_oracle(_block_number: u32) -> [Field; HEADER_LENGTH] {}\n\nunconstrained pub fn get_header_at_internal(block_number: u32) -> Header {\n    let header = get_header_at_oracle(block_number);\n    Header::deserialize(header)\n}\n\npub fn get_header_at(block_number: u32, context: PrivateContext) -> Header {\n    let historical_header_block_number = context.historical_header.global_variables.block_number as u32;\n\n    if (block_number == historical_header_block_number) {\n        // If the block number we want to prove against is the same as the block number in the historical header we\n        // skip the inclusion proofs and just return the historical header from context.\n        context.historical_header\n    } else {\n        // 1) Get block number corresponding to the last_archive root in the header\n        // Note: We subtract 1 because the last_archive root is the root of the archive after applying the previous block\n        let last_archive_block_number = historical_header_block_number - 1;\n\n        // 2) Check that the last archive block number is more than or equal to the block number we want to prove against\n        // We could not perform the proof otherwise because the last archive root from the header would not \"contain\"\n        // the header we want to prove against\n        assert(\n            last_archive_block_number >= block_number, \"Last archive block number is smaller than the block number we want to prove against\"\n        );\n\n        // 3) Get the header of a given block from oracle\n        let header = get_header_at_internal(block_number);\n\n        // 4) Compute the block hash from the block header\n        let block_hash = header.hash();\n\n        // 5) Get the membership witness of the block in the archive\n        let witness = get_archive_membership_witness(last_archive_block_number, block_hash);\n\n        // 6) Check that the block is in the archive (i.e. the witness is valid)\n        assert(\n            context.historical_header.last_archive.root\n            == compute_merkle_root(block_hash, witness.index, witness.path), \"Proving membership of a block in archive failed\"\n        );\n\n        // 7) Return the block header\n        header\n    }\n}\n"},"136":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use crate::keys::PublicKeys;\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained fn get_public_keys_and_partial_address_oracle_wrapper(address: AztecAddress) -> [Field; 13] {\n    get_public_keys_and_partial_address_oracle(address)\n}\n\nfn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle_wrapper(address);\n\n    let keys = PublicKeys {\n        npk_m: Point::new(result[0], result[1], result[2] as bool),\n        ivpk_m: Point::new(result[3], result[4], result[5] as bool),\n        ovpk_m: Point::new(result[6], result[7], result[8] as bool),\n        tpk_m: Point::new(result[9], result[10], result[11] as bool)\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"139":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"140":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{\n    abis::{\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\n    utils::reader::Reader,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n}\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\n    let mut reader = Reader::new(fields);\n\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n    // WARNING: if updating, see comment in public_call_stack_item.ts's PublicCallStackItem.hash()\n    let item = PublicCallStackItem {\n        contract_address: AztecAddress::from_field(reader.read()),\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\n        public_inputs: PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            args_hash: reader.read(),\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            end_side_effect_counter: 0,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0\n        },\n        is_execution_request: true\n    };\n    reader.finish();\n\n    item\n}\n"},"144":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{hash::pedersen_hash, storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"146":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UnconstrainedContext> {\n    unconstrained pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"149":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr","source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext}, oracle::storage::storage_read,\n    state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PublicContext> {\n    // Intended to be only called once. \n    pub fn initialize<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T> SharedImmutable<T, UnconstrainedContext> {\n    unconstrained pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PrivateContext> {\n    pub fn read_private<T_SERIALIZED_LEN>(self) -> T  where T: Deserialize<T_SERIALIZED_LEN> {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n"},"155":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_delay_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initally equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation \n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the \n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a \n// reduced delay, invalidating prior private reads.\nstruct ScheduledDelayChange<INITIAL_DELAY> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option, \n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pre: Option<u32>,\n    post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numeric value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\nimpl<INITIAL_DELAY> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior contraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This \n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is \n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in \n            //                             which to scheduled value change\n\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY)\n            )\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Serialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn serialize(self) -> [Field; 1] {\n        // We pack all three u32 values into a single U128, which is made up of two u64 limbs.\n        // Low limb: [ pre_inner: u32 | post_inner: u32 ]\n        // High limb: [ empty | pre_is_some: u8 |  post_is_some: u8 | block_of_change: u32 ]\n\n        let lo = ((self.pre.unwrap_unchecked() as u64) * (1 << 32))\n            + (self.post.unwrap_unchecked() as u64);\n\n        let hi = (self.pre.is_some() as u64) * (1 << 33) \n            + (self.post.is_some() as u64 * (1 << 32)) \n            + self.block_of_change as u64;\n\n        let packed = U128::from_u64s_le(lo, hi);\n\n        [packed.to_integer()]\n    }\n}\n\nimpl<INITIAL_DELAY> Deserialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn deserialize(input: [Field; 1]) -> Self {\n        let packed = U128::from_integer(input[0]);\n\n        // We use division and modulo to clear the bits that correspond to other values when unpacking.\n\n        let pre_is_some = ((packed.hi as u64) / (1 << 33)) as bool;\n        let pre_inner = ((packed.lo as u64) / (1 << 32)) as u32;\n\n        let post_is_some = (((packed.hi as u64) / (1 << 32)) % (1 << 1)) as bool;\n        let post_inner = ((packed.lo as u64) % (1 << 32)) as u32;\n\n        let block_of_change = ((packed.hi as u64) % (1 << 32)) as u32;\n\n        Self {\n            pre: if pre_is_some { Option::some(pre_inner) } else { Option::none() },\n            post: if post_is_some { Option::some(post_inner) } else { Option::none() },\n            block_of_change,\n            _dummy: [0; INITIAL_DELAY],\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"157":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable_private_getter.nr","source":"use dep::protocol_types::{\n    hash::{pedersen_hash, poseidon2_hash}, traits::{FromField, ToField}, address::AztecAddress,\n    header::Header\n};\n\nuse crate::context::PrivateContext;\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{\n    shared_mutable::SharedMutable, scheduled_delay_change::ScheduledDelayChange,\n    scheduled_value_change::ScheduledValueChange\n}\n};\n\nstruct SharedMutablePrivateGetter<T, INITIAL_DELAY> {\n    context: &mut PrivateContext,\n    // The contract address of the contract we want to read from\n    other_contract_address: AztecAddress,\n    // The storage slot where the SharedMutable is stored on the other contract\n    storage_slot: Field,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numberic value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\n// We have this as a view-only interface to reading Shared Mutables in other contracts.\n// Currently the Shared Mutable does not support this. We can adapt SharedMutable at a later date\nimpl<T, INITIAL_DELAY> SharedMutablePrivateGetter<T, INITIAL_DELAY> {\n    pub fn new(\n        context: &mut PrivateContext,\n        other_contract_address: AztecAddress,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        assert(other_contract_address.to_field() != 0, \"Other contract address cannot be 0\");\n        Self { context, other_contract_address, storage_slot, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    pub fn get_value_in_private(self, header: Header) -> T where T: FromField + ToField + Eq {\n        // We create a dummy SharedMutable state variable so that we can reuse its historical_read_from_public_storage\n        // method, greatly reducing code duplication. \n        let dummy: SharedMutable<T, INITIAL_DELAY, ()> = SharedMutable::new((), self.storage_slot);\n        let (value_change, delay_change, historical_block_number) = dummy.historical_read_from_public_storage(header, self.other_contract_address);\n\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // If our context has the same header as the one we pass in via the parameter, we are trying to read the \"current\" value\n        // and thus need to set the tx max block number below. If the context header is not the same as the one we pass in, this means\n        // we are trying to read a historical value and thus have no constraint on the max block number that this transaction can be included in.\n        if (self.context.historical_header.global_variables.block_number.eq(header.global_variables.block_number)) {\n            self.context.set_tx_max_block_number(block_horizon);\n        }\n\n        value_change.get_current_at(historical_block_number)\n    }\n}\n"},"159":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_value_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\nstruct ScheduledValueChange<T> {\n    pre: T,\n    post: T,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Serialize<3> for ScheduledValueChange<T> {\n    fn serialize(self) -> [Field; 3] where T: ToField {\n        [self.pre.to_field(), self.post.to_field(), self.block_of_change.to_field()]\n    }\n}\n\nimpl<T> Deserialize<3> for ScheduledValueChange<T> {\n  fn deserialize(input: [Field; 3]) -> Self  where T: FromField {\n    Self {\n        pre: FromField::from_field(input[0]),\n        post: FromField::from_field(input[1]),\n        block_of_change: FromField::from_field(input[2]),\n    }\n  }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>  {\n    fn eq(self, other: Self) -> bool where T: Eq {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"160":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable.nr","source":"use dep::protocol_types::{\n    hash::{pedersen_hash, poseidon2_hash}, header::Header, address::AztecAddress,\n    traits::{FromField, ToField}\n};\n\nuse crate::context::{PrivateContext, PublicContext};\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{scheduled_value_change::ScheduledValueChange, scheduled_delay_change::ScheduledDelayChange}\n};\nuse crate::oracle::storage::storage_read;\nuse dep::std::unsafe::zeroed;\n\nmod test;\n\nstruct SharedMutable<T, INITIAL_DELAY, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Serialize<N> trait, and allocate N storage slots to\n// this state variable. This is incorrect, since what we actually store is:\n//  - a ScheduledValueChange<T>, which requires 1 + 2 * M storage slots, where M is the serialization length of T\n//  - a ScheduledDelayChange, which requires another storage slot\n//\n// TODO https://github.com/AztecProtocol/aztec-packages/issues/5736: change the storage allocation scheme so that we\n// can actually use it here\nimpl<T, INITIAL_DELAY, Context> Storage<T> for SharedMutable<T, INITIAL_DELAY, Context> {}\n\n// TODO: extract into a utils module once  we can do arithmetic on generics, i.e. https://github.com/noir-lang/noir/issues/4784\nfn concat_arrays<N, M, O>(arr_n: [Field; N], arr_m: [Field; M]) -> [Field; O] {\n    assert_eq(N + M, O);\n    let mut out: [Field; O] = [0; O];\n    for i in 0..N {\n        out[i] = arr_n[i];\n    }\n    for i in 0..M {\n        out[N+i] = arr_m[i];\n    }\n    out\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, INITIAL_DELAY, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    fn hash_scheduled_data(\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) -> Field where T: ToField {\n        // TODO(#5491 and https://github.com/noir-lang/noir/issues/4784): update this so that we don't need to rely on\n        // ScheduledValueChange serializing to 3 and ScheduledDelayChange serializing to 1\n        let concatenated: [Field; 4] = concat_arrays(value_change.serialize(), delay_change.serialize());\n        poseidon2_hash(concatenated)\n    }\n\n    // Since we can't rely on the native storage allocation scheme, we hash the storage slot to get a unique location in\n    // which we can safely store as much data as we need.\n    // See https://github.com/AztecProtocol/aztec-packages/issues/5492 and\n    // https://github.com/AztecProtocol/aztec-packages/issues/5736\n    // We store three things in public storage:\n    //  - a ScheduledValueChange\n    //  - a ScheduledDelaChange\n    //  - the hash of both of these (via `hash_scheduled_data`)\n    fn get_value_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 0], 0)\n    }\n\n    fn get_delay_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 1], 0)\n    }\n\n    fn get_hash_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 2], 0)\n    }\n\n    // It may seem odd that we take a header and address instead of reading from e.g. a PrivateContext, but this lets us\n    // reuse this function in SharedMutablePrivateGetter.\n    fn historical_read_from_public_storage(\n        self,\n        header: Header,\n        address: AztecAddress\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) where T: FromField + ToField + Eq {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for both the ScheduledValueChange and\n        // ScheduledDelayChange, but that'd require one full sibling path per storage slot (since due to kernel siloing\n        // the storage is not contiguous), and in the best case in which T is a single field that'd be 4 slots.\n        // Instead, we get an oracle to provide us the correct values for both the value and delay changes, and instead\n        // prove inclusion of their hash, which is both a much smaller proof (a single slot), and also independent of\n        // the size of T.\n        let (value_change_hint, delay_change_hint) = get_public_storage_hints(address, self.storage_slot, historical_block_number);\n\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let hash = header.public_storage_historical_read(self.get_hash_storage_slot(), address);\n\n        // @todo This is written strangely to bypass a formatting issue with the if that is breaking ci.\n        let (a, b, c) = if hash != 0 {\n            let a = SharedMutable::hash_scheduled_data(value_change_hint, delay_change_hint);\n            (a, value_change_hint, delay_change_hint)\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized, meaning no value or delay change was ever\n            // scheduled. Therefore, the hints must then correspond to uninitialized scheduled changes.\n            let b = ScheduledValueChange::deserialize(zeroed());\n            let c = ScheduledDelayChange::deserialize(zeroed());\n            (hash, b, c)\n        };\n\n        assert_eq(hash, a, \"Hint values do not match hash\");\n        assert_eq(value_change_hint, b, \"Non-zero value change for zero hash\");\n        assert_eq(delay_change_hint, c, \"Non-zero delay change for zero hash\");\n\n        (value_change_hint, delay_change_hint, historical_block_number)\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PublicContext> {\n    pub fn schedule_value_change(self, new_value: T) where T: ToField {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) where T: ToField {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value_in_public(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay_in_public(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value_in_public(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay_in_public(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        self.context.storage_read(self.get_delay_change_storage_slot())\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) where T: ToField {\n        // Whenever we write to public storage, we write both the value change and delay change as well as the hash of\n        // them both. This guarantees that the hash is always kept up to date.\n        // While this makes for more costly writes, it also makes private proofs much simpler because they only need to\n        // produce a historical proof for the hash, which results in a single inclusion proof (as opposed to 4 in the\n        // best case scenario in which T is a single field). Private shared mutable reads are assumed to be much more\n        // frequent than public writes, so this tradeoff makes sense.\n        self.context.storage_write(self.get_value_change_storage_slot(), value_change);\n        self.context.storage_write(self.get_delay_change_storage_slot(), delay_change);\n        self.context.storage_write(\n            self.get_hash_storage_slot(),\n            SharedMutable::hash_scheduled_data(value_change, delay_change)\n        );\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext> {\n    pub fn get_current_value_in_private(self) -> T where T: FromField + ToField + Eq {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n\n        let (value_change, delay_change, historical_block_number) = self.historical_read_from_public_storage(self.context.get_header(), self.context.this_address());\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n}\n\nunconstrained fn get_public_storage_hints<T, INITIAL_DELAY>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>) {\n    // This function cannot be part of the &mut PrivateContext impl because that'd mean that by passing `self` we'd also\n    // be passing a mutable reference to an unconstrained function, which is not allowed. We therefore create a dummy\n    // state variable here so that we can access the methods to compute storage slots. This will all be removed in the\n    // future once we do proper storage slot allocation (#5492).\n    let dummy = SharedMutable::new((), storage_slot);\n\n    (\n        storage_read(address, dummy.get_value_change_storage_slot(), block_number), storage_read(address, dummy.get_delay_change_storage_slot(), block_number)\n    )\n}\n"},"170":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"173":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item_compressed.nr","source":"use crate::abis::{call_context::CallContext, function_data::FunctionData, gas::Gas};\nuse crate::address::AztecAddress;\nuse crate::constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH};\nuse crate::traits::{Hash, Empty, Serialize, Deserialize};\nuse crate::utils::reader::Reader;\n\n/**\n * A compressed version of the PublicCallStackItem struct used to compute the \"hash\"\n * of a PublicCallStackItem.\n * \n * Historically, we have been zeroing most values in the PublicCallStackItem struct\n * to compute the hash involved when adding a PublicCallStackItem to the PublicCallStack.\n * \n * This struct is used to store the values that we did not zero out, and allow us to hash\n * only these, thereby skipping a lot of computation and saving us a lot of constraints\n * \n * Essentially this struct exists such that we don't have a `hash` function in the \n * PublicCallStackItem struct that practically throws away some values of the struct\n * without clearly indicating that it does so.\n */\nstruct PublicCallStackItemCompressed {\n    contract_address: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    revert_code: u8,\n    start_gas_left: Gas,\n    end_gas_left: Gas,\n}\n\nimpl Eq for PublicCallStackItemCompressed {\n    fn eq(self, other: PublicCallStackItemCompressed) -> bool {\n        (self.contract_address == other.contract_address)\n            & (self.call_context == other.call_context)\n            & (self.function_data == other.function_data)\n            & (self.args_hash == other.args_hash)\n            & (self.returns_hash == other.returns_hash)\n            & (self.revert_code == other.revert_code)\n            & (self.start_gas_left == other.start_gas_left)\n            & (self.end_gas_left == other.end_gas_left)\n    }\n}\n\nimpl Hash for PublicCallStackItemCompressed {\n    fn hash(self) -> Field {\n        std::hash::pedersen_hash_with_separator(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PublicCallStackItemCompressed {\n    fn empty() -> Self {\n        PublicCallStackItemCompressed {\n            contract_address: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n    fn serialize(self) -> [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.push(self.revert_code as Field);\n        fields.extend_from_array(self.start_gas_left.serialize());\n        fields.extend_from_array(self.end_gas_left.serialize());\n\n        assert_eq(fields.len(), PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n  fn deserialize(fields: [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH]) -> PublicCallStackItemCompressed {\n    let mut reader = Reader::new(fields);\n\n    let item = PublicCallStackItemCompressed {\n      contract_address: reader.read_struct(AztecAddress::deserialize),\n      call_context: reader.read_struct(CallContext::deserialize),\n      function_data: reader.read_struct(FunctionData::deserialize),\n      args_hash: reader.read(),\n      returns_hash: reader.read(),\n      revert_code: reader.read() as u8,\n      start_gas_left: reader.read_struct(Gas::deserialize),\n      end_gas_left: reader.read_struct(Gas::deserialize),\n    };\n    reader.finish();\n    item\n  }\n}\n"},"175":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n"},"180":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point::new(fields[0], fields[1], fields[2] as bool),\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"192":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr","source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n  fn eq(self, other: Self) -> bool {\n    (self.nullifier == other.nullifier) &\n    (self.next_nullifier == other.next_nullifier) &\n    (self.next_index == other.next_index)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"193":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"21":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    fn new(x: Field, y: Field, is_infinite: bool) -> Self {\n        Self { x, y, is_infinite }\n    }\n\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n// Scalar represented as low and high limbs\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    pub fn derive_public_key(self) -> EmbeddedCurvePoint {\n        let public_key = fixed_base_scalar_mul(self.lo, self.hi);\n        EmbeddedCurvePoint { x: public_key[0], y: public_key[1], is_infinite: false }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, key: EmbeddedCurveScalar) -> bool {\n        (key.hi == self.hi) & (key.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n#[foreign(multi_scalar_mul)]\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> [Field; 3]\n// docs:end:multi_scalar_mul\n{}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(\n    scalar_low: Field,\n    scalar_high: Field\n) -> [Field; 3]\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    let scalar = EmbeddedCurveScalar { lo: scalar_low, hi: scalar_high };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n"},"215":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr","source":"struct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n"},"216":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n}\n// docs:end:call-context\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n"},"217":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"22":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"229":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"235":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<N> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<N> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<N> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<N> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"237":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr","source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  num_txs: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.num_txs);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let num_txs = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      num_txs,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      num_txs: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.num_txs == other.num_txs)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n"},"238":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"239":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr","source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"241":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n"},"246":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: Field = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point {\n            x: 0,\n            y: 0,\n            is_infinite: false\n        }\n    }\n}\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn pub_key_to_bytes(pk: Point) -> [u8; 64] {\n    assert(!pk.is_infinite, \"Point at infinity is not a valid public key.\");\n    let mut result = [0 as u8; 64];\n    let x_bytes = pk.x.to_be_bytes(32);\n    let y_bytes = pk.y.to_be_bytes(32);\n    for i in 0..32 {\n        result[i] = x_bytes[i];\n        result[i + 32] = y_bytes[i];\n    }\n    result\n}\n"},"247":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"249":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n"},"25":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n#[no_predicates]\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    let value = pedersen_commitment_with_separator(input, 0);\n    if (value.x == 0) & (value.y == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value.x, y: value.y, is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        points[i] = EmbeddedCurveScalar::from_field(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let values = multi_scalar_mul(generators, points);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: values[2] as bool }\n}\n\n#[no_predicates]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let v1 = pedersen_commitment_with_separator(input, separator);\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    multi_scalar_mul(\n        [length_generator[0], v1],\n        [EmbeddedCurveScalar { lo: N as Field, hi: 0 }, EmbeddedCurveScalar { lo: 1, hi: 0 }]\n    )[0]\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n#[test]\nfn assert_pedersen_noir() {\n    // TODO: make this a fuzzer test once fuzzer supports curve-specific blackbox functions.\n    let input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq(pedersen_hash_with_separator(input, 4), pedersen_hash_with_separator_noir(input, 4));\n    assert_eq(pedersen_commitment_with_separator(input, 4), pedersen_commitment_with_separator_noir(input, 4));\n}\n"},"263":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"273":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"289":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"32":{"path":"std/merkle.nr","source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n"},"351":{"path":"/usr/src/noir-projects/noir-contracts/contracts/easy_private_voting_contract/src/main.nr","source":"contract EasyPrivateVoting {\n    // docs:start:imports\n    use dep::aztec::prelude::{\n        AztecAddress, FunctionSelector, NoteHeader, NoteInterface, NoteGetterOptions, PrivateContext,\n        Map, PublicMutable, SharedImmutable\n    };\n    // docs:end:imports\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        admin: PublicMutable<AztecAddress>, // admin can end vote\n        tally: Map<Field, PublicMutable<Field>>, // we will store candidate as key and number of votes as value\n        vote_ended: PublicMutable<bool>, // vote_ended is boolean\n        active_at_block: SharedImmutable<u32>, // when people can start voting\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)] // annotation to mark function as a constructor\n    fn constructor(admin: AztecAddress) {\n        storage.admin.write(admin);\n        storage.vote_ended.write(false);\n        storage.active_at_block.initialize(context.block_number() as u32);\n    }\n    // docs:end:constructor\n\n    // docs:start:cast_vote\n    #[aztec(private)] // annotation to mark function as private and expose private context\n    fn cast_vote(candidate: Field) {\n        // Below, we make sure to get our nullifier public key at a specific block. By pinning the nullifier public key at a specific block,\n        // rotating keys will have no effect on the nullifier being produced, and voting again after will fail because the same nullifier is computed each time the user votes.\n        let header_at_active_at_block = context.get_header_at(storage.active_at_block.read_private());\n        let msg_sender_npk_m_hash = header_at_active_at_block.get_npk_m_hash(&mut context, context.msg_sender());\n\n        let secret = context.request_nsk_app(msg_sender_npk_m_hash); // get secret key of caller of function\n        let nullifier = std::hash::pedersen_hash([context.msg_sender().to_field(), secret]); // derive nullifier from sender and secret\n        context.push_nullifier(nullifier, 0); // push nullifier\n        EasyPrivateVoting::at(context.this_address()).add_to_tally_public(candidate).enqueue(&mut context);\n    }\n    // docs:end:cast_vote\n\n    // docs:start:add_to_tally_public\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn add_to_tally_public(candidate: Field) {\n        assert(storage.vote_ended.read() == false, \"Vote has ended\"); // assert that vote has not ended\n        let new_tally = storage.tally.at(candidate).read() + 1;\n        storage.tally.at(candidate).write(new_tally);\n    }\n    // docs:end:add_to_tally_public\n\n    // docs:start:end_vote\n    #[aztec(public)] \n    fn end_vote() {\n        assert(storage.admin.read().eq(context.msg_sender()), \"Only admin can end votes\"); // assert that caller is admin\n        storage.vote_ended.write(true);\n    }\n    // docs:end:end_vote\n    // docs:start:get_vote\n    unconstrained fn get_vote(candidate: Field) -> pub Field {\n        storage.tally.at(candidate).read()\n    }\n    // docs:end:get_vote\n}\n"},"38":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"4":{"path":"std/cmp.nr","source":"// docs:start:eq-trait\ntrait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\nimpl Eq for Field { fn eq(self, other: Field) -> bool { self == other } }\n\nimpl Eq for u64 { fn eq(self, other: u64) -> bool { self == other } }\nimpl Eq for u32 { fn eq(self, other: u32) -> bool { self == other } }\nimpl Eq for u8 { fn eq(self, other: u8) -> bool { self == other } }\nimpl Eq for u1 { fn eq(self, other: u1) -> bool { self == other } }\n\nimpl Eq for i8 { fn eq(self, other: i8) -> bool { self == other } }\nimpl Eq for i32 { fn eq(self, other: i32) -> bool { self == other } }\nimpl Eq for i64 { fn eq(self, other: i64) -> bool { self == other } }\n\nimpl Eq for () { fn eq(_self: Self, _other: ()) -> bool { true } }\nimpl Eq for bool { fn eq(self, other: bool) -> bool { self == other } }\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3) & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\nstruct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n// docs:start:ord-trait\ntrait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"47":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"65":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::PrivateContext,\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}},\n    state_vars::{shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter}\n};\n\nglobal DELAY = 5;\n\n// docs:start:key-getters\ntrait KeyGetters {\n  fn get_npk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ivpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ovpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_tpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_npk_m_hash(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Field;\n}\n\nimpl KeyGetters for Header {\n    fn get_npk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, NULLIFIER_INDEX, self)\n    }\n\n    fn get_ivpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, INCOMING_INDEX, self)\n    }\n\n    fn get_ovpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, OUTGOING_INDEX, self)\n    }\n\n    fn get_tpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, TAGGING_INDEX, self)\n    }\n\n    fn get_npk_m_hash(self, context: &mut PrivateContext, address: AztecAddress) -> Field {\n        get_master_key(context, address, NULLIFIER_INDEX, self).hash()\n    }\n}\n// docs:end:key-getters\n\nfn get_master_key(\n    context: &mut PrivateContext,\n    address: AztecAddress,\n    key_index: Field,\n    header: Header\n) -> Point {\n    let key = fetch_key_from_registry(context, key_index, address, header);\n    if is_empty(key) {\n        // Keys were not registered in registry yet --> fetch key from PXE\n        let keys = fetch_and_constrain_keys(address);\n        // Return the corresponding to index\n        keys.get_key_by_index(key_index)\n    } else {\n        // Keys were registered --> return the key\n        key\n    }\n}\n\nfn fetch_key_from_registry(\n    context: &mut PrivateContext,\n    key_index: Field,\n    address: AztecAddress,\n    header: Header\n) -> Point {\n    let x_coordinate_map_slot = key_index * 2 + 1;\n    let y_coordinate_map_slot = x_coordinate_map_slot + 1;\n    let x_coordinate_derived_slot = derive_storage_slot_in_map(x_coordinate_map_slot, address);\n    let y_coordinate_derived_slot = derive_storage_slot_in_map(y_coordinate_map_slot, address);\n\n    let x_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        x_coordinate_derived_slot\n    );\n    let y_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        y_coordinate_derived_slot\n    );\n    let x_coordinate = x_coordinate_registry.get_value_in_private(header);\n    let y_coordinate = y_coordinate_registry.get_value_in_private(header);\n\n    Point::new(x_coordinate, y_coordinate, false)\n}\n\n// Passes only when keys were not rotated - is expected to be called only when keys were not registered yet\nfn fetch_and_constrain_keys(address: AztecAddress) -> PublicKeys {\n    let (public_keys, partial_address) = get_public_keys_and_partial_address(address);\n\n    let computed_address = AztecAddress::compute(public_keys.hash(), partial_address);\n\n    assert(computed_address.eq(address));\n\n    public_keys\n}\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n"},"66":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr","source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH, hash::poseidon2_hash,\n    point::Point, traits::{Deserialize, Serialize, Empty, is_empty}\n};\nuse crate::keys::constants::{NUM_KEY_TYPES, NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX};\n\nglobal PUBLIC_KEYS_LENGTH = 12;\n\nstruct PublicKeys {\n    npk_m: Point,\n    ivpk_m: Point,\n    ovpk_m: Point,\n    tpk_m: Point,\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m : Point::empty(),\n            ivpk_m : Point::empty(),\n            ovpk_m : Point::empty(),\n            tpk_m : Point::empty()\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        ( self.npk_m == other.npk_m ) &\n        ( self.ivpk_m == other.ivpk_m ) &\n        ( self.ovpk_m == other.ovpk_m ) &\n        ( self.tpk_m == other.tpk_m )\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash(\n                [\n                self.npk_m.x,\n                self.npk_m.y,\n                self.npk_m.is_infinite as Field,\n                self.ivpk_m.x,\n                self.ivpk_m.y,\n                self.ivpk_m.is_infinite as Field,\n                self.ovpk_m.x,\n                self.ovpk_m.y,\n                self.ovpk_m.is_infinite as Field,\n                self.tpk_m.x,\n                self.tpk_m.y,\n                self.tpk_m.is_infinite as Field,\n                GENERATOR_INDEX__PUBLIC_KEYS_HASH\n            ]\n            )\n        }\n        )\n    }\n\n    pub fn get_key_by_index(self, index: Field) -> Point {\n        assert(index as u8 < NUM_KEY_TYPES, \"Invalid key index\");\n        if index == NULLIFIER_INDEX {\n            self.npk_m\n        } else if index == INCOMING_INDEX {\n            self.ivpk_m\n        } else if index == OUTGOING_INDEX {\n            self.ovpk_m\n        } else {\n            self.tpk_m\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.x,\n            self.npk_m.y,\n            self.npk_m.is_infinite as Field,\n            self.ivpk_m.x,\n            self.ivpk_m.y,\n            self.ivpk_m.is_infinite as Field,\n            self.ovpk_m.x,\n            self.ovpk_m.y,\n            self.ovpk_m.is_infinite as Field,\n            self.tpk_m.x,\n            self.tpk_m.y,\n            self.tpk_m.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: Point::new(serialized[0], serialized[1], serialized[2] as bool),\n            ivpk_m: Point::new(serialized[3], serialized[4], serialized[5] as bool),\n            ovpk_m: Point::new(serialized[6], serialized[7], serialized[8] as bool),\n            tpk_m: Point::new(serialized[9], serialized[10], serialized[11] as bool)\n        }\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: Point { x: 1, y: 2, is_infinite: false },\n        ivpk_m: Point { x: 3, y: 4, is_infinite: false },\n        ovpk_m: Point { x: 5, y: 6, is_infinite: false },\n        tpk_m: Point { x: 7, y: 8, is_infinite: false }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x146f68c0e0ba4067d61a3304bbfdec0797d5df1357db6c01247c48bfb345c7d7;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nfn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nfn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: Point { x: 1, y: 2, is_infinite: false },\n        ivpk_m: Point { x: 3, y: 4, is_infinite: false },\n        ovpk_m: Point { x: 5, y: 6, is_infinite: false },\n        tpk_m: Point { x: 7, y: 8, is_infinite: false }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.x, deserialized.npk_m.x);\n    assert_eq(keys.npk_m.y, deserialized.npk_m.y);\n    assert_eq(keys.ivpk_m.x, deserialized.ivpk_m.x);\n    assert_eq(keys.ivpk_m.y, deserialized.ivpk_m.y);\n    assert_eq(keys.ovpk_m.x, deserialized.ovpk_m.x);\n    assert_eq(keys.ovpk_m.y, deserialized.ovpk_m.y);\n    assert_eq(keys.tpk_m.x, deserialized.tpk_m.x);\n    assert_eq(keys.tpk_m.y, deserialized.tpk_m.y);\n}\n"},"80":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n"},"81":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr","source":"use std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext, oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: Header, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for Header {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier);\n\n        // 2) Check that the witness we obtained matches the nullifier\n        assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n        // 3) Compute the nullifier tree leaf\n        let nullifier_leaf = witness.leaf_preimage.hash();\n\n        // 4) Prove that the nullifier is in the nullifier tree\n        assert(\n            self.state.partial.nullifier_tree.root\n            == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n        );\n        // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n        //     was included in the nullifier tree.\n    }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, N, M>(header: Header, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M>;\n}\n\nimpl ProveNoteIsNullified for Header {\n    // docs:start:prove_note_is_nullified\n    fn prove_note_is_nullified<Note, N, M>(self, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M> {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n    // docs:end:prove_note_is_nullified\n}\n"},"88":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::storage::{raw_storage_read, storage_read};\n\nstruct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = block_number_oracle();\n        let contract_address = contract_address_oracle();\n        let chain_id = chain_id_oracle();\n        let version = version_oracle();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<N>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n\n#[oracle(getContractAddress)]\nunconstrained fn contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn version_oracle() -> Field {}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<N, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<N, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"95":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn block_number(self) -> Field {\n        block_number()\n    }\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<N>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<N>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, N>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N)\n}\n\nunconstrained fn storage_write<N>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<N>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<N>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}