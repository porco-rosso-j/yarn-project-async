{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"TestLog","functions":[{"name":"emit_unencrypted_events","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"preimages","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"emit_encrypted_events","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"other","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"randomness","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"preimages","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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C256s+DGNwtufrPgBjgLboKz4EY4C26Gs+CGOAtuirPgxjgLbo6z4AY5C26Ss+BGOQtultNws5yGm+U03Cyn4WY57Wg4VMehBg41cSjHoXDVAjfLabhZTsPNchpultNws5yGm+U03Cyn4WY5DTfLabhZTsPNchpultNws5yGm+U03Cyn4WY5DTfLabhZTsPNchpultNws5yGm+U03Cyn4WY5DTfLabhZTsPNchpultNws5yGm+U03Cyn4WY5DTfLabhZTsPNchpultNws5yGm+U03Cyn4WY5DTfLabhZTsPNchpultNws5yGm+U03Cyn4WY5DTfLabhZTsPNchpultNws5yGm+U03Cyn4WY5DTfLabhZTsPNchpultNws5yGm+U03Cyn4WY5DTfLabhZTsPNchpultNws5yGm+U03Cyn4WY5DTfLabhZTsPNchpultNws5yGm+U03Cyn4WY5DTfLabhZTsPNchpultNws5yGm+U03Cyn4WY5DTfLabhZzoqb5ay4Wc6Km+WsuFnOejQcCpdMiJvlrLhZzoqb5ay4Wc5agBGmuGqBm+WsuFnOipvlrLhZzoqb5ay4Wc6Km+WsuFnOipvlrAZMPMZVi0eznLcycqJqP56g6vS7WXXzJ69ebd2jw1fv9Xy1te9ijVWss4oNVrHJKuasYotU7NE07M+LFVYxYxVjrfyVtfJX1spfWSt/Za38lbXyP5xVXuVLbPQnqFHt71cP//baahevbXX8/drW5z9ee0o9nGpOk7p9Oe9SozyQKoxSxihVGaUao1RnlBofkSrzlBpPpHz0e6XyMezr1X1905qcWs6ptSi1+sGpVTi1DK41j/v/9e0/1wOtyqnVOLU6p9bg1JqcWs6pha/ys69Ta8xrrXFwahVOLePUqpxajVOrc2r9QJWv80vL/6F18Tejdv6Jydq3zz9uH4Z8exPzf+FN+P/Cm3j0dwJf55toNp68idurz4+xVv3Ix1iPtk9+XqywihmrWGUVa6xinVVssIpNVjFnFWOt/M5a+Z218jtr5XfWyu+slf/RvtTtR+YvsVae/VD52b8fPNqs+lmpySjljFKLUOrRBti/lPoXvz0tq/fDvax9//X62+9Dj7bFflrLOLUqp1bj1OqcWgOvZceXlv9D62K8xNZZTWr5enW8n//nxbPfO/Jc7dtHHt/e7vxvvV3/b73d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"},{"name":"compute_incoming_log_body_ciphertext","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"secret","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurveScalar"},"visibility":"private"},{"name":"point","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"},"visibility":"private"},{"name":"randomness","type":{"kind":"field"},"visibility":"private"},{"name":"event_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"preimage","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"7d3RThtJEIXhd/E1WnV1Vfd08yqraEUSskJCJgrOSivEu68BezA5joxEmJnNOVeRQ7un63cIHzczd6vPlx+///3X1frLze3q/M+71fXNp4vN1c16++puZeXx726/XqwfXt5uLr5tVufpbHW5/rz98/5s9eXq+nJ17q3dn8G6XK3vluYaNq62bEdW+xB5t9pb6idW9+ixW91L8XF1jnT/4Wxl9f968GG6g4cNtlsd2e2NB29vObi3nMaGpY6rezzu3d9v75yO7W3Wffcecy8nrlDHMsNhxlSPrLWh7j+hlE/s29v+87FkB8X92L7e9xtb+IvFD1MaxZSZYkqnmDIopiwUU1aKKQeKKRvFlJ1hSqewj1PYxyns4xT28aCYksI+TmEfp7CPU9jHKewTFPYJCvsEhX2Cwj4RFFNS2Cco7BMU9gkK+wSFfQqFfQqFfQqFfQqFfUpQTElhn0Jhn0Jhn0Jhn0Jhn0phn0phn0phn0phnxoUU1LYp1LYp1LYp1LYp05snzKurblPNuWQKKY0iikzxZROMWVQTFkopqwUUw4UUzaKKSns0yjs0yjs0yjs0yjs04JiSgr7NAr7NAr7NAr7NAr7dAr7dAr7dAr7dAr79KCYksI+ncI+ncI+ncI+ncI+lijws30/x5gU/LFE4R9LwTEmhYC2Z+EYk8JAligQZIlDQcahIONQkHEoyDgUZMExJoeCjENBxqEg41CQcSgocygocygocygocyho6hs+zzUmh4Iyh4Iyh4Iyh4Iyh4KcQ0HOoSDnUJBzKGjqWz/PNSaHgpxDQc6hIOdQkHMoKDgUFBwKCg4FBYeCpr4J9FxjcigoOBQUHAoKDgUFh4IKh4IKh4IKh4IKh4Kmvh30XGNyKKhwKKhwKKhwKKhwKKhyKKhyKKhyKKhyKGjqG0PPNSaHgiqHgl5xb+h66jit9d3ifnD0n4zp+zHLwb41ng7Tpj3MYHn/+fTh8DBHMtp4cNv+vvOcMeo7f0BdTX5s8orbQ/M1MTWBJllNoImrCTQJNYEmRU2gSVUTaDKoCTSRY7GJHAtNmhyLTeRYbCLHYhM5FpuEmkATORabyLHYRI7FJnIsNpFjoUmXY7GJHItN5FhsIsdik1ATaCLHYhM5FpvIsdhEjsUmcuyPTXKSY7GJHItN5FhsIsdik1ATaCLHYhM5FpvIsdhEjsUmciw0MTkWm8ix2ESOxSZyLDYJNYEmciw2kWOxyZIdOzw36VM2WbJj52qyZMfO1CQv2bFzNVmyY+dqsmTHztVkyY6dq0moCTRZsmPnarJkx87VRI7FJnIsNpFjoYnLsdhEjsUmciw2kWOxSagJNJFjsYkci03kWGwix2ITORaahByLTeRYbCLHYhM5FpuEmkATORabyLHYRI7FJnIsNpFjoUmRY7GJHItN5FhsIsdik1ATaCLHYhM5FpvIsdhEjsUmciw0qXIsNpFjsYkci03kWGwSagJN5FhsMrFjLZUynv1llcfjDMs6zi/Qm5mNH4CVlwd6vEZ//2v8iqcsnbyGTXCNPME1jv40Sbu3pBO716htt7SW9Pzt1p/+QR1/PM2rNy+ex83Li81x8ZZP+++D7U+Dg2fWZTuy2ofYb+0t9ROre4yPuOuHB8mRnsYsHGNWjjEHjjEbx5idYszjD2T5/cY0jjEzx5i+0DHDhv2vHJHd3vpfkP/xk/vV1GFPs14OLjLcf9i++ufi29XFx+vL2+07Hr74ff1pc3Wz3r3c/Pv16Svbtf8B"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2dW4wk51XHq3tqetrb0z0zuzt7m924jRBxlEiZm732A44RwQ+YgIJwXuIErb3rYOF48XqM7TfAiCCDoigPCFAcJRIPoAgCCMELEQ+JkIjCTSgPfoqlGAEKElJAKDdZ2ert//avz5yqvkyd7ur1lNTqunxffeec7/b/zjnfqVpy62jd/NX658v9/0Zy+FCah/v/20c7dkp813YknbUFobO+IHQuLQidaYl0ZrQtJcNH2fQuB8i1bBobC0DjSsn1LhrT/nnz5u+um78Tya2x99BDMlbvN5zseVbBmQBXkCbvpe8ywsmON3F+vv//EzduXHm5+/SzV6+91L3+wkH3+lPdJ66/8OzV55nxW9Nm/Pa0Gf+2NmXG79enzLiJ7nlP///KwcG1j//KQffgevf5F544uHHlyYPui08f/FL3+q9eu/HUM9df5AsuLE1Z8otHLfnXpi35t6bN+BfIePEwyVeuXs2n9svTFvoP02b8jyNQu5ROWehd02Z8Zzo9tT85baE/O23Gx6bN+PwR2Pz9aQv98hEK/ca0hW4uT5nxp6bN+OTy9Gx+c9pC721MX+gDjSkLfWjajI8fgdqXpi30lWkzvjptxj8+Apv/OG2h3zlCoUsrUxZ617QZ37kyGbW3IdV7+xkJ2bpJSdjxge0nG3g5y8iODOWk/Zv6z+hq9Z8xU3ZPM2AN9zSe1XFPnX8J91SbKWhZKZ/f+5oDkst77008n/FwV/9doruFcz67CNGl5fP4QBMyLu2929v7IXVyU3ZBddJbF0nuy/13N3GtOjjRPy9RB7PDsmv93wnTFlKcbyGt0kkeddCaHe1k0F9OFOSzy70O0jSQz44tulZdZ7La6J9n/02NCXj/av/8reToMry8s7+7s3/5cvaOFmhQnamsFM//Gum6oGsFfD58RLp0NI38SnrvDusi7b9b9DfA0xLqqpyyd/Y5LifgjUcX50ugp/QxrD8mlM/nrbpjfyrnvffdp3mRslo2suogDWloBcjP6gK7uG45ZZcni/uvZWWvjiGLVYee1RnLYtUpu0RZPJGV3R5DFm2HnvaMZaHyJqW5VQGam+a8nLLvf6rW53WULDoOPZ0Zy6LjlF2eLC5fzspeG0MWaw49azOWhcqblOZWBWhumvNyyt7t4eH1MWSx7tCzPmNZqLxJaW4tIM3tCtDcNOfllH15Pyt7YwxZbDj0bMxYFhtO2SXOJT2MeHIMWZx06Dk5Y1movElpXltAmtcrQHPTnJdT9uUHs7JPjSGLUw49p2Ysi1NO2SXKojf/nR5DFqcdek7PWBYqb1KaNxaQ5rUK0Nw05+WUvd/rf5tjyGLToWdzxrLYdMouURY9LHBmDFmcceg5M2NZqLw0GejkXgulZ+e+VpLvv0UaE0NjC+fUy53tnz+clKc/Y/2cRVnnSpfHrfqx7UXX50LL3unZOi4E8JS9d6v89/bmNtmVpAPfcmR1qX9ett76It5bQzm6n+L8D5FW6SQPjQeiPVsbydJ6qSDfGZOvgzTnkW/L5NO16jor/1P986i2NU67zjCpNy4HjIM93X8zGT7GGXc4xpRIz04Qn9u0KbyVlNv3zhlZNY2sOkjDMXpe4+Yxzcc059FMX4Ym7sl2rD6fjZUfXRqkC7Dd7LaSYbuaZJoYHnTQfhKgf99rJcO2rVH0UAceYRsJ4nObOuiyx0qrG101spq1Dtrad3RdpM89prl8mmkfp224g/Mq0DhLW1/T0ENfnsCyt+kPovdn119HuQHj2V7G8yrK64IOlZcizfcbg7SvI531LchrR1E2vrx2tAYa20a+kb4gaje1ZLgdURYBvn3bQTztUcZqJyuGpxRp/r3/zzExgUxsfan96J3txO97EfUV1C73OCdIZqJ/DTJTmv8eIbO8+aUFmdnxM4i33SB7YU9mJ43MRP8GZKY0/2v4tTI7mSMzjgvKS1tMhF9UKxn28xGNiaFRB7F1hJ1sUmxN+UTYilvJcH2Nooe2lwjbWSsZtqWPoifaftVKhm2Lo+iJtm20kmG70yh6ou0LrWTY9jOKHuoDiC11z8Pv1oZNX4o67qmePPtbinuidwXlB7TlvUllE92Wg/jsrXet/8um4Yl11sR/lP+L9QfQ9QbqYRKaOwtI8yz8jEbRHNPm9i4Hzc97GUY5AbmeNPIlXwHj6e6k+IB2iijdW4SdIuPprOFp1fDUQRruw4mwxxTpjM+iHiaheaMCNMfU3979Qbr7XfU/yfWckS/5ks2zTN0t6y1bCwlLqKwUzx+tDdI9WBvQFTB379L/Qcc8cWgQn9venHLG8ORhvaj1SC057OdlfecmpflsBWgOqr+9oHn59rgguZ408hVf1OnqXnb9gdrh52ed50F1svt2WgtY/Y+HUZWGewSj/JLzMGqRL3URzcsVoDmo/vaD1gq7FldvGPmKr2x+1T7gJzC//iL6p95R5rzP+VXvz8p9BLb/CN3rpPqcaP1bEJ+9ccHuUbP+3NyjRh1BlP3KrqV1XbSvrojmWewFLJvmYJvFWDTHtLlbOoII+63GMsm1beRLvqL8hdQ/dBSNGbRpRPgUBPHZGzNsvIGm4Yn+FNQRRNmY7Z5/aw+clOa1CtAcU3+3dAQB9vbbWEJyXTHyJV9qE2XrCFRv1BGk+NfzzwDDvAoME4Gx3k5YwtrlvTlOaagjiPKpypvjinzVimiehR/YKJqjMG+Uf4Sdl60PA2W7ae5l/fOztcPPW87zoDrZndTWHG3fCeLTXQucMjwRo1JHEIVRbd+0PqOT0rxZAZqD6m8/CFff7r+Sa9vIl/FLbB/P+uefOzq8Muf9IJy7P6nPSzSez+pAutGPXTt49NrLH7ryzNNXrxw8ff3Zn7/23AvXnj+ogUy6iJH0WjLMxltIU8d9uiWecp6/hf9IN+S87sRlfUD17wVB/94WPEFkufVZiMytv1/qV1aeW1/TyEf1rne2jaz0HwV11x0aE0OjDkLdZhA9k3Rhyidi2TepiiDYRXpn0i1OdM0KCL24x7C149BD1UIjQD5BfB76XEoXfNMlzgtPEhCasjfOpoYeXd8OrZwc07x9tGMsmrnc5LYCpVuvCI26Fxse9hYMm2ROWdTwsBlPdcPTuiN3pWFbrQfw6fUdXddRD8c0x9PMso+wdNqzN7Kyz40hi3MOPVFbxPNkcQ70eKojL5TePGm06ucotWsnGWBKD0/XSi6LmFT/AePhxNvvvVDXnD+9ENRVaB+NWHp2Jw3t5NHIfuaFizgfJEc7Nun6PGjUvTSYnpahZ5QcPRrZPyNCPLVQ7jg0XgCN50FbdlDdTtfbC/VBuqhtj3QR7Dp0pEjz9+kg7Tv6tLWTw6YCqvE5BsxrC0ZGo+f+OS/XU46bmxWVGd116eZh3Y65ZuA4NS+VfzvxzXjzMiF6a96qyYzrYPYZ3TuPe8rDcHMBppAeXpYuNe2/m3WcHbVk2ERGXplXaX68P2Zl49fP1AfpvL7omaGrUD90p1/EdhVlUuXc77n0lY3Nzxte2aa8vkO7TYm07NQMj+w3ooF94IPoA9+uH5ZTN5nNXMg24vU/71MNUXYva9a27qw0a3uhhMumJ29OGdX39Zx9Pyq8cF69boJGL1x1xLqc4x7x8xNo3xFbfWrJsKt8Nzk8TqdI8xvAz0/F0rbNNcVp0Pg0yo3Y8l8z5XWTw1tJUqR5L2TycYyfes41xYa5N09cRyxMzKTzc7hXhKOIo9vmXpC9vcef/fST/TQVbdne55dKpGc/yH6wP+lWcuo1AmzkUTbO/awtZW1xzfCxaq6rEMqO8z37eJXCtjH8H9fs9nNyXLOzz0bhgrw1u7fFlnK3OjHi12AXyiP5qUT4Gh3F1SxqTIjYOhLlAuhhP+sHRew3i8+r5G3vKPpUyTHN5dPsrfc5B69XhEb2af1H9EFicIY7/ULFMPj/Lw3SftHB4NSFebrVeW2bzMPgVndXNX1CO/G3SkbLsVYgx+P1yDA9HSOzWZadh/Pa+Nc5bchq22z/3pbACBxTNPYSi+oesaj9NCrHmSpsXfPC4BFXe22iTB0v8XrwGm5ozhoKCV4PrYc91oOds6jHVpq/wpz1+oLbohfVrurpthZVn3+sUx869sbVG9COtKh62yibZFB/dcPi2/7KsPg/qA/LgAffJTpPOzLzwsBGhb+2a5WMx9pSaLkTr5mexPyzvDSQ07jzT1T7z5t/WJfjzj92TTDvNZM3J+mc+Eh56KMSvW6x64RV3Bf+bSTDuJg+Kkpzpi9sr69S/mVv6w3Y09XrU7I9qE+1IQvxrjRbI3iP2AcXxHuvbdTBY/bu0w7vt/c5YDz5kf459zDSzrzjPNdRM9ddnNO+FfB50p4u+2L57+3pnC+B/24y/MlR8fQOyKAsnlh2rf9TOZdAg863lwZplU7yUB2K9qwvyC+YtNt8TZOvgzQXkO+iyadr1XUmux9DO9vBnBqx57UG+iwv/CwSfaP1f85JZ32uItdDK5BrF9ee3xL9uL11TpTPft6cybWY7nE/cVSYrXUjM6uHzVtj6TlxRlR7VFl6t92/kqdHU2hM6igeicWk+8TCCWSbGB50vF0+n8Hw0YvyKYrlBaQ5+tNLETSfqQDNWb/Vp3W5HtSndbnO/KiD5e5CHo1LJ3CPe0N1T2PnCt7BtR4/VZy354c+i0rzMeCFP8U619PzVMlnnmtaT1/JdW7H3JuFXUnvtnYlrmn5zK5paQOij3m0bUdzO8N76b7anta5du2SIs1LBWu9dnL4M4+My8D2FbVPPC8uQx00ch0XSM8ecbTts1xjKs2vF8iW7xKdkvUmeBNPF8BbwD7KPa6TbYymC+BNaT4xQkcQIf8g3nvtbAs8Zu8+5fCuNL+LsfiTmDfUDjmvvOY811GEITm3XArgmev0Et/bw5B3g/8uyiFPXcigLJ5YtnQEKkf3U5x/BjoCpZM8VIeiPeuL1Knk5WuYfB2kuYh8VrdgdRmZ7D6NdvbaDHQEF3N4oZ7U6nu4TlP6vDkiSvebN0eQbt3j+tLb66/nxCBReskVQzfnbdHo6Tvoa6J/65dAnBhlI8p4sLZSuyYgRmwk+ThXaf6yYF7J20tTAx62Ns4q+pwV2U8Wye/L83/i5+CJhwPGrB5mUV+xeIwxz5TmKyPwWMPIwNr9+VlyxjCJsId4eIz4Xf9K89U54bGIeGPExsJj9D3Sv9L8M+bJf3XwFnU/b5SAxwJsKztBOG+bWEPt6JLDE3FTWTyxbOExlaP7Kc6/ATymdJKH6lC0Z31ReJy023wNk6+DNFvId8nk07Xquud7h3b2xgzw2FYOL/RDUhr60Ef5NDQNPdYvkDpCO9crL30H/7NgzMrDlZ4PU5TuIc+HqQ4adc/DlcQdVcWV49r66L9s65R+qYu8X8H6Oi+CTjJqLzB1jRZ/qLwUadL+xJyHraxPumTNd1qfnai9h8S7ljfu1VWaEwW8Bcl/LxLrcyzO3n3K4V1p1hAXYKN/zjXVkK+e81xHEbaiL/2ixbS2GN3b403fkLJ4YtnCViqHumid350O0lq9M9fhol3zA2m3+ew+d/qQ0G8jTz/Dtdsm2pnaUaTtcCWHF2IrO0dG2fMzeqwt0+o5OD9YbEW/WKW5t2DM4v5QYhQbr2iecx33/hPzeT7JX1hwv/c87LFIfr/EjspDnWTb4a/p8Be1lrJrF12vgEZvP3IAPfuT6q3ePwJbWb2VZF2ktyK/7CsNcy+yTizdDSMDtptGLD2uj7RXJ0rzcyPqxM55kjXrxNqtdT8Br5b3iM8+FfG+6vD+oRF4OCK2TiQeZv12wRd5V5oPA6d8BHhXdUVd4zPOcx1FeJh+DBH27iC/8x4epr6smwzb1cUT/bjL4ollCw9bHV6K818GHra6P9WhaM/6pHA0abf5miZfJzmsa/X0erqmb8kVtLNngIej90hYXoiH6XMjeqJwlLVHTaJrpH5CaQ5G4GEvFpaHG6PsHXm4kWsr3fNiYdEHsaqxsKh/FF4kzqS/vHixdcrYidznR79Ku39QdU69Je3TD5coj028t+bIg3Eofxt9/O/SwzzdCXvnq7aGKYq5UrSG4Vq47D1/s7KN229scY3xByMwXcS+xMi1Be3E2btPO7wrzWfRDz8HzGYxey8uk/NcRxGmI4a/UzAdeaoCpvuzAkynOpwU062afEfBdH+EdvZFYLooX/F6Di+Mp2MxHbEQ9QNWr1aV+BtN3PP2tHk6pmi7it7dNHLsJIfXieNiIWKESDy3aXiwcbSJDxqJj6+4b+UrBfNKy8lr44VX4Xs7X0W//dHGgLaImCKTxkUN/sT6ThCf294az2KzDtKwv0fZJPLwI2NLTEJzsI1+LJpjcOvefVnZq2PIYtWhJ2r8zZMF9fpRcYDyfCVoI1WaN0rwlbA2+zx9ftPcm7eNheOV/qPwT157IGbwsE6VZEbMwL5tcQ1tN9HfA+baUu+2tgz6EHCdME+fN09XViWZdRLfBqZ71EVw7fFwiTSmeC/XEA2HHsZ1it6TmBqZ0S9F9+rJsO2NeZXmRj8AQPa3tDzgacORcUQM0exd60bGKqfo+yVROhiWLxlTr66y0yBZbBhZWP8p0qf6tbHN6av3PtRvp6B+aRvYQJ6Hlgc8B6w9Zhrjy9YjdV5n+nzeqTG+1hzelWYL9X2pf861KLHce5znOorWZccxvibniWVrPCiK8fXu5UFau59WdThpjK91k+8oMb7uQTt7D8aVqLXghRxeqGtSGu8buPTX9/ZMzmvdxvhZXFt7eM7bMzkrG3XbyJG6AMb9ilhLUI/IsiSbEvvp0Hc3uQfkIbT355y5d9S32OxeUuLcblLuXGnjeBBjZAf3Fz4yYq6MwL5BvLuxLvjtXt1XmkdRpx/AXGhjA2SPHnee6yiaKxnb5E6JdUGeupBBWTyxbM2VKseLdfFhzJVKJ3moDucZ6+KDaGePY66MWovnxbrg/KI0jOc3qznQfmOqlhy2u1h9K20WVwvGrEn2VkbFjcjzd/JiyVE/4s35ej6LvZWj9rLkxRopsvExhv9z6Act2JqiMEwe9iKG8XSkXoy5KFybF2OOfdXuTQjS9RfqGlm3Xjv1fKGqgKmDsek2xxa9P2vfr2Ccj7LLsG91E3/MVJq/aQzSfgK0RXyTwtsTnRX5asVkchUy+SQwvfdtt7a5F9m+x4lXY9eM48arObavDB37Qbqmfc7dOorWCRfBZ8TaKIpPfRe6afhIzX/wHifXJ0zXo+Ju2zigkXbbvPmVdtuiOZex57w5d55Yyq61x427EYSvdif1Y6UfR4SNgPPIOPRQJx01JgTwOfRNqrK/C23xctvIKg8vR/WLvDUT7aDHNMfT7PljcQ5erQiN1n4f1QeJwWk7/VrFMPi7gcH/xdGrj4p1OS/fQy9mQOS6PO+7J6PibK6ae5HYZtS3eblGCY6D5H43zVtHefE8A+SzHYUpiHvV30Q/MbjSvDnC3hNhk4pcS04SS/O/oH/8Fuw5wtvc3/4957mOIszGcf04luZ4PLHsWjI6luZ3Ye8pK5bmisl3lFia/4N29j3Mt1F6+60cXrimVBrPN4LrX0/3HbUXN0/3TZ8OxtfWPS8Gpae/mldsF/q6ensVyqRn3DU2bS70sa/yt3W8uJrRsa2EFWzZ7C+nKioz9pdR8bfsN4rmXdf2O0qRdc34CF2nbI4xGxWVGeua+/24h29WMRTs/kLSXxTPT2ne1ac5bx+lFxfvQh+UcB1GG663zoha9+TZa7juKbLXsF9WKZYybUUrsfS4cbqKfLwfLGgzfJfo9PYhMF6CeItaozVyeOM6RWneV8BblI995Botz3/dW5++H/qgR/rn3LdG3dJjznMdRWs02qLuFP918lQF//VfaAzSjvJDH9d/3doYj+K//tNoZ49hzpyV/7p48fzXOdbOys/H6mi9Odz6uXAO/0jBmEXdPH2G7LwdOdfl4SmuK63vVZ5vz9fuIF+RRYpZSzzCNa/y0Mel4fBXd/iL+uaiytK7dX0BNHq2oAB69qkjsvjD+wbkyyOwVd63W4itbu9Hc/hlX9ky9yLrZFQcI7abrVh69jhPFdWJ0vzmiDqxc55kzToRT0xLXVbd4T0AE+4X8Z46vP/OCDwc4dc0S5sFY/HqX2k+BZzyaeBd9is9/7zzXEcRHqbvWcBekh3aDUp873YNfKgd3e3wdA9kUBZPLFt4+B4j2xTnnwMeVjqlVR2K9uxaOJq023zWrtFBGmJ1a+uwtpVMdr+HdvZ54OGofVqXcnghHlaa4Bjhrk7f26PSBj1MQ/2E0vzJCDzs+SF6uDHChkhe9G5dc22le54fIuftRfJDpE1MeJH2L1un9Fsn3mdM3jWk7Sa+3WLW8TY8X5svoY//X+MwT8drmMnojlzDcC1cdkzeKDw7yRrjn0ZgugC93F7k2oJ+79m71xzelebf0A+/Dsxm/QWz5286z3UUYTpi+DsF05GnKmC6bxZgOtXhpJguNfmOguleRzt7cw6Yzq5BPUxHLOTtbZjFd62mxRSaYzhXejqmaLuK3k07i2jUPe6NHAcLESPM0s7t6aHzcDd9/ZTmuyNsyd6+xFeA77w4kx1zL1IenWRYHh0jD+KeTiw9ri/3sqGH+DJdGZYtD6+u2dbEm/edvqg4ySdzeKMuSmlOFPDWRLpuUi5eifbh0HzWdnhXmrWVgZw2+ud5McW6znMdRXjlJGQZEXs9e++Z8t/bwytnyT/KIU9cL5bFE8sWXlE5up/i/O6VQVqlkzxUh6I9aw+KS03abb51k4/zC+OqnzH5dM3Y6JtoZ2pHkWPt6RxelsELv/UjeqJsxHbs57goOaqeGiaN8jIW870FY1aeDsrOf0FjW+F+kZOgUfeIBy3PvXVU//yH17nQqyc8AQA=","debug_symbols":"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"}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"example_set","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"events":[{"fields":[{"name":"value2","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"value3","type":{"kind":"integer","sign":"unsigned","width":8}}],"kind":"struct","path":"TestLog::ExampleEvent1"},{"fields":[{"name":"value0","type":{"kind":"field"}},{"name":"value1","type":{"kind":"field"}}],"kind":"struct","path":"TestLog::ExampleEvent0"}],"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"secret","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurveScalar"}},{"name":"point","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"randomness","type":{"kind":"field"}},{"name":"event_type_id","type":{"kind":"field"}},{"name":"preimage","type":{"kind":"array","length":2,"type":{"kind":"field"}}}],"kind":"struct","path":"TestLog::compute_incoming_log_body_ciphertext_parameters"}},{"name":"return_type","type":{"kind":"array","length":144,"type":{"kind":"integer","sign":"unsigned","width":8}}}],"kind":"struct","path":"TestLog::compute_incoming_log_body_ciphertext_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"preimages","type":{"kind":"array","length":4,"type":{"kind":"field"}}}],"kind":"struct","path":"TestLog::emit_unencrypted_events_parameters"}}],"kind":"struct","path":"TestLog::emit_unencrypted_events_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"other","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"randomness","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"preimages","type":{"kind":"array","length":4,"type":{"kind":"field"}}}],"kind":"struct","path":"TestLog::emit_encrypted_events_parameters"}}],"kind":"struct","path":"TestLog::emit_encrypted_events_abi"}]}},"file_map":{"100":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/unencrypted_logs/unencrypted_event_emission.nr","source":"use crate::{\n    context::{PrivateContext, PublicContext}, event::event_interface::EventInterface,\n    encrypted_logs::payload::compute_encrypted_event_log, oracle::logs_traits::LensForEncryptedEvent\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Serialize};\n\nfn emit<Event, NB, MB, OB, N, M>(\n    context: &mut PublicContext,\n    event: Event\n) where Event: EventInterface<NB, MB>, Event: Serialize<N>, [Field; N]: LensForEventSelector<N, M> {\n    let selector = Event::get_event_type_id();\n\n    let serialized_event = event.serialize();\n    let mut emitted_log = [0; M];\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    for i in 0..serialized_event.len() {\n        emitted_log[i] = serialized_event[i];\n    }\n\n    emitted_log[serialized_event.len()] = selector.to_field();\n\n    context.emit_unencrypted_log(emitted_log);\n}\n\npub fn encode_event<Event, NB, MB, OB, N, M>(context: &mut PublicContext) -> fn[(&mut PublicContext,)](Event) -> () where Event: EventInterface<NB, MB>, Event: Serialize<N>, [Field; N]: LensForEventSelector<N, M> {\n    | e: Event | {\n        emit(\n          context,\n          e,\n        );\n    }\n}\n\ntrait LensForEventSelector<N, M> {\n    // N = event preimage input in fields\n    // M = event preimage input in fields + event selector as field\n    fn output(self: [Field; N]) -> [Field; M];\n}\n\nimpl LensForEventSelector<1, 2> for [Field; 1] {\n    fn output(self) -> [Field; 2] {[self[0] as Field; 2]}\n}\nimpl LensForEventSelector<2, 3> for [Field; 2] {\n    fn output(self) -> [Field; 3] {[self[0] as Field; 3]}\n}\nimpl LensForEventSelector<3, 4> for [Field; 3] {\n    fn output(self) -> [Field; 4] {[self[0] as Field; 4]}\n}\nimpl LensForEventSelector<4, 5> for [Field; 4] {\n    fn output(self) -> [Field; 5] {[self[0] as Field; 5]}\n}\nimpl LensForEventSelector<5, 6> for [Field; 5] {\n    fn output(self) -> [Field; 6] {[self[0] as Field; 6]}\n}\nimpl LensForEventSelector<6, 7> for [Field; 6] {\n    fn output(self) -> [Field; 7] {[self[0] as Field; 7]}\n}\n"},"102":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::{Point, pub_key_to_bytes},\n    constants::{GENERATOR_INDEX__IVSK_M, GENERATOR_INDEX__OVSK_M}, hash::poseidon2_hash\n};\n\nuse std::field::bytes32_to_field;\n\nuse crate::oracle::unsafe_rand::unsafe_rand;\n\nuse crate::event::event_interface::EventInterface;\nuse crate::note::note_interface::NoteInterface;\n\nuse crate::encrypted_logs::{\n    header::EncryptedLogHeader, incoming_body::EncryptedLogIncomingBody,\n    outgoing_body::EncryptedLogOutgoingBody\n};\n\npub fn compute_encrypted_event_log<Event, NB, MB, OB>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    event: Event\n) -> [u8; OB] where Event: EventInterface<NB, MB> {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    let eph_sk: Scalar = fr_to_fq(unsafe_rand());\n    let eph_pk = eph_sk.derive_public_key();\n\n    // TODO: (#7177) This value needs to be populated!\n    let recipient = AztecAddress::from_field(0);\n\n    let ivpk_app = compute_ivpk_app(ivpk, contract_address);\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_Header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_event(event, randomness).compute_ciphertext(eph_sk, ivpk_app);\n    let outgoing_body_ciphertext: [u8; 176] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk_app).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; OB] = [0; OB];\n    // @todo We ignore the tags for now \n\n    let eph_pk_bytes = pub_key_to_bytes(eph_pk);\n    for i in 0..64 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[128 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[176 + i] = outgoing_Header_ciphertext[i];\n    }\n    for i in 0..176 {\n        encrypted_bytes[224 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = OB - 400;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[400 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (64 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (176 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\npub fn compute_encrypted_note_log<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> [u8; M] where Note: NoteInterface<N, NB> {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    let eph_sk: Scalar = fr_to_fq(unsafe_rand());\n    let eph_pk = eph_sk.derive_public_key();\n\n    // TODO: (#7177) This value needs to be populated!\n    let recipient = AztecAddress::from_field(0);\n\n    let ivpk_app = compute_ivpk_app(ivpk, contract_address);\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_Header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_note(note, storage_slot).compute_ciphertext(eph_sk, ivpk_app);\n    let outgoing_body_ciphertext: [u8; 176] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk_app).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now \n\n    let eph_pk_bytes = pub_key_to_bytes(eph_pk);\n    for i in 0..64 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[128 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[176 + i] = outgoing_Header_ciphertext[i];\n    }\n    for i in 0..176 {\n        encrypted_bytes[224 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 400;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[400 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (64 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (176 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field elememt to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let r_bytes = r.to_be_bytes(32);\n\n    let mut high_bytes = [0; 32];\n    let mut low_bytes = [0; 32];\n\n    for i in 0..16 {\n        high_bytes[16 + i] = r_bytes[i];\n        low_bytes[16 + i] = r_bytes[i + 16];\n    }\n\n    let low = bytes32_to_field(low_bytes);\n    let high = bytes32_to_field(high_bytes);\n\n    Scalar::new(low, high)\n}\n\nfn compute_ivpk_app(ivpk: Point, contract_address: AztecAddress) -> Point {\n    // It is useless to compute this, it brings no value to derive fully.\n    // Issue(#6955)\n    ivpk\n    /*\n    // @todo Just setting infinite to false, but it should be checked.\n    // for example user could define ivpk = infinity using the registry\n    assert((ivpk.x != 0) & (ivpk.y != 0), \"ivpk is infinite\");\n\n    let i = fr_to_fq(poseidon2_hash([contract_address.to_field(), ivpk.x, ivpk.y, GENERATOR_INDEX__IVSK_M]));\n    let I = i.derive_public_key();\n\n    let embed_I = Point { x: I.x, y: I.y, is_infinite: false };\n    let embed_ivpk = Point { x: ivpk.x, y: ivpk.y, is_infinite: false };\n\n    let embed_result = embedded_curve_add(embed_I, embed_ivpk);\n\n    Point::new(embed_result.x, embed_result.y)*/\n}\n"},"104":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/outgoing_body.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash\n};\n\nuse std::aes128::aes128_encrypt;\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nstruct EncryptedLogOutgoingBody {\n    eph_sk: Scalar,\n    recipient: AztecAddress,\n    recipient_ivpk_app: Point,\n}\n\nimpl EncryptedLogOutgoingBody {\n    pub fn new(eph_sk: Scalar, recipient: AztecAddress, recipient_ivpk_app: Point) -> Self {\n        Self { eph_sk, recipient, recipient_ivpk_app }\n    }\n\n    pub fn compute_ciphertext(self, ovsk_app: Scalar, eph_pk: Point) -> [u8; 176] {\n        // Again, we could compute `eph_pk` here, but we keep the interface more similar\n        // and also make it easier to optimise it later as we just pass it along\n\n        let mut buffer: [u8; 160] = [0; 160];\n\n        let serialized_eph_sk_high = self.eph_sk.hi.to_be_bytes(32);\n        let serialized_eph_sk_low = self.eph_sk.lo.to_be_bytes(32);\n\n        let address_bytes = self.recipient.to_field().to_be_bytes(32);\n        let serialized_recipient_ivpk_app = self.recipient_ivpk_app.serialize();\n        let serialized_recipient_ivpk_app_x = serialized_recipient_ivpk_app[0].to_be_bytes(32);\n        let serialized_recipient_ivpk_app_y = serialized_recipient_ivpk_app[1].to_be_bytes(32);\n\n        for i in 0..32 {\n            buffer[i] = serialized_eph_sk_high[i];\n            buffer[i + 32] = serialized_eph_sk_low[i];\n            buffer[i + 64] = address_bytes[i];\n            buffer[i + 96] = serialized_recipient_ivpk_app_x[i];\n            buffer[i + 128] = serialized_recipient_ivpk_app_y[i];\n        }\n\n        // We compute the symmetric key using poseidon.\n        let full_key: [u8; 32] = poseidon2_hash(\n            [\n            ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y,\n            GENERATOR_INDEX__SYMMETRIC_KEY as Field\n        ]\n        ).to_be_bytes(32).as_array();\n\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(buffer, iv, sym_key).as_array()\n    }\n}\n\nmod test {\n    use crate::encrypted_logs::outgoing_body::EncryptedLogOutgoingBody;\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, hash::poseidon2_hash\n    };\n\n    use crate::context::PrivateContext;\n\n    #[test]\n    fn test_encrypted_log_outgoing_body() {\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        );\n        let recipient_ivsk_app = Scalar::new(\n            0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        );\n        let sender_ovsk_app = Scalar::new(\n            0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        );\n\n        let eph_pk = eph_sk.derive_public_key();\n        let recipient_ivpk_app = recipient_ivsk_app.derive_public_key();\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let body = EncryptedLogOutgoingBody::new(eph_sk, recipient, recipient_ivpk_app);\n\n        let ciphertext = body.compute_ciphertext(sender_ovsk_app, eph_pk);\n\n        let expected_outgoing_body_ciphertext = [\n            127, 84, 96, 176, 101, 107, 236, 57, 68, 8, 53, 202, 138, 74, 186, 54, 74, 193, 245, 7, 109, 59, 218, 33, 1, 31, 205, 225, 241, 209, 64, 222, 94, 245, 4, 150, 47, 241, 187, 64, 152, 20, 102, 158, 200, 217, 213, 82, 1, 240, 170, 185, 51, 80, 27, 109, 63, 231, 235, 120, 174, 44, 133, 248, 10, 97, 60, 40, 222, 190, 147, 76, 187, 48, 91, 206, 48, 106, 56, 118, 38, 127, 82, 4, 182, 188, 44, 224, 31, 129, 47, 107, 134, 252, 20, 25, 122, 191, 158, 69, 35, 255, 215, 171, 196, 45, 91, 184, 83, 80, 238, 201, 1, 233, 235, 159, 171, 130, 158, 64, 176, 165, 132, 30, 84, 81, 71, 195, 145, 47, 82, 247, 210, 192, 23, 4, 220, 90, 56, 109, 46, 105, 79, 251, 165, 141, 185, 233, 191, 118, 219, 153, 191, 162, 99, 238, 241, 249, 9, 74, 210, 241, 54, 28, 126, 226, 85, 235, 174, 75, 239, 207, 100, 184, 248, 194\n        ];\n\n        for i in 0..expected_outgoing_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_outgoing_body_ciphertext[i]);\n        }\n        assert_eq(expected_outgoing_body_ciphertext.len(), ciphertext.len());\n    }\n}\n"},"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\nstruct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext(self, secret: Scalar, point: Point) -> [u8; 48] {\n        let full_key = point_to_symmetric_key(secret, point);\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes(32).as_array();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nfn test_encrypted_log_header() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar::new(\n        0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    );\n    let point = Point::new(\n        0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        false\n    );\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    let expected_header_ciphertext = [\n        228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 23, 131, 32, 226, 26, 176, 43, 39, 239, 177, 177, 192, 85, 216, 17, 15, 18, 187, 35, 225, 135, 192, 63, 88, 29, 173, 232, 46, 72, 82, 187, 139\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext);\n}\n"},"106":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/incoming_body.nr","source":"use crate::note::note_interface::NoteInterface;\nuse crate::event::event_interface::EventInterface;\nuse dep::protocol_types::{scalar::Scalar, point::Point};\n\nuse std::aes128::aes128_encrypt;\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nstruct EncryptedLogIncomingBody<M> {\n    plaintext: [u8; M]\n}\n\nimpl<M> EncryptedLogIncomingBody<M> {\n    pub fn from_note<T, N>(note: T, storage_slot: Field) -> Self where T: NoteInterface<N, M> {\n        let mut plaintext = note.to_be_bytes(storage_slot);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn from_event<T, MR>(event: T, randomness: Field) -> Self where T: EventInterface<M, MR> {\n        let mut plaintext = event.private_to_be_bytes(randomness);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn compute_ciphertext(self, eph_sk: Scalar, ivpk_app: Point) -> [u8] {\n        let full_key = point_to_symmetric_key(eph_sk, ivpk_app);\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(self.plaintext, iv, sym_key)\n    }\n}\n\nmod test {\n    use crate::encrypted_logs::incoming_body::EncryptedLogIncomingBody;\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, traits::Serialize, abis::event_selector::EventSelector\n    };\n\n    use crate::{\n        note::{note_header::NoteHeader, note_interface::NoteInterface},\n        event::event_interface::EventInterface, oracle::unsafe_rand::unsafe_rand,\n        context::PrivateContext\n    };\n\n    struct AddressNote {\n        address: AztecAddress,\n        owner: AztecAddress,\n        randomness: Field,\n        header: NoteHeader,\n    }\n\n    global ADDRESS_NOTE_LEN: Field = 3;\n    global ADDRESS_NOTE_BYTES_LEN = 32 * 3 + 64;\n\n    impl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n        fn compute_note_content_hash(self) -> Field {1}\n\n        fn get_note_type_id() -> Field {\n            1\n        }\n\n        fn get_header(self) -> NoteHeader { self.header}\n\n        fn set_header(&mut self, header: NoteHeader) {self.header = header; }\n\n        fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n            (1, 1)\n        }\n\n        fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {(1,1)}\n\n        fn serialize_content(self) -> [Field; ADDRESS_NOTE_LEN] { [self.address.to_field(), self.owner.to_field(), self.randomness]}\n\n        fn deserialize_content(fields: [Field; ADDRESS_NOTE_LEN]) -> Self {\n            AddressNote { address: AztecAddress::from_field(fields[0]), owner: AztecAddress::from_field(fields[1]), randomness: fields[2], header: NoteHeader::empty() }\n        }\n\n        fn to_be_bytes(self, storage_slot: Field) -> [u8; ADDRESS_NOTE_BYTES_LEN] {\n            let serialized_note = self.serialize_content();\n\n            let mut buffer: [u8; ADDRESS_NOTE_BYTES_LEN] = [0; ADDRESS_NOTE_BYTES_LEN];\n\n            let storage_slot_bytes = storage_slot.to_be_bytes(32);\n            let note_type_id_bytes = AddressNote::get_note_type_id().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = storage_slot_bytes[i];\n                buffer[32 + i] = note_type_id_bytes[i];\n            }\n\n            for i in 0..serialized_note.len() {\n                let bytes = serialized_note[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n            buffer\n        }\n    }\n\n    impl AddressNote {\n        pub fn new(address: AztecAddress, owner: AztecAddress, randomness: Field) -> Self {\n            AddressNote { address, owner, randomness, header: NoteHeader::empty() }\n        }\n    }\n\n    #[test]\n    fn test_encrypted_note_log_incoming_body() {\n        let note = AddressNote::new(\n            AztecAddress::from_field(0x1),\n            AztecAddress::from_field(0x2),\n            3\n        );\n\n        let storage_slot = 2;\n\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        );\n        let ivpk_app = Point::new(\n            0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            false\n        );\n\n        let body = EncryptedLogIncomingBody::from_note(note, storage_slot);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk_app);\n\n        let expected_note_body_ciphertext = [\n            228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 63, 127, 188, 251, 150, 188, 238, 205, 3, 86, 102, 164, 175, 12, 137, 158, 163, 111, 205, 10, 229, 230, 46, 202, 110, 107, 156, 180, 67, 192, 161, 201, 48, 153, 169, 1, 25, 182, 93, 39, 39, 207, 251, 218, 234, 147, 156, 13, 110, 180, 190, 199, 41, 6, 211, 203, 176, 110, 165, 186, 110, 127, 199, 22, 201, 149, 92, 249, 219, 68, 145, 68, 179, 29, 233, 34, 98, 123, 197, 234, 169, 53, 44, 14, 81, 60, 92, 27, 250, 134, 49, 248, 57, 119, 236, 118, 158, 104, 82, 243, 98, 164, 60, 72, 74, 27, 177, 194, 221, 225, 193, 150, 67, 235, 205, 106, 150, 24, 126, 186, 220, 178, 199, 189, 113, 54, 181, 55, 46, 15, 236, 236, 9, 159, 5, 172, 237, 154, 110, 50, 241, 64, 92, 13, 37, 53, 20, 140, 42, 146, 229, 63, 97, 25, 159, 63, 235, 104, 68, 100\n        ];\n\n        assert_eq(expected_note_body_ciphertext.len(), ciphertext.len());\n\n        for i in 0..expected_note_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_note_body_ciphertext[i]);\n        }\n    }\n\n    struct TestEvent {\n        value0: Field,\n        value1: Field,\n        value2: Field,\n    }\n\n    impl Serialize<3> for TestEvent {\n        fn serialize(self) -> [Field; 3] {\n            [self.value0, self.value1, self.value2]\n        }\n    }\n\n    global TEST_EVENT_LEN: Field = 3;\n    global TEST_EVENT_BYTES_LEN = 32 * 3 + 64;\n    global TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS = 32 * 3 + 32;\n\n    impl EventInterface<TEST_EVENT_BYTES_LEN, TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS> for TestEvent {\n        fn get_event_type_id() -> EventSelector {\n            EventSelector::from_signature(\"TestEvent(Field,Field,Field)\")\n        }\n\n        fn private_to_be_bytes(self, randomness: Field) -> [u8; TEST_EVENT_BYTES_LEN] {\n            let mut buffer: [u8; TEST_EVENT_BYTES_LEN] = [0; TEST_EVENT_BYTES_LEN];\n\n            let randomness_bytes = randomness.to_be_bytes(32);\n            let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = randomness_bytes[i];\n                buffer[32 + i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes = serialized_event[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn to_be_bytes(self) -> [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] {\n             let mut buffer: [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] = [0; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS];\n\n             let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n             for i in 0..32 {\n                 buffer[i] = event_type_id_bytes[i];\n            }\n\n             let serialized_event = self.serialize();\n\n             for i in 0..serialized_event.len() {\n                 let bytes = serialized_event[i].to_be_bytes(32);\n                 for j in 0..32 {\n                     buffer[32 + i * 32 + j] = bytes[j];\n                }\n            }\n\n             buffer\n        }\n\n        fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n            _emit(self);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_event_incoming_body() {\n        let test_event = TestEvent { value0: 1, value1: 2, value2: 3 };\n\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        );\n\n        let ivpk_app = Point::new(\n            0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            false\n        );\n\n        let randomness = 2;\n\n        let body = EncryptedLogIncomingBody::from_event(test_event, randomness);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk_app);\n\n        let expected_event_body_ciphertext = [\n            228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 63, 127, 188, 251, 150, 188, 238, 205, 3, 86, 102, 164, 175, 12, 137, 158, 163, 111, 205, 10, 229, 230, 46, 202, 110, 107, 156, 180, 67, 192, 161, 201, 66, 122, 29, 35, 42, 33, 153, 216, 199, 208, 103, 207, 126, 153, 189, 136, 19, 220, 238, 15, 169, 29, 255, 11, 123, 107, 70, 192, 53, 40, 36, 93, 187, 32, 123, 136, 104, 23, 229, 245, 152, 90, 84, 2, 136, 112, 42, 27, 82, 214, 104, 14, 250, 48, 199, 245, 88, 22, 200, 77, 38, 51, 127, 56, 138, 255, 16, 46, 179, 129, 215, 185, 185, 116, 148, 16, 133, 62, 56, 180, 10, 132, 109, 77, 206, 199, 21, 167, 7, 163, 171, 158, 244, 23, 18, 121, 108, 42, 107, 7, 48, 84, 212, 104, 39, 16, 109, 7, 108, 129, 60, 80, 112, 241, 223, 140, 186, 158, 38, 74, 230, 213, 159, 175, 142, 228, 128, 160\n        ];\n\n        assert_eq(expected_event_body_ciphertext.len(), ciphertext.len());\n\n        for i in 0..expected_event_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_event_body_ciphertext[i]);\n        }\n    }\n}\n"},"107":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_event_emission.nr","source":"use crate::{\n    context::PrivateContext, event::event_interface::EventInterface,\n    encrypted_logs::payload::compute_encrypted_event_log, oracle::logs_traits::LensForEncryptedEvent,\n    oracle::unsafe_rand::unsafe_rand\n};\nuse dep::protocol_types::{address::AztecAddress, point::Point, hash::sha256_to_field};\n\nunconstrained fn compute_unconstrained<Event, NB, MB, OB>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    event: Event\n) -> ([u8; OB], Field) where Event: EventInterface<NB, MB>, [u8; NB]: LensForEncryptedEvent<NB, OB> {\n    compute(contract_address, randomness, ovsk_app, ovpk, ivpk, event)\n}\n\nfn compute<Event, NB, MB, OB>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    event: Event\n) -> ([u8; OB], Field) where Event: EventInterface<NB, MB>, [u8; NB]: LensForEncryptedEvent<NB, OB> {\n    let encrypted_log: [u8; OB] = compute_encrypted_event_log(contract_address, randomness, ovsk_app, ovpk, ivpk, event);\n    let log_hash = sha256_to_field(encrypted_log);\n    (encrypted_log, log_hash)\n}\n\nfn emit_with_keys<Event, NB, MB, OB>(\n    context: &mut PrivateContext,\n    randomness: Field,\n    event: Event,\n    ovpk: Point,\n    ivpk: Point,\n    inner_compute: fn(AztecAddress, Field, Field, Point, Point, Event) -> ([u8; OB], Field)\n) where Event: EventInterface<NB, MB>, [u8; NB]: LensForEncryptedEvent<NB, OB> {\n    let contract_address: AztecAddress = context.this_address();\n    let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n    let (encrypted_log, log_hash) = inner_compute(contract_address, randomness, ovsk_app, ovpk, ivpk, event);\n    context.emit_raw_event_log_with_masked_address(randomness, encrypted_log, log_hash);\n}\n\npub fn encode_and_encrypt_event<Event, NB, MB, OB>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](Event) -> () where Event: EventInterface<NB, MB>, [u8; NB]: LensForEncryptedEvent<NB, OB> {\n    | e: Event | {\n        let header = context.get_header();\n        let ovpk = header.get_ovpk_m(context, ov);\n        let ivpk = header.get_ivpk_m(context, iv);\n        let randomness = unsafe_rand();\n        emit_with_keys(context, randomness, e, ovpk, ivpk, compute);\n    }\n}\n\npub fn encode_and_encrypt_event_unconstrained<Event, NB, MB, OB>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](Event) -> () where Event: EventInterface<NB, MB>, [u8; NB]: LensForEncryptedEvent<NB, OB> {\n    | e: Event | {\n        let header = context.get_header();\n        let ovpk = header.get_ovpk_m(context, ov);\n        let ivpk = header.get_ivpk_m(context, iv);\n        let randomness = unsafe_rand();\n        emit_with_keys(context, randomness, e, ovpk, ivpk, compute_unconstrained);\n    }\n}\n\npub fn encode_and_encrypt_event_with_randomness<Event, NB, MB, OB>(\n    context: &mut PrivateContext,\n    randomness: Field,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress, Field)](Event) -> () where Event: EventInterface<NB, MB>, [u8; NB]: LensForEncryptedEvent<NB, OB> {\n    | e: Event | {\n        let header = context.get_header();\n        let ovpk = header.get_ovpk_m(context, ov);\n        let ivpk = header.get_ivpk_m(context, iv);\n        emit_with_keys(context, randomness, e, ovpk, ivpk, compute);\n    }\n}\n\npub fn encode_and_encrypt_event_with_randomness_unconstrained<Event, NB, MB, OB>(\n    context: &mut PrivateContext,\n    randomness: Field,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress, Field)](Event) -> () where Event: EventInterface<NB, MB>, [u8; NB]: LensForEncryptedEvent<NB, OB> {\n    | e: Event | {\n        let header = context.get_header();\n        let ovpk = header.get_ovpk_m(context, ov);\n        let ivpk = header.get_ivpk_m(context, iv);\n        emit_with_keys(context, randomness, e, ovpk, ivpk, compute_unconstrained);\n    }\n}\n\npub fn encode_and_encrypt_event_with_keys<Event, NB, MB, OB>(\n    context: &mut PrivateContext,\n    ovpk: Point,\n    ivpk: Point\n) -> fn[(&mut PrivateContext, Point, Point)](Event) -> () where Event: EventInterface<NB, MB>, [u8; NB]: LensForEncryptedEvent<NB, OB> {\n    | e: Event | {\n        let randomness = unsafe_rand();\n        emit_with_keys(context, randomness, e, ovpk, ivpk, compute);\n    }\n}\n\npub fn encode_and_encrypt_event_with_keys_unconstrained<Event, NB, MB, OB>(\n    context: &mut PrivateContext,\n    ovpk: Point,\n    ivpk: Point\n) -> fn[(&mut PrivateContext, Point, Point)](Event) -> () where Event: EventInterface<NB, MB>, [u8; NB]: LensForEncryptedEvent<NB, OB> {\n    | e: Event | {\n        let randomness = unsafe_rand();\n        emit_with_keys(context, randomness, e, ovpk, ivpk, compute_unconstrained);\n    }\n}\n\npub fn encode_and_encrypt_event_with_keys_with_randomness<Event, NB, MB, OB>(\n    context: &mut PrivateContext,\n    randomness: Field,\n    ovpk: Point,\n    ivpk: Point\n) -> fn[(&mut PrivateContext, Field, Point, Point)](Event) -> () where Event: EventInterface<NB, MB>, [u8; NB]: LensForEncryptedEvent<NB, OB> {\n    | e: Event | {\n        emit_with_keys(context, randomness, e, ovpk, ivpk, compute);\n    }\n}\n\npub fn encode_and_encrypt_event_with_keys_with_randomness_unconstrained<Event, NB, MB, OB>(\n    context: &mut PrivateContext,\n    randomness: Field,\n    ovpk: Point,\n    ivpk: Point\n) -> fn[(&mut PrivateContext, Field, Point, Point)](Event) -> () where Event: EventInterface<NB, MB>, [u8; NB]: LensForEncryptedEvent<NB, OB> {\n    | e: Event | {\n        emit_with_keys(context, randomness, e, ovpk, ivpk, compute_unconstrained);\n    }\n}\n"},"112":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__INNER_NOTE_HASH,\n    hash::{\n    pedersen_hash, compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_inner_note_hash_from_preimage(storage_slot: Field, note_content_hash: Field) -> Field {\n    pedersen_hash(\n        [storage_slot, note_content_hash],\n        GENERATOR_INDEX__INNER_NOTE_HASH\n    )\n}\n\nfn compute_inner_note_hash<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    compute_inner_note_hash_from_preimage(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N, M>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let (_, inner_nullifier) = note_with_header.compute_note_hash_and_nullifier(context);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\nfn compute_note_hash_for_read_request_from_innter_and_nonce(\n    inner_note_hash: Field,\n    nonce: Field\n) -> Field {\n    // TODO(#1386): This if-else can be nuked once we have nonces injected from public\n    if (nonce == 0) {\n        // If nonce is zero, that means we are reading a public note.\n        inner_note_hash\n    } else {\n        compute_unique_note_hash(nonce, inner_note_hash)\n    }\n}\n\npub fn compute_note_hash_for_read_request<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let inner_note_hash = compute_inner_note_hash(note);\n    let nonce = note.get_header().nonce;\n\n    compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, nonce)\n}\n\npub fn compute_note_hash_for_consumption<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    if (header.note_hash_counter != 0) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        inner_note_hash\n    } else {\n        // If a note is not transient, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the siloed_note_hash which has already been hashed with\n        // nonce and then contract address. This hash will match the existing leaf in the note hash\n        // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, header.nonce);\n        compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, N, M, S>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n    let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, note_header.nonce);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        let (_, nullifier) = note.compute_note_hash_and_nullifier_without_context();\n        nullifier\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [inner_note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"124":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::{address::AztecAddress, point::Point};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<M>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<M>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<M>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32\n) {}\n\nunconstrained pub fn emit_encrypted_event_log<M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<N, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<N, M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\n}\n"},"127":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle<N>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<N>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<N>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n"},"128":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n"},"132":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<N>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field\n) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number as Field, N)\n}\n\nunconstrained pub fn storage_read<T, N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"133":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/unsafe_rand.nr","source":"#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n\n// Called `unsafe_rand` because we do not constrain in circuit that we are dealing with an actual random value.\n// Instead we just trust our PXE.\nunconstrained pub fn unsafe_rand() -> Field {\n    rand_oracle()\n}\n"},"136":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use crate::keys::PublicKeys;\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained fn get_public_keys_and_partial_address_oracle_wrapper(address: AztecAddress) -> [Field; 13] {\n    get_public_keys_and_partial_address_oracle(address)\n}\n\nfn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle_wrapper(address);\n\n    let keys = PublicKeys {\n        npk_m: Point::new(result[0], result[1], result[2] as bool),\n        ivpk_m: Point::new(result[3], result[4], result[5] as bool),\n        ovpk_m: Point::new(result[6], result[7], result[8] as bool),\n        tpk_m: Point::new(result[9], result[10], result[11] as bool)\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"155":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_delay_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initally equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation \n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the \n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a \n// reduced delay, invalidating prior private reads.\nstruct ScheduledDelayChange<INITIAL_DELAY> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option, \n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pre: Option<u32>,\n    post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numeric value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\nimpl<INITIAL_DELAY> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior contraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This \n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is \n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in \n            //                             which to scheduled value change\n\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY)\n            )\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Serialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn serialize(self) -> [Field; 1] {\n        // We pack all three u32 values into a single U128, which is made up of two u64 limbs.\n        // Low limb: [ pre_inner: u32 | post_inner: u32 ]\n        // High limb: [ empty | pre_is_some: u8 |  post_is_some: u8 | block_of_change: u32 ]\n\n        let lo = ((self.pre.unwrap_unchecked() as u64) * (1 << 32))\n            + (self.post.unwrap_unchecked() as u64);\n\n        let hi = (self.pre.is_some() as u64) * (1 << 33) \n            + (self.post.is_some() as u64 * (1 << 32)) \n            + self.block_of_change as u64;\n\n        let packed = U128::from_u64s_le(lo, hi);\n\n        [packed.to_integer()]\n    }\n}\n\nimpl<INITIAL_DELAY> Deserialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn deserialize(input: [Field; 1]) -> Self {\n        let packed = U128::from_integer(input[0]);\n\n        // We use division and modulo to clear the bits that correspond to other values when unpacking.\n\n        let pre_is_some = ((packed.hi as u64) / (1 << 33)) as bool;\n        let pre_inner = ((packed.lo as u64) / (1 << 32)) as u32;\n\n        let post_is_some = (((packed.hi as u64) / (1 << 32)) % (1 << 1)) as bool;\n        let post_inner = ((packed.lo as u64) % (1 << 32)) as u32;\n\n        let block_of_change = ((packed.hi as u64) % (1 << 32)) as u32;\n\n        Self {\n            pre: if pre_is_some { Option::some(pre_inner) } else { Option::none() },\n            post: if post_is_some { Option::some(post_inner) } else { Option::none() },\n            block_of_change,\n            _dummy: [0; INITIAL_DELAY],\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"157":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable_private_getter.nr","source":"use dep::protocol_types::{\n    hash::{pedersen_hash, poseidon2_hash}, traits::{FromField, ToField}, address::AztecAddress,\n    header::Header\n};\n\nuse crate::context::PrivateContext;\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{\n    shared_mutable::SharedMutable, scheduled_delay_change::ScheduledDelayChange,\n    scheduled_value_change::ScheduledValueChange\n}\n};\n\nstruct SharedMutablePrivateGetter<T, INITIAL_DELAY> {\n    context: &mut PrivateContext,\n    // The contract address of the contract we want to read from\n    other_contract_address: AztecAddress,\n    // The storage slot where the SharedMutable is stored on the other contract\n    storage_slot: Field,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numberic value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\n// We have this as a view-only interface to reading Shared Mutables in other contracts.\n// Currently the Shared Mutable does not support this. We can adapt SharedMutable at a later date\nimpl<T, INITIAL_DELAY> SharedMutablePrivateGetter<T, INITIAL_DELAY> {\n    pub fn new(\n        context: &mut PrivateContext,\n        other_contract_address: AztecAddress,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        assert(other_contract_address.to_field() != 0, \"Other contract address cannot be 0\");\n        Self { context, other_contract_address, storage_slot, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    pub fn get_value_in_private(self, header: Header) -> T where T: FromField + ToField + Eq {\n        // We create a dummy SharedMutable state variable so that we can reuse its historical_read_from_public_storage\n        // method, greatly reducing code duplication. \n        let dummy: SharedMutable<T, INITIAL_DELAY, ()> = SharedMutable::new((), self.storage_slot);\n        let (value_change, delay_change, historical_block_number) = dummy.historical_read_from_public_storage(header, self.other_contract_address);\n\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // If our context has the same header as the one we pass in via the parameter, we are trying to read the \"current\" value\n        // and thus need to set the tx max block number below. If the context header is not the same as the one we pass in, this means\n        // we are trying to read a historical value and thus have no constraint on the max block number that this transaction can be included in.\n        if (self.context.historical_header.global_variables.block_number.eq(header.global_variables.block_number)) {\n            self.context.set_tx_max_block_number(block_horizon);\n        }\n\n        value_change.get_current_at(historical_block_number)\n    }\n}\n"},"159":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_value_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\nstruct ScheduledValueChange<T> {\n    pre: T,\n    post: T,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Serialize<3> for ScheduledValueChange<T> {\n    fn serialize(self) -> [Field; 3] where T: ToField {\n        [self.pre.to_field(), self.post.to_field(), self.block_of_change.to_field()]\n    }\n}\n\nimpl<T> Deserialize<3> for ScheduledValueChange<T> {\n  fn deserialize(input: [Field; 3]) -> Self  where T: FromField {\n    Self {\n        pre: FromField::from_field(input[0]),\n        post: FromField::from_field(input[1]),\n        block_of_change: FromField::from_field(input[2]),\n    }\n  }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>  {\n    fn eq(self, other: Self) -> bool where T: Eq {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"160":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable.nr","source":"use dep::protocol_types::{\n    hash::{pedersen_hash, poseidon2_hash}, header::Header, address::AztecAddress,\n    traits::{FromField, ToField}\n};\n\nuse crate::context::{PrivateContext, PublicContext};\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{scheduled_value_change::ScheduledValueChange, scheduled_delay_change::ScheduledDelayChange}\n};\nuse crate::oracle::storage::storage_read;\nuse dep::std::unsafe::zeroed;\n\nmod test;\n\nstruct SharedMutable<T, INITIAL_DELAY, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Serialize<N> trait, and allocate N storage slots to\n// this state variable. This is incorrect, since what we actually store is:\n//  - a ScheduledValueChange<T>, which requires 1 + 2 * M storage slots, where M is the serialization length of T\n//  - a ScheduledDelayChange, which requires another storage slot\n//\n// TODO https://github.com/AztecProtocol/aztec-packages/issues/5736: change the storage allocation scheme so that we\n// can actually use it here\nimpl<T, INITIAL_DELAY, Context> Storage<T> for SharedMutable<T, INITIAL_DELAY, Context> {}\n\n// TODO: extract into a utils module once  we can do arithmetic on generics, i.e. https://github.com/noir-lang/noir/issues/4784\nfn concat_arrays<N, M, O>(arr_n: [Field; N], arr_m: [Field; M]) -> [Field; O] {\n    assert_eq(N + M, O);\n    let mut out: [Field; O] = [0; O];\n    for i in 0..N {\n        out[i] = arr_n[i];\n    }\n    for i in 0..M {\n        out[N+i] = arr_m[i];\n    }\n    out\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, INITIAL_DELAY, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    fn hash_scheduled_data(\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) -> Field where T: ToField {\n        // TODO(#5491 and https://github.com/noir-lang/noir/issues/4784): update this so that we don't need to rely on\n        // ScheduledValueChange serializing to 3 and ScheduledDelayChange serializing to 1\n        let concatenated: [Field; 4] = concat_arrays(value_change.serialize(), delay_change.serialize());\n        poseidon2_hash(concatenated)\n    }\n\n    // Since we can't rely on the native storage allocation scheme, we hash the storage slot to get a unique location in\n    // which we can safely store as much data as we need.\n    // See https://github.com/AztecProtocol/aztec-packages/issues/5492 and\n    // https://github.com/AztecProtocol/aztec-packages/issues/5736\n    // We store three things in public storage:\n    //  - a ScheduledValueChange\n    //  - a ScheduledDelaChange\n    //  - the hash of both of these (via `hash_scheduled_data`)\n    fn get_value_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 0], 0)\n    }\n\n    fn get_delay_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 1], 0)\n    }\n\n    fn get_hash_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 2], 0)\n    }\n\n    // It may seem odd that we take a header and address instead of reading from e.g. a PrivateContext, but this lets us\n    // reuse this function in SharedMutablePrivateGetter.\n    fn historical_read_from_public_storage(\n        self,\n        header: Header,\n        address: AztecAddress\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) where T: FromField + ToField + Eq {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for both the ScheduledValueChange and\n        // ScheduledDelayChange, but that'd require one full sibling path per storage slot (since due to kernel siloing\n        // the storage is not contiguous), and in the best case in which T is a single field that'd be 4 slots.\n        // Instead, we get an oracle to provide us the correct values for both the value and delay changes, and instead\n        // prove inclusion of their hash, which is both a much smaller proof (a single slot), and also independent of\n        // the size of T.\n        let (value_change_hint, delay_change_hint) = get_public_storage_hints(address, self.storage_slot, historical_block_number);\n\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let hash = header.public_storage_historical_read(self.get_hash_storage_slot(), address);\n\n        // @todo This is written strangely to bypass a formatting issue with the if that is breaking ci.\n        let (a, b, c) = if hash != 0 {\n            let a = SharedMutable::hash_scheduled_data(value_change_hint, delay_change_hint);\n            (a, value_change_hint, delay_change_hint)\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized, meaning no value or delay change was ever\n            // scheduled. Therefore, the hints must then correspond to uninitialized scheduled changes.\n            let b = ScheduledValueChange::deserialize(zeroed());\n            let c = ScheduledDelayChange::deserialize(zeroed());\n            (hash, b, c)\n        };\n\n        assert_eq(hash, a, \"Hint values do not match hash\");\n        assert_eq(value_change_hint, b, \"Non-zero value change for zero hash\");\n        assert_eq(delay_change_hint, c, \"Non-zero delay change for zero hash\");\n\n        (value_change_hint, delay_change_hint, historical_block_number)\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PublicContext> {\n    pub fn schedule_value_change(self, new_value: T) where T: ToField {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) where T: ToField {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value_in_public(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay_in_public(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value_in_public(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay_in_public(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        self.context.storage_read(self.get_delay_change_storage_slot())\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) where T: ToField {\n        // Whenever we write to public storage, we write both the value change and delay change as well as the hash of\n        // them both. This guarantees that the hash is always kept up to date.\n        // While this makes for more costly writes, it also makes private proofs much simpler because they only need to\n        // produce a historical proof for the hash, which results in a single inclusion proof (as opposed to 4 in the\n        // best case scenario in which T is a single field). Private shared mutable reads are assumed to be much more\n        // frequent than public writes, so this tradeoff makes sense.\n        self.context.storage_write(self.get_value_change_storage_slot(), value_change);\n        self.context.storage_write(self.get_delay_change_storage_slot(), delay_change);\n        self.context.storage_write(\n            self.get_hash_storage_slot(),\n            SharedMutable::hash_scheduled_data(value_change, delay_change)\n        );\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext> {\n    pub fn get_current_value_in_private(self) -> T where T: FromField + ToField + Eq {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n\n        let (value_change, delay_change, historical_block_number) = self.historical_read_from_public_storage(self.context.get_header(), self.context.this_address());\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n}\n\nunconstrained fn get_public_storage_hints<T, INITIAL_DELAY>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>) {\n    // This function cannot be part of the &mut PrivateContext impl because that'd mean that by passing `self` we'd also\n    // be passing a mutable reference to an unconstrained function, which is not allowed. We therefore create a dummy\n    // state variable here so that we can access the methods to compute storage slots. This will all be removed in the\n    // future once we do proper storage slot allocation (#5492).\n    let dummy = SharedMutable::new((), storage_slot);\n\n    (\n        storage_read(address, dummy.get_value_change_storage_slot(), block_number), storage_read(address, dummy.get_delay_change_storage_slot(), block_number)\n    )\n}\n"},"180":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point::new(fields[0], fields[1], fields[2] as bool),\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"183":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        EventSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"21":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    fn new(x: Field, y: Field, is_infinite: bool) -> Self {\n        Self { x, y, is_infinite }\n    }\n\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n// Scalar represented as low and high limbs\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    pub fn derive_public_key(self) -> EmbeddedCurvePoint {\n        let public_key = fixed_base_scalar_mul(self.lo, self.hi);\n        EmbeddedCurvePoint { x: public_key[0], y: public_key[1], is_infinite: false }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, key: EmbeddedCurveScalar) -> bool {\n        (key.hi == self.hi) & (key.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n#[foreign(multi_scalar_mul)]\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> [Field; 3]\n// docs:end:multi_scalar_mul\n{}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(\n    scalar_low: Field,\n    scalar_high: Field\n) -> [Field; 3]\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    let scalar = EmbeddedCurveScalar { lo: scalar_low, hi: scalar_high };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n"},"217":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"22":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"229":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"235":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<N> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<N> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<N> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<N> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"238":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"246":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: Field = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point {\n            x: 0,\n            y: 0,\n            is_infinite: false\n        }\n    }\n}\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn pub_key_to_bytes(pk: Point) -> [u8; 64] {\n    assert(!pk.is_infinite, \"Point at infinity is not a valid public key.\");\n    let mut result = [0 as u8; 64];\n    let x_bytes = pk.x.to_be_bytes(32);\n    let y_bytes = pk.y.to_be_bytes(32);\n    for i in 0..32 {\n        result[i] = x_bytes[i];\n        result[i + 32] = y_bytes[i];\n    }\n    result\n}\n"},"25":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n#[no_predicates]\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    let value = pedersen_commitment_with_separator(input, 0);\n    if (value.x == 0) & (value.y == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value.x, y: value.y, is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        points[i] = EmbeddedCurveScalar::from_field(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let values = multi_scalar_mul(generators, points);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: values[2] as bool }\n}\n\n#[no_predicates]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let v1 = pedersen_commitment_with_separator(input, separator);\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    multi_scalar_mul(\n        [length_generator[0], v1],\n        [EmbeddedCurveScalar { lo: N as Field, hi: 0 }, EmbeddedCurveScalar { lo: 1, hi: 0 }]\n    )[0]\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n#[test]\nfn assert_pedersen_noir() {\n    // TODO: make this a fuzzer test once fuzzer supports curve-specific blackbox functions.\n    let input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq(pedersen_hash_with_separator(input, 4), pedersen_hash_with_separator_noir(input, 4));\n    assert_eq(pedersen_commitment_with_separator(input, 4), pedersen_commitment_with_separator_noir(input, 4));\n}\n"},"273":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"32":{"path":"std/merkle.nr","source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n"},"330":{"path":"/usr/src/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Deserialize, Serialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n"},"38":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"388":{"path":"/usr/src/noir-projects/noir-contracts/contracts/test_log_contract/src/main.nr","source":"contract TestLog {\n    use dep::aztec::prelude::PrivateSet;\n    use dep::aztec::protocol_types::{traits::Serialize, point::Point, scalar::Scalar, address::AztecAddress};\n    use dep::value_note::value_note::ValueNote;\n    use dep::aztec::encrypted_logs::incoming_body::EncryptedLogIncomingBody;\n    use dep::aztec::event::event_interface::EventInterface;\n    use dep::aztec::encrypted_logs::encrypted_event_emission::encode_and_encrypt_event_with_randomness;\n    use dep::aztec::unencrypted_logs::unencrypted_event_emission::encode_event;\n\n    #[aztec(event)]\n    struct ExampleEvent0 {\n        value0: Field,\n        value1: Field,\n    }\n\n    #[aztec(event)]\n    struct ExampleEvent1 {\n        value2: AztecAddress,\n        value3: u8,\n    }\n\n    #[aztec(storage)]\n    struct Storage {\n        example_set: PrivateSet<ValueNote>,\n    }\n\n    // EXAMPLE_EVENT_0_BYTES_LEN + 16\n    global EXAMPLE_EVENT_0_CIPHERTEXT_BYTES_LEN = 144;\n\n    #[aztec(private)]\n    fn compute_incoming_log_body_ciphertext(\n        secret: Scalar,\n        point: Point,\n        randomness: Field,\n        event_type_id: Field,\n        preimage: [Field; 2]\n    ) -> [u8; EXAMPLE_EVENT_0_CIPHERTEXT_BYTES_LEN] {\n        EncryptedLogIncomingBody::from_event(\n            ExampleEvent0 { value0: preimage[0], value1: preimage[1] },\n            randomness\n        ).compute_ciphertext(secret, point).as_array()\n    }\n\n    #[aztec(private)]\n    fn emit_encrypted_events(other: AztecAddress, randomness: [Field; 2], preimages: [Field; 4]) {\n        let event0 = ExampleEvent0 { value0: preimages[0], value1: preimages[1] };\n\n        event0.emit(\n            encode_and_encrypt_event_with_randomness(\n                &mut context,\n                randomness[0],\n                // outgoing is set to other, incoming is set to msg sender\n                other,\n                context.msg_sender()\n            )\n        );\n\n        // We duplicate the emission, but specifying different incoming and outgoing parties\n        event0.emit(\n            encode_and_encrypt_event_with_randomness(\n                &mut context,\n                randomness[0],\n                // outgoing is set to msg sender, incoming is set to other\n                context.msg_sender(),\n                other\n            )\n        );\n\n        let event1 = ExampleEvent1 { value2: AztecAddress::from_field(preimages[2]), value3: preimages[3] as u8 };\n\n        event1.emit(\n            encode_and_encrypt_event_with_randomness(\n                &mut context,\n                randomness[1],\n                // outgoing is set to other, incoming is set to msg sender\n                other,\n                context.msg_sender()\n            )\n        );\n    }\n\n    #[aztec(public)]\n    fn emit_unencrypted_events(preimages: [Field; 4]) {\n        let event0 = ExampleEvent0 { value0: preimages[0], value1: preimages[1] };\n\n        event0.emit(encode_event(&mut context));\n\n        let event1 = ExampleEvent1 { value2: AztecAddress::from_field(preimages[2]), value3: preimages[3] as u8 };\n\n        event1.emit(encode_event(&mut context));\n    }\n}\n"},"4":{"path":"std/cmp.nr","source":"// docs:start:eq-trait\ntrait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\nimpl Eq for Field { fn eq(self, other: Field) -> bool { self == other } }\n\nimpl Eq for u64 { fn eq(self, other: u64) -> bool { self == other } }\nimpl Eq for u32 { fn eq(self, other: u32) -> bool { self == other } }\nimpl Eq for u8 { fn eq(self, other: u8) -> bool { self == other } }\nimpl Eq for u1 { fn eq(self, other: u1) -> bool { self == other } }\n\nimpl Eq for i8 { fn eq(self, other: i8) -> bool { self == other } }\nimpl Eq for i32 { fn eq(self, other: i32) -> bool { self == other } }\nimpl Eq for i64 { fn eq(self, other: i64) -> bool { self == other } }\n\nimpl Eq for () { fn eq(_self: Self, _other: ()) -> bool { true } }\nimpl Eq for bool { fn eq(self, other: bool) -> bool { self == other } }\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3) & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\nstruct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n// docs:start:ord-trait\ntrait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"47":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"5":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\nstruct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len);\n        self.get_unchecked(index)\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Responds with undefined data for `index` where `self.len < index < self.max_len()`.\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Does not check whether the passed `index` is a valid index within the vector.\n    ///\n    /// Silently writes past the end of the vector for `index` where `self.len < index < self.max_len()`\n    /// Panics if the given index points beyond the maximum length of the vector (`self.max_len()`).\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        \n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen>  {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n    // TODO: Allow imports from \"super\"\n    use crate::collections::bounded_vec::BoundedVec;\n\n    #[test]\n    fn empty_equality() {\n        let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n        let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n        assert_eq(bounded_vec1, bounded_vec2);\n    }\n\n    #[test]\n    fn inequality() {\n        let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n        let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n        bounded_vec1.push(1);\n        bounded_vec2.push(2);\n\n        assert(bounded_vec1 != bounded_vec2);\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n}\n"},"64":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::{Point, pub_key_to_bytes},\n    utils::arr_copy_slice\n};\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret_fields = multi_scalar_mul([point], [secret]);\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/6061): make the func return Point struct directly\n    let shared_secret = pub_key_to_bytes(Point::new(shared_secret_fields[0], shared_secret_fields[1], false));\n    let mut shared_secret_bytes_with_separator = [0 as u8; 65];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[64] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nfn check_point_to_symmetric_key() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar::new(\n        0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    );\n    let point = Point::new(\n        0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        false\n    );\n\n    let key = point_to_symmetric_key(secret, point);\n    // The following value gets updated when running encrypt_buffer.test.ts with AZTEC_GENERATE_TEST_DATA=1\n    let expected_key = [\n        49, 167, 146, 222, 151, 129, 138, 184, 87, 210, 245, 249, 99, 100, 1, 59, 223, 180, 5, 99, 14, 7, 177, 236, 159, 203, 231, 72, 220, 180, 241, 23\n    ];\n    assert_eq(key, expected_key);\n}\n"},"65":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::PrivateContext,\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}},\n    state_vars::{shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter}\n};\n\nglobal DELAY = 5;\n\n// docs:start:key-getters\ntrait KeyGetters {\n  fn get_npk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ivpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ovpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_tpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_npk_m_hash(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Field;\n}\n\nimpl KeyGetters for Header {\n    fn get_npk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, NULLIFIER_INDEX, self)\n    }\n\n    fn get_ivpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, INCOMING_INDEX, self)\n    }\n\n    fn get_ovpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, OUTGOING_INDEX, self)\n    }\n\n    fn get_tpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, TAGGING_INDEX, self)\n    }\n\n    fn get_npk_m_hash(self, context: &mut PrivateContext, address: AztecAddress) -> Field {\n        get_master_key(context, address, NULLIFIER_INDEX, self).hash()\n    }\n}\n// docs:end:key-getters\n\nfn get_master_key(\n    context: &mut PrivateContext,\n    address: AztecAddress,\n    key_index: Field,\n    header: Header\n) -> Point {\n    let key = fetch_key_from_registry(context, key_index, address, header);\n    if is_empty(key) {\n        // Keys were not registered in registry yet --> fetch key from PXE\n        let keys = fetch_and_constrain_keys(address);\n        // Return the corresponding to index\n        keys.get_key_by_index(key_index)\n    } else {\n        // Keys were registered --> return the key\n        key\n    }\n}\n\nfn fetch_key_from_registry(\n    context: &mut PrivateContext,\n    key_index: Field,\n    address: AztecAddress,\n    header: Header\n) -> Point {\n    let x_coordinate_map_slot = key_index * 2 + 1;\n    let y_coordinate_map_slot = x_coordinate_map_slot + 1;\n    let x_coordinate_derived_slot = derive_storage_slot_in_map(x_coordinate_map_slot, address);\n    let y_coordinate_derived_slot = derive_storage_slot_in_map(y_coordinate_map_slot, address);\n\n    let x_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        x_coordinate_derived_slot\n    );\n    let y_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        y_coordinate_derived_slot\n    );\n    let x_coordinate = x_coordinate_registry.get_value_in_private(header);\n    let y_coordinate = y_coordinate_registry.get_value_in_private(header);\n\n    Point::new(x_coordinate, y_coordinate, false)\n}\n\n// Passes only when keys were not rotated - is expected to be called only when keys were not registered yet\nfn fetch_and_constrain_keys(address: AztecAddress) -> PublicKeys {\n    let (public_keys, partial_address) = get_public_keys_and_partial_address(address);\n\n    let computed_address = AztecAddress::compute(public_keys.hash(), partial_address);\n\n    assert(computed_address.eq(address));\n\n    public_keys\n}\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n"},"66":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr","source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH, hash::poseidon2_hash,\n    point::Point, traits::{Deserialize, Serialize, Empty, is_empty}\n};\nuse crate::keys::constants::{NUM_KEY_TYPES, NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX};\n\nglobal PUBLIC_KEYS_LENGTH = 12;\n\nstruct PublicKeys {\n    npk_m: Point,\n    ivpk_m: Point,\n    ovpk_m: Point,\n    tpk_m: Point,\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m : Point::empty(),\n            ivpk_m : Point::empty(),\n            ovpk_m : Point::empty(),\n            tpk_m : Point::empty()\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        ( self.npk_m == other.npk_m ) &\n        ( self.ivpk_m == other.ivpk_m ) &\n        ( self.ovpk_m == other.ovpk_m ) &\n        ( self.tpk_m == other.tpk_m )\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash(\n                [\n                self.npk_m.x,\n                self.npk_m.y,\n                self.npk_m.is_infinite as Field,\n                self.ivpk_m.x,\n                self.ivpk_m.y,\n                self.ivpk_m.is_infinite as Field,\n                self.ovpk_m.x,\n                self.ovpk_m.y,\n                self.ovpk_m.is_infinite as Field,\n                self.tpk_m.x,\n                self.tpk_m.y,\n                self.tpk_m.is_infinite as Field,\n                GENERATOR_INDEX__PUBLIC_KEYS_HASH\n            ]\n            )\n        }\n        )\n    }\n\n    pub fn get_key_by_index(self, index: Field) -> Point {\n        assert(index as u8 < NUM_KEY_TYPES, \"Invalid key index\");\n        if index == NULLIFIER_INDEX {\n            self.npk_m\n        } else if index == INCOMING_INDEX {\n            self.ivpk_m\n        } else if index == OUTGOING_INDEX {\n            self.ovpk_m\n        } else {\n            self.tpk_m\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.x,\n            self.npk_m.y,\n            self.npk_m.is_infinite as Field,\n            self.ivpk_m.x,\n            self.ivpk_m.y,\n            self.ivpk_m.is_infinite as Field,\n            self.ovpk_m.x,\n            self.ovpk_m.y,\n            self.ovpk_m.is_infinite as Field,\n            self.tpk_m.x,\n            self.tpk_m.y,\n            self.tpk_m.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: Point::new(serialized[0], serialized[1], serialized[2] as bool),\n            ivpk_m: Point::new(serialized[3], serialized[4], serialized[5] as bool),\n            ovpk_m: Point::new(serialized[6], serialized[7], serialized[8] as bool),\n            tpk_m: Point::new(serialized[9], serialized[10], serialized[11] as bool)\n        }\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: Point { x: 1, y: 2, is_infinite: false },\n        ivpk_m: Point { x: 3, y: 4, is_infinite: false },\n        ovpk_m: Point { x: 5, y: 6, is_infinite: false },\n        tpk_m: Point { x: 7, y: 8, is_infinite: false }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x146f68c0e0ba4067d61a3304bbfdec0797d5df1357db6c01247c48bfb345c7d7;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nfn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nfn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: Point { x: 1, y: 2, is_infinite: false },\n        ivpk_m: Point { x: 3, y: 4, is_infinite: false },\n        ovpk_m: Point { x: 5, y: 6, is_infinite: false },\n        tpk_m: Point { x: 7, y: 8, is_infinite: false }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.x, deserialized.npk_m.x);\n    assert_eq(keys.npk_m.y, deserialized.npk_m.y);\n    assert_eq(keys.ivpk_m.x, deserialized.ivpk_m.x);\n    assert_eq(keys.ivpk_m.y, deserialized.ivpk_m.y);\n    assert_eq(keys.ovpk_m.x, deserialized.ovpk_m.x);\n    assert_eq(keys.ovpk_m.y, deserialized.ovpk_m.y);\n    assert_eq(keys.tpk_m.x, deserialized.tpk_m.x);\n    assert_eq(keys.tpk_m.y, deserialized.tpk_m.y);\n}\n"},"80":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"95":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn block_number(self) -> Field {\n        block_number()\n    }\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<N>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<N>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, N>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N)\n}\n\nunconstrained fn storage_write<N>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<N>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<N>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}