{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"Benchmarking","functions":[{"name":"increment_balance","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"value","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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y33FPfKlGGtNMVAUKNIuCkXaRaFIuygUaReFIu0iUAzaRaFIuygUaReFIu2iUAwUBYq0i0KRqfuuYk7X7wE+/WPt9wCDqVuhyNQtUNyYuhWKTN0KRaZuhSJTt0IxUBQoMnUrFPmJgUKRdlEo0i4KRdpFoMih8RJF2kWhSLsoFGkXhWKgKFCkXRSKtItCkXZRKNIuCkXaRaDIkeMSRabuf1O8wTBIvwITwNRhGHdfgWGCfQWGQcB8ouPGUbF+crZH7eRMdXZy5kU7eUDuJmfGtZMzPdvJ2Sy2k7OzbCenPtXkx3aRlxo5J637yalPOzn1aSenPu3kAbmbnPp0n1vKSet+curTTk592smpTzP5zknrfnLq005OfdrJqU87eUDuJqc+7eTUp52c+rSTU592curTTc6J9n5y6tNOTn3ayalPO3lA7ianPu3k1KednPq0k1OfdnLq002eqU87OfVpJ6c+7eTUp508IHeTU592curTTk592smpTzs59ekmX6lPOzn1aSenPu3k1KednLlcS36W25mpZ9lr4EzlZnBmcjM4E7kXPJjHzeBM42ZwZnEzOJO4GTwA94LzMyAzOKVpBqc0zeCUphmc0vSCb5SmGZzSNINTmmZwSlP8M5/lsktLihp5QO4mpzbt5PSmnZzitJPTnHZyqtNNvtOddnLK005Oe9rJqU87eUAuJk/lIl9TjZz6tJNTn3Zy6tNOTn3ayalPN/lBfX7BIbFOTn265/KD+rSTU5928oDcTU592smpTzs59Wknpz7t5NSnm7xQn3Zy6tNOTn3ayalPO3lA7ianPu3k1KednPq0k1OfdnLq001+Up92curTTk592smpTzt5QO4mpz7t5NSnnZz6tJNTn3Zy6tNMfizUp52c+rSTU592curTTh6Qu8mpTzs59Wknpz7t5NSnnZz6dJMn6tNOTn3ayalPOzn1aScPyN3k1KednPq0kzOXa8lL2p4fW9JZAc9M5WLw6/WV7aiBM5ObwZnIzeBMKmZw5hQzOHvkZnB2yM3gzOFe8JU53AzOHG4GZw43g7MvbgYPwL3glKYZnNI0g1OaYvBrEaXU9sNXStMMTml6wYPSNINTmmZwStMMTmmawQNwLzilaQanNM3glKYZnNI0g1OaXvCN0jSDU5pmcErTDE5pmsEDcC84pWkGpzTN4JSmGZzSNINTml7wndI0g1OaZnBK0wxOaZrBA3AvOKVpBqc0zeCUphmc0jSDU5pe8IPSNINTmmZwStMMTmmawQNwLzilaQanNM3glKYZnNL0ghfCxwxO+JjBCR8zOOFjBg/AveD9Y+Gayu11rvs98G07nx+8HekF8Omr3BZURlvQOdiCzmW0BaXRFpTNCzpvf/K+7NUFraMtKEZb0DbagvbRFnSMtiD3nbrk27d9KdUFnWMtqCzLaAtKoy0oj7agdbQFxWgL2kZb0D7ago7RFjTYnboso92p02h36jTanTqNdqdOo92p02h36jTanTqNdqdOo92p02h36jTanTqPdqfOo92p82h36jzanTqPdqfOo92p82h36jzanTqPdqfOo92p19Hu1Otod+p1tDv1Otqdeh3tTr2Odqdex7lTP/3b/379t2+//uN33/z49Ixf/s+/f/+nn7794fvnf/3p//76r//n6bH/Dw=="},{"name":"recreate_note","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"outgoing_viewer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"create_note","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"outgoing_viewer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"value","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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7tb74G69D+7W++BuvQ/u1vvgbr0P7tb74G69D+7W++Cutg/uavvgbr0P7tb74G69D+7W++BuvQ/u1vvgbr0P7tb74G69D+7W++BuvQ/u1vvgbr0P7tb74G69D+7W++BuvQ/u1vvgbr0P7mr74K62D+5q++Cutg/uavvgrrYP7mr74K62D+5q++Cutg/uavvgrrcP7nr74K63D+56++Cutw/uevvgrrcP7nr74K63D+56++Cutw/uevvgrrcP7nr74K63D+56++Cutw/uevvgrrcP7nr74K63D+56++Cutw/uevvgrrcP7nr74K63D+56++Cutw/uevvgLrgP7oL74C64D+6C++AuuA/ugvvgLrgP7oL74C64D+6C++AuuA/uavvg2Md4M4barw+Eov52TJY9r5+7nyH9gZ8r3/y5+s2f2//xn2tbfTNpjvaaQrffLaFLnb/9XPnmz9Vv/tz+zZ+Lb/5c++bP5Td/7vaoaqW/fq6Nv/u5u78f93736WYZ22+UsYQyV1Dun8yPU8oSSl1C2ZdQ4jllXO/+bfZ7SltCySWUvoQyllDmCsq+LaF84Nmf1784HcR7Sl1C2ZdQYgmlLaHkEkpfQhkfpZT7N/8+V1BiW0J5/uyX/TdK3P93ibqEsi+hxBJKW0LJJZROp8z6y+1vWM3XX5hrn7/7i+H5reyWI39p9/8KuvfXN4Qifndq1vjbPx3/1//86T///Kd//rd//a/jJ/A//vdf/uWvf/73v/z6f/71f//j//+X49f+Hw=="},{"name":"broadcast","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/83XW4/SQBQH8Cl3WBahpVDuBVoKkpj1YX3R1cR3n/wEJl5evCRe4nf0UznnzJz+wZpu5oUsSe1w+v/NrZLNJKqqVEtfSi2U/VBF9VRD3zy6Xipp6UZFX15PeVJK6SGpSmpjqsotCtY2+p/OrZIhEuqbu2imMlqdB+RPExnqp5HgSUK5sw/10uJZ8vgt003ddtNOK/ZBGx22TaZpmnQvklo5OZuSLKbzvHaSof46xfnS58rM94quOjfb9mst4eHUdZ3v1N+1vrpmkBf66uc71sOO9c937BGm19cdvtX3gQn3bNjnRQ6oBeabTN80mf5EWWjAlAIBaAAaWPoNZaFDphQYgg5Bh5Z+R1loyJQCIWgIGlr6DmWhI6YUGIGOQEeWfkJZ6JgpBcagY9CxpR9QFhoxpUAEGoFGlsYoC50wpcAEdAI6sfQHykKnTCkwBZ2CTi39jLLQGVMKzEBnoDNzL5LAnfjuJConek03KAudM6XAHHQOOi+ONs9HKyF6tK8oC10wpcACdAG6KI62yHfQkfjuJHInoTuZXoTcs2P6/fxGWeiSKQWWoEvQZXG0Zf4rLiF6tPcoC10xpcAKdAW6svQJykJjphSIQWPQuDjROH/FjmTgTnx3EriToTsJ3cnInYwv8l4m7mR6kffiX2Qt9+yY/t18QVnomikF1qBr0LWlv1AWumFKgQ3oBnRTnOgmX5sj8d1J9FAnFrqT4UPYMf2/4CPKQrdMKbAF3YJui6Nt8zU5ksCdxO4kKid6G56iLDRhSoEENAFNiqMl+Z+sEkI/L+81zjN3DOU808d5htIqlZON7rGm8El5qPR8qJ3BiWnKEzow7RDa41x0aHDzYPOP9UZQ4uhx8EglunjGr8w3WS6ZYyqxDAObBxVTpIcywp7u+uV5tyfT+mfCzzy72rvimZGPgubMSBtRO1l2vntd7N7ObKFk0oym1Lbfuie4kR9qiWS82DfU4snYT9V0zrGMl02rOzkbp2hm/5tOdj6dHV7CHr3zFqUy0QPiB5PZy1beeFZkWxos+kPXXzorf8+/EAAA","debug_symbols":"5dzNTlNRGIXhe+mYmL3Wt3+5FWNMVTRNSDFSTQzh3i3SQzH8lAGR86YzCpvD2gz6dvRcLb6cffr57eNq/fXicnH6/mpxfvF5uVldrLevrhbpndLf715+X65vvnG5Wf7YLE6drZPF2frLzZe5XZ8svq7Ozxan4X598uD0iL47PHq/O6ucHzmrknZnNfZn7fHYc/PI04NLif3pnK4/nNyMF3m8yeODPD6Txxfy+EYe38njB3i8yZEyOVImR8rkSJkcKZMj5UoeTy6sX6GwSjWmRXI6MH8anw48taXpX9Jc7j2z3g6PRB0u6nBThwd1eKYOL9ThlTq8UYdjAzSgwzO1nJlazkwtZ6aWM1PLmanlzNRyZmo5M7WcmVrOQi1noZazUMtZqOUs1HIWajkLtZyFWs5CLWehlrNSy1mp5azUclZqOSu1nJVazkotZ6WWs1LLWanlbNRyNmo5G7WcjVrORi1no5azUcvZqOVs1HI2ajk7tZydWs5OLWenlrNTy9mp5ezUcnZqOTu1nJ1azkEt56CWc1DLOajlHNRyDmo5B7Wcg1rOQS3noJZTiZpOJWo7lajxVKLWU4maTyVqP7d/FLucWlAlakKVsA0VtqHCNlTYhgrb0NdAcd5oObahwjZU2IYK21BhG2psQ41tqLENNbahr2H2vNFybEONbaixDcU6PTK2oVhiSFhjSFhkSFhlSFhmSFhnSFhoSFhpSFhqSFhrSFhsSFhtSFhuSFhvSFhwSFhxSFhySFhzSFh0SFh1SFh2SFh3SFh4SFh5SFh6SFh7SFh8SFh9SFh+SFh/SFiASFiBSFiCSFiDSFiESFiFSFiGSFiHSFiISFiJSFiKSFiLSFiMSFiNSFiOSFiPSFiQSFiRSFiSSFiTSFiUSFiVSFiWSFiXSFiYSFiZSFiaSFibSFicSFidSFieSFifSFigSFihSFiiSFijSFikSFilSFimSFinyFinyFinyFinyFinyInaUGOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdImOdosA6RYF1igLrFAXWKYpEbWhgnaLAOkWBdYoC6xQF1ikKrFMUWKcosE5RYJ2iwDpFgXWKAusUBdYpCqxTFFinKLBOUWCdoniBU1TyweWt7Zfrn7/y8HSJyLvTJeq4Oz3KY4c1pn9KsQ4c7iVNO3rJcf/w7rL5mC5bjumy9Zgu247psv2YLjv+/2U17i7b0vP7NXKdHj3KPieOvLvAC5ikmV9A9AuYfoGgXyDTL/D4J4cY3l+gHLhALWX63Kl4flCrbXq/bU3p4bviEz7S2+1pM9vTZ7ZnzGvPE+7Q2+3RzPZ4ZntiZnvyzPbM5/15++LX8sdq+en87HL7Kzc/+7n+vFldrHcvN7+/3/5ke/YP"}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"notes","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"value","type":{"kind":"field"}}],"kind":"struct","path":"Benchmarking::increment_balance_parameters"}}],"kind":"struct","path":"Benchmarking::increment_balance_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"outgoing_viewer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"Benchmarking::recreate_note_parameters"}}],"kind":"struct","path":"Benchmarking::recreate_note_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"outgoing_viewer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"value","type":{"kind":"field"}}],"kind":"struct","path":"Benchmarking::create_note_parameters"}}],"kind":"struct","path":"Benchmarking::create_note_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Benchmarking::broadcast_parameters"}}],"kind":"struct","path":"Benchmarking::broadcast_abi"}]}},"file_map":{"102":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::{Point, pub_key_to_bytes},\n    constants::{GENERATOR_INDEX__IVSK_M, GENERATOR_INDEX__OVSK_M}, hash::poseidon2_hash\n};\n\nuse std::field::bytes32_to_field;\n\nuse crate::oracle::unsafe_rand::unsafe_rand;\n\nuse crate::event::event_interface::EventInterface;\nuse crate::note::note_interface::NoteInterface;\n\nuse crate::encrypted_logs::{\n    header::EncryptedLogHeader, incoming_body::EncryptedLogIncomingBody,\n    outgoing_body::EncryptedLogOutgoingBody\n};\n\npub fn compute_encrypted_event_log<Event, NB, MB, OB>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    event: Event\n) -> [u8; OB] where Event: EventInterface<NB, MB> {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    let eph_sk: Scalar = fr_to_fq(unsafe_rand());\n    let eph_pk = eph_sk.derive_public_key();\n\n    // TODO: (#7177) This value needs to be populated!\n    let recipient = AztecAddress::from_field(0);\n\n    let ivpk_app = compute_ivpk_app(ivpk, contract_address);\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_Header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_event(event, randomness).compute_ciphertext(eph_sk, ivpk_app);\n    let outgoing_body_ciphertext: [u8; 176] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk_app).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; OB] = [0; OB];\n    // @todo We ignore the tags for now \n\n    let eph_pk_bytes = pub_key_to_bytes(eph_pk);\n    for i in 0..64 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[128 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[176 + i] = outgoing_Header_ciphertext[i];\n    }\n    for i in 0..176 {\n        encrypted_bytes[224 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = OB - 400;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[400 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (64 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (176 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\npub fn compute_encrypted_note_log<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> [u8; M] where Note: NoteInterface<N, NB> {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    let eph_sk: Scalar = fr_to_fq(unsafe_rand());\n    let eph_pk = eph_sk.derive_public_key();\n\n    // TODO: (#7177) This value needs to be populated!\n    let recipient = AztecAddress::from_field(0);\n\n    let ivpk_app = compute_ivpk_app(ivpk, contract_address);\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_Header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_note(note, storage_slot).compute_ciphertext(eph_sk, ivpk_app);\n    let outgoing_body_ciphertext: [u8; 176] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk_app).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now \n\n    let eph_pk_bytes = pub_key_to_bytes(eph_pk);\n    for i in 0..64 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[128 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[176 + i] = outgoing_Header_ciphertext[i];\n    }\n    for i in 0..176 {\n        encrypted_bytes[224 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 400;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[400 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (64 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (176 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field elememt to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let r_bytes = r.to_be_bytes(32);\n\n    let mut high_bytes = [0; 32];\n    let mut low_bytes = [0; 32];\n\n    for i in 0..16 {\n        high_bytes[16 + i] = r_bytes[i];\n        low_bytes[16 + i] = r_bytes[i + 16];\n    }\n\n    let low = bytes32_to_field(low_bytes);\n    let high = bytes32_to_field(high_bytes);\n\n    Scalar::new(low, high)\n}\n\nfn compute_ivpk_app(ivpk: Point, contract_address: AztecAddress) -> Point {\n    // It is useless to compute this, it brings no value to derive fully.\n    // Issue(#6955)\n    ivpk\n    /*\n    // @todo Just setting infinite to false, but it should be checked.\n    // for example user could define ivpk = infinity using the registry\n    assert((ivpk.x != 0) & (ivpk.y != 0), \"ivpk is infinite\");\n\n    let i = fr_to_fq(poseidon2_hash([contract_address.to_field(), ivpk.x, ivpk.y, GENERATOR_INDEX__IVSK_M]));\n    let I = i.derive_public_key();\n\n    let embed_I = Point { x: I.x, y: I.y, is_infinite: false };\n    let embed_ivpk = Point { x: ivpk.x, y: ivpk.y, is_infinite: false };\n\n    let embed_result = embedded_curve_add(embed_I, embed_ivpk);\n\n    Point::new(embed_result.x, embed_result.y)*/\n}\n"},"103":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    encrypted_logs::payload::compute_encrypted_note_log, oracle::logs_traits::LensForEncryptedLog\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field, address::AztecAddress, point::Point, abis::note_hash::NoteHash,\n    constants::MAX_NOTE_HASHES_PER_CALL, utils::arrays::find_index\n};\n\nunconstrained fn compute_unconstrained<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    compute(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note)\n}\n\nfn compute<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let encrypted_log: [u8; M] = compute_encrypted_note_log(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note);\n    let log_hash = sha256_to_field(encrypted_log);\n    (encrypted_log, log_hash)\n}\n\nfn emit_with_keys<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    note: Note,\n    ovpk: Point,\n    ivpk: Point,\n    inner_compute: fn(AztecAddress, Field, Field, Point, Point, Note) -> ([u8; M], Field)\n) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    let note_exists_index = find_index(\n        context.note_hashes.storage,\n        |n: NoteHash| n.counter == note_hash_counter\n    );\n    assert(\n        note_exists_index as u32 != MAX_NOTE_HASHES_PER_CALL, \"Can only emit a note log for an existing note.\"\n    );\n\n    let contract_address: AztecAddress = context.this_address();\n    let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n    let (encrypted_log, log_hash) = inner_compute(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n\npub fn encode_and_encrypt_note<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let header = context.get_header();\n        let ovpk = header.get_ovpk_m(context, ov);\n        let ivpk = header.get_ivpk_m(context, iv);\n        emit_with_keys(context, e.note, ovpk, ivpk, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let header = context.get_header();\n        let ovpk = header.get_ovpk_m(context, ov);\n        let ivpk = header.get_ivpk_m(context, iv);\n        emit_with_keys(context, e.note, ovpk, ivpk, compute_unconstrained);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ovpk: Point,\n    ivpk: Point\n) -> fn[(&mut PrivateContext, Point, Point)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys_unconstrained<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ovpk: Point,\n    ivpk: Point\n) -> fn[(&mut PrivateContext, Point, Point)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, compute_unconstrained);\n    }\n}\n"},"104":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/outgoing_body.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash\n};\n\nuse std::aes128::aes128_encrypt;\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nstruct EncryptedLogOutgoingBody {\n    eph_sk: Scalar,\n    recipient: AztecAddress,\n    recipient_ivpk_app: Point,\n}\n\nimpl EncryptedLogOutgoingBody {\n    pub fn new(eph_sk: Scalar, recipient: AztecAddress, recipient_ivpk_app: Point) -> Self {\n        Self { eph_sk, recipient, recipient_ivpk_app }\n    }\n\n    pub fn compute_ciphertext(self, ovsk_app: Scalar, eph_pk: Point) -> [u8; 176] {\n        // Again, we could compute `eph_pk` here, but we keep the interface more similar\n        // and also make it easier to optimise it later as we just pass it along\n\n        let mut buffer: [u8; 160] = [0; 160];\n\n        let serialized_eph_sk_high = self.eph_sk.hi.to_be_bytes(32);\n        let serialized_eph_sk_low = self.eph_sk.lo.to_be_bytes(32);\n\n        let address_bytes = self.recipient.to_field().to_be_bytes(32);\n        let serialized_recipient_ivpk_app = self.recipient_ivpk_app.serialize();\n        let serialized_recipient_ivpk_app_x = serialized_recipient_ivpk_app[0].to_be_bytes(32);\n        let serialized_recipient_ivpk_app_y = serialized_recipient_ivpk_app[1].to_be_bytes(32);\n\n        for i in 0..32 {\n            buffer[i] = serialized_eph_sk_high[i];\n            buffer[i + 32] = serialized_eph_sk_low[i];\n            buffer[i + 64] = address_bytes[i];\n            buffer[i + 96] = serialized_recipient_ivpk_app_x[i];\n            buffer[i + 128] = serialized_recipient_ivpk_app_y[i];\n        }\n\n        // We compute the symmetric key using poseidon.\n        let full_key: [u8; 32] = poseidon2_hash(\n            [\n            ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y,\n            GENERATOR_INDEX__SYMMETRIC_KEY as Field\n        ]\n        ).to_be_bytes(32).as_array();\n\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(buffer, iv, sym_key).as_array()\n    }\n}\n\nmod test {\n    use crate::encrypted_logs::outgoing_body::EncryptedLogOutgoingBody;\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, hash::poseidon2_hash\n    };\n\n    use crate::context::PrivateContext;\n\n    #[test]\n    fn test_encrypted_log_outgoing_body() {\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        );\n        let recipient_ivsk_app = Scalar::new(\n            0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        );\n        let sender_ovsk_app = Scalar::new(\n            0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        );\n\n        let eph_pk = eph_sk.derive_public_key();\n        let recipient_ivpk_app = recipient_ivsk_app.derive_public_key();\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let body = EncryptedLogOutgoingBody::new(eph_sk, recipient, recipient_ivpk_app);\n\n        let ciphertext = body.compute_ciphertext(sender_ovsk_app, eph_pk);\n\n        let expected_outgoing_body_ciphertext = [\n            127, 84, 96, 176, 101, 107, 236, 57, 68, 8, 53, 202, 138, 74, 186, 54, 74, 193, 245, 7, 109, 59, 218, 33, 1, 31, 205, 225, 241, 209, 64, 222, 94, 245, 4, 150, 47, 241, 187, 64, 152, 20, 102, 158, 200, 217, 213, 82, 1, 240, 170, 185, 51, 80, 27, 109, 63, 231, 235, 120, 174, 44, 133, 248, 10, 97, 60, 40, 222, 190, 147, 76, 187, 48, 91, 206, 48, 106, 56, 118, 38, 127, 82, 4, 182, 188, 44, 224, 31, 129, 47, 107, 134, 252, 20, 25, 122, 191, 158, 69, 35, 255, 215, 171, 196, 45, 91, 184, 83, 80, 238, 201, 1, 233, 235, 159, 171, 130, 158, 64, 176, 165, 132, 30, 84, 81, 71, 195, 145, 47, 82, 247, 210, 192, 23, 4, 220, 90, 56, 109, 46, 105, 79, 251, 165, 141, 185, 233, 191, 118, 219, 153, 191, 162, 99, 238, 241, 249, 9, 74, 210, 241, 54, 28, 126, 226, 85, 235, 174, 75, 239, 207, 100, 184, 248, 194\n        ];\n\n        for i in 0..expected_outgoing_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_outgoing_body_ciphertext[i]);\n        }\n        assert_eq(expected_outgoing_body_ciphertext.len(), ciphertext.len());\n    }\n}\n"},"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\nstruct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext(self, secret: Scalar, point: Point) -> [u8; 48] {\n        let full_key = point_to_symmetric_key(secret, point);\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes(32).as_array();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nfn test_encrypted_log_header() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar::new(\n        0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    );\n    let point = Point::new(\n        0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        false\n    );\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    let expected_header_ciphertext = [\n        228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 23, 131, 32, 226, 26, 176, 43, 39, 239, 177, 177, 192, 85, 216, 17, 15, 18, 187, 35, 225, 135, 192, 63, 88, 29, 173, 232, 46, 72, 82, 187, 139\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext);\n}\n"},"106":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/incoming_body.nr","source":"use crate::note::note_interface::NoteInterface;\nuse crate::event::event_interface::EventInterface;\nuse dep::protocol_types::{scalar::Scalar, point::Point};\n\nuse std::aes128::aes128_encrypt;\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nstruct EncryptedLogIncomingBody<M> {\n    plaintext: [u8; M]\n}\n\nimpl<M> EncryptedLogIncomingBody<M> {\n    pub fn from_note<T, N>(note: T, storage_slot: Field) -> Self where T: NoteInterface<N, M> {\n        let mut plaintext = note.to_be_bytes(storage_slot);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn from_event<T, MR>(event: T, randomness: Field) -> Self where T: EventInterface<M, MR> {\n        let mut plaintext = event.private_to_be_bytes(randomness);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn compute_ciphertext(self, eph_sk: Scalar, ivpk_app: Point) -> [u8] {\n        let full_key = point_to_symmetric_key(eph_sk, ivpk_app);\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(self.plaintext, iv, sym_key)\n    }\n}\n\nmod test {\n    use crate::encrypted_logs::incoming_body::EncryptedLogIncomingBody;\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, traits::Serialize, abis::event_selector::EventSelector\n    };\n\n    use crate::{\n        note::{note_header::NoteHeader, note_interface::NoteInterface},\n        event::event_interface::EventInterface, oracle::unsafe_rand::unsafe_rand,\n        context::PrivateContext\n    };\n\n    struct AddressNote {\n        address: AztecAddress,\n        owner: AztecAddress,\n        randomness: Field,\n        header: NoteHeader,\n    }\n\n    global ADDRESS_NOTE_LEN: Field = 3;\n    global ADDRESS_NOTE_BYTES_LEN = 32 * 3 + 64;\n\n    impl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n        fn compute_note_content_hash(self) -> Field {1}\n\n        fn get_note_type_id() -> Field {\n            1\n        }\n\n        fn get_header(self) -> NoteHeader { self.header}\n\n        fn set_header(&mut self, header: NoteHeader) {self.header = header; }\n\n        fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n            (1, 1)\n        }\n\n        fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {(1,1)}\n\n        fn serialize_content(self) -> [Field; ADDRESS_NOTE_LEN] { [self.address.to_field(), self.owner.to_field(), self.randomness]}\n\n        fn deserialize_content(fields: [Field; ADDRESS_NOTE_LEN]) -> Self {\n            AddressNote { address: AztecAddress::from_field(fields[0]), owner: AztecAddress::from_field(fields[1]), randomness: fields[2], header: NoteHeader::empty() }\n        }\n\n        fn to_be_bytes(self, storage_slot: Field) -> [u8; ADDRESS_NOTE_BYTES_LEN] {\n            let serialized_note = self.serialize_content();\n\n            let mut buffer: [u8; ADDRESS_NOTE_BYTES_LEN] = [0; ADDRESS_NOTE_BYTES_LEN];\n\n            let storage_slot_bytes = storage_slot.to_be_bytes(32);\n            let note_type_id_bytes = AddressNote::get_note_type_id().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = storage_slot_bytes[i];\n                buffer[32 + i] = note_type_id_bytes[i];\n            }\n\n            for i in 0..serialized_note.len() {\n                let bytes = serialized_note[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n            buffer\n        }\n    }\n\n    impl AddressNote {\n        pub fn new(address: AztecAddress, owner: AztecAddress, randomness: Field) -> Self {\n            AddressNote { address, owner, randomness, header: NoteHeader::empty() }\n        }\n    }\n\n    #[test]\n    fn test_encrypted_note_log_incoming_body() {\n        let note = AddressNote::new(\n            AztecAddress::from_field(0x1),\n            AztecAddress::from_field(0x2),\n            3\n        );\n\n        let storage_slot = 2;\n\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        );\n        let ivpk_app = Point::new(\n            0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            false\n        );\n\n        let body = EncryptedLogIncomingBody::from_note(note, storage_slot);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk_app);\n\n        let expected_note_body_ciphertext = [\n            228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 63, 127, 188, 251, 150, 188, 238, 205, 3, 86, 102, 164, 175, 12, 137, 158, 163, 111, 205, 10, 229, 230, 46, 202, 110, 107, 156, 180, 67, 192, 161, 201, 48, 153, 169, 1, 25, 182, 93, 39, 39, 207, 251, 218, 234, 147, 156, 13, 110, 180, 190, 199, 41, 6, 211, 203, 176, 110, 165, 186, 110, 127, 199, 22, 201, 149, 92, 249, 219, 68, 145, 68, 179, 29, 233, 34, 98, 123, 197, 234, 169, 53, 44, 14, 81, 60, 92, 27, 250, 134, 49, 248, 57, 119, 236, 118, 158, 104, 82, 243, 98, 164, 60, 72, 74, 27, 177, 194, 221, 225, 193, 150, 67, 235, 205, 106, 150, 24, 126, 186, 220, 178, 199, 189, 113, 54, 181, 55, 46, 15, 236, 236, 9, 159, 5, 172, 237, 154, 110, 50, 241, 64, 92, 13, 37, 53, 20, 140, 42, 146, 229, 63, 97, 25, 159, 63, 235, 104, 68, 100\n        ];\n\n        assert_eq(expected_note_body_ciphertext.len(), ciphertext.len());\n\n        for i in 0..expected_note_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_note_body_ciphertext[i]);\n        }\n    }\n\n    struct TestEvent {\n        value0: Field,\n        value1: Field,\n        value2: Field,\n    }\n\n    impl Serialize<3> for TestEvent {\n        fn serialize(self) -> [Field; 3] {\n            [self.value0, self.value1, self.value2]\n        }\n    }\n\n    global TEST_EVENT_LEN: Field = 3;\n    global TEST_EVENT_BYTES_LEN = 32 * 3 + 64;\n    global TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS = 32 * 3 + 32;\n\n    impl EventInterface<TEST_EVENT_BYTES_LEN, TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS> for TestEvent {\n        fn get_event_type_id() -> EventSelector {\n            EventSelector::from_signature(\"TestEvent(Field,Field,Field)\")\n        }\n\n        fn private_to_be_bytes(self, randomness: Field) -> [u8; TEST_EVENT_BYTES_LEN] {\n            let mut buffer: [u8; TEST_EVENT_BYTES_LEN] = [0; TEST_EVENT_BYTES_LEN];\n\n            let randomness_bytes = randomness.to_be_bytes(32);\n            let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = randomness_bytes[i];\n                buffer[32 + i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes = serialized_event[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn to_be_bytes(self) -> [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] {\n             let mut buffer: [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] = [0; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS];\n\n             let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n             for i in 0..32 {\n                 buffer[i] = event_type_id_bytes[i];\n            }\n\n             let serialized_event = self.serialize();\n\n             for i in 0..serialized_event.len() {\n                 let bytes = serialized_event[i].to_be_bytes(32);\n                 for j in 0..32 {\n                     buffer[32 + i * 32 + j] = bytes[j];\n                }\n            }\n\n             buffer\n        }\n\n        fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n            _emit(self);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_event_incoming_body() {\n        let test_event = TestEvent { value0: 1, value1: 2, value2: 3 };\n\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        );\n\n        let ivpk_app = Point::new(\n            0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            false\n        );\n\n        let randomness = 2;\n\n        let body = EncryptedLogIncomingBody::from_event(test_event, randomness);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk_app);\n\n        let expected_event_body_ciphertext = [\n            228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 63, 127, 188, 251, 150, 188, 238, 205, 3, 86, 102, 164, 175, 12, 137, 158, 163, 111, 205, 10, 229, 230, 46, 202, 110, 107, 156, 180, 67, 192, 161, 201, 66, 122, 29, 35, 42, 33, 153, 216, 199, 208, 103, 207, 126, 153, 189, 136, 19, 220, 238, 15, 169, 29, 255, 11, 123, 107, 70, 192, 53, 40, 36, 93, 187, 32, 123, 136, 104, 23, 229, 245, 152, 90, 84, 2, 136, 112, 42, 27, 82, 214, 104, 14, 250, 48, 199, 245, 88, 22, 200, 77, 38, 51, 127, 56, 138, 255, 16, 46, 179, 129, 215, 185, 185, 116, 148, 16, 133, 62, 56, 180, 10, 132, 109, 77, 206, 199, 21, 167, 7, 163, 171, 158, 244, 23, 18, 121, 108, 42, 107, 7, 48, 84, 212, 104, 39, 16, 109, 7, 108, 129, 60, 80, 112, 241, 223, 140, 186, 158, 38, 74, 230, 213, 159, 175, 142, 228, 128, 160\n        ];\n\n        assert_eq(expected_event_body_ciphertext.len(), ciphertext.len());\n\n        for i in 0..expected_event_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_event_body_ciphertext[i]);\n        }\n    }\n}\n"},"110":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr","source":"use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus, PropertySelector},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\n\nmod test;\n\nfn extract_property_value_from_selector<N>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note. \n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value = serialized_note[selector.index].to_be_bytes(32);\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, N, M>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<N>(serialized_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let is_equal = value_field == select.value.to_field();\n        let is_lt = value_field.lt(select.value.to_field());\n\n        if (select.comparator == Comparator.EQ) {\n            assert(is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(is_lt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(is_lt | is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!is_lt & !is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!is_lt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N, M> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    context.push_note_hash_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, M, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> where Note: NoteInterface<N, M> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nfn constrain_get_notes_internal<Note, N, M, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> where Note: NoteInterface<N, M> {\n    let mut returned_notes = BoundedVec::new();\n\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        let opt_note = filtered_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n\n            // The below code is used to collapse a sparse array into one where the values are guaranteed to be at the \n            // front of the array. This is highly useful because the caller knows that the returned array won't have\n            // more than option.limits notes, and can therefore loop over this limit value instead of the entire array,\n            // resulting in a smaller circuit and faster proving times.\n            // We write at returned_notes[num_notes] because num_notes is only advanced when we have a value in \n            // filtered_notes.\n            returned_notes.push(note);\n        };\n    }\n\n    // As long as we only loop till `options.limit` the array will be guaranteed to be at most of length `options.limit`.\n    assert(returned_notes.len() <= options.limit, \"Got more notes than limit.\");\n    // We will however check that nothing else was returned after the limit.\n    for i in options.limit..filtered_notes.len() {\n        assert(filtered_notes[i].is_none(), \"Got more notes than limit.\");\n    }\n\n    assert(returned_notes.len() != 0, \"Cannot return zero notes\");\n\n    returned_notes\n}\n\nunconstrained fn get_note_internal<Note, N, M>(storage_slot: Field) -> Note where Note: NoteInterface<N, M> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, M, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N, M> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained pub fn view_notes<Note, N, M>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N, M>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N, M> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n"},"112":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__INNER_NOTE_HASH,\n    hash::{\n    pedersen_hash, compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_inner_note_hash_from_preimage(storage_slot: Field, note_content_hash: Field) -> Field {\n    pedersen_hash(\n        [storage_slot, note_content_hash],\n        GENERATOR_INDEX__INNER_NOTE_HASH\n    )\n}\n\nfn compute_inner_note_hash<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    compute_inner_note_hash_from_preimage(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N, M>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let (_, inner_nullifier) = note_with_header.compute_note_hash_and_nullifier(context);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\nfn compute_note_hash_for_read_request_from_innter_and_nonce(\n    inner_note_hash: Field,\n    nonce: Field\n) -> Field {\n    // TODO(#1386): This if-else can be nuked once we have nonces injected from public\n    if (nonce == 0) {\n        // If nonce is zero, that means we are reading a public note.\n        inner_note_hash\n    } else {\n        compute_unique_note_hash(nonce, inner_note_hash)\n    }\n}\n\npub fn compute_note_hash_for_read_request<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let inner_note_hash = compute_inner_note_hash(note);\n    let nonce = note.get_header().nonce;\n\n    compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, nonce)\n}\n\npub fn compute_note_hash_for_consumption<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    if (header.note_hash_counter != 0) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        inner_note_hash\n    } else {\n        // If a note is not transient, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the siloed_note_hash which has already been hashed with\n        // nonce and then contract address. This hash will match the existing leaf in the note hash\n        // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, header.nonce);\n        compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, N, M, S>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n    let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, note_header.nonce);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        let (_, nullifier) = note.compute_note_hash_and_nullifier_without_context();\n        nullifier\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [inner_note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"113":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_inner_note_hash, compute_note_hash_for_consumption}, note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let inner_note_hash = compute_inner_note_hash(*note);\n\n    let serialized_note = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash,\n        note_hash_counter\n    )\n        == 0\n    );\n\n    context.push_note_hash(inner_note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, N, M>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let inner_note_hash = compute_inner_note_hash(*note);\n\n    context.push_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let (note_hash, nullifier) = note.compute_note_hash_and_nullifier(context);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let note_hash_for_consumption = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a non-transient note and we don't populate the note_hash with real\n        // value (if we did so the `notifyNullifiedNote` oracle would throw).\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a transient note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can find it and squash both\n        // the note and the nullifier.\n        note_hash\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    assert(notify_nullified_note(nullifier, note_hash_for_consumption, nullifier_counter) == 0);\n\n    context.push_nullifier(nullifier, note_hash_for_consumption)\n}\n"},"114":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\nstruct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting  \n * a change note in a token's transfer function only when there is \"change\" left).\n */\nstruct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(self) {}\n}\n"},"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"124":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::{address::AztecAddress, point::Point};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<M>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<M>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<M>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32\n) {}\n\nunconstrained pub fn emit_encrypted_event_log<M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<N, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<N, M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\n}\n"},"128":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n"},"132":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<N>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field\n) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number as Field, N)\n}\n\nunconstrained pub fn storage_read<T, N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"133":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/unsafe_rand.nr","source":"#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n\n// Called `unsafe_rand` because we do not constrain in circuit that we are dealing with an actual random value.\n// Instead we just trust our PXE.\nunconstrained pub fn unsafe_rand() -> Field {\n    rand_oracle()\n}\n"},"136":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use crate::keys::PublicKeys;\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained fn get_public_keys_and_partial_address_oracle_wrapper(address: AztecAddress) -> [Field; 13] {\n    get_public_keys_and_partial_address_oracle(address)\n}\n\nfn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle_wrapper(address);\n\n    let keys = PublicKeys {\n        npk_m: Point::new(result[0], result[1], result[2] as bool),\n        ivpk_m: Point::new(result[3], result[4], result[5] as bool),\n        ovpk_m: Point::new(result[6], result[7], result[8] as bool),\n        tpk_m: Point::new(result[9], result[10], result[11] as bool)\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"138":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        inner_note_hash,\n        counter\n    )\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field, _counter: u32) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(\n    nullifier: Field,\n    inner_note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash, counter)\n}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, NB, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N, NB> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n// Only ever use this in private!\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n// Only ever use this in private!\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n"},"144":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{hash::pedersen_hash, storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"146":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UnconstrainedContext> {\n    unconstrained pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"153":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr","source":"use dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE, lifecycle::{create_note, create_note_hash_from_public, destroy_note},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader, note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note> PrivateSet<Note, &mut PublicContext> {\n    // docs:start:insert_from_public\n    pub fn insert_from_public<N, M>(self, note: &mut Note) where Note: NoteInterface<N, M> {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note> PrivateSet<Note, &mut PrivateContext> {\n    // docs:start:insert\n    pub fn insert<N, M>(self, note: &mut Note) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    // docs:start:remove\n    pub fn remove<N, M>(self, note: Note) where Note: NoteInterface<N, M> {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read = self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note(self.context, note);\n    }\n    // docs:end:remove\n\n    // docs:start:get_notes\n    pub fn get_notes<N, M, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> where Note: NoteInterface<N, M> {\n        get_notes(self.context, self.storage_slot, options)\n    }\n    // docs:end:get_notes\n}\n\nimpl<Note> PrivateSet<Note, UnconstrainedContext> {\n    // docs:start:view_notes\n    unconstrained pub fn view_notes<N, M>(\n        self,\n        options: NoteViewerOptions<Note, N, M>\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N, M> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"},"155":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_delay_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initally equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation \n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the \n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a \n// reduced delay, invalidating prior private reads.\nstruct ScheduledDelayChange<INITIAL_DELAY> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option, \n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pre: Option<u32>,\n    post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numeric value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\nimpl<INITIAL_DELAY> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior contraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This \n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is \n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in \n            //                             which to scheduled value change\n\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY)\n            )\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Serialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn serialize(self) -> [Field; 1] {\n        // We pack all three u32 values into a single U128, which is made up of two u64 limbs.\n        // Low limb: [ pre_inner: u32 | post_inner: u32 ]\n        // High limb: [ empty | pre_is_some: u8 |  post_is_some: u8 | block_of_change: u32 ]\n\n        let lo = ((self.pre.unwrap_unchecked() as u64) * (1 << 32))\n            + (self.post.unwrap_unchecked() as u64);\n\n        let hi = (self.pre.is_some() as u64) * (1 << 33) \n            + (self.post.is_some() as u64 * (1 << 32)) \n            + self.block_of_change as u64;\n\n        let packed = U128::from_u64s_le(lo, hi);\n\n        [packed.to_integer()]\n    }\n}\n\nimpl<INITIAL_DELAY> Deserialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn deserialize(input: [Field; 1]) -> Self {\n        let packed = U128::from_integer(input[0]);\n\n        // We use division and modulo to clear the bits that correspond to other values when unpacking.\n\n        let pre_is_some = ((packed.hi as u64) / (1 << 33)) as bool;\n        let pre_inner = ((packed.lo as u64) / (1 << 32)) as u32;\n\n        let post_is_some = (((packed.hi as u64) / (1 << 32)) % (1 << 1)) as bool;\n        let post_inner = ((packed.lo as u64) % (1 << 32)) as u32;\n\n        let block_of_change = ((packed.hi as u64) % (1 << 32)) as u32;\n\n        Self {\n            pre: if pre_is_some { Option::some(pre_inner) } else { Option::none() },\n            post: if post_is_some { Option::some(post_inner) } else { Option::none() },\n            block_of_change,\n            _dummy: [0; INITIAL_DELAY],\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"157":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable_private_getter.nr","source":"use dep::protocol_types::{\n    hash::{pedersen_hash, poseidon2_hash}, traits::{FromField, ToField}, address::AztecAddress,\n    header::Header\n};\n\nuse crate::context::PrivateContext;\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{\n    shared_mutable::SharedMutable, scheduled_delay_change::ScheduledDelayChange,\n    scheduled_value_change::ScheduledValueChange\n}\n};\n\nstruct SharedMutablePrivateGetter<T, INITIAL_DELAY> {\n    context: &mut PrivateContext,\n    // The contract address of the contract we want to read from\n    other_contract_address: AztecAddress,\n    // The storage slot where the SharedMutable is stored on the other contract\n    storage_slot: Field,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numberic value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\n// We have this as a view-only interface to reading Shared Mutables in other contracts.\n// Currently the Shared Mutable does not support this. We can adapt SharedMutable at a later date\nimpl<T, INITIAL_DELAY> SharedMutablePrivateGetter<T, INITIAL_DELAY> {\n    pub fn new(\n        context: &mut PrivateContext,\n        other_contract_address: AztecAddress,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        assert(other_contract_address.to_field() != 0, \"Other contract address cannot be 0\");\n        Self { context, other_contract_address, storage_slot, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    pub fn get_value_in_private(self, header: Header) -> T where T: FromField + ToField + Eq {\n        // We create a dummy SharedMutable state variable so that we can reuse its historical_read_from_public_storage\n        // method, greatly reducing code duplication. \n        let dummy: SharedMutable<T, INITIAL_DELAY, ()> = SharedMutable::new((), self.storage_slot);\n        let (value_change, delay_change, historical_block_number) = dummy.historical_read_from_public_storage(header, self.other_contract_address);\n\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // If our context has the same header as the one we pass in via the parameter, we are trying to read the \"current\" value\n        // and thus need to set the tx max block number below. If the context header is not the same as the one we pass in, this means\n        // we are trying to read a historical value and thus have no constraint on the max block number that this transaction can be included in.\n        if (self.context.historical_header.global_variables.block_number.eq(header.global_variables.block_number)) {\n            self.context.set_tx_max_block_number(block_horizon);\n        }\n\n        value_change.get_current_at(historical_block_number)\n    }\n}\n"},"159":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_value_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\nstruct ScheduledValueChange<T> {\n    pre: T,\n    post: T,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Serialize<3> for ScheduledValueChange<T> {\n    fn serialize(self) -> [Field; 3] where T: ToField {\n        [self.pre.to_field(), self.post.to_field(), self.block_of_change.to_field()]\n    }\n}\n\nimpl<T> Deserialize<3> for ScheduledValueChange<T> {\n  fn deserialize(input: [Field; 3]) -> Self  where T: FromField {\n    Self {\n        pre: FromField::from_field(input[0]),\n        post: FromField::from_field(input[1]),\n        block_of_change: FromField::from_field(input[2]),\n    }\n  }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>  {\n    fn eq(self, other: Self) -> bool where T: Eq {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"160":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable.nr","source":"use dep::protocol_types::{\n    hash::{pedersen_hash, poseidon2_hash}, header::Header, address::AztecAddress,\n    traits::{FromField, ToField}\n};\n\nuse crate::context::{PrivateContext, PublicContext};\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{scheduled_value_change::ScheduledValueChange, scheduled_delay_change::ScheduledDelayChange}\n};\nuse crate::oracle::storage::storage_read;\nuse dep::std::unsafe::zeroed;\n\nmod test;\n\nstruct SharedMutable<T, INITIAL_DELAY, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Serialize<N> trait, and allocate N storage slots to\n// this state variable. This is incorrect, since what we actually store is:\n//  - a ScheduledValueChange<T>, which requires 1 + 2 * M storage slots, where M is the serialization length of T\n//  - a ScheduledDelayChange, which requires another storage slot\n//\n// TODO https://github.com/AztecProtocol/aztec-packages/issues/5736: change the storage allocation scheme so that we\n// can actually use it here\nimpl<T, INITIAL_DELAY, Context> Storage<T> for SharedMutable<T, INITIAL_DELAY, Context> {}\n\n// TODO: extract into a utils module once  we can do arithmetic on generics, i.e. https://github.com/noir-lang/noir/issues/4784\nfn concat_arrays<N, M, O>(arr_n: [Field; N], arr_m: [Field; M]) -> [Field; O] {\n    assert_eq(N + M, O);\n    let mut out: [Field; O] = [0; O];\n    for i in 0..N {\n        out[i] = arr_n[i];\n    }\n    for i in 0..M {\n        out[N+i] = arr_m[i];\n    }\n    out\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, INITIAL_DELAY, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    fn hash_scheduled_data(\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) -> Field where T: ToField {\n        // TODO(#5491 and https://github.com/noir-lang/noir/issues/4784): update this so that we don't need to rely on\n        // ScheduledValueChange serializing to 3 and ScheduledDelayChange serializing to 1\n        let concatenated: [Field; 4] = concat_arrays(value_change.serialize(), delay_change.serialize());\n        poseidon2_hash(concatenated)\n    }\n\n    // Since we can't rely on the native storage allocation scheme, we hash the storage slot to get a unique location in\n    // which we can safely store as much data as we need.\n    // See https://github.com/AztecProtocol/aztec-packages/issues/5492 and\n    // https://github.com/AztecProtocol/aztec-packages/issues/5736\n    // We store three things in public storage:\n    //  - a ScheduledValueChange\n    //  - a ScheduledDelaChange\n    //  - the hash of both of these (via `hash_scheduled_data`)\n    fn get_value_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 0], 0)\n    }\n\n    fn get_delay_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 1], 0)\n    }\n\n    fn get_hash_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 2], 0)\n    }\n\n    // It may seem odd that we take a header and address instead of reading from e.g. a PrivateContext, but this lets us\n    // reuse this function in SharedMutablePrivateGetter.\n    fn historical_read_from_public_storage(\n        self,\n        header: Header,\n        address: AztecAddress\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) where T: FromField + ToField + Eq {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for both the ScheduledValueChange and\n        // ScheduledDelayChange, but that'd require one full sibling path per storage slot (since due to kernel siloing\n        // the storage is not contiguous), and in the best case in which T is a single field that'd be 4 slots.\n        // Instead, we get an oracle to provide us the correct values for both the value and delay changes, and instead\n        // prove inclusion of their hash, which is both a much smaller proof (a single slot), and also independent of\n        // the size of T.\n        let (value_change_hint, delay_change_hint) = get_public_storage_hints(address, self.storage_slot, historical_block_number);\n\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let hash = header.public_storage_historical_read(self.get_hash_storage_slot(), address);\n\n        // @todo This is written strangely to bypass a formatting issue with the if that is breaking ci.\n        let (a, b, c) = if hash != 0 {\n            let a = SharedMutable::hash_scheduled_data(value_change_hint, delay_change_hint);\n            (a, value_change_hint, delay_change_hint)\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized, meaning no value or delay change was ever\n            // scheduled. Therefore, the hints must then correspond to uninitialized scheduled changes.\n            let b = ScheduledValueChange::deserialize(zeroed());\n            let c = ScheduledDelayChange::deserialize(zeroed());\n            (hash, b, c)\n        };\n\n        assert_eq(hash, a, \"Hint values do not match hash\");\n        assert_eq(value_change_hint, b, \"Non-zero value change for zero hash\");\n        assert_eq(delay_change_hint, c, \"Non-zero delay change for zero hash\");\n\n        (value_change_hint, delay_change_hint, historical_block_number)\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PublicContext> {\n    pub fn schedule_value_change(self, new_value: T) where T: ToField {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) where T: ToField {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value_in_public(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay_in_public(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value_in_public(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay_in_public(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        self.context.storage_read(self.get_delay_change_storage_slot())\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) where T: ToField {\n        // Whenever we write to public storage, we write both the value change and delay change as well as the hash of\n        // them both. This guarantees that the hash is always kept up to date.\n        // While this makes for more costly writes, it also makes private proofs much simpler because they only need to\n        // produce a historical proof for the hash, which results in a single inclusion proof (as opposed to 4 in the\n        // best case scenario in which T is a single field). Private shared mutable reads are assumed to be much more\n        // frequent than public writes, so this tradeoff makes sense.\n        self.context.storage_write(self.get_value_change_storage_slot(), value_change);\n        self.context.storage_write(self.get_delay_change_storage_slot(), delay_change);\n        self.context.storage_write(\n            self.get_hash_storage_slot(),\n            SharedMutable::hash_scheduled_data(value_change, delay_change)\n        );\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext> {\n    pub fn get_current_value_in_private(self) -> T where T: FromField + ToField + Eq {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n\n        let (value_change, delay_change, historical_block_number) = self.historical_read_from_public_storage(self.context.get_header(), self.context.this_address());\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n}\n\nunconstrained fn get_public_storage_hints<T, INITIAL_DELAY>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>) {\n    // This function cannot be part of the &mut PrivateContext impl because that'd mean that by passing `self` we'd also\n    // be passing a mutable reference to an unconstrained function, which is not allowed. We therefore create a dummy\n    // state variable here so that we can access the methods to compute storage slots. This will all be removed in the\n    // future once we do proper storage slot allocation (#5492).\n    let dummy = SharedMutable::new((), storage_slot);\n\n    (\n        storage_read(address, dummy.get_value_change_storage_slot(), block_number), storage_read(address, dummy.get_delay_change_storage_slot(), block_number)\n    )\n}\n"},"180":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point::new(fields[0], fields[1], fields[2] as bool),\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"193":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"21":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    fn new(x: Field, y: Field, is_infinite: bool) -> Self {\n        Self { x, y, is_infinite }\n    }\n\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n// Scalar represented as low and high limbs\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    pub fn derive_public_key(self) -> EmbeddedCurvePoint {\n        let public_key = fixed_base_scalar_mul(self.lo, self.hi);\n        EmbeddedCurvePoint { x: public_key[0], y: public_key[1], is_infinite: false }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, key: EmbeddedCurveScalar) -> bool {\n        (key.hi == self.hi) & (key.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n#[foreign(multi_scalar_mul)]\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> [Field; 3]\n// docs:end:multi_scalar_mul\n{}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(\n    scalar_low: Field,\n    scalar_high: Field\n) -> [Field; 3]\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    let scalar = EmbeddedCurveScalar { lo: scalar_low, hi: scalar_high };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n"},"217":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"22":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"229":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"235":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<N> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<N> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<N> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<N> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"238":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"246":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: Field = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point {\n            x: 0,\n            y: 0,\n            is_infinite: false\n        }\n    }\n}\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn pub_key_to_bytes(pk: Point) -> [u8; 64] {\n    assert(!pk.is_infinite, \"Point at infinity is not a valid public key.\");\n    let mut result = [0 as u8; 64];\n    let x_bytes = pk.x.to_be_bytes(32);\n    let y_bytes = pk.y.to_be_bytes(32);\n    for i in 0..32 {\n        result[i] = x_bytes[i];\n        result[i + 32] = y_bytes[i];\n    }\n    result\n}\n"},"25":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n#[no_predicates]\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    let value = pedersen_commitment_with_separator(input, 0);\n    if (value.x == 0) & (value.y == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value.x, y: value.y, is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        points[i] = EmbeddedCurveScalar::from_field(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let values = multi_scalar_mul(generators, points);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: values[2] as bool }\n}\n\n#[no_predicates]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let v1 = pedersen_commitment_with_separator(input, separator);\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    multi_scalar_mul(\n        [length_generator[0], v1],\n        [EmbeddedCurveScalar { lo: N as Field, hi: 0 }, EmbeddedCurveScalar { lo: 1, hi: 0 }]\n    )[0]\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n#[test]\nfn assert_pedersen_noir() {\n    // TODO: make this a fuzzer test once fuzzer supports curve-specific blackbox functions.\n    let input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq(pedersen_hash_with_separator(input, 4), pedersen_hash_with_separator_noir(input, 4));\n    assert_eq(pedersen_commitment_with_separator(input, 4), pedersen_commitment_with_separator_noir(input, 4));\n}\n"},"273":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"32":{"path":"std/merkle.nr","source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n"},"328":{"path":"/usr/src/noir-projects/noir-contracts/contracts/benchmarking_contract/src/main.nr","source":"// A contract used for running benchmarks.\n// We should try to change this contract as little as possible, since any modification\n// would alter the metrics we're capturing in the benchmarks, and we want to keep the\n// subject being tested as unmodified as possible so we can detect metric changes that\n\ncontract Benchmarking {\n    use dep::aztec::prelude::{AztecAddress, FunctionSelector, NoteHeader, NoteGetterOptions, Map, PublicMutable, PrivateSet};\n    use dep::value_note::{utils::{increment, decrement}, value_note::ValueNote};\n\n    use dep::aztec::context::gas::GasOpts;\n\n    #[aztec(storage)]\n    struct Storage {\n        notes: Map<AztecAddress, PrivateSet<ValueNote>>,\n        balances: Map<AztecAddress, PublicMutable<Field>>,\n    }\n\n    // Creates a new value note for the target owner. Use this method to seed an initial set of notes.\n    #[aztec(private)]\n    fn create_note(owner: AztecAddress, outgoing_viewer: AztecAddress, value: Field) {\n        increment(storage.notes.at(owner), value, owner, outgoing_viewer);\n    }\n\n    // Deletes a note at a specific index in the set and creates a new one with the same value.\n    // We explicitly pass in the note index so we can ensure we consume different notes when sending\n    // multiple txs that will land on the same block.\n    // See https://discourse.aztec.network/t/utxo-concurrency-issues-for-private-state/635\n    // by @rahul-kothari for a full explanation on why this is needed.\n    #[aztec(private)]\n    fn recreate_note(owner: AztecAddress, outgoing_viewer: AztecAddress, index: u32) {\n        let owner_notes = storage.notes.at(owner);\n        let mut getter_options = NoteGetterOptions::new();\n        let notes = owner_notes.get_notes(getter_options.set_limit(1).set_offset(index));\n        let note = notes.get_unchecked(0);\n        owner_notes.remove(note);\n        increment(owner_notes, note.value, owner, outgoing_viewer);\n    }\n\n    // Reads and writes to public storage and enqueues a call to another public function.\n    #[aztec(public)]\n    fn increment_balance(owner: AztecAddress, value: Field) {\n        let current = storage.balances.at(owner).read();\n        storage.balances.at(owner).write(current + value);\n        Benchmarking::at(context.this_address()).broadcast(owner).call(&mut context);\n    }\n\n    // Emits a public log.\n    #[aztec(public)]\n    fn broadcast(owner: AztecAddress) {\n        context.emit_unencrypted_log(storage.balances.at(owner).read());\n    }\n}\n"},"329":{"path":"/usr/src/noir-projects/aztec-nr/value-note/src/utils.nr","source":"use dep::aztec::prelude::{AztecAddress, PrivateContext, PrivateSet, NoteGetterOptions};\nuse dep::aztec::note::note_getter_options::SortOrder;\nuse dep::aztec::encrypted_logs::encrypted_note_emission::encode_and_encrypt_note;\nuse crate::{filter::filter_notes_min_sum, value_note::{ValueNote, VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN}};\n\n// Sort the note values (0th field) in descending order.\n// Pick the fewest notes whose sum is equal to or greater than `amount`.\npub fn create_note_getter_options_for_decreasing_balance(amount: Field) -> NoteGetterOptions<ValueNote, VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN, Field> {\n    NoteGetterOptions::with_filter(filter_notes_min_sum, amount).sort(ValueNote::properties().value, SortOrder.DESC)\n}\n\n// Creates a new note for the recipient.\n// Inserts it to the recipient's set of notes.\npub fn increment(\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    amount: Field,\n    recipient: AztecAddress,\n    outgoing_viewer: AztecAddress\n) {\n    let header = balance.context.get_header();\n    let recipient_npk_m_hash = header.get_npk_m_hash(balance.context, recipient);\n\n    let mut note = ValueNote::new(amount, recipient_npk_m_hash);\n    // Insert the new note to the owner's set of notes and emit the log if value is non-zero.\n    balance.insert(&mut note).emit(encode_and_encrypt_note(balance.context, outgoing_viewer, recipient));\n}\n\n// Find some of the `owner`'s notes whose values add up to the `amount`.\n// Remove those notes.\n// If the value of the removed notes exceeds the requested `amount`, create a new note containing the excess value, so that exactly `amount` is removed.\n// Fail if the sum of the selected notes is less than the amount.\npub fn decrement(\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    amount: Field,\n    owner: AztecAddress,\n    outgoing_viewer: AztecAddress\n) {\n    let sum = decrement_by_at_most(balance, amount, owner, outgoing_viewer);\n    assert(sum == amount, \"Balance too low\");\n}\n\n// Similar to `decrement`, except that it doesn't fail if the decremented amount is less than max_amount.\n// The motivation behind this function is that there is an upper-bound on the number of notes a function may\n// read and nullify. The requested decrementation `amount` might be spread across too many of the `owner`'s\n// notes to 'fit' within this upper-bound, so we might have to remove an amount less than `amount`. A common\n// pattern is to repeatedly call this function across many function calls, until enough notes have been nullified to\n// equal `amount`.\n//\n// It returns the decremented amount, which should be less than or equal to max_amount.\npub fn decrement_by_at_most(\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    max_amount: Field,\n    owner: AztecAddress,\n    outgoing_viewer: AztecAddress\n) -> Field {\n    let options = create_note_getter_options_for_decreasing_balance(max_amount);\n    let notes = balance.get_notes(options);\n\n    let mut decremented = 0;\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n\n            decremented += destroy_note(balance, note);\n        }\n    }\n\n    // Add the change value back to the owner's balance.\n    let mut change_value = 0;\n    if max_amount.lt(decremented) {\n        change_value = decremented - max_amount;\n        decremented -= change_value;\n    }\n    increment(balance, change_value, owner, outgoing_viewer);\n\n    decremented\n}\n\n// Removes the note from the owner's set of notes.\n// Returns the value of the destroyed note.\npub fn destroy_note(balance: PrivateSet<ValueNote, &mut PrivateContext>, note: ValueNote) -> Field {\n    balance.remove(note);\n\n    note.value\n}\n"},"330":{"path":"/usr/src/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Deserialize, Serialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n"},"38":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"4":{"path":"std/cmp.nr","source":"// docs:start:eq-trait\ntrait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\nimpl Eq for Field { fn eq(self, other: Field) -> bool { self == other } }\n\nimpl Eq for u64 { fn eq(self, other: u64) -> bool { self == other } }\nimpl Eq for u32 { fn eq(self, other: u32) -> bool { self == other } }\nimpl Eq for u8 { fn eq(self, other: u8) -> bool { self == other } }\nimpl Eq for u1 { fn eq(self, other: u1) -> bool { self == other } }\n\nimpl Eq for i8 { fn eq(self, other: i8) -> bool { self == other } }\nimpl Eq for i32 { fn eq(self, other: i32) -> bool { self == other } }\nimpl Eq for i64 { fn eq(self, other: i64) -> bool { self == other } }\n\nimpl Eq for () { fn eq(_self: Self, _other: ()) -> bool { true } }\nimpl Eq for bool { fn eq(self, other: bool) -> bool { self == other } }\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3) & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\nstruct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n// docs:start:ord-trait\ntrait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"44":{"path":"std/slice.nr","source":"use crate::append::Append;\n\nimpl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::unsafe::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"},"47":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"5":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\nstruct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len);\n        self.get_unchecked(index)\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Responds with undefined data for `index` where `self.len < index < self.max_len()`.\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Does not check whether the passed `index` is a valid index within the vector.\n    ///\n    /// Silently writes past the end of the vector for `index` where `self.len < index < self.max_len()`\n    /// Panics if the given index points beyond the maximum length of the vector (`self.max_len()`).\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        \n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen>  {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n    // TODO: Allow imports from \"super\"\n    use crate::collections::bounded_vec::BoundedVec;\n\n    #[test]\n    fn empty_equality() {\n        let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n        let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n        assert_eq(bounded_vec1, bounded_vec2);\n    }\n\n    #[test]\n    fn inequality() {\n        let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n        let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n        bounded_vec1.push(1);\n        bounded_vec2.push(2);\n\n        assert(bounded_vec1 != bounded_vec2);\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n}\n"},"64":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::{Point, pub_key_to_bytes},\n    utils::arr_copy_slice\n};\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret_fields = multi_scalar_mul([point], [secret]);\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/6061): make the func return Point struct directly\n    let shared_secret = pub_key_to_bytes(Point::new(shared_secret_fields[0], shared_secret_fields[1], false));\n    let mut shared_secret_bytes_with_separator = [0 as u8; 65];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[64] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nfn check_point_to_symmetric_key() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar::new(\n        0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    );\n    let point = Point::new(\n        0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        false\n    );\n\n    let key = point_to_symmetric_key(secret, point);\n    // The following value gets updated when running encrypt_buffer.test.ts with AZTEC_GENERATE_TEST_DATA=1\n    let expected_key = [\n        49, 167, 146, 222, 151, 129, 138, 184, 87, 210, 245, 249, 99, 100, 1, 59, 223, 180, 5, 99, 14, 7, 177, 236, 159, 203, 231, 72, 220, 180, 241, 23\n    ];\n    assert_eq(key, expected_key);\n}\n"},"65":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::PrivateContext,\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}},\n    state_vars::{shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter}\n};\n\nglobal DELAY = 5;\n\n// docs:start:key-getters\ntrait KeyGetters {\n  fn get_npk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ivpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ovpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_tpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_npk_m_hash(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Field;\n}\n\nimpl KeyGetters for Header {\n    fn get_npk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, NULLIFIER_INDEX, self)\n    }\n\n    fn get_ivpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, INCOMING_INDEX, self)\n    }\n\n    fn get_ovpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, OUTGOING_INDEX, self)\n    }\n\n    fn get_tpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, TAGGING_INDEX, self)\n    }\n\n    fn get_npk_m_hash(self, context: &mut PrivateContext, address: AztecAddress) -> Field {\n        get_master_key(context, address, NULLIFIER_INDEX, self).hash()\n    }\n}\n// docs:end:key-getters\n\nfn get_master_key(\n    context: &mut PrivateContext,\n    address: AztecAddress,\n    key_index: Field,\n    header: Header\n) -> Point {\n    let key = fetch_key_from_registry(context, key_index, address, header);\n    if is_empty(key) {\n        // Keys were not registered in registry yet --> fetch key from PXE\n        let keys = fetch_and_constrain_keys(address);\n        // Return the corresponding to index\n        keys.get_key_by_index(key_index)\n    } else {\n        // Keys were registered --> return the key\n        key\n    }\n}\n\nfn fetch_key_from_registry(\n    context: &mut PrivateContext,\n    key_index: Field,\n    address: AztecAddress,\n    header: Header\n) -> Point {\n    let x_coordinate_map_slot = key_index * 2 + 1;\n    let y_coordinate_map_slot = x_coordinate_map_slot + 1;\n    let x_coordinate_derived_slot = derive_storage_slot_in_map(x_coordinate_map_slot, address);\n    let y_coordinate_derived_slot = derive_storage_slot_in_map(y_coordinate_map_slot, address);\n\n    let x_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        x_coordinate_derived_slot\n    );\n    let y_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        y_coordinate_derived_slot\n    );\n    let x_coordinate = x_coordinate_registry.get_value_in_private(header);\n    let y_coordinate = y_coordinate_registry.get_value_in_private(header);\n\n    Point::new(x_coordinate, y_coordinate, false)\n}\n\n// Passes only when keys were not rotated - is expected to be called only when keys were not registered yet\nfn fetch_and_constrain_keys(address: AztecAddress) -> PublicKeys {\n    let (public_keys, partial_address) = get_public_keys_and_partial_address(address);\n\n    let computed_address = AztecAddress::compute(public_keys.hash(), partial_address);\n\n    assert(computed_address.eq(address));\n\n    public_keys\n}\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n"},"66":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr","source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH, hash::poseidon2_hash,\n    point::Point, traits::{Deserialize, Serialize, Empty, is_empty}\n};\nuse crate::keys::constants::{NUM_KEY_TYPES, NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX};\n\nglobal PUBLIC_KEYS_LENGTH = 12;\n\nstruct PublicKeys {\n    npk_m: Point,\n    ivpk_m: Point,\n    ovpk_m: Point,\n    tpk_m: Point,\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m : Point::empty(),\n            ivpk_m : Point::empty(),\n            ovpk_m : Point::empty(),\n            tpk_m : Point::empty()\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        ( self.npk_m == other.npk_m ) &\n        ( self.ivpk_m == other.ivpk_m ) &\n        ( self.ovpk_m == other.ovpk_m ) &\n        ( self.tpk_m == other.tpk_m )\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash(\n                [\n                self.npk_m.x,\n                self.npk_m.y,\n                self.npk_m.is_infinite as Field,\n                self.ivpk_m.x,\n                self.ivpk_m.y,\n                self.ivpk_m.is_infinite as Field,\n                self.ovpk_m.x,\n                self.ovpk_m.y,\n                self.ovpk_m.is_infinite as Field,\n                self.tpk_m.x,\n                self.tpk_m.y,\n                self.tpk_m.is_infinite as Field,\n                GENERATOR_INDEX__PUBLIC_KEYS_HASH\n            ]\n            )\n        }\n        )\n    }\n\n    pub fn get_key_by_index(self, index: Field) -> Point {\n        assert(index as u8 < NUM_KEY_TYPES, \"Invalid key index\");\n        if index == NULLIFIER_INDEX {\n            self.npk_m\n        } else if index == INCOMING_INDEX {\n            self.ivpk_m\n        } else if index == OUTGOING_INDEX {\n            self.ovpk_m\n        } else {\n            self.tpk_m\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.x,\n            self.npk_m.y,\n            self.npk_m.is_infinite as Field,\n            self.ivpk_m.x,\n            self.ivpk_m.y,\n            self.ivpk_m.is_infinite as Field,\n            self.ovpk_m.x,\n            self.ovpk_m.y,\n            self.ovpk_m.is_infinite as Field,\n            self.tpk_m.x,\n            self.tpk_m.y,\n            self.tpk_m.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: Point::new(serialized[0], serialized[1], serialized[2] as bool),\n            ivpk_m: Point::new(serialized[3], serialized[4], serialized[5] as bool),\n            ovpk_m: Point::new(serialized[6], serialized[7], serialized[8] as bool),\n            tpk_m: Point::new(serialized[9], serialized[10], serialized[11] as bool)\n        }\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: Point { x: 1, y: 2, is_infinite: false },\n        ivpk_m: Point { x: 3, y: 4, is_infinite: false },\n        ovpk_m: Point { x: 5, y: 6, is_infinite: false },\n        tpk_m: Point { x: 7, y: 8, is_infinite: false }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x146f68c0e0ba4067d61a3304bbfdec0797d5df1357db6c01247c48bfb345c7d7;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nfn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nfn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: Point { x: 1, y: 2, is_infinite: false },\n        ivpk_m: Point { x: 3, y: 4, is_infinite: false },\n        ovpk_m: Point { x: 5, y: 6, is_infinite: false },\n        tpk_m: Point { x: 7, y: 8, is_infinite: false }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.x, deserialized.npk_m.x);\n    assert_eq(keys.npk_m.y, deserialized.npk_m.y);\n    assert_eq(keys.ivpk_m.x, deserialized.ivpk_m.x);\n    assert_eq(keys.ivpk_m.y, deserialized.ivpk_m.y);\n    assert_eq(keys.ovpk_m.x, deserialized.ovpk_m.x);\n    assert_eq(keys.ovpk_m.y, deserialized.ovpk_m.y);\n    assert_eq(keys.tpk_m.x, deserialized.tpk_m.x);\n    assert_eq(keys.tpk_m.y, deserialized.tpk_m.y);\n}\n"},"80":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<N, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<N, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"95":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn block_number(self) -> Field {\n        block_number()\n    }\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<N>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<N>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, N>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N)\n}\n\nunconstrained fn storage_write<N>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<N>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<N>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}