{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"ImportTest","functions":[{"name":"pub_call_public_fn","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/82Zu48cRRDGe+Zudnd2eh+397DvvXu3c6/1YZvDlkAYAoywCCwnlhDIAWAeFiAhcABEOCMgABGRkZAiIgR/AAkxOXLmkIScqeqq/np29uZsIk7a297q79fdU93TVdMzNnPGtIqPMZtG/shiuqZRfEX0ecFoqSjExSfqmkhNOVUSFeciM3NcIuH8TvGvfcVoF2Nqm1jTzLW3BnfIf036l8fSSwPqhlfHUDe8miwx1HEeXMkcQO3fjVa7mXPGudpBAWx5TROaVvniUm686QdOI22jOnNg2xVNm9UtLqk6c2qqsE6duaLJWJ1CE3nQoG0j7cObGS7TenUbauvVTd8gtWDRS0dwVyya0XFbr+5g3F2n7rii6fhxd3Kdj2RY/Hs28G3CxUSaTUeku04lEl7LxXnFHETqP99zMP/iMXFeMdW6bpvT6rhOnQT+NX5gRCf+yue4lJVmulXhWsK1vH9b0+sixtpuy0+3LpKyBks0mblE50uroTm1GoI1CK8XrUeyiOd0+v0d0pq6taaG+L9FvKeT3JS9eKo6g8aUbgFefffh32aDi6nOJS3T6CMqkfAzXkCJnysqpZUlkWrbrE7LyyadNcmpm8DEVP9S3qxZkfrbLFi+2awbPpvdHutde5nfbqZc4+53vlvoir+Ga7KGX6mZ3sHRDfXhN941cRcr2nXm5irS3ZxLDQ0m7vIew4nNaXX8uC7HnZr6Habh56Jxxk4o206wg1v0f6o6q+xZ1V2+8Vj9x7pbe/VZO3FW1rRnhb7aPSO5dPfmJw8v/3D4662Xf3nw4LU71KCby45rOzk4eXTj898+/valh/9897csHaew7nqSYNHpX9cpaKTd2DfHA5/6afxPW+ZkMhtyCV3vzC4upostoIs18kQI3NGbdYP1yt7rPr0sHcyb8oam4uKOjTg3Shjo6f7i2lgkclZmM1/uJ8aw5osGb2IX0Zu07wNLH1g/qBf0HZi1aoFREiwAXQjqBf0UZq0aMEqCAdBBUC/ofZi1apFREiwCXQzq3XcV6dcjRW93YdaqJUZJsAR0KagXdAizVi0zSoJloMtBvaBvw6xVK4ySYAXoSlAv6Jswa9U5RklwDui5oF7QD2HWqvOMkuA80PNBfdWz/xlZqkeKAb4Ls1atMkqCVaCrQX21t1Xvjhqk6O0ezFq1xigJ1oCuBfXV3ta8O54Q6T85sliPFNc0glmr1hklwTrQ9aCevjlOv4LNZolBgx1Gt5R1fkzQbadocT7Yuje4q41yV5sOXndFraFL2YRoG5vW0KUQQ9GPZFPciVhID5Q02BGP+Lr7pZdLzE6usi107CpiZ6RKVW/Td1GInguGNTXgq5He+LuzUqq0klKpZ23kozRH3GbpQaPDV3CLSld9/AvCReQTAg52Du6KqcfwbSoBziXZkAwnSDxpNL2GzwIosvS5hTeodDUIvxqXOhwnJDCECWEHz14Ix5nTaRLaLyWOCYhKusk9913rRPVj31G/lM22TZjOmBS+5EdhvpgPqBS4Q2ZHklTvk5ZPy+NKRql5VPDMOPaL5fTn5pk5UpHfRC8iWWtrnuKnqZpaWLk8QlfKGYflNEOvvwe0B7Qn6FswK+pifm9mzLfibUItzIrWxXzriozuwKxoXcy3rsjoEGZF62K+lTuV0D9hVrQugFvZ3OwspF+PFL19CbOidTHfuiKjX8CsaF3MtxLDCP0JZkXrYr6VgEToXzArWhfArSsyugCzonXR2Loio9/DrGhdaLUSoAhtw6xoXQSzslNbSTrXy6iLSCTYALoBdEPQMcyKbvpgtlkJZlZiA6GvwqzoFqMk2AK6BXRL0A7Mim77KLUdREeg24L+CLOiQ0Y5ogEdAh0Keg9mRUeMDl24VXQEdCTo8zAr6sIqCXaA7gDdEfR3mBXdZZQEQWDdBbor6FcwKzpmlARjoGOgY0F/hlnRnFES5EBzoLmgCcyK7jFKgj2ge0D3BL0Ns6L7jJJgH+g+0H1BD2FW9IBREhwAPQB6IOgjmBU9ZJQEh0APgR4K+j7Mih4xSoIjoEdAj6qb6JF3Tw1S9PY6zIpOGCXBBOgE6MT48w9exjiB41o+KKa9ZTKdy7RFNsmlRQ36lBJdQDMXis8xN0M30PF0RkbqY4zsQuITJQKfGrl2i1IxuniP8wQ6SprQzys+bZggbTgupw2XkDZcdoO6LKKnJf89cfnvCZnow10+437pyRUxJ7nKLrqKia+InZEqtYdL9E2DPOKRVs6jJuKei/49wsXgHY4pnYPGTf+TD2h5hNeoNJWiTkx4LBscwh3jUo6NHpdbn7JxtkfTf/+MVwZ84Bh0qu8NUp+JNqffWARJGM7J5KhNXiid9X5D1Xb2oeqCy3IXynnUAD4clEczQEY6MOERU/fUI6YgtVuEi5Ya/pEudlkKL6iVSNMNzkCW2XPvIUlpCrOSq0xG1PUVOjbJTZY066K1dAcDEG6Aq9FmBj7RWygnerL8+qXsteMfK/j4bdYUWkwKP2P5rLcz/UIreOGiD2jWJ4HBUWufQTK6t1X08/wf9PkXhtiYnzsdAAA=","debug_symbols":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"call_no_args","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+19B5wcR5V+z2q0Wmm1K8lytiX1rnKemc2SLK9kS85BDtjGNrYkSw444QAYbKIBgwGbnIPBNjmHO8IBJoc/6TgyHDmnIx0Hd5h/1Wx/3m/fVnfv9vSbmTLTv9/7TXXNq67vvap+9Sp2IRi73jojCJ7fNhYuGJoR/dqoUMThl8NFR1y7I+1cR1y3I26+I+4AR9zBhkZF3GIH3xJHXOiI63HELY/i+CpEv6PRb19psL9/31BlX7mvvLtUGdkzPFDqH9gzOFweLg8MD1xSGe7r2zfcPzw0smdkqDRS7u/bV94/MNK3vzR2/agw/qxSjZfFNjvSIbCuMHR/FLZ5+RReZ+jHhbE4KdePPZNFyvWTQjDhahP1qlTbVV6eYx39aX51tMzvl31uaH5nCh24rpzyL7HaOfwzUR65v+g/y/FFnxmMG9ogBXeptqu8Ir9nlQKFgh0Z2D20p7J7n8azXbjz1m+OL5cqzmLQ3PUA1xZ65s8jJfwi+v1l9Pur6PfX0e9vot/fRr+/i37/K/r9ffT7h+j3j9Hvn6LfPxfGHQt7/be5+Yuh/zH0V0N/M/S/hv7P0N9tI2DoHzaBsXgFQ22GZhgqGpppqN3QLEMdhmYbmmOo09BcQ12Gug3NMzTf0AJDBxhaaOhAQwe1TcRysLk/xNChhg4zdLihIwwdaWiRocWGlhgKDfUY6jW01NAyQ8sNrTC00tAqQ6sNrTG01tA6Q+sNbTC00VDJUNlQxVCfoX5DAxGW0yMsg+Z+yNCwoRFDmwxtNrTF0FGGtho62tCooW2Gths6xtCxhnYY2mnoOEPHGzrB0ImGTjJ0sqFTDJ1q6DRDpxvaZegMQ2caOsvQ2YYeYugcQ+caOs/QQw2db+gCQxcaepihiwxdbGi3oT2G9hq6xNA+Q/sNXWroMkOXG7rC0MMNXWnoKkNXG7rG0LWGHmHoOkPXG7rB0I2GHmnoUYYebegmQ48x9FhDNxu6xdDjDD3e0BMMPdHQkww92dCthp4iyvWp5v5phm4z9HRDzzB0u6FnGnqWoWcbusPQnYaeY+i5hp7XNubsv8DQCw29yNCLDb3E0EsNvczQyw29wtArDb3K0KsN3WXoNYZea+huQ/dEWPAi32vuX2fo9YbeYOiNht5k6M2G3mLorYbeZujtht5h6J2G3mXo3YbeY+i9hv7F0L8aep+h9xv6gKEPGvo3Qx8y9GFDHzF0n6GPGvqYoY8b+oShTxr6lKFPG/qMoc8a+pyh/2fo84a+YOiLhr5k6MuG/t3QVwz9h6GvRrLAbnzN3H/d0DcMfdPQtwx929B3DH3X0H8a+p6h7xv6gaEfGvqRoR8b+omhnxr6maGfG/qFoV8a+pWhXxv6jaHfGvqdof8y9HtDfzD0R0N/MvRnQ/9t6C+G/sfQXw39zdD/Gvo/Q383dL+hfxiyXlTBUJuhGYaKhmYaajc0y1CHodmG5hjqNDTXUJehbkPzDM03tGDGeKfLXgeY+4WGDjR0kKGDDR1i6FBDhxk63NARho40tMjQYkNLDIWGemaMPaN3xkTfZKm5X2ZouaEVhlYaWhXxro5+10RpRqM0a839OkPrDW0wtNFQyVDZUMVQn6F+QwOGBg0NGRo2NGJok6HNhrYYOsrQVkNHGxo1tM3QdkPHGDrW0A5DOw0dZ+h4QycYOtHQSYZONnSKoVMNnWbodEO7DJ1h6ExDZxk629BDDJ1j6FxD5xl6qKHzDV1g6EJDDzN0kaGLDe02tMfQXkOXGNpnaL+hSw1dZuhyQ1eIMnm4ub/S0FWGrjZ0jaFrDT3C0HWGrjd0g6EbDT3S0KMMPdrQTYYeM2O8822vx5r7mw3dYuhxhh5v6AmGnmjoSYaebOhWQ08x9NSobJ4W/d4W/T49+n1G9Ht79PvM6PdZ0e+zo987ot87o9/nRL/PjX6fF/0+P/p9QfT7wuj3RdHvi6Pfl0S/L41+Xxb9vjz6fUX0+8ro91XR76uj37ui39dEv6+Nfu+Ofu+Jfu+1v9xb+WVh8kjHb6IeDMf9zsH3BwffHx18f3LE/dmR9i+OuL864v7XEfd3R9w/HHHWMZFxMxxxMx1xsxxxsx1xnY64LkfcPEfcAkfcQkfcQY64QxxxhznijnDELXLELXHE9TjiljriljviVjriVjvi1jri1jviNjriyo64PkfcgCNuuG1yPT3KEbfdEXecI+5kR9wuR9xDHHHnO+IudsTtc8Rd4Yi7xhF3gyPuJkfc4xxxT3bEPc2h06c74m53xD3LEXeHI+45jrjnOeJe4Ih7kSPuJY64lzniXuGIe5Uj7i5H3Gsdcfc44l7niHujI+4tjri3O+Le5Yh7ryPufY64DzriPuyI+6gj7hOOuE874j7niPuCI+7Ljrj/cMR90xH3LUc9/bYj7juOtN918P3QEfcjR9ofO+J+7oj7heN5v3TE/cqR9tcOvt874v7gSPtHR9xfHHH/43jeXx1xf3Ok/V8HX9XBF3HW4Zdp2xxx7Y64WY7ndTjiZjvSznHwzXPEzXekXeCIW+6IW+WIW+2IW+OIW+eI2+CIKzniKo64fkfcoCNu2BG3yRG3xRG31RE36ojb7og71hG30xF3vCPuREfcyY64Ux1xpzviznDEneWIe4gj7lxH3EMdcRc44h7miLvYEbfHEXeJI26/I+4yR9wVjrgrHXHXOuJucMQ92hF3syPu8Y64JzninuKIu80R92xH3J2OuOc64p7viLMdtFER92oH312OuNc44l4bxfHVFv2ORr/NNLO1eobOALmUuVTbVV4zIz/9vS4/mSfMDL5uCmVfqu2aMLFVqx5+XvBjEucXhdplHtg9MNx/yUBfEs5a9flfnujzt4X6vPO16jPHybvy7zyROceJ6/KvPZG5kKPMv8pR5pmRrIVg8pX3O/n7HHEXCCPCr7eNlH2hOmVkMNaAdTqEHM0JkJbSflRofoxvyNPBsgU4l0C+gQpwbtAqQA2Mb8yzAC04uSjQZuDzosA3RUMqUq43eS7Xm2cEE668XfnfF/JrQt88I99mb0ZQl4WNZW6iAqo7eebxeo0urqvCv97zCv+WmBf5LZ7L9daUF7nWly/PyroyUKisQXP77Ks8kbktR5lXeyLzjBxlXuOJzHmOO6ytk8yl2q7yuhz195OCHzKvz1HmtyqNo+ftDG0I/MC50ROcJU9wlj3BWfEEZ58nOPs9wTngCc5BT3AOeYJz2BOcI57g3OQJzs2e4NziCc6jPMG51ROcR3uCc9QTnNs8wbndE5zHeILzWE9w7vAE505PcB7nCc7jPcF5gic4T/QE50me4DzZE5yneILzVE9wnuYJztM9wbnLE5xneILzTE9wnuUJzrM9wfkQT3Ce4wnOcz3BeZ4nOB/qCc7zPcF5gSc4L/QE58M8wXmRJzgv9gTnbk9w7vEE515PcF7iCc59nuDc7wnOSz3BeZknOC/3BOcVnuB8uCc4r/QE51We4LzaE5zXeILzWk9wPsITnNd5gvN6T3De4AnOGz3B+UhPcD7KE5yP9gTnTZ7gfIwnOB/rCc6bPcF5iyc4H+cJzsd7gvMJnuB8oic4n+QJzid7gvNWT3A+xROcT/UE59M8wXmbJzif7gnOZ3iC83ZPcD7TE5zP8gTnsz3BeYcnOO/0BOdzPMH5XE9wPs8TnM/3BOcLPMH5Qk9wvsgTnC/2BOdLPMH5Uk9wvswTnC/3BOcrPMH5Sk9wvsoTnK/2BOddnuB8jSc4X+sJzrs9wXmPJzjv9QTn6zzB+XpPcL7BE5xv9ATnmzzB+WZPcL7FE5xv9QTn2zzB+XZPcL7DE5zv9ATnuzzB+W5PcL7HE5zv9QTnv3iC8189wfk+T3C+3xOcH/AE5wc9wflvnuD8kCc4P+wJzo94gvM+T3B+1BOcH/ME58c9wfkJT3B+0hOcn/IE56c9wfkZT3B+1hOcn/ME5//zBOfnPcH5BU9wftETnF/yBOeXPcH5757g/IonOP/DE5xf9QTn1zzB+XVPcH7DE5zf9ATntzzB+W1PcH7HE5zf9QTnf3qC83ue4Py+Jzh/4AnOH3qC80ee4PyxJzh/4gnOn3qC82ee4Py5Jzh/4QnOX3qC81ee4Py1Jzh/4wnO33qC83ee4PwvT3D+3hOcf/AE5x89wfknT3D+2ROc/+0Jzr94gvN/PMH5V09w/s0TnP/rCc7/8wTn3z3Beb8nOP/hCU77QB9wFjzB2eYJzhme4Cx6gnOmJzjbPcE5yxOcHZ7gnO0Jzjme4Oz0BOdcT3B2eYKz2xOc8zzBOd8TnAuUcLYJnH2lwf7+fUOVfeW+8u5SZWTP8ECpf2DP4HB5uDwwPHBJZbivb99w//DQyJ6RodJIub9vX3n/wEjf/ujZK3KU+QBPZC7kKPPCf8JyPrBOMpdqu8oHFfLT3288sTsHe1IfiznKfIgnZXNoDvVxYPfAcP8lA31JZVOq7SofluN780tPyuZwT2zaETmWze89KZsjPcG56J/Q9i725L1ZkuN781NPZA5zlHnNDD/ewR5PbEWvJziXeoJzmSc4l3uCc4UnOFd6gnOVJzhXe4JzjSc413qCc50nONd7gnODJzg3eoKz5AnOsic4K57g7PMEZ78nOAc8wTnoCc4hT3AOe4JzxBOcmzzBudkTnFs8wXmUJzi3eoLzaE9wjnqCc5snOLd7gvMYT3Ae6wnOHZ7g3OkJzuM8wXm8JzhP8ATniZ7gPMkTnCd7gvMUT3Ce6gnO0zzBebonOHd5gvMMT3Ce6QnOszzBebYnOB/iCc5zPMF5ric4z/ME50M9wXm+Jzgv8ATnhZ7gfJgnOC/yBOfFnuDc7QnOPZ7g3OsJzkuUcLYJnLWuo16eo8z76iRzqbarvL+Qn/5e58k69Es9eW8u8wTn5Z7gvMITnA/3BOeVnuC8yhOcV3uC8xpPcF7rCc5HeILzOk9wXu8Jzhs8wXmjJzgf6QnOR3mC89Ge4LzJE5yP8QTnYz3BebMnOG/xBOfjPMH5eE9wPsETnE/0BOeTPMH5ZE9w3uoJzqd4gvOpnuB8mic4b/ME59M9wfkMT3De7gnOZ3qC81me4Hy2Jzjv8ATnnZ7gfI4nOJ/rCc7neYLz+Z7gfIEnOF/oCc4XeYLzxZ7gfIknOF/qCc6XeYLz5Z7gfIUnOF/pCc5XeYLz1Z7gvMsTnK/xBOdrPcF5tyc47/EE572e4HydJzhf7wnON3iC842e4HyTJzjf7AnOt3iC862e4HybJzjf7gnOd3iC852e4HyXJzjf7QnO93iC872e4PwXT3D+qyc43+cJzvd7gvMDnuD8oCc4/80TnB/yBOeHPcH5EU9w3ucJzo8q4WwTOGvdBz0zR5k/5onM7TnK/HFPZJ6Vo8yf8ETmjhxl/qQnMs/OUeZPeSLznBxl/rQnMnfmKPNnPJF5bo4yf9YTmbtylPlznsjcnaPM/88TmeflKPPnPZF5fo4yf8ETmRfkKPMXPZH5gBxl/pInMi/MUeYveyLzgTnK/O+eyHxQjjJ/xROZD85R5v/wROZDcpT5q57IfGiOMn/NE5kPy1Hmr3si8+E5yvwNT2Q+IkeZv+mJzEfmKPO3PJF5UY4yf9sTmRfnKPN3PJF5SY4yf9cTmcMcZf5PT2TuyVHm73kic2+OMn/fE5mX5ijzDzyReVmOMv8wR5nt3HgxetZKkr8Q6WBG9L+dS7Zzq3au0c692bkoOzdj5yrs2L0dy7Zju3as04792bEwOzZkx0rs2IHtS9u+pe1r2b6H9cWtb2p9Neu72Lbctm3W1oeGrC2w74atK1Z39kz0FYTvg4VxzKsMrTa0xtBaQ+sMrTe0wdBGqyNDZUMVW46G+g0NGBo0NGRo2NCIoU2GNhvaYugoQ1sNHR2V2zZD2w0dY+hYQzsM7TR0nKHjDZ1g6ERDJxk62dAphk41dJqh0w3tMnSGoTMNnWXobEMPMXSOoXMNnWfooYbON3SBoQsNPczQRYYuNrTb0B5Dew1dYmifof2GLjV0maHLDV1h6OGGrjR0laGrDV1j6FpDjzB0naHrDd1g6EZDjzT0KEOPNnSToccYeqyhmw3dYuhxhh5v6AmGnmjoSYaebOhWQ08x9FRDTzN0m6GnG3qGodsNPdPQsww929Adhu409BxDzzX0PEPPN/QCQy809CJDLzb0EkMvNfQyQy839ApDrzT0KkOvNnSXodcYeq2huw3dY+heQ68z9HpDbzD0RkNvMvRmQ28x9FZDbzP0dkPvMPROQ+8y9G5D7zH0XkP/YuhfDb3P0PsNfcDQBw39m6EPGfqwoY8Yus/QRw19zNDHDX3C0CcNfcrQpw19xtBnDX3O0P8z9HlDXzD0RUNfMvRlQ/9u6CuG/sPQVw19zdDXDX3D0DcNfcvQtw19x9B3Df2noe8Z+r6hHxj6oaEfGfqxoZ8Y+qmhnxn6uaFfGPqloV8Z+rWh3xj6raHfGfovQ7839AdDfzT0J0N/NvTfhv5i6H8M/dXQ3wz9r6H/M/R3Q/cb+ochawwKhtoMzTBUNDTTULuhWYY6DM02NMdQp6G5hroMdRuaZ2i+oQWGDjC00NCBhg4ydLChQwwdaugwQ4cbOsLQkYYWGVpsaImh0FCPoV5DSw0tM7Tc0ApDKw2tMrTa0BpDaw2tM7Te0AZDGw1ZI1c2VDHUZ6jf0IChQUNDhux37+035e332u230O13xu03vO33savfnjZkv5lsv0dsv/Vrv6Nrv1Frv/9qv61qv1tqvwlqv7dpv2VpvxNpv8Fov29ovx1ov8tnv3lnvydnv9Vmv4NmvzFmv99lv41lvztlv+lkv5dkv0Vkv/Njv6Fjv09jv/1ysSH7zRL7PRD7rQ37HQv7XQf7zQT7DQF7Pr89+96eK2/PbLfnoduzxu053vaMbHv+tD3b2Z6bbM8ktuf92rN07Tm19gxYe76qPbvUngtqz9y051nasyLtOYz2jMMnGLJn89lz7+yZcva8NnsWmj1nzJ7hZc/HsmdP2XOd7JlJ9jwie9aPPUfHnlFjz3+xZ6vYc0vsmSD2vA17loU9J8KewWDPN7BnB9h9+XbPu91Pbvdq233Qdo+x3b9r98bafad2T6fdL2n3Itp9fnYPnd2fZvd+2X1Vds+S3Q9k99rYfSx2j4jdf2H3Nth9A3ZNvl3vbteS23Xadg20XV9s1+7adbF2zaltW+xaSbsO0a7xs+vn7No0u+7LroOy64LsOhm7bsSuo7DrCuw8u513tvOwdl7SztPZeSs7j2PnNew4vx33tuPAdlzUjhPacTM7jmTHVew4g+13236o7ZfZfor1260fa/066+f8MCoPXAeMB6ttqL1233DDvquuvSG84Zpw9yWXhI+6/IbLwmseue+6/VdeY0191W5NJ43N7qCI77BC9rQrKO1h0e+2667bfVN4+dWX7Ht0eM2NN4TX7A/3XHPj1ZdczwkfWkOml2bN9BFZE76xBrSFtuxpj2jLCHhF1oTlrAmPzprwlKwJ92RNeFkNJXJt1kwfWUOmj8ua6a01ZHpH1kxfUEOmn60h7dezAv5B1oQPn5kd7WNmZsz0iTVk+vmsmX61hky/nzXTn9aQ6YpZ2dPuriHt82tI+/Ua0h7ekT3tEko7vVYma8L1WRMOZk24JWvCY7ImPDFrwptqKMp3Zc30/VkTfixrws9kTfiVrAm/lTXhj7Mm/FXWhG2zMyacmzXhwVkThlkTrs+acAslPCL63bv7yiurb8f11++77oaLrtr96Iv2XH7DRddf/ph9nHR71jwfTQmn+1I+JWumz8ya8Oc1oO2YkzHThVkTXjgnO9rX15D2PVkBfzhrwv+uAe2MzoyZdmVNeGxndrSnZ830nKwJd2dNeGkNYh7XnT3tSd0ZAe/KmvCaGtA+pYa0T88K+I6sCd9SA9qP1ZD2U1kBfz5rwl/VgLYwL3vamfMyAu7MmnB1DWiPriHtMVkBn5A14aU1oL2lhrRPzAr4aVkT3lMD2vfUkPZ9WQF/OGvC79aA9jdZM/1j1oQL5mdH21ND2uXzMwJemzXhCTWgPa+GtBdmBbw3a8In1oD2OTWkfUFWwC/LmvB9NaD9TNZMv5g14W9qQDtjQfa0sxZkBNyVNeHaGtA+ooa0j8sK+ClZE96RNeGrKWHPZDGvuvHKGy6/9sqb4mW9O2vO99Wg4E9kzfSHNWT606yZdhyQPdPDaki76ICMgJdmTbitBrS315D2xVkBvyprwjdkTfj2rAnvo4SZ3tRPZM35hzWUzE+zZjpjYfZMZy3MmOmyGjJdlTXTE2vI9Pwa0l6UFfC+rAmfXAPaz9eQ9ltZAf8ga8JfZU34h6wJ2w8cT5jJPMw5MGPOKynhdEtmbdZMj68h05OzZnp5DZlelTXTO2rI9NU1pL07K+A3Zk346RrQdh+UPe0RB2UEvIoSTnNicH3WPPuzJjyeEmYyECdnzfnyGsrmqqyZPqOGTJ+dNdO315DpfTWk/URWwJ/LmvAXNaD9Rw1pZxycEfDsrAlXHpwd7cNrSPvOGtJ+OKuw/6gh08MPyZjp8qwJS1kTbs2a8OSsCW8/JLtiX5Q107uyJnxr1oTvrkHMD2bN9KM1ZPrXGtKOHpo97SmHZhT2lhoyfXrWTF+QNeHLakB75mEZM33oYdkzvTxrptfUkGl4+HjaTK7ZssMzot52eHbUO7JmuqeGTPdnzfTJNWT6tKyZ3l1Dpq/Pmuknasj0M1kz/WkNmf4ya6azjsieaecRGTNdVUOm67JmekINmZ6SNdMrasj06qyZ3l5DpndkzfTNNWT69qyZfr6GTL+cNdPf1pDpH7JmeuCR2TNdXkPa1UdmBLwxa8JTakC7t4a0l2YFfFXWhLfXgPauGtLekxXwm7Im/EwNaL9XQ9ofZQX8i6wJZy3KjnZRDWl7FmUEvDJrwh01oD2/hrQXZQW8L2vCJ9eA9iU1pH1FVsCvzZrwvhrQzlqcPe2BizMCPiJrwuVZEw5Swp7JYqZ3NDdlzfmcGhR8ftZMH11DpjdnzfSVNWT6thrSvisr4PdlTfj1GtAetiR72hVLMgJenzXhNkqY6b3ZkTXnPTXoaX/WTG+rIdOX1JD2FVkBvzZrwvtqQDsvzJ52Tw1prw4zCntj1oQ3Z0341KwJ78ya8IVhdsWe0jOeNtNbvqsnI+qre7Kjvi5rpnfUkOnzsmb69hoyfXfWTL9cQ6ZfzZrpX2rItKM3e9q5vRkBH5A1YakGtDtrSHtiVsCnZ014dQ1o315D2n/LCvjjWRN+gxJmsoXfyZrzX2vQ09+zZrpkafZMSzWk7V+aEfCmrAnPrQHtS2tI+7qsgN+aNeFHKWGmKvzJrDn/qAY9/SxrprOXZc/08BrSLl6WEfCyrAm314D23BrSXpAV8J6sCZ9QA9oX1pD2pVkBvzprwg/VgPY/akj7jayA/zNrwv+rAe0By7OnPXh5RsBHZk24qQa0p9eQ9qysgB+aNeGjp4sWZ+VjSyGd2xWEQU7n8g+XKu308EIw8WrjjDvG8+4Mxr9bgHj7MyN/fGX73GLezy2Nfdd7Zv7PLVvdtEfPgj46KdxOatOQy57Y2EX5FjqoLIOx+lQQ5T2H0ly7e+/Dt1136Y1X7bv6huu5QgA4x91PD+ZM8EGHgIRkvjC6l8+ygGeK/Liy4T97mNgTojdK5cUY2TvAL0Z7MPGqYocSOybKNCO6nyHii9F9kZRv42dG9zMp3vWCcSUqUNwD+qU46GkGxUGGIsXheE/kbe+/GVAaUXmqaSAfxXVANoqbDbkobo7Qp43rpLwRN5eMCuK6opvZFNcdxc2huHkkH37nR3FzKW5BFMcvywFRXDfFLYzicHCJvT0hCodBXoau3G+fe2Lezy1Vqobu5NyfO2aYT8n/udUPxZwaPWtm9GzkcyKVwWlRuJCjTJx3ISLkg/gihVcTL/igD5yhAey2np0UhU9LSHeCSNdNPCdRulNEOtyjrK3uMHehU2f7WnU2unyqs0PEK+setuI3ss6uj8I6dXZAqc4OtOrsNGSabp3dQbyy7mFLcCPr7OYorFNnd7fsbHT5VGfPJF5Z97CHspF1Fs/SqbN7lepsX6vOTkOm6dbZ3cQr6x726TWyzp4ThXXq7H6tOru3VWenLtN06+w1xCvrHraNNbLO7ovCKnV2ZMwe5l9nyy07Ow2ZpltnbyFeWfcwO9DIOnt9FLbjX6PRgBuW8urU4/6yTj0uDbbq8dRlmm49fibxyvqIsadG1uMnRWFbj4+L6nEPxR0fxWFRkFLdHtGp2/0tGz0NmaZbt19OvLKOYgVOI+v2c6OwTp0dHmn5FWOXT3X2jcQr6x4WIDSyzr46CuvU2RGlOltq9d+mIdN06+y/Eq+seyujcCPr7FujsPUX7on8hdUUd28Ut4biXhfFraW410dx6yjuDVHceop7YxS3geLeFMVtpLg3R3ElintLFFemuLdGcRWKe1sU10dxb4/i+inuHVHcAMW9M4obpLh3RXFDFPfuKG6Y4t4TxY1Q3HujuE0U9y9R3GaK+9cobgvFvS+KO4ri3h/FbaW4D0RxR1PcB6O4UYr7tyhuG8V9KIrbTnEfjuKOobiPRHHHUtx9UdwOivtoFLeT4j4WxR1HcR+P4o6P4uzCHazHsB+Lt5e97Yr+D4Oc3uHynv3V9RvBxKsg7kMKA4PFMydvPAaRfSaOPbbHp55+3eWP3H3Dvp03Xr33hsuvubpAEAEbKuL/WIT7iYeX9/AypRkULlKYvgI8Ie0sR9z9pA7XPePTWpNmn03f+as+e46QpZV3Y/LOfc2kmdfjJWC4kl7fGYSnXUEXvHRtKnjadfGUuoO6rcdMrAdFyntW/nlXeHngVPQ+i/Dk3qxE9WDWNPBws9KmgEdJzmoXtzt61v1Bvm79PKGrWUJX3cTTTfqbp6C/AuWLZ+OeMaAO8hJP8BWbBCPi2giPxjuQZA+4DHmps9TZzCbTGS+/jTzUB+yqxdpJ7qqGPbePR90qRs+WOIrEs335OLZ5EbYugVnKwzqfnb8M5QLlFQgZkF9XMNFGIw5hbsc13HD2ryVG5FcIxpdet8fIUSSewyP90yfnHri4nWYd8HOC6FmdIs7mOVdJB53BRB3gfi5h5KXrwKPlX6BOFIKJbQLrojP/vEuaOmZb59JxkXhWJtQhly1jmxpE/xcpDJ11KMkWV14ddcw7SMhbwb5V2JYGJH8g8OCaTXgU6lhlukMccwmPhl+gJGddfdHZQlf19kXnCjy4R34+Yu4OJrefncHE+tgMGLntAx6ttiHOhnEZurYR4v96+M/T0Rn3i3irHbCerOs/V1inaG/bhP7Yfy6S/3x6iv88W8TV0zfFPfevIJfLn2T/WcFfqrj6ftIX4brTHiNHkXjOn6L/zDqYQ3Iib5c90er/xr0bXfQr7bKmT4Q6AX+MxwDwq9U2K+i4Ws/Qds2M0XGReC5L8Z+76T4MxuuPq78D3rZgYluAtG3Eg/+xjVw+Iwx0/S0F21/VPfQI3cuxkyLxXJeie44Pg2DSWFEX6Qu8bcTXTc+y8dKWQPfgm038mmMdce8c+/3aeQcJeSu0UdPuc7Cdzr2ulvfs7aQ8poKHt8DPzxuPeCfz7KvY5y5Q0J997gFKeliY/3OrfTZsl4RtQj58zsxBVBfykonzLkT0wPno0W+Rws8ujPOCD/pAnQX2buLhvt5CkQ73B5AOnloYf4a0jdVjIqIw2waNMi9QXnj2AoG3m+LmE57c63aKnVxAeFz9rAWk32bSGfetZJ/RYn059bNy9/eMvXCNa0ocPK75yWXjvK+mfpbsx7IdZ50rzCknzl/xXCT6M65+h+p6g0jPs2Iw8jFG3Md1yVEknjdNsZ/FOkCY+3guX0NrDCLu/Z1HGCEz93m0/C7u44Z0P5v0iPrLR/W4xhA01gMkjSG0EUbZZ1caL0h811p5680L8PyevQriPqQwj09ovDc8NjMVPMr9pxKPW3JeWu9jXD1ge6XRj2dbPRW9c99IwR8b6Awmzl2k4WF/XquvpiBniX3FvOerZH9gntBVdzC5j6DUF0v0XZFfC3ML84MJs8UjfVDuL7Y1CcZ69rHj2jcuQ/gjsxw662wynbGfhn4s++9/pD62gn8ywDqV4++8bgw8t1Ef+y/Ux5b+Jo8ZsM411su7+q9ybwnPkbn6nOyXKvhHVT23x2DkMbj5hNslB8+FtEUGwNXHZtl4HMdlOxo11tRF2Nn/0u6roj8926ELrbzlvNT8Vt4P5K3QVky7P8L1T+N94HdvKngOUMaTVDbKvk+1z3Jg/s+t2ljMa8j5Gp4zeeA7DAn2k58FnLCneGYX6eqBD41ROAx0ygv2a34D8g4S8lYo02q/+eD8n1utK4dEz0JdAX7kVySelSl15RChH9QVPLOLdHUI6ewQBZ0l1ZV65h0k5K1QphX73EPzf261ruDrJagrwI/8isRTSakrhwn9oK7gmV2kq8NIZ4flL1tiXUF+bSQn15k24sH/WB8j8Yd1kiGIkUGpbvTZ5x6e/3Orde6I6Fmoc8CP/IrEM5pS544Q+kGdwzO7SFdHkM6OyF+2xDqH/NpIzsOIt4148D/qnMRfqJMMQYwMSnWjeuzqkfk/t1rnFkXPQp0DfuRXJJ5TU+rcIqEf1Dk8s4t0BV4eG1GeI0ishzyehH6EazyJ+zGLlDDG9aNdOuP+layPeH/aBC/eH373wP9g7Y+nzVurzAOJtRZ4x9pFefDegb0p71jaug1ewz8rIR34ec2ZHItqF8/hsajLE3BqjvvF1aH2OuYdJOStVYd4zVhIZcJ1CDyPSKlD0r641idBpgUJ6WSfx1WHZonncB16VEod0lqfFVeHZtUx7yAhb606JNt62YZwW//4abb1cl6Gx6MXJaQDf1Idku0f16GnpNQhLT8irg6xnwBMXJfagsl6R3ss35WwTjIEMTJo1kX4l6iLi4ROisRzZ0pdPFLIgbqIZ3aRTEcmpAN/Ul1cJJ7DdfGFCTh5XRDSKvn1ifWT84YsOa4jKXMetmzlu/ugq8/R3MN0xvp53nyJEp7508DDn8FbnD+espKc1XkFyJH3Wqgeoav5QlfdxBOS/noU9FegfPFs3CM/HzG7+rGdxLegSTAijj/xoFCfE20Yl6HcO8A662wynbnO58J8mm0fPtg2jldhvLa63/Rwyi8kHDyWD54Tab3LRyJsXcTL610OFHGaa4yQF559oNClxYj5BJ6DQpjXu2i0gYVg8no75M1jbhjja4+Ro0g8n5uiP8U6kPv1eF0w2xOtvfvy/BTeS4JfyFyP8U7UCfiBBzt0obD+SXXvvly/JnXM69e+kdJ3kOsLUX/4mXLtXhvlxeMjbcHk/efo28lnWH7NvfsaZ1S5xhBcawfB88NpjiHwe4xf2ZdrIz7eg27jpS2B7sHH6xW01i8kvXPIT6mdqHCbFBAGvkIKLyQ8+deXSqkzmNgmpOHh/TIacyssZ9775/PvN419flajf6jkG1b7Tb3Rs2AfkA/7zkupLuSUd5nzLkSEfBBfpPCMaENqZzBeB7kvhbTQEb+v9uomntkO2cKcZQsFHtwvzYh5XpNg7hE8uEe9t/XoT23j+KWNt+WHusX2NVSSabHAy+89MCKOx7w0xlW4rcGzcb+Y8KB/cqhDZ51NprODCRf6ZKir1fHEGeN4819TVq7asEMpv5Bw8DpB8Fy8dJz3oAgb9xe5jyjXpir1xcquvhjukR/3F9nvkn1aHkvkuqK1Jz9ujQ3741KWeuixEKNHzbzj3u35uuUw7fFjbku0/Mjp7O3l9li7f5W3H6ng97b80+jyyT/dOk3/lO2AvXzwT5MwL2oSzD2Cx+Wfbpwxjl+2V+xrsd0OlWSajq/F509q+adxfojLPz3QobNm80+53wG/kMfETib/NP8xnrLzjLrDBTY+J+6RveO8p5N/KsfmuY3letrIcXLXWKz0RXleieuK1hlNXQK3HP/scshSDz0WYvSomXfcu92lWw4VLvOA5A8EHlzc/uVv5wZK0z23lH0NrXFO5JG3f7qE5MvzuaFCuSj5kQNKPknVtkfTzw/Yds4HdWZ5/mVQ5rzhnyIfxBcp/BTyT+Gzst+EtMCO9wO83cSz2CFbGOj43ng27pf/E2Fe4iHmVt3Ijln2t3APm2htzBXUd5G+DPc9uU3vVZIpFHhxzzpGHPcPQyU8cT5qSHjgc8536KyzyXTG43Qaaz7ixuyfP0Mz37E+kfymgMTB67Q/s2Sc98XUJ+KxcXuxX8f1X2vfX9zaP17HDnkYl+z/dFIaroNafXy5jgP3PM4gZamHHgsxetTMO85mKM8FVrjMA5I/EHhwcRsV5o5nbMx+8TTwhIRHY22t1lpxrbFqnTZjbMxeoe9SUfJ1qrZ9RfQs2Hbk00t1ZmUUzrtPtIKeW6B8EF+k8H3UJ0I/if0xpIWO8H6At5t4QodsYaDT38Ozcb8yI+aeJsEsfXXco97bevRO8ntle8V9Wrbby5RkivPlWceI4z6clk8Z54ewT8nfhpU662wynXF/Bn4h94G+SP5p/uOVY/6p/K7F4QIbf9fie4vHeb9C/in+Z9/OtdZIa29K3DwJ8mM/j30/6YvG7VcJlXDH7VcJCaOUpR56LMTosZH7i5TKocJlHpD8gcAjwzp2rq/UKfJLw8O+hoK/V2Y58/ZPNcaqdWx7X0nJj+xT8kmqtn1V9CzYduSzjOrM6iict3+6ip5boHwQX6QwPuJu6z58VvabkBY6CqMweLuJp9chWxjo+N54Nu5XZ8S81EPMzaJn2Q/APd5VW/d/Qz61bGO5T8RtzQolmeL6CaxjxHG/RctfjfOd2F+FL7TIobPOJtMZ95Xgy3L/qrs4jjf/sbYxn3ox5RcGk9fjFInnM4vGeQ+IsLFvyv5oKOK02vxCMNnnwT3y6womnimIOOk/d1Kaesw79AjcuO8ljKGQpR56LMToUTNvlA+efbgjb4VyqHCZByR/IPDg4rZEwXfby2MAU8HD/pHGGk8lez7BR8373BHZFrvGNcCznPTXqDahhbk+mJXyLrl8O5cuVjrwNGqMV2m8f0JfLkkXqxx4VtVZF9zve7BjXuEhZh/1vLyFuYX5QYS5ZetamOMwt97BFuY4zC1/o4U5DnOrbtQHc8vWtTA/mDC3bF0Lcxzm1jvYwhyHueVvtDDHYW7Vjfpgbtm6FuYHE+aWrWthjsPcegdbmOMwt/yNFuY4zK26UR/MLVvXwvxgwtyydf88mPn7c8DKexx6mgQj4ni/0DIlPKHAg3suQ6znX+LQWWeT6SwkXNh7wec3rJ45jldhj2s/6xT7QuT+2iLxbDx4nHd9hI33V/SQPL0izsqgdTYx8sKzcY/8eM9yL8UxXvwuFXGa9TnuzLFlhFHKUg89FmL0qJl33J4vZbtS4TIPSP5A4MG1jPDkv8a8XGJ7NRU83FZpnJ/Hcua91zr/NfHlkpZtt89V2FNaXUe/JnoWbDDyYX9vbTBeF/KSifMuRIR8EF+k8Kkzx3nBB32gzgJ7N/HwXhK5n1fuwbZZ7Jw5/gxpEztJL2wbtNrzuL283J7L/b06dTu5rVtJeNB29Th0Vg8faDo66yU8vfnjmXB2BZ5vq9eF5Fv15J5v2fn9jFCUS5F4fn/QOO9u8q1cPorLn9U6OzXOn0V+vHeV/RaE+Vu6Gu1lIZh8hhXyZruD+tYeI0eReK6M9O/6FifLxr7iKhGn1F6UXX1Z3K8mjPKd0/TdwuhZCIcOXWjlHWdr6pF3KPJ2yZ27jS3v2cvtqDznD/kVieexCfXZ1SbD5vA7DplWa8oW6VXikbKx39IueFaT/OB5UoL8/G1slk3r3Q1JhpDuOW8FW17t56wWshfEfUhh9mXW5o9nsDOYaLfT8KwlPGvyx1NWkrPaH1kXPSvv/e/rha6WC111E8860t96Bf25+gS4R34+YlbKu1p+G6agiw0OPBvqrAvkN13M61qY64K5GeoGn8MFrJ3Et7pJMMrxDSW7n+gfchm6+uprKdxMOgsJF/qtqHvWxXoP9akVzt+ocN8Hfi9w8BnT4PnSgeO876M+tTyzjeXhepr/uEDyGA7ysxjlud1dAi9+e0RcRzBeTnnj7hG4WT/A6Jr30dZjIUaPmnnHnZtdT7mDIL7+IMzjL7n7zVFfFPYB7yTy5jFk8HwhpS8q7dFqh2xhFF5bb3ljbKaU1/LAj2gXPGtJJ+D5WoJOGvn+tBHGkH7biIf7Nm3B5DHOMGjsu9AhZMgl76jec9tnn71W6KRIPD9IqfeyX4R676rjSf0p6d+46qLs43Bd/NkUx0qU+0eJ9RP5tZEsXL/aiAf/o35KHYaBmg9YHXPh8oEsfIUU5jGO/P29/hL7llPBs4Hw5P4ORWMuyCPvueWN+eOtPrekUC72ueX88fbb5/Yp6MHWmf7oWbB9yKdEdWYgCheCfO1CPz23QPkgvkjh+e1jv7buV6K4PkqPtNAR3g/wdhPPBodsYc6yVQQe3A9kxLzRQ8wtPWfH3Cd4cA/7Yt/Xv9L6CtlO2vcE7zC38RUlmUoCL+5Zx4jjsbn87XCyP1kiPOhrr3borLPJdMZrhzEugrpqq8Hi9nG8+ftAY/Pz6yi/kHC4+kK3Lxzn7Y2wdQWTfVaez+J6Wq85SbluyWKEz83z8IwXv6tEnNLal8S1Aq5xpVV11GMhRo+aeaN88Ow1jrwVyqHCZR6Q/IHAg4vXROXvx46tMe2dBh5u2zTGoevhr+c991oWuuoVuuomHvaJFfz8at3eKPDgvqybd8nll7h0UXHg0Wof43SB/KaLudTC3MIctOpzC3OrPpdqu1p6bmGuK+ZWff7nwcx7uHncA3yrmgQj4nicU6H/kzhuwWWIcYj1Dp3VYzxrOjrjMTeMGfHY5m00nqXQl+9nnWI8CziQH6+9P+GAcd5n0ngWeHksaL2I01z3JeeNcY/8ukiu9RQnx646KQ3XFa36LNdF4n4jYZSy1EOPhRg9auaN8sGz1znyViiHCpd5QPIHAg8uHj9SGIPYy/ZqKnjYJ9CYR9Aaa2EbnPd4lpw3kuNH3cRTIf0pzC+XXeNruO/TzXvC3HaSLvodePrrrAueB58O5koLc10wt+pGC3Mc5lbdaGGOw9yqG9kw854o7r+Cb0OTYKznvGBcP4/LEP22VQ6ddTaZzlzrP/C+2D72D6n/r7COoJ91Ks/r4b334OlbMM77U+r/Iw33nV3jQlrrnOLGXJAf9/W5by37+nFrn7Tqc9zapzJhlLLUQ4+FGD1q5o3ywbNXNUDuIEFuhTpQ4foWkO4DgQcX9/Xz7y+Wh9hWTgUPt+0a46ksZ95r6vO3/+UhrfWy9rmD+T+3Oj4wFD0L9h/59FPZDgfjdSEvmTjvQkTIB/FFCs+eNc4LPugDdRbYu4mH18cPinS4HyAdFGaNP0Pa407Si2tvQJizfqTP2i/w1ttnjbOT7Nug3dzg0Flnk+mMx3I11uzxPAivUz501ni++Y+nl4cKIr8wmDyWXySeP88f5z0ywhbnH7l8aa25tDhfGvnx/Aj7TAjz/lmN9rIQTJ5XlmO7XCfbY+TgPT4rI/3PDyZfvGeRdSDnrZvNTnGZcLui5c/FzWO59j1wHXf5/lq2NM73Z1vq2ruiMf823b2dyvOBJd7LozzOMW0fnOuvgk9W4Xd3KngGCY9Pvqd9Lny7vOf/pH/YL3TF/uEQ6W9YQX9Jfif71b5hZvvE/h34Sk2CUfr4rrEp6/fsIp9MYS62et4P5xcSDuRXJJ77yCc72+GTNXNbD3nq0dbH7RHlsT9XO6qgn4pLPyWhH6637YG77S8Sz54Uf3C9SKvZLk2nneR2SeH972dbMxU8w4RnKH88ZSU5q+3kSPSsvNvJTUJXLvsJnhHS3yYF/bnaQNwjvxbmFuY4zOyPAGsn8ZWaBGOdfLgS+zl4vvUlbiU/R6GdqM4p8nhqSDiQX5F4nk5+zm3k50ifJs631LDlSb4l8usiGbit0/Jz5PkdA0IXcX6Ogn76XfopCf3w+yD9HK4H4HnBFP0cZb9i2n4O+xUKdmWYbdhU8GwiPCP54ykryVn1czZHz8rbz9kidOWyy+DZTPrboqA/V9uKe+TXwtzC3MLcwvzPgJn9dmDtJL5Sk2CsU19ngt+O51vf+FPktyv4PcNWD3ItiOw/8HqMXeS3f478dumjx/XBNHyTpD4Y8usiGdh30/LbhwSeIaGLOL9dQT/DLv2UhH74fZB+O9cD8Hxjin67sp88bb+d/WQFuzLMNmwqeLYQns354ykryVn124+KnpW3375V6Mpll8FzFOlvq4L+XG0r7pFfC3MLcwtzC/M/A2b224G1k/hKTYKxTn2dCX47nm994zkd4/lqjA9aPYxQfmEwuf9QJJ7DyG/vjrBZH1T66HF9MA3fJKkPhvy6SAb23bT89hGBZ0ToIs5vV9DPsEs/JaEffh+k3871ADxHRGWf5rfr6npsDS2/L2Ewud4x7jABt8smVIQcvGaYfW7tMy5yfG7FpTPXmmLwrJymzrDGiNdUb3LoTGvPj8I7XdXZUUJnct10kXg2pOjsqBid8bps6Aq8bcTHbZCNx7ol/oZIG/HxmjSldbf9Lh3J/caso6Fp6ghzulyvIBf7NFqylYRsFYds4DkqRbZSjGxc/pCppCtbRcnHqursaKEz4N9KOgPPsSk6OzpGZ3xOF3R1NOlMQba+DnpWjs+t6myb0Bnwj5LOwHNSis62xehsK+kMutpGOtPYt2B9wgEHxkBgxMV7GZCO97Buyx/jtNfPs862K+HZNg082wnPaP54ykpyVn2dY6Jn5T0OeKzQ1Tahq27iOYb0d6yC/gqUL56Ne+TnI2beFwmsncTX3yQYETdKGOVZLtbuXk79boU+WYXHbGS/G/kViecn88Z5r6J+92ahX95jyTrXOoMybo8ln5PhOn9Ya19c3Heh+gmP3HOgpJ+KSz9y77Dlgf/SHrj9XN7X8ZiUfrerndTa95alLVdqlwan226PEh6NPZFKcpbY78m7nZT2s1/oiu2nst9TfZdHBR7cI78W5hbmFubGYuY2h30Q8A00CUbE8X7w0fzxVOdxZH/d+mx3kz+p4GsMFoLJ36EFDuTH50S8hfzJ15M/ifVFvN/V5S9pnWkWtz+Ux/xcZwxp7VdNO/NHyb/S+g5y1SeVZ7u4/E3wvDtlfEme6SP7I7zPRfns87LW+CjbmKRxbfB8IEVnozE6c53bB9424mP7YePRx+H9D23B5G9HWH6l/uygS0f9Ahfr6OPT1BHsEtcryAVeTdnk3vuyQzbwfDZFtg0xsnH5j0Zh8HL5j1JanhOS5S+fYfm1xjOUxmMH2SeC7oEf+RWJ5z9SdC/9qyGhOz4jgcdSFWTr4zHPHJ87yOOH0BnwH0M6A8+3U3R2bIzOtpHO5FhbG+XFfl9bMHncEvVVPsPyK+mo3z53R/7Prep+Z/Qs6B74kV+ReH6SovuddB8G47rHM7tIX+BVkm3APvc4JZ0dL3QG/MeRzsDz6xSdHR+jsx2kM+gKvG3Et5PS2ni5dxf1FXy8D1ppX3TimiLe0/rPmrfCPuXKdM8I4T35xyvoojOYuB8kDc/xyniSyobzVrAZ1TVtJ0TPkv4m2wzwzJg99htnM04QcmA9I/ubkOkEku2E/GWboNeC0Gs98w4S8tYq0xOjZ0k/m8sUPF0pZXqikANlyn42ZDqRZDsxf9kSy7SeeQcJeWuV6UnRs6T/zmUKnkNSyvQkIQfKlP13yHQSyXZS/rIllmk98w4S8tYq05OjZ8n+BZcpeHpSyvRkIQfKlPsXkOlkku3k/GVLLFPk10ZyAtdoFH+y0AN8RYl/tE4yBDEyaNaNU6Jnyf4P1w3wbEipG6cIOVA3uP8DmU4h2U7JX7bEuoH82igMXPdHmE6l+9EaMe2PLvvc0zI8d3/KZZ97eu14yzIiID20URh5TeV/F+9plOY4wXe/uLdbjlFGXCfx/1EJdVLpvUl8Z4+jvBXqdfWdheyy/32KQz/HpLyzpws58M5y/1uWEde3MD/ZBu3c35Ajr0bZh3rkHSTkfVr+eVf7yWynIX8g8OA6jfDsUsJz2jTw7CI8p+aPp6wkZ3WO8IzoWXmvBTpT6Oo0oatu4jmD9Hemgv4KlC+ejXvk5yNmiwfvDbB2Et8pTYIRcacSHoX6nGjDuAzlWaKss8Em09kIYcR6DF6nccXscbwK8xzVuesdlF9IOHguCDzX0LqQqyNsXcQ76JCHda61v1fub8c99/vRX+S9LQjz2KzC2ThVPW+Owcg+gTzTUsrBZ1relOBnsV/DOkAcbAeXE9sTrTP148ppmDAC71bCo+UToU7AH9vm0IXC/rCSko4nnBE/M0bHvM7rqSm+ulxvhfrD7xB05fqmWxjk6ydprXk6VehMjgUXiedZKTo7NUZnXMehK24ztWxjXB1Hftxmwo530v/K82hll23E/RBhlOs62KbzN8QGRZymbuPW/7HNPcahR625UOSFsm5E3kFC3hpri6Y7D8tntSj050b43ZkKHrYBWt+OUJBzwhrUvPuXpwldbRa66iYe3sukMH5Rdtl0Oa7YwtzC3MLcwtzC3JyY2ccF1k7iG2wSjIjj8QiNMeckf43LED70NofOOptMZ9x3wXgV76H/Fo2lbcsf7wjrVM6TIb8i8ZRpLO0/HWNp3KfZKuKaeSyNv4usMJY2ojGW9ouUsbS5Dh3I/jGfRV6PPnPcWeT8DSE59qPZ/4sbZ+BvjKL+ch139deb4Zue2wiPgr1IfNdaeevMd0z3vCQ+O0fjvekMJrbDaXjqMY4TVzbK38YqKdnKanvBZ/eEwWRbWSSe2XPGfuPGd+WZLWgHeHwXumLfV2tPNJ/zHNJ9PfMOEvL2aExrhPs2qCvAj/yKxHNgSl2J6ydxGw1d8boXjXU4tm07xpGXVv8irl6eWse8g4S8FdaTVbh/FJD8gcCDi9ecnZE/nqHOYOJ6uzQ8vO5FYw2HkpwlXs+R91j0WUJXpwtddRPPmaS/sxT0V6B88WzcI78W5hbmFuYW5uli5rE0YO0kvlObBCPieF2uQpuS6EdwGaI/udmhs21NpjMeR8TYJH+/+7Q543gVxheHWKdyjNR1rukfu8d5z4yw8bjWNpJnRMRpjiPFrUN1rWPjbwMizOMKCv2jIdf4IPLmb2ijH9AeIwf3dR6W0NfhvgXrAGGeMzhNxCn54mWWD8/G/emEETLXo0/E31MJA/e8Geovv6v4n+t2M8y58FoarfmIuHetlbfK2tTKdNcv8TpdjfeG57+mgkd5fKHUHbjHE7Tex7h6wPZKayxjOvuklMcyKq2xjNquVj+qfv629DO4T3Bak2CsZz8qzoZxGcp5FNbZ5ibTGe/bQv+F9xC8lPpRWvuJ5J6FHQIb71l4D/WjXkn9KNn34jUMrPNGrmFw9a0QZt9Dow0sBJO/sY68kZ/lwTvUHsTPL4LnDSn9qK0OHSDs2gfK9kTr/Y3b03gGYYTMbE+0fSL0o1w+kfae6hyfW61naLtmxui4SDzvTZl3lHudUX/wzC7SFXjbgsltVBjFy33ROLdGPsPya9VDJdtf1f3Z0bOge2n7i8TzkRTdn033YTCue35XoC/wthEf69LGS1sC3YOPx7jqMeYl3zleW9ao8TalNqrC7WFA8gcCDy5et6tRV6d7xuNZhOfs/PFovZNVO/uQ6Fl594HOEboaErrqJp6HkP7OUdCfq3+De+TnI2aLR9qtTuIbbhKMiDub8Gj1L+JsGJchfO4dDp1tbjKdcR8I/Qz4F7Yd/Tn1gTTO8eE+G9ptiaNIPI+iPtCvqQ+0S+iX5WGdK5yZnTjezudhoa9xKsUhzH0grb7mjhiM7BPgPW+PkaNIPH+ZYh+IdSDnK7ktZHui9f7KfqC0wVwm7Ado+UTc/wzpXtknKtXTD5c6Zj+8GG0YmKofjvrD/Wroiv1w2UaFUfzZAgv8cPkMy69VD9kvyvG5FfYxoHvgR35F4ulO0b30V3YI3XWRvsDbRnysSxsvbQl0Dz6e59Gcv4175+qxplWem+jKW6GNmvaa1h2ER6Ou8pjrVPBo+8NKclbt7LnRs/LuA50ndLVD6KqbeM4l/Z2noL8C5Ytn4x75+YiZ10mwPw++U5sEI+LOITwK9TnRhnEZwufe5dDZ5ibTmWt+D/6FbUcHO8fxavWBzqL8wmDyvF6ReEaoD7QpwtYVTO5j8vwC61xrnVbc/AKv05Jycd+N+0AabaCr7iJv5Md9/PYYOYrEsyPBh2LZeO2c3Iuk+a7G9XceQhjlmkJN/wflD9/LtS5Zq79TL59b6ph97l3T9LlRf7i/A11p23r2XXJ8boX9AOgM+M8lnT3gB6To7LwYnXEdh67OI50pjLMk1vGROuYdJOSt0IYNucoU9pLbMPDsmWaZom1zrflN8i+lb8LtVLvgOY9wgueyBJw8xsX1SsuniatX7NOgnYe+Oul/5TWnZZf+cb+VMCKO51LluZA8Zr6tDrqNGzM/jzDK+eR6rGOSZc3zDNDL5ibVGc8zcFkDG++fUFhrMOEsn2L07G0Cj45+ynunu/6a7YfWmKNCPSixLenI7bkDTl99s9BVN/EoryFLtG2u75vkp4vBAW6zknSxy4FH6wz/OF3scuSdoy6qeZ87BV2c68Cj4Msm6uJcR9456qLf5v3QKejioQ48D62zLpDfdDGf3gSYO0Q4n7yHqjbu/Cno4nwHnvPrrIvzHXnnp4tKdTz7gino4gIHngvqrAvkN13M5zYB5g4RzifvwaqvdeEUdHGhA8+FddYF8psu5nM9xHx+E2DuEOF88h7cZ/N+2BR08TAHnofVWRcPc+Sdoy7227wvmoIuLnLguajOurjIkXeO7WrVL7p4Crq42IHn4jrrAvlNF/P5HmJ+qIeYT/cQ8y4PMZ/rIWYf38FmqBsdIpxP3oN7bd67p6CL3Q48u+usC+T3z4D5fA8xn+sh5l0eYr7IQ8zNoGf+BsGhczXxlC/pFHigs0BgDATGTgrz/MaeKDwa5DcPweWzh/Lam7s+xspH1hfc71XNu7zXPnefgkz2ufvzf251XO/S6FlYF7DfoavLonAh53K6lJ5boHwQX6TwQXPHecEHfcAeALudx7wkCjN2mW63SNdNPJdQuv0iHe5R1lZ3nfSea9StqdRruw4C7/Ii0sW2KMzfO9kj4jTt5R6BG/e7CSPsJduHPUp44r7hiPz4OxrbmlRn3RTHc/WdSngOFngOduhCK++FIu+Fdcx7nsh7Xh3zni3ynl3HvA8XeR9ex7wXi7wX1zHvlSLvlXXMe7nIe3kd814j8l5Tx7zXibzX1THvVSLvVSLvLgrzd7dy/3ZOeU+1jUceWBMlv+ek1I/YO93v9uwmPBrttFLb6tybtU3IxOsgee2S1lq93QKP7JdNF/PpHmLe5SHmeuyBa9WNiXNTvmA+30PMPtbnCzzE7KOefazPF3qI+WEeYr7IQ8w+1mcf28GWL1ofzK02pT6YfawbF7cw1wVzy+evD2Yf30EffaRm0LMdB8WY6OfmauIZW0vBeKCzQGAMBEZeg7GbdIZ52dEg37UUyIvn6C/JXR/Ja10uUc17bC2FwpqH6rjypfk/tzqufFn0LKyluNShq8ujcCHncuJ1DgXKB/FFCn+a1lKAD/qAPQB2O/+BdQ6MXaY7T6TrJp59lO5SkQ73KGuruw/Re65Rt6ZSr+1aCrzLWEvRml/PP+/W/PrYs1vz6/p5t+bXx57drPPrM+m/vSJO0wfdKzDi/jzCCB9Udw3pGB7kVYieLfPuFrpqRp11Uxyvm5irhCeu/axH3nHtZz3yjms/65F3XPtZj7zj2s965B3XftYj77j2sx55x7Wf9cg7rv2sR95x7Wc98o5rP1s2tWVT8867ZVNbNrVeeTezTWV/fwbhyb2PVN5TPRsEeWDNL/Lm/pnCeHd1zS/6CrgK4j6k8HmER6Pvo9RfqY7N7hYyzRQy8R5FXvO7W0HOQhA//ribymE6mE/3EHOz7olOwtyse88fbHXjoR5ibtazFB5s9fkCDzH7qGcf6/OFHmJ+mIeYm/VskAdbffaxHWz5ovXB3GpT6oPZx7pxcQtzXTC3fP76YPbxHfTRR2qW89MwJvrGLk08+Z+fhvWDo0G+a36RF68l3Ze7PpLXZO9TzXtsza/C2tzquPJl+T+3Oq6MNa5Y83uZQ1dXROFCzuXE63ELlA/iixR+Xdc4L/igD9gDYLesWI/L2GW63SJdN/Hsp3SXiXS457PnXkHvuUbdmkq9dp2fZt9zvHNFikPaDopje4o4PPsAioNuDqI46OIQioOeDqM4lOcRFAedt1Hcw6NwO8VdGYVnUdxVUfhIirs6Ci+guGui8ByKuzYKH0pxj4jCvH75uih8IMVdH4V5rfENUXg+xd0YhXld8COjcBfFPSoK8xreR0dhLsubojCvt31MFF5CcY+Nwrw29uYovIzibonCvI71cVF4KcU9PgqvoLgnROHlFPfEKBxS3JOicA/FPTkKr6W4W6Mwry19ShTupbinRmFeB/q0KLya4m6Lwqso7ulReBPFPSMKb6G426NwH8U9MwofRXHPisIlint2FD6a4u6IwgMUd2cU3khxz4nCFYp7bhQepbjnReENFPf8KLyd4l4QhY+luBdG4Z0U96IofDzFvTgKn0BxL4nCJ1LcS6PwSRT3sih8MsW9PAofR3GviMKnUNwro3A/xb0qCq+nuFdH4UGKuysKlynuNVH4NIp7bRQ+k+LujsLDFHdPFD6b4u6NwqdS3Oui8DkU9/ooPEJxsHGXUBx8RfbNYKt5jxbauX0UB/u4n+JgHy+lONj5yygOtuZyioN9vILiMI//cIrDHP+VFAd7dhXFoS25muJgC6+hONjMaykO9vsRFId26DqKgw2+nuJgq2+gOLRXN1Ic7PwjKQ5t2KMoDm3EoykO7dpNFAe7/BiKQ1v3WIpDe3UzxcHO30JxsN+PozjY+cdTXBiFn0BxsLdPpDjY0SdRHOz8kykObcStFAc7/xSKQ3vwVIpDW/I0ioMNvo3iYKufTnGw/c+guLVR+HaKg+1/JsXBNjyL4mAfn01xsLd3UBzs950UBxvyHIqDXX4uxaGNeB7FwXY9n+Jg+19AcbBdL6Q4fI/7RRQHm/RiioNdeQnFoV17KcXhfOGXURzaupdTHNq1V1Ac1pK8kuLQrr2K4kaj8KspblsUvovi0Da9huJwNuBrKQ7t1d0UtyMK30NxaMPupTi0L6+jOLRrsMnW9ll7he+hsi0/XcR1UN5hkG8fSH6HFPfIz2KU397sojB/n3dExFncCt+7r+IeEbhxz9+ShwwjFIcw6lWB0shn8XeK8Y3t9pj8isRzfNTouL6r3RGofM+++o1ytP3oSwPbQwgjeE5OwMjPAs7Thbysy3NINoXyrrhkO0PgYdnOSNH/OQoYNes6l5999i6H7OA5p3tcT+dFYbZdZ5EeL3P8j6sg7kMKc3mfpyCzfa7C91Cr403nk/wh5cMy8Tcw85KJ88Z4k/zeZ5HCl3aP88rvcKIMgd2+i5iTSPp+5w6RzvX9zkIw+Ru2uEdZW91dSPUM9cjqTuv71OfGyHIGyQIe2CWLR+sb9vKb1fIb9txGtQsepC0Sz7UJNsv+BV8AcnN7y36Cgm1LbG/PIYyIO50wSpltfRmMOnRd9D/3eU8XcS3/Z+rlkaf/cyrxoF4n+T/geWpK+6vwTlb9H4yRSP/nLMIInmek+D9n030YJPs/Z5NsCvav4pINZXO6Q7Y7U/R/tgJGTdvP5WefvcshO3heQO3Si8i/QbmdQXq81/E/riT/h8tbw97a556b/3MnnN2OenSuQyb+nn1eMnHe8H+kX1Gk8D3k/0h/BGUI7PZdhP/L2GW6IZGum3geQumkr4F77oO8jOrZveT/aLVTD4mR5VSSBTzs/5yhhEf6P8DBfWbp/4DH5f+8NcX/gS8Aubm9ZT9BwbYltrdnE0bEsY8mZbb15efRIHcX/c9zA8MiTtOPQF54ttQzt3PDFIcw+z/SJ+ogucOgPn7bLsIIGVx+G/s/u2KetYN4UK/bY/IrEs/HU9pfhXey6v9gLgm2HdjOIIzg+XSK/3Mm3YfBeHmzfqGDM0m24fxlq7hkQ9kMO2T7Qor+z1TAqCR7mese/J8Rh+zg+Qq1S18l/wbldirp8ceO/3El+T9c3hr2VmmMtOQaR3yIQyYeC8lLJs4b/o/0K3gM80fk/0h/BGUI7DyPwNhlul0iHY+Z8LiF9DVwz32Qb1I9+zH5P1rt1FkxsuwgWcDD+ydGlPDI9kf2tS0Pyqld8HC/BTy/TvF/4AtAbvYt2E9QsG1llgXPxv2ZhBFx7KNJmW19eSn5P2iHef7LNa6lZVvj/Dr2deDPuMZRthHuIRFncZ+mhFuO2eD+NMLo8uUQ5m94nhbzLPZ/UH7tMfkViactWmAR1/4qjBOMsB8H2w5s/L6Bpz0BIz8LOEeEvKxLXvOtYG+GXLJJe8OyzU3Rv4JPPlQPWwv/Z7NDdvAsmDeup4VR2L6bKLetpMdex/+4kvwfLm8Ne6s0RlpyjSOe5ZCJx0Lykonzhv8j/Qoew+yZN84r/RGUIbDzPAJjl+lOE+l4zITHLaSvgXvugxxC9Qz1qB59ACkL+z9yTtzi2ayER7Y/wLGZ9Ihykv4PzxmAZ02CzWLfgsdJpO+gOd6wNZgoL+53EUbE8VyWlNnWl9PI/0E7POiQa5Dk0irHOLmQH3//fCvFbSW8+B0Rcc3st/EZscMxz2L/B+XXHsT3wcEzmtL+5t5Hir59i/WCsO3S/ysSz7Ep/k+Z7sNgct1mXZZJNoXyHnHJ5hr/Ac+JKfovK2DUrOtcfvbZ2xyyP+CPU7u0i/wbvAvHkB4vdvyPK8n/4fLW6N8o9RFKLj/6dIdM7AvkJRPnDf/HtR4E4YvI/5FtP8qQx7Vd8y8y3WaRjn0GnuuPG1tHWVvdnU317GLyf7ZSutEoXKrtco4/QBb2f8DD81+5f2c8wrNN4AEO7lfL+S/wIC3Pf12W4v/AF3CtN2E/QcG2Jba3ZcIo15Z0OmS29eVb0cYPXqPC+2+2iThN/0eWI+7Z/zlGyMA+EfttrvJoVv8H7UWS/8NzZNhPkOT/gOdxKe1vf/46GU7yf/oJI3ieNE3/R7a5cf7Ptvxlq7hkQ9lsc8h2W/39n4qS7GWue/B/jnHIDp5nUbt0B/k3KLcdpMdXOv7H1fJ/Guv/vCLB/5FzClP1f4ZFulr8n+dRPXsl+T9a7dSpMbJsJVlc/o/WeqRjBB7g4D6z9H/Ag7Ts/9yb4v/AF+CxFaRlP6EZ/B/20aTMtr5cQf4P7Bbvy94g4jpIljBnuZAXno175GExbozC+M+VbqvQB9sOWf5IWySe96a0WQptS9VnwH7AmUJ+blvA8/4Un2E73YfBuB+IZ3YR9u26sg3yO5rkM4DnIyn6V+hHDWr6DMeSjPbZGx2yg+cTZMs/RT4Byq2f9Pg1x/+4knyGY0iXOxVkts89Lv/nVn2G40n+kPJhmU4gHeQlE+cNnwH5IL5I4a+SzwA+6ANlCOzc92TsMt0Gka6beLitO06kwz3K2uruc1TPvkY+w3ZKNxqFS7VdVd3tiJGFfQbwIF+LZ6MSnlGBBzg2kh5lP3OrwMe+/n+m+AxoP/mMEtneao4R9QcT5cX9MYQRcXxmipTZ1pe7owM0eO6FzyepiDhNXwh54dm4R3489lDRxTPMvgjs00aBp0g8v01pw6VfgzZ8I8kGmTaQbKP5y1bh8Skp2yjJBp4/1d+Hqmj6pttJRvvszQ7ZwfNXsq3/62ijed3HnPmT/8eV1IZvI10eqyCzUn+t2oZzOxQGk8dl2X/Iuw3fSc/lthLxRQrPnj/OK9tU2cfksVnGLtNtEOm6g8k+jKu9xD3K2uruH1TPUI80be0xMbJsJFnAw7ZWaxxC2n7gSFr3sVHg43UfB0Q6jGvD0Z5xGy7bP81+RNz6iG2EUfZ9Ox0y2/pyObXhGCsoUZrNIs6yb1GSa7OQC/fIz2LEWT5ctjId5BwmHjxDlj/SFomnN6H8rfxH5S5/eYjLdaaQ/yjCCJ4VCRhddaQi5O0iebeqyjbmDx0tZNvokA0861L0f7QCRiXZJ/Qx4DNscsgOnvL8cT31kU8g583s/9sd/+NK8hmOJl1q9POU+i8lHkNBPTrGIRP3gfOSifOGzyDbYh6/2UY+g2zDUYbAznO3jF2mk+tluK+8jdLJ9hn3PK44RPVsO/kMWmsltsXIwj4DeGCXLJ5NSni2CDzAsYn0KOcKNgp8PFdwYorPgPbTtVaC21YF25Y4V3A0YXStlZAyV31M8hmGhAxxcmmVY5xcyI/3nPA+KJkOcg4SD54hy5/X+IPnoSltVv6+75jPwOUSBpPne9iveViKzyDfiYqQl/2vLaqyjfkMRwnZXD4beC6pu8825jNor4GGzzDskB08l5Mtfzj5BHJdjf3/MY7/cSX5DEeRLkcVZFbqL5V4zAb1aJtDJu5z5yUT5w2fQbbFPF50E/kMsg2X+/jsuwjbzdhlOrknkPvmR1O6bSId7kejX6u7a6iePYZ8Bq3+4NExsrDPAB7YJc39vnJNGnDwurW4NoPXpIHnSVP0GXgPA9Jy26rVb9kUTJRX9lu6g8ntQadD5uocZnQAt623A0IG3qfKcmmvXcezhwReixF+AJetTAc5+4kHz5Dlz+vlwfPclDYr/72LYz4DykyeSebya16Y4jPIOlIR8rL/tUlVtlI/jwVJn4FlA8/L6+6zlfqVZJ/Qp4HPMOiQHTx3kS1/LfkEKLcB0uM7Hf/jSvIZ+MwdjX6lUn+pxD4A6tHRDpm4z52XTPws+AyyLebxoneQzyDbcJQhsNt3Ebabsct0QyId982PonSyfcY9j2O+jurZO8ln0OoPHhUjC/sM4OEzugaU8AwKPMAxQHqMazOQltuM90/RZ+DzLpCW21atfkvc2V2bCaNsDzodMtv6civ5DBuEDLxuguXSKse4dRPIz2LENw/6VfGMteGspzCYXK+KxPPZlDZc1lG04by+ADLxPhKtc9WHY2Rz+VBfSmnDNc7+0uxjcFttn93nkB08XyXb+nVqo+UaT/v/Tx3/40pqw9lGatgMpf5jyTV+tMUhE+8nyksmzhttOPLhOR+Ef0JtuJy3Qxm65kAZu0w3KNLxnDCPccsxP9yzH/1tqmc/pTZcy9ZuipGF23DwsK3tU8IjbT9w9JEeUU6yDed9Qg+s95piG877+GT7p9k/jlt/P0wY5X6ATofM1f3e1IZvFDLw94RYroqSXHL/HO6RH/sZvG6Q11Dgt0/EKe0hrOLuE7iln8Hr//ooDmE+V6I/5lnriQdl2h6TX5F4igvGfuPa39xtRHSuhPR/pD/G/k9HAkaX/1MW8rIudfc1u307lE3ZIVt3iv4HFTDqyD5W17n87LM3OGQHz8IF43o6KApzv2Aj6XGZ439cSf6P9r5ppfGgkmucz7UXnNdR5SUT5w3/B/kgnscYly4Y541by8VzkPCFk9aA9Yt03cTDY7ppe9at7g6jeoZ6pNlODcXIsp5kAQ/sksWzQQmPbH+Ag/feoZzaBQ/SFolnXYLNYv+H9xJI30HHto3JuzGYKK8cm+gOJq+l7HTIbOvLoeT/rIried1oScRp2lbkhWfjnn0dqeeuYKK/ht+KiNP0v+P2drCvI325RvqRSrqosN5xJbVdbBsU+mp97AdPBQ/vb9LwlZXkLLGtuT/It42Wtr5P6IptvfLY2wT/C8/GfdI8aAtz/pgtHmnn+Hu5lSbBiDjdMe9ku8tliPao5NBZZ5PpjM83UWjzS+yT8Fk9e8mHLeWfb18hmHw20HpRLnw2UOcB47yXRtjixl3WizhNvwN5BYHbp2XfaD3FITyXMCq0d31JvjmvSZHjOS7fHDzXpfjmcx06QJh9Qped0vLX4965QcIImdkH0fIPUScKwUQ/m3Wh7afk+Nw+bj9nxuiYz/t8fMp4W1pbzOOZfG60Rv1RGtfp47EF6Az4eS0geJ6aorORGJ1xHZfruNqCyefthlG8HOe4P4qXz7D8mvOoCutA+ng8SJ67x+NP4LkzRfdybKlP6I73TvL6oPX5y5ZoX3h8CO0jt6HN1HZ2B5N9ApatLUq3Orrv19VriX2WYuBuS9lnucsxZjkjmFge3Ab3iWcjzWqK7xPPruO6xL2McaaQY7MD4z0pGBXq1V7NdUtsF+yzXXtNwPNGGg9+M80roL6sIj1+wPE/roK4DynMYzca67uV1mRW3yO513erQ6ZR0kFeMnHeBfFsxPM+4/cvmIwB+kAZ8vcFsDbChR3p1ot03cSzhdLF7eHnNStvp3r2AeqzaY0Pb4mRpUSygKdCssjxWbl+gcfU2wO3T8zzAx9NsS2r8pffaf+AbRVhBM8nG2T/FGR32r+yQ3bwfI7q5efJvkk/xP7/Hcf/uFr2r7H279sJ9k/asanav5JIV4v9+zLVs++Q/dM6C25LjCwVkgU8SWPL4Gf7h/epXfC4voPyoxTbouD/Ou0fsK0njOD5WYPsn1afKs7/Y9nB82uql78l+4YyLZEe/+74H1fL/jXW/v1fgv2Tdmyq9q8i0tVi//5A9ezvDfD/pI1i+8frarB2gcd/5fnMSnMNies12G+V5y+yTUY69MXZbkOmdsHDYwXgmR3NY7hsYqcjrS3XH7aPhV1rGHh+nceOG7nOFDp1jf/zPI1rzq2R4/+u/ToI8/rYwZhn8fpY+d21pLHwwxPqhMo8ZLQ+Vu6hkfuZeQ/N4gSM/CzgdI09Qwe8t0LBB+hzyeaazwLPshT9a4z9a46ryu+ulRyyg2c1zauujcK8/4ft0CbH/7iS/BQub409nUpjfiVu7+R5eywT7+PJSybOG34K8uE93A+0tQeM88r9rShDPtcPbTNjl+nkt7t4XyyfkxR3JiOvLd5I9Qz1SLOdGomRhec/wMPzvVr+h2x/XPMasv8n56O5/7c9wWbxuiDeH+Rag6i1PyhuHQ7vD5J7KDodMvNaFFtve6P4VZRmg4jT7P/H7XvifbBy7TPvGWL/R66ZbbZ1vY30x5V0UZnuGCOvv1Jor/v5vZwKHu4fa6xNUZKzxLY+7/Wx0raWha7qvQYxro/E5zm0MLcwuzDz3hZelwG+epxjMRWMrjEHrf5MXFvBZYg2dINDZ51NprONhEfBTynxOBLvb7yF/G6FfWD9BZFfSDj422ngOWXhOO8TI2zsh7CvtFrEafpKyCsI3ON57M+tpjiEeU2vQhvdnzQuyXPuqG9J45LgeWZKf2KuQwdyX36cnWrkWCRkZr9Jy6flvY5h4D6PQdu3yvG5/dx+zozRMa8Lf0nKGGFaW8xjx/XYB6Yw1tzP42/y3AHX2O+rU3Q2FKMzruNy/0gb5cXtHa/d5b1qbY5nWH4lHVWUxh36edxnKuup35iiezmGVBa6c62n1hwvVhg7dZ6HmbQO+h0pOtsco7O0ddCr85ct0SYjP/Yd2e9oJn+jO5jsR7FsWAe9Lrqv6Oq1xH5eMXD7HxPW6tHYtFwHLeeF2beR66DXUXxZPLt+66DLE9aBy+/vbnZg/GQKRoUzYkpKcyLOdTDrHbI/sA6Qxv0/T/NHqC+9pMfvOP7HVRD3IYV5jO7Bsg6GZRolHeQlE+ddCKawDvCAyRigD5ThdNfBrBbpaloHSPXsO9TPrdc6QGmfeR2Ma+8K0slvNVsevE/tgbsfUSSeH6XYlt7c5XfbP2DrJYzg+VmD7F/+sievA2TZH1gHSPXyt2TfpB9SXb/l+B9Xy/41eB1ggv2Tdmyq9s/1XWvwTHsdINWzv5P901oLuyVGFtc+kKTxeNc+uLh9IDwP/oD/GY0hxtmW/P1ft/0DNt6r90AdTsGoZf+0+lRx/h/L/sC3tWiMd14Udp1pZf9f7PgfV8v+Ndb+LVo4GQP0Ie1YI/aBLKR6hnrUiH0gPN8zlX0gcu7R5f/JsTn2/5an2Jb853nc9g/YeJ4HPKsbZP+0zjqM8/9YdvBsoHpZIvsmv29k/z/a8T+ulv1rrP3bmmD/su4DGRDparF//VTPjib7Vy//z3WGlWsfyKoozGv/kaYe6/fivuvF58bLPW1sk5EOY5FJZyitE8/hubKTEmxipyOtLdfbaB9I65z0bLjrcU76auKZzjnpF6S0k81wTvrFCRj5WcDpmq+szznpY3NbUjbXGgjw7E/Rv8Z8sea80nTOSX84tR9XkR/iOif9Zsf/uJL8lNY56dOXifOGn5J0TvpjyU9pxnPSH0H17GbyU+p9TjrP/7rOSa/X/gG5To/bKLlui/sX4Lk1wWbFnZPuWqOlte8yrr3lc9JdZ0NKmXn9oq23a6P49Y4060kurTmAuDl75GcxronCrjWC7P/IvSGN3r8CGXhftlZfulfgceWtoIvKdOdYeM2uhq/C++Gngof7xxrrGZXkLLGtz3sfiLQ1cj9/vdetx/WRkF8LcwtzHGY+M4PXpYFvQ5NgdI05aPVn4toKLkO0oasdOqvHmabT0Vkv4VHwU0o8jsTrrD68UDXffvaP0F+SOIrE89wDx3k/FmHrojTsK/WKOE1fKa6+sa/k8vsQ5n0gCm30hP02EmPSvnIpB8/VfCGlPzHXoQM5/xFnpxo5FilthaZPy+N/YTC5L1MP3yrH5/Zz+zkzRsfcJ/12yhhhWlvMY8f12O9cr70zwO8a+/1his4GYnTGdVzuOWyjvLi94/0evCe7zfEMy6+ko0qz7MH5dYru5RiS/Iataw+Okmx9zbJ35o8pOhuJ0Vnatwjkd9zDKF62WfJbBOzH1GPcR9p25Mc+KPsvzeS3dFMcy4NwW5RuFTARZg0/tRBM3NvBmHnNM3hmHTiOGXUH+0lWi3TsI+HZSLOK4jeKZ8fNAeU/v9A/YT+NnKcacWDsTMGYf73qLynNrVTrK9sX++w1DtnBM5/6CgdEYX6/1pIeexz/4yqI+5DCPNansYfGPndL/s+t1iNeExJSPizTVtJBXjJx3oVg4roVxBcpHNI7LNe3oAyB3bYVmN9i7DJdr0jXTTw8hybXruCe90EeTPUM9cjqbh2lG43CpdquCXN8Uhaep3pgTRnJEjefxPvp8D4lzSeBZ1WKbVmbu/xu+wdsawnjA98GbpD9y192t/1b55AdPGWql31k31z76bY7/sfVsn+NtX/bEuyftGNTtX+rRbpa7N8Q1bPtZP/WULrRKFyq7XLaP9d+OvDwuP46kc61nxj6lPvp2OcEzwkptiX/cWO3/VsnZJ1wbk6D7J/WmHmc/+c6q/cMqpdnkX1z7afb6/gfV8v+Ndb+7Umwf9KOTdX+bRDparF/51I920v2T2tcYVOMLOtIFvAk7aeTZ0C4/L914jns/12RYlvy31Pmtn+u/XTgubpB9k9rP520f70O2cFzPdXLG8m+oUx5vdStjv9xtexfY+3fkxPsn7RjU7V/60S6WuzfTVTPbm2A/ydtFNs/3mOCtX6usVZeB9io9Ws81grdsU1GOoxFst2GTO2CB2l5TPTOBJvY6Uhb3SdJ+0mkv91s32fhOVzX3DOvEXCt92jk3LPrrG2EeT9JJeZZ64hHrg1Omoe9q959mWg/CebF5Lwn+/PguScBIz8LOF3znnKPidLcSr9LNpTNRodsb0rRv8a8s+a8EpeffbZrHQl43k7txzvJD0G5cT/tPsf/uJL8FC5vre++D+X/3BL7fHL/NMvE39jISybOG36K3KfB/uZHHHNt0AfKENh5Hpyxy3Sub4bJb3EUgvi9mryn671Uz+4jP6Ve3/GALNxPAw+vNdLqN8r2R66zszwoJ9n/431g4PlMgs3iNalJezWUbFvivot+wijngDsdMvM6SFtvV0TxvG60R8R1BOP2J2+5kBee3UNhYFwehXsorofw4neNiNOcu5B+LO7XEsYwCq8hPFr9iFDgceWtoIsK6x1XUtu1lvAo7NHv66Q8poKH+0oac5xKck445yPv/SSyTyL3nPE3I5X3K1XrtjyDAPe8d7CFWR+zxSPtHH+7ak2TYJRjI0rvYKLd5TJEe9Tj0Fk91sVNR2ch4Qnzx1PiMRk83/okwUGq+faxr4G+h8RRJJ53HTTOW4zCXcHE76/hNxRxmn4H8sKzcc9+h8uHQpj3Zii0d1U9r43ByOM58qwvKQef9TUv0n/a3gzWAcLsE7rslNb4aNw7t4EwhlGYfRAt/xB1AnWox6ELbT8lx+f2cfs5M0bHPHd2ZEId4mcBp2yLeV87eHndNv67P5jYD8/DN9sfXbx/ZjrP3Z9y5bQ3uSwjAtJDG4V5rCvtfxdvmdLIfvn94n5W4D6n7oHxuIR6odUmK43L9/G4CN4JOW7Me942pLwTcowF7wTPQ8izdZRkqyiNbVV1Jvd4AT+vwX9gf1CKzvpidOYatwdvG/Hx/jjsRwjof+z/YD781mOcRrYfyI/9XPaRQgoHQWN9o26KY3kQhr4xhsj9hzB/zNW+Nu/FYMy8Rg88Jxw0jhl1B/s/ekQ69sPwbKTppfi14tn1W/9XGmSMM4UcfQ6Mp6RgVKhXg5rr/9i+2Gcvd8gOnjOoP3JWFOb3awXpca/jf1wFcc//89icxvcilearqu+R3Pc46JCJ53/ykonzLkSEfPjcYoT30DsMPugDZch7BTG+z9hlulCk6yYePqdTnlEov5VWXf9H9Wwv9cm5rzwahUu1XVXd9cfI0kOygCdpHQn4eXwN71N74O7zFInnihTbsiJ/+Z32D9hWEEbwXN0g+6cgu9P+rXLIDp7rqV7eSPZN+iHVdVuO/3G17F9j7d+TE+xfGIWna/96RLpa7N9NVM9uJfu3nNKNRuFSbZfT/kkbxfaP97+tEunk2AT7w+2CR/qc9ro9xbYojOE47d8qISvbvzsaZP+0xgjj/D+WHTzPp3r5QrJvKNMe0uM9jv9xtexfY+3f3Qn2T9qxqdq/NSJdLfbvpVTP7tGdk3HaP2mj2P65vgvK4/t4f3jdSo8S7uUCt1yj0h1MbDPsxTYZ8XItIfu28twqpOV9K+9IsImdjrS2XN8zcyzMc0WsRzl3orU2gu0/no175MfzJK75HZ6Hc82pNnJ+R37LoIvCvP55Q8yzVhGP/DZY0lzHR+s9ph2tf+ZvuoTB5HMcuT37ZMo4aonuw2C8vFm/0AGf06LgA/S5ZEPZrHXI9v9S9K8xjq05rirPkQkdsoPny9R+fIX8EJQb+yk/dPyPK8lP0f7Oh9KYX4nbO9Qj15nkvBY4L5k4b/gp8iw0XsP/A/JT5NpflCF/JwRtc9IeTXm2nWvNcCGIPzsdZW1193WqZz8kP0WrnSrHyMJ+Cnh4Pj9UwiPbH7mWxfKgnOQ+Kv4uD3h+mbLGAr4A75OSvoOSbUtcJ8zf3UQc74mTMvNaI95btZTSLBNxmv1/5IVn4x75sY+2jOKWEV78rhBxFvdKJdwrBG7crySMkGEFxSHM/s/KmGeFxINybI/Jj+fJgoPHfuLa39zHsiP/R579C2w83vLA3uYEjPws4Fwm5HWt3e8gvjAv2aLvHkrZwuh+mUO2OSn61/g2rY7sY3Vdjpf1OGQHz7yDx/W0IArb9xHl1st6dPyPK8n/4fLW8PmU2tESt1tyHyHLxOOcecnEecP/QT7cHiK85OBxXtk/k+sDeG1Y0hllK0U63lfEc1vybB95LpbV3UFUz1CPNNupNTGyhCSLnLvSHH+R7Q9w9JAeUU5yjSnPL4FnVYLNsrLBF4DcPLbCfoLWWRm9wUR55VkZvN9+OWEMhcy2vlxI4z9LovgeSrNUxGnaVuSFZ+OefR2p565gor+G3+UiTnPuMm78j30d6cs10o9U0kWF9Y4rqe1i25C7H1Yq7Wc/eCp4VhEeDV+Z5cxzn5aSrdmvtQZdyVeZcIYyfArkwz4Ft/15ycR5w6eQe4/4rJJTyaeQ/XfUWV6r6BoHjhsv5/NNdh48/gxpl3jfMtsGrX0HcfuWeX4bcSsJj1Y7GmcnuR1F+7HUobPOJtPZMsKj0EaX2IfA86s+BPmcS/PPd39B5BcSDuRXJJ7bF43z7o6wxfkJzTZOEkbhpHESrfYyafyF7Y48S8E1/gKeK1N86bkOHSDMPlwz2am48RYtfy6MnoVwKHQRZ6dcPrCWLY3zgdmWyjlwzTHxuHetlbeKja5Md3259ng6912ngke5X1bicQPOS+t9jKsHbK8U7GeFbfVU9K69rmS66954n49P46ncr8n7DBA5drlG6IrHLutx3mTcmCifN+laE5Y0vhw2AKMcy9Wcs46zB1yGYRRe6dBZ2GQ6Y79djm9Zv/9u6pMo+PPO/XpyXo7ngk6hPsnrqU8ix87Zb0Oc5phrnN/GY64rhH55PpfbcS1/fFkMRp4nwTvUHiMHrx1/1xTH911z7Nz3d40tNXJtJGRme6LtX6BP4vIvNMb4NHUs5yOljnlO8CMpc/ZyTA/1h9etQlfcZmr1IePKqx7zEXFtD+etYN+mPR/B42cKdWyA26qp4NE+s0rTF63XeXTLhK7qfU5anM+SdLZbC3MLs6+YeRyP1x2Cb3mTYJT7LXzpWzWDzrhvhf4Lrzf6PfWtFNYRDBRIT3KPBa/XAc886lv9OaVvtUzE1bPfgnvXPIKrr8F9KwVfuqrnNTEYkR/XnfYYOXheOzhk7Cetb8U6QJjnK1z2ROvczrh3g/dqSbv8YPXVp7J26J81b4X2Y9p9FO0+Ab97U8GzXhlPUtkojzWXlNrjqt2dzv7IIxJsKj8LOOX647j9kVr7c5YRtpDu65l3kJC31jmO5fyfW60rvNctJPz87QrwrEipK/L7SvKsEP5WU4V0pvXtqLi6Us+8g4S8Fcq0orSntFpX5J5Seb4k7+ssp9SVuPMY+Bte0BV/s0fruydxdQX5tQWT94eGUXy/0APOzpT4wzrJEMTIoFQ3+ngvcY7PrdY5/hZRSPj526rgOTqlzslzSeR3kPkclEHSmca3r5LqHPJrCybvnS5E8fJMFdQ5ib9QJxmCGBmU6kb1O2wK3w6r1jn57TDg53N2wHNKSp2LO0MHz+wiXYG33vP3cfWQx5jkvGhcP3pYCWNcP9qlM+BvCybXR7w/cpwR78+gkAnvT2vu7EE7d1apZe5Maw+L1twZ3pe8587ktwRdNgQ8w6Q/BRueaC/4DDXfME9nfqSRGBFXj3O98pwfaQadueZHMNZi/ZFbDhnHq+DLVyxePqcvJBzczwPPl48c531ihK1LYIM8G0Wc5nq/uO9d87gV+pqu713z/IhGm1MIJq99Rd6us/XbY+TgtWfPTPBFWTaeC5HzI0r7fxK/ZbmKMLrOBNTyf/gsqJDulfcBlZR0XK1Tcm7TdRYveF6c0neR+7XkN4h4XSB42ygvLre2YPI5NfC55TMsv1Y9VJpXrnA/KmleGTyvSdG97FdvFLrjOWju72wUukR/B+8V/ofuwcdzskpzwonvHPdztfMOEvJWGL937jF1zcmA523TrBtoa7ltg0zLEtLJs+W43WwXPLzWGTzvScCp2bbH1aENdcw7SMhbqw7x2SohlQnXIfD8W0odkn4z6hCvFYFMKxLSgT+pDi0Tz+E69LEprung8zy0zlqJq1f1zDtIyFtrLGY655jwWIxCf6lvumMxQ4RHa+5VQU7VsZgRoatlQlfdxMPjGiMK+nONs+Ae+bUw1wezxSPXBHYS34omwYi4jYRHa2wmzu5yGYZRuM+hs7DJdFYmjBij4TN7fkXjRwrrD5zfuZRnLxeJ53k0fvS7DONHWuOKceNHvCduquNHCmMIfa5xRdk/tzzwy9pj5OB9pH+boi/GOkgat1T2XSacmYpn4579WNl3bqQPGWdPXGdpaI3DxY2ZryKMiOPv7SrYi8R3rZW3zhh/ZzCx3bNXQdyHFO4jPBrvTWcw8Sz+NDzK/bHqeSp9jry03se4esD2Sqvvx/YzTe/c99NY5zHdvp/2nKySnCX2FfPu+20SulomdNVNPCOkv00K+isEk9c/4X4T4ZFtdifxrWoSjPJba1rvQJI94DKE/V7n0Fm5yXS2kTCiL8BjmZVDx/FqnQcvvy00IPTHY5JnU59kMMLGfiT3seS6ZU3fMm7+lM9zlGsveA8ct+Na/viKGIw8D4F3qD1GjiLxbIv0H9cn6XPoQPqz3F9ne6L1/sb114cJI2Rme6LlX/B6gpDuWRfaY5x5y4S2a2aMjovEc2pCHeJnASfqD57ZRbriNlNrb29cea2pY95BQt5a57tP5yw99su1fNHpzItoj+9q+qJos/P2RTcLXa0Quuomnk2kv80K+kvyWTYTHtkWsV+1pkkwIo5tUSPX3ctx0DhftBl0xv6y3Ndh25JrmswXPYR80evJF5Vj6rymtR6+aFy9YD/MNWaOcCN8Ubk/xOWLSjnYF31cgh/h8r3jbIfWPFHcezBCGF3r2bV8CT6LKAwmz0/UY3wlb5nQTs2M0XGReJ6R4nfKsRppW7mfwO2j1lxoXHkN1THvoEnzVmgL+lz1Se5f4Pr0wmnWJznWwu//poR0co0A23v5XYZNhBM8L59in53rtMI8R2KdRn5tweT+XiGYuN8b/2PN7JB4RqHBMrAPhjLnOZV6+ANx31LmeU/E8boOhb3BfS4fa5PQj44uynunO7fG/ViN+qM1R8Y2sSO35w5UXOMxrjl08DAGrTY/br58xJF3froYHHD1oV262OzAo9XXitPFZkfeOeqimveWKehiiwPPljrrYosj7xx10W/zPmoKujjKgeeoOusC+U0X80gTYO4Q4XzyHqrauK1T0MVWB56tddbFVkfe+emiUh0POXoKujjagefoOusC+U0X85YmwNwhwvnkPThSoGcl6WLUgWe0zrpAHtPFvMVDzFubAHNHTLhU0zW4z+a9bQq62ObAs63OutjmyDtHXVT3hW2fgi62O/Bsr7MutjvyzrFdrfpFx0xBF8c48BxTZ10gv+li3uoh5qM8xDziIebNHmLe4iFmH9/BZqgbHSKcT96De23ex05BF8c68BxbZ10gv38GzFs9xLzFQ8ybPcS83UPMzaBnXhty7GGaeMqXTHcNHDB0UpjnN3ZE4dEg3706yGsH5bUzd32MlY+sL7jfqZp3ea997vEKMtnnnpD/c6vjeidGz8Lc9gkOXZ0UhQs5l9OJ9NwC5YP4IoW3HTbOCz7oA/YA2O0c+nFRmLHLdMeKdN3EcxylO0Gkwz3K2upuiN5zjbo1lXpt5/LxLi8iXfD+EnvZd3+HiNO0lzsEbtwfSxhhL9k+7FDCEzdXX8+8gybMu4vCvDdeYW66OiaGegvbg7x5XR94zorer7h1NTuFbJscssn3xSWv61ngWUY8wNgueHYSdvCcn4C9kfWc19Xwu98WTC4LrKuR7XgYtN7VRuWt9V6i7cN7iTrN7yV4rkh5L48TcuC9dL2DxyWkA3/SO7hTPIffwWsTcPK5GUjbQXFhUJ86jfzaSBauX23Eg//xXko7FjZYBj5DA2XeKfAEgW4/AHnh2VJ3XO683k1hP+5+1hnWux0n9KPlO3YG4/rGVRD3/D/7/hr1R6nMS2wT8OxQyMTnpvC6NAVbWnb5EtKWThfziIeYN3uIeYuHmH2sG0d5iHmrh5h9rM9He4jZRz37WJ9HPcS8zUPM2z3E7GN99rEdbPmi9cHcalPqg9nHunFMC3NdMLd8/vpg9vEd9NFHagY98zqZrsM18Yytk2E80FkgMAYCI6+v2Uk6Oz4Kjwb5rpNBXsdTXgprPxLXMZ2gmvfYOpmTFGSyzz05/+dWx5VPiZ6FObGTHbo6NQoXci6nU+i5BcoH8UUKzzl8nBd80EcYhYHdzr1hfQ1jl+lWiHTdxMNreE4W6XCPsra6C+g916hbU6nXdg4Q7zKvk8F8TCf9Hi/iNO3l8QI37lcQRthLtg8aa84KQfwcH/LrJr0c16Q666Y4lgfhtijd4uh+k65eq7aE56cZM5/TAp4eep9RZ2cEE8uDz4lZIZ6NNIspfoV4dty6lJ25y9834f2cKeTY6cC4PAVj/vWqb6+O7GP19QSS0T671yE7eNYcPq6ndVGY368lpMfNjv9xTcXPeTC1ySxTM7TJmxLaZJThdNvk40W6WtrkEtWzzdQ+H0fpRqNwqbZrwrpfKctGkgU8q0mW1SId+HlNEN6ndsGDtEXi2Z5iW5bkLr/b/gHbEsL4QJ+jQfYvf9nd9u84h+zgOYnq5Slk36QfYv+/wPE/rpb9a6z9Oz/B/kk7NlX7t1Gkq8X+7aJ6dgHZv15KNxqFS7VdTvsnbRTbv/Uki1wTCX62f9Bnu+BhnxM8e1Nsy/rc5Xfbv+OErGz/Lm2Q/ctf9mT/j2UHz5VUL68m+4Yy3Uh6vMXxP66W/Wus/bs5wf5JOzZV+7dapKvF/l1H9ewWsn9a4wonxshyHMkCnhLJUhLpwJ/k/x0nnsP+360ptiX/bxW77R+wub4RfluD7F/+srvt3/EO2cHzLKqXd5B9Q5muJj2+0vE/rpb9a6z9e0WC/ZN2bKr27ziRrhb79zyqZ69sgP8nbRTbvwrJIsc6wc/2D/psFzxIWySee1JsSyV3+d3273ghK9u/NzTI/uUve7L/x7KD561UL99O9g1lyvu0Puz4H1fL/jXW/n0owf5JOzZV+1cS6Wqxf++mevZhsn+rKd1oFC7Vdjntn7RRbP/6SZZekQ78bP+gz3bBg7Q8t/LJFNvSn7v8bvvXK2Rl+/fZBtm//GV327/VDtnB80Wql192zG+USI/fb81/NK39+16C/ZN2rBHzH1+levb9Bs5/9JIs4BkkWeT8B/jZ/kGf7YKH5z/A87MU2zKYu/zJ8x+DhBE8v2qQ/ctf9uT5D5YdPP9F9fIPZN9Qpjz/UThi8v+4WvavsfYvOGKcN6/5j16Rrhb7999Uz1CPrO5KlG40Cpdqu5z2T9ootn/LSZblIp1r/kP6f6vFc9j/64hkjbMt+Y9/uu0fsHEfHTxzUzBq2T+tsV9p/1zjE+BZcMS4nhaSfUOZ9pIeex3/42rZv8bav54E+yftWCPmPw6hetZL9q9e/p+0UWz/VpIscv4D/EnzH+BxzX+sTrEtK3OXP3n+YyVhBM/6Btm//GVP9v9YdvBUqF72k31DmfL8xzGO/3G17F9j7d/2BPuXdf5juUhXi/0bpnp2DNm/es1/SBvF9m8tybJWpHPNf0j/rySew/7fiSm2Jf/xT7f9Azbuo4Pn1AbZP62x37j5D5YdPGdSvTyb7BvKdDnp8RLH/7ha9q+x9m9vgv2TdqwR8x/nUT27pAH+n7RRbP82kCxy/gP8bP+gz3bBw/Mf4Hl4im3ZkLv8yfMfGwgjeK5pkP3LX/Zk/49lB88NVC8fSfYNZcrzH09x/I+rZf8aa/9uTbB/Wec/1op0tdi/x1A9ewrZv+WUbjQKl2q7nPZP2ii2f6tIFrn+eTrzH7z+GTzPTLEtq3KXP3n98yrCCJ47G2T/8pfdbf+WO2QHzwuoXr7IMb+xlvR4b2v+o2nt3z0J9k/asUbMf7yM6tm9DZz/cK1/XkOyyPkP1/pn6FOuf+b5D/C8JcW2rMld/uT5jzWEETzvaJD9y1/25PkPlh0876V6+a9k31CmPP/xKcf/uFr2r7H275MK8x95rn/+INWzT5H9W0vpRqNwqbYrcf2za/5jiGQZEulc8x/S/1sunsP+3xdSbEv+459u+wds3EcHz783yP5pjf1K++canwDP16leftMxv8Hrn3/emv9oWvv3swT7l3X9c57zH9+levbzBvh/0kax/TuWZJHzH+BPmv8Aj2v+43cptiX/74Elz3/w9xPB88cG2b/8ZU/2/1h28PwP1cu/kX1DmfL8x+wjJ/+Pq2X/Gmv/Oo4c581r/mNIpKvF/t1P9Qz1qJ7zH9JGsf3bQXE9URj8/B1D/Kfpt+4QuHc4cCMu6VtWOIuL7TZkahc8PG4JnoOiMnLZxE5HWluuq2eOhfkMuTWUZoWI6yB8YZCvHuPO50N+FuO6KMxn3yFcJtxDIs7iHlbCLfsfuB8mjJBhiOIQ7ot+C5RGPmuAeHC+entMfkXiWZFQJzqILwxy00mfxbgpehZsMLCNEEbwrEnAyM8CzhVCXtYln9OnVd5StgGBh2Urpehf4ZtiZU3Zufzss9c5ZAfPwJHjehoiPwTvAp9TstPxP64kP4XLe4uSLo/K/7lVP2UryR9SPizT0aSDvGTivOGnIB/EFym8g/wU8EEfKENgt+/i5ijM2GW6ZSJdN/FspnRHiXS4R1lXz6ajeraT/JT8+wBjutscI8sAyQIe2CXNszPWCTzAweeaSj8CPEjLfsSpCTbLygZfAHJze8t+goZtS2pvNxFGxPF53VJmW1+uOXQszP7PKkqzRsRp1ivkhWevETKw/7OG4hBm/2eZiOsgnYQ5414mcLt8HZcvhzD7P0Mxz2L/B21Ne0x+ReK5JKX9VWgn+7idlGO5rnbyshT/Z4Tuw2C8vFm/0AF/e0drrkrKhrJZ45Dt6vr7n2VN2bn87LPXOWQHz/XULt3oGIdh/+fWjOM0XN6blXSp4FeVuG1HPdrikIn9lLxk4rzh/yAfxBcp/GTyf8AHfaAMgd2+i2iHGLtMNyTSdRMPn9u9RaTDPcra6u4mqme31sH/2RQjC/s/4IFdarT/AxxJ/g94npni/8AX4PEmpGU/QcO2JbW3I4QRcWn+T4X8nz5Hmo0iroPShznLFfdte+RnMcKf2UhxXK+Ae42I01y7Fue3rSKMSX4bvqVdoDTyWez/yLos8+O6/JqU9ldhLG8/+3Gw7cC2jDCC594U/0f6hNJPZ10q97f6XLJJe8OyvTlF/wo+eZ+mreXys88uO2QHzzuoXXoX+Tcotz7S40cd/+NK8n+4vLV8SYV+bInHEVCPNjlk2kI6yEsmzhv+j/QrihS+j/wf6Y+gDIHdvovwfxm7TLdKpOsmnmFKJ30N3HMf5F+onn2U/B+tdmo4Rhb2f8DD4yFlJTyy/QGOMukR5ST9H+63gOezKf4PfAEeJ5G+g+Z4Q18wUV7c8zoJxK0jjFJmW19+dchYuIv+X05pyiJO07YiLzzb5etArjLFcb0C7g0iTvN92CBw4579NsiwgeIQZv9nXcyzeL+HXMss8+O1zN9PaX8V5oT38zsJ2w5svN4GPD9O8X/k+10W8rIule1NxSUbyqbskO2XKfpXGKepaNpaLj/77D6H7OD5HbVLvyf/BuU2QHrEB+f4f1xJ/g+Xt0Z/X6mPUHL50cscMrEvkJdMnDf8H+TDY8gI/4P8H9n2owx5XBtndjB2mW6dSMc+A5/tEtfX57Vyf6Z6hnqk2U6tjJFlFckCHtgli6dPCY9sf2T/wvKgnNoFD++vBU9HpMM4/we+gMu3YD9Bawx6IJgor/RruoPJfdJOh8y2vtxC/s9KIQOPa9VDrri6zmMmSfNIIeFeK+I0/R+5/hb33D5DhrUUh3CS/wMe9n/WR+H2mPyKxLM4oS53BCrfs9nP76T0f/h7NuDpTcDoer+XCXlZl2xvFMp7wCXbKoGHZVuVon+F8wQGNOs6l5999gqH7OBZv2hcTxvJv8G7sJL0uNXxP64k/4fLW2NdvpIvWfV/KiR/SPm42sy8/R/+fgT3qfl7AwgftWicV/a9UYbcH0Wbw9hlOrlmgfvsPG8T1yfmMy76qJ5tJf9Ha53qxhhZ2P8BD+ySxaN1dpxcNwsc7EfKPjN4kJb7LTun6P/wOmGkZT9B66yUuPZ2A2GUZ+B0OmSu9ssOHgt30f+rKc0KEad5/kXc+mfkxz6aa/1zSLhd819a69/j5r/Y15F1Jm7+a23Ms3hNPNqa9pj8isRzQUr7q9BO7ud2Uu5lcrWTF6f4P+vpPgzGy5v1Cx2sJ9m05v+lbLJPyrLtr7//WdaUncvPPnulQ3bwPJzapavIv5E+vf3/Zsf/uJL8Hy5vjf6+kl9V4rZdnvfKMrGfkpdMnDf8H+TD43gIP5b8H/BBHyhDYOexWMYu08mzurqJh892k2f7ym8CWt09gurZzeT/aLVTG2Jk4bEs13i01voLOR4l1+JwGyXXjPL5uuC5NcX/gS8Aubm9ZT9B61uxce3tesKIONdYDve77ib/Z5kjjfRB6unHrhB4LUb4Ci7/p5N+V4k4i1vr7NJVArf0I9lv4zUrCM+NfgvB5G+58DsDHlmXZX5cl1+a0v7mPpZX3rOX/TjYdmDj+WbwvDLF/5E+ofTJWZfc31LwAfa7ZAuje1df6u4U/WvMP9ZjjwL8n6UO2cHzBmqX3kT+jfw+h/3//Y7/cSX5P1zeWr6kQj+2xOMIqEcbHDLxd47zkonzhv/j+tYwwu8j/0f6IyhDnteH/5v0jebVIl038ayjdHFrC7gP8jaqZ+8n/0ernVoXI0tIssg5MYtnqRIe2f4AB/er5ZrRUODjdXsfneL4D4+TuOaJtMYb4uaJeL+99HU6g8ky2/pyIfk/kdjBEkrTI+KsXFpnICEvPBv3yK+LZOihuB7Ci9+lIk5zPHSpwI17nqODDEsJj9b70CvwuPJW0EWF9Y4rqe3ivREK7XXfdPdS89o9jb6jkpwltvX3B/m20dK2yrEu3g+ykvSn1deN6yNxX7eFWR+zxSPtHPeXlzYJRlf/XatvEGd3uQzRHvU4dNbZZDrrJTwKbX6Jz+TB861P8lfyYXvyz7evIPILCQfyKxLPXYvHef8eYeM2nf2OxSJO0+9AXoGQgf0OyLOY4hCeSxgV2rs+l6+KvJEf18n2GDmKxNMR/Rnnm8916ABh9glddqqR43qQmX0QLf8QdaIQTPSzWRfafkqOz+3j9nNmjI6LxHNQQh2aSlvM47Dcv9WoP0rjtn08lgWdAb9rHPXIFJ2tidEZ13HoCrxtlBe3d23B5PmE+6N4+QzLr6SjilIfvo/HUOT4sGsOf0WK7uV4zDKhO54fB6+VbXH+siXaF+THfhC3oc3UdnYHk30Clq0tShd9InqCf6mg1xL7LMXA3ZayzzK0eBwzynxGMLE8uA2W+1qR5nCKXyaeXb81JX0lxjhTyOE6w2BzCsb861VfSUd2976b0CE7eEbJX90ehfn9WkR63OX4H1dB3IcU5rEbjXVuSus5qvWI106GlA/LxOsj8pKJ8y4EE9d38neIET6d3mG5DhRlyHsjMSfA2GW6xSJdN/Gsp3RxZ1Hw2u+dVM9QjzTHh9fHyNJDsoCHx/7l+Cz4eX1oGIXbA7dPXCSec1Nsy6Lc5XfbP2BbRBjBc0GD7F/+srvtX69DdvDspnq5l+yb9EPs/9c5/sfVsn+NtX+PSLB/0o5N1f71iHS12L9LqZ5dR/YvpHSjUbhU2+W0f9JGsf1LGlsGP9s/vE/tgofnR8FzU4ptyd//dds/YFtMGMFzS4Psn1afKs7/Y9nB8ySql7eSfUOZ9pAen+f4H1fL/jXW/j03wf5JOzZV+7dUpKvF/t1G9ex5DfD/pI1i+8d7gbF2gcd/wyjM6xp6lHCHAjfu2W9FHHTHNhnp0Bdnuw2Z2gUPjxWA51UJNrHTkdaWa3dxLOxaw8Dz6zx2rLXuOm7dC+8Pgk5d4/88T+Oac2vk+D9kcK3r5fWxK2OetZh48D60x+THY+FvT2knc5+HjNbHYmxSjj2zvwGed6eMf8o1w66xZ9c+NoWxxT6XbK75LPC8P0X/GmP/muOqXH722T0O2cHzYWo/7iM/BOXGduhLjv9xJfkpXN4a6/GUxvxK3N7JMwRYJt4rk5dMnDf8FLnulPe4fZH8FLleFWXoOguCsct0K0U6156aQjB57kOeM2V19wmqZ18iP0WrnVoTIwvPf8iz7TX9D9n+uOY1ZP9Pzkdz/+8bKXPwsn/ZGbjXIGrtR4lbh7OaMCKO9/pImXktiq23s6P4RZRmiYjT7P8jLzx7CYWBETIsoThez4vfHhHXbOt6G+mPK+miMt0xRl5/pbVet3caeLh/rLE2RUnOEtv6+4N822hpW3uFruq9BjGuj4T8fMTM3zjk9QLg62kSjK6+sJafHQo8uOcyhG1f4tBZZ5PpLCQ8Yf54qmtNu0Retn3vXDKe75L8860URH4h4UB+PLd4+5Jx3nlRmNtHbsO7RJxmG468AiEDt+Hsc+AXYV5rqtB2VFx+H/JO2gcm5eA5hMMjgdLWmrIOEGb/ymWnGjlGBpm5PdfytVAn8B4scehCu83P8bkVbj9nxuiY1yuvTKhDU2mLeUyzHvuTFMZAKzwuBJ0Bv2tMckOKzlbF6IzruNzX0BZM3o8RRvHSBmCtKY/Fgr9D3I9G4VJtV+K7gvy4TQ+j32ZrB7qDye0byybXTbKvpKDXEre/xcDdLnD7u33JOGbUHayblPNI3ObgGUjD6yZ7xbPrNtZeqkxYNzpTyOGa29+ZgjH/elUp6cg+8WwcuWaWZQfPSeR7nRKF+f2aTXq8wPE/roK4DynMfXqNc4SVxrmr9UiuWV/rkInHjfOSifMuBBPPhOP1rwifT++wnDNGGfLZcRgXZOwyXZdIx3PNqyndWpEO97zXYhfVswuo/xFSutEoXKrtqupudYwsS0gW8PSQLD0iHfh53Tjep/bA7d8ViWdvim2Znbv8bvsHbLMJI3gubZD9y192t/0LHbKD50qql1eTfZN+SPXcdMf/uFr2r7H27+YE+yft2FTt3xKRrhb7dx3Vs1vI/mmtnVsdI0sPyQIeHptynYeC/3m+R6vvHLduhHG71n/IvU1yjxL743LdEK8nBM/TE2xipyOtLdcvzhgLu+Z2eN6BxwEadR4Kj125xnJ4zM01ftrIsRzXWTMI87qh5THP6iIeuQ87aVzjpSntZO5jytG6IT67MQwmr5vi9uyVKeMIci2VaxxBriXSmht0yeYamwTP3Sn61xjH0RxX4PKzz17ikB08b6D2403kh/B7iP/f7/gfV5KfwuWtsU5Byf8pcRuMerTGIRP7E3nJxHnDT3F99w3h95GfItfxhFGYz0tHn52xy3TynHXXWXSFIP4MWV679zaqZ+8nP6Ve59ixHYIs4OGxe4V5K2f74xrXC6OwnE+R+4nt9dGU+RT4ArwmB2nZT9BapxsGE+XF/UrCiDheAy1l5nlF+9+8YDyMNItEnKb/i7zwbNzzmTBybROfB8j+j1xL1GzrnTTfh7gzA5bo6qIy3T52SHgU2uuBTpFfGh7uH2v0lZTkLLGtz3vdkLStodBVvdeTxPWRkF8Lcwvzgwkz7wsLo18el1jSJBhd4yRafbC49o3LEO3+IofO6nFuz3R0tpjwaJzJY+WdL/Kyvl8hHM9X4TyEgYLILyQcfB4CeIZ7x3lnRtji/LtQxDVyHXYXyRVSHMK8pkzDzykEk+fAkDfyszxyD6aUg/dgzo/+TFtTxjpAmH3vpSJO852byvnWYRRm267lh0N3qEPzhS7i7JSr76LVl4/ru/BZDYibT3jmK+EJBZ6wlfcDeSvY6Aq3DbgK4j6kMM8nabw3POYwFTzK/emSa35N830MhZy4/yc7E7+f57Cmgqd1Jv7Ey+pKjtO69jWAp3W+fAtzM2NuneM/GU8o8OCeyxBte49DZ/ObTGchYZRj1rZPeFY4jlehr9fP/fapnLf/t55x3nMjbLweYz7JE4o4zX4H8sKzQ6HLLqE/xCHMPp7CeES/q9+BvHl9kNwDJeXgPVB7oz9d/VVXv4/n2ZXPk6+WiVzX4jpHR65j0fQzUf6oLz0OXSj4USUtf9HKMZ01N9eEY79TXXMTsTvXNHH7qFF/lOxzVWfyDCBpn/kMoEeGyTpbHaMzruPy7H4l2SpK61aqOpPrVoDf9c3UW8Jkna2N0dkq0pk8c78tmLwOpBDFy3Ws2CMmn2H5lXTUx+t2cnxuVfdYyyvXDPH6YvA8LRz7jdO9XDscCt11kb7Aqzl+GWeTl9Ux7yAh7zD/vAdcZSrnu7hMnxNFTrVM5TwZt7NTWUfO51GEUVjuIeGzpsDzogScPKbE9UrrTOq4erWI8AAnz5Hh/3r4rHFrf5Y4dNZDeLTnU1Cm64V+dHRR3jvd8Vgek9SoP1rjqmxPOnJ77kB1fbJca+mad+H2CRi0vokRN8eyzpF3froYrNbjDVPQxQYHHo2zkpN0scGRd466mPAt7SRdbHTgUTjfOVEXGx1556iLqh9VmoIuSg48pTrrIunb5EmY1zUB5g4RzifvoaqNK09BF2UHnnKddVF25J2fLsb2zVamoIuKA0+lzrpAftPFvLEJMHeIcD55D47YvPumoIs+B56+OusC+U0X80YPMZebAHOHCOeT9+A+m3f/FHTR78DTX2dd9DvyzlEX+23eA1PQxYADz0CddTHgyDvHdrXqFw1OQReDDjyDddYF8psu5rKHmEseYl7nIeYNHmLe6CFmH9/BZqgbHSKcT96D1f36Q1PQxZADz1CddYH8/hkwlz3EvNFDzBs8xDzgIeZm0LOdz+iJwpt6NPGUL5nufmBg6KQwz28MR+HRIN/13chrmPIayV0fY+Uj6wvuR1TzLu+1z92sIJN97pb8n1sd1zsqehbmhbc4dLU1ChdyLqej6LkFygfxRQoP9Yzzgg/6gD0Adjv/vCkKM3aZbkik6yaeTZRui0iHe5S11d16es816tZU6rXVA95lPrsB86q8t29YxGnay2GBG/dDhBH2ku3DsBIe5FWIni3z5j1j65tUZ90Ux/Ig3Balk99xVNLrhG+UFQXmXooHz6n0PqPO4mzlHpGO6748E4rPVh4Sz447Dyv/ufaBEmOUZ4sucWA8IwVj/vVqoKS5tmSEZLTPnu2QHTzn9Izr6bwozO/XPNLjZY7/cRXEfUjhIdLlg6VNZpmaoU2+NKFNRhlOt00eFulqaZMvpHp2GbXP6yndaBQu1XZVdbcpRpYekgU8fG683FMNfl4Xh/epXfDwufXguSbFtszLXX63/QO2eYQRPNc3yP7lL7vb/q13yA6eR1O9fAzZN+mH2P+f7vgfV8v+Ndb+3ZZg/6Qdm6r96xHparF/j6N69nSyf1rni2+KkYXPOQAPf7dc7gMBP9s/vE/tgofPNAfPnSm2JX//123/gG2YMILn+Q2yf1p9qjj/j2UHz0uoXr6M7BvKtIf0+EbH/7ha9q+x9u8NCfZP2rGp2r+lIl0t9u9VVM/e2AD/T9ootn+8p2i2SAd+tn/QZ7vg4W83gOcdKbYl/zOM3fZvtpCV7d97GmT/tL4zHef/sezgeT/Vyw+SfUOZLiU9fs7xP66W/Wus/ftsgv2Tdmyq9m+lSFeL/fsI1bPPkf3roXSjUbhU2+W0f9JGsf3jPZJyfyb4k/w/+e0m9v/+PcW25L/f223/gI376OD5WoPsn9Zed2n/ehyyg+fbVC+/S/YNZcp7zH/t+B9Xy/411v79KsH+STs2Vfs3W6Srxf79gOrZrxvg/0kbxfaPzyjFue/g57EePhNe66z7HoEb9+y3Ii5pPy/mYpLGLQ8Xz+Fxy/9JsImdjrS2XJ8/YyzMZ8Lw+SOhiNOcAwmDifrA/VTPhOGzbJaJOKWzQqb8bSHI4Pq2EOaaC0H8t4X4zJnpfFtodu9EPfCldBZIdU/ndM456UrAyM8CzlDIG/dtoTB/2ZxnuPD5Q1K2hSn6V7BJ/UqyO78t1OOQHTyH9o7r6fAozGca9ZIeVzv+x1UQ9yGFW98Wmr5MnDf8lKRvC63qHeeV+9ZRho38ttBiqmeoR5rt1KoYWRaTLODhs0m0+o2y/ZHnwVkelFO74OFvC4GnnGCz+IxD/raQ9B00/a3eYKK8uGd/C3F8TrWUmc/rc33/hv0fXuOpVY7IC8/GPfuyfH4G4kLCi99eEafZd40rD/4mJGTopTiE+duKS2OexeeUyzP3ZH585t5xKe1v7mcVRd9WxLsh5/L5fQPPSSn+j/QJQyEv65LP5Qvzli3y7aRs8rsCLNuuFP0r+OQDmv4Pl5999iKH7OB5CLVL55J/g3Lj705c6vgfV0HchxTm8tawt/a5q/J/btX/kef6rXLItIZ0kJdMnDf8H+lX8JmC+8n/kf4IyhDY7bsI/5exy3RLRbpu4uH+v/Q1cM99kAuonl1K/o9WO7UiRpb5JAt4eN2s1tlhsv2R32+xPCindsHDa2vBc02K/yO/P+E6C1hzvCHu20LLCaP0ATsdMvP3dWy9XRhMlJu/x8jjKFrrX5AXni3H9Vzff+wKJn4LEr/yezwdQXN9E1LzfZDz4a68FXRRme53MfibUqESnsXTwBMSHo2+o5KcJbb19wf5ttHStsqxrnp/Vy0UeHDPex18w8znRgIr9z0XNQlGxHEbFyrhibNhIeGBbe9y6KyzyXQ2m/AotJ/V7+cdKPKy7ftrelXzrXC7DT9e4igST+/Scd57I2xdlIbb8NkiTrMNj6tv3Ia7/BGE+ft5Cm1HxeX3yT1CXCfbY+Tg83/fkeLnznXoAGH2r0IR1+gxMmkrNH0t1Alg63LoIsw/75KSjivcfs6M0TGPFX8oZewqrS3mMU3uK2rUH6Ux0KrOlgmdAb9rTPITKTpLG8/n8T7wtgWTvzEbRvHSBuC8ffDx+1KP/p18V3h9G2w9twfN1A50BxPtP+RBuC1Kh7UW7CtptPsF0lXS3lHwfJPGslB3sG+4S6TjNgfPRhreN7xYPLtuY+3R2ary+72QY5kD43dTMOZfryolHdknfk8W5TPPITt4fkjjhD+m8WbUl4Wkxz86/sdVEPchhblPr/WdGYVx7gnfIpT7j1gmHjfOSybOuxBM/E4N4osU/gO9w/J7NijDB9bWBOPjgoxdppNrR7uJZzmlk2tx5F4Lq7ufUz37I/U/DqR0o1G4VNvl/G6VtM/dxMNjwvNEOvD3EA/02S54eF8qeP6WYlvy90Hd9m+ekJXt3/0Nsn9a/re0fwc6ZAfPDOp7zozCPMbN/eYDHf/jatm/xtq/hUvHedPs2FTtX5dIV4v9m031DPXI6m4hpRuNwqXaLqf9kzaK7R+PTcEG8PiZXG+huedf9g17HbgRB92xTUY6+KJstyGTXDeNtDwmFS6dKDNfnY60tlxPpnXTss/P8w7a3yJn+49ny7lIHhNxjeXwmFso4ho9lsM6QxzCvG6oJ+ZZBxKPXAMn85uwBi6hTqiMKUfrhnjvYhhMXjfF7dlAAkZ+FnC6xhHCKMzr9hTKu+KS7UCBh2XbnKJ/jXEczbrO5WefPdshO3hGqf3YTn4Iv8/4f5fjf1wFcR9SWPkbqmrfouc2WH4P1PV97bz9FD53g/0WPkcD4dPJTwEf9IEydH1bl7HLdPKbf661xoUg/pvWvHZvJ9WzXeSnaI2tLYuR5UCShcdJgKdLCY8c6wMOOU5pr3bBw3Nb4DkvwWbxHK9rfTH7CVrrdMNgory45/NlEMe+QdK8otXVwVE8j9nOF3GafuR8IRfuea2QXNvUFUxc54RfuZao2dY7ab4PcjzElbfGHPJ0+9g8l661jinrmKfW9y0V5JxwnmXe64ZCoSvXPAp46rGeJK6PhPx8xBy395n7eM2A0dUX1vIx4mwYlyFs+3yHzjqbTGfzCI9C+1ldN3SoyMu2789cqppvhdtt+PESR5F45i4b570zwtZFabgNnyfiNNvwuPrGbbjLH0GY1w0ptB0Vl58r5we4TrbHyMFzCC9L8XPnOnQg52Ti7FQjx8ikrdD0tXg/WxhMHoutR5uf43Mr3H7OjNEx95VenzJ2FdK9DSetxwtJZ1rrtnuUdCbXWgG/a1zobSk6643RGdfxMAqDl9cHhfRr46UNwLoh8HG7UI/+nXxXeJ4Atp7bg2ZqB7opjuVBWK4bYl9Jo90vkK7k2hGeOwXPx2gsC3UH64Zc+63k+AjS8Lqh2eLZdRtrj+bNeTyD5eh1YPxUCsb869XYvHn+sk88swjls9AhO3j+H40TfoHGm1FfDiY9ftfxP66CuA8pzH16jbVSSuPc1XrEc78h5cMy8bhxXjJx3oVg4vw0n9OC8HfoHZbz2ChDPlNHnr/qSjdPpOsOJp/DWQgmz1HjntfN/jvVs+9S/+NQSjcahUu1XRPWjkhZeB8r77GHLHL+WX5PzfJAn3K/Kc8/g+fHKbYlfx/Ubf8WClnZ/v28QfZPy/+W9u9Qh+zg+Q3Vy9+RfZN+iP3/fsf/uFr2r7H27+8J9k/asanav/kiXS32749Uz+4n+3cwpRuNwqXaLqf9kzaK7V9IcZjT4fEzpOH5Hi27Le0v7g8ljIiD7tgmI51co8/+uFw3hLQ8JjVn2UQ98NXpSGvLdcGMsTCPC/GYiBwn0Vw7mbZPnMdEXGM5PObmGj9t5FiOaw8+wrxuaEnMsw4lnjAKtwfp4xpHJNQJlTHlaN0Q2io5jhASRvAsScDIz0J61ziCXEukub9UyoaycZ3dvzxF/xrjOJrjCiHJaMOucVnwrKEx8nVRmNcF8Xj7Zsf/uJL8FC5vjXUKSv5Pidtg1KNlDpnYn8hLJs4bfopcj8NnZm1aNs4r1/GgDPkcWfTZGbtMJ8+fdZ3RUwjiz7LltXslqmeoR/U83weycHsPHh67n6+ER471AQeP68n5FNfcFniOSbBZPMfrOsuQ/QQF25bY3vYQRte+8KR5RYsb/tECSnOwiNPcNyT9QbmOiecXD6a4gwkvfheKOM36F+f/sj8JGbhPjzD7P/NjnsXjHSi/9pj8isRzXkr7m/tYduT/zImeJcdy+X0Dz4Up/s8cug+D8fJm/UIHc0g2hX5axSUbyuZgh2x7U/Q/RwGjZh+Vy88++1CH7OC5jNqlK8i/gS4OJz3e5PgfV5L/w+Xt01ov7uvI+VmWKSQd5CUT5w3/B/lwHwrhR5P/Az7oA2XoOluNsct080U619k8SW0dytrq7mqqZzeR/6PVTs2OkYX3t8o93PUcfwEO7jOjnOS+WR7/Bs8TU/wf+AI83iR9ByXbVmZZ8GzczyGMiOM10FJmW18+2DYW7qL0bZRmloizcrUryYW88GzcIz9+t2ZR3CzCi1/XXHu9/G85b9NFMiStuXL5P3LNs+VZQHpx5VcknheltL8L8tZJ5P8cED1L+j8LCCN4Xpbi/xxA92EwXt6sX+jgAJJtVt6yRedNS9lQNrMcst2Vov8DFDAqyV7muif3jbHs4LmX2qXXO/wb9iP/JaP/w+Wt0d7Z5x6U/3NL3N9DPTrIIdMhpIO8ZOK84f8gH/ZjEX4v+T/ggz5QhsDOfRHGLtPNF+m6iYf3Vh8k0uEeZW1192aqZ/9C/o9WOxU3387+D3h4vXS91nrJNfjcZ0s6NwQ8H07xf+ALsP8jfQcl21ZmWfBs3B9AGFleYJQyV+c4I+PiOk+xMxj3H3juWMuvQ154Nu6Rn8U3l7AhrpPkwX/tIs7iblPC3S5w476NMMryYJ8omoKs1tO2mGfNIh45/iPz4z74V+s//rOf/TjYdmBz7SX4Zor/I33CTiEv65LPyci9vCPfTsom+wgs2/dS9J+7T24watZ1Of4z1yE7eH5M7dJPyb/h9xn//9nxP64k/4fLW8PeKp0TM+GcQLnei2U6iHSQl0ycN/wf6VcUKfwn8n+kPyL71PYe/i9jl+nmiHTdxLOA0sWNrXMf5JdUz/5M/k8npRuNwqXargl9ACnLLJKF+6jAo7V2bq7Aw2MD0GM74WEepC0Sz99T/B/4ApCb21v2E7TGG+LaW14nyn4PfqXMtr68nPyfWYQdaWaLOE3/J279D9tLqWceE2L/R/pEHSR3GNTHb5tLGLmuIA5h9n/mxjyrjXjkWVIyPz5LamE0iV+3tbyR/9MdPQu2nXUBjOA5JAEjPws45RnnrMtukk1r/Y+UDWUz2yHbohT9dytgrMcZEfB/2h2yg6d3+bielkVhW04ot1mkxz7H/7iS/B8ubw17qzJGWhrzf+Q44gKHTDwWkpdMnDf8H+lX8BhmZfk4r/RHUIbAzmOxSWfkzRXpXGMmLl9Dzr1Y3a2ieoZ6pNlOzYuRpY1kcc0/aI3JSn8AOLjPDBztggdpi8SzOcFmdQfjvgCPRbCc+FWwbYntbTf9yrGTTofM1XMTHf5P0ZGmSHJp2VY59iHbFfZ/uO/fRvIA9xwRp9kfiBuPY1/H5cshzP5PZ8yzOogH9a49Jr8i8exKaX9z9wkj/4f79mGQ7KOdneL/dNF9GEycnw2Cibrk9XdaYyBSNpRNm0O28+vtf0ZttpbsXH722a6xR/BcTO3SHvJvUG7s/zzC8T+uJP+Hy1tjv7uSX1Xitl3OEbNM7KfkJRPnDf8H+fD8JsLXkv8zlblotEOMXaaTZ/50BxPnL5Au7Sw5q7v9VM8eQf6PVjvVHSNLB+EHD9tvrfk42f4ARzvpkdeSMA/SFonnphT/h/0D/ErfQXO8K26dDM8/Io7nsqTMtr50RsaFz3cI8sY9XKq008OlPWM/CzwWP68dK+aPqWrbZub93MhmzlJ6bkf+z3Xuve6ge5QB6k3etpjnqfl95jEFhNmmyvee557txf7ynIR0RZHONX9cCCa/G7jndhxxtu0oiPquVS/s+zMjmHgl+Qw8zpv7e2XwWN3BFt149bW79z78jH033Hjd1dcXCNwMAZR/Gfz9Dh57tTniLC8bY+TBxs/VueMFhDNIOfayFa9bxNkrDHSMI3cCH7jvmAggDNxGs4Pw54ivrFVRtAwwT8hwHUCYJ6U05LL1iQe42rjiBGPGBc6D4/VgiLJ6c/Voo1+IVhT/QbQ2x7Ns1f7/mbkvUo7pBwA=","debug_symbols":"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f7328bdrH3+/9vGPSx+/3K59/GvfuuXat2659q1brn3rlmvfuuXat2659q1brn3rlmvfutO1b93p2rfudO1bd7r2rauYRDHy+Ne+dadr37rTtW/d6dq37nTtW3cO/dxv/ZXwPId+7rePH/rJ0/pLyXkO/eRpHz/0k6d9/NBPnubxa2i/3z5+aL/fPn7o537rD37mGvq53z5+vfbxQ/v99vFD37rt44e+ddvHD33rto8f+tZtHn8Jfeu2jx/61m0f/9q37nLtW1cyBWTg8X/+1n3nzwtv+9efg92+/ZHd15+DLevVC9iuXsB+9QKOixew3q5eQLl6AVPsAr7WTpVb+UMBr775MZx++zaQthzPO2OdnYqtTsXGdgN/+OPw1/97GNsNdBQQ2w10FBDbDXQUENsNtAvYYruBjgJiu4GOAmK7gfY7NlvsG76jgNi3dkcBgW7ix5EC3a2PI0luy+OxgWGalqlxpLI81zUs9eWR9nhHOn76SNK/JpFMvxl4/HLt40/XPv587ePXax9/ufbx12sff7v28fdrH//at+5x7Vv3uPate1z71j2ufetKpt4MPP61b93j2rfuce1b97j2rXtc+tatt0vfuvV26Vu33i5969bbpW/derv0rVtvl7516+3St269XfrWrbdL37r1du1bt4R+7rde+Ksl9HO/ffzQT57WS0+1hH7ytI8f+snTPn7oJ0/z+FNov98+fmi/3z5+6Od+62/36xT6ud8+fr328UP7/fbxQ9+67eOHvnXbxw9967aPH/rWbR5/Dn3rto8f+tZtH//at+587Vt3vvatO1/71p2vfevO175152vfuvO1b93687fuG3+Tva/b4xz7enz9HW3Zpr/SUqzFqdjJqdjZqdh61WIfBSxXL2C9egHb1QvYr17AcfEClss6h0cBl3UDjwIue8M/Crjsrf0oIPZNvC23x4e3pu0o++2xO6/s07etgWV9lhv73paXG/uWf6tc6Z9mLLHdw0AwsV3JQDCx3c44MGtsFzUQTGx3NhBMbNc3EExsNzkQTAXMazCJ/KwWDM73BAzO9wQMzvcEDM73NZgN53sCBud7AgbnewIG53sCpgLmNRic7wkYnO8JGJzvCRic7wkYnO9rMDvO9wQMzvcEDM73BAzO9wRMBcxrMDjfEzA43xMwON8TMDjfEzA439dgDpzvCRic7wkYnO8J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zT3freae71Zzz3eruee71dzz3Wru+W4193y3mnu+W809363mnu9Wc893q7nnu9Xc891q7vluNfd8t5p7vlvNPd+t5p7vVnPPd6u557vV3PPdau75bjX3fLeae75bzT3freae71Zzz3eruee71dzz3Wru+W4193y3mnu+W809363mnu9Wc893q7nnu9Xc891q7vluNfd8t5p7vlvNPd+t5p7vVnPPd6u557vV3PPdau75YTX3/LCae35YzT0/rOaeH7dqVa2Tlzqs5p4fVnPPD6u554fV3PPDau75YTX3/LCae35YzT0/rOaeH1Zzzw+rueeH1dzzw2ru+WE19/ywmnt+WM09P6zmnh9Wc88Pq7nnh9Xc88Nq7vlhNff8sJp7fljNPT+s5p4fVnPPD6u554fV3PPDau75YTX3/LCae35YzT0/rOaeH1Zzzw+rueeH1dzzw2ru+WE19/ywmnt+WM09P6zmnh9Wc88Pq7nnh9Xc88Nq7vlhNff8sJp7fljNPT+s5p4fVnPPD6u554fV3PPDau75YTX3/LCae35YzT0/rOaeH1Zzzw+rueeH1dzzw2ru+WE19/ywmnt+WM09P6zmnh9Wc88Pq7nnh9Xc88Nq7vlhNff8sJp7fljNPT+s5p4fVnPPD6u554fV3PPDau75YTX3/LCae35YzT0/rOaeH1Zzzw+rueeH1dzzw2ru+WE19/ywmnt+WM09P6zmnh9Wc88Pq7nnh9Xc88Nq7vnhNPd8uznNPb9Xa+Sl7tUaeal7tUZe6l5ttarWyEvdqzXyUvdqjbzUvVojL3Wv1spLOc09v1dr5aWc5p7fq7XyUk5zz+/VWnkpp7nn92qtvJTT3PN7tVZeymnu+b1aKy/lNPf8Xq2Vl3Kae36v1spLOc09v1dr5aWc5p7fq7XyUk5zz+/VWnkpp7nn92qtvJTT3PN7tVZeymnu+b1aKy/lNPf8Xq2Vl3Kae36v1spLOc09v1dr5aWc5p7fq7XyUk5zz+/VWnkpp7nn92qtvJTT3PN7tVZeymnu+b1aKy/lNPf8Xq2Vl3Kae36v1spLOc09v1dr5aWc5p7fq7XyUk5zz+/VWnkpp7nn92qtvJTT3PN7tVZeymnu+b1aKy/lNPf8Xq2Vl3Kae36v1spLOc09v1dr5aWc5p7fq7XyUk5zz+/VWnkpp7nn92qtvJTT3PN7tVZeymnu+b1aKy/lNPf8Xq2Vl3Kae36v1spLOc09v1dr5aWc5p7fq7XyUk5zz+/VWnkpp7nn92qtvJTT3PN7tU5eqljNPS9Wc8+L1dzzYjX3/F6LVbVOXqpYzT0vVnPPi9Xc82I197xYzT0vVnPPi9Xc82I197xYzT0vVnPPi9Xc82I197xYzT0vVnPPi9Xc82I197xYzT0vVnPPi9Xc82I197xYzT0vVnPPi9Xc82I197xYzT0vVnPPi9Xc82I197xYzT0vVnPPi9Xc82I197xYzT0vVnPPi9Xc82I197xYzT0vVnPPi9Xc82I197xYzT0vVnPPi9Xc82I197xYzT0vVnPPi9Xc82I197xYzT0vVnPPi9Xc82I197xYzT0vVnPPi9Xc82I197xYzT0vVnPPi9Xc82I197xYzT0vVnPPi9Xc82I197xYzT0vVnPPi9Xc82I197xYzT0vVnPPi9Xc82I197xYzT0vVnPPi9Xc82I197xYzT0vVnPPi9Xc82I197xYzT0vVnPPi9Xc85JpNvb91Lfnqaej8d3vnGOe5+XXh+d5L1/nOOrf/ObpNj0+PN227+yOV9+8H89vnhrfvNTp12eXOr/WPpH7QPs3tU/kxdD+Te0r2ttqn8ino/2b2idKLWj/pvaJMhzav6l9okSL9m9qn+i3ErR/S/sp02YStH9Te/p6vtrT18uq/f6AsRzLa+3p6/lqX9HeVnv6er7a09fLqv32pf36Wnv6er7a09fz1Z6+nq32mbbkof2b2tPX89Wevl5W7ZfH3+ku6/Zae/p6vtpXtLfVnr6er/b09Xy1p6/nqz19PV/t6evZap9pYzPav6k9fT1f7enr+WpPX89X+4r2ttrT1/PVnr6er/b09Xy1p6/nqz19PVvtZ/p6vtrT1/PVnr6er/b09Xy1r2hvqz19PV/t6ev5ak9fz1d7+nq+2tPXs9W+0tfz1Z6+nq/29PV8taev56t9RXtb7enr+WpPX89Xe/p6vtrT1/PVnr6erfYLfT1f7cn3Q7W/f8NDonIcs1L75t6MpaK9rfbke1/tyfe+2pPvfbUn3/tqT7631X4l3/tqz9/t+GrP3+34ak9fz1f7ivZJtW/uRlzp6/lqT1/PV3v6er7a09fLqn1zR9pKX89W+42+nq/29PV8taev56s9fT1f7SvaJ9W++Xe6G309X+3p6/lqT1/P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/7bPf/H7t178/q0Xv3/rxe/fevH7d7n4/btc/P5dLn7/Lhe/fwfMeNee/+L373Lx+3e5+P27XPz+XS5+/64Xv3/Xi9+/68Xv3/Xi9++A+dLa81/8/l0vfv+uF79/14vfv+vF79/t4vfvdvH7d7v4/btd/P7VzCktjyNNZa3K8zf//kozTXTg+feLn/+49vk18zMHnr9c/PzTxc8/X/z89eLnXy5+/ovfv3vs+7f596t77Pu3ff7Y92/z/Efs+7d9/tj3b/PvJ4/Y92/7/LHv3/b5Y9+/7fPHvn/b5499/7bPH/v+bfYfjtj3b/v8se/f1vmXW+z7t33+2Pdv+/yx79/2+WPfv+3zx75/2+ePff+2zx/7/m2f/9r373K79v273C5+/5aL37/l4vdvufj9Wy5+/2rmLw08/8Xv33Lx+7dc/P4tF79/y8Xv3+ni9+908ft3uvj9O138/tXMXxp4/ovfv9PF79/p4vfvdPH7d7r4/Ttf/P6dL37/zhe/f+eL37+a+UsDz3/x+1cy/+dWl8f5b8dNef7W318tkvk/A88vmf8z8vzl4uefLn7++eLnrxc//3Lx868XP/928fNf/P6tse/f1t+vLkvs+7d9/tj3b/v8se/f9vlj37+tv59cJPN/Rp4/9v3bPn/s+7d9/tj3b/v8se/f9vlj37/N/sMa+/5tnz/2/ds+f+z7t33+2Pdv+/yx79/2+WPfv+3zx75/2+ePff+2zx/7/m2f/+L373bx+3e7+P27Xfz+3S5+/24Xv3+3i9+/28Xv3+3i9+928ft3u/j9u1/8/t0vfv/uF79/94vfv5L5SyPPf/H7d7/4/btf/P7dL37/7he/f4+L37/Hxe/f4+L373Hx+1cyf2nk+S9+/x4Xv3+PC9+/t+Xfv359c94f56nl+Dr8tD3+Y6/fmmz/x8pf+49Nf+0/Nr//Hyvzvz+ZCLBuD0G//SXMv/3H7v/T//Uf/4//8h//l//6n//7/T/xj//P//Of/9d/+S//7Z9//Y//8n//7//v/8/9s/8P"},{"name":"main_contract","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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3Wru+W4193y3mnu+W809363mnu9Wc893q7nnu9Xc891q7vluNfd8t5p7vlvNPd+t5p7vVnPPd6u557vV3PPdau75bjX3fLeae75bzT3freae71Zzz3eruee71dzz3Wru+W4193y3mnu+W809363mnu9Wc893q7nnu9Xc891q7vluNfd8t5p7vlvNPd+t5p7vVnPPd6u557vV3PPdau75bjX3fLeae75bzT3freae71Zzz3eruee71dzz3Wru+W4193y3mnu+W809363mnu9Wc893q7nnu9Xc891q7vluNff8sJp7fljNPT+s5p4fVnPPj1u1qtbJSx1Wc88Pq7nnh9Xc88Nq7vlhNff8sJp7fljNPT+s5p4fVnPPD6u554fV3PPDau75YTX3/LCae35YzT0/rOaeH1Zzzw+rueeH1dzzw2ru+WE19/ywmnt+WM09P6zmnh9Wc88Pq7nnh9Xc88Nq7vlhNff8sJp7fljNPT+s5p4fVnPPD6u554fV3PPDau75YTX3/LCae35YzT0/rOaeH1Zzzw+rueeH1dzzw2ru+WE19/ywmnt+WM09P6zmnh9Wc88Pq7nnh9Xc88Nq7vlhNff8sJp7fljNPT+s5p4fVnPPD6u554fV3PPDau75YTX3/LCae35YzT0/rOaeH1Zzzw+rueeH1dzzw2ru+WE19/ywmnt+WM09P6zmnh9Wc88Pq7nnh9Xc88Nq7vlhNff8sJp7fljNPT+s5p4fVnPPD6u554fV3PPDau75YTX3/LCae35YzT0/rOaeH1Zzzw+rueeH1dzzw2ru+WE19/xwmnu+3Zzmnt+rNfJS92qNvNS9WiMvda+2WlVr5KXu1Rp5qXu1Rl7qXq2Rl7pXa+WlnOae36u18lJOc8/v1Vp5Kae55/dqrbyU09zze7VWXspp7vm9Wisv5TT3/F6tlZdymnt+r9bKSznNPb9Xa+WlnOae36u18lJOc8/v1Vp5Kae55/dqrbyU09zze7VWXspp7vm9Wisv5TT3/F6tlZdymnt+r9bKSznNPb9Xa+WlnOae36u18lJOc8/v1Vp5Kae55/dqrbyU09zze7VWXspp7vm9Wisv5TT3/F6tlZdymnt+r9bKSznNPb9Xa+WlnOae36u18lJOc8/v1Vp5Kae55/dqrbyU09zze7VWXspp7vm9Wisv5TT3/F6tlZdymnt+r9bKSznNPb9Xa+WlnOae36u18lJOc8/v1Vp5Kae55/dqrbyU09zze7VWXspp7vm9Wisv5TT3/F6tlZdymnt+r9bKSznNPb9Xa+WlnOae36u18lJOc8/v1Vp5Kae55/dqrbyU09zze7VWXspp7vm9WicvVazmnheruefFau55sZp7fq/FqlonL1Ws5p4Xq7nnxWruebGae16s5p4Xq7nnxWruebGae16s5p4Xq7nnxWruebGae16s5p4Xq7nnxWruebGae16s5p4Xq7nnxWruebGae16s5p4Xq7nnxWruebGae16s5p4Xq7nnxWruebGae16s5p4Xq7nnxWruebGae16s5p4Xq7nnxWruebGae16s5p4Xq7nnxWruebGae16s5p4Xq7nnxWruebGae16s5p4Xq7nnxWruebGae16s5p4Xq7nnxWruebGae16s5p4Xq7nnxWruebGae16s5p4Xq7nnxWruebGae16s5p4Xq7nnxWruebGae16s5p4Xq7nnxWruebGae16s5p4Xq7nnxWruebGae16s5p4Xq7nnxWruebGae16s5p4Xq7nnxWruebGae16s5p4Xq7nnxWrueck0G/t+6tvz1NPR+O53zjHP8/Lrw/O8l69zHPVvfvN0mx4fnm7bd3bHq2/ej+c3T41vXur067NLnV9rn8h9oP2b2ifyYmj/pvYV7W21T+TT0f5N7ROlFrR/U/tEGQ7t39Q+UaJF+ze1T/RbCdq/pf2UaTMJ2r+pPX09X+3p62XVfn/AWI7ltfb09Xy1r2hvqz19PV/t6etl1X770n59rT19PV/t6ev5ak9fz1b7TFvy0P5N7enr+WpPXy+r9svj73SXdXutPX09X+0r2ttqT1/PV3v6er7a09fz1Z6+nq/29PVstc+0sRnt39Sevp6v9vT1fLWnr+erfUV7W+3p6/lqT1/PV3v6er7a09fz1Z6+nq32M309X+3p6/lqT1/PV3v6er7aV7S31Z6+nq/29PV8taev56s9fT1f7enr2Wpf6ev5ak9fz1d7+nq+2tPX89W+or2t9vT1fLWnr+erPX09X+3p6/lqT1/PVvuFvp6v9uT7odrfv+EhUTmOWal9c2/GUtHeVnvyva/25Htf7cn3vtqT7321J9/bar+S73215+92fLXn73Z8taev56t9Rfuk2jd3I6709Xy1p6/nqz19PV/t6etl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/zb7D3Ps+7d9/tj3b/v8se/f9vlj37/N89fY92/7/LHv3/b5Y9+/7fPHvn/b5499/7bPf/H7t178/q0Xv3/rxe/fevH7d7n4/btc/P5dLn7/Lhe/fwfMeNee/+L373Lx+3e5+P27XPz+XS5+/64Xv3/Xi9+/68Xv3/Xi9++A+dLa81/8/l0vfv+uF79/14vfv+vF79/t4vfvdvH7d7v4/btd/P7VzCktjyNNZa3K8zf//kozTXTg+feLn/+49vk18zMHnr9c/PzTxc8/X/z89eLnXy5+/ovfv3vs+7f596t77Pu3ff7Y92/z/Efs+7d9/tj3b/PvJ4/Y92/7/LHv3/b5Y9+/7fPHvn/b5499/7bPH/v+bfYfjtj3b/v8se/f1vmXW+z7t33+2Pdv+/yx79/2+WPfv+3zx75/2+ePff+2zx/7/m2f/9r373K79v273C5+/5aL37/l4vdvufj9Wy5+/2rmLw08/8Xv33Lx+7dc/P4tF79/y8Xv3+ni9+908ft3uvj9O138/tXMXxp4/ovfv9PF79/p4vfvdPH7d7r4/Ttf/P6dL37/zhe/f+eL37+a+UsDz3/x+1cy/+dWl8f5b8dNef7W318tkvk/A88vmf8z8vzl4uefLn7++eLnrxc//3Lx868XP/928fNf/P6tse/f1t+vLkvs+7d9/tj3b/v8se/f9vlj37+tv59cJPN/Rp4/9v3bPn/s+7d9/tj3b/v8se/f9vlj37/N/sMa+/5tnz/2/ds+f+z7t33+2Pdv+/yx79/2+WPfv+3zx75/2+ePff+2zx/7/m2f/+L373bx+3e7+P27Xfz+3S5+/24Xv3+3i9+/28Xv3+3i9+928ft3u/j9u1/8/t0vfv/uF79/94vfv5L5SyPPf/H7d7/4/btf/P7dL37/7he/f4+L37/Hxe/f4+L373Hx+1cyf2nk+S9+/x4Xv3+PC9+/5fYfX7++Oe+P89RyfB1+2h7/2Ou3Jtv/WPlr/9j01/6x+S/8Y/t/PJkIsG4PQb/9Jcy//2P3/+n/95//j3/+z//Lf/uv/+P+T/zj//P//Jf/9V//+b//y6//8V/////7//3/c//s/wU="},{"name":"call_public_fn","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"7ZzdbuIwEIXfJdeo8ozHf7zKarWiLV0hIagKXWmFePdNaOKEEGK1TdmxplcQGNvnfDjkOJJzKB6X96+/f602T9tdMf9xKNbbh8V+td2UR4cC6PTZ7nmxqQ53+8XLvpirWbHcPJavx1nxtFovi7k27ji7qEMLoS5FSxCrAWGgWjvCulp7FRLVgQLV1cEYHauR1PHnrACTq3B7O+EEDupqQg2fFO4+I1x7VJGhsbE60Klv/4V9h6G+wUezEKpeR0cIRmOLBtsR9FdPF1RZq4cbq590xiNOod5H9Va5rvpqBD3FCDaMjEATjGDBNyN4hPFfAEHbpm8EE6B3OqK5uSALOgqy9kzQwPyn9s+EbDsnoJwTl9XONbKdb/94oGZv5Vh1cqx6OVaDGKtaybEKcqyiHKtajlVibtXYplp3E9k1q64u9tCJoHZICFjXZD1w2GbhUtS7IXLPYVlA5J7wsoDIPTtmAZF7Ks0CIve8mwNE4p6ks4DIPaNnAZF7+s8CIvd1RRYQSSxEZ6JH58wZxAqM3FVIAozclUUCjNzVQgKM3BVAAozcVD8OxshN6gkwctN3AozcRJ0AIzcle2Uajx7tBRj6BjMMRm7yTYCRm3wTYOQm3wQYuck3AUZu8h0HY+Um3wQYuck3AUZu8k2A4Z58LfkIxpoEGE0tRTgDU1klOVa5p9MJrXLPmxNa5Z4gJ7TKPRNOaJV7ypvOquOe2ya0yj2JTWiVe7aa0Op/SEtxRxSC9zhuFbUH25Rrb3y3vNJP7PW7Vn9A09dvuOsPuonmSAou+Fvm+klp2+p3rq/fcdePCqN+dKqv37PX733Urw329Qfu+oON88co0j39XjHXb1Tc74kGXP/89be/qoe476J8TxeCkJug218hQ4hhoDz7E2GgK19BZ4exO13gPWUtH/EOhn+Adl4DnG0LN2/bjO+u7It0EO8ehd59qbpd+Fi7Kzv20u3gg+3w3e3Koz+Ll9Xifr2snrZRffm6eWgevlEe7v8+v31T1v4D"}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000005be4c59b"},{"kind":"string","value":"TestNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000005be4c59b"},{"kind":"string","value":"TestNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"example_constant","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"example_set","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"ImportTest::call_public_fn_parameters"}}],"kind":"struct","path":"ImportTest::call_public_fn_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"ImportTest::main_contract_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"ImportTest::main_contract_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"ImportTest::pub_call_public_fn_parameters"}}],"kind":"struct","path":"ImportTest::pub_call_public_fn_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"ImportTest::call_no_args_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"ImportTest::call_no_args_abi"}]}},"file_map":{"112":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__INNER_NOTE_HASH,\n    hash::{\n    pedersen_hash, compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_inner_note_hash_from_preimage(storage_slot: Field, note_content_hash: Field) -> Field {\n    pedersen_hash(\n        [storage_slot, note_content_hash],\n        GENERATOR_INDEX__INNER_NOTE_HASH\n    )\n}\n\nfn compute_inner_note_hash<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    compute_inner_note_hash_from_preimage(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N, M>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let (_, inner_nullifier) = note_with_header.compute_note_hash_and_nullifier(context);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\nfn compute_note_hash_for_read_request_from_innter_and_nonce(\n    inner_note_hash: Field,\n    nonce: Field\n) -> Field {\n    // TODO(#1386): This if-else can be nuked once we have nonces injected from public\n    if (nonce == 0) {\n        // If nonce is zero, that means we are reading a public note.\n        inner_note_hash\n    } else {\n        compute_unique_note_hash(nonce, inner_note_hash)\n    }\n}\n\npub fn compute_note_hash_for_read_request<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let inner_note_hash = compute_inner_note_hash(note);\n    let nonce = note.get_header().nonce;\n\n    compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, nonce)\n}\n\npub fn compute_note_hash_for_consumption<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    if (header.note_hash_counter != 0) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        inner_note_hash\n    } else {\n        // If a note is not transient, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the siloed_note_hash which has already been hashed with\n        // nonce and then contract address. This hash will match the existing leaf in the note hash\n        // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, header.nonce);\n        compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, N, M, S>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n    let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, note_header.nonce);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        let (_, nullifier) = note.compute_note_hash_and_nullifier_without_context();\n        nullifier\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [inner_note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"125":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"127":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle<N>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<N>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<N>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n"},"135":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n"},"140":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{\n    abis::{\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\n    utils::reader::Reader,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n}\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\n    let mut reader = Reader::new(fields);\n\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n    // WARNING: if updating, see comment in public_call_stack_item.ts's PublicCallStackItem.hash()\n    let item = PublicCallStackItem {\n        contract_address: AztecAddress::from_field(reader.read()),\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\n        public_inputs: PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            args_hash: reader.read(),\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            end_side_effect_counter: 0,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0\n        },\n        is_execution_request: true\n    };\n    reader.finish();\n\n    item\n}\n"},"167":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{GAS_LENGTH, FIXED_DA_GAS, FIXED_L2_GAS}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\n    abis::gas_fees::GasFees\n};\nuse std::ops::{Add, Sub};\n\nstruct Gas {\n    da_gas: u32,\n    l2_gas: u32,\n}\n\nimpl Gas {\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\n        Self { da_gas, l2_gas }\n    }\n\n    pub fn tx_overhead() -> Self {\n        Self { da_gas: FIXED_DA_GAS, l2_gas: FIXED_L2_GAS }\n    }\n\n    pub fn compute_fee(self, fees: GasFees) -> Field {\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.da_gas == 0) & (self.l2_gas == 0)\n    }\n\n    pub fn within(self, limits: Gas) -> bool {\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\n    }\n}\n\nimpl Add for Gas {\n    fn add(self, other: Gas) -> Self {\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\n    }\n}\n\nimpl Sub for Gas {\n    fn sub(self, other: Gas) -> Self {\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\n    }\n}\n\nimpl Serialize<GAS_LENGTH> for Gas {\n    fn serialize(self) -> [Field; GAS_LENGTH] {\n        [self.da_gas as Field, self.l2_gas as Field]\n    }\n}\n\nimpl Deserialize<GAS_LENGTH> for Gas {\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\n    }\n}\n\nimpl Eq for Gas {\n    fn eq(self, other : Gas) -> bool {\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\n    }\n}\n\nimpl Empty for Gas {\n    fn empty() -> Self {\n        Gas::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Gas::empty();\n    let serialized = item.serialize();\n    let deserialized = Gas::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n"},"169":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr","source":"use crate::{\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct NoteHash {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for NoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteHash {\n    fn eq(self, other: NoteHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter) \n    }\n}\n\nimpl Empty for NoteHash {\n    fn empty() -> Self {\n        NoteHash {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl NoteHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNoteHash {\n        ScopedNoteHash { note_hash: self, contract_address }\n    }\n}\n\nstruct ScopedNoteHash {\n    note_hash: NoteHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<NoteHash> for ScopedNoteHash {\n    fn inner(self) -> NoteHash {\n        self.note_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNoteHash {\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNoteHash {\n    fn value(self) -> Field {\n        self.note_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl Eq for ScopedNoteHash {\n    fn eq(self, other: ScopedNoteHash) -> bool {\n        (self.note_hash == other.note_hash)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedNoteHash {\n    fn empty() -> Self {\n        ScopedNoteHash {\n            note_hash: NoteHash::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\n        array_concat(self.note_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            note_hash: reader.read_struct(NoteHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNoteHash {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.note_hash.value, read_request.value(), \"Value of the note hash does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the note hash does not match read request\");\n        assert(\n            read_request.counter() > self.note_hash.counter, \"Read request counter must be greater than the counter of the note hash\"\n        );\n    }\n}\n\nimpl ScopedNoteHash {\n    pub fn expose_to_public(self) -> NoteHash {\n        // Hide the actual counter when exposing it to the public kernel.\n        NoteHash { value: self.note_hash.value, counter: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = NoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"170":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"172":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr","source":"use crate::{\n    abis::{\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    transaction::tx_context::TxContext, utils::arrays::validate_array\n};\n\nstruct PrivateCircuitPublicInputsArrayLengths {\n    note_hash_read_requests: u32,\n    nullifier_read_requests: u32,\n    key_validation_requests_and_generators: u32,\n    note_hashes: u32,\n    nullifiers: u32,\n    l2_to_l1_msgs: u32,\n    private_call_requests: u32,\n    public_call_stack_hashes: u32,\n    note_encrypted_logs_hashes: u32,\n    encrypted_logs_hashes: u32,\n    unencrypted_logs_hashes: u32,\n}\n\nimpl PrivateCircuitPublicInputsArrayLengths {\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\n        PrivateCircuitPublicInputsArrayLengths {\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\n            note_hashes: validate_array(public_inputs.note_hashes),\n            nullifiers: validate_array(public_inputs.nullifiers),\n            l2_to_l1_msgs: validate_array(public_inputs.l2_to_l1_msgs),\n            private_call_requests: validate_array(public_inputs.private_call_requests),\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\n        }\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    note_hashes: [NoteHash; MAX_NOTE_HASHES_PER_CALL],\n    nullifiers: [Nullifier; MAX_NULLIFIERS_PER_CALL],\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs: [L2ToL1Message; MAX_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    tx_context: TxContext,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.returns_hash == other.returns_hash) &\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\n        (self.is_fee_payer == other.is_fee_payer) &\n        (self.max_block_number == other.max_block_number) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\n        (self.note_hashes == other.note_hashes) &\n        (self.nullifiers == other.nullifiers) &\n        (self.private_call_requests == other.private_call_requests) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.l2_to_l1_msgs == other.l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\n        self.historical_header.eq(other.historical_header) &\n        self.tx_context.eq(other.tx_context)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\n\n        fields.extend_from_array(self.max_block_number.serialize());\n\n        for i in 0..self.note_hash_read_requests.len() {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..self.nullifier_read_requests.len() {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..self.key_validation_requests_and_generators.len() {\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\n        }\n        for i in 0..self.note_hashes.len() {\n            fields.extend_from_array(self.note_hashes[i].serialize());\n        }\n        for i in 0..self.nullifiers.len() {\n            fields.extend_from_array(self.nullifiers[i].serialize());\n        }\n        for i in 0..self.private_call_requests.len() {\n            fields.extend_from_array(self.private_call_requests[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n        fields.push(self.public_teardown_function_hash);\n        for i in 0..self.l2_to_l1_msgs.len() {\n            fields.extend_from_array(self.l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        for i in 0..self.note_encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.unencrypted_logs_hashes.len() {\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.tx_context.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            is_fee_payer: reader.read() == 1,\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL]),\n            nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL]),\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            public_teardown_function_hash: reader.read(),\n            l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            tx_context: reader.read_struct(TxContext::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PrivateCircuitPublicInputs {\n    fn empty() -> Self {\n        PrivateCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter : 0 as u32,\n            end_side_effect_counter : 0 as u32,\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            tx_context: TxContext::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PrivateCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PrivateCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x15c9b0a92b9b541598e24c9f0b0b4b04b7f2408599751c45aa12de671fd9b363;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"173":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item_compressed.nr","source":"use crate::abis::{call_context::CallContext, function_data::FunctionData, gas::Gas};\nuse crate::address::AztecAddress;\nuse crate::constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH};\nuse crate::traits::{Hash, Empty, Serialize, Deserialize};\nuse crate::utils::reader::Reader;\n\n/**\n * A compressed version of the PublicCallStackItem struct used to compute the \"hash\"\n * of a PublicCallStackItem.\n * \n * Historically, we have been zeroing most values in the PublicCallStackItem struct\n * to compute the hash involved when adding a PublicCallStackItem to the PublicCallStack.\n * \n * This struct is used to store the values that we did not zero out, and allow us to hash\n * only these, thereby skipping a lot of computation and saving us a lot of constraints\n * \n * Essentially this struct exists such that we don't have a `hash` function in the \n * PublicCallStackItem struct that practically throws away some values of the struct\n * without clearly indicating that it does so.\n */\nstruct PublicCallStackItemCompressed {\n    contract_address: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    revert_code: u8,\n    start_gas_left: Gas,\n    end_gas_left: Gas,\n}\n\nimpl Eq for PublicCallStackItemCompressed {\n    fn eq(self, other: PublicCallStackItemCompressed) -> bool {\n        (self.contract_address == other.contract_address)\n            & (self.call_context == other.call_context)\n            & (self.function_data == other.function_data)\n            & (self.args_hash == other.args_hash)\n            & (self.returns_hash == other.returns_hash)\n            & (self.revert_code == other.revert_code)\n            & (self.start_gas_left == other.start_gas_left)\n            & (self.end_gas_left == other.end_gas_left)\n    }\n}\n\nimpl Hash for PublicCallStackItemCompressed {\n    fn hash(self) -> Field {\n        std::hash::pedersen_hash_with_separator(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PublicCallStackItemCompressed {\n    fn empty() -> Self {\n        PublicCallStackItemCompressed {\n            contract_address: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n    fn serialize(self) -> [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.push(self.revert_code as Field);\n        fields.extend_from_array(self.start_gas_left.serialize());\n        fields.extend_from_array(self.end_gas_left.serialize());\n\n        assert_eq(fields.len(), PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n  fn deserialize(fields: [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH]) -> PublicCallStackItemCompressed {\n    let mut reader = Reader::new(fields);\n\n    let item = PublicCallStackItemCompressed {\n      contract_address: reader.read_struct(AztecAddress::deserialize),\n      call_context: reader.read_struct(CallContext::deserialize),\n      function_data: reader.read_struct(FunctionData::deserialize),\n      args_hash: reader.read(),\n      returns_hash: reader.read(),\n      revert_code: reader.read() as u8,\n      start_gas_left: reader.read_struct(Gas::deserialize),\n      end_gas_left: reader.read_struct(Gas::deserialize),\n    };\n    reader.finish();\n    item\n  }\n}\n"},"175":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n"},"176":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr","source":"use crate::{\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for ReadRequest {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\n        ScopedReadRequest { read_request: self, contract_address }\n    }\n}\n\nstruct ScopedReadRequest {\n    read_request: ReadRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<ReadRequest> for ScopedReadRequest {\n    fn inner(self) -> ReadRequest {\n        self.read_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ScopedReadRequest {\n    fn eq(self, other: ScopedReadRequest) -> bool {\n        (self.read_request == other.read_request)\n        & (self.contract_address.eq(other.contract_address))\n    }\n}\n\nimpl Empty for ScopedReadRequest {\n    fn empty() -> Self {\n        ScopedReadRequest {\n            read_request: ReadRequest::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            read_request: reader.read_struct(ReadRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedReadRequest {\n    pub fn value(self) -> Field {\n        self.read_request.value\n    }\n    pub fn counter(self) -> u32 {\n        self.read_request.counter\n    }\n}\n\n#[test]\nfn serialization_of_empty_read() {\n    let item = ReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"179":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr","source":"use crate::{\n    address::AztecAddress,\n    abis::validation_requests::{\n    key_validation_request::KeyValidationRequest,\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\n},\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct KeyValidationRequestAndGenerator {\n    request: KeyValidationRequest,\n    sk_app_generator: Field,\n}\n\nimpl Eq for KeyValidationRequestAndGenerator {\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\n    }\n}\n\nimpl Empty for KeyValidationRequestAndGenerator {\n    fn empty() -> Self {\n        KeyValidationRequestAndGenerator {\n            request: KeyValidationRequest::empty(),\n            sk_app_generator: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\n        array_concat(self.request.serialize(), [self.sk_app_generator])\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\n        let mut reader = Reader::new(fields);\n        let res = Self {\n            request: reader.read_struct(KeyValidationRequest::deserialize),\n            sk_app_generator: reader.read(),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl KeyValidationRequestAndGenerator {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = KeyValidationRequestAndGenerator::empty();\n    let serialized = item.serialize();\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"180":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point::new(fields[0], fields[1], fields[2] as bool),\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"184":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr","source":"use crate::{\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH},\n    hash::compute_siloed_nullifier, traits::{Empty, Hash, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct Nullifier {\n    value: Field,\n    counter: u32,\n    note_hash: Field,\n}\n\nimpl Ordered for Nullifier {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for Nullifier {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for Nullifier {\n    fn eq(self, other: Nullifier) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.note_hash == other.note_hash) \n    }\n}\n\nimpl Empty for Nullifier {\n    fn empty() -> Self {\n        Nullifier {\n            value: 0,\n            counter: 0,\n            note_hash: 0,\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\n        [self.value, self.counter as Field, self.note_hash]\n    }\n}\n\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            note_hash: values[2],\n        }\n    }\n}\n\nimpl Readable for Nullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        // Public kernels output Nullifier instead of ScopedNullifier.\n        // The nullifier value has been siloed.\n        let siloed_request_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.value, siloed_request_value, \"Value of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl Nullifier {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\n        ScopedNullifier { nullifier: self, contract_address }\n    }\n}\n\nstruct ScopedNullifier {\n    nullifier: Nullifier,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<Nullifier> for ScopedNullifier {\n    fn inner(self) -> Nullifier {\n        self.nullifier\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNullifier {\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNullifier {\n    fn value(self) -> Field {\n        self.nullifier.value\n    }\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl Eq for ScopedNullifier {\n    fn eq(self, other: ScopedNullifier) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedNullifier {\n    fn empty() -> Self {\n        ScopedNullifier {\n            nullifier: Nullifier::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            nullifier: reader.read_struct(Nullifier::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.nullifier.value, read_request.value(), \"Value of the nullifier does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.nullifier.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl ScopedNullifier {\n    pub fn nullified_note_hash(self) -> Field {\n        self.nullifier.note_hash\n    }\n\n    pub fn expose_to_public(self) -> Nullifier {\n        // Hide the actual counter and note hash when exposing it to the public kernel.\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Nullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = Nullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"193":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"194":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr","source":"use crate::{\n    abis::{\n    private_call_stack_item::PrivateCallStackItem, call_context::CallContext,\n    function_data::FunctionData, caller_context::CallerContext,\n    side_effect::{Ordered, RangeOrdered, Scoped}\n},\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PrivateCallRequest {\n    target: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Ordered for PrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.start_side_effect_counter\n    }\n}\n\nimpl RangeOrdered for PrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.start_side_effect_counter\n    }\n    fn counter_end(self) -> u32 {\n        self.end_side_effect_counter\n    }\n}\n\nimpl Eq for PrivateCallRequest {\n    fn eq(self, other: PrivateCallRequest) -> bool {\n        (self.target == other.target) \n            & (self.call_context == other.call_context) \n            & (self.function_data == other.function_data) \n            & (self.args_hash == other.args_hash) \n            & (self.returns_hash == other.returns_hash)\n            & (self.caller_context == other.caller_context)\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\n    }\n}\n\nimpl Empty for PrivateCallRequest {\n    fn empty() -> Self {\n        PrivateCallRequest {\n            target: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.push(self.target.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.extend_from_array(self.caller_context.serialize());\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = PrivateCallRequest {\n            target: reader.read_struct(AztecAddress::deserialize),\n            call_context: reader.read_struct(CallContext::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            caller_context: reader.read_struct(CallerContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            end_side_effect_counter: reader.read_u32(),\n        };\n        reader.finish();\n        item\n    }\n}\n\nimpl PrivateCallRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\n        ScopedPrivateCallRequest { call_request: self, contract_address }\n    }\n\n    pub fn matches_stack_item(self, stack_item: PrivateCallStackItem) -> bool {\n        (self.target == stack_item.contract_address)\n            & (self.call_context == stack_item.public_inputs.call_context)\n            & (self.function_data == stack_item.function_data)\n            & (self.args_hash == stack_item.public_inputs.args_hash)\n            & (self.returns_hash == stack_item.public_inputs.returns_hash)\n            & (self.start_side_effect_counter\n                                == stack_item.public_inputs.start_side_effect_counter)\n            & (self.end_side_effect_counter\n                                    == stack_item.public_inputs.end_side_effect_counter)\n    }\n}\n\nstruct ScopedPrivateCallRequest {\n    call_request: PrivateCallRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\n    fn inner(self) -> PrivateCallRequest {\n        self.call_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedPrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.call_request.counter_start()\n    }\n}\n\nimpl RangeOrdered for ScopedPrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.call_request.counter_start()\n    }\n    fn counter_end(self) -> u32 {\n        self.call_request.counter_end()\n    }\n}\n\nimpl Eq for ScopedPrivateCallRequest {\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\n        (self.call_request == other.call_request)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedPrivateCallRequest {\n    fn empty() -> Self {\n        ScopedPrivateCallRequest {\n            call_request: PrivateCallRequest::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.call_request.serialize());\n        fields.extend_from_array(self.contract_address.serialize());\n\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = ScopedPrivateCallRequest {\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        item\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = ScopedPrivateCallRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"199":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\n    abis::gas_fees::GasFees,\n    constants::{\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\n    DEFAULT_INCLUSION_FEE\n},\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    utils::reader::Reader\n};\n\nstruct GasSettings {\n    gas_limits: Gas,\n    teardown_gas_limits: Gas,\n    max_fees_per_gas: GasFees,\n    inclusion_fee: Field,\n}\n\nimpl GasSettings {\n    pub fn new(\n        gas_limits: Gas,\n        teardown_gas_limits: Gas,\n        max_fees_per_gas: GasFees,\n        inclusion_fee: Field\n    ) -> Self {\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\n    }\n\n    pub fn default() -> Self {\n        GasSettings::new(\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\n            DEFAULT_INCLUSION_FEE\n        )\n    }\n}\n\nimpl Eq for GasSettings {\n    fn eq(self, other: Self) -> bool {\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\n    }\n}\n\nimpl Empty for GasSettings {\n    fn empty() -> Self {\n        GasSettings::new(\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\n        )\n    }\n}\n\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\n\n        serialized.extend_from_array(self.gas_limits.serialize());\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\n        serialized.push(self.inclusion_fee);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\n        let mut reader = Reader::new(serialized);\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasSettings::empty();\n    let serialized = item.serialize();\n    let deserialized = GasSettings::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"208":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr","source":"use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PrivateCallStackItem {\n    fn empty() -> Self {\n        PrivateCallStackItem {\n            contract_address: AztecAddress::empty(),\n            function_data: FunctionData::empty(),\n            public_inputs: PrivateCircuitPublicInputs::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = PrivateCallStackItem::empty();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item = PrivateCallStackItem::empty();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x065f2831db9ac0db5e710bd3a865b5facd8cf83f1585e1af8fd1d6ce9c47f685;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr","source":"use crate::address::AztecAddress;\nuse crate::traits::{Empty, Serialize, Deserialize};\nuse crate::constants::CALLER_CONTEXT_LENGTH;\nuse crate::utils::reader::Reader;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n    is_static_call: bool,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, other: CallerContext) -> bool {\n        other.msg_sender.eq(self.msg_sender)\n            & other.storage_contract_address.eq(self.storage_contract_address)\n            & other.is_static_call == self.is_static_call\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n            is_static_call: false,\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\n    }\n\n    // Different to an empty context, a hidden context won't reveal the caller's msg_sender and storage_contract_address,\n    // but will still propagate the is_static_call flag.\n    pub fn is_hidden(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array(self.msg_sender.serialize());\n    fields.extend_from_array(self.storage_contract_address.serialize());\n    fields.push(self.is_static_call as Field);\n\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\n    let mut reader = Reader::new(fields);\n\n    let item = CallerContext {\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\n      is_static_call: reader.read_bool(),\n    };\n    reader.finish();\n    item\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = CallerContext::empty();\n    let serialized = item.serialize();\n    let deserialized = CallerContext::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"211":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr","source":"use crate::{\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\n    constants::{\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\n},\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct LogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n}\n\nimpl Ordered for LogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for LogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for LogHash {\n    fn eq(self, other: LogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n    }\n}\n\nimpl Empty for LogHash {\n    fn empty() -> Self {\n        LogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n        }\n    }\n}\n\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length]\n    }\n}\n\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n        }\n    }\n}\n\nimpl LogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\n        ScopedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedLogHash {\n    log_hash: LogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<LogHash> for ScopedLogHash {\n    fn inner(self) -> LogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedLogHash {\n    fn eq(self, other: ScopedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedLogHash {\n    fn empty() -> Self {\n        ScopedLogHash {\n            log_hash: LogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(LogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the counter when exposing to public.\n        // The log hash must already be siloed when we call this.\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nstruct EncryptedLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    randomness: Field,\n}\n\nimpl Ordered for EncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for EncryptedLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for EncryptedLogHash {\n    fn eq(self, other: EncryptedLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.randomness == other.randomness) \n    }\n}\n\nimpl Empty for EncryptedLogHash {\n    fn empty() -> Self {\n        EncryptedLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            randomness: 0,\n        }\n    }\n}\n\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.randomness]\n    }\n}\n\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            randomness: values[3],\n        }\n    }\n}\n\nimpl EncryptedLogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedEncryptedLogHash {\n    log_hash: EncryptedLogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\n    fn inner(self) -> EncryptedLogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl ScopedEncryptedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the secret randomness and counter when exposing to public\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\n        // The log hash will already be silo'd when we call this\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nimpl Ordered for ScopedEncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedEncryptedLogHash {\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedEncryptedLogHash {\n    fn empty() -> Self {\n        ScopedEncryptedLogHash {\n            log_hash: EncryptedLogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct NoteLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    note_hash_counter: u32,\n}\n\nimpl NoteLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\n        LogHash { value: self.value, counter: 0, length: self.length }\n    }\n}\n\nimpl Ordered for NoteLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for NoteLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteLogHash {\n    fn eq(self, other: NoteLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.note_hash_counter == other.note_hash_counter) \n    }\n}\n\nimpl Empty for NoteLogHash {\n    fn empty() -> Self {\n        NoteLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            note_hash_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            note_hash_counter: values[3] as u32,\n        }\n    }\n}\n"},"215":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr","source":"struct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n"},"216":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n}\n// docs:end:call-context\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n"},"217":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"220":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize, Empty}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        (self.is_private == other.is_private)\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nimpl Empty for FunctionData {\n    fn empty() -> Self {\n        FunctionData {\n            selector: FunctionSelector::empty(),\n            is_private: false\n        }\n    }\n\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data = FunctionData::empty();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data = FunctionData::empty();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty function data hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"227":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n    counter: u32,\n}\n\nimpl Ordered for L2ToL1Message {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content, self.counter as Field]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\nimpl L2ToL1Message {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\n        ScopedL2ToL1Message { message: self, contract_address }\n    }\n}\n\nstruct ScopedL2ToL1Message {\n    message: L2ToL1Message,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\n    fn inner(self) -> L2ToL1Message {\n        self.message\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedL2ToL1Message {\n    fn counter(self) -> u32 {\n        self.message.counter\n    }\n}\n\nimpl Eq for ScopedL2ToL1Message {\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\n        (self.message == other.message)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedL2ToL1Message {\n    fn empty() -> Self {\n        ScopedL2ToL1Message {\n            message: L2ToL1Message::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            message: reader.read_struct(L2ToL1Message::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\n#[test]\nfn serialization_of_empty_l2() {\n    let item = L2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = L2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped_l2() {\n    let item = ScopedL2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"237":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr","source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  num_txs: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.num_txs);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let num_txs = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      num_txs,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      num_txs: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.num_txs == other.num_txs)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n"},"239":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr","source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"241":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n"},"243":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr","source":"use crate::{\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    abis::gas_settings::GasSettings\n};\n\n// docs:start:tx-context\nstruct TxContext {\n    chain_id : Field,\n    version : Field,\n    gas_settings: GasSettings,\n}\n// docs:end:tx-context\n\nimpl TxContext {\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\n        TxContext { chain_id, version, gas_settings }\n    }\n}\n\nimpl Eq for TxContext {\n    fn eq(self, other: Self) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.gas_settings.eq(other.gas_settings))\n    }\n}\n\nimpl Empty for TxContext {\n    fn empty() -> Self {\n        TxContext {\n            chain_id: 0,\n            version: 0,\n            gas_settings: GasSettings::empty(),\n        }\n    }\n}\n\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\n\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.extend_from_array(self.gas_settings.serialize());\n\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let context = Self {\n            chain_id: reader.read(),\n            version: reader.read(),\n            gas_settings: reader.read_struct(GasSettings::deserialize),\n        };\n\n        reader.finish();\n        context\n    }\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context = TxContext::empty();\n    let serialized = context.serialize();\n    let deserialized = TxContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let context = TxContext::empty();\n    let hash = context.hash();\n\n    // Value from tx_context.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"249":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n"},"263":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"273":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"289":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"330":{"path":"/usr/src/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Deserialize, Serialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n"},"357":{"path":"/usr/src/noir-projects/noir-contracts/contracts/import_test_contract/src/main.nr","source":"// Contract that uses the autogenerated interface of the Test contract for calling its functions.\n// Used for testing calling into other contracts via autogenerated interfaces.\ncontract ImportTest {\n    use dep::aztec::prelude::AztecAddress;\n\n    use dep::test::{Test, Test::DeepStruct, Test::DummyNote};\n\n    use dep::test::Test::ValueNote;\n\n    // Calls the test_code_gen on the Test contract at the target address\n    // Used for testing calling a function with arguments of multiple types\n    // See yarn-project/simulator/src/client/private_execution.ts\n    // See yarn-project/end-to-end/src/e2e_nested_contract.test.ts\n    #[aztec(private)]\n    fn main_contract(target: AztecAddress) -> Field {\n        Test::at(target).test_code_gen(\n            1,\n            true,\n            1 as u32,\n            [1, 2],\n            DummyNote { amount: 1, secret_hash: 2 },\n            DeepStruct {\n            a_field: 1,\n            a_bool: true,\n            a_note: DummyNote { amount: 1, secret_hash: 2 },\n            many_notes: [\n                DummyNote { amount: 1, secret_hash: 2 },\n                DummyNote { amount: 1, secret_hash: 2 },\n                DummyNote { amount: 1, secret_hash: 2 }\n            ]\n        }\n        ).call(&mut context)\n    }\n\n    // Calls the get_this_address on the Test contract at the target address\n    // Used for testing calling a function with no arguments\n    // See yarn-project/end-to-end/src/e2e_nested_contract.test.ts\n    #[aztec(private)]\n    fn call_no_args(target: AztecAddress) -> AztecAddress {\n        Test::at(target).get_this_address().call(&mut context)\n    }\n\n    // Calls the emit_nullifier_public on the Test contract at the target address\n    // Used for testing calling a public function\n    // See yarn-project/end-to-end/src/e2e_nested_contract.test.ts\n    #[aztec(private)]\n    fn call_public_fn(target: AztecAddress) {\n        Test::at(target).emit_nullifier_public(1).enqueue(&mut context);\n    }\n\n    // Calls the emit_nullifier_public on the Test contract at the target address\n    // Used for testing calling a public function from another public function\n    // See yarn-project/end-to-end/src/e2e_nested_contract.test.ts\n    #[aztec(public)]\n    fn pub_call_public_fn(target: AztecAddress) {\n        Test::at(target).emit_nullifier_public(1).call(&mut context);\n    }\n}\n\n"},"358":{"path":"/usr/src/noir-projects/noir-contracts/contracts/test_contract/src/main.nr","source":"mod test_note;\n\n// A contract used for testing a random hodgepodge of small features from simulator and end-to-end tests.\ncontract Test {\n\n    use dep::aztec::prelude::{\n        AztecAddress, EthAddress, FunctionSelector, NoteHeader, NoteGetterOptions, NoteViewerOptions,\n        PrivateContext, PrivateImmutable, PrivateSet, SharedImmutable\n    };\n    use dep::aztec::encrypted_logs::encrypted_note_emission::encode_and_encrypt_note;\n    use dep::aztec::encrypted_logs::encrypted_event_emission::encode_and_encrypt_event_with_keys_with_randomness;\n\n    use dep::aztec::protocol_types::{\n        abis::private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, CANONICAL_KEY_REGISTRY_ADDRESS},\n        traits::{Serialize, ToField, FromField}, point::Point, scalar::Scalar,\n        storage::map::derive_storage_slot_in_map\n    };\n\n    use dep::aztec::encrypted_logs::header::EncryptedLogHeader;\n    use dep::aztec::encrypted_logs::incoming_body::EncryptedLogIncomingBody;\n    use dep::aztec::encrypted_logs::outgoing_body::EncryptedLogOutgoingBody;\n\n    use dep::aztec::note::constants::MAX_NOTES_PER_PAGE;\n\n    use dep::aztec::state_vars::{shared_mutable::SharedMutablePrivateGetter};\n\n    use dep::aztec::{\n        context::inputs::private_context_inputs::PrivateContextInputs,\n        hash::{pedersen_hash, compute_secret_hash, ArgsHasher},\n        note::{\n        lifecycle::{create_note, destroy_note}, note_getter::{get_notes, view_notes},\n        note_getter_options::NoteStatus\n    },\n        deploy::deploy_contract as aztec_deploy_contract,\n        oracle::{encryption::aes128_encrypt, unsafe_rand::unsafe_rand}\n    };\n    use dep::token_portal_content_hash_lib::{get_mint_private_content_hash, get_mint_public_content_hash};\n    use dep::value_note::value_note::ValueNote;\n\n    use crate::test_note::TestNote;\n\n    #[aztec(event)]\n    struct ExampleEvent {\n        value0: Field,\n        value1: Field,\n        value2: Field,\n        value3: Field,\n        value4: Field,\n    }\n\n    #[aztec(storage)]\n    struct Storage {\n        example_constant: PrivateImmutable<TestNote>,\n        example_set: PrivateSet<TestNote>,\n    }\n\n    #[aztec(private)]\n    fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n        context.request_ovsk_app(ovpk_m_hash)\n    }\n\n    #[aztec(private)]\n    fn get_master_incoming_viewing_public_key(address: AztecAddress) -> [Field; 2] {\n        let header = context.get_header();\n        let pub_key = header.get_ivpk_m(&mut context, address);\n\n        [pub_key.x, pub_key.y]\n    }\n\n    // Get the address of this contract (taken from the input context)\n    #[aztec(private)]\n    fn get_this_address() -> AztecAddress {\n        context.this_address()\n    }\n\n    #[aztec(private)]\n    fn set_tx_max_block_number(max_block_number: u32, enqueue_public_call: bool) {\n        context.set_tx_max_block_number(max_block_number);\n\n        if enqueue_public_call {\n            Test::at(context.this_address()).dummy_public_call().enqueue(&mut context)\n        }\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn dummy_public_call() {}\n\n    #[aztec(private)]\n    fn call_create_note(\n        value: Field,\n        owner: AztecAddress,\n        outgoing_viewer: AztecAddress,\n        storage_slot: Field\n    ) {\n        assert(\n            storage_slot != storage.example_constant.get_storage_slot(), \"this storage slot is reserved for example_constant\"\n        );\n\n        let header = context.get_header();\n        let owner_npk_m_hash = header.get_npk_m_hash(&mut context, owner);\n\n        let mut note = ValueNote::new(value, owner_npk_m_hash);\n        create_note(&mut context, storage_slot, &mut note).emit(encode_and_encrypt_note(&mut context, outgoing_viewer, owner));\n    }\n\n    #[aztec(private)]\n    fn call_get_notes(storage_slot: Field, active_or_nullified: bool) -> Field {\n        assert(\n            storage_slot != storage.example_constant.get_storage_slot(), \"this storage slot is reserved for example_constant\"\n        );\n\n        let mut options = NoteGetterOptions::new();\n        if (active_or_nullified) {\n            options = options.set_status(NoteStatus.ACTIVE_OR_NULLIFIED);\n        }\n\n        let notes: BoundedVec<ValueNote, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = get_notes(&mut context, storage_slot, options);\n\n        notes.get(0).value\n    }\n\n    #[aztec(private)]\n    fn call_get_notes_many(storage_slot: Field, active_or_nullified: bool) -> [Field; 2] {\n        assert(\n            storage_slot != storage.example_constant.get_storage_slot(), \"this storage slot is reserved for example_constant\"\n        );\n\n        let mut options = NoteGetterOptions::new();\n        if (active_or_nullified) {\n            options = options.set_status(NoteStatus.ACTIVE_OR_NULLIFIED);\n        }\n\n        let notes: BoundedVec<ValueNote, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = get_notes(&mut context, storage_slot, options);\n\n        [notes.get(0).value, notes.get(1).value]\n    }\n\n    unconstrained fn call_view_notes(storage_slot: Field, active_or_nullified: bool) -> pub Field {\n        assert(\n            storage_slot != storage.example_constant.get_storage_slot(), \"this storage slot is reserved for example_constant\"\n        );\n\n        let mut options = NoteViewerOptions::new();\n        if (active_or_nullified) {\n            options = options.set_status(NoteStatus.ACTIVE_OR_NULLIFIED);\n        }\n\n        let notes: BoundedVec<ValueNote, MAX_NOTES_PER_PAGE> = view_notes(storage_slot, options);\n\n        notes.get(0).value\n    }\n\n    unconstrained fn call_view_notes_many(storage_slot: Field, active_or_nullified: bool) -> pub [Field; 2] {\n        assert(\n            storage_slot != storage.example_constant.get_storage_slot(), \"this storage slot is reserved for example_constant\"\n        );\n\n        let mut options = NoteViewerOptions::new();\n        if (active_or_nullified) {\n            options = options.set_status(NoteStatus.ACTIVE_OR_NULLIFIED);\n        }\n\n        let notes: BoundedVec<ValueNote, MAX_NOTES_PER_PAGE> = view_notes(storage_slot, options);\n\n        [notes.get(0).value, notes.get(1).value]\n    }\n\n    #[aztec(private)]\n    fn call_destroy_note(storage_slot: Field) {\n        assert(\n            storage_slot != storage.example_constant.get_storage_slot(), \"this storage slot is reserved for example_constant\"\n        );\n\n        let options = NoteGetterOptions::new();\n        let notes: BoundedVec<ValueNote, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = get_notes(&mut context, storage_slot, options);\n\n        let note = notes.get(0);\n\n        destroy_note(&mut context, note);\n    }\n\n    #[aztec(private)]\n    fn test_code_gen(\n        a_field: Field,\n        a_bool: bool,\n        a_number: u32,\n        an_array: [Field; 2],\n        a_struct: DummyNote,\n        a_deep_struct: DeepStruct\n    ) -> Field {\n        let mut args = ArgsHasher::new();\n        args.add(a_field);\n        args.add(a_bool as Field);\n        args.add(a_number as Field);\n        args.add_multiple(an_array);\n        args.add(a_struct.amount);\n        args.add(a_struct.secret_hash);\n        args.add(a_deep_struct.a_field);\n        args.add(a_deep_struct.a_bool as Field);\n        args.add(a_deep_struct.a_note.amount);\n        args.add(a_deep_struct.a_note.secret_hash);\n        for note in a_deep_struct.many_notes {\n            args.add(note.amount);\n            args.add(note.secret_hash);\n        }\n        args.hash()\n    }\n\n    #[aztec(private)]\n    fn test_setting_teardown() {\n        context.set_public_teardown_function(\n            context.this_address(),\n            FunctionSelector::from_signature(\"dummy_public_call()\"),\n            []\n        );\n    }\n\n    #[aztec(private)]\n    fn test_setting_fee_payer() {\n        context.set_as_fee_payer();\n    }\n\n    // Purely exists for testing\n    #[aztec(public)]\n    fn create_l2_to_l1_message_public(amount: Field, secret_hash: Field, portal_address: EthAddress) {\n        // Create a commitment to the amount\n        let note = DummyNote::new(amount, secret_hash);\n\n        // Public oracle call to emit new commitment.\n        context.message_portal(portal_address, note.get_commitment());\n    }\n\n    #[aztec(public)]\n    fn create_l2_to_l1_message_arbitrary_recipient_public(content: Field, recipient: EthAddress) {\n        // Public oracle call to emit new commitment.\n        context.message_portal(recipient, content);\n    }\n\n    #[aztec(private)]\n    fn create_l2_to_l1_message_arbitrary_recipient_private(content: Field, recipient: EthAddress) {\n        // Public oracle call to emit new commitment.\n        context.message_portal(recipient, content);\n    }\n\n    // Purely exists for testing\n    #[aztec(public)]\n    fn emit_nullifier_public(nullifier: Field) {\n        context.push_nullifier(nullifier, 0);\n    }\n\n    // Forcefully emits a nullifier (for testing purposes)\n    #[aztec(private)]\n    fn emit_nullifier(nullifier: Field) {\n        context.push_nullifier(nullifier, 0);\n    }\n\n    // For testing non-note encrypted logs\n    #[aztec(private)]\n    fn emit_array_as_encrypted_log(\n        fields: [Field; 5],\n        owner: AztecAddress,\n        outgoing_viewer: AztecAddress,\n        nest: bool\n    ) {\n        let header = context.get_header();\n        let outgoing_viewer_ovpk_m = header.get_ovpk_m(&mut context, outgoing_viewer);\n        let owner_ivpk_m = header.get_ivpk_m(&mut context, owner);\n\n        let event = ExampleEvent { value0: fields[0], value1: fields[1], value2: fields[2], value3: fields[3], value4: fields[4] };\n\n        event.emit(\n            encode_and_encrypt_event_with_keys_with_randomness(\n                &mut context,\n                // testing only - a secret random value is passed in here to salt / mask the address\n                5,\n                outgoing_viewer_ovpk_m,\n                owner_ivpk_m\n            )\n        );\n\n        // this contract has reached max number of functions, so using this one fn\n        // to test nested and non nested encrypted logs\n        if nest {\n            Test::at(context.this_address()).emit_array_as_encrypted_log([0, 0, 0, 0, 0], owner, outgoing_viewer, false).call(&mut context);\n\n            let otherEvent = ExampleEvent { value0: 1, value1: 2, value2: 3, value3: 4, value4: 5 };\n\n            otherEvent.emit(\n                encode_and_encrypt_event_with_keys_with_randomness(\n                    &mut context,\n                    // testing only - a randomness of 0 signals the kerels to not mask the address\n                    0,\n                    outgoing_viewer_ovpk_m,\n                    owner_ivpk_m\n                )\n            );\n        }\n    }\n\n    #[aztec(private)]\n    fn emit_encrypted_logs_nested(value: Field, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let mut storage_slot = storage.example_constant.get_storage_slot() + 1;\n        Test::at(context.this_address()).call_create_note(value, owner, outgoing_viewer, storage_slot).call(&mut context);\n        storage_slot += 1;\n\n        let header = context.get_header();\n        let owner_npk_m_hash = header.get_npk_m_hash(&mut context, owner);\n\n        let mut note = ValueNote::new(value + 1, owner_npk_m_hash);\n        create_note(&mut context, storage_slot, &mut note).emit(encode_and_encrypt_note(&mut context, context.msg_sender(), owner));\n        storage_slot += 1;\n        Test::at(context.this_address()).call_create_note(value + 2, owner, outgoing_viewer, storage_slot).call(&mut context);\n    }\n\n    // docs:start:is-time-equal\n    #[aztec(public)]\n    fn is_time_equal(time: u64) -> u64 {\n        assert(context.timestamp() == time);\n        time\n    }\n    // docs:end:is-time-equal\n\n    #[aztec(public)]\n    fn emit_unencrypted(value: Field) {\n        // docs:start:emit_unencrypted\n        context.emit_unencrypted_log(/*message=*/ value);\n        context.emit_unencrypted_log(/*message=*/ [10, 20, 30]);\n        context.emit_unencrypted_log(/*message=*/ \"Hello, world!\");\n        // docs:end:emit_unencrypted\n    }\n\n    #[aztec(public)]\n    fn consume_mint_public_message(\n        to: AztecAddress,\n        amount: Field,\n        secret: Field,\n        message_leaf_index: Field,\n        portal_address: EthAddress\n    ) {\n        let content_hash = get_mint_public_content_hash(to, amount);\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(content_hash, secret, portal_address, message_leaf_index);\n    }\n\n    #[aztec(private)]\n    fn consume_mint_private_message(\n        secret_hash_for_redeeming_minted_notes: Field,\n        amount: Field,\n        secret_for_L1_to_L2_message_consumption: Field,\n        portal_address: EthAddress\n    ) {\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash = get_mint_private_content_hash(secret_hash_for_redeeming_minted_notes, amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            portal_address\n        );\n    }\n\n    #[aztec(public)]\n    fn consume_message_from_arbitrary_sender_public(\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        message_leaf_index: Field\n    ) {\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(content, secret, sender, message_leaf_index);\n    }\n\n    #[aztec(private)]\n    fn consume_message_from_arbitrary_sender_private(\n        content: Field,\n        secret: Field,\n        sender: EthAddress\n    ) {\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(content, secret, sender);\n    }\n\n    #[aztec(private)]\n    fn set_constant(value: Field) {\n        let mut note = TestNote::new(value);\n        storage.example_constant.initialize(&mut note).discard();\n    }\n\n    #[aztec(private)]\n    fn assert_private_global_vars(chain_id: Field, version: Field) {\n        assert(context.chain_id() == chain_id, \"Invalid chain id\");\n        assert(context.version() == version, \"Invalid version\");\n    }\n\n    #[aztec(private)]\n    fn encrypt(input: [u8; 64], iv: [u8; 16], key: [u8; 16]) -> [u8; 80] {\n        aes128_encrypt(input, iv, key)\n    }\n\n    #[aztec(private)]\n    fn encrypt_with_padding(input: [u8; 65], iv: [u8; 16], key: [u8; 16]) -> [u8; 80] {\n        aes128_encrypt(input, iv, key)\n    }\n\n    #[aztec(private)]\n    fn compute_note_header_ciphertext(secret: Scalar, point: Point) -> [u8; 48] {\n        EncryptedLogHeader::new(context.this_address()).compute_ciphertext(secret, point)\n    }\n\n    // 64 bytes + 32 * #fields + 16 = 112 bytes\n    #[aztec(private)]\n    fn compute_incoming_log_body_ciphertext(\n        secret: Scalar,\n        point: Point,\n        storage_slot: Field,\n        value: Field\n    ) -> [u8; 112] {\n        let note = TestNote::new(value);\n        EncryptedLogIncomingBody::from_note(note, storage_slot).compute_ciphertext(secret, point).as_array()\n    }\n\n    #[aztec(private)]\n    fn compute_outgoing_log_body_ciphertext(\n        eph_sk: Scalar,\n        recipient: AztecAddress,\n        recipient_ivpk_app: Point,\n        ovsk_app: Scalar\n    ) -> [u8; 176] {\n        let eph_pk = eph_sk.derive_public_key();\n        EncryptedLogOutgoingBody::new(eph_sk, recipient, recipient_ivpk_app).compute_ciphertext(ovsk_app, eph_pk)\n    }\n\n    #[aztec(public)]\n    fn assert_public_global_vars(\n        chain_id: Field,\n        version: Field,\n        block_number: Field,\n        timestamp: u64,\n        fee_per_da_gas: Field,\n        fee_per_l2_gas: Field\n    ) {\n        assert(context.chain_id() == chain_id, \"Invalid chain id\");\n        assert(context.version() == version, \"Invalid version\");\n        assert(context.block_number() == block_number, \"Invalid block number\");\n        assert(context.timestamp() == timestamp, \"Invalid timestamp\");\n        assert(context.fee_per_da_gas() == fee_per_da_gas, \"Invalid fee per da gas\");\n        assert(context.fee_per_l2_gas() == fee_per_l2_gas, \"Invalid fee per l2 gas\");\n    }\n\n    #[aztec(private)]\n    fn assert_header_private(header_hash: Field) {\n        assert(context.historical_header.hash() == header_hash, \"Invalid header hash\");\n    }\n\n    // TODO(4840): add AVM opcodes for getting header (members)\n    //#[aztec(public)]\n    //fn assert_header_public(header_hash: Field) {\n    //    assert(context.historical_header.hash() == header_hash, \"Invalid header hash\");\n    //}\n\n    #[aztec(private)]\n    fn deploy_contract(target: AztecAddress) {\n        aztec_deploy_contract(&mut context, target);\n    }\n\n    #[aztec(private)]\n    // Adapted from TokenContract#redeem_shield but without an initcheck so it can be run in simulator/src/client/private_execution.test.ts\n    fn consume_note_from_secret(secret: Field) {\n        let notes_set = storage.example_set;\n        let secret_hash = compute_secret_hash(secret);\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TestNote::properties().value, secret_hash, Option::none()).set_limit(1);\n        let notes = notes_set.get_notes(options);\n        let note = notes.get_unchecked(0);\n        notes_set.remove(note);\n    }\n\n    unconstrained fn get_constant() -> pub Field {\n        let constant = storage.example_constant.view_note();\n        constant.value\n    }\n\n    // This function is used in the e2e_state_vars to test the SharedMutablePrivateGetter in isolation\n    #[aztec(private)]\n    fn test_shared_mutable_private_getter(\n        contract_address_to_read: AztecAddress,\n        storage_slot_of_shared_mutable: Field\n    ) -> Field {\n        // It's a bit wonky because we need to know the delay for get_current_value_in_private to work correctly\n        let test: SharedMutablePrivateGetter<AztecAddress, 5> = SharedMutablePrivateGetter::new(\n            &mut context,\n            contract_address_to_read,\n            storage_slot_of_shared_mutable\n        );\n\n        let ret = test.get_value_in_private(context.get_header());\n\n        ret.to_field()\n    }\n\n    // This function is used for testing the registry contract and fresh public key getters. If nothing exists in the registry, but we have added public\n    // keys to the pxe, this function will return nothing, but the public key getters will return the correct value\n    #[aztec(private)]\n    fn test_shared_mutable_private_getter_for_registry_contract(\n        storage_slot_of_shared_mutable: Field,\n        address_to_get_in_registry: AztecAddress\n    ) -> Field {\n        // We have to derive this slot to get the location of the shared mutable inside the Map\n        let derived_slot = derive_storage_slot_in_map(storage_slot_of_shared_mutable, address_to_get_in_registry);\n\n        // It's a bit wonky because we need to know the delay for get_current_value_in_private to work correctly\n        let registry_private_getter: SharedMutablePrivateGetter<Field, 5> = SharedMutablePrivateGetter::new(\n            &mut context,\n            AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n            derived_slot\n        );\n        registry_private_getter.get_value_in_private(context.get_header())\n    }\n\n    #[aztec(private)]\n    fn test_nullifier_key_freshness(address: AztecAddress, public_nullifying_key: Point) {\n        assert_eq(context.get_header().get_npk_m(&mut context, address), public_nullifying_key);\n    }\n\n    // Purely exists for testing\n    unconstrained fn get_random(kinda_seed: Field) -> pub Field {\n        kinda_seed * unsafe_rand()\n    }\n\n    struct DummyNote {\n        amount: Field,\n        secret_hash: Field\n    }\n\n    impl DummyNote {\n        fn new(amount: Field, secret_hash: Field) -> Self {\n            Self { amount, secret_hash }\n        }\n\n        fn get_commitment(self) -> Field {\n            pedersen_hash([self.amount, self.secret_hash], 0)\n        }\n    }\n\n    impl Serialize<2> for DummyNote {\n        fn serialize(self) -> [Field; 2] {\n            [self.amount, self.secret_hash]\n        }\n    }\n\n    struct DeepStruct {\n        a_field: Field,\n        a_bool: bool,\n        a_note: DummyNote,\n        many_notes: [DummyNote; 3],\n    }\n\n    // Serializing using \"canonical\" form. \n    // 1. Everything that fits in a field, *becomes* a Field\n    // 2. Strings become arrays of bytes (no strings here)\n    // 4. Arrays become arrays of Fields following rules 2 and 3 (no arrays here)\n    // 5. Structs become arrays of Fields, with every item defined in the same order as they are in Noir code, following rules 2, 3, 4 and 5 (recursive)\n    impl Serialize<10> for DeepStruct {\n        fn serialize(self) -> [Field; 10] {\n            let mut result = [0; 10];\n            result[0] = self.a_field;\n            result[1] = self.a_bool as Field;\n            result[2] = self.a_note.amount;\n            result[3] = self.a_note.secret_hash;\n            for i in 0..3 {\n                result[4 + i * 2] = self.many_notes[i].amount;\n                result[5 + i * 2] = self.many_notes[i].secret_hash;\n            }\n            result\n        }\n    }\n}\n"},"359":{"path":"/usr/src/noir-projects/noir-contracts/contracts/test_contract/src/test_note.nr","source":"use dep::aztec::{\n    note::{note_header::NoteHeader, note_interface::NoteInterface}, hash::pedersen_hash,\n    context::PrivateContext\n};\n\nglobal TEST_NOTE_LEN: Field = 1;\n// TEST_NOTE_LENGTH * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TEST_NOTE_BYTES_LENGTH: Field = 1 * 32 + 64;\n\n// A note which stores a field and is expected to be passed around using the `addNote` function.\n// WARNING: This Note is not private as it does not contain randomness and hence it can be easy to perform \n// serialized_note attack on it. This note has been developed purely for testing purposes so that it can easily be\n// manually added to PXE. Do not use for real applications.\n#[aztec(note)]\nstruct TestNote {\n    value: Field,\n}\n\nimpl NoteInterface<TEST_NOTE_LEN, TEST_NOTE_BYTES_LENGTH> for TestNote {\n\n    fn compute_note_hash_and_nullifier(self, _context: &mut PrivateContext) -> (Field, Field) {\n        // This note is expected to be shared between users and for this reason can't be nullified using a secret.\n        (0, 0)\n    }\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        // This note is expected to be shared between users and for this reason can't be nullified using a secret.\n        (0, 0)\n    }\n}\n\nimpl TestNote {\n    pub fn new(value: Field) -> Self {\n        TestNote { value, header: NoteHeader::empty() }\n    }\n}\n"},"44":{"path":"std/slice.nr","source":"use crate::append::Append;\n\nimpl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::unsafe::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"},"65":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::PrivateContext,\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}},\n    state_vars::{shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter}\n};\n\nglobal DELAY = 5;\n\n// docs:start:key-getters\ntrait KeyGetters {\n  fn get_npk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ivpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ovpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_tpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_npk_m_hash(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Field;\n}\n\nimpl KeyGetters for Header {\n    fn get_npk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, NULLIFIER_INDEX, self)\n    }\n\n    fn get_ivpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, INCOMING_INDEX, self)\n    }\n\n    fn get_ovpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, OUTGOING_INDEX, self)\n    }\n\n    fn get_tpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, TAGGING_INDEX, self)\n    }\n\n    fn get_npk_m_hash(self, context: &mut PrivateContext, address: AztecAddress) -> Field {\n        get_master_key(context, address, NULLIFIER_INDEX, self).hash()\n    }\n}\n// docs:end:key-getters\n\nfn get_master_key(\n    context: &mut PrivateContext,\n    address: AztecAddress,\n    key_index: Field,\n    header: Header\n) -> Point {\n    let key = fetch_key_from_registry(context, key_index, address, header);\n    if is_empty(key) {\n        // Keys were not registered in registry yet --> fetch key from PXE\n        let keys = fetch_and_constrain_keys(address);\n        // Return the corresponding to index\n        keys.get_key_by_index(key_index)\n    } else {\n        // Keys were registered --> return the key\n        key\n    }\n}\n\nfn fetch_key_from_registry(\n    context: &mut PrivateContext,\n    key_index: Field,\n    address: AztecAddress,\n    header: Header\n) -> Point {\n    let x_coordinate_map_slot = key_index * 2 + 1;\n    let y_coordinate_map_slot = x_coordinate_map_slot + 1;\n    let x_coordinate_derived_slot = derive_storage_slot_in_map(x_coordinate_map_slot, address);\n    let y_coordinate_derived_slot = derive_storage_slot_in_map(y_coordinate_map_slot, address);\n\n    let x_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        x_coordinate_derived_slot\n    );\n    let y_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        y_coordinate_derived_slot\n    );\n    let x_coordinate = x_coordinate_registry.get_value_in_private(header);\n    let y_coordinate = y_coordinate_registry.get_value_in_private(header);\n\n    Point::new(x_coordinate, y_coordinate, false)\n}\n\n// Passes only when keys were not rotated - is expected to be called only when keys were not registered yet\nfn fetch_and_constrain_keys(address: AztecAddress) -> PublicKeys {\n    let (public_keys, partial_address) = get_public_keys_and_partial_address(address);\n\n    let computed_address = AztecAddress::compute(public_keys.hash(), partial_address);\n\n    assert(computed_address.eq(address));\n\n    public_keys\n}\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n"},"89":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<N>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, N>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<N, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<N, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"95":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn block_number(self) -> Field {\n        block_number()\n    }\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<N>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<N>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, N>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N)\n}\n\nunconstrained fn storage_write<N>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<N>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<N>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}