{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"Auth","functions":[{"name":"do_private_authorized_thing","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"get_authorized_delay","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/72Yy44bRRSGy22PPTjj9m3sGd+vPbbHnkmygE2iLFnyCoibAAkRicsiiC1rJF6FJW/AW7BhgdiwQEJIUVLnnDr1d7snlioa2VK7q0/937lUVZdVXpqiMaf2MmZk3CeyFhObsr0V6HpmtCWdphCbgpoS6mQqcTJTnNuvaqKuonepg7klRSPWVBKNZsMUXbNCX0nkopShju5SR15NlnLd+O9o66SsqSxNgZyUTySydon7us/VSCXqvkpfSOGdJXqsww/s/YGIT534jHN5QC1gZ6KpSpPR5zArWmOUBDWgNaA1h34Hs6IxoySIgcZAY4dOYVa0zigJ6kDrQOsO/RJmRRuMkqABtAG04dCvYVa0ySgJmkCbQJtyzyP1cKR271FsTR/BrGiLURK0gLaAthz6FcyKthklQRtoG2g7n2jbJ3oAsdF+gFnRc0ZJcA70HOi5Qz+DWdEOoyToAO0A7Tj0U5gV7TJKgi7QLtAu3Wf0av2IF7PBoMHbqK9fl997fUWtx5LB54JDXWRDXQrclab20ABeQtTHCz4oc3Pg9EO3gYwKLKR9ckgXZ/xCnrRcYkaJynoILB2RGKlTI/TpTm/n81Raewm/V9D3yqUSyV5WxBZHzSeZvezijXtZN7uXvY+IF07c40wpdg9YDzPWc+j3MCva90X2U4MLtI/ZzCKNw4iN9gnMig4Y5TEEOgA6yEcb+K0hEKmHI2fhSCMciQ8jduQ+h1nRIaMDWd+KDoEO89GGfgsIRGqHEZvghzArKm8LCUZAR0BH+Wgjvw8HIr1wpHYYsTV9AbOiY0ZJMAY6BjrORxv7hXQAsdG+gVnRCaMkmACdAJ3ko038Sg9E2uHIeTjSCUeGR4nyFrW0wpHmYcSughcwKzpllARToFOg03y0qd9WApF+ONIMRxpHqeXsKIm1wpH7n0q7cD6GWdEZoySYAZ0BneWjzfzLEIjE4Ug/HGmGI62jIG8xYp17H2S7Cr6FWdE5oySYA50Dneejzf0PZCDSPEqUejjSP0otraMgk8MIzXThFxwqnjJ4xzlsnjmHzbPnsAWHWmRDLQWeS1N76NSyhOgKh5OVnMNWTr92h5+NnMM2ZKKLM/5ZnrRcYjaJyhIElo7Ipb4xPsIV3afW00+ptPYS9uewp3wILcbcTdeC/y/jgitipf+Zikt/RMMQVvaGEKUvULodmxOT/ZCXqoSpYiYqmh/XVM2OZX7A952ySpwuAajThJ1SRwKnqcFMMIsGTWKunpRSmgrmlTxs/VisMBbb7FisVzpH9LRKwWUfnpAdz/6v1OLZcR+dVZLteB3syJ1UmshiOnm19yFGFISuKtxcu0cJ9Fs2UMyLnv3FUIuVoHXBB2QfmIBUrum0En6JdsrA01Y0XLJYdzIuJTfiPIZF6EVYdsJb+hPX3LoLf+KKSRxS80aQG8KeaSq7LLKTSkqpKm4l8Bpeis7LQ6S05/8x+3/srpR/NklK1HwkyCPCGLlxVwq5QdB1ji46eh37ZXG3YMVT/CeVN7WNP5ZS3y7RgShhrcsaplE+Ie1fbm+6TXScS9x66AXs+x/Kkx7/dr6vWXUtI6q+N2ykjWtL2n+d75SWW2svKPt9iLc3ChXx3ke9/3Hkl1rV/xKH1uHau2HhK19S6pGyuLaPEf8wRDQTJXosvslNdMqPJ9lHuPFFoMpoQc3L3+l6DeB1EXWRGAAA","debug_symbols":"7Z3dThxHEIXfhWsrmj6nf/0qURThvwjJAsvgSJHld88S7w5YDN58MmXwDFdooau3q47ObM1H9+znkzdvX33668+z83cXlycvf/988v7i9enV2cX57tXnk+m3NP3328sPp+fXv7i8Ov14dfJyenHy9vzN7ueXFyfvzt6/PXlppS9/vLgOSDRANMA0INOAQgMqDWg0oP//gBd3xo1S9iNHa/PYJC2MzakdBufU8zx6lIXBVW77wVXFtwd/Xfb4kWWnydoPTVPJP3Phmn6o3iPdrLscWXdKKR9GpzZ9f90tz0m2kvrddaegdX+dXaGzO3T2HDp7CZ29hs7eQmfvobOPyNk9hc4e6lWHetWhXnWoVx3qVYd61aFedahXHerVHOrVHOrVHOrVHOrVHOrVHOrVHOrVHOrVHOrVHOrVEurVEurVEurVEurVEurVEurVEurVEurVEurVEurVGurVGurVGurVGurVGurVGurVGurVGurVGurVGurVFurVFurVFurVFurVFurVFurVFurVFurVFurVFurVHurVHurVHurVHurVHurVHurVHurVHurVHurVHurVEerVEerVEerVEerVEerVEerVEerVEerVEerVEerVNE2x06fY6RU7vWOnz7HTl9jpa+z0LXb6Hjt9rGtTrGtTrGtTrGtTrGtTrGtTrGtTrGtTrGtTrGtTrGsV69rY3UwpdjtTit3PlMiGpn0E3tcovLFReGcj2SC0jxg0wngbq/E+VvONrHgnq7Hmxpoba26subHmxppnrHnGmmeseea7l7HmGWueseYZa56x5hlrXrDmBWtesOYFa16w5gVrXrDmBWtesOYFa16x5hVrXrHmFWteseaVn1PAmlesecWaV6x5w5o3rHnDmjesecOaN6x544dTsOYNa96w5h1r3rHmHWveseYda96x5h1r3vmJJKx5x5oPrPnAmg+s+cCaD6z5wJoPrPnAmg+s+aCaa5pwRMIRwhHGERlHFBxRcUTDER1HYM3xMVPhc6bCB02FT5oKHzUVPmsqfNhU+LSpEtY8Yc2FNRfWXFhzYc0xhxPmcMIcTpjDCXM4YQ4nzOGEOZwwhxPmcMIcTpjDCXM4YQ4nzOGEOZwwhxPmcMIcTpjDCXM4YQ4nzOGEOZwwhxPmcMIcTpjDCXM4YQ4nzOGEOZwwhxPmcMIcTpjDCXM4YQ4nzOGEOZwwhxPmcMIcTpjDCXM4YQ4nzOGEOZwwhxPmcMIcTpjDCXM4YQ4nzOGEOZwwhxPmcMIcTpjDCXM4YQ4nzOGEOZwwhxPmcMIcTpjDCXM4YQ4nzOGEOZwwhxPmcMIcTpjDGXM4Yw5nzOGMOZwxhzPmcMYczpjDGXM4Yw5nzOGMOZwxhzPmcMYczpjDGXM4Yw5nzOGMOZwxhzPmcMYczpjDGXM4Yw5nzOGMOZwxhzPmcMYczpjDGXM4Yw5nzOGMOZwxhzPmcMYczpjDGXM4Yw5nzOGMOZwxhzPmcMYczpjDGXM4Yw5nzOGMOZwxhzPmcMYczpjDGXM4Yw5nzOGMOZwxhzPmcMYczpjDGXM4Yw5nzOGMOZwxhzPmcMYczpjDGXM4Yw5nzOGMOZwxhzPmcMYczpjDGXM4Yw5nzOGMOZwxhzPmcMYczpjDGXM4Yw5nzOGMOZwxhzPmcMYczpjDGXM4Yw5nzOGMOVzGHC5jDpeXOZzSNPZBSqV9E7fwaPLWD88xbz2leXSq09LT2ls5nG/Lrd6cb1t+Wnsb89Pa+8JTz/MyFfyR9fdv1r9/l/xT3qX8lHepD/AuXX1+l6Ijivdd77Qf3XeCHRm9uzge5t5dX/qR0SOPQ76j3Hqcv/Kcb9tYvn1j+Y5t5btM6lecb9pYvt5Yvnlj+ZaN5buxfiNtrN9IG/v81cY+f7Wxz19pY/lurN/QxvoNbazf0CP0Gznd5JuPjC72IYOy+4fP9/lXScOHwUpHBvcyzXUv+e5XG2a159LcV5r+XJr7SjOeS3NPaTw9l+a+0qSnXpo05tIc+/LVIR8GD+VbX6Rb5nS1rXS9rXTzttIt20r3yXeMD5vuk+8CUbqabtLt36R7d/Sulzl8r/juA+pm9HWd7uZY5hTHzZrlQxmffMf4S5QxP/kW6tco47rarUcr47rauEcr47raQ1RGu81lzOV2Gfe1yc+1ubc262o8H7Y26+pSWW1anmvTp4XabLildfNNbcZCbZ48vnu82pRVNZ+et36OPE0Ld35lVU3i8XRX1cwdT3dVTZe753STl9LN20p3Va2Ru+Z0paV0V0VXjqe7qg/po+nWVV2Zdy3WnG4bS+mu6sp8PN1VXZlz7nO6fYmn11Vdmcs8eJS8qO6q7kNLmtUtNS2lu6or89F026ruiEpqc7ptqWduq7oyl3kn3ajqS+mu6sp8PN11XZnno7Cjui6lu6orc20z6WmL97ttVdDveLqruiOqddyku+DdMj00q2rHthZL6XDbIt3+4tXrNe1e/X368ez01fu3l7uY6z9+On99dXZxvn959c+Hr3/Zjf0X"},{"name":"set_authorized_delay","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"new_delay","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"7Z3tjuTIcUXfZX4vDCYz8kuvYhjGSloZCwi7gnZlwBD07q6RmuweDEvsxpIZdzLPL48sTg3jHJEd97K66u+f/vjD7//2P//9409/+vmXT7/7z79/+vPPf/j+1x9//unxn/7+afmPEP75//3lL9//9Pn/8cuv3//110+/W7779MNPf3z833989+lPP/75h0+/i2v4x3999/kvrB/9C/Gjf8E++hfSR/9C/uhfKB/9C/Wjf6G9/y9899VxLaWXI1sp+7FhXQ+OtVC2gy1U249u6eDgvMbycnBeU3x78D9Pe11+y2mHJa4vh4YlWdcTD7+Jdwuv551OzjuEYNvRoSz//ryL7UOWFOrX573edN7/evV466vbra+ebn31fOurl1tfvd766u3OV4/Lra8ebn31W6/VeOu1Gm+9VuOt12q89VqNt16r8dZrNd56rdqt16rdeq3ardeq3Xqt2q3Xqt16rdqt16rdeq3ardeq3Xqtpluv1XTrtZpuvVbTrddquvVaTbdeq+nWazXdeq2mW6/VdOu1mm+9VvOt12q+9VrNt16r+dZrNd96reZbr9V867Wab71W863Xarn1Wi23Xqvl1mu13Hqtlluv1XLrtVpuvVbLrddqufVaLbdeq/XWa7Xeeq3WW6/Veuu1Wm+9Vuut12q99Vqtt16r9dZrtd56rbZbr9V267Xabr1W263Xarv1Wm23Xqvt1mu13Xqttluv1XbrtRqW5d6XD/e+/Hrvy8d7X97uffl078vne1++3Pvy9d6Xv/eqDfdeteHeqzbce9WGe6/acO9VG+69asO9V22496oN91614d6rdr33ql3vvWrvfTtTuPf9TOHeNzSF43c0ratt/8K6tnDyj5S1be+DK/88YvtX8nJwdI15O7raEk+OjrXVl6Nji/Xk6GZtextcS2/ekfcYZ5s3TzZvmWzeOtm8ba55j9+rN/C862TzxsnmtcnmnWzfiJPtG3Gyn79xsp+/NtnP3+N3BA8872T7hk22b9hk+4Y57BsWXue1k6NTjNsEKea2H334i3sptLgdvIaTg2tadu7Jvv7txGAZNM/QFNA8Q1NB8wxNA80TNGlRRxPajubs96fbGreD22pvfhc+7eOGucZd5xo3zjWuzTWu/MZ47bjyW+CHxl2X13HrF+N+fbStbftoEItvPgfjM6evZ0xbLint9ZzXuGGU3xi/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"},{"name":"get_authorized_in_private","is_unconstrained":false,"custom_attributes":["aztec(private)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"get_scheduled_authorized","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/+WYy27TQBSGJ5emDXFs59rcYyd2WrXdwgYJumLJKyBuKkgIBJQFvANrJB6FR+CpmHNmjn+7BktToQgJS7Yn//zfnDPjmZEmiWoodaRvpZbKXnWtKF+19KtG9wMlJVOpar6qiZRSJVOptanGRj/upNJU/S5VMBeQ1uTnwTmXqaTvVqJqhB4cUMsUmuVmQukpAtqppHeoWKSrTQ/jIewoQY1u8DGlYcyH1txJ60ZUHWAd42mbIqPvIAvqMUoGD6gH1LPoNWRBu4ySoQu0C7Rr0QiyoD6jZPCB+kB9i76GLGjAKBkCoAHQwKJvIQsaMkqGEGgINDTvMuK7I95fj6L79BSyoD1GydAD2gPas+gbyIL2GSVDH2gfaL+caD9LtALR0b5AFnTAKBkGQAdABxZ9CVnQIaNkGAIdAh1a9AVkQUeMkmEEdAR0RO+YltY1FmbIoMJqlOVHbpXKEtUtNhWuMYcaF0MdG3hkilJDU/AYpikW+KzFxZn1z+0GsqixcUES3Zzxe/NLukvMIhXbBIFNRd2IVCkRpvSm1XmVS+tGwvdqMgdtKk2zlzXsNtcy6MPCXjb+4142Ku5ljxBxbM0TzpRiT4BN8MUmFv0EWdBp1slpbnCBTvE1i0hQjehozyELOmOUxxDoDOisHG2WbQ2OiO+OdNyRwB3pViN65K4gCzpndGbmt6BzoPNytHm2BTgiXjWiE3wCWVCzWsiwALoAurDoR8iCLhklwxLoEuiynOgym0gViI72CrKgK0bJsAK6AroqR1tlI+mIDN2RiTvS+1f7MndHwr2MmOeO3GLCdKoRPT0/QBZ0zSgZ1kDXQNflaOtsv3NE+u7IwB0ZuiNdd2TqjoTuSLCXvnT2klivGtHT8zNkQSNGyRABjYBG5WhRNgwViI72DLKgMaNkiIHGQONytDibpo5I1x2ZuiOhO9LbC3KLERvuZZAX7oi3l+9yiyj+/z3H1tUIPWrfcUC6ZFAOSLkzZVw4U8bFM+WGQ22KobYGjk1RaugEtoUpxUFrZ86UO+s/sQe5U3OmPCWJbs74m/kl3SXmNBVbgsCmom5EqpQI1JNdpFv6mkvrRsLZmfLSeLiP2dg0MDab4uGxhT5tEv4nLX9RKzH/v8eR7Adp2GbanGxstmdpsJ2r/32j/F1Mo20AAm250XZx5Le5etNoLmnpbnK/mfOQmpSDk5ya4Ck+Kd1n2WjtMFpnxdE6Oannmt+h4gztnJupQST9cXnBc+AHlfgb5fLYWdsFz4YL7rySGcUlmkR1Fic/6f4FMz4HQoQVAAA=","debug_symbols":"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"},{"name":"get_authorized","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/72YyY4jRRCG03a7Zjxtl/ce72tV21Iv05fpCxJHjrwCYhMgASOxCA3iVbhx44gQ78BTkX9kRv4uV2MpRyOXVOWsyP+LyIxcVOnM1Ix5bm9j5sZfVWsxqUnsTwX3h0ZLrtJUUlNRU45KoXIvM7WNfbzI1VX1NSqEyxANrElyjVY3YsSV4JFXfZQ61dWn1NWghqXeNuFZvfFS0SSZqcBJve4ia5VzD6AR3D+j+wYebMLzjDXW4cfoohM/8+JLacsLlIhdOk3DFQV9Q7OiTUEhaBJtEm169CeaFW0JCkGLaItoy6MrmhVNBYUgJZoSTT36Dc2KtgWFoE20TbTt0e9pVrQjKAQdoh2iHfdbRtJ4pPneo9g+fUqzol1BIegS7RLtevRbmhXtCQpBj2iPaK/c0F5o6AnERvuVZkX7gkLQJ9on2vfolzQrOhAUggHRAdGBR7+gWdGhoBAMiQ6JDvG7xtL6jQuzI6DhatTlN5R1r0vUerwwvK4k1FUx1EsHD11RazAFX1I05gKfJFKceP3UbyCzighnMOGWFr91b9pdMLNcZSMGdhVVZ0SlRhjjF6vzzUGzjhr8WNE56JtSdXtZjVsciq8Le9nV/+5lw+Je9hEjXnnxSFqK2CNiI47YyKM/06zoOHRyfJBcomOOZhFpn0ZstM9pVnQiqOSQ6ITopBxtEraGSCSNRy7jkXY80jqN2Mx9RbOiU0Enbn4rOiU6LUebhi0gEmmeRmwDP6FZUbdaIJgRnRGdlaPNwj4ciYzikeZpxPbpa5oVnQsKwZzonOi8HG0eJtIJxEb7gWZFF4JCsCC6ILooR1uEmR6J9OKRfjwyiEda8cg4HunEI+2z9OXyLA3rnkbs9HxLs6JLQSFYEl0SXZajLUMaTiA22mc0K7oSFIIV0RXRVTnaKkzTSKQVj4zjkU480j0L8g4ZG7z3JNtZ8CPNiq4FhWBNdE10XY62Dtt9JNI5S5Q0HhmfpS/dsyCL0wgechDyn8iPAj5xqlgXThXr4qliI6E2xVBbB69dUWvwDb6lKOen9rU7VVx7/c5/yu/dqWIPE25p8S/uTbsLZp+rLGNgV1F1RlRqBPTk2k7zyncHzTpqcDhVPCKGqaVSjXsj//5IhxNnxWstCwcOpjA5SiG7vmHXbW7qpnjBS8OFaXAkEm2f9KlRzGU54cdOcW2d0y0BdZqJU1RkdHqQzIyjaFgEk39wcaBJ3LgeB5fUu+AYgesspPMmZGvHbN0Us7Xf6SjW3OQIcBIaCORW5sfvKMn4HQTfedmtzJTbYj9v6PHOeYS3O3vfi8c/UHrKI2T34vEeXpmUO3p85TzC2yt7P4jHP1F6yiNkD+LxAV7dBIPzncseNHtnxXS/T0IciPbi/G+UML//ktyisxd4/Sc3Po0Hrxi8Wq5NqG5RHP2L+z+08H3z/xQAAA==","debug_symbols":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2b3U7bQBCF18GhBoOb2HGckEAIBaTehRSScMfLtM/d60p9haqss6Mclmm0UcdLVool5LG9O+ebsz+EyERqfSSvP5GJ2+Z8rN4f1ObFnGf/dzwI5po1yRkFwtkKhPMoEM5YkDNiOPU5NrFed3rNfVLr9fjuIXbWA30Ez9W2RLZqYgJ8eC1V6Wr2fAzJEVwZ8Ng8o7PGSc0zBEtNkXUbuEeFtuAe6RzBPdrBSCcxpgjX+5RskOXyvs4+XcOJyUXcKcT4bAzWxQ3V2Jav8bGRMXn1rqExqVcx+d42uRO4pjE4NbHgb44H1I7Mz6k1F2KIR9CW2pEfLWDVx7narJfTLf1iq18GbY6hn7230DWNtfaqa2J9btOeAPkb8HCm86byed+MTWx5l0JNGXgioz1f6fxn6u0RWdfXEGfAcy7Os1578nWux+4zsMvkfXrUXnUsr84srzJogwydBvyLQJdy03WH0ZbzYrHS2l0HL7oMT9ezF11GW9CLZ62dO3iRMzy5Zy9yRlvOi+U3rV04eFEwPIVnLwpGW86Lef0ZoOfgRY/h6Xn2osdoC66Rel6UDl6UDE/p2YuS0Rb04ofW7jt40Wd4+p696DPagl5819qVgxcVw1N59qJitAX3zvrzxcDBiwHDM/DsxYDRFvRirrWHDl4MGZ6hZy+GjLbgGqm1Lxy8uGB4Ljx7QXq7MvcCZK4CZC72gDmxYhntRb1/jhy8GDE8I89e4HcuuzCXe8CcWLGM9uJJa48dvBgzPGPPXpDersx5gMxFgMz9AJnLAJmrAJn3YT4nViyjvaz30EsHLy4ZnkvPXpDersx5gMyjAJmLPWBOrFhGe1l/N3fl4MUVw3Pl2QvS25V5ECBzdw+YEyuW0V4utPbEwYsJwzPx7AXp7co8DJC5CpB5FCBzESBzP0DmMkDmwxr0w5zvATO+e/S7UZ75c2rxkGfKYlQWYwpxBozU9kXJva+SWbWT1lTcj/X42POFrqeNas9XOu+XBmrSeW/l89Z/I9yZXPQO3y3j1b2JI+FxuoO8EejQ/RjiX9CW2pEftB8Qu36X68bE91v6Tax+GbS5gX63Vj+6prHW3v00cVNzy2Ved9RmLX8Fngb2wUd8J1eBV8pipGMCPNfyPA8N1TnDd/j+KNm1N7W8OrG8yqAN7tEftW8emA/M/2LGzxMncA956F7LqgX/v2EKOf4CARQXTpY1AAA=","debug_symbols":"ndpBattQGIXRvWgciu9v6T0pWymlOIlTDMYOsVMoJnuv3NIF9Mz0JN3ZNzq82/Cyf/r48f1wej1fhsevt+F4ft5dD+fTeroNmy81/3l7edud7i8u1937dXjctv4w7E8v61Ovz4fh9XDcr8+Vz28P99ECo+1GRpFRyWgro1FGk4yajLqMpIitFDFKEaMUMUoRoxQxShGjFDFKEaMUMUoRoxQxSRGTFDFJEZMUMUkRkxQxSRGTFDFJEZMU0aSIJkU0KaJJEU2KaFJEkyKaFNGkiCZFdCmiSxFdiuhSRJciuhTRpYguRXQpoksRsxQxSxGzFDFLEbMUMUsRsxQxSxGzFDFLEYsUsUgRixSxSBGLFLFIEYsUsUgRixSxSBHZbGgVWhWttrQaaTXRqtGq02qmFbURaiPURqiNUBuhNkJthNoItRFqI9RGURtFbRS1UdRGURtFbRS1UdQGgWZINEOkGTLNEGqGVDPEmiHXDMFmSDZDtBmyzRBuhnQzxJsh3wwBZ0g4Q8QZMs4QcoaUM8ScIecMQWdIOkPUGbLOEHaGtDPEnSHvDIFnSDxD5BkyzxB6htQzxJ4h9wzBZ0g+Q/QZss8Qfob0M8SfIf8MAWhIQEMEGjLQEIKGFDTEoCEHDUFoSEJDFBqy0BCGhjQ0xKEhDw2BaEhEQyQaMtEQioZUNMSiIRctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLbvoSS5a5KJFLlrkokUuWuSiRS5a/+2i6+nn7v2wezru73d77x8/Ts//rvqux+uvt79f1n9/Aw=="},{"name":"set_authorized","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"authorized","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"}],"outputs":{"globals":{"storage":[{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"authorized","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Auth::get_authorized_in_private_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"new_delay","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"Auth::set_authorized_delay_parameters"}}],"kind":"struct","path":"Auth::set_authorized_delay_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"authorized","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Auth::set_authorized_parameters"}}],"kind":"struct","path":"Auth::set_authorized_abi"},{"fields":[{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Auth::get_authorized_abi"},{"fields":[{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"Auth::get_authorized_delay_abi"},{"fields":[],"kind":"struct","path":"Auth::do_private_authorized_thing_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Auth::constructor_parameters"}}],"kind":"struct","path":"Auth::constructor_abi"},{"fields":[{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Auth::get_scheduled_authorized_abi"}]}},"file_map":{"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"122":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::{compute_siloed_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_contract_initialization_nullifier(context.this_address());\n    let header = context.get_header();\n    header.prove_nullifier_inclusion(init_nullifier);\n}\n\nfn compute_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    compute_siloed_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(address)\n    )\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"123":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr","source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"},"127":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle<N>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<N>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<N>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n"},"128":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"132":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<N>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field\n) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number as Field, N)\n}\n\nunconstrained pub fn storage_read<T, N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"139":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"148":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr","source":"use crate::{\n    context::{PublicContext, UnconstrainedContext}, oracle::storage::storage_read,\n    state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like SharedImmutable but without the ability to read from private functions.\n// docs:start:public_immutable_struct\nstruct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\nimpl<T, Context> Storage<T> for PublicImmutable<T, Context> {}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl <T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UnconstrainedContext> {\n    unconstrained pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"155":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_delay_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initally equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation \n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the \n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a \n// reduced delay, invalidating prior private reads.\nstruct ScheduledDelayChange<INITIAL_DELAY> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option, \n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pre: Option<u32>,\n    post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numeric value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\nimpl<INITIAL_DELAY> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior contraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This \n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is \n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in \n            //                             which to scheduled value change\n\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY)\n            )\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Serialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn serialize(self) -> [Field; 1] {\n        // We pack all three u32 values into a single U128, which is made up of two u64 limbs.\n        // Low limb: [ pre_inner: u32 | post_inner: u32 ]\n        // High limb: [ empty | pre_is_some: u8 |  post_is_some: u8 | block_of_change: u32 ]\n\n        let lo = ((self.pre.unwrap_unchecked() as u64) * (1 << 32))\n            + (self.post.unwrap_unchecked() as u64);\n\n        let hi = (self.pre.is_some() as u64) * (1 << 33) \n            + (self.post.is_some() as u64 * (1 << 32)) \n            + self.block_of_change as u64;\n\n        let packed = U128::from_u64s_le(lo, hi);\n\n        [packed.to_integer()]\n    }\n}\n\nimpl<INITIAL_DELAY> Deserialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn deserialize(input: [Field; 1]) -> Self {\n        let packed = U128::from_integer(input[0]);\n\n        // We use division and modulo to clear the bits that correspond to other values when unpacking.\n\n        let pre_is_some = ((packed.hi as u64) / (1 << 33)) as bool;\n        let pre_inner = ((packed.lo as u64) / (1 << 32)) as u32;\n\n        let post_is_some = (((packed.hi as u64) / (1 << 32)) % (1 << 1)) as bool;\n        let post_inner = ((packed.lo as u64) % (1 << 32)) as u32;\n\n        let block_of_change = ((packed.hi as u64) % (1 << 32)) as u32;\n\n        Self {\n            pre: if pre_is_some { Option::some(pre_inner) } else { Option::none() },\n            post: if post_is_some { Option::some(post_inner) } else { Option::none() },\n            block_of_change,\n            _dummy: [0; INITIAL_DELAY],\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"159":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_value_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\nstruct ScheduledValueChange<T> {\n    pre: T,\n    post: T,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Serialize<3> for ScheduledValueChange<T> {\n    fn serialize(self) -> [Field; 3] where T: ToField {\n        [self.pre.to_field(), self.post.to_field(), self.block_of_change.to_field()]\n    }\n}\n\nimpl<T> Deserialize<3> for ScheduledValueChange<T> {\n  fn deserialize(input: [Field; 3]) -> Self  where T: FromField {\n    Self {\n        pre: FromField::from_field(input[0]),\n        post: FromField::from_field(input[1]),\n        block_of_change: FromField::from_field(input[2]),\n    }\n  }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>  {\n    fn eq(self, other: Self) -> bool where T: Eq {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"160":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable.nr","source":"use dep::protocol_types::{\n    hash::{pedersen_hash, poseidon2_hash}, header::Header, address::AztecAddress,\n    traits::{FromField, ToField}\n};\n\nuse crate::context::{PrivateContext, PublicContext};\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{scheduled_value_change::ScheduledValueChange, scheduled_delay_change::ScheduledDelayChange}\n};\nuse crate::oracle::storage::storage_read;\nuse dep::std::unsafe::zeroed;\n\nmod test;\n\nstruct SharedMutable<T, INITIAL_DELAY, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Serialize<N> trait, and allocate N storage slots to\n// this state variable. This is incorrect, since what we actually store is:\n//  - a ScheduledValueChange<T>, which requires 1 + 2 * M storage slots, where M is the serialization length of T\n//  - a ScheduledDelayChange, which requires another storage slot\n//\n// TODO https://github.com/AztecProtocol/aztec-packages/issues/5736: change the storage allocation scheme so that we\n// can actually use it here\nimpl<T, INITIAL_DELAY, Context> Storage<T> for SharedMutable<T, INITIAL_DELAY, Context> {}\n\n// TODO: extract into a utils module once  we can do arithmetic on generics, i.e. https://github.com/noir-lang/noir/issues/4784\nfn concat_arrays<N, M, O>(arr_n: [Field; N], arr_m: [Field; M]) -> [Field; O] {\n    assert_eq(N + M, O);\n    let mut out: [Field; O] = [0; O];\n    for i in 0..N {\n        out[i] = arr_n[i];\n    }\n    for i in 0..M {\n        out[N+i] = arr_m[i];\n    }\n    out\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, INITIAL_DELAY, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    fn hash_scheduled_data(\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) -> Field where T: ToField {\n        // TODO(#5491 and https://github.com/noir-lang/noir/issues/4784): update this so that we don't need to rely on\n        // ScheduledValueChange serializing to 3 and ScheduledDelayChange serializing to 1\n        let concatenated: [Field; 4] = concat_arrays(value_change.serialize(), delay_change.serialize());\n        poseidon2_hash(concatenated)\n    }\n\n    // Since we can't rely on the native storage allocation scheme, we hash the storage slot to get a unique location in\n    // which we can safely store as much data as we need.\n    // See https://github.com/AztecProtocol/aztec-packages/issues/5492 and\n    // https://github.com/AztecProtocol/aztec-packages/issues/5736\n    // We store three things in public storage:\n    //  - a ScheduledValueChange\n    //  - a ScheduledDelaChange\n    //  - the hash of both of these (via `hash_scheduled_data`)\n    fn get_value_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 0], 0)\n    }\n\n    fn get_delay_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 1], 0)\n    }\n\n    fn get_hash_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 2], 0)\n    }\n\n    // It may seem odd that we take a header and address instead of reading from e.g. a PrivateContext, but this lets us\n    // reuse this function in SharedMutablePrivateGetter.\n    fn historical_read_from_public_storage(\n        self,\n        header: Header,\n        address: AztecAddress\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) where T: FromField + ToField + Eq {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for both the ScheduledValueChange and\n        // ScheduledDelayChange, but that'd require one full sibling path per storage slot (since due to kernel siloing\n        // the storage is not contiguous), and in the best case in which T is a single field that'd be 4 slots.\n        // Instead, we get an oracle to provide us the correct values for both the value and delay changes, and instead\n        // prove inclusion of their hash, which is both a much smaller proof (a single slot), and also independent of\n        // the size of T.\n        let (value_change_hint, delay_change_hint) = get_public_storage_hints(address, self.storage_slot, historical_block_number);\n\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let hash = header.public_storage_historical_read(self.get_hash_storage_slot(), address);\n\n        // @todo This is written strangely to bypass a formatting issue with the if that is breaking ci.\n        let (a, b, c) = if hash != 0 {\n            let a = SharedMutable::hash_scheduled_data(value_change_hint, delay_change_hint);\n            (a, value_change_hint, delay_change_hint)\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized, meaning no value or delay change was ever\n            // scheduled. Therefore, the hints must then correspond to uninitialized scheduled changes.\n            let b = ScheduledValueChange::deserialize(zeroed());\n            let c = ScheduledDelayChange::deserialize(zeroed());\n            (hash, b, c)\n        };\n\n        assert_eq(hash, a, \"Hint values do not match hash\");\n        assert_eq(value_change_hint, b, \"Non-zero value change for zero hash\");\n        assert_eq(delay_change_hint, c, \"Non-zero delay change for zero hash\");\n\n        (value_change_hint, delay_change_hint, historical_block_number)\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PublicContext> {\n    pub fn schedule_value_change(self, new_value: T) where T: ToField {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) where T: ToField {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value_in_public(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay_in_public(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value_in_public(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay_in_public(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        self.context.storage_read(self.get_delay_change_storage_slot())\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) where T: ToField {\n        // Whenever we write to public storage, we write both the value change and delay change as well as the hash of\n        // them both. This guarantees that the hash is always kept up to date.\n        // While this makes for more costly writes, it also makes private proofs much simpler because they only need to\n        // produce a historical proof for the hash, which results in a single inclusion proof (as opposed to 4 in the\n        // best case scenario in which T is a single field). Private shared mutable reads are assumed to be much more\n        // frequent than public writes, so this tradeoff makes sense.\n        self.context.storage_write(self.get_value_change_storage_slot(), value_change);\n        self.context.storage_write(self.get_delay_change_storage_slot(), delay_change);\n        self.context.storage_write(\n            self.get_hash_storage_slot(),\n            SharedMutable::hash_scheduled_data(value_change, delay_change)\n        );\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext> {\n    pub fn get_current_value_in_private(self) -> T where T: FromField + ToField + Eq {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n\n        let (value_change, delay_change, historical_block_number) = self.historical_read_from_public_storage(self.context.get_header(), self.context.this_address());\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n}\n\nunconstrained fn get_public_storage_hints<T, INITIAL_DELAY>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>) {\n    // This function cannot be part of the &mut PrivateContext impl because that'd mean that by passing `self` we'd also\n    // be passing a mutable reference to an unconstrained function, which is not allowed. We therefore create a dummy\n    // state variable here so that we can access the methods to compute storage slots. This will all be removed in the\n    // future once we do proper storage slot allocation (#5492).\n    let dummy = SharedMutable::new((), storage_slot);\n\n    (\n        storage_read(address, dummy.get_value_change_storage_slot(), block_number), storage_read(address, dummy.get_delay_change_storage_slot(), block_number)\n    )\n}\n"},"192":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr","source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n  fn eq(self, other: Self) -> bool {\n    (self.nullifier == other.nullifier) &\n    (self.next_nullifier == other.next_nullifier) &\n    (self.next_index == other.next_index)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"193":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"22":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"235":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<N> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<N> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<N> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<N> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"238":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"247":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"25":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n#[no_predicates]\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    let value = pedersen_commitment_with_separator(input, 0);\n    if (value.x == 0) & (value.y == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value.x, y: value.y, is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        points[i] = EmbeddedCurveScalar::from_field(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let values = multi_scalar_mul(generators, points);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: values[2] as bool }\n}\n\n#[no_predicates]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let v1 = pedersen_commitment_with_separator(input, separator);\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    multi_scalar_mul(\n        [length_generator[0], v1],\n        [EmbeddedCurveScalar { lo: N as Field, hi: 0 }, EmbeddedCurveScalar { lo: 1, hi: 0 }]\n    )[0]\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n#[test]\nfn assert_pedersen_noir() {\n    // TODO: make this a fuzzer test once fuzzer supports curve-specific blackbox functions.\n    let input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq(pedersen_hash_with_separator(input, 4), pedersen_hash_with_separator_noir(input, 4));\n    assert_eq(pedersen_commitment_with_separator(input, 4), pedersen_commitment_with_separator_noir(input, 4));\n}\n"},"263":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"273":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"32":{"path":"std/merkle.nr","source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n"},"321":{"path":"/usr/src/noir-projects/noir-contracts/contracts/auth_contract/src/main.nr","source":"// Test contract showing basic public access control that can be used in private. It uses a SharedMutable state variable to\n// publicly store the address of an authorized account that can call private functions.\ncontract Auth {\n    use dep::aztec::protocol_types::address::AztecAddress;\n    use dep::aztec::state_vars::{PublicImmutable, SharedMutable};\n\n    // Authorizing a new address has a certain block delay before it goes into effect.\n    global CHANGE_AUTHORIZED_DELAY_BLOCKS = 5;\n\n    #[aztec(storage)]\n    struct Storage {\n        // Admin can change the value of the authorized address via set_authorized()\n        admin: PublicImmutable<AztecAddress>,\n        // docs:start:shared_mutable_storage\n        authorized: SharedMutable<AztecAddress, CHANGE_AUTHORIZED_DELAY_BLOCKS>, \n        // docs:end:shared_mutable_storage\n    }\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.initialize(admin);\n    }\n\n    // docs:start:shared_mutable_schedule\n    #[aztec(public)]\n    fn set_authorized(authorized: AztecAddress) {\n        assert_eq(storage.admin.read(), context.msg_sender(), \"caller is not admin\");\n        storage.authorized.schedule_value_change(authorized);\n        // docs:end:shared_mutable_schedule\n    }\n\n    // docs:start:public_getter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn get_authorized() -> AztecAddress {\n        // docs:start:shared_mutable_get_current_public\n        storage.authorized.get_current_value_in_public()\n        // docs:end:shared_mutable_get_current_public\n    }\n    // docs:end:public_getter\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn get_scheduled_authorized() -> AztecAddress {\n        // docs:start:shared_mutable_get_scheduled_public\n        let (scheduled_value, _block_of_change): (AztecAddress, u32) = storage.authorized.get_scheduled_value_in_public();\n        // docs:end:shared_mutable_get_scheduled_public\n        scheduled_value\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn get_authorized_delay() -> pub u32 {\n        storage.authorized.get_current_delay_in_public()\n    }\n\n    #[aztec(public)]\n    fn set_authorized_delay(new_delay: u32) {\n        storage.authorized.schedule_delay_change(new_delay);\n    }\n\n    #[aztec(private)]\n    fn do_private_authorized_thing() {\n        // Reading a value from authorized in private automatically adds an extra validity condition: the base rollup\n        // circuit will reject this tx if included in a block past the block horizon, which is as far as the circuit can\n        // guarantee the value will not change from some historical value (due to CHANGE_AUTHORIZED_DELAY_BLOCKS).\n        // docs:start:shared_mutable_get_current_private\n        let authorized = storage.authorized.get_current_value_in_private();\n        // docs:end:shared_mutable_get_current_private\n        assert_eq(authorized, context.msg_sender(), \"caller is not authorized\");\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn get_authorized_in_private() -> AztecAddress {\n        storage.authorized.get_current_value_in_private()\n    }\n}\n"},"38":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"4":{"path":"std/cmp.nr","source":"// docs:start:eq-trait\ntrait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\nimpl Eq for Field { fn eq(self, other: Field) -> bool { self == other } }\n\nimpl Eq for u64 { fn eq(self, other: u64) -> bool { self == other } }\nimpl Eq for u32 { fn eq(self, other: u32) -> bool { self == other } }\nimpl Eq for u8 { fn eq(self, other: u8) -> bool { self == other } }\nimpl Eq for u1 { fn eq(self, other: u1) -> bool { self == other } }\n\nimpl Eq for i8 { fn eq(self, other: i8) -> bool { self == other } }\nimpl Eq for i32 { fn eq(self, other: i32) -> bool { self == other } }\nimpl Eq for i64 { fn eq(self, other: i64) -> bool { self == other } }\n\nimpl Eq for () { fn eq(_self: Self, _other: ()) -> bool { true } }\nimpl Eq for bool { fn eq(self, other: bool) -> bool { self == other } }\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3) & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\nstruct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n// docs:start:ord-trait\ntrait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"47":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"80":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n"},"81":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr","source":"use std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext, oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: Header, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for Header {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier);\n\n        // 2) Check that the witness we obtained matches the nullifier\n        assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n        // 3) Compute the nullifier tree leaf\n        let nullifier_leaf = witness.leaf_preimage.hash();\n\n        // 4) Prove that the nullifier is in the nullifier tree\n        assert(\n            self.state.partial.nullifier_tree.root\n            == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n        );\n        // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n        //     was included in the nullifier tree.\n    }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, N, M>(header: Header, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M>;\n}\n\nimpl ProveNoteIsNullified for Header {\n    // docs:start:prove_note_is_nullified\n    fn prove_note_is_nullified<Note, N, M>(self, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M> {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n    // docs:end:prove_note_is_nullified\n}\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"95":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn block_number(self) -> Field {\n        block_number()\n    }\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<N>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<N>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, N>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N)\n}\n\nunconstrained fn storage_write<N>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<N>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<N>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}