{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"AuthWitTest","functions":[{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2b3U7bQBCF18GhBoOb2HGckEAIBaTehRSScMfLtM/d60p9haqss6Mclmm0UcdLVool5LG9O+ebsz+EyERqfSSvP5GJ2+Z8rN4f1ObFnGf/dzwI5po1yRkFwtkKhPMoEM5YkDNiOPU5NrFed3rNfVLr9fjuIXbWA30Ez9W2RLZqYgJ8eC1V6Wr2fAzJEVwZ8Ng8o7PGSc0zBEtNkXUbuEeFtuAe6RzBPdrBSCcxpgjX+5RskOXyvs4+XcOJyUXcKcT4bAzWxQ3V2Jav8bGRMXn1rqExqVcx+d42uRO4pjE4NbHgb44H1I7Mz6k1F2KIR9CW2pEfLWDVx7narJfTLf1iq18GbY6hn7230DWNtfaqa2J9btOeAPkb8HCm86byed+MTWx5l0JNGXgioz1f6fxn6u0RWdfXEGfAcy7Os1578nWux+4zsMvkfXrUXnUsr84srzJogwydBvyLQJdy03WH0ZbzYrHS2l0HL7oMT9ezF11GW9CLZ62dO3iRMzy5Zy9yRlvOi+U3rV04eFEwPIVnLwpGW86Lef0ZoOfgRY/h6Xn2osdoC66Rel6UDl6UDE/p2YuS0Rb04ofW7jt40Wd4+p696DPagl5819qVgxcVw1N59qJitAX3zvrzxcDBiwHDM/DsxYDRFvRirrWHDl4MGZ6hZy+GjLbgGqm1Lxy8uGB4Ljx7QXq7MvcCZK4CZC72gDmxYhntRb1/jhy8GDE8I89e4HcuuzCXe8CcWLGM9uJJa48dvBgzPGPPXpDersx5gMxFgMz9AJnLAJmrAJn3YT4nViyjvaz30EsHLy4ZnkvPXpDersx5gMyjAJmLPWBOrFhGe1l/N3fl4MUVw3Pl2QvS25V5ECBzdw+YEyuW0V4utPbEwYsJwzPx7AXp7co8DJC5CpB5FCBzESBzP0DmMkDmwxr0w5zvATO+e/S7UZ75c2rxkGfKYlQWYwpxBozU9kXJva+SWbWT1lTcj/X42POFrqeNas9XOu+XBmrSeW/l89Z/I9yZXPQO3y3j1b2JI+FxuoO8EejQ/RjiX9CW2pEftB8Qu36X68bE91v6Tax+GbS5gX63Vj+6prHW3v00cVNzy2Ved9RmLX8Fngb2wUd8J1eBV8pipGMCPNfyPA8N1TnDd/j+KNm1N7W8OrG8yqAN7tEftW8emA/M/2LGzxMncA956F7LqgX/v2EKOf4CARQXTpY1AAA=","debug_symbols":"ndpBattQGIXRvWgciu9v6T0pWymlOIlTDMYOsVMoJnuv3NIF9Mz0JN3ZNzq82/Cyf/r48f1wej1fhsevt+F4ft5dD+fTeroNmy81/3l7edud7i8u1937dXjctv4w7E8v61Ovz4fh9XDcr8+1/fz2cB8tMNpuZBQZlYy2MhplNMmoyajLSIrYShGjFDFKEaMUMUoRoxQxShGjFDFKEaMUMUoRkxQxSRGTFDFJEZMUMUkRkxQxSRGTFDFJEU2KaFJEkyKaFNGkiCZFNCmiSRFNimhSRJciuhTRpYguRXQpoksRXYroUkSXIroUMUsRsxQxSxGzFDFLEbMUMUsRsxQxSxGzFLFIEYsUsUgRixSxSBGLFLFIEYsUsUgRixSRzYZWoVXRakurkVYTrRqtOq1mWlEboTZCbYTaCLURaiPURqiNUBuhNkJtFLVR1EZRG0VtFLVR1EZRG0VtEGiGRDNEmiHTDKFmSDVDrBlyzRBshmQzRJsh2wzhZkg3Q7wZ8s0QcIaEM0ScIeMMIWdIOUPMGXLOEHSGpDNEnSHrDGFnSDtD3BnyzhB4hsQzRJ4h8wyhZ0g9Q+wZcs8QfIbkM0SfIfsM4WdIP0P8GfLPEICGBDREoCEDDSFoSEFDDBpy0BCEhiQ0RKEhCw1haEhDQxwa8tAQiIZENESiIRMNoWhIRUMsGnLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0bKLnuSiRS5a5KJFLlrkokUuWuSi9d8uup5+7t4Pu6fj/n639/7x4/T876rverz+evv7Zf33Nw=="},{"name":"consume","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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92y12ETZtl5somRbL9bIQR3Bp8uLix3WQT0KGNYVPQqI7XTm5xDjc9lvfztmH7fiVW5styMvN7bfkZcb2/HIy43teeTlxnY96nKDT6OXlxvb+cjLje2T5OV6uargU97l5Xq5quAT2eXlermq4NPT5eV6uargk87l5Xq5quBTyeXlermq4BPE5eV6uarg077l5Xq5quCTueXlermq4FO05eV6uargE6/l5Xq5quDTqeXlermq4JOk5eV6uargU5/l5Xq5quATmuXlermq4HN03yq39puPI/gcXXGxiZ7K1W8sBp+yqi02+IxVcbGJnsf1YhNl3HqxiRJuvdhM92y12Ez3bLXYRNm2XmyiZFsv1slBBZ+oqi02+DzV3xT7KGBYV/QoILbTKXN5FLDutf0t0/o4xrSWl//cYjsdcbHFqdjYTkdcbGynIy42ttMRFxvb6YiLje10tMUGn3EqLja2KxIX6+Sggk83FRdbnIp1clDB55qKi3VyUMFnmoqLdXJQweeZiot1clDBZ5mKi3VyUEdxKtbJQQWfUSsu1slBHU4OKvj0YW2xwacPi4t1clDBpw+Li3VyUMGnD4uLdXJQwacPi4t1clDBpw+LizVyUGfw6cPiYo0c1Bl8UrG4WCMHdd6KU7FGDuoMPs9YXKyRgzqDzzIWF+vkoILPMRYX6+Sggs8wFheb6Oqp/YL5DD7yVVts8JGg7xVb+f3NGXwgqLjYRA+oerGJIl692OJUbKKIVy820z1bLTbTPVstNlHEqxebKOJViw0+/lNcrJODCj768zfFPgoY1hU9CiihC9hu66OA7aytv5xu+zNl345vr97OZ7mxvY683NhuR15ubL8jLze245GXG9vzqMsNPp5TXm5s3yMvN7bzkZcb2yfJyy1e5Xq5quLlqoqXqwo+XlderperCj5iV16ul6sKPmZXXq6Xqwo+alderperCj5uV16ul6sKPnJXXq6Xqwo+dlderperCj7SV16ul6sKPtZXXq6Xqwo+2lderperCj7eV16ul6sKPuJXXq6Xqwo+5ldebqJ7t/qbj+DjYMXFJnoqV7+xGHxoqLjYRE/kerGJnsf1YhNl3HqxxanYTPdstdhM92y12ETZtl5somRbL9bJQQUfGioudlgH9ShgWFf0KCC209nnZwHHXFt/OZV5e5y6/OOkj1cf5Vlu8So3ttuRlxvb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P6zmnh9Wc88Pq7nnh9Xc88Nq7vlhNff8sJp7fljNPT+s5p4fVnPPD6u554fV3PPDau75YTX3/LCae35YzT0/rOaeH1Zzzw+rueeH1dzzw2ru+WE19/ywmnt+WM09P6zmnh9Wc88Pq7nnh9Xc88Nq7vlhNff8sJp7fljNPT+s5p4fVnPPD6u554fV3PPDau75YTX3/LCae35YzT0/rOaeH1Zzzw+rueeH1dzzw2ru+WE19/ywmnt+WM09P6zmnh9Wc88Pq7nnh9Xc88Nq7vlhNff8sJp7fljNPT+s5p4fVnPPD6u554fV3PPDau75YTX3/LCae35YzT0/rOaeH1Zzzw+rueeH1dzzw2ru+WE19/ywmnt+WM09P6zmnh9Wc88Pq7nnh9Xc88Nq7vlpNff8tJp7flrNPT+t5p6ft2JVrZOXOq3mnp9Wc89Pq7nnp9Xc89Nq7vlpNff8tJp7flrNPT+t5p6fVnPPT6u556fV3PPTau75aTX3/LSae35azT0/reaen1Zzz0+rueen1dzz02ru+Wk19/y0mnt+Ws09P63mnp9Wc89Pq7nnp9Xc89Nq7vlpNff8tJp7flrNPT+t5p6fVnPPT6u556fV3PPTau75aTX3/LSae35azT0/reaen1Zzz0+rueen1dzz02ru+Wk19/y0mnt+Ws09P63mnp9Wc89Pq7nnp9Xc89Nq7vlpNff8tJp7flrNPT+t5p6fVnPPT6u556fV3PPTau75aTX3/LSae35azT0/reaen1Zzz0+rueen1dzz02ru+Wk19/y0mnt+Ws09P63mnp9Wc89Pq7nnp9Xc89Nq7vlpNff8tJp7flrNPT+t5p6fVnPPT6u556fV3PPTau75aTX3/LSae35azT0/reaen1Zzz0+rueen1dzz02ru+ek093y/Oc09v1dr5KXu1Rp5qXu1Rl7qXm2xqtbIS92rNfJS92qNvNS9WiMvda/Wyks5zT2/V2vlpZzmnt+rtfJSTnPP79VaeSmnuef3aq28lNPc83u1Vl7Kae75vVorL+U09/xerZWXcpp7fq/Wyks5zT2/V2vlpZzmnt+rtfJSTnPP79VaeSmnuef3aq28lNPc83u1Vl7Kae75vVorL+U09/xerZWXcpp7fq/Wyks5zT2/V2vlpZzmnt+rtfJSTnPP79VaeSmnuef3aq28lNPc83u1Vl7Kae75vVorL+U09/xerZWXcpp7fq/Wyks5zT2/V2vlpZzmnt+rtfJSTnPP79VaeSmnuef3aq28lNPc83u1Vl7Kae75vVorL+U09/xerZWXcpp7fq/Wyks5zT2/V2vlpZzmnt+rtfJSTnPP79VaeSmnuef3aq28lNPc83u1Vl7Kae75vVorL+U09/xerZWXcpp7fq/Wyks5zT2/V2vlpZzmnt+rtfJSTnPP79VaeSmnuef3aq28lNPc83u1Tl5qspp7PlnNPZ+s5p5PVnPP77VYVevkpSarueeT1dzzyWru+WQ193yymns+Wc09n6zmnk9Wc88nq7nnk9Xc88lq7vlkNfd8spp7PlnNPZ+s5p5PVnPPJ6u555PV3PPJau75ZDX3fLKaez5ZzT2frOaeT1ZzzyerueeT1dzzyWru+WQ193yymns+Wc09n6zmnk9Wc88nq7nnk9Xc88lq7vlkNfd8spp7PlnNPZ+s5p5PVnPPJ6u555PV3PPJau75ZDX3fLKaez5ZzT2frOaeT1ZzzyerueeT1dzzyWru+WQ193yymns+Wc09n6zmnk9Wc88nq7nnk9Xc88lq7vlkNfd8spp7PlnNPZ+s5p5PVnPPJ6u555PV3PPJau75ZDX3fLKaez5ZzT2frOaeT1ZzzyerueeT1dzzyWru+WQ193yymns+Wc09n6zmnk9Wc88nq7nnk9Xc88lq7vmUaTb2/dS356nns/Le75xjWZb114uX5Zi+znGWv/nO821+vHi+7d/Zna/e+Tif7zxX3nkt86/XrmV5rX0i94H2b2qfyIuh/ZvaF7S31T6RT0f7N7VPlFrQ/k3tE2U4tH9T+0SJFu3f1D7RZyVo/5b2c6bNJGj/pvb09Xy1p6+XVfvjAWM919fa09fz1b6gva329PV8taevl1X7/Uv77bX29PV8taev56s9fT1b7TNtyUP7N7Wnr+erPX29rNqvj+/prtv+Wnv6er7aF7S31Z6+nq/29PV8taev56s9fT1f7enr2WqfaWMz2r+pPX09X+3p6/lqT1/PV/uC9rba09fz1Z6+nq/29PV8taev56s9fT1b7Rf6er7a09fz1Z6+nq/29PV8tS9ob6s9fT1f7enr+WpPX89Xe/p6vtrT17PVvtDX89Wevp6v9vT1fLWnr+erfUF7W+3p6/lqT1/PV3v6er7a09fz1Z6+nq32K309X+3J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P/8x+PnPsc/fYUeP9vzT4OefBz//Mvj5B79/59j3b+0XqWWOff/Wzx/7/q2fP/b9Wz9/7Pu39qu3ssS+f+vnj33/1s8f+/6tnz/2/Vs/f+z7t37+2Pdvtf+wxL5/6+ePff/Wzx/7/q2fP/b9Wz1/iX3/1s8f+/6tnz/2/Vs/f+z7t37+2Pdv/fyD379l8Pu3DH7/lsHv3zL4/bsOfv+ug9+/6+D37zr4/dthxrv2/IPfv+vg9+86+P27Dn7/roPfv9vg9+82+P27DX7/boPfvx3mS2vPP/j9uw1+/26D37/b4PfvNvj9uw9+/+6D37/74PfvPvj9q5lTOj2ONE9bUZ6/+v0rzTTRjuc/Bj//Ofb5NfMzO55/Gvz88+DnXwY/fxn8/Ovg5x/8/j1i37/V768ese/f+vlj37/V85+x79/6+WPfv9XvT56x79/6+WPfv/Xzx75/6+ePff/Wzx/7/q2fP/b9W+0/nLHv3/r5Y9+/tfOvt9j3b/38se/f+vlj37/188e+f+vnj33/1s8f+/6tnz/2/Vs//9j373ob+/5db4Pfv9Pg9+80+P07DX7/ToPfv5r5Sx3PP/j9Ow1+/06D37/T4PfvNPj9Ow9+/86D37/z4PfvPPj9q5m/1PH8g9+/8+D37zz4/TsPfv/Og9+/y+D37zL4/bsMfv8ug9+/mvlLHc8/+P0rmf9zK+vj/Lfzpjx/7ftXq2T+T8fzS+b/9Dz/NPj558HPvwx+/jL4+dfBz78Nfv598PMPfv+W2Pdv7fur6xr7/q2fP/b9Wz9/7Pu3fv7Y92/t+5OrZP5Pz/PHvn/r5499/9bPH/v+rZ8/9v1bP3/s+7faf9hi37/188e+f+vnj33/1s8f+/6tnz/2/Vs/f+z7t37+2Pdv/fyx79/6+WPfv/XzD37/7oPfv/vg9+8++P27D37/7oPfv/vg9+8++P27D37/7oPfv/vg9+8x+P17DH7/HoPfv8fg969k/lLP8w9+/x6D37/H4PfvMfj9ewx+/56D37/n4PfvOfj9ew5+/0rmL/U8/+D37zn4/XsOfP/etn//+ueby/E4T5nOr8PP++OPvf7VZP2PTX/tj81/7Y8tb/6x+//2f/3H/+O//Mf/5b/+5/9+/xP/+D/+n//8v/7Lf/lv//zrf/2X//t//3//L/fX/j8="},{"name":"consume_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"}],"outputs":{"globals":{},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"inner_hash","type":{"kind":"field"}}],"kind":"struct","path":"AuthWitTest::consume_parameters"}}],"kind":"struct","path":"AuthWitTest::consume_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"inner_hash","type":{"kind":"field"}}],"kind":"struct","path":"AuthWitTest::consume_public_parameters"}}],"kind":"struct","path":"AuthWitTest::consume_public_abi"}]}},"file_map":{"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"125":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"127":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle<N>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<N>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<N>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n"},"135":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n"},"167":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{GAS_LENGTH, FIXED_DA_GAS, FIXED_L2_GAS}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\n    abis::gas_fees::GasFees\n};\nuse std::ops::{Add, Sub};\n\nstruct Gas {\n    da_gas: u32,\n    l2_gas: u32,\n}\n\nimpl Gas {\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\n        Self { da_gas, l2_gas }\n    }\n\n    pub fn tx_overhead() -> Self {\n        Self { da_gas: FIXED_DA_GAS, l2_gas: FIXED_L2_GAS }\n    }\n\n    pub fn compute_fee(self, fees: GasFees) -> Field {\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.da_gas == 0) & (self.l2_gas == 0)\n    }\n\n    pub fn within(self, limits: Gas) -> bool {\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\n    }\n}\n\nimpl Add for Gas {\n    fn add(self, other: Gas) -> Self {\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\n    }\n}\n\nimpl Sub for Gas {\n    fn sub(self, other: Gas) -> Self {\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\n    }\n}\n\nimpl Serialize<GAS_LENGTH> for Gas {\n    fn serialize(self) -> [Field; GAS_LENGTH] {\n        [self.da_gas as Field, self.l2_gas as Field]\n    }\n}\n\nimpl Deserialize<GAS_LENGTH> for Gas {\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\n    }\n}\n\nimpl Eq for Gas {\n    fn eq(self, other : Gas) -> bool {\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\n    }\n}\n\nimpl Empty for Gas {\n    fn empty() -> Self {\n        Gas::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Gas::empty();\n    let serialized = item.serialize();\n    let deserialized = Gas::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n"},"169":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr","source":"use crate::{\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct NoteHash {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for NoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteHash {\n    fn eq(self, other: NoteHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter) \n    }\n}\n\nimpl Empty for NoteHash {\n    fn empty() -> Self {\n        NoteHash {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl NoteHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNoteHash {\n        ScopedNoteHash { note_hash: self, contract_address }\n    }\n}\n\nstruct ScopedNoteHash {\n    note_hash: NoteHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<NoteHash> for ScopedNoteHash {\n    fn inner(self) -> NoteHash {\n        self.note_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNoteHash {\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNoteHash {\n    fn value(self) -> Field {\n        self.note_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl Eq for ScopedNoteHash {\n    fn eq(self, other: ScopedNoteHash) -> bool {\n        (self.note_hash == other.note_hash)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedNoteHash {\n    fn empty() -> Self {\n        ScopedNoteHash {\n            note_hash: NoteHash::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\n        array_concat(self.note_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            note_hash: reader.read_struct(NoteHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNoteHash {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.note_hash.value, read_request.value(), \"Value of the note hash does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the note hash does not match read request\");\n        assert(\n            read_request.counter() > self.note_hash.counter, \"Read request counter must be greater than the counter of the note hash\"\n        );\n    }\n}\n\nimpl ScopedNoteHash {\n    pub fn expose_to_public(self) -> NoteHash {\n        // Hide the actual counter when exposing it to the public kernel.\n        NoteHash { value: self.note_hash.value, counter: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = NoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"170":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"172":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr","source":"use crate::{\n    abis::{\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    transaction::tx_context::TxContext, utils::arrays::validate_array\n};\n\nstruct PrivateCircuitPublicInputsArrayLengths {\n    note_hash_read_requests: u32,\n    nullifier_read_requests: u32,\n    key_validation_requests_and_generators: u32,\n    note_hashes: u32,\n    nullifiers: u32,\n    l2_to_l1_msgs: u32,\n    private_call_requests: u32,\n    public_call_stack_hashes: u32,\n    note_encrypted_logs_hashes: u32,\n    encrypted_logs_hashes: u32,\n    unencrypted_logs_hashes: u32,\n}\n\nimpl PrivateCircuitPublicInputsArrayLengths {\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\n        PrivateCircuitPublicInputsArrayLengths {\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\n            note_hashes: validate_array(public_inputs.note_hashes),\n            nullifiers: validate_array(public_inputs.nullifiers),\n            l2_to_l1_msgs: validate_array(public_inputs.l2_to_l1_msgs),\n            private_call_requests: validate_array(public_inputs.private_call_requests),\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\n        }\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    note_hashes: [NoteHash; MAX_NOTE_HASHES_PER_CALL],\n    nullifiers: [Nullifier; MAX_NULLIFIERS_PER_CALL],\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs: [L2ToL1Message; MAX_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    tx_context: TxContext,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.returns_hash == other.returns_hash) &\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\n        (self.is_fee_payer == other.is_fee_payer) &\n        (self.max_block_number == other.max_block_number) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\n        (self.note_hashes == other.note_hashes) &\n        (self.nullifiers == other.nullifiers) &\n        (self.private_call_requests == other.private_call_requests) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.l2_to_l1_msgs == other.l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\n        self.historical_header.eq(other.historical_header) &\n        self.tx_context.eq(other.tx_context)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\n\n        fields.extend_from_array(self.max_block_number.serialize());\n\n        for i in 0..self.note_hash_read_requests.len() {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..self.nullifier_read_requests.len() {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..self.key_validation_requests_and_generators.len() {\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\n        }\n        for i in 0..self.note_hashes.len() {\n            fields.extend_from_array(self.note_hashes[i].serialize());\n        }\n        for i in 0..self.nullifiers.len() {\n            fields.extend_from_array(self.nullifiers[i].serialize());\n        }\n        for i in 0..self.private_call_requests.len() {\n            fields.extend_from_array(self.private_call_requests[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n        fields.push(self.public_teardown_function_hash);\n        for i in 0..self.l2_to_l1_msgs.len() {\n            fields.extend_from_array(self.l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        for i in 0..self.note_encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.unencrypted_logs_hashes.len() {\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.tx_context.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            is_fee_payer: reader.read() == 1,\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL]),\n            nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL]),\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            public_teardown_function_hash: reader.read(),\n            l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            tx_context: reader.read_struct(TxContext::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PrivateCircuitPublicInputs {\n    fn empty() -> Self {\n        PrivateCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter : 0 as u32,\n            end_side_effect_counter : 0 as u32,\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            tx_context: TxContext::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PrivateCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PrivateCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x15c9b0a92b9b541598e24c9f0b0b4b04b7f2408599751c45aa12de671fd9b363;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"175":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n"},"176":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr","source":"use crate::{\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for ReadRequest {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\n        ScopedReadRequest { read_request: self, contract_address }\n    }\n}\n\nstruct ScopedReadRequest {\n    read_request: ReadRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<ReadRequest> for ScopedReadRequest {\n    fn inner(self) -> ReadRequest {\n        self.read_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ScopedReadRequest {\n    fn eq(self, other: ScopedReadRequest) -> bool {\n        (self.read_request == other.read_request)\n        & (self.contract_address.eq(other.contract_address))\n    }\n}\n\nimpl Empty for ScopedReadRequest {\n    fn empty() -> Self {\n        ScopedReadRequest {\n            read_request: ReadRequest::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            read_request: reader.read_struct(ReadRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedReadRequest {\n    pub fn value(self) -> Field {\n        self.read_request.value\n    }\n    pub fn counter(self) -> u32 {\n        self.read_request.counter\n    }\n}\n\n#[test]\nfn serialization_of_empty_read() {\n    let item = ReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"179":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr","source":"use crate::{\n    address::AztecAddress,\n    abis::validation_requests::{\n    key_validation_request::KeyValidationRequest,\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\n},\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct KeyValidationRequestAndGenerator {\n    request: KeyValidationRequest,\n    sk_app_generator: Field,\n}\n\nimpl Eq for KeyValidationRequestAndGenerator {\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\n    }\n}\n\nimpl Empty for KeyValidationRequestAndGenerator {\n    fn empty() -> Self {\n        KeyValidationRequestAndGenerator {\n            request: KeyValidationRequest::empty(),\n            sk_app_generator: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\n        array_concat(self.request.serialize(), [self.sk_app_generator])\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\n        let mut reader = Reader::new(fields);\n        let res = Self {\n            request: reader.read_struct(KeyValidationRequest::deserialize),\n            sk_app_generator: reader.read(),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl KeyValidationRequestAndGenerator {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = KeyValidationRequestAndGenerator::empty();\n    let serialized = item.serialize();\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"180":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point::new(fields[0], fields[1], fields[2] as bool),\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"184":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr","source":"use crate::{\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH},\n    hash::compute_siloed_nullifier, traits::{Empty, Hash, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct Nullifier {\n    value: Field,\n    counter: u32,\n    note_hash: Field,\n}\n\nimpl Ordered for Nullifier {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for Nullifier {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for Nullifier {\n    fn eq(self, other: Nullifier) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.note_hash == other.note_hash) \n    }\n}\n\nimpl Empty for Nullifier {\n    fn empty() -> Self {\n        Nullifier {\n            value: 0,\n            counter: 0,\n            note_hash: 0,\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\n        [self.value, self.counter as Field, self.note_hash]\n    }\n}\n\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            note_hash: values[2],\n        }\n    }\n}\n\nimpl Readable for Nullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        // Public kernels output Nullifier instead of ScopedNullifier.\n        // The nullifier value has been siloed.\n        let siloed_request_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.value, siloed_request_value, \"Value of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl Nullifier {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\n        ScopedNullifier { nullifier: self, contract_address }\n    }\n}\n\nstruct ScopedNullifier {\n    nullifier: Nullifier,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<Nullifier> for ScopedNullifier {\n    fn inner(self) -> Nullifier {\n        self.nullifier\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNullifier {\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNullifier {\n    fn value(self) -> Field {\n        self.nullifier.value\n    }\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl Eq for ScopedNullifier {\n    fn eq(self, other: ScopedNullifier) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedNullifier {\n    fn empty() -> Self {\n        ScopedNullifier {\n            nullifier: Nullifier::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            nullifier: reader.read_struct(Nullifier::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.nullifier.value, read_request.value(), \"Value of the nullifier does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.nullifier.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl ScopedNullifier {\n    pub fn nullified_note_hash(self) -> Field {\n        self.nullifier.note_hash\n    }\n\n    pub fn expose_to_public(self) -> Nullifier {\n        // Hide the actual counter and note hash when exposing it to the public kernel.\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Nullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = Nullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"193":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"194":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr","source":"use crate::{\n    abis::{\n    private_call_stack_item::PrivateCallStackItem, call_context::CallContext,\n    function_data::FunctionData, caller_context::CallerContext,\n    side_effect::{Ordered, RangeOrdered, Scoped}\n},\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PrivateCallRequest {\n    target: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Ordered for PrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.start_side_effect_counter\n    }\n}\n\nimpl RangeOrdered for PrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.start_side_effect_counter\n    }\n    fn counter_end(self) -> u32 {\n        self.end_side_effect_counter\n    }\n}\n\nimpl Eq for PrivateCallRequest {\n    fn eq(self, other: PrivateCallRequest) -> bool {\n        (self.target == other.target) \n            & (self.call_context == other.call_context) \n            & (self.function_data == other.function_data) \n            & (self.args_hash == other.args_hash) \n            & (self.returns_hash == other.returns_hash)\n            & (self.caller_context == other.caller_context)\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\n    }\n}\n\nimpl Empty for PrivateCallRequest {\n    fn empty() -> Self {\n        PrivateCallRequest {\n            target: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.push(self.target.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.extend_from_array(self.caller_context.serialize());\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = PrivateCallRequest {\n            target: reader.read_struct(AztecAddress::deserialize),\n            call_context: reader.read_struct(CallContext::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            caller_context: reader.read_struct(CallerContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            end_side_effect_counter: reader.read_u32(),\n        };\n        reader.finish();\n        item\n    }\n}\n\nimpl PrivateCallRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\n        ScopedPrivateCallRequest { call_request: self, contract_address }\n    }\n\n    pub fn matches_stack_item(self, stack_item: PrivateCallStackItem) -> bool {\n        (self.target == stack_item.contract_address)\n            & (self.call_context == stack_item.public_inputs.call_context)\n            & (self.function_data == stack_item.function_data)\n            & (self.args_hash == stack_item.public_inputs.args_hash)\n            & (self.returns_hash == stack_item.public_inputs.returns_hash)\n            & (self.start_side_effect_counter\n                                == stack_item.public_inputs.start_side_effect_counter)\n            & (self.end_side_effect_counter\n                                    == stack_item.public_inputs.end_side_effect_counter)\n    }\n}\n\nstruct ScopedPrivateCallRequest {\n    call_request: PrivateCallRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\n    fn inner(self) -> PrivateCallRequest {\n        self.call_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedPrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.call_request.counter_start()\n    }\n}\n\nimpl RangeOrdered for ScopedPrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.call_request.counter_start()\n    }\n    fn counter_end(self) -> u32 {\n        self.call_request.counter_end()\n    }\n}\n\nimpl Eq for ScopedPrivateCallRequest {\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\n        (self.call_request == other.call_request)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedPrivateCallRequest {\n    fn empty() -> Self {\n        ScopedPrivateCallRequest {\n            call_request: PrivateCallRequest::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.call_request.serialize());\n        fields.extend_from_array(self.contract_address.serialize());\n\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = ScopedPrivateCallRequest {\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        item\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = ScopedPrivateCallRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"199":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\n    abis::gas_fees::GasFees,\n    constants::{\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\n    DEFAULT_INCLUSION_FEE\n},\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    utils::reader::Reader\n};\n\nstruct GasSettings {\n    gas_limits: Gas,\n    teardown_gas_limits: Gas,\n    max_fees_per_gas: GasFees,\n    inclusion_fee: Field,\n}\n\nimpl GasSettings {\n    pub fn new(\n        gas_limits: Gas,\n        teardown_gas_limits: Gas,\n        max_fees_per_gas: GasFees,\n        inclusion_fee: Field\n    ) -> Self {\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\n    }\n\n    pub fn default() -> Self {\n        GasSettings::new(\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\n            DEFAULT_INCLUSION_FEE\n        )\n    }\n}\n\nimpl Eq for GasSettings {\n    fn eq(self, other: Self) -> bool {\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\n    }\n}\n\nimpl Empty for GasSettings {\n    fn empty() -> Self {\n        GasSettings::new(\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\n        )\n    }\n}\n\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\n\n        serialized.extend_from_array(self.gas_limits.serialize());\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\n        serialized.push(self.inclusion_fee);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\n        let mut reader = Reader::new(serialized);\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasSettings::empty();\n    let serialized = item.serialize();\n    let deserialized = GasSettings::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"208":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr","source":"use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PrivateCallStackItem {\n    fn empty() -> Self {\n        PrivateCallStackItem {\n            contract_address: AztecAddress::empty(),\n            function_data: FunctionData::empty(),\n            public_inputs: PrivateCircuitPublicInputs::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = PrivateCallStackItem::empty();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item = PrivateCallStackItem::empty();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x065f2831db9ac0db5e710bd3a865b5facd8cf83f1585e1af8fd1d6ce9c47f685;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr","source":"use crate::address::AztecAddress;\nuse crate::traits::{Empty, Serialize, Deserialize};\nuse crate::constants::CALLER_CONTEXT_LENGTH;\nuse crate::utils::reader::Reader;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n    is_static_call: bool,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, other: CallerContext) -> bool {\n        other.msg_sender.eq(self.msg_sender)\n            & other.storage_contract_address.eq(self.storage_contract_address)\n            & other.is_static_call == self.is_static_call\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n            is_static_call: false,\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\n    }\n\n    // Different to an empty context, a hidden context won't reveal the caller's msg_sender and storage_contract_address,\n    // but will still propagate the is_static_call flag.\n    pub fn is_hidden(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array(self.msg_sender.serialize());\n    fields.extend_from_array(self.storage_contract_address.serialize());\n    fields.push(self.is_static_call as Field);\n\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\n    let mut reader = Reader::new(fields);\n\n    let item = CallerContext {\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\n      is_static_call: reader.read_bool(),\n    };\n    reader.finish();\n    item\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = CallerContext::empty();\n    let serialized = item.serialize();\n    let deserialized = CallerContext::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"211":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr","source":"use crate::{\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\n    constants::{\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\n},\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct LogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n}\n\nimpl Ordered for LogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for LogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for LogHash {\n    fn eq(self, other: LogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n    }\n}\n\nimpl Empty for LogHash {\n    fn empty() -> Self {\n        LogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n        }\n    }\n}\n\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length]\n    }\n}\n\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n        }\n    }\n}\n\nimpl LogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\n        ScopedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedLogHash {\n    log_hash: LogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<LogHash> for ScopedLogHash {\n    fn inner(self) -> LogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedLogHash {\n    fn eq(self, other: ScopedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedLogHash {\n    fn empty() -> Self {\n        ScopedLogHash {\n            log_hash: LogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(LogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the counter when exposing to public.\n        // The log hash must already be siloed when we call this.\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nstruct EncryptedLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    randomness: Field,\n}\n\nimpl Ordered for EncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for EncryptedLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for EncryptedLogHash {\n    fn eq(self, other: EncryptedLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.randomness == other.randomness) \n    }\n}\n\nimpl Empty for EncryptedLogHash {\n    fn empty() -> Self {\n        EncryptedLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            randomness: 0,\n        }\n    }\n}\n\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.randomness]\n    }\n}\n\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            randomness: values[3],\n        }\n    }\n}\n\nimpl EncryptedLogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedEncryptedLogHash {\n    log_hash: EncryptedLogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\n    fn inner(self) -> EncryptedLogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl ScopedEncryptedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the secret randomness and counter when exposing to public\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\n        // The log hash will already be silo'd when we call this\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nimpl Ordered for ScopedEncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedEncryptedLogHash {\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedEncryptedLogHash {\n    fn empty() -> Self {\n        ScopedEncryptedLogHash {\n            log_hash: EncryptedLogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct NoteLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    note_hash_counter: u32,\n}\n\nimpl NoteLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\n        LogHash { value: self.value, counter: 0, length: self.length }\n    }\n}\n\nimpl Ordered for NoteLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for NoteLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteLogHash {\n    fn eq(self, other: NoteLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.note_hash_counter == other.note_hash_counter) \n    }\n}\n\nimpl Empty for NoteLogHash {\n    fn empty() -> Self {\n        NoteLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            note_hash_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            note_hash_counter: values[3] as u32,\n        }\n    }\n}\n"},"215":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr","source":"struct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n"},"216":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n}\n// docs:end:call-context\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n"},"217":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"220":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize, Empty}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        (self.is_private == other.is_private)\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nimpl Empty for FunctionData {\n    fn empty() -> Self {\n        FunctionData {\n            selector: FunctionSelector::empty(),\n            is_private: false\n        }\n    }\n\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data = FunctionData::empty();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data = FunctionData::empty();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty function data hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"227":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n    counter: u32,\n}\n\nimpl Ordered for L2ToL1Message {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content, self.counter as Field]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\nimpl L2ToL1Message {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\n        ScopedL2ToL1Message { message: self, contract_address }\n    }\n}\n\nstruct ScopedL2ToL1Message {\n    message: L2ToL1Message,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\n    fn inner(self) -> L2ToL1Message {\n        self.message\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedL2ToL1Message {\n    fn counter(self) -> u32 {\n        self.message.counter\n    }\n}\n\nimpl Eq for ScopedL2ToL1Message {\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\n        (self.message == other.message)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedL2ToL1Message {\n    fn empty() -> Self {\n        ScopedL2ToL1Message {\n            message: L2ToL1Message::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            message: reader.read_struct(L2ToL1Message::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\n#[test]\nfn serialization_of_empty_l2() {\n    let item = L2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = L2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped_l2() {\n    let item = ScopedL2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"237":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr","source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  num_txs: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.num_txs);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let num_txs = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      num_txs,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      num_txs: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.num_txs == other.num_txs)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n"},"239":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr","source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"241":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n"},"243":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr","source":"use crate::{\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    abis::gas_settings::GasSettings\n};\n\n// docs:start:tx-context\nstruct TxContext {\n    chain_id : Field,\n    version : Field,\n    gas_settings: GasSettings,\n}\n// docs:end:tx-context\n\nimpl TxContext {\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\n        TxContext { chain_id, version, gas_settings }\n    }\n}\n\nimpl Eq for TxContext {\n    fn eq(self, other: Self) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.gas_settings.eq(other.gas_settings))\n    }\n}\n\nimpl Empty for TxContext {\n    fn empty() -> Self {\n        TxContext {\n            chain_id: 0,\n            version: 0,\n            gas_settings: GasSettings::empty(),\n        }\n    }\n}\n\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\n\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.extend_from_array(self.gas_settings.serialize());\n\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let context = Self {\n            chain_id: reader.read(),\n            version: reader.read(),\n            gas_settings: reader.read_struct(GasSettings::deserialize),\n        };\n\n        reader.finish();\n        context\n    }\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context = TxContext::empty();\n    let serialized = context.serialize();\n    let deserialized = TxContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let context = TxContext::empty();\n    let hash = context.hash();\n\n    // Value from tx_context.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"249":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n"},"263":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"273":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"289":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"323":{"path":"/usr/src/noir-projects/noir-contracts/contracts/auth_wit_test_contract/src/main.nr","source":"contract AuthWitTest {\n    use dep::aztec::protocol_types::address::AztecAddress;\n    use dep::authwit::auth::{assert_inner_hash_valid_authwit, assert_inner_hash_valid_authwit_public};\n\n    #[aztec(private)]\n    fn consume(on_behalf_of: AztecAddress, inner_hash: Field) {\n        assert_inner_hash_valid_authwit(&mut context, on_behalf_of, inner_hash);\n    }\n\n    #[aztec(public)]\n    fn consume_public(on_behalf_of: AztecAddress, inner_hash: Field) {\n        assert_inner_hash_valid_authwit_public(&mut context, on_behalf_of, inner_hash);\n    }\n}\n"},"54":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n    GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER, GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    CANONICAL_AUTH_REGISTRY_ADDRESS\n},\n    hash::pedersen_hash\n};\nuse dep::aztec::{prelude::Deserialize, context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties \n * (e.g. protocols or other users) to execute an action on their behalf.\n * \n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be \n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few \n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can \n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be \n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n * \n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer. \n * \n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is \n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n * \n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline \n * how this would look in private, and then in public later. \n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX). \n * `Alice` would make a `deposit` transaction, that she is executing using her account contract. \n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token` \n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to \n * convince the `Token` contract that it is allowed to do so. \n * \n * This is where the authentication witness comes in! The `Token` contract computes a `message_hash` from the \n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to \n * execute that call.\n * \n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her \n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n * \n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n * \n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts. \n * \n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *  \n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store \n * the messages that we have approved. \n * \n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `keccak256(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a colission and we return \n *      a success flag.\n * \n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be \n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the \n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n * \n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains. \n */\n\nglobal IS_VALID_SELECTOR = 0xabf64ad4; // 4 first bytes of keccak256(\"IS_VALID()\")\n\n/** \n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n * \n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([context.msg_sender().to_field(), context.selector().to_field(), context.args_hash]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/** \n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n * \n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n * \n * @param on_behalf_of The address that have authorized the current call\n * @param inner_hash The hash of the message to authorize  \n */\npub fn assert_inner_hash_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context.static_call_private_function(\n        on_behalf_of,\n        FunctionSelector::from_signature(\"verify_private_authwit(Field)\"),\n        [inner_hash]\n    ).unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier, 0);\n}\n\n/** \n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n * \n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n * \n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub fn assert_current_call_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash(\n        [(*context).msg_sender().to_field(), (*context).selector().to_field(), (*context).get_args_hash()]\n    );\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/** \n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n * \n * @param on_behalf_of The address that have authorized the the `inner_hash`\n */\npub fn assert_inner_hash_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    let result: Field = context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"consume((Field),Field)\"),\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default()\n    ).deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness \n * \n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n * \n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<N>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N]\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash = compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n * \n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n * \n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<N>(args: [Field; N]) -> Field {\n    pedersen_hash(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/** \n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n * \n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n * \n * @param on_behalf_of The address that have authorized the the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    pedersen_hash(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n * \n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(consumer: AztecAddress, chain_id: Field, version: Field, inner_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        consumer.to_field(),\n        chain_id,\n        version,\n        inner_hash\n    ],\n        GENERATOR_INDEX__AUTHWIT_OUTER\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n * \n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n * \n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"set_authorized(Field,bool)\"),\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n * \n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise \n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"set_reject_all(bool)\"),\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n"},"89":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<N>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, N>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"95":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn block_number(self) -> Field {\n        block_number()\n    }\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<N>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<N>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, N>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N)\n}\n\nunconstrained fn storage_write<N>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<N>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<N>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}