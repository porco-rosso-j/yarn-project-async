{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"Escrow","functions":[{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"withdraw","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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lMvlqrhmq+9cs9V3rtnqO9ds9Z1rtvrONVt955qtvnPNVt+5ZqvvXLPVd67Z6jvXbPWda7b6zjVbfeearb5zzVbfuWar71yz1SvXbPXKNVu9cs1Wr1yz1etiXOVSuarKNVu9cs1Wr1yz1SvXbPXKNVu9cs1Wr1yz1SvXbPXKNVu9cs1Wr1yz1SvXbPXKNVu9cs1Wr1yz1SvXbPXKNVu9cs1Wr1yz1SvXbPXKNVu9cs1Wr1yz1SvXbPXKNVu9cs1Wr1yz1SvXbPXKNVu9cs1Wr1yz1SvXbPXKNVu9cs1Wr1yz1SvXbPXKNVu9cs1Wr1yz1SvXbPXKNVu9cs1Wr1yz1SvXbPXKNVu9cs1Wr1yz1SvXbPXKNVu9cs1Wr1yz1SvXbPXKNVu9cs1Wr1yz1SvXbPXKNVu9cs1Wr1yz1SvXbPXKNVu9cs1Wr1yz1SvXbPXKNVu9cs1Wr1yz1SvXbPXKNVu9cs1Wr1yz1SvXbPXKNVu9cs1Wr1yz1SvXbPXKNVu9cs1Wr1yz1SvXbPXKNVu9cs1Wr1yz1SvXbPXKNVu9cs1Wr1yz1SvXbPXKNVu9cs1Wr1yz1SvXbPXKNVu9cs1Wb1yz1RvXbPXGNVu9cc1Wb4txlUvlqhrXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPXGNVu9cc1Wb1yz1RvXbPVGNVt9X6hmq3+Uy+SqPsplclUf5TK5qo9yjatcJlf1US6Tq/ool8lVfZTL5Ko+yuVyVVSz1T/K5XJVVLPVP8rlclVUs9U/yuVyVVSz1T/K5XJV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"},{"name":"constructor","is_unconstrained":false,"custom_attributes":["aztec(private)","aztec(initializer)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000006827b230"},{"kind":"string","value":"AddressNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000006827b230"},{"kind":"string","value":"AddressNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"pending_shields","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"owner","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Escrow::withdraw_parameters"}}],"kind":"struct","path":"Escrow::withdraw_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Escrow::constructor_parameters"}}],"kind":"struct","path":"Escrow::constructor_abi"}]}},"file_map":{"102":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::{Point, pub_key_to_bytes},\n    constants::{GENERATOR_INDEX__IVSK_M, GENERATOR_INDEX__OVSK_M}, hash::poseidon2_hash\n};\n\nuse std::field::bytes32_to_field;\n\nuse crate::oracle::unsafe_rand::unsafe_rand;\n\nuse crate::event::event_interface::EventInterface;\nuse crate::note::note_interface::NoteInterface;\n\nuse crate::encrypted_logs::{\n    header::EncryptedLogHeader, incoming_body::EncryptedLogIncomingBody,\n    outgoing_body::EncryptedLogOutgoingBody\n};\n\npub fn compute_encrypted_event_log<Event, NB, MB, OB>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    event: Event\n) -> [u8; OB] where Event: EventInterface<NB, MB> {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    let eph_sk: Scalar = fr_to_fq(unsafe_rand());\n    let eph_pk = eph_sk.derive_public_key();\n\n    // TODO: (#7177) This value needs to be populated!\n    let recipient = AztecAddress::from_field(0);\n\n    let ivpk_app = compute_ivpk_app(ivpk, contract_address);\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_Header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_event(event, randomness).compute_ciphertext(eph_sk, ivpk_app);\n    let outgoing_body_ciphertext: [u8; 176] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk_app).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; OB] = [0; OB];\n    // @todo We ignore the tags for now \n\n    let eph_pk_bytes = pub_key_to_bytes(eph_pk);\n    for i in 0..64 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[128 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[176 + i] = outgoing_Header_ciphertext[i];\n    }\n    for i in 0..176 {\n        encrypted_bytes[224 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = OB - 400;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[400 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (64 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (176 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\npub fn compute_encrypted_note_log<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> [u8; M] where Note: NoteInterface<N, NB> {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    let eph_sk: Scalar = fr_to_fq(unsafe_rand());\n    let eph_pk = eph_sk.derive_public_key();\n\n    // TODO: (#7177) This value needs to be populated!\n    let recipient = AztecAddress::from_field(0);\n\n    let ivpk_app = compute_ivpk_app(ivpk, contract_address);\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_Header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_note(note, storage_slot).compute_ciphertext(eph_sk, ivpk_app);\n    let outgoing_body_ciphertext: [u8; 176] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk_app).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now \n\n    let eph_pk_bytes = pub_key_to_bytes(eph_pk);\n    for i in 0..64 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[128 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[176 + i] = outgoing_Header_ciphertext[i];\n    }\n    for i in 0..176 {\n        encrypted_bytes[224 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 400;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[400 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (64 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (176 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field elememt to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let r_bytes = r.to_be_bytes(32);\n\n    let mut high_bytes = [0; 32];\n    let mut low_bytes = [0; 32];\n\n    for i in 0..16 {\n        high_bytes[16 + i] = r_bytes[i];\n        low_bytes[16 + i] = r_bytes[i + 16];\n    }\n\n    let low = bytes32_to_field(low_bytes);\n    let high = bytes32_to_field(high_bytes);\n\n    Scalar::new(low, high)\n}\n\nfn compute_ivpk_app(ivpk: Point, contract_address: AztecAddress) -> Point {\n    // It is useless to compute this, it brings no value to derive fully.\n    // Issue(#6955)\n    ivpk\n    /*\n    // @todo Just setting infinite to false, but it should be checked.\n    // for example user could define ivpk = infinity using the registry\n    assert((ivpk.x != 0) & (ivpk.y != 0), \"ivpk is infinite\");\n\n    let i = fr_to_fq(poseidon2_hash([contract_address.to_field(), ivpk.x, ivpk.y, GENERATOR_INDEX__IVSK_M]));\n    let I = i.derive_public_key();\n\n    let embed_I = Point { x: I.x, y: I.y, is_infinite: false };\n    let embed_ivpk = Point { x: ivpk.x, y: ivpk.y, is_infinite: false };\n\n    let embed_result = embedded_curve_add(embed_I, embed_ivpk);\n\n    Point::new(embed_result.x, embed_result.y)*/\n}\n"},"103":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    encrypted_logs::payload::compute_encrypted_note_log, oracle::logs_traits::LensForEncryptedLog\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field, address::AztecAddress, point::Point, abis::note_hash::NoteHash,\n    constants::MAX_NOTE_HASHES_PER_CALL, utils::arrays::find_index\n};\n\nunconstrained fn compute_unconstrained<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    compute(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note)\n}\n\nfn compute<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let encrypted_log: [u8; M] = compute_encrypted_note_log(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note);\n    let log_hash = sha256_to_field(encrypted_log);\n    (encrypted_log, log_hash)\n}\n\nfn emit_with_keys<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    note: Note,\n    ovpk: Point,\n    ivpk: Point,\n    inner_compute: fn(AztecAddress, Field, Field, Point, Point, Note) -> ([u8; M], Field)\n) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    let note_exists_index = find_index(\n        context.note_hashes.storage,\n        |n: NoteHash| n.counter == note_hash_counter\n    );\n    assert(\n        note_exists_index as u32 != MAX_NOTE_HASHES_PER_CALL, \"Can only emit a note log for an existing note.\"\n    );\n\n    let contract_address: AztecAddress = context.this_address();\n    let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n    let (encrypted_log, log_hash) = inner_compute(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n\npub fn encode_and_encrypt_note<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let header = context.get_header();\n        let ovpk = header.get_ovpk_m(context, ov);\n        let ivpk = header.get_ivpk_m(context, iv);\n        emit_with_keys(context, e.note, ovpk, ivpk, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let header = context.get_header();\n        let ovpk = header.get_ovpk_m(context, ov);\n        let ivpk = header.get_ivpk_m(context, iv);\n        emit_with_keys(context, e.note, ovpk, ivpk, compute_unconstrained);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ovpk: Point,\n    ivpk: Point\n) -> fn[(&mut PrivateContext, Point, Point)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys_unconstrained<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ovpk: Point,\n    ivpk: Point\n) -> fn[(&mut PrivateContext, Point, Point)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, compute_unconstrained);\n    }\n}\n"},"104":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/outgoing_body.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash\n};\n\nuse std::aes128::aes128_encrypt;\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nstruct EncryptedLogOutgoingBody {\n    eph_sk: Scalar,\n    recipient: AztecAddress,\n    recipient_ivpk_app: Point,\n}\n\nimpl EncryptedLogOutgoingBody {\n    pub fn new(eph_sk: Scalar, recipient: AztecAddress, recipient_ivpk_app: Point) -> Self {\n        Self { eph_sk, recipient, recipient_ivpk_app }\n    }\n\n    pub fn compute_ciphertext(self, ovsk_app: Scalar, eph_pk: Point) -> [u8; 176] {\n        // Again, we could compute `eph_pk` here, but we keep the interface more similar\n        // and also make it easier to optimise it later as we just pass it along\n\n        let mut buffer: [u8; 160] = [0; 160];\n\n        let serialized_eph_sk_high = self.eph_sk.hi.to_be_bytes(32);\n        let serialized_eph_sk_low = self.eph_sk.lo.to_be_bytes(32);\n\n        let address_bytes = self.recipient.to_field().to_be_bytes(32);\n        let serialized_recipient_ivpk_app = self.recipient_ivpk_app.serialize();\n        let serialized_recipient_ivpk_app_x = serialized_recipient_ivpk_app[0].to_be_bytes(32);\n        let serialized_recipient_ivpk_app_y = serialized_recipient_ivpk_app[1].to_be_bytes(32);\n\n        for i in 0..32 {\n            buffer[i] = serialized_eph_sk_high[i];\n            buffer[i + 32] = serialized_eph_sk_low[i];\n            buffer[i + 64] = address_bytes[i];\n            buffer[i + 96] = serialized_recipient_ivpk_app_x[i];\n            buffer[i + 128] = serialized_recipient_ivpk_app_y[i];\n        }\n\n        // We compute the symmetric key using poseidon.\n        let full_key: [u8; 32] = poseidon2_hash(\n            [\n            ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y,\n            GENERATOR_INDEX__SYMMETRIC_KEY as Field\n        ]\n        ).to_be_bytes(32).as_array();\n\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(buffer, iv, sym_key).as_array()\n    }\n}\n\nmod test {\n    use crate::encrypted_logs::outgoing_body::EncryptedLogOutgoingBody;\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, hash::poseidon2_hash\n    };\n\n    use crate::context::PrivateContext;\n\n    #[test]\n    fn test_encrypted_log_outgoing_body() {\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        );\n        let recipient_ivsk_app = Scalar::new(\n            0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        );\n        let sender_ovsk_app = Scalar::new(\n            0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        );\n\n        let eph_pk = eph_sk.derive_public_key();\n        let recipient_ivpk_app = recipient_ivsk_app.derive_public_key();\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let body = EncryptedLogOutgoingBody::new(eph_sk, recipient, recipient_ivpk_app);\n\n        let ciphertext = body.compute_ciphertext(sender_ovsk_app, eph_pk);\n\n        let expected_outgoing_body_ciphertext = [\n            127, 84, 96, 176, 101, 107, 236, 57, 68, 8, 53, 202, 138, 74, 186, 54, 74, 193, 245, 7, 109, 59, 218, 33, 1, 31, 205, 225, 241, 209, 64, 222, 94, 245, 4, 150, 47, 241, 187, 64, 152, 20, 102, 158, 200, 217, 213, 82, 1, 240, 170, 185, 51, 80, 27, 109, 63, 231, 235, 120, 174, 44, 133, 248, 10, 97, 60, 40, 222, 190, 147, 76, 187, 48, 91, 206, 48, 106, 56, 118, 38, 127, 82, 4, 182, 188, 44, 224, 31, 129, 47, 107, 134, 252, 20, 25, 122, 191, 158, 69, 35, 255, 215, 171, 196, 45, 91, 184, 83, 80, 238, 201, 1, 233, 235, 159, 171, 130, 158, 64, 176, 165, 132, 30, 84, 81, 71, 195, 145, 47, 82, 247, 210, 192, 23, 4, 220, 90, 56, 109, 46, 105, 79, 251, 165, 141, 185, 233, 191, 118, 219, 153, 191, 162, 99, 238, 241, 249, 9, 74, 210, 241, 54, 28, 126, 226, 85, 235, 174, 75, 239, 207, 100, 184, 248, 194\n        ];\n\n        for i in 0..expected_outgoing_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_outgoing_body_ciphertext[i]);\n        }\n        assert_eq(expected_outgoing_body_ciphertext.len(), ciphertext.len());\n    }\n}\n"},"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\nstruct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext(self, secret: Scalar, point: Point) -> [u8; 48] {\n        let full_key = point_to_symmetric_key(secret, point);\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes(32).as_array();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nfn test_encrypted_log_header() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar::new(\n        0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    );\n    let point = Point::new(\n        0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        false\n    );\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    let expected_header_ciphertext = [\n        228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 23, 131, 32, 226, 26, 176, 43, 39, 239, 177, 177, 192, 85, 216, 17, 15, 18, 187, 35, 225, 135, 192, 63, 88, 29, 173, 232, 46, 72, 82, 187, 139\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext);\n}\n"},"106":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/incoming_body.nr","source":"use crate::note::note_interface::NoteInterface;\nuse crate::event::event_interface::EventInterface;\nuse dep::protocol_types::{scalar::Scalar, point::Point};\n\nuse std::aes128::aes128_encrypt;\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nstruct EncryptedLogIncomingBody<M> {\n    plaintext: [u8; M]\n}\n\nimpl<M> EncryptedLogIncomingBody<M> {\n    pub fn from_note<T, N>(note: T, storage_slot: Field) -> Self where T: NoteInterface<N, M> {\n        let mut plaintext = note.to_be_bytes(storage_slot);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn from_event<T, MR>(event: T, randomness: Field) -> Self where T: EventInterface<M, MR> {\n        let mut plaintext = event.private_to_be_bytes(randomness);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn compute_ciphertext(self, eph_sk: Scalar, ivpk_app: Point) -> [u8] {\n        let full_key = point_to_symmetric_key(eph_sk, ivpk_app);\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(self.plaintext, iv, sym_key)\n    }\n}\n\nmod test {\n    use crate::encrypted_logs::incoming_body::EncryptedLogIncomingBody;\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, traits::Serialize, abis::event_selector::EventSelector\n    };\n\n    use crate::{\n        note::{note_header::NoteHeader, note_interface::NoteInterface},\n        event::event_interface::EventInterface, oracle::unsafe_rand::unsafe_rand,\n        context::PrivateContext\n    };\n\n    struct AddressNote {\n        address: AztecAddress,\n        owner: AztecAddress,\n        randomness: Field,\n        header: NoteHeader,\n    }\n\n    global ADDRESS_NOTE_LEN: Field = 3;\n    global ADDRESS_NOTE_BYTES_LEN = 32 * 3 + 64;\n\n    impl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n        fn compute_note_content_hash(self) -> Field {1}\n\n        fn get_note_type_id() -> Field {\n            1\n        }\n\n        fn get_header(self) -> NoteHeader { self.header}\n\n        fn set_header(&mut self, header: NoteHeader) {self.header = header; }\n\n        fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n            (1, 1)\n        }\n\n        fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {(1,1)}\n\n        fn serialize_content(self) -> [Field; ADDRESS_NOTE_LEN] { [self.address.to_field(), self.owner.to_field(), self.randomness]}\n\n        fn deserialize_content(fields: [Field; ADDRESS_NOTE_LEN]) -> Self {\n            AddressNote { address: AztecAddress::from_field(fields[0]), owner: AztecAddress::from_field(fields[1]), randomness: fields[2], header: NoteHeader::empty() }\n        }\n\n        fn to_be_bytes(self, storage_slot: Field) -> [u8; ADDRESS_NOTE_BYTES_LEN] {\n            let serialized_note = self.serialize_content();\n\n            let mut buffer: [u8; ADDRESS_NOTE_BYTES_LEN] = [0; ADDRESS_NOTE_BYTES_LEN];\n\n            let storage_slot_bytes = storage_slot.to_be_bytes(32);\n            let note_type_id_bytes = AddressNote::get_note_type_id().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = storage_slot_bytes[i];\n                buffer[32 + i] = note_type_id_bytes[i];\n            }\n\n            for i in 0..serialized_note.len() {\n                let bytes = serialized_note[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n            buffer\n        }\n    }\n\n    impl AddressNote {\n        pub fn new(address: AztecAddress, owner: AztecAddress, randomness: Field) -> Self {\n            AddressNote { address, owner, randomness, header: NoteHeader::empty() }\n        }\n    }\n\n    #[test]\n    fn test_encrypted_note_log_incoming_body() {\n        let note = AddressNote::new(\n            AztecAddress::from_field(0x1),\n            AztecAddress::from_field(0x2),\n            3\n        );\n\n        let storage_slot = 2;\n\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        );\n        let ivpk_app = Point::new(\n            0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            false\n        );\n\n        let body = EncryptedLogIncomingBody::from_note(note, storage_slot);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk_app);\n\n        let expected_note_body_ciphertext = [\n            228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 63, 127, 188, 251, 150, 188, 238, 205, 3, 86, 102, 164, 175, 12, 137, 158, 163, 111, 205, 10, 229, 230, 46, 202, 110, 107, 156, 180, 67, 192, 161, 201, 48, 153, 169, 1, 25, 182, 93, 39, 39, 207, 251, 218, 234, 147, 156, 13, 110, 180, 190, 199, 41, 6, 211, 203, 176, 110, 165, 186, 110, 127, 199, 22, 201, 149, 92, 249, 219, 68, 145, 68, 179, 29, 233, 34, 98, 123, 197, 234, 169, 53, 44, 14, 81, 60, 92, 27, 250, 134, 49, 248, 57, 119, 236, 118, 158, 104, 82, 243, 98, 164, 60, 72, 74, 27, 177, 194, 221, 225, 193, 150, 67, 235, 205, 106, 150, 24, 126, 186, 220, 178, 199, 189, 113, 54, 181, 55, 46, 15, 236, 236, 9, 159, 5, 172, 237, 154, 110, 50, 241, 64, 92, 13, 37, 53, 20, 140, 42, 146, 229, 63, 97, 25, 159, 63, 235, 104, 68, 100\n        ];\n\n        assert_eq(expected_note_body_ciphertext.len(), ciphertext.len());\n\n        for i in 0..expected_note_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_note_body_ciphertext[i]);\n        }\n    }\n\n    struct TestEvent {\n        value0: Field,\n        value1: Field,\n        value2: Field,\n    }\n\n    impl Serialize<3> for TestEvent {\n        fn serialize(self) -> [Field; 3] {\n            [self.value0, self.value1, self.value2]\n        }\n    }\n\n    global TEST_EVENT_LEN: Field = 3;\n    global TEST_EVENT_BYTES_LEN = 32 * 3 + 64;\n    global TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS = 32 * 3 + 32;\n\n    impl EventInterface<TEST_EVENT_BYTES_LEN, TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS> for TestEvent {\n        fn get_event_type_id() -> EventSelector {\n            EventSelector::from_signature(\"TestEvent(Field,Field,Field)\")\n        }\n\n        fn private_to_be_bytes(self, randomness: Field) -> [u8; TEST_EVENT_BYTES_LEN] {\n            let mut buffer: [u8; TEST_EVENT_BYTES_LEN] = [0; TEST_EVENT_BYTES_LEN];\n\n            let randomness_bytes = randomness.to_be_bytes(32);\n            let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = randomness_bytes[i];\n                buffer[32 + i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes = serialized_event[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn to_be_bytes(self) -> [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] {\n             let mut buffer: [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] = [0; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS];\n\n             let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n             for i in 0..32 {\n                 buffer[i] = event_type_id_bytes[i];\n            }\n\n             let serialized_event = self.serialize();\n\n             for i in 0..serialized_event.len() {\n                 let bytes = serialized_event[i].to_be_bytes(32);\n                 for j in 0..32 {\n                     buffer[32 + i * 32 + j] = bytes[j];\n                }\n            }\n\n             buffer\n        }\n\n        fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n            _emit(self);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_event_incoming_body() {\n        let test_event = TestEvent { value0: 1, value1: 2, value2: 3 };\n\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        );\n\n        let ivpk_app = Point::new(\n            0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            false\n        );\n\n        let randomness = 2;\n\n        let body = EncryptedLogIncomingBody::from_event(test_event, randomness);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk_app);\n\n        let expected_event_body_ciphertext = [\n            228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 63, 127, 188, 251, 150, 188, 238, 205, 3, 86, 102, 164, 175, 12, 137, 158, 163, 111, 205, 10, 229, 230, 46, 202, 110, 107, 156, 180, 67, 192, 161, 201, 66, 122, 29, 35, 42, 33, 153, 216, 199, 208, 103, 207, 126, 153, 189, 136, 19, 220, 238, 15, 169, 29, 255, 11, 123, 107, 70, 192, 53, 40, 36, 93, 187, 32, 123, 136, 104, 23, 229, 245, 152, 90, 84, 2, 136, 112, 42, 27, 82, 214, 104, 14, 250, 48, 199, 245, 88, 22, 200, 77, 38, 51, 127, 56, 138, 255, 16, 46, 179, 129, 215, 185, 185, 116, 148, 16, 133, 62, 56, 180, 10, 132, 109, 77, 206, 199, 21, 167, 7, 163, 171, 158, 244, 23, 18, 121, 108, 42, 107, 7, 48, 84, 212, 104, 39, 16, 109, 7, 108, 129, 60, 80, 112, 241, 223, 140, 186, 158, 38, 74, 230, 213, 159, 175, 142, 228, 128, 160\n        ];\n\n        assert_eq(expected_event_body_ciphertext.len(), ciphertext.len());\n\n        for i in 0..expected_event_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_event_body_ciphertext[i]);\n        }\n    }\n}\n"},"110":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr","source":"use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus, PropertySelector},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\n\nmod test;\n\nfn extract_property_value_from_selector<N>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note. \n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value = serialized_note[selector.index].to_be_bytes(32);\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, N, M>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<N>(serialized_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let is_equal = value_field == select.value.to_field();\n        let is_lt = value_field.lt(select.value.to_field());\n\n        if (select.comparator == Comparator.EQ) {\n            assert(is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(is_lt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(is_lt | is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!is_lt & !is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!is_lt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N, M> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    context.push_note_hash_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, M, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> where Note: NoteInterface<N, M> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nfn constrain_get_notes_internal<Note, N, M, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> where Note: NoteInterface<N, M> {\n    let mut returned_notes = BoundedVec::new();\n\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        let opt_note = filtered_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n\n            // The below code is used to collapse a sparse array into one where the values are guaranteed to be at the \n            // front of the array. This is highly useful because the caller knows that the returned array won't have\n            // more than option.limits notes, and can therefore loop over this limit value instead of the entire array,\n            // resulting in a smaller circuit and faster proving times.\n            // We write at returned_notes[num_notes] because num_notes is only advanced when we have a value in \n            // filtered_notes.\n            returned_notes.push(note);\n        };\n    }\n\n    // As long as we only loop till `options.limit` the array will be guaranteed to be at most of length `options.limit`.\n    assert(returned_notes.len() <= options.limit, \"Got more notes than limit.\");\n    // We will however check that nothing else was returned after the limit.\n    for i in options.limit..filtered_notes.len() {\n        assert(filtered_notes[i].is_none(), \"Got more notes than limit.\");\n    }\n\n    assert(returned_notes.len() != 0, \"Cannot return zero notes\");\n\n    returned_notes\n}\n\nunconstrained fn get_note_internal<Note, N, M>(storage_slot: Field) -> Note where Note: NoteInterface<N, M> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, M, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N, M> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained pub fn view_notes<Note, N, M>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N, M>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N, M> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n"},"112":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__INNER_NOTE_HASH,\n    hash::{\n    pedersen_hash, compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_inner_note_hash_from_preimage(storage_slot: Field, note_content_hash: Field) -> Field {\n    pedersen_hash(\n        [storage_slot, note_content_hash],\n        GENERATOR_INDEX__INNER_NOTE_HASH\n    )\n}\n\nfn compute_inner_note_hash<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    compute_inner_note_hash_from_preimage(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N, M>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let (_, inner_nullifier) = note_with_header.compute_note_hash_and_nullifier(context);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\nfn compute_note_hash_for_read_request_from_innter_and_nonce(\n    inner_note_hash: Field,\n    nonce: Field\n) -> Field {\n    // TODO(#1386): This if-else can be nuked once we have nonces injected from public\n    if (nonce == 0) {\n        // If nonce is zero, that means we are reading a public note.\n        inner_note_hash\n    } else {\n        compute_unique_note_hash(nonce, inner_note_hash)\n    }\n}\n\npub fn compute_note_hash_for_read_request<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let inner_note_hash = compute_inner_note_hash(note);\n    let nonce = note.get_header().nonce;\n\n    compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, nonce)\n}\n\npub fn compute_note_hash_for_consumption<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    if (header.note_hash_counter != 0) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        inner_note_hash\n    } else {\n        // If a note is not transient, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the siloed_note_hash which has already been hashed with\n        // nonce and then contract address. This hash will match the existing leaf in the note hash\n        // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, header.nonce);\n        compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, N, M, S>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n    let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, note_header.nonce);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        let (_, nullifier) = note.compute_note_hash_and_nullifier_without_context();\n        nullifier\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [inner_note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"113":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_inner_note_hash, compute_note_hash_for_consumption}, note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let inner_note_hash = compute_inner_note_hash(*note);\n\n    let serialized_note = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash,\n        note_hash_counter\n    )\n        == 0\n    );\n\n    context.push_note_hash(inner_note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, N, M>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let inner_note_hash = compute_inner_note_hash(*note);\n\n    context.push_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let (note_hash, nullifier) = note.compute_note_hash_and_nullifier(context);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let note_hash_for_consumption = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a non-transient note and we don't populate the note_hash with real\n        // value (if we did so the `notifyNullifiedNote` oracle would throw).\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a transient note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can find it and squash both\n        // the note and the nullifier.\n        note_hash\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    assert(notify_nullified_note(nullifier, note_hash_for_consumption, nullifier_counter) == 0);\n\n    context.push_nullifier(nullifier, note_hash_for_consumption)\n}\n"},"114":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\nstruct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting  \n * a change note in a token's transfer function only when there is \"change\" left).\n */\nstruct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(self) {}\n}\n"},"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"122":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::{compute_siloed_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_contract_initialization_nullifier(context.this_address());\n    let header = context.get_header();\n    header.prove_nullifier_inclusion(init_nullifier);\n}\n\nfn compute_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    compute_siloed_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(address)\n    )\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"123":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr","source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"},"124":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::{address::AztecAddress, point::Point};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<M>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<M>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<M>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32\n) {}\n\nunconstrained pub fn emit_encrypted_event_log<M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<N, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<N, M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\n}\n"},"125":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"128":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n"},"132":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<N>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field\n) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number as Field, N)\n}\n\nunconstrained pub fn storage_read<T, N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"133":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/unsafe_rand.nr","source":"#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n\n// Called `unsafe_rand` because we do not constrain in circuit that we are dealing with an actual random value.\n// Instead we just trust our PXE.\nunconstrained pub fn unsafe_rand() -> Field {\n    rand_oracle()\n}\n"},"135":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n"},"136":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use crate::keys::PublicKeys;\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained fn get_public_keys_and_partial_address_oracle_wrapper(address: AztecAddress) -> [Field; 13] {\n    get_public_keys_and_partial_address_oracle(address)\n}\n\nfn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle_wrapper(address);\n\n    let keys = PublicKeys {\n        npk_m: Point::new(result[0], result[1], result[2] as bool),\n        ivpk_m: Point::new(result[3], result[4], result[5] as bool),\n        ovpk_m: Point::new(result[6], result[7], result[8] as bool),\n        tpk_m: Point::new(result[9], result[10], result[11] as bool)\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"138":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        inner_note_hash,\n        counter\n    )\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field, _counter: u32) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(\n    nullifier: Field,\n    inner_note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash, counter)\n}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, NB, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N, NB> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n// Only ever use this in private!\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n// Only ever use this in private!\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n"},"139":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"155":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_delay_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initally equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation \n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the \n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a \n// reduced delay, invalidating prior private reads.\nstruct ScheduledDelayChange<INITIAL_DELAY> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option, \n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pre: Option<u32>,\n    post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numeric value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\nimpl<INITIAL_DELAY> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior contraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This \n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is \n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in \n            //                             which to scheduled value change\n\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY)\n            )\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Serialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn serialize(self) -> [Field; 1] {\n        // We pack all three u32 values into a single U128, which is made up of two u64 limbs.\n        // Low limb: [ pre_inner: u32 | post_inner: u32 ]\n        // High limb: [ empty | pre_is_some: u8 |  post_is_some: u8 | block_of_change: u32 ]\n\n        let lo = ((self.pre.unwrap_unchecked() as u64) * (1 << 32))\n            + (self.post.unwrap_unchecked() as u64);\n\n        let hi = (self.pre.is_some() as u64) * (1 << 33) \n            + (self.post.is_some() as u64 * (1 << 32)) \n            + self.block_of_change as u64;\n\n        let packed = U128::from_u64s_le(lo, hi);\n\n        [packed.to_integer()]\n    }\n}\n\nimpl<INITIAL_DELAY> Deserialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn deserialize(input: [Field; 1]) -> Self {\n        let packed = U128::from_integer(input[0]);\n\n        // We use division and modulo to clear the bits that correspond to other values when unpacking.\n\n        let pre_is_some = ((packed.hi as u64) / (1 << 33)) as bool;\n        let pre_inner = ((packed.lo as u64) / (1 << 32)) as u32;\n\n        let post_is_some = (((packed.hi as u64) / (1 << 32)) % (1 << 1)) as bool;\n        let post_inner = ((packed.lo as u64) % (1 << 32)) as u32;\n\n        let block_of_change = ((packed.hi as u64) % (1 << 32)) as u32;\n\n        Self {\n            pre: if pre_is_some { Option::some(pre_inner) } else { Option::none() },\n            post: if post_is_some { Option::some(post_inner) } else { Option::none() },\n            block_of_change,\n            _dummy: [0; INITIAL_DELAY],\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"157":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable_private_getter.nr","source":"use dep::protocol_types::{\n    hash::{pedersen_hash, poseidon2_hash}, traits::{FromField, ToField}, address::AztecAddress,\n    header::Header\n};\n\nuse crate::context::PrivateContext;\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{\n    shared_mutable::SharedMutable, scheduled_delay_change::ScheduledDelayChange,\n    scheduled_value_change::ScheduledValueChange\n}\n};\n\nstruct SharedMutablePrivateGetter<T, INITIAL_DELAY> {\n    context: &mut PrivateContext,\n    // The contract address of the contract we want to read from\n    other_contract_address: AztecAddress,\n    // The storage slot where the SharedMutable is stored on the other contract\n    storage_slot: Field,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numberic value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\n// We have this as a view-only interface to reading Shared Mutables in other contracts.\n// Currently the Shared Mutable does not support this. We can adapt SharedMutable at a later date\nimpl<T, INITIAL_DELAY> SharedMutablePrivateGetter<T, INITIAL_DELAY> {\n    pub fn new(\n        context: &mut PrivateContext,\n        other_contract_address: AztecAddress,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        assert(other_contract_address.to_field() != 0, \"Other contract address cannot be 0\");\n        Self { context, other_contract_address, storage_slot, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    pub fn get_value_in_private(self, header: Header) -> T where T: FromField + ToField + Eq {\n        // We create a dummy SharedMutable state variable so that we can reuse its historical_read_from_public_storage\n        // method, greatly reducing code duplication. \n        let dummy: SharedMutable<T, INITIAL_DELAY, ()> = SharedMutable::new((), self.storage_slot);\n        let (value_change, delay_change, historical_block_number) = dummy.historical_read_from_public_storage(header, self.other_contract_address);\n\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // If our context has the same header as the one we pass in via the parameter, we are trying to read the \"current\" value\n        // and thus need to set the tx max block number below. If the context header is not the same as the one we pass in, this means\n        // we are trying to read a historical value and thus have no constraint on the max block number that this transaction can be included in.\n        if (self.context.historical_header.global_variables.block_number.eq(header.global_variables.block_number)) {\n            self.context.set_tx_max_block_number(block_horizon);\n        }\n\n        value_change.get_current_at(historical_block_number)\n    }\n}\n"},"159":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_value_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\nstruct ScheduledValueChange<T> {\n    pre: T,\n    post: T,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Serialize<3> for ScheduledValueChange<T> {\n    fn serialize(self) -> [Field; 3] where T: ToField {\n        [self.pre.to_field(), self.post.to_field(), self.block_of_change.to_field()]\n    }\n}\n\nimpl<T> Deserialize<3> for ScheduledValueChange<T> {\n  fn deserialize(input: [Field; 3]) -> Self  where T: FromField {\n    Self {\n        pre: FromField::from_field(input[0]),\n        post: FromField::from_field(input[1]),\n        block_of_change: FromField::from_field(input[2]),\n    }\n  }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>  {\n    fn eq(self, other: Self) -> bool where T: Eq {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"160":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable.nr","source":"use dep::protocol_types::{\n    hash::{pedersen_hash, poseidon2_hash}, header::Header, address::AztecAddress,\n    traits::{FromField, ToField}\n};\n\nuse crate::context::{PrivateContext, PublicContext};\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{scheduled_value_change::ScheduledValueChange, scheduled_delay_change::ScheduledDelayChange}\n};\nuse crate::oracle::storage::storage_read;\nuse dep::std::unsafe::zeroed;\n\nmod test;\n\nstruct SharedMutable<T, INITIAL_DELAY, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Serialize<N> trait, and allocate N storage slots to\n// this state variable. This is incorrect, since what we actually store is:\n//  - a ScheduledValueChange<T>, which requires 1 + 2 * M storage slots, where M is the serialization length of T\n//  - a ScheduledDelayChange, which requires another storage slot\n//\n// TODO https://github.com/AztecProtocol/aztec-packages/issues/5736: change the storage allocation scheme so that we\n// can actually use it here\nimpl<T, INITIAL_DELAY, Context> Storage<T> for SharedMutable<T, INITIAL_DELAY, Context> {}\n\n// TODO: extract into a utils module once  we can do arithmetic on generics, i.e. https://github.com/noir-lang/noir/issues/4784\nfn concat_arrays<N, M, O>(arr_n: [Field; N], arr_m: [Field; M]) -> [Field; O] {\n    assert_eq(N + M, O);\n    let mut out: [Field; O] = [0; O];\n    for i in 0..N {\n        out[i] = arr_n[i];\n    }\n    for i in 0..M {\n        out[N+i] = arr_m[i];\n    }\n    out\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, INITIAL_DELAY, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    fn hash_scheduled_data(\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) -> Field where T: ToField {\n        // TODO(#5491 and https://github.com/noir-lang/noir/issues/4784): update this so that we don't need to rely on\n        // ScheduledValueChange serializing to 3 and ScheduledDelayChange serializing to 1\n        let concatenated: [Field; 4] = concat_arrays(value_change.serialize(), delay_change.serialize());\n        poseidon2_hash(concatenated)\n    }\n\n    // Since we can't rely on the native storage allocation scheme, we hash the storage slot to get a unique location in\n    // which we can safely store as much data as we need.\n    // See https://github.com/AztecProtocol/aztec-packages/issues/5492 and\n    // https://github.com/AztecProtocol/aztec-packages/issues/5736\n    // We store three things in public storage:\n    //  - a ScheduledValueChange\n    //  - a ScheduledDelaChange\n    //  - the hash of both of these (via `hash_scheduled_data`)\n    fn get_value_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 0], 0)\n    }\n\n    fn get_delay_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 1], 0)\n    }\n\n    fn get_hash_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 2], 0)\n    }\n\n    // It may seem odd that we take a header and address instead of reading from e.g. a PrivateContext, but this lets us\n    // reuse this function in SharedMutablePrivateGetter.\n    fn historical_read_from_public_storage(\n        self,\n        header: Header,\n        address: AztecAddress\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) where T: FromField + ToField + Eq {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for both the ScheduledValueChange and\n        // ScheduledDelayChange, but that'd require one full sibling path per storage slot (since due to kernel siloing\n        // the storage is not contiguous), and in the best case in which T is a single field that'd be 4 slots.\n        // Instead, we get an oracle to provide us the correct values for both the value and delay changes, and instead\n        // prove inclusion of their hash, which is both a much smaller proof (a single slot), and also independent of\n        // the size of T.\n        let (value_change_hint, delay_change_hint) = get_public_storage_hints(address, self.storage_slot, historical_block_number);\n\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let hash = header.public_storage_historical_read(self.get_hash_storage_slot(), address);\n\n        // @todo This is written strangely to bypass a formatting issue with the if that is breaking ci.\n        let (a, b, c) = if hash != 0 {\n            let a = SharedMutable::hash_scheduled_data(value_change_hint, delay_change_hint);\n            (a, value_change_hint, delay_change_hint)\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized, meaning no value or delay change was ever\n            // scheduled. Therefore, the hints must then correspond to uninitialized scheduled changes.\n            let b = ScheduledValueChange::deserialize(zeroed());\n            let c = ScheduledDelayChange::deserialize(zeroed());\n            (hash, b, c)\n        };\n\n        assert_eq(hash, a, \"Hint values do not match hash\");\n        assert_eq(value_change_hint, b, \"Non-zero value change for zero hash\");\n        assert_eq(delay_change_hint, c, \"Non-zero delay change for zero hash\");\n\n        (value_change_hint, delay_change_hint, historical_block_number)\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PublicContext> {\n    pub fn schedule_value_change(self, new_value: T) where T: ToField {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) where T: ToField {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value_in_public(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay_in_public(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value_in_public(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay_in_public(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        self.context.storage_read(self.get_delay_change_storage_slot())\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) where T: ToField {\n        // Whenever we write to public storage, we write both the value change and delay change as well as the hash of\n        // them both. This guarantees that the hash is always kept up to date.\n        // While this makes for more costly writes, it also makes private proofs much simpler because they only need to\n        // produce a historical proof for the hash, which results in a single inclusion proof (as opposed to 4 in the\n        // best case scenario in which T is a single field). Private shared mutable reads are assumed to be much more\n        // frequent than public writes, so this tradeoff makes sense.\n        self.context.storage_write(self.get_value_change_storage_slot(), value_change);\n        self.context.storage_write(self.get_delay_change_storage_slot(), delay_change);\n        self.context.storage_write(\n            self.get_hash_storage_slot(),\n            SharedMutable::hash_scheduled_data(value_change, delay_change)\n        );\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext> {\n    pub fn get_current_value_in_private(self) -> T where T: FromField + ToField + Eq {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n\n        let (value_change, delay_change, historical_block_number) = self.historical_read_from_public_storage(self.context.get_header(), self.context.this_address());\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n}\n\nunconstrained fn get_public_storage_hints<T, INITIAL_DELAY>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>) {\n    // This function cannot be part of the &mut PrivateContext impl because that'd mean that by passing `self` we'd also\n    // be passing a mutable reference to an unconstrained function, which is not allowed. We therefore create a dummy\n    // state variable here so that we can access the methods to compute storage slots. This will all be removed in the\n    // future once we do proper storage slot allocation (#5492).\n    let dummy = SharedMutable::new((), storage_slot);\n\n    (\n        storage_read(address, dummy.get_value_change_storage_slot(), block_number), storage_read(address, dummy.get_delay_change_storage_slot(), block_number)\n    )\n}\n"},"162":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr","source":"use dep::protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::pedersen_hash};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::create_note, note_getter::{get_note, view_notes}, note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions, note_emission::NoteEmission\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateImmutable<T, Context> {}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor. \n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        pedersen_hash(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<N, M>(\n        self,\n        note: &mut Note\n    ) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier, 0);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<N, M>(self) -> Note where Note: NoteInterface<N, M> {\n        let storage_slot = self.storage_slot;\n        get_note(self.context, storage_slot)\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UnconstrainedContext> {\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    unconstrained pub fn view_note<N, M>(self) -> Note  where Note: NoteInterface<N, M> {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"},"167":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{GAS_LENGTH, FIXED_DA_GAS, FIXED_L2_GAS}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\n    abis::gas_fees::GasFees\n};\nuse std::ops::{Add, Sub};\n\nstruct Gas {\n    da_gas: u32,\n    l2_gas: u32,\n}\n\nimpl Gas {\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\n        Self { da_gas, l2_gas }\n    }\n\n    pub fn tx_overhead() -> Self {\n        Self { da_gas: FIXED_DA_GAS, l2_gas: FIXED_L2_GAS }\n    }\n\n    pub fn compute_fee(self, fees: GasFees) -> Field {\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.da_gas == 0) & (self.l2_gas == 0)\n    }\n\n    pub fn within(self, limits: Gas) -> bool {\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\n    }\n}\n\nimpl Add for Gas {\n    fn add(self, other: Gas) -> Self {\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\n    }\n}\n\nimpl Sub for Gas {\n    fn sub(self, other: Gas) -> Self {\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\n    }\n}\n\nimpl Serialize<GAS_LENGTH> for Gas {\n    fn serialize(self) -> [Field; GAS_LENGTH] {\n        [self.da_gas as Field, self.l2_gas as Field]\n    }\n}\n\nimpl Deserialize<GAS_LENGTH> for Gas {\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\n    }\n}\n\nimpl Eq for Gas {\n    fn eq(self, other : Gas) -> bool {\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\n    }\n}\n\nimpl Empty for Gas {\n    fn empty() -> Self {\n        Gas::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Gas::empty();\n    let serialized = item.serialize();\n    let deserialized = Gas::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n"},"169":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr","source":"use crate::{\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct NoteHash {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for NoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteHash {\n    fn eq(self, other: NoteHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter) \n    }\n}\n\nimpl Empty for NoteHash {\n    fn empty() -> Self {\n        NoteHash {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl NoteHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNoteHash {\n        ScopedNoteHash { note_hash: self, contract_address }\n    }\n}\n\nstruct ScopedNoteHash {\n    note_hash: NoteHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<NoteHash> for ScopedNoteHash {\n    fn inner(self) -> NoteHash {\n        self.note_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNoteHash {\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNoteHash {\n    fn value(self) -> Field {\n        self.note_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl Eq for ScopedNoteHash {\n    fn eq(self, other: ScopedNoteHash) -> bool {\n        (self.note_hash == other.note_hash)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedNoteHash {\n    fn empty() -> Self {\n        ScopedNoteHash {\n            note_hash: NoteHash::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\n        array_concat(self.note_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            note_hash: reader.read_struct(NoteHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNoteHash {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.note_hash.value, read_request.value(), \"Value of the note hash does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the note hash does not match read request\");\n        assert(\n            read_request.counter() > self.note_hash.counter, \"Read request counter must be greater than the counter of the note hash\"\n        );\n    }\n}\n\nimpl ScopedNoteHash {\n    pub fn expose_to_public(self) -> NoteHash {\n        // Hide the actual counter when exposing it to the public kernel.\n        NoteHash { value: self.note_hash.value, counter: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = NoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"170":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"172":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr","source":"use crate::{\n    abis::{\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    transaction::tx_context::TxContext, utils::arrays::validate_array\n};\n\nstruct PrivateCircuitPublicInputsArrayLengths {\n    note_hash_read_requests: u32,\n    nullifier_read_requests: u32,\n    key_validation_requests_and_generators: u32,\n    note_hashes: u32,\n    nullifiers: u32,\n    l2_to_l1_msgs: u32,\n    private_call_requests: u32,\n    public_call_stack_hashes: u32,\n    note_encrypted_logs_hashes: u32,\n    encrypted_logs_hashes: u32,\n    unencrypted_logs_hashes: u32,\n}\n\nimpl PrivateCircuitPublicInputsArrayLengths {\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\n        PrivateCircuitPublicInputsArrayLengths {\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\n            note_hashes: validate_array(public_inputs.note_hashes),\n            nullifiers: validate_array(public_inputs.nullifiers),\n            l2_to_l1_msgs: validate_array(public_inputs.l2_to_l1_msgs),\n            private_call_requests: validate_array(public_inputs.private_call_requests),\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\n        }\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    note_hashes: [NoteHash; MAX_NOTE_HASHES_PER_CALL],\n    nullifiers: [Nullifier; MAX_NULLIFIERS_PER_CALL],\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs: [L2ToL1Message; MAX_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    tx_context: TxContext,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.returns_hash == other.returns_hash) &\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\n        (self.is_fee_payer == other.is_fee_payer) &\n        (self.max_block_number == other.max_block_number) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\n        (self.note_hashes == other.note_hashes) &\n        (self.nullifiers == other.nullifiers) &\n        (self.private_call_requests == other.private_call_requests) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.l2_to_l1_msgs == other.l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\n        self.historical_header.eq(other.historical_header) &\n        self.tx_context.eq(other.tx_context)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\n\n        fields.extend_from_array(self.max_block_number.serialize());\n\n        for i in 0..self.note_hash_read_requests.len() {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..self.nullifier_read_requests.len() {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..self.key_validation_requests_and_generators.len() {\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\n        }\n        for i in 0..self.note_hashes.len() {\n            fields.extend_from_array(self.note_hashes[i].serialize());\n        }\n        for i in 0..self.nullifiers.len() {\n            fields.extend_from_array(self.nullifiers[i].serialize());\n        }\n        for i in 0..self.private_call_requests.len() {\n            fields.extend_from_array(self.private_call_requests[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n        fields.push(self.public_teardown_function_hash);\n        for i in 0..self.l2_to_l1_msgs.len() {\n            fields.extend_from_array(self.l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        for i in 0..self.note_encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.unencrypted_logs_hashes.len() {\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.tx_context.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            is_fee_payer: reader.read() == 1,\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL]),\n            nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL]),\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            public_teardown_function_hash: reader.read(),\n            l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            tx_context: reader.read_struct(TxContext::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PrivateCircuitPublicInputs {\n    fn empty() -> Self {\n        PrivateCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter : 0 as u32,\n            end_side_effect_counter : 0 as u32,\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            tx_context: TxContext::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PrivateCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PrivateCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x15c9b0a92b9b541598e24c9f0b0b4b04b7f2408599751c45aa12de671fd9b363;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"175":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n"},"176":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr","source":"use crate::{\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for ReadRequest {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\n        ScopedReadRequest { read_request: self, contract_address }\n    }\n}\n\nstruct ScopedReadRequest {\n    read_request: ReadRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<ReadRequest> for ScopedReadRequest {\n    fn inner(self) -> ReadRequest {\n        self.read_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ScopedReadRequest {\n    fn eq(self, other: ScopedReadRequest) -> bool {\n        (self.read_request == other.read_request)\n        & (self.contract_address.eq(other.contract_address))\n    }\n}\n\nimpl Empty for ScopedReadRequest {\n    fn empty() -> Self {\n        ScopedReadRequest {\n            read_request: ReadRequest::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            read_request: reader.read_struct(ReadRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedReadRequest {\n    pub fn value(self) -> Field {\n        self.read_request.value\n    }\n    pub fn counter(self) -> u32 {\n        self.read_request.counter\n    }\n}\n\n#[test]\nfn serialization_of_empty_read() {\n    let item = ReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"179":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr","source":"use crate::{\n    address::AztecAddress,\n    abis::validation_requests::{\n    key_validation_request::KeyValidationRequest,\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\n},\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct KeyValidationRequestAndGenerator {\n    request: KeyValidationRequest,\n    sk_app_generator: Field,\n}\n\nimpl Eq for KeyValidationRequestAndGenerator {\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\n    }\n}\n\nimpl Empty for KeyValidationRequestAndGenerator {\n    fn empty() -> Self {\n        KeyValidationRequestAndGenerator {\n            request: KeyValidationRequest::empty(),\n            sk_app_generator: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\n        array_concat(self.request.serialize(), [self.sk_app_generator])\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\n        let mut reader = Reader::new(fields);\n        let res = Self {\n            request: reader.read_struct(KeyValidationRequest::deserialize),\n            sk_app_generator: reader.read(),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl KeyValidationRequestAndGenerator {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = KeyValidationRequestAndGenerator::empty();\n    let serialized = item.serialize();\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"180":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point::new(fields[0], fields[1], fields[2] as bool),\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"184":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr","source":"use crate::{\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH},\n    hash::compute_siloed_nullifier, traits::{Empty, Hash, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct Nullifier {\n    value: Field,\n    counter: u32,\n    note_hash: Field,\n}\n\nimpl Ordered for Nullifier {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for Nullifier {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for Nullifier {\n    fn eq(self, other: Nullifier) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.note_hash == other.note_hash) \n    }\n}\n\nimpl Empty for Nullifier {\n    fn empty() -> Self {\n        Nullifier {\n            value: 0,\n            counter: 0,\n            note_hash: 0,\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\n        [self.value, self.counter as Field, self.note_hash]\n    }\n}\n\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            note_hash: values[2],\n        }\n    }\n}\n\nimpl Readable for Nullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        // Public kernels output Nullifier instead of ScopedNullifier.\n        // The nullifier value has been siloed.\n        let siloed_request_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.value, siloed_request_value, \"Value of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl Nullifier {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\n        ScopedNullifier { nullifier: self, contract_address }\n    }\n}\n\nstruct ScopedNullifier {\n    nullifier: Nullifier,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<Nullifier> for ScopedNullifier {\n    fn inner(self) -> Nullifier {\n        self.nullifier\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNullifier {\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNullifier {\n    fn value(self) -> Field {\n        self.nullifier.value\n    }\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl Eq for ScopedNullifier {\n    fn eq(self, other: ScopedNullifier) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedNullifier {\n    fn empty() -> Self {\n        ScopedNullifier {\n            nullifier: Nullifier::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            nullifier: reader.read_struct(Nullifier::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.nullifier.value, read_request.value(), \"Value of the nullifier does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.nullifier.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl ScopedNullifier {\n    pub fn nullified_note_hash(self) -> Field {\n        self.nullifier.note_hash\n    }\n\n    pub fn expose_to_public(self) -> Nullifier {\n        // Hide the actual counter and note hash when exposing it to the public kernel.\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Nullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = Nullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"192":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr","source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n  fn eq(self, other: Self) -> bool {\n    (self.nullifier == other.nullifier) &\n    (self.next_nullifier == other.next_nullifier) &\n    (self.next_index == other.next_index)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"193":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"194":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr","source":"use crate::{\n    abis::{\n    private_call_stack_item::PrivateCallStackItem, call_context::CallContext,\n    function_data::FunctionData, caller_context::CallerContext,\n    side_effect::{Ordered, RangeOrdered, Scoped}\n},\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PrivateCallRequest {\n    target: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Ordered for PrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.start_side_effect_counter\n    }\n}\n\nimpl RangeOrdered for PrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.start_side_effect_counter\n    }\n    fn counter_end(self) -> u32 {\n        self.end_side_effect_counter\n    }\n}\n\nimpl Eq for PrivateCallRequest {\n    fn eq(self, other: PrivateCallRequest) -> bool {\n        (self.target == other.target) \n            & (self.call_context == other.call_context) \n            & (self.function_data == other.function_data) \n            & (self.args_hash == other.args_hash) \n            & (self.returns_hash == other.returns_hash)\n            & (self.caller_context == other.caller_context)\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\n    }\n}\n\nimpl Empty for PrivateCallRequest {\n    fn empty() -> Self {\n        PrivateCallRequest {\n            target: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.push(self.target.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.extend_from_array(self.caller_context.serialize());\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = PrivateCallRequest {\n            target: reader.read_struct(AztecAddress::deserialize),\n            call_context: reader.read_struct(CallContext::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            caller_context: reader.read_struct(CallerContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            end_side_effect_counter: reader.read_u32(),\n        };\n        reader.finish();\n        item\n    }\n}\n\nimpl PrivateCallRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\n        ScopedPrivateCallRequest { call_request: self, contract_address }\n    }\n\n    pub fn matches_stack_item(self, stack_item: PrivateCallStackItem) -> bool {\n        (self.target == stack_item.contract_address)\n            & (self.call_context == stack_item.public_inputs.call_context)\n            & (self.function_data == stack_item.function_data)\n            & (self.args_hash == stack_item.public_inputs.args_hash)\n            & (self.returns_hash == stack_item.public_inputs.returns_hash)\n            & (self.start_side_effect_counter\n                                == stack_item.public_inputs.start_side_effect_counter)\n            & (self.end_side_effect_counter\n                                    == stack_item.public_inputs.end_side_effect_counter)\n    }\n}\n\nstruct ScopedPrivateCallRequest {\n    call_request: PrivateCallRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\n    fn inner(self) -> PrivateCallRequest {\n        self.call_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedPrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.call_request.counter_start()\n    }\n}\n\nimpl RangeOrdered for ScopedPrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.call_request.counter_start()\n    }\n    fn counter_end(self) -> u32 {\n        self.call_request.counter_end()\n    }\n}\n\nimpl Eq for ScopedPrivateCallRequest {\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\n        (self.call_request == other.call_request)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedPrivateCallRequest {\n    fn empty() -> Self {\n        ScopedPrivateCallRequest {\n            call_request: PrivateCallRequest::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.call_request.serialize());\n        fields.extend_from_array(self.contract_address.serialize());\n\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = ScopedPrivateCallRequest {\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        item\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = ScopedPrivateCallRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"199":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\n    abis::gas_fees::GasFees,\n    constants::{\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\n    DEFAULT_INCLUSION_FEE\n},\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    utils::reader::Reader\n};\n\nstruct GasSettings {\n    gas_limits: Gas,\n    teardown_gas_limits: Gas,\n    max_fees_per_gas: GasFees,\n    inclusion_fee: Field,\n}\n\nimpl GasSettings {\n    pub fn new(\n        gas_limits: Gas,\n        teardown_gas_limits: Gas,\n        max_fees_per_gas: GasFees,\n        inclusion_fee: Field\n    ) -> Self {\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\n    }\n\n    pub fn default() -> Self {\n        GasSettings::new(\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\n            DEFAULT_INCLUSION_FEE\n        )\n    }\n}\n\nimpl Eq for GasSettings {\n    fn eq(self, other: Self) -> bool {\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\n    }\n}\n\nimpl Empty for GasSettings {\n    fn empty() -> Self {\n        GasSettings::new(\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\n        )\n    }\n}\n\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\n\n        serialized.extend_from_array(self.gas_limits.serialize());\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\n        serialized.push(self.inclusion_fee);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\n        let mut reader = Reader::new(serialized);\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasSettings::empty();\n    let serialized = item.serialize();\n    let deserialized = GasSettings::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"208":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr","source":"use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PrivateCallStackItem {\n    fn empty() -> Self {\n        PrivateCallStackItem {\n            contract_address: AztecAddress::empty(),\n            function_data: FunctionData::empty(),\n            public_inputs: PrivateCircuitPublicInputs::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = PrivateCallStackItem::empty();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item = PrivateCallStackItem::empty();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x065f2831db9ac0db5e710bd3a865b5facd8cf83f1585e1af8fd1d6ce9c47f685;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr","source":"use crate::address::AztecAddress;\nuse crate::traits::{Empty, Serialize, Deserialize};\nuse crate::constants::CALLER_CONTEXT_LENGTH;\nuse crate::utils::reader::Reader;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n    is_static_call: bool,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, other: CallerContext) -> bool {\n        other.msg_sender.eq(self.msg_sender)\n            & other.storage_contract_address.eq(self.storage_contract_address)\n            & other.is_static_call == self.is_static_call\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n            is_static_call: false,\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\n    }\n\n    // Different to an empty context, a hidden context won't reveal the caller's msg_sender and storage_contract_address,\n    // but will still propagate the is_static_call flag.\n    pub fn is_hidden(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array(self.msg_sender.serialize());\n    fields.extend_from_array(self.storage_contract_address.serialize());\n    fields.push(self.is_static_call as Field);\n\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\n    let mut reader = Reader::new(fields);\n\n    let item = CallerContext {\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\n      is_static_call: reader.read_bool(),\n    };\n    reader.finish();\n    item\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = CallerContext::empty();\n    let serialized = item.serialize();\n    let deserialized = CallerContext::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"21":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    fn new(x: Field, y: Field, is_infinite: bool) -> Self {\n        Self { x, y, is_infinite }\n    }\n\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n// Scalar represented as low and high limbs\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    pub fn derive_public_key(self) -> EmbeddedCurvePoint {\n        let public_key = fixed_base_scalar_mul(self.lo, self.hi);\n        EmbeddedCurvePoint { x: public_key[0], y: public_key[1], is_infinite: false }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, key: EmbeddedCurveScalar) -> bool {\n        (key.hi == self.hi) & (key.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n#[foreign(multi_scalar_mul)]\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> [Field; 3]\n// docs:end:multi_scalar_mul\n{}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(\n    scalar_low: Field,\n    scalar_high: Field\n) -> [Field; 3]\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    let scalar = EmbeddedCurveScalar { lo: scalar_low, hi: scalar_high };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n"},"211":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr","source":"use crate::{\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\n    constants::{\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\n},\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct LogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n}\n\nimpl Ordered for LogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for LogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for LogHash {\n    fn eq(self, other: LogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n    }\n}\n\nimpl Empty for LogHash {\n    fn empty() -> Self {\n        LogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n        }\n    }\n}\n\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length]\n    }\n}\n\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n        }\n    }\n}\n\nimpl LogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\n        ScopedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedLogHash {\n    log_hash: LogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<LogHash> for ScopedLogHash {\n    fn inner(self) -> LogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedLogHash {\n    fn eq(self, other: ScopedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedLogHash {\n    fn empty() -> Self {\n        ScopedLogHash {\n            log_hash: LogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(LogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the counter when exposing to public.\n        // The log hash must already be siloed when we call this.\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nstruct EncryptedLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    randomness: Field,\n}\n\nimpl Ordered for EncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for EncryptedLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for EncryptedLogHash {\n    fn eq(self, other: EncryptedLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.randomness == other.randomness) \n    }\n}\n\nimpl Empty for EncryptedLogHash {\n    fn empty() -> Self {\n        EncryptedLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            randomness: 0,\n        }\n    }\n}\n\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.randomness]\n    }\n}\n\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            randomness: values[3],\n        }\n    }\n}\n\nimpl EncryptedLogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedEncryptedLogHash {\n    log_hash: EncryptedLogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\n    fn inner(self) -> EncryptedLogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl ScopedEncryptedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the secret randomness and counter when exposing to public\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\n        // The log hash will already be silo'd when we call this\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nimpl Ordered for ScopedEncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedEncryptedLogHash {\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedEncryptedLogHash {\n    fn empty() -> Self {\n        ScopedEncryptedLogHash {\n            log_hash: EncryptedLogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct NoteLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    note_hash_counter: u32,\n}\n\nimpl NoteLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\n        LogHash { value: self.value, counter: 0, length: self.length }\n    }\n}\n\nimpl Ordered for NoteLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for NoteLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteLogHash {\n    fn eq(self, other: NoteLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.note_hash_counter == other.note_hash_counter) \n    }\n}\n\nimpl Empty for NoteLogHash {\n    fn empty() -> Self {\n        NoteLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            note_hash_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            note_hash_counter: values[3] as u32,\n        }\n    }\n}\n"},"215":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr","source":"struct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n"},"216":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n}\n// docs:end:call-context\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n"},"217":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"22":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"220":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize, Empty}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        (self.is_private == other.is_private)\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nimpl Empty for FunctionData {\n    fn empty() -> Self {\n        FunctionData {\n            selector: FunctionSelector::empty(),\n            is_private: false\n        }\n    }\n\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data = FunctionData::empty();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data = FunctionData::empty();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty function data hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"227":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n    counter: u32,\n}\n\nimpl Ordered for L2ToL1Message {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content, self.counter as Field]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\nimpl L2ToL1Message {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\n        ScopedL2ToL1Message { message: self, contract_address }\n    }\n}\n\nstruct ScopedL2ToL1Message {\n    message: L2ToL1Message,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\n    fn inner(self) -> L2ToL1Message {\n        self.message\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedL2ToL1Message {\n    fn counter(self) -> u32 {\n        self.message.counter\n    }\n}\n\nimpl Eq for ScopedL2ToL1Message {\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\n        (self.message == other.message)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedL2ToL1Message {\n    fn empty() -> Self {\n        ScopedL2ToL1Message {\n            message: L2ToL1Message::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            message: reader.read_struct(L2ToL1Message::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\n#[test]\nfn serialization_of_empty_l2() {\n    let item = L2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = L2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped_l2() {\n    let item = ScopedL2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"229":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"235":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<N> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<N> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<N> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<N> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"237":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr","source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  num_txs: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.num_txs);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let num_txs = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      num_txs,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      num_txs: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.num_txs == other.num_txs)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n"},"238":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"239":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr","source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"241":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n"},"243":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr","source":"use crate::{\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    abis::gas_settings::GasSettings\n};\n\n// docs:start:tx-context\nstruct TxContext {\n    chain_id : Field,\n    version : Field,\n    gas_settings: GasSettings,\n}\n// docs:end:tx-context\n\nimpl TxContext {\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\n        TxContext { chain_id, version, gas_settings }\n    }\n}\n\nimpl Eq for TxContext {\n    fn eq(self, other: Self) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.gas_settings.eq(other.gas_settings))\n    }\n}\n\nimpl Empty for TxContext {\n    fn empty() -> Self {\n        TxContext {\n            chain_id: 0,\n            version: 0,\n            gas_settings: GasSettings::empty(),\n        }\n    }\n}\n\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\n\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.extend_from_array(self.gas_settings.serialize());\n\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let context = Self {\n            chain_id: reader.read(),\n            version: reader.read(),\n            gas_settings: reader.read_struct(GasSettings::deserialize),\n        };\n\n        reader.finish();\n        context\n    }\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context = TxContext::empty();\n    let serialized = context.serialize();\n    let deserialized = TxContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let context = TxContext::empty();\n    let hash = context.hash();\n\n    // Value from tx_context.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"246":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: Field = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point {\n            x: 0,\n            y: 0,\n            is_infinite: false\n        }\n    }\n}\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn pub_key_to_bytes(pk: Point) -> [u8; 64] {\n    assert(!pk.is_infinite, \"Point at infinity is not a valid public key.\");\n    let mut result = [0 as u8; 64];\n    let x_bytes = pk.x.to_be_bytes(32);\n    let y_bytes = pk.y.to_be_bytes(32);\n    for i in 0..32 {\n        result[i] = x_bytes[i];\n        result[i + 32] = y_bytes[i];\n    }\n    result\n}\n"},"247":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"249":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n"},"25":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n#[no_predicates]\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    let value = pedersen_commitment_with_separator(input, 0);\n    if (value.x == 0) & (value.y == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value.x, y: value.y, is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        points[i] = EmbeddedCurveScalar::from_field(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let values = multi_scalar_mul(generators, points);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: values[2] as bool }\n}\n\n#[no_predicates]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let v1 = pedersen_commitment_with_separator(input, separator);\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    multi_scalar_mul(\n        [length_generator[0], v1],\n        [EmbeddedCurveScalar { lo: N as Field, hi: 0 }, EmbeddedCurveScalar { lo: 1, hi: 0 }]\n    )[0]\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n#[test]\nfn assert_pedersen_noir() {\n    // TODO: make this a fuzzer test once fuzzer supports curve-specific blackbox functions.\n    let input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq(pedersen_hash_with_separator(input, 4), pedersen_hash_with_separator_noir(input, 4));\n    assert_eq(pedersen_commitment_with_separator(input, 4), pedersen_commitment_with_separator_noir(input, 4));\n}\n"},"263":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"273":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"289":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"292":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\n    address::{\n    eth_address::EthAddress, salted_initialization_hash::SaltedInitializationHash,\n    aztec_address::AztecAddress\n},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::pedersen_hash, traits::{ToField, FromField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH = 1;\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n       PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            pedersen_hash(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"293":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\n    address::{eth_address::EthAddress, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            pedersen_hash(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"303":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/main.nr","source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n\ncontract Token {\n    // Libs\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        hash::compute_secret_hash,\n        prelude::{NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress},\n        encrypted_logs::{\n        encrypted_note_emission::{\n        encode_and_encrypt_note, encode_and_encrypt_note_with_keys,\n        encode_and_encrypt_note_with_keys_unconstrained\n    },\n        encrypted_event_emission::{encode_and_encrypt_event, encode_and_encrypt_event_with_keys_unconstrained}\n    }\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public, compute_authwit_nullifier};\n    // docs:end:import_authwit\n\n    use crate::types::{transparent_note::TransparentNote, token_note::{TokenNote, TOKEN_NOTE_LEN}, balances_map::BalancesMap};\n    // docs:end::imports\n\n    #[aztec(event)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: BalancesMap<TokenNote>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128>>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n\n    // docs:start:admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[aztec(public)]\n    #[aztec(view)]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_public\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n\n    // docs:start:mint_private\n    #[aztec(public)]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        storage.balances.add(caller, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, caller, caller));\n\n        Token::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    // docs:start:shield\n    #[aztec(public)]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n\n    // docs:start:transfer_public\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n\n    // docs:start:burn_public\n    #[aztec(public)]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:redeem_shield\n    #[aztec(private)]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let pending_shields = storage.pending_shields;\n        let secret_hash = compute_secret_hash(secret);\n        // Get 1 note (set_limit(1)) which has amount stored in field with index 0 (select(0, amount)) and secret_hash\n        // stored in field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TransparentNote::properties().amount, amount, Option::none()).select(\n            TransparentNote::properties().secret_hash,\n            secret_hash,\n            Option::none()\n        ).set_limit(1);\n        let notes = pending_shields.get_notes(options);\n        let note = notes.get_unchecked(0);\n        // Remove the note from the pending shields set\n        pending_shields.remove(note);\n\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        storage.balances.add(to, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, to));\n    }\n    // docs:end:redeem_shield\n\n    // docs:start:unshield\n    #[aztec(private)]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n\n    // docs:start:transfer\n    #[aztec(private)]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, from_ivpk));\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk));\n\n        Transfer { from, to, amount: amount.to_field() }.emit(encode_and_encrypt_event_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk));\n    }\n    // docs:end:transfer\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[aztec(private)]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier, 0);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_from\n    #[aztec(private)]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, from_ivpk));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, to_ivpk));\n    }\n    // docs:end:transfer_from\n\n    // docs:start:burn\n    #[aztec(private)]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n\n    /// Internal ///\n\n    // docs:start:increase_public_balance\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n\n    // docs:start:balance_of_private\n    unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.balance_of(owner).to_field()\n    }\n    // docs:end:balance_of_private\n}\n// docs:end:token_all"},"315":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr","source":"use dep::aztec::{\n    prelude::{AztecAddress, NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash},\n    note::utils::compute_note_hash_for_consumption, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app\n};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\nglobal TOKEN_NOTE_LEN: Field = 3; // 3 plus a header.\n// TOKEN_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TOKEN_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n#[aztec(note)]\nstruct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NoteInterface<TOKEN_NOTE_LEN, TOKEN_NOTE_BYTES_LEN> for TokenNote {\n    // docs:start:nullifier\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self {\n            amount,\n            npk_m_hash: owner_npk_m_hash,\n            randomness: unsafe_rand(),\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n"},"317":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr","source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::{note_getter_options::PropertySelector, utils::compute_note_hash_for_consumption},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash}\n};\n\nglobal TRANSPARENT_NOTE_LEN: Field = 2;\n// TRANSPARENT_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TRANSPARENT_NOTE_BYTES_LEN: Field = 2 * 32 + 64;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[aztec(note)]\nstruct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nstruct TransparentNoteProperties {\n    amount: PropertySelector,\n    secret_hash: PropertySelector,\n}\n\nimpl NoteInterface<TRANSPARENT_NOTE_LEN, TRANSPARENT_NOTE_BYTES_LEN> for TransparentNote {\n\n    // Custom serialization to avoid disclosing the secret field\n    fn serialize_content(self) -> [Field; TRANSPARENT_NOTE_LEN] {\n        [self.amount, self.secret_hash]\n    }\n\n    // Custom deserialization since we don't have access to the secret plaintext\n    fn deserialize_content(serialized_note: [Field; TRANSPARENT_NOTE_LEN]) -> Self {\n        TransparentNote {\n            amount: serialized_note[0],\n            secret_hash: serialized_note[1],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): Ensure nullifier collisions are prevented\n    fn compute_note_hash_and_nullifier(self, _context: &mut PrivateContext) -> (Field, Field) {\n        self.compute_note_hash_and_nullifier_without_context()\n    }\n\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit. \n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n\n    // CUSTOM FUNCTIONS FOR THIS NOTE TYPE\n    // Custom serialization forces us to manually create the metadata struct and its getter\n    pub fn properties() -> TransparentNoteProperties {\n        TransparentNoteProperties {\n            amount: PropertySelector { index: 0, offset: 0, length: 32 },\n            secret_hash: PropertySelector { index: 1, offset: 0, length: 32 }\n        }\n    }\n}\n// docs:end:token_types_all\n"},"32":{"path":"std/merkle.nr","source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n"},"354":{"path":"/usr/src/noir-projects/noir-contracts/contracts/escrow_contract/src/main.nr","source":"// Sample escrow contract that stores a balance of a private token on behalf of an owner.\ncontract Escrow {\n    use dep::aztec::prelude::{AztecAddress, EthAddress, FunctionSelector, NoteHeader, PrivateContext, PrivateImmutable};\n    use dep::aztec::encrypted_logs::encrypted_note_emission::encode_and_encrypt_note;\n\n    use dep::address_note::address_note::AddressNote;\n\n    use dep::token::Token;\n\n    #[aztec(storage)]\n    struct Storage {\n        owner: PrivateImmutable<AddressNote>,\n    }\n\n    // Creates a new instance\n    #[aztec(private)]\n    #[aztec(initializer)]\n    fn constructor(owner: AztecAddress) {\n        let header = context.get_header();\n        let owner_npk_m_hash = header.get_npk_m_hash(&mut context, owner);\n\n        let mut note = AddressNote::new(owner, owner_npk_m_hash);\n        storage.owner.initialize(&mut note).emit(encode_and_encrypt_note(&mut context, context.msg_sender(), owner));\n    }\n\n    // Withdraws balance. Requires that msg.sender is the owner.\n    #[aztec(private)]\n    fn withdraw(token: AztecAddress, amount: Field, recipient: AztecAddress) {\n        let sender = context.msg_sender();\n\n        let note = storage.owner.get_note();\n        assert(note.address == sender);\n\n        Token::at(token).transfer(recipient, amount).call(&mut context);\n    }\n}\n"},"355":{"path":"/usr/src/noir-projects/aztec-nr/address-note/src/address_note.nr","source":"use dep::aztec::{\n    protocol_types::{address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal ADDRESS_NOTE_LEN: Field = 3;\n// ADDRESS_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal ADDRESS_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:address_note_def\n// Stores an address\n#[aztec(note)]\nstruct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n\nimpl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"},"38":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"4":{"path":"std/cmp.nr","source":"// docs:start:eq-trait\ntrait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\nimpl Eq for Field { fn eq(self, other: Field) -> bool { self == other } }\n\nimpl Eq for u64 { fn eq(self, other: u64) -> bool { self == other } }\nimpl Eq for u32 { fn eq(self, other: u32) -> bool { self == other } }\nimpl Eq for u8 { fn eq(self, other: u8) -> bool { self == other } }\nimpl Eq for u1 { fn eq(self, other: u1) -> bool { self == other } }\n\nimpl Eq for i8 { fn eq(self, other: i8) -> bool { self == other } }\nimpl Eq for i32 { fn eq(self, other: i32) -> bool { self == other } }\nimpl Eq for i64 { fn eq(self, other: i64) -> bool { self == other } }\n\nimpl Eq for () { fn eq(_self: Self, _other: ()) -> bool { true } }\nimpl Eq for bool { fn eq(self, other: bool) -> bool { self == other } }\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3) & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\nstruct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n// docs:start:ord-trait\ntrait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"47":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"5":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\nstruct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len);\n        self.get_unchecked(index)\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Responds with undefined data for `index` where `self.len < index < self.max_len()`.\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Does not check whether the passed `index` is a valid index within the vector.\n    ///\n    /// Silently writes past the end of the vector for `index` where `self.len < index < self.max_len()`\n    /// Panics if the given index points beyond the maximum length of the vector (`self.max_len()`).\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        \n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen>  {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n    // TODO: Allow imports from \"super\"\n    use crate::collections::bounded_vec::BoundedVec;\n\n    #[test]\n    fn empty_equality() {\n        let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n        let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n        assert_eq(bounded_vec1, bounded_vec2);\n    }\n\n    #[test]\n    fn inequality() {\n        let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n        let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n        bounded_vec1.push(1);\n        bounded_vec2.push(2);\n\n        assert(bounded_vec1 != bounded_vec2);\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n}\n"},"64":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::{Point, pub_key_to_bytes},\n    utils::arr_copy_slice\n};\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret_fields = multi_scalar_mul([point], [secret]);\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/6061): make the func return Point struct directly\n    let shared_secret = pub_key_to_bytes(Point::new(shared_secret_fields[0], shared_secret_fields[1], false));\n    let mut shared_secret_bytes_with_separator = [0 as u8; 65];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[64] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nfn check_point_to_symmetric_key() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar::new(\n        0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    );\n    let point = Point::new(\n        0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        false\n    );\n\n    let key = point_to_symmetric_key(secret, point);\n    // The following value gets updated when running encrypt_buffer.test.ts with AZTEC_GENERATE_TEST_DATA=1\n    let expected_key = [\n        49, 167, 146, 222, 151, 129, 138, 184, 87, 210, 245, 249, 99, 100, 1, 59, 223, 180, 5, 99, 14, 7, 177, 236, 159, 203, 231, 72, 220, 180, 241, 23\n    ];\n    assert_eq(key, expected_key);\n}\n"},"65":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::PrivateContext,\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}},\n    state_vars::{shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter}\n};\n\nglobal DELAY = 5;\n\n// docs:start:key-getters\ntrait KeyGetters {\n  fn get_npk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ivpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ovpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_tpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_npk_m_hash(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Field;\n}\n\nimpl KeyGetters for Header {\n    fn get_npk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, NULLIFIER_INDEX, self)\n    }\n\n    fn get_ivpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, INCOMING_INDEX, self)\n    }\n\n    fn get_ovpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, OUTGOING_INDEX, self)\n    }\n\n    fn get_tpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, TAGGING_INDEX, self)\n    }\n\n    fn get_npk_m_hash(self, context: &mut PrivateContext, address: AztecAddress) -> Field {\n        get_master_key(context, address, NULLIFIER_INDEX, self).hash()\n    }\n}\n// docs:end:key-getters\n\nfn get_master_key(\n    context: &mut PrivateContext,\n    address: AztecAddress,\n    key_index: Field,\n    header: Header\n) -> Point {\n    let key = fetch_key_from_registry(context, key_index, address, header);\n    if is_empty(key) {\n        // Keys were not registered in registry yet --> fetch key from PXE\n        let keys = fetch_and_constrain_keys(address);\n        // Return the corresponding to index\n        keys.get_key_by_index(key_index)\n    } else {\n        // Keys were registered --> return the key\n        key\n    }\n}\n\nfn fetch_key_from_registry(\n    context: &mut PrivateContext,\n    key_index: Field,\n    address: AztecAddress,\n    header: Header\n) -> Point {\n    let x_coordinate_map_slot = key_index * 2 + 1;\n    let y_coordinate_map_slot = x_coordinate_map_slot + 1;\n    let x_coordinate_derived_slot = derive_storage_slot_in_map(x_coordinate_map_slot, address);\n    let y_coordinate_derived_slot = derive_storage_slot_in_map(y_coordinate_map_slot, address);\n\n    let x_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        x_coordinate_derived_slot\n    );\n    let y_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        y_coordinate_derived_slot\n    );\n    let x_coordinate = x_coordinate_registry.get_value_in_private(header);\n    let y_coordinate = y_coordinate_registry.get_value_in_private(header);\n\n    Point::new(x_coordinate, y_coordinate, false)\n}\n\n// Passes only when keys were not rotated - is expected to be called only when keys were not registered yet\nfn fetch_and_constrain_keys(address: AztecAddress) -> PublicKeys {\n    let (public_keys, partial_address) = get_public_keys_and_partial_address(address);\n\n    let computed_address = AztecAddress::compute(public_keys.hash(), partial_address);\n\n    assert(computed_address.eq(address));\n\n    public_keys\n}\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n"},"66":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr","source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH, hash::poseidon2_hash,\n    point::Point, traits::{Deserialize, Serialize, Empty, is_empty}\n};\nuse crate::keys::constants::{NUM_KEY_TYPES, NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX};\n\nglobal PUBLIC_KEYS_LENGTH = 12;\n\nstruct PublicKeys {\n    npk_m: Point,\n    ivpk_m: Point,\n    ovpk_m: Point,\n    tpk_m: Point,\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m : Point::empty(),\n            ivpk_m : Point::empty(),\n            ovpk_m : Point::empty(),\n            tpk_m : Point::empty()\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        ( self.npk_m == other.npk_m ) &\n        ( self.ivpk_m == other.ivpk_m ) &\n        ( self.ovpk_m == other.ovpk_m ) &\n        ( self.tpk_m == other.tpk_m )\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash(\n                [\n                self.npk_m.x,\n                self.npk_m.y,\n                self.npk_m.is_infinite as Field,\n                self.ivpk_m.x,\n                self.ivpk_m.y,\n                self.ivpk_m.is_infinite as Field,\n                self.ovpk_m.x,\n                self.ovpk_m.y,\n                self.ovpk_m.is_infinite as Field,\n                self.tpk_m.x,\n                self.tpk_m.y,\n                self.tpk_m.is_infinite as Field,\n                GENERATOR_INDEX__PUBLIC_KEYS_HASH\n            ]\n            )\n        }\n        )\n    }\n\n    pub fn get_key_by_index(self, index: Field) -> Point {\n        assert(index as u8 < NUM_KEY_TYPES, \"Invalid key index\");\n        if index == NULLIFIER_INDEX {\n            self.npk_m\n        } else if index == INCOMING_INDEX {\n            self.ivpk_m\n        } else if index == OUTGOING_INDEX {\n            self.ovpk_m\n        } else {\n            self.tpk_m\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.x,\n            self.npk_m.y,\n            self.npk_m.is_infinite as Field,\n            self.ivpk_m.x,\n            self.ivpk_m.y,\n            self.ivpk_m.is_infinite as Field,\n            self.ovpk_m.x,\n            self.ovpk_m.y,\n            self.ovpk_m.is_infinite as Field,\n            self.tpk_m.x,\n            self.tpk_m.y,\n            self.tpk_m.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: Point::new(serialized[0], serialized[1], serialized[2] as bool),\n            ivpk_m: Point::new(serialized[3], serialized[4], serialized[5] as bool),\n            ovpk_m: Point::new(serialized[6], serialized[7], serialized[8] as bool),\n            tpk_m: Point::new(serialized[9], serialized[10], serialized[11] as bool)\n        }\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: Point { x: 1, y: 2, is_infinite: false },\n        ivpk_m: Point { x: 3, y: 4, is_infinite: false },\n        ovpk_m: Point { x: 5, y: 6, is_infinite: false },\n        tpk_m: Point { x: 7, y: 8, is_infinite: false }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x146f68c0e0ba4067d61a3304bbfdec0797d5df1357db6c01247c48bfb345c7d7;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nfn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nfn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: Point { x: 1, y: 2, is_infinite: false },\n        ivpk_m: Point { x: 3, y: 4, is_infinite: false },\n        ovpk_m: Point { x: 5, y: 6, is_infinite: false },\n        tpk_m: Point { x: 7, y: 8, is_infinite: false }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.x, deserialized.npk_m.x);\n    assert_eq(keys.npk_m.y, deserialized.npk_m.y);\n    assert_eq(keys.ivpk_m.x, deserialized.ivpk_m.x);\n    assert_eq(keys.ivpk_m.y, deserialized.ivpk_m.y);\n    assert_eq(keys.ovpk_m.x, deserialized.ovpk_m.x);\n    assert_eq(keys.ovpk_m.y, deserialized.ovpk_m.y);\n    assert_eq(keys.tpk_m.x, deserialized.tpk_m.x);\n    assert_eq(keys.tpk_m.y, deserialized.tpk_m.y);\n}\n"},"80":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n"},"81":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr","source":"use std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext, oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: Header, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for Header {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier);\n\n        // 2) Check that the witness we obtained matches the nullifier\n        assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n        // 3) Compute the nullifier tree leaf\n        let nullifier_leaf = witness.leaf_preimage.hash();\n\n        // 4) Prove that the nullifier is in the nullifier tree\n        assert(\n            self.state.partial.nullifier_tree.root\n            == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n        );\n        // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n        //     was included in the nullifier tree.\n    }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, N, M>(header: Header, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M>;\n}\n\nimpl ProveNoteIsNullified for Header {\n    // docs:start:prove_note_is_nullified\n    fn prove_note_is_nullified<Note, N, M>(self, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M> {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n    // docs:end:prove_note_is_nullified\n}\n"},"89":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<N>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, N>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<N, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<N, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"}}}