{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"GasToken","functions":[{"name":"claim_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"set_portal","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/72WzW7TQBSFx0nTRKR14tAkzv+fx2mpWIKQkNiz5glAIIEELBAs4FF4B16kD8GeNRLbMufOz4njNpKlqiNNM75zvnvuzLjyZKquVMt0pWbKNURUrI7NT4T+QvmRGdRMj2IV+ZDGJKiadjJVlxGER2vz58ET5S0y1VDFBlVDvGSqUVYg47FVSM9Qn0Tb2muaUrS0tvXxmta25lLjqZkF3Qk1p8cyPMHQ9HiF+RSjpxHrqFsfkcUaEzHsbGVwbe3Vfm0aVFYBcWwU13sNplYB71Pm2LFWHavooNdCOjzGe48qPJ4WuWZThi23io4s8hwjLrK8+WitOJCtBleLRJLkMUa3Jnn+86pW3Kc2d7570wl2iyfYkRNsF08Qw4THlpjek2KeYXTbsfXk2HrwsAvpuoV0bNYNUt1UUlIsqcfXKMlU9Mr8PqQTxGe6ZoPqjNiZ1SR2KOh7hj3aFxSCPtE+0b5DXzPs0YGgEAyIDogOHPqFYY8OBYVgSHRIdOjQdwx7NBUUgpRoSjR16FuGPToSFIIR0RHRkUNfMuzRsaAQjImOiY4d+olhj04EhWBCdEJ0Yn8rI8btG8MenQoKwZTolOjUoV8Z9uhMUAhmRGdEZ+VCZ+EVOIAYtzcMe3QuKARzonOic4d+ZNijC0EhWBBdEF2UC12Et+YAYtyWDHt0KSgES6JLosuy2zJsS0VkXh0ZVEeG97KW9DBiNvs7wx5dCQrBiuiK6KrstgrncwAxbh8Y9uhaUAjWRNdE1w79zLBHN4JCsCG6IbopF7oJbhWR6b249Ksj8zsvzGz2D4Y9mgkKQUY0I5qV3bLwpldE0sOIfPb/8SOeCaj45a6Hi4lp2n/OTcajnWuKFitdtMpVyJhzBqvOKTrnZeDC3kgunP6R2TsoLiMRXiKELhX/tU9+uWAutZdtaWwnajaISe+Au9sF/i//7JS1V7BchJLionTYmy73Ru/dubgmXboU/v4Frb3PZTyQrkuTSLGZfXfCXc1qtCtHn0eOiIoXwjwUp1lcXiwuyXZnfFqItmKNY91S7vYydzuYi7V2k40NRukV+n+JxmtyCw0AAA==","debug_symbols":"7ZztahpREIbvxd+h7DtzPnMrpRTzVYRgQmIKJeTeq9U1EW2lQR5djv+izjrzTng4sjzs6+jm9urlx/fJ9O7heXT59XV0/3A9nk0epvNXr6Pui7o/7z4/jqeLN55n46fZ6NLl3cXodnqz+DOlt4vR3eT+dnRpNbxdbFUre1pVK5duXa1Qd1RH97Cqjp7qurrGXcWq3heb9hSX2OVVcYnBPxZ/u1hktYayhoayxoaypoay5oayloayVj6r6jpr7v49fi79N+fF5/0YpS6nt27Q02vQ09ugp/dBTx8GPX0c9PTptKdPvp4+bUy/XVu9/9764dDZXZtjWX9veK/11VLyeSnbSznxs/UoS/ETP/SOs5QTP42Os5QTP+SOs5QTPzuPs5TzkbxjKecjecdSynkp20s5/07ZXkrYf2shby5leZl97jL/3GXhc5f95RAp/a0iN9/7D7fUr0+ucLI3uEJuKGtpKGttJ2vsGsqqhrIan/U/Dl7VsD7Ta/xwK8xX50j0gc8fBj5/HPj8aeDz54HPf4jfC+5azx/SxvzLJhVokjqiiYgmRjRxokkgmkSiSSKaZKIJQXwiiM8E8ZkgPhPEZ4L4TBCfCeIzQXwmiM8E8ZkgvhDEF4L4QhBfCOILQXwhiC8E8YUgvhDEF4L4ShBfCeIrQXwliK8E8ZUgvhLEV4L4ShBfCeLVdUgXIV0M6eJIl4B0iUiXhHTJSJeCdEHYF8K+EPaFsC+EfSHsC2FfCPtC2BfCvhD2DWHfEPYNYd8Q9g1h3xD2DWHfEPYNYd8Q9h1h3xH2HWHfEfYdYd8R9h1h3xH2HWHfEfYDwn5A2A8I+wFhPyDsB4T9gLAfEPYDwn5A2I8I+xFhPyLsR4T9iLAfEfYjwn5E2Ed0PSG+nhBhT4ixJ0TZE+LsCZH2hFh7QrQ9Id6eEHFPiLknRN0T4u4JkfeE2HtC9D0h/p4QgU+IwSdE4RPi8AmR+IRYfEI0PiEenxCRT4jJJ0TlE+LyCZH5hNh8QnQ+IT6fEKFPiNEnROkT4vQJkfqEWH1CtD4hXp8hXp8hXp8hXp8hXp91AekSkS4J6ZKRLgXpgrCPeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH2GeH12EK8vdv0DtRRT2OiyXR2T+ierxpTen6i1+1GBIa+LY7enuCTrHwNW0uaDvVZhc0thS0tha0NhD+J8DiasWgrrLYUNLYWNLYVt6UdFbOlHxUH06Zj7Z0UrWTrhsLWhsAeRyQcTVi2FtZbCekthQ0thY0thU0thcxth5y9+jp8m46v72+f5JYvPXqbXs8nDdPVy9utx+cm89jc="},{"name":"deploy","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"artifact_hash","type":{"kind":"field"},"visibility":"private"},{"name":"private_functions_root","type":{"kind":"field"},"visibility":"private"},{"name":"public_bytecode_commitment","type":{"kind":"field"},"visibility":"private"},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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viNtnz3S86/Zv+WvuXDL8L9m/J6/pnzPXzN9z18T3/PXzN/z1yzf89es3/PXAJ4CZYj56EDsQ+XBNI7Hp8fxS1u57MNxqJ3wUDF896HW7enjtvHnR/g7vxX0PP547+OXex9/uvfx497Hn+99/OXex1/vffzt3sffb338+d637nzvW3e+96073/vWne996873vnXne9+6871v3fnet+5871t3ufetu9z71l3ufesu9751l3vfugv1c38+VlnMcX586ud+9fgr9ZNnPvb1zMt6enzqJ0/9+NRPnvrxqZ889eNT+/368an9fv341M/96rfRK/Vzv358ar9fPf5G7ffrx6e+devHp75168envnXrx6e+devHp75168envnXrx7/3rbvd+9bd7n3r7t9/674zO2Zcnh8ex/XLLw+9fiVmH+9eQLl7AdPdC4i7FzDfvYDl7gWsPAU8j7TxHQlxV47jsXJ5XKJypHEsL+m+vBdcylO6aRgYDzV+96GQXwBMQ7n38ad7Hz/uffz53sdf7n389d7H3+59/P3Wxx+Hex//3rfueO9bd7z3rTve+9Yd733rjve+dcd737rjvW/d8d63brn3rVvufeuWe9+65d63LmIaRc/j3/vWLfe+dcu9b91y71u33PvWnaif+7XfEp4m6ud+/fjUT57ab0pOE/WTp3586idP/fjUT57q8YPa79ePT+3368enfu7XfuFnCurnfv34ce/jU/v9+vGpb9368alv3frxqW/d+vGpb93q8WfqW7d+fOpbt378e9+6871vXcgUkI7H//5b951fLxy216+DDV9+ye7162DzcvcC1rsXsN29gP3mBSzD3QsY715A4S7gSO6PAsafCjj7yceGli9Dacf9uDOWSanYUCqW2w389Mvh5/8dcruBhgK43UBDAdxuoKEAbjdQL2DldgMNBXC7gYYCuN1A/R2blfuGbyiA+9ZuKIDoJn4eiehufR4Jclt+Wef4ZYvrxQtqx17JcY7TI218R9q/+0jQ3yaBTL/pePzx3scv9z7+dO/jx72PP9/7+Mu9j7/e+/jbvY9/71t3v/etu9/71t3vfevu9751IVNvOh7/3rfufu9bd7/3rbvf+9bdb33rxnDrWzeGW9+6Mdz61o3h1rduDLe+dWO49a0bw61v3RhufevGcOtbN4Z737oj9XO/9sJfjNTP/frxqZ88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tis1VCvlpTJtEmqoVspLZdqa01CtlJfKtCGmoVopL5VpG0pDtVJeKtPmj4ZqpbxUpi0XDdVKealMGx0aqpXyUpm2FzRUK+WlMk3qb6hWyktlmnjfUK2Ul8o0lb6hWikvlWlyfEO1Ul4q03T3hmqlvFSmCewN1Up5qUxT0huqlfJSUnPPV6m556vU3PNVau75KjX3fJWae75KzT1fpeaer1Jzz1epueer1NzzVWru+So193yVmnu+Ss09X6Xmnq9Sc89Xqbnnm9Tc801q7vkmNfd8k5p7vg0hVa2Sl9qk5p5vUnPPN6m555vU3PNNau75JjX3fJOae75JzT3fpOaeb1Jzzzepueeb1NzzTWru+SY193yTmnu+Sc0936Tmnm9Sc883qbnnm9Tc801q7vkmNfd8k5p7vknNPd+k5p5vUnPPN6m555vU3PNNau75JjX3fJOae75JzT3fpOaeb1Jzzzepueeb1NzzTWru+SY193yTmnu+Sc0936Tmnm9Sc883qbnnm9Tc801q7vkmNfd8k5p7vknNPd+k5p5vUnPPN6m555vU3PNNau75JjX3fJOae75JzT3fpOaeb1Jzzzepueeb1NzzTWru+SY193yTmnu+Sc0936Tmnm9Sc883qbnnm9Tc801q7vkmNfd8k5p7vknNPd+k5p5vUnPPN6m555vU3PNNau75JjX3fJOae75JzT3fpOaeb1Jzzzepueeb1NzzTWru+SY193yTmnu+Sc0936Tmnm9Sc883qbnnm9Tc801q7vkmNfd8l5p7vkvNPd+l5p7vUnPP9yGkqlXyUrvU3PNdau75LjX3fJeae75LzT3fpeae71Jzz3epuee71NzzXWru+S4193yXmnu+S80936Xmnu9Sc893qbnnu9Tc811q7vkuNfd8l5p7vkvNPd+l5p7vUnPPd6m557vU3PNdau75LjX3fJeae75LzT3fpeae71Jzz3epuee71NzzXWru+S4193yXmnu+S80936Xmnu9Sc893qbnnu9Tc811q7vkuNfd8l5p7vkvNPd+l5p7vUnPPd6m557vU3PNdau75LjX3fJeae75LzT3fpeae71Jzz3epuee71NzzXWru+S4193yXmnu+S80936Xmnu9Sc893qbnnu9Tc811q7vkuNfd8l5p7vkvNPd+l5p7vUnPPd6m557vU3PNdau75LjX3fJeae75LzT3fpeae71Jzz3epuee71NzzXWru+S4193yXmnu+S80936Xmnu9Sc893qbnnu9Tc811q7vkuNfd8l5p7vkvNPd+V5p6vg9Lc80e1Ql7qUa2Ql3pUK+SlHtWGVLVCXupRrZCXelQr5KUe1Qp5qUe1Ul5Kae75o1opL6U09/xRrZSXUpp7/qhWykspzT1/VCvlpZTmnj+qlfJSSnPPH9VKeSmlueePaqW8lNLc80e1Ul5Kae75o1opL6U09/xRrZSXUpp7/qhWykspzT1/VCvlpZTmnj+qlfJSSnPPH9VKeSmlueePaqW8lNLc80e1Ul5Kae75o1opL6U09/xRrZSXUpp7/qhWykspzT1/VCvlpZTmnj+qlfJSSnPPH9VKeSmlueePaqW8lNLc80e1Ul5Kae75o1opL6U09/xRrZSXUpp7/qhWykspzT1/VCvlpZTmnj+qlfJSSnPPH9VKeSmlueePaqW8lNLc80e1Ul5Kae75o1opL6U09/xRrZSXUpp7/qhWykspzT1/VCvlpZTmnj+qlfJSSnPPH9VKeSmlueePaqW8lNLc80e1Ul5Kae75o1opL6U09/xRrZSXUpp7/qhWykspzT1/VCvlpZTmnj+qVfJSo9Tc81Fq7vkoNfd8lJp7/qhFqlolLzVKzT0fpeaej1Jzz0epueej1NzzUWru+Sg193yUmns+Ss09H6Xmno9Sc89Hqbnno9Tc81Fq7vkoNfd8lJp7PkrNPR+l5p6PUnPPR6m556PU3PNRau75KDX3fJSaez5KzT0fpeaej1Jzz0epueej1NzzUWru+Sg193yUmns+Ss09H6Xmno9Sc89Hqbnno9Tc81Fq7vkoNfd8lJp7PkrNPR+l5p6PUnPPR6m556PU3PNRau75KDX3fJSaez5KzT0fpeaej1Jzz0epueej1NzzUWru+Sg193yUmns+Ss09H6Xmno9Sc89Hqbnno9Tc81Fq7vkoNfd8lJp7PkrNPR+l5p6PUnPPR6m556PU3PNRau75KDX3fJSaez5KzT0fpeaej1Jzz0epueej1NzzUWru+Sg193yUmns+Ss09H6Xmno9Sc8/HTLOxH6cejlOXvfKz3znHNE3zjw9P0za+zrHHX/zJZSjPD5dh/cpuP/vJ23785FL5yXOUH5+dYzrXPpH7sPZvap/Ii1n7N7UPay+rfSKfbu3f1D5RarH2b2qfKMNZ+ze1T5Rorf2b2if6rsTav6V9ybSZxNq/qb37errau6+XVfvtCWPe53Pt3dfT1T6svaz27uvpau++Xlbt15f2y7n27uvpau++nq727uvJap9pS561f1N79/V0tXdfL6v28/P3dOdlPdfefT1d7cPay2rvvp6u9u7r6Wrvvp6u9u7r6Wrvvp6s9pk2Nlv7N7V3X09Xe/f1dLV3X09X+7D2stq7r6ervft6utq7r6ervft6utq7ryer/eS+nq727uvpau++nq727uvpah/WXlZ79/V0tXdfT1d79/V0tXdfT1d79/VktQ/39XS1d19PV3v39XS1d19PV/uw9rLau6+nq737errau6+nq737errau68nq/3svp6u9s73XbV//ISnROO+T0jtq3sz5rD2sto73+tq73yvq73zva72zve62jvfy2q/ON/rau/f29HV3r+3o6u9+3q62oe1T6p9dTfi4r6ervbu6+lq776ervbu62XVvrojbXFfT1b71X09Xe3d19PV3n09Xe3d19PVPqx9Uu2rv6e7uq+nq737errau6+nq737errau68nq/3mvp6u9u7r6Wrvvp6u9u7r6Wof1l5We/f1dLV3X09Xe/f1dLV3X09Xe/f1ZLXf3dfT1d59PV3t3dfT1d59PV3tw9rLau++nq727uvpau++nq727uvpau++nqr20+C+nq727uvpau++nq727uvpah/WXlZ79/V0tXdfT1d79/V0tXdfT1d79/VktR/d19PV3n09Xe3d19PV3vkerz1yu8U0OoWzK+SszK6QEy27Qs6d5AoVp0N2hZzh2BVy0mJXyL/nwK5QWCFyhdxTYFfIPYW+CtV2nE3FPQV2hdxTYFfIPQVyhSb3FPoqVNvBM03uKbAr5J4Cu0LuKbArFFaIXCH3FNgVck+hr0LV3/WZ3FNgV8g9BXaF3FMgVyjcU2BXyD0FdoXcU2BXyD0FdoXCCpEr5J4Cu0LuKbAr5J4Cu0LuKbAr5J4CuUKzewrsCrmnwK6QewrsCrmnwK5QWCFyhdxTYFfIPQV2hdxTYFfIPQV2hdxTIFdocU+BXSH3FNgVck+BXSH3FNgVCitErpB7CuwKuafArpB7CuwKuafArpB7CuQKre4psCvkngK7Qu4psCvkngK7QmGFyBVyHmpRaNyePKZSFqRC1RmNq/MQu0LO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Op4fMv+n5/nHm5+/3Pz8083PHzc//3zz8y83P/968/Pf/P4N7vu39vur88x9/9bPz33/1s/Pff/Wz899/9Z+f3KGzP/peX7u+7d+fu77t35+7vu3fn7u+7d+fu77t9p/WLjv3/r5ue/f+vm579/6+bnv3/r5ue/f+vm579/6+bnv3/r5ue/f+vm579/6+W9+/643v3/Xm9+/683v3/Xm9+968/t3vfn9u978/l1vfv+uN79/15vfv9vN79/t5vfvdvP7d7v5/QuZv9Tz/De/f7eb37/bze/f7eb373bz+3e/+f273/z+3W9+/+43v38h85d6nv/m9+9+8/t3v+/9W7b1365eH9+ev/c0jsP+On6Z//kH938r5y/ebsNzkvW+x09lH39u+80/t//enzt/wbPhz42/+efKb/656Tf/HOABNu7L868Z922p/ANcxuXHh5ep/Pkf1R9nmgnPtBCeaSU80/bZMx1/z/49fw/iBbOmv2f8pr+nfNPfM33T3xPf9PfM3/T3LN/096zf9Pd8e0Afx+PT47h+sS2PP3mcamc8FffLTOu6Hp+dTp/93C8zNZyfOkw3nJ86TDecP25+fuow3XB+6jDdcH7qMN1wfupmdsP5qZvZ9fNzv8zUcP6b37/cLzM1nP/m9y/3y0wN57/5/cv9MlPD+W9+/3K/zNRw/pvfv9wvMzWc/+b3L/fLTA3nv/n9y/0yU8P57ztM4p/nv+8wiX+c/8Yvc/zz/Pf9ZZZ/nv++v8zyz/NTP38azn/fX2b55/nv+8ss/zw/9fO//t0198scDeen9v/183O/zNFwfur7t+H81Pdvw/mp79+G81Pfvw3np75/G85Pff82nP/m9y/3yxwN57/5/dvhZY7LnsKfPzuOy/PD47h++W2jL79B0+F1DnQF5fYVTLevIG5fwXz7CpbbV7DyVHCcaSM807evIBnH8lIvtteny6He9P2LrZtORb0upKr1xL2uuuH81OtCGs4fNz8/9bqQhvNTr+tqOD/1uq6G81Ov62o4P/W6rvr5uddVN5z/5vcv97rqhvPf/P7lXlfdcP6b37/c66obzn/z+5d7XXXD+W9+/3Kvq244/83vX+511Q3nv/n9y72uuuH8N79/uddVN5z/5vcv97rqhvPf/P4lX5dc+w3jiXxdcv381M+f6m9YThP186fh/NTPn4bzUz9/6ucP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PMk1CDzJNQg8yTUG/EJyDQJPcg0CT3INAk9yDQLfAB8DnuQaBJ7kGgSe5BoEnuQaBJ7k+i/v4wVnJV1+gEMC/ACHlPYBDknqA5wGnGM4JJIPcEgNH+Dg7D/AwX1/gINDPoaz4ZA/wCnkkPdte714PRi3kOftGbeQi+0Zt3mNW8hp9oxbyDv2jFvIDfaMW8jf9YxbyLF1jLsX8mA943q5qt3LVe1ermpvXuN6uardy1XtXq5q93JVu5WrWh9Wrmp9WLmq9WHlqtaHlataH81rXCtXtT6sXNX6sHJV68PKVa0PL1c1eLmqSnfse8b1clWVbrb3jNu8xvVyVZWugveM6+WqKl3A7hnXy1VVuvbcM66Xq6p02bhnXC9XVemKb8+4Xq6q0sXannG9XFWl66w943q5qkqXSHvG9XJVla5u9ozr5aoqXZjsGdfLVVW6ptgzrperqnQ5sGdcL1dV6Upez7herqrSRbiecb1cVaXrZz3jermqSpe+esb1clWVrlr1jOvlqipdcOoZ18tVVbpW1DOul6uqdJmnZ1wvV1XpCk3PuF6uqtLFlZ5xvVxVpesiPeN6uapKlzR6xvVyVZWuRvSM6+WqKl1I6BnXy1VVugbQM66Xq6q0Vb9nXC9XVWnzfc+4Xq6q0nb6nnG9XFWlDfI943q5qkpb3nvG9XJVlTax94zr5aq8dquvXrvVV6/d6qvXbvXVa7f66rVbffXarb567VZfvXarr1671Vev3eqr12711Wu3+uq1W3312q2+eu1WX712q69eu9U3r93qm9du9c1rt/rmtVt9ezSvca1c1ea1W33z2q2+ee1W37x2q29eu9U3r93qm9du9c1rt/rmtVt989qtvnntVt+8dqtvXrvVN6/d6pvXbvXNa7f65rVbffParb557VbfvHarb1671Tev3eqb1271zWu3+ua1W33z2q2+ee1W37x2q29eu9U3r93qm9du9c1rt/rmtVt989qtvnntVt+8dqtvXrvVN6/d6pvXbvXNa7f65rVbffParb557VbfvHarb1671Tev3eqb1271zWu3+ua1W33z2q2+ee1W37x2q29eu9U3r93qm9du9c1rt/rmtVt989qtvnntVt+8dqtvXrvVN6/d6pvXbvXNa7f65rVbffParb557VbfvHarb1671Tev3eqb1271zWu3+ua1W33z2q2+ee1W37x2q29eu9U3r93qm9du9c1rt/rmtVt989qtvnntVt+8dqtvXrvVN6/d6pvXbvXNa7f65rVbffParb557VbfvHarb1671Tev3eq712713Wu3+u61W3332q2+P5rXuFauavfarb577VbfvXar71671Xev3eq712713Wu3+u61W3332q2+e+1W3712q+9eu9V3r93qu9du9d1rt/rutVt999qtvnvtVt+9dqvvXrvVd6/d6rvXbvXda7f67rVbfffarb577VbfvXar71671Xev3eq712713Wu3+u61W3332q2+e+1W3712q+9eu9V3r93qu9du9d1rt/rutVt999qtvnvtVt+9dqvvXrvVd6/d6rvXbvXda7f67rVbfffarb577VbfvXar71671Xev3eq712713Wu3+u61W3332q2+e+1W3712q+9eu9V3r93qu9du9d1rt/rutVt999qtvnvtVt+9dqvvXrvVd6/d6rvXbvXda7f67rVbfffarb577VbfvXar71671Xev3eq712713Wu3+u61W3332q2+e+1W3712q+9eu9V3r93qu9du9d1rt/rutVt999qtvnvtVt+9dqvvXrvVd6/d6rvVbvX1YbVb/WtcJ1f1Na6Tq/oa18lVfY3bvMZ1clVf4zq5qq9xnVzV17hOruprXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXC9XZbVb/WtcL1dltVv9a1wvV2W1W/1rXCtXNXjtVh+8dqsPXrvVB6/d6l/DeI1r5aoGr93qg9du9cFr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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2b3U7bQBCF18GhBoOb2HGckEAIBaTehRSScMfLtM/d60p9haqss6Mclmm0UcdLVool5LG9O+ebsz+EyERqfSSvP5GJ2+Z8rN4f1ObFnGf/dzwI5po1yRkFwtkKhPMoEM5YkDNiOPU5NrFed3rNfVLr9fjuIXbWA30Ez9W2RLZqYgJ8eC1V6Wr2fAzJEVwZ8Ng8o7PGSc0zBEtNkXUbuEeFtuAe6RzBPdrBSCcxpgjX+5RskOXyvs4+XcOJyUXcKcT4bAzWxQ3V2Jav8bGRMXn1rqExqVcx+d42uRO4pjE4NbHgb44H1I7Mz6k1F2KIR9CW2pEfLWDVx7narJfTLf1iq18GbY6hn7230DWNtfaqa2J9btOeAPkb8HCm86byed+MTWx5l0JNGXgioz1f6fxn6u0RWdfXEGfAcy7Os1578nWux+4zsMvkfXrUXnUsr84srzJogwydBvyLQJdy03WH0ZbzYrHS2l0HL7oMT9ezF11GW9CLZ62dO3iRMzy5Zy9yRlvOi+U3rV04eFEwPIVnLwpGW86Lef0ZoOfgRY/h6Xn2osdoC66Rel6UDl6UDE/p2YuS0Rb04ofW7jt40Wd4+p696DPagl5819qVgxcVw1N59qJitAX3zvrzxcDBiwHDM/DsxYDRFvRirrWHDl4MGZ6hZy+GjLbgGqm1Lxy8uGB4Ljx7QXq7MvcCZK4CZC72gDmxYhntRb1/jhy8GDE8I89e4HcuuzCXe8CcWLGM9uJJa48dvBgzPGPPXpDersx5gMxFgMz9AJnLAJmrAJn3YT4nViyjvaz30EsHLy4ZnkvPXpDersx5gMyjAJmLPWBOrFhGe1l/N3fl4MUVw3Pl2QvS25V5ECBzdw+YEyuW0V4utPbEwYsJwzPx7AXp7co8DJC5CpB5FCBzESBzP0DmMkDmwxr0w5zvATO+e/S7UZ75c2rxkGfKYlQWYwpxBozU9kXJva+SWbWT1lTcj/X42POFrqeNas9XOu+XBmrSeW/l89Z/I9yZXPQO3y3j1b2JI+FxuoO8EejQ/RjiX9CW2pEftB8Qu36X68bE91v6Tax+GbS5gX63Vj+6prHW3v00cVNzy2Ved9RmLX8Fngb2wUd8J1eBV8pipGMCPNfyPA8N1TnDd/j+KNm1N7W8OrG8yqAN7tEftW8emA/M/2LGzxMncA956F7LqgX/v2EKOf4CARQXTpY1AAA=","debug_symbols":"ndpRattAGIXRveg5FN/foxkpWymlOIlTDMEJsVMoJnuv3dIF9LxpJN237+kwl+lp//Dx4/vh+Px6mu6/XqaX18fd+fB6vJ4u0+ZLLX/ent52x9uL03n3fp7ut33cTfvj0/Vp1Ofd9Hx42U/3tbbPb3e30Qqj7UZGkVHJaCujJqNZRl1GQ0ZSxFaKaFJEkyKaFNGkiCZFNCmiSRFNimhSRJMiZililiJmKWKWImYpYpYiZililiJmKWKWIroU0aWILkV0KaJLEV2K6FJElyK6FNGliCFFDCliSBFDihhSxJAihhQxpIghRQwpYpEiFilikSIWKWKRIhYpYpEiFilikSIWKWKVIlYpYpUiVililSJWKWKVIlYpYpUiVikimw2tQqui1ZZWjVYzrTqtBq0WWlEboTZCbYTaCLURaiPURqiNUBuhNkJtFLVR1EZRG0VtFLVR1EZRG0VtEGiGRDNEmiHTDKFmSDVDrBlyzRBshmQzRJsh2wzhZkg3Q7wZ8s0QcIaEM0ScIeMMIWdIOUPMGXLOEHSGpDNEnSHrDGFnSDtD3BnyzhB4hsQzRJ4h8wyhZ0g9Q+wZcs8QfIbkM0SfIfsM4WdIP0P8GfLPEICGBDREoCEDDSFoSEFDDBpy0BCEhiQ0RKEhCw1haEhDQxwa8tAQiIZENESiIRMNoWhIRUMsGnLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0SIXLXLRIhctctEiFy1y0bKLnuSiRS5a5KJFLlrkokUuWuSi9d8uej393L0fdg8v+9vd3tvHj+Pjv6u+1+P519vfL9d/fwM="},{"name":"mint_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/+2aWW/jNhDH5StOE6/XSRPftyXbm/jKOnZ3m6YPfS7Qh770sQV6Ar3Q8zv26/S5aDkzHP7lKPGCi1YIijWgiBr+fxxyKIkaImGQC4LDfGB+ncD+zNVhUA4OzClDx/uBlkwha45MOcioKaJKorKRlQU5LpEwzyXjISgMzZ/jTaDOuPmgYI6DMCj8fednzEVRFOkoclEvDwfUwAmVthntc5l6Le2Voc44L0XrycodR60IcOj6pleFkILDIz6KVG0qc7Z4RH9EQ+29FaIGnoKYx2PxdCxHzrqiZkpR1laU0GBJNEdSpHMSye9Hdrqkg3lyk49pqL0nyf7S76n09ykdBS6W7GU5lBCeFPhcthNSESfvmePMRewUETvbjdjb6N6ZafBjcz4X8akVV3mQ51QCVhXNmRQZ/QVmRWuMkqAGtAa0ZtEfYFa0zigJ6kDrQOsW/QlmRRuMkqABtAG0YdHPYFa0ySgJmkCbQJsW/QpmRVuMkqAFtAW0ZdEvYFa0zSgJ2kDbQNsW7cOsaIdREnSAdoB2LPozzIp2GSVBF2gXaNei38KsaI9REvSA9oD25JxEav5I1R9p70fMmFYwK9pnlAR9oH2g/aS3vvO2BzHevodZ0QGjJBgAHQAdJL0NXAQ9kao/0vZHGv5INxXkFREz8/M7zIoOGSXBEOgQ6DDpbeie4j2I8fY5zIqOGCXBCOgI6MiiC5gVDRklQQg0BBomOxq6KfZEzv2Rqj9S80fq/kjDH2n6I61U5qXjj3RTmZdqKmN5RcTMc/MdzIpGjJIgAhoBjSz6K8yKjhklwRjoGOg42dGxG5snUvVH2o+1Yw1/pP4YImbugi9hVnTCKAkmQCdAJ0lvEzcmT6Tmj4T+SHs/YsJwBbOiU0ZJMAU6BTpNepu6JWsPQktv5iPkM7cMBkhiNGshNT+MwoacjunvGbt6tuvqQuCpFLWGEqYLiGbIi+YHXJxb/cIEghTLDAuXZKKDe/yhXOlwiVlGKruEY6nIipEq1cOMzn3T0gexbt3pMKfcNNpb9Be5XvnBXK8yydr8kRPGGHzgUlZCLngon1BpG8vSc9I4yy4iG8mgVHZZaeX+bYSyKAgtyzZCxV6Ko093Hck2ArdXhjrjvBBY4UmmikOxqoOiYHlbG9vBsC2o6yK3ULQtVALXvN2pUIz0BexsxLpULDhRAfdpe2cuSg/OxUUYr8lZ5yS6dC/LS8gv8XhcPoRUU0Fa/ki4HzHP048wKzpzT8cs9lQCnSW9zdyYPJF2Kl5qqXSs4Y8MU0FeYyyD/Yi5cb6BWdE5o/weBToHOk96m7sp3YMYb1/DrOiC0bmsC4ougC6S3hYuHJ5IbT9iOvgbzIrKKkOCJdAl0GXS29I96J5I3R8Z+yNdf6Tmjwz2I1SdDfDe7zB4z/fJcuf7ZLn7fbJiV6tdV1cCL6WoNXS/XEG0xvpxLav3tdVv7PfJVr5PtmSig9fav+RKh0vMNlLZcziWiqwYqVI9rOncNy39GevWnQ6775MONrxXLjYFxGZ15/skjNfk7MK6clNyfO+UrKzre5H8fgT9W7oN+ZVtZCnrO13SdntettlJdSJPm36erd3QrjC09e7QnofxmpyNFAfTba1cQ34tmjWCnkSq/kjNH6n7Iw1/pOmPtPyRtj/S8Ue6qcxLNZXh91Lx0v8fRayRyg2Tzj02SOWpHPojo1Sm8s07+c07+b+e/U4qEQv9kSiVsVQf6w1TTeURqz/WiI1TGUstlTv5NYY/+deXJFpKcz3kDbcMBrspQWDVki6upcV4urhhV5tdV7HkbIsaSky2EL1A/vFS0sWXVv+uTRdvJF28IRMd3OO2XOlwibmJVPYOHEtFVoxUqR5e0Llvrk9j3brTYU4XabS3WfyDmaRauq1LQSjet9mdf3CDtZzYYM1bkUSRvGwg3yC/p/ieTTXZo/NqRA7rf9DxD/Dv8iGuJwAA","debug_symbols":"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"},{"name":"claim","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"_increase_public_balance","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"check_balance","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"fee_limit","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"balance_of_public","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/83YW2/rRBAH8E3itA1NHCd2mmvbtLFzT3NOKYgjKI8g8cojD4i7kLiJixBfkS8FO7M7+09qHVcrHVnHUmpnPD/P7tppM01VTamzQOntUtmNIipUJ3pXodfHSo70QVW/KqGqSCijk6SqmU1TNT6ixOBW/zjPlHFntffoRI2ukKoKpZ7UVcVUpHKqnvLhB/rVyGQ4p+Y8bQ36YXKInaU4oy/4id6/Y5JPbfJ5VjVBdQ52bnIa5pDpXwgLbTKlhCZoE7Rp6S8IC20xpYQWaAu0Zek3CAsNmVJCCBqChpb+ibDQNlNKaIO2QduW/oiw0IgpJUSgEWhk6a8IC+0wpYQOaAe0Y/Z50iwmutoUYaFdppTQBe2Cdi39GmGhMVNKiEFj0NjSrxAWmjClhAQ0AU0s/QlhoT2mlNAD7YH28svTc9U8SdOftIqJntN3CAu9YEoJF6AXoBeWfomw0D5TSuiD9kH7+YH23QNWQHS17xEWOmBKCQPQAeggX23gBlhAdLXfEBY6ZEoJQ9Ah6DBfbeh+x3iSrj9J/Enbn7T8SaeUKrE/aZYyl6iUgT1z9/UT/Q/CQkdMKWEEOgId5auN3DJ4kq4/6ZUysJY/if1JUgp5ZsX0U/AtwkLHTClhDDoGHeerjd1iFxBd7Q+EhU6YUsIEdAI6yVebuC8+niQupUrbn7RKmUtSChkWkxuKX+K7/yuGCl/45Rs+ZatMugB9xUBhu+RSl8elrgyemEM5Q83FFZKm6CFuTvjwxubf2h5lVuHEGYXoxSMemXcyXYrNMkm7RmFzomqCdFIqTGmvf1Sig2E9GfD7FTvbVyaH55gdtGkycm7dMKc65nSZqro63vgucHvHlewNqdnLNHiwE/MBlQs2Ds6bfZ4ExeRoSDKZqw+Dg5yauTNPx0vbtRkvreF1nQ8b9m2Qcjl1YzrJQJbXFPmI1sWt2C1WLD1esRmGl+oLfm4etZq95ZQ850nSpeZgc5OTmkPa50noT6Jiogf4O8JCF0wpYQG6AF3kqy3cb44Coqv9gLDQJVNKWIIuQZf5akv3J8iTdPzJ2J8k/iTyJ+Ebn76+Py8QFrpiSgkr0BXoKl9t5ap5kqY/ifxJWMpcYn+SlEKeWTH9FPyNsNA1U0pYg65B1/lqa/cp9SSjYqIHeIew0A1TStiAbkA3+Wobd2s9SeZPQn8S+ZO5P4n9ycKf9Eq5L2N/kpRyX8JS5vLMiunPzc8IC90ypYQt6BZ0m6+2df9r8iRjfxL6k87bOrDYn8zf1hXrlzKXyJ9s3vj09efmJcJCd0wpYQe6A93lq+3cn6gCQi1H9TP0HY8MFZoN6S4o23SxqbniYRd7x6XujkvtDd6ZQzlDjc0eSS/Rv9ybLvbe5r9ru9gH08U+UIhePOJPzTuZLpmHTNJeoLA5UTVBOikVaInvp/pKjwfDejJg7mJpto8YL3qy4LU92XRRtX0eN3YH+MS1lkT2PBVq2fZcym41c3FO22d2JVUjdN2jvlX1/55sZEwG0eCUD6f2rSn0xXGh0DS+lBYiu+KqBLaSTT8YoNobQMPa82MwlUFWHd+bsIyIMhrunyDTTFR1RoeDf+n1P22FxfXTHQAA","debug_symbols":"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"}],"outputs":{"globals":{"storage":[{"fields":[{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"portal_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::mint_public_parameters"}}],"kind":"struct","path":"GasToken::mint_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::_increase_public_balance_parameters"}}],"kind":"struct","path":"GasToken::_increase_public_balance_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::claim_parameters"}}],"kind":"struct","path":"GasToken::claim_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"GasToken::balance_of_public_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::balance_of_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"GasToken::set_portal_parameters"}}],"kind":"struct","path":"GasToken::set_portal_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"fee_limit","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::check_balance_parameters"}}],"kind":"struct","path":"GasToken::check_balance_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"artifact_hash","type":{"kind":"field"}},{"name":"private_functions_root","type":{"kind":"field"}},{"name":"public_bytecode_commitment","type":{"kind":"field"}},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"GasToken::deploy_parameters"}}],"kind":"struct","path":"GasToken::deploy_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"leaf_index","type":{"kind":"field"}}],"kind":"struct","path":"GasToken::claim_public_parameters"}}],"kind":"struct","path":"GasToken::claim_public_abi"}]}},"file_map":{"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"125":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"128":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"135":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n"},"139":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"140":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{\n    abis::{\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\n    utils::reader::Reader,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n}\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\n    let mut reader = Reader::new(fields);\n\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n    // WARNING: if updating, see comment in public_call_stack_item.ts's PublicCallStackItem.hash()\n    let item = PublicCallStackItem {\n        contract_address: AztecAddress::from_field(reader.read()),\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\n        public_inputs: PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            args_hash: reader.read(),\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            end_side_effect_counter: 0,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0\n        },\n        is_execution_request: true\n    };\n    reader.finish();\n\n    item\n}\n"},"143":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr","source":"use dep::protocol_types::{address::AztecAddress};\n\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {}\n\nunconstrained pub fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\n}\n"},"144":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{hash::pedersen_hash, storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"146":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UnconstrainedContext> {\n    unconstrained pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"149":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr","source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext}, oracle::storage::storage_read,\n    state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PublicContext> {\n    // Intended to be only called once. \n    pub fn initialize<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T> SharedImmutable<T, UnconstrainedContext> {\n    unconstrained pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PrivateContext> {\n    pub fn read_private<T_SERIALIZED_LEN>(self) -> T  where T: Deserialize<T_SERIALIZED_LEN> {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n"},"167":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{GAS_LENGTH, FIXED_DA_GAS, FIXED_L2_GAS}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\n    abis::gas_fees::GasFees\n};\nuse std::ops::{Add, Sub};\n\nstruct Gas {\n    da_gas: u32,\n    l2_gas: u32,\n}\n\nimpl Gas {\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\n        Self { da_gas, l2_gas }\n    }\n\n    pub fn tx_overhead() -> Self {\n        Self { da_gas: FIXED_DA_GAS, l2_gas: FIXED_L2_GAS }\n    }\n\n    pub fn compute_fee(self, fees: GasFees) -> Field {\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.da_gas == 0) & (self.l2_gas == 0)\n    }\n\n    pub fn within(self, limits: Gas) -> bool {\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\n    }\n}\n\nimpl Add for Gas {\n    fn add(self, other: Gas) -> Self {\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\n    }\n}\n\nimpl Sub for Gas {\n    fn sub(self, other: Gas) -> Self {\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\n    }\n}\n\nimpl Serialize<GAS_LENGTH> for Gas {\n    fn serialize(self) -> [Field; GAS_LENGTH] {\n        [self.da_gas as Field, self.l2_gas as Field]\n    }\n}\n\nimpl Deserialize<GAS_LENGTH> for Gas {\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\n    }\n}\n\nimpl Eq for Gas {\n    fn eq(self, other : Gas) -> bool {\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\n    }\n}\n\nimpl Empty for Gas {\n    fn empty() -> Self {\n        Gas::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Gas::empty();\n    let serialized = item.serialize();\n    let deserialized = Gas::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n"},"169":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr","source":"use crate::{\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct NoteHash {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for NoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteHash {\n    fn eq(self, other: NoteHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter) \n    }\n}\n\nimpl Empty for NoteHash {\n    fn empty() -> Self {\n        NoteHash {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl NoteHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNoteHash {\n        ScopedNoteHash { note_hash: self, contract_address }\n    }\n}\n\nstruct ScopedNoteHash {\n    note_hash: NoteHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<NoteHash> for ScopedNoteHash {\n    fn inner(self) -> NoteHash {\n        self.note_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNoteHash {\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNoteHash {\n    fn value(self) -> Field {\n        self.note_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl Eq for ScopedNoteHash {\n    fn eq(self, other: ScopedNoteHash) -> bool {\n        (self.note_hash == other.note_hash)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedNoteHash {\n    fn empty() -> Self {\n        ScopedNoteHash {\n            note_hash: NoteHash::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\n        array_concat(self.note_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            note_hash: reader.read_struct(NoteHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNoteHash {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.note_hash.value, read_request.value(), \"Value of the note hash does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the note hash does not match read request\");\n        assert(\n            read_request.counter() > self.note_hash.counter, \"Read request counter must be greater than the counter of the note hash\"\n        );\n    }\n}\n\nimpl ScopedNoteHash {\n    pub fn expose_to_public(self) -> NoteHash {\n        // Hide the actual counter when exposing it to the public kernel.\n        NoteHash { value: self.note_hash.value, counter: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = NoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"170":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"172":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr","source":"use crate::{\n    abis::{\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    transaction::tx_context::TxContext, utils::arrays::validate_array\n};\n\nstruct PrivateCircuitPublicInputsArrayLengths {\n    note_hash_read_requests: u32,\n    nullifier_read_requests: u32,\n    key_validation_requests_and_generators: u32,\n    note_hashes: u32,\n    nullifiers: u32,\n    l2_to_l1_msgs: u32,\n    private_call_requests: u32,\n    public_call_stack_hashes: u32,\n    note_encrypted_logs_hashes: u32,\n    encrypted_logs_hashes: u32,\n    unencrypted_logs_hashes: u32,\n}\n\nimpl PrivateCircuitPublicInputsArrayLengths {\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\n        PrivateCircuitPublicInputsArrayLengths {\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\n            note_hashes: validate_array(public_inputs.note_hashes),\n            nullifiers: validate_array(public_inputs.nullifiers),\n            l2_to_l1_msgs: validate_array(public_inputs.l2_to_l1_msgs),\n            private_call_requests: validate_array(public_inputs.private_call_requests),\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\n        }\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    note_hashes: [NoteHash; MAX_NOTE_HASHES_PER_CALL],\n    nullifiers: [Nullifier; MAX_NULLIFIERS_PER_CALL],\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs: [L2ToL1Message; MAX_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    tx_context: TxContext,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.returns_hash == other.returns_hash) &\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\n        (self.is_fee_payer == other.is_fee_payer) &\n        (self.max_block_number == other.max_block_number) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\n        (self.note_hashes == other.note_hashes) &\n        (self.nullifiers == other.nullifiers) &\n        (self.private_call_requests == other.private_call_requests) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.l2_to_l1_msgs == other.l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\n        self.historical_header.eq(other.historical_header) &\n        self.tx_context.eq(other.tx_context)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\n\n        fields.extend_from_array(self.max_block_number.serialize());\n\n        for i in 0..self.note_hash_read_requests.len() {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..self.nullifier_read_requests.len() {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..self.key_validation_requests_and_generators.len() {\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\n        }\n        for i in 0..self.note_hashes.len() {\n            fields.extend_from_array(self.note_hashes[i].serialize());\n        }\n        for i in 0..self.nullifiers.len() {\n            fields.extend_from_array(self.nullifiers[i].serialize());\n        }\n        for i in 0..self.private_call_requests.len() {\n            fields.extend_from_array(self.private_call_requests[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n        fields.push(self.public_teardown_function_hash);\n        for i in 0..self.l2_to_l1_msgs.len() {\n            fields.extend_from_array(self.l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        for i in 0..self.note_encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.unencrypted_logs_hashes.len() {\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.tx_context.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            is_fee_payer: reader.read() == 1,\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL]),\n            nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL]),\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            public_teardown_function_hash: reader.read(),\n            l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            tx_context: reader.read_struct(TxContext::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PrivateCircuitPublicInputs {\n    fn empty() -> Self {\n        PrivateCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter : 0 as u32,\n            end_side_effect_counter : 0 as u32,\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            tx_context: TxContext::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PrivateCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PrivateCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x15c9b0a92b9b541598e24c9f0b0b4b04b7f2408599751c45aa12de671fd9b363;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"173":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item_compressed.nr","source":"use crate::abis::{call_context::CallContext, function_data::FunctionData, gas::Gas};\nuse crate::address::AztecAddress;\nuse crate::constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH};\nuse crate::traits::{Hash, Empty, Serialize, Deserialize};\nuse crate::utils::reader::Reader;\n\n/**\n * A compressed version of the PublicCallStackItem struct used to compute the \"hash\"\n * of a PublicCallStackItem.\n * \n * Historically, we have been zeroing most values in the PublicCallStackItem struct\n * to compute the hash involved when adding a PublicCallStackItem to the PublicCallStack.\n * \n * This struct is used to store the values that we did not zero out, and allow us to hash\n * only these, thereby skipping a lot of computation and saving us a lot of constraints\n * \n * Essentially this struct exists such that we don't have a `hash` function in the \n * PublicCallStackItem struct that practically throws away some values of the struct\n * without clearly indicating that it does so.\n */\nstruct PublicCallStackItemCompressed {\n    contract_address: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    revert_code: u8,\n    start_gas_left: Gas,\n    end_gas_left: Gas,\n}\n\nimpl Eq for PublicCallStackItemCompressed {\n    fn eq(self, other: PublicCallStackItemCompressed) -> bool {\n        (self.contract_address == other.contract_address)\n            & (self.call_context == other.call_context)\n            & (self.function_data == other.function_data)\n            & (self.args_hash == other.args_hash)\n            & (self.returns_hash == other.returns_hash)\n            & (self.revert_code == other.revert_code)\n            & (self.start_gas_left == other.start_gas_left)\n            & (self.end_gas_left == other.end_gas_left)\n    }\n}\n\nimpl Hash for PublicCallStackItemCompressed {\n    fn hash(self) -> Field {\n        std::hash::pedersen_hash_with_separator(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PublicCallStackItemCompressed {\n    fn empty() -> Self {\n        PublicCallStackItemCompressed {\n            contract_address: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n    fn serialize(self) -> [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.push(self.revert_code as Field);\n        fields.extend_from_array(self.start_gas_left.serialize());\n        fields.extend_from_array(self.end_gas_left.serialize());\n\n        assert_eq(fields.len(), PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n  fn deserialize(fields: [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH]) -> PublicCallStackItemCompressed {\n    let mut reader = Reader::new(fields);\n\n    let item = PublicCallStackItemCompressed {\n      contract_address: reader.read_struct(AztecAddress::deserialize),\n      call_context: reader.read_struct(CallContext::deserialize),\n      function_data: reader.read_struct(FunctionData::deserialize),\n      args_hash: reader.read(),\n      returns_hash: reader.read(),\n      revert_code: reader.read() as u8,\n      start_gas_left: reader.read_struct(Gas::deserialize),\n      end_gas_left: reader.read_struct(Gas::deserialize),\n    };\n    reader.finish();\n    item\n  }\n}\n"},"175":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n"},"176":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr","source":"use crate::{\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for ReadRequest {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\n        ScopedReadRequest { read_request: self, contract_address }\n    }\n}\n\nstruct ScopedReadRequest {\n    read_request: ReadRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<ReadRequest> for ScopedReadRequest {\n    fn inner(self) -> ReadRequest {\n        self.read_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ScopedReadRequest {\n    fn eq(self, other: ScopedReadRequest) -> bool {\n        (self.read_request == other.read_request)\n        & (self.contract_address.eq(other.contract_address))\n    }\n}\n\nimpl Empty for ScopedReadRequest {\n    fn empty() -> Self {\n        ScopedReadRequest {\n            read_request: ReadRequest::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            read_request: reader.read_struct(ReadRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedReadRequest {\n    pub fn value(self) -> Field {\n        self.read_request.value\n    }\n    pub fn counter(self) -> u32 {\n        self.read_request.counter\n    }\n}\n\n#[test]\nfn serialization_of_empty_read() {\n    let item = ReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"179":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr","source":"use crate::{\n    address::AztecAddress,\n    abis::validation_requests::{\n    key_validation_request::KeyValidationRequest,\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\n},\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct KeyValidationRequestAndGenerator {\n    request: KeyValidationRequest,\n    sk_app_generator: Field,\n}\n\nimpl Eq for KeyValidationRequestAndGenerator {\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\n    }\n}\n\nimpl Empty for KeyValidationRequestAndGenerator {\n    fn empty() -> Self {\n        KeyValidationRequestAndGenerator {\n            request: KeyValidationRequest::empty(),\n            sk_app_generator: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\n        array_concat(self.request.serialize(), [self.sk_app_generator])\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\n        let mut reader = Reader::new(fields);\n        let res = Self {\n            request: reader.read_struct(KeyValidationRequest::deserialize),\n            sk_app_generator: reader.read(),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl KeyValidationRequestAndGenerator {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = KeyValidationRequestAndGenerator::empty();\n    let serialized = item.serialize();\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"180":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point::new(fields[0], fields[1], fields[2] as bool),\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"184":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr","source":"use crate::{\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH},\n    hash::compute_siloed_nullifier, traits::{Empty, Hash, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct Nullifier {\n    value: Field,\n    counter: u32,\n    note_hash: Field,\n}\n\nimpl Ordered for Nullifier {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for Nullifier {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for Nullifier {\n    fn eq(self, other: Nullifier) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.note_hash == other.note_hash) \n    }\n}\n\nimpl Empty for Nullifier {\n    fn empty() -> Self {\n        Nullifier {\n            value: 0,\n            counter: 0,\n            note_hash: 0,\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\n        [self.value, self.counter as Field, self.note_hash]\n    }\n}\n\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            note_hash: values[2],\n        }\n    }\n}\n\nimpl Readable for Nullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        // Public kernels output Nullifier instead of ScopedNullifier.\n        // The nullifier value has been siloed.\n        let siloed_request_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.value, siloed_request_value, \"Value of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl Nullifier {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\n        ScopedNullifier { nullifier: self, contract_address }\n    }\n}\n\nstruct ScopedNullifier {\n    nullifier: Nullifier,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<Nullifier> for ScopedNullifier {\n    fn inner(self) -> Nullifier {\n        self.nullifier\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNullifier {\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNullifier {\n    fn value(self) -> Field {\n        self.nullifier.value\n    }\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl Eq for ScopedNullifier {\n    fn eq(self, other: ScopedNullifier) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedNullifier {\n    fn empty() -> Self {\n        ScopedNullifier {\n            nullifier: Nullifier::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            nullifier: reader.read_struct(Nullifier::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.nullifier.value, read_request.value(), \"Value of the nullifier does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.nullifier.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl ScopedNullifier {\n    pub fn nullified_note_hash(self) -> Field {\n        self.nullifier.note_hash\n    }\n\n    pub fn expose_to_public(self) -> Nullifier {\n        // Hide the actual counter and note hash when exposing it to the public kernel.\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Nullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = Nullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"193":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"194":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr","source":"use crate::{\n    abis::{\n    private_call_stack_item::PrivateCallStackItem, call_context::CallContext,\n    function_data::FunctionData, caller_context::CallerContext,\n    side_effect::{Ordered, RangeOrdered, Scoped}\n},\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PrivateCallRequest {\n    target: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Ordered for PrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.start_side_effect_counter\n    }\n}\n\nimpl RangeOrdered for PrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.start_side_effect_counter\n    }\n    fn counter_end(self) -> u32 {\n        self.end_side_effect_counter\n    }\n}\n\nimpl Eq for PrivateCallRequest {\n    fn eq(self, other: PrivateCallRequest) -> bool {\n        (self.target == other.target) \n            & (self.call_context == other.call_context) \n            & (self.function_data == other.function_data) \n            & (self.args_hash == other.args_hash) \n            & (self.returns_hash == other.returns_hash)\n            & (self.caller_context == other.caller_context)\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\n    }\n}\n\nimpl Empty for PrivateCallRequest {\n    fn empty() -> Self {\n        PrivateCallRequest {\n            target: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.push(self.target.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.extend_from_array(self.caller_context.serialize());\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = PrivateCallRequest {\n            target: reader.read_struct(AztecAddress::deserialize),\n            call_context: reader.read_struct(CallContext::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            caller_context: reader.read_struct(CallerContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            end_side_effect_counter: reader.read_u32(),\n        };\n        reader.finish();\n        item\n    }\n}\n\nimpl PrivateCallRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\n        ScopedPrivateCallRequest { call_request: self, contract_address }\n    }\n\n    pub fn matches_stack_item(self, stack_item: PrivateCallStackItem) -> bool {\n        (self.target == stack_item.contract_address)\n            & (self.call_context == stack_item.public_inputs.call_context)\n            & (self.function_data == stack_item.function_data)\n            & (self.args_hash == stack_item.public_inputs.args_hash)\n            & (self.returns_hash == stack_item.public_inputs.returns_hash)\n            & (self.start_side_effect_counter\n                                == stack_item.public_inputs.start_side_effect_counter)\n            & (self.end_side_effect_counter\n                                    == stack_item.public_inputs.end_side_effect_counter)\n    }\n}\n\nstruct ScopedPrivateCallRequest {\n    call_request: PrivateCallRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\n    fn inner(self) -> PrivateCallRequest {\n        self.call_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedPrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.call_request.counter_start()\n    }\n}\n\nimpl RangeOrdered for ScopedPrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.call_request.counter_start()\n    }\n    fn counter_end(self) -> u32 {\n        self.call_request.counter_end()\n    }\n}\n\nimpl Eq for ScopedPrivateCallRequest {\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\n        (self.call_request == other.call_request)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedPrivateCallRequest {\n    fn empty() -> Self {\n        ScopedPrivateCallRequest {\n            call_request: PrivateCallRequest::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.call_request.serialize());\n        fields.extend_from_array(self.contract_address.serialize());\n\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = ScopedPrivateCallRequest {\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        item\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = ScopedPrivateCallRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"199":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\n    abis::gas_fees::GasFees,\n    constants::{\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\n    DEFAULT_INCLUSION_FEE\n},\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    utils::reader::Reader\n};\n\nstruct GasSettings {\n    gas_limits: Gas,\n    teardown_gas_limits: Gas,\n    max_fees_per_gas: GasFees,\n    inclusion_fee: Field,\n}\n\nimpl GasSettings {\n    pub fn new(\n        gas_limits: Gas,\n        teardown_gas_limits: Gas,\n        max_fees_per_gas: GasFees,\n        inclusion_fee: Field\n    ) -> Self {\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\n    }\n\n    pub fn default() -> Self {\n        GasSettings::new(\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\n            DEFAULT_INCLUSION_FEE\n        )\n    }\n}\n\nimpl Eq for GasSettings {\n    fn eq(self, other: Self) -> bool {\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\n    }\n}\n\nimpl Empty for GasSettings {\n    fn empty() -> Self {\n        GasSettings::new(\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\n        )\n    }\n}\n\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\n\n        serialized.extend_from_array(self.gas_limits.serialize());\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\n        serialized.push(self.inclusion_fee);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\n        let mut reader = Reader::new(serialized);\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasSettings::empty();\n    let serialized = item.serialize();\n    let deserialized = GasSettings::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"208":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr","source":"use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PrivateCallStackItem {\n    fn empty() -> Self {\n        PrivateCallStackItem {\n            contract_address: AztecAddress::empty(),\n            function_data: FunctionData::empty(),\n            public_inputs: PrivateCircuitPublicInputs::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = PrivateCallStackItem::empty();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item = PrivateCallStackItem::empty();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x065f2831db9ac0db5e710bd3a865b5facd8cf83f1585e1af8fd1d6ce9c47f685;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr","source":"use crate::address::AztecAddress;\nuse crate::traits::{Empty, Serialize, Deserialize};\nuse crate::constants::CALLER_CONTEXT_LENGTH;\nuse crate::utils::reader::Reader;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n    is_static_call: bool,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, other: CallerContext) -> bool {\n        other.msg_sender.eq(self.msg_sender)\n            & other.storage_contract_address.eq(self.storage_contract_address)\n            & other.is_static_call == self.is_static_call\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n            is_static_call: false,\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\n    }\n\n    // Different to an empty context, a hidden context won't reveal the caller's msg_sender and storage_contract_address,\n    // but will still propagate the is_static_call flag.\n    pub fn is_hidden(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array(self.msg_sender.serialize());\n    fields.extend_from_array(self.storage_contract_address.serialize());\n    fields.push(self.is_static_call as Field);\n\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\n    let mut reader = Reader::new(fields);\n\n    let item = CallerContext {\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\n      is_static_call: reader.read_bool(),\n    };\n    reader.finish();\n    item\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = CallerContext::empty();\n    let serialized = item.serialize();\n    let deserialized = CallerContext::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"211":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr","source":"use crate::{\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\n    constants::{\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\n},\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct LogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n}\n\nimpl Ordered for LogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for LogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for LogHash {\n    fn eq(self, other: LogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n    }\n}\n\nimpl Empty for LogHash {\n    fn empty() -> Self {\n        LogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n        }\n    }\n}\n\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length]\n    }\n}\n\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n        }\n    }\n}\n\nimpl LogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\n        ScopedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedLogHash {\n    log_hash: LogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<LogHash> for ScopedLogHash {\n    fn inner(self) -> LogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedLogHash {\n    fn eq(self, other: ScopedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedLogHash {\n    fn empty() -> Self {\n        ScopedLogHash {\n            log_hash: LogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(LogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the counter when exposing to public.\n        // The log hash must already be siloed when we call this.\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nstruct EncryptedLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    randomness: Field,\n}\n\nimpl Ordered for EncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for EncryptedLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for EncryptedLogHash {\n    fn eq(self, other: EncryptedLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.randomness == other.randomness) \n    }\n}\n\nimpl Empty for EncryptedLogHash {\n    fn empty() -> Self {\n        EncryptedLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            randomness: 0,\n        }\n    }\n}\n\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.randomness]\n    }\n}\n\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            randomness: values[3],\n        }\n    }\n}\n\nimpl EncryptedLogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedEncryptedLogHash {\n    log_hash: EncryptedLogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\n    fn inner(self) -> EncryptedLogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl ScopedEncryptedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the secret randomness and counter when exposing to public\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\n        // The log hash will already be silo'd when we call this\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nimpl Ordered for ScopedEncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedEncryptedLogHash {\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedEncryptedLogHash {\n    fn empty() -> Self {\n        ScopedEncryptedLogHash {\n            log_hash: EncryptedLogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct NoteLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    note_hash_counter: u32,\n}\n\nimpl NoteLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\n        LogHash { value: self.value, counter: 0, length: self.length }\n    }\n}\n\nimpl Ordered for NoteLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for NoteLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteLogHash {\n    fn eq(self, other: NoteLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.note_hash_counter == other.note_hash_counter) \n    }\n}\n\nimpl Empty for NoteLogHash {\n    fn empty() -> Self {\n        NoteLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            note_hash_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            note_hash_counter: values[3] as u32,\n        }\n    }\n}\n"},"215":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr","source":"struct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n"},"216":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n}\n// docs:end:call-context\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n"},"217":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"22":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"220":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize, Empty}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        (self.is_private == other.is_private)\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nimpl Empty for FunctionData {\n    fn empty() -> Self {\n        FunctionData {\n            selector: FunctionSelector::empty(),\n            is_private: false\n        }\n    }\n\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data = FunctionData::empty();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data = FunctionData::empty();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty function data hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"227":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n    counter: u32,\n}\n\nimpl Ordered for L2ToL1Message {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content, self.counter as Field]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\nimpl L2ToL1Message {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\n        ScopedL2ToL1Message { message: self, contract_address }\n    }\n}\n\nstruct ScopedL2ToL1Message {\n    message: L2ToL1Message,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\n    fn inner(self) -> L2ToL1Message {\n        self.message\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedL2ToL1Message {\n    fn counter(self) -> u32 {\n        self.message.counter\n    }\n}\n\nimpl Eq for ScopedL2ToL1Message {\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\n        (self.message == other.message)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedL2ToL1Message {\n    fn empty() -> Self {\n        ScopedL2ToL1Message {\n            message: L2ToL1Message::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            message: reader.read_struct(L2ToL1Message::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\n#[test]\nfn serialization_of_empty_l2() {\n    let item = L2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = L2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped_l2() {\n    let item = ScopedL2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"229":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"235":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<N> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<N> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<N> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<N> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"236":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"// Utility function to console.log data in the acir simulator\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<M, N>(_msg: str<M>, args: [Field]) {}\n\n/// NOTE: call this with a str<N> msg of form\n/// \"some string with {0} and {1} ... {N}\"\n/// and an array of N field which will be formatted\n/// into the string in the simulator.\n/// Example:\n/// debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n/// debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\nunconstrained pub fn debug_log_format<M, N>(msg: str<M>, args: [Field; N]) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n/// NOTE: call this with a str<N> msg of length > 1\n/// Example:\n/// `debug_log(\"blah blah this is a debug string\");`\nunconstrained pub fn debug_log<N>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n"},"237":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr","source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  num_txs: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.num_txs);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let num_txs = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      num_txs,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      num_txs: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.num_txs == other.num_txs)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n"},"238":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"239":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr","source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"241":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n"},"243":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr","source":"use crate::{\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    abis::gas_settings::GasSettings\n};\n\n// docs:start:tx-context\nstruct TxContext {\n    chain_id : Field,\n    version : Field,\n    gas_settings: GasSettings,\n}\n// docs:end:tx-context\n\nimpl TxContext {\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\n        TxContext { chain_id, version, gas_settings }\n    }\n}\n\nimpl Eq for TxContext {\n    fn eq(self, other: Self) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.gas_settings.eq(other.gas_settings))\n    }\n}\n\nimpl Empty for TxContext {\n    fn empty() -> Self {\n        TxContext {\n            chain_id: 0,\n            version: 0,\n            gas_settings: GasSettings::empty(),\n        }\n    }\n}\n\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\n\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.extend_from_array(self.gas_settings.serialize());\n\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let context = Self {\n            chain_id: reader.read(),\n            version: reader.read(),\n            gas_settings: reader.read_struct(GasSettings::deserialize),\n        };\n\n        reader.finish();\n        context\n    }\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context = TxContext::empty();\n    let serialized = context.serialize();\n    let deserialized = TxContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let context = TxContext::empty();\n    let hash = context.hash();\n\n    // Value from tx_context.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"247":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"248":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_class_id.nr","source":"use crate::constants::GENERATOR_INDEX__CONTRACT_LEAF;\nuse crate::traits::{ToField, FromField, Hash, Serialize, Deserialize};\n\nstruct ContractClassId {\n  inner: Field\n}\n\nimpl Eq for ContractClassId {\n    fn eq(self, other: ContractClassId) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl ToField for ContractClassId {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for ContractClassId {\n    fn from_field(value: Field) -> Self {\n        Self { inner: value }\n    }\n}\n\nimpl Serialize<1> for ContractClassId {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<1> for ContractClassId {\n  fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] }\n    }\n}\n\nimpl ContractClassId {\n    pub fn compute(\n        artifact_hash: Field,\n        private_functions_root: Field,\n        public_bytecode_commitment: Field\n    ) -> Self {\n        let hash = std::hash::pedersen_hash_with_separator(\n            [\n            artifact_hash,\n            private_functions_root,\n            public_bytecode_commitment\n        ],\n            GENERATOR_INDEX__CONTRACT_LEAF\n        ); // TODO(@spalladino): Update generator index\n\n        ContractClassId::from_field(hash)\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"249":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n"},"25":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n#[no_predicates]\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    let value = pedersen_commitment_with_separator(input, 0);\n    if (value.x == 0) & (value.y == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value.x, y: value.y, is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        points[i] = EmbeddedCurveScalar::from_field(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let values = multi_scalar_mul(generators, points);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: values[2] as bool }\n}\n\n#[no_predicates]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let v1 = pedersen_commitment_with_separator(input, separator);\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    multi_scalar_mul(\n        [length_generator[0], v1],\n        [EmbeddedCurveScalar { lo: N as Field, hi: 0 }, EmbeddedCurveScalar { lo: 1, hi: 0 }]\n    )[0]\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n#[test]\nfn assert_pedersen_noir() {\n    // TODO: make this a fuzzer test once fuzzer supports curve-specific blackbox functions.\n    let input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq(pedersen_hash_with_separator(input, 4), pedersen_hash_with_separator_noir(input, 4));\n    assert_eq(pedersen_commitment_with_separator(input, 4), pedersen_commitment_with_separator_noir(input, 4));\n}\n"},"263":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"273":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"289":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"292":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\n    address::{\n    eth_address::EthAddress, salted_initialization_hash::SaltedInitializationHash,\n    aztec_address::AztecAddress\n},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::pedersen_hash, traits::{ToField, FromField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH = 1;\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n       PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            pedersen_hash(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"293":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\n    address::{eth_address::EthAddress, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            pedersen_hash(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"294":{"path":"/usr/src/noir-projects/noir-contracts/contracts/gas_token_contract/src/main.nr","source":"mod lib;\n\ncontract GasToken {\n    use dep::aztec::{\n        protocol_types::{\n        contract_class_id::ContractClassId, abis::function_selector::FunctionSelector,\n        address::{AztecAddress, EthAddress},\n        constants::{DEPLOYER_CONTRACT_ADDRESS, REGISTERER_CONTRACT_ADDRESS}\n    },\n        state_vars::{SharedImmutable, PublicMutable, Map},\n        oracle::get_contract_instance::get_contract_instance, deploy::deploy_contract\n    };\n\n    use dep::deployer::ContractInstanceDeployer;\n    use dep::registerer::ContractClassRegisterer;\n\n    use crate::lib::{calculate_fee, get_bridge_gas_msg_hash};\n\n    #[aztec(storage)]\n    struct Storage {\n        // This map is accessed directly by protocol circuits to check balances for fee payment.\n        // Do not change this storage layout unless you also update the base rollup circuits.\n        balances: Map<AztecAddress, PublicMutable<U128>>,\n        portal_address: SharedImmutable<EthAddress>,\n    }\n\n    // Not flagged as initializer to reduce cost of checking init nullifier in all functions.\n    // This function should be called as entrypoint to initialize the contract by minting itself funds.\n    #[aztec(private)]\n    fn deploy(\n        artifact_hash: Field,\n        private_functions_root: Field,\n        public_bytecode_commitment: Field,\n        portal_address: EthAddress\n    ) {\n        // Validate contract class parameters are correct\n        let self = context.this_address();\n        let instance = get_contract_instance(self);\n        let contract_class_id = ContractClassId::compute(\n            artifact_hash,\n            private_functions_root,\n            public_bytecode_commitment\n        );\n        assert(\n            instance.contract_class_id == contract_class_id, \"Invalid contract class id computed for gas token\"\n        );\n\n        // Increase self balance and set as fee payer, and end setup\n        let deploy_fees = 20000000000;\n        GasToken::at(self)._increase_public_balance(self, deploy_fees).enqueue(&mut context);\n        context.set_as_fee_payer();\n        context.end_setup();\n\n        // Register class and publicly deploy contract\n        let _register = ContractClassRegisterer::at(AztecAddress::from_field(REGISTERER_CONTRACT_ADDRESS)).register(\n            artifact_hash,\n            private_functions_root,\n            public_bytecode_commitment\n        ).call(&mut context);\n        let _deploy = ContractInstanceDeployer::at(AztecAddress::from_field(DEPLOYER_CONTRACT_ADDRESS)).deploy(\n            instance.salt,\n            instance.contract_class_id,\n            instance.initialization_hash,\n            instance.public_keys_hash,\n            true\n        ).call(&mut context);\n\n        // Enqueue call to set the portal address\n        GasToken::at(self).set_portal(portal_address).enqueue(&mut context);\n    }\n\n    // We purposefully not set this function as an initializer so we do not bind\n    // the contract to a specific L1 portal address, since the gas token address\n    // is a hardcoded constant in the rollup circuits.\n    #[aztec(public)]\n    fn set_portal(portal_address: EthAddress) {\n        assert(storage.portal_address.read_public().is_zero());\n        storage.portal_address.initialize(portal_address);\n    }\n\n    #[aztec(private)]\n    fn claim(to: AztecAddress, amount: Field, secret: Field) {\n        let content_hash = get_bridge_gas_msg_hash(to, amount);\n        let portal_address = storage.portal_address.read_private();\n        assert(!portal_address.is_zero());\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(content_hash, secret, portal_address);\n\n        // TODO(palla/gas) Emit an unencrypted log to announce which L1 to L2 message has been claimed\n        // Otherwise, we cannot trace L1 deposits to their corresponding claims on L2\n\n        GasToken::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.balances.at(to).read().add(U128::from_integer(amount));\n        storage.balances.at(to).write(new_balance);\n    }\n\n    // TODO(palla/gas) Remove this function and use the private claim flow only\n    #[aztec(public)]\n    fn claim_public(to: AztecAddress, amount: Field, secret: Field, leaf_index: Field) {\n        let content_hash = get_bridge_gas_msg_hash(to, amount);\n        let portal_address = storage.portal_address.read_public();\n        assert(!portal_address.is_zero());\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(content_hash, secret, portal_address, leaf_index);\n\n        let new_balance = storage.balances.at(to).read() + U128::from_integer(amount);\n        storage.balances.at(to).write(new_balance);\n    }\n\n    // TODO(@just-mitch): remove this function before mainnet deployment\n    // convenience function for testing\n    // the true canonical gas token contract will not have this function\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.balances.at(to).read().add(amount);\n\n        storage.balances.at(to).write(new_balance);\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn check_balance(fee_limit: Field) {\n        let fee_limit = U128::from_integer(fee_limit);\n        assert(storage.balances.at(context.msg_sender()).read() >= fee_limit, \"Balance too low\");\n    }\n\n    // utility function for testing\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> pub Field {\n        storage.balances.at(owner).read().to_field()\n    }\n}\n"},"295":{"path":"/usr/src/noir-projects/noir-contracts/contracts/gas_token_contract/src/lib.nr","source":"use dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::context::PublicContext;\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\npub fn calculate_fee<TPublicContext>(context: PublicContext) -> Field {\n    context.transaction_fee()\n}\n\npub fn get_bridge_gas_msg_hash(owner: AztecAddress, amount: Field) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes = owner.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0x3e87b9be keccak256('mint_public(bytes32,uint256)')\n    hash_bytes[0] = 0x3e;\n    hash_bytes[1] = 0x87;\n    hash_bytes[2] = 0xb9;\n    hash_bytes[3] = 0xbe;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n"},"296":{"path":"/usr/src/noir-projects/noir-contracts/contracts/contract_instance_deployer_contract/src/main.nr","source":"contract ContractInstanceDeployer {\n    use dep::aztec::protocol_types::{\n        address::{AztecAddress, EthAddress, PublicKeysHash, PartialAddress},\n        contract_class_id::ContractClassId, constants::DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE,\n        traits::Serialize, abis::log_hash::LogHash\n    };\n    use dep::aztec::{\n        context::PrivateContext, hash::compute_unencrypted_log_hash,\n        oracle::logs::emit_unencrypted_log_private_internal\n    };\n\n    #[aztec(event)]\n    struct ContractInstanceDeployed {\n        DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE: Field,\n        address: AztecAddress,\n        version: u8,\n        salt: Field, \n        contract_class_id: ContractClassId, \n        initialization_hash: Field, \n        public_keys_hash: PublicKeysHash, \n        deployer: AztecAddress,\n    }\n\n    #[aztec(private)]\n    fn deploy(\n        salt: Field,\n        contract_class_id: ContractClassId,\n        initialization_hash: Field,\n        public_keys_hash: PublicKeysHash,\n        universal_deploy: bool\n    ) {\n        // TODO(@spalladino): assert nullifier_exists silo(contract_class_id, ContractClassRegisterer)\n\n        let deployer = if universal_deploy {\n            AztecAddress::zero()\n        } else {\n            context.msg_sender()\n        };\n\n        let partial_address = PartialAddress::compute(contract_class_id, salt, initialization_hash, deployer);\n\n        let address = AztecAddress::compute(public_keys_hash, partial_address);\n\n        // Emit the address as a nullifier to be able to prove that this instance has been (not) deployed\n        context.push_nullifier(address.to_field(), 0);\n\n        // Broadcast the event\n        let event = ContractInstanceDeployed {\n            DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE,\n            contract_class_id,\n            address,\n            public_keys_hash,\n            initialization_hash,\n            salt,\n            deployer,\n            version: 1\n        };\n\n        let payload = event.serialize();\n        dep::aztec::oracle::debug_log::debug_log_format(\"ContractInstanceDeployed: {}\", payload);\n\n        let contract_address = context.this_address();\n        let counter = context.next_counter();\n\n        // @todo This is very inefficient, we are doing a lot of back and forth conversions.\n        let log_slice = payload.to_be_bytes_arr();\n        let log_hash = compute_unencrypted_log_hash(contract_address, payload);\n        // 40 = addr (32) + raw log len (4) + processed log len (4)\n        let len = 40 + log_slice.len().to_field();\n        let side_effect = LogHash { value: log_hash, counter, length: len };\n        context.unencrypted_logs_hashes.push(side_effect);\n\n        let _void = emit_unencrypted_log_private_internal(contract_address, payload, counter);\n    }\n}\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"301":{"path":"/usr/src/noir-projects/noir-contracts/contracts/contract_class_registerer_contract/src/main.nr","source":"mod events;\nmod capsule;\n\ncontract ContractClassRegisterer {\n    use dep::aztec::prelude::{AztecAddress, EthAddress, FunctionSelector};\n    use dep::aztec::protocol_types::{\n        contract_class_id::ContractClassId,\n        constants::{\n        ARTIFACT_FUNCTION_TREE_MAX_HEIGHT, FUNCTION_TREE_HEIGHT,\n        MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS,\n        MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS,\n        MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS, REGISTERER_CONTRACT_CLASS_REGISTERED_MAGIC_VALUE\n    },\n        traits::Serialize, abis::log_hash::LogHash\n    };\n\n    use dep::aztec::{context::PrivateContext, oracle::logs::emit_contract_class_unencrypted_log_private_internal};\n\n    use crate::events::{\n        class_registered::ContractClassRegistered,\n        private_function_broadcasted::{ClassPrivateFunctionBroadcasted, PrivateFunction, InnerPrivateFunction},\n        unconstrained_function_broadcasted::{ClassUnconstrainedFunctionBroadcasted, UnconstrainedFunction, InnerUnconstrainedFunction}\n    };\n\n    // docs:start:import_pop_capsule\n    use crate::capsule::pop_capsule;\n    // docs:end:import_pop_capsule\n\n    #[aztec(private)]\n    fn register(artifact_hash: Field, private_functions_root: Field, public_bytecode_commitment: Field) {\n        // TODO: Validate public_bytecode_commitment is the correct commitment of packed_public_bytecode\n        // TODO: Validate packed_public_bytecode is legit public bytecode\n\n        // docs:start:pop_capsule\n        let packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS] = pop_capsule();\n        // docs:end:pop_capsule\n\n        // Compute contract class id from preimage\n        let contract_class_id = ContractClassId::compute(\n            artifact_hash,\n            private_functions_root,\n            public_bytecode_commitment\n        );\n\n        // Emit the contract class id as a nullifier to be able to prove that this class has been (not) registered\n        let event = ContractClassRegistered { contract_class_id, version: 1, artifact_hash, private_functions_root, packed_public_bytecode };\n        context.push_nullifier(contract_class_id.to_field(), 0);\n\n        // Broadcast class info including public bytecode\n        dep::aztec::oracle::debug_log::debug_log_format(\n            \"ContractClassRegistered: {}\",\n            [\n            contract_class_id.to_field(),\n            artifact_hash,\n            private_functions_root,\n            public_bytecode_commitment\n        ]\n        );\n        emit_contract_class_unencrypted_log(&mut context, event.serialize());\n    }\n\n    #[aztec(private)]\n    fn broadcast_private_function(\n        contract_class_id: ContractClassId,\n        artifact_metadata_hash: Field,\n        unconstrained_functions_artifact_tree_root: Field,\n        private_function_tree_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n        private_function_tree_leaf_index: Field,\n        artifact_function_tree_sibling_path: [Field; ARTIFACT_FUNCTION_TREE_MAX_HEIGHT],\n        artifact_function_tree_leaf_index: Field,\n        function_data: InnerPrivateFunction\n    ) {\n        let private_bytecode: [Field; MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS] = pop_capsule();\n\n        let event = ClassPrivateFunctionBroadcasted {\n            contract_class_id,\n            artifact_metadata_hash,\n            unconstrained_functions_artifact_tree_root,\n            private_function_tree_sibling_path,\n            private_function_tree_leaf_index,\n            artifact_function_tree_sibling_path,\n            artifact_function_tree_leaf_index,\n            function: PrivateFunction {\n                selector: function_data.selector,\n                metadata_hash: function_data.metadata_hash,\n                vk_hash: function_data.vk_hash,\n                bytecode: private_bytecode\n            }\n        };\n        dep::aztec::oracle::debug_log::debug_log_format(\n            \"ClassPrivateFunctionBroadcasted: {}\",\n            [\n            contract_class_id.to_field(),\n            artifact_metadata_hash,\n            unconstrained_functions_artifact_tree_root,\n            function_data.selector.to_field(),\n            function_data.vk_hash,\n            function_data.metadata_hash\n        ]\n        );\n        emit_contract_class_unencrypted_log(&mut context, event.serialize());\n    }\n\n    #[aztec(private)]\n    fn broadcast_unconstrained_function(\n        contract_class_id: ContractClassId,\n        artifact_metadata_hash: Field,\n        private_functions_artifact_tree_root: Field,\n        artifact_function_tree_sibling_path: [Field; ARTIFACT_FUNCTION_TREE_MAX_HEIGHT],\n        artifact_function_tree_leaf_index: Field,\n        function_data: InnerUnconstrainedFunction\n    ) {\n        let unconstrained_bytecode: [Field; MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS] = pop_capsule();\n        let event = ClassUnconstrainedFunctionBroadcasted {\n            contract_class_id,\n            artifact_metadata_hash,\n            private_functions_artifact_tree_root,\n            artifact_function_tree_sibling_path,\n            artifact_function_tree_leaf_index,\n            function: UnconstrainedFunction {\n                selector: function_data.selector,\n                metadata_hash: function_data.metadata_hash,\n                bytecode: unconstrained_bytecode\n            }\n        };\n        dep::aztec::oracle::debug_log::debug_log_format(\n            \"ClassUnconstrainedFunctionBroadcasted: {}\",\n            [\n            contract_class_id.to_field(),\n            artifact_metadata_hash,\n            private_functions_artifact_tree_root,\n            function_data.selector.to_field(),\n            function_data.metadata_hash\n        ]\n        );\n        emit_contract_class_unencrypted_log(&mut context, event.serialize());\n    }\n\n    // This fn exists separately from emit_unencrypted_log because sha hashing the preimage\n    // is too large to compile (16,200 fields, 518,400 bytes) => the oracle hashes it\n    // It is ONLY used with contract_class_registerer_contract since we already assert correctness:\n    // - Contract class -> we will commit to the packed bytecode (currently a TODO)\n    // - Private function -> we provide a membership proof\n    // - Unconstrained function -> we provide a membership proof\n    // Ordinary logs are not protected by the above so this fn shouldn't be called by anything else\n    #[contract_library_method]\n    pub fn emit_contract_class_unencrypted_log<N>(context: &mut PrivateContext, log: [Field; N]) {\n        let contract_address = context.this_address();\n        let counter = context.next_counter();\n        let log_hash = emit_contract_class_unencrypted_log_private_internal(contract_address, log, counter);\n        // 40 = addr (32) + raw log len (4) + processed log len (4)\n        let len = 40 + N * 32;\n        let side_effect = LogHash { value: log_hash, counter, length: len };\n        context.unencrypted_logs_hashes.push(side_effect);\n    }\n}\n"},"32":{"path":"std/merkle.nr","source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n"},"4":{"path":"std/cmp.nr","source":"// docs:start:eq-trait\ntrait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\nimpl Eq for Field { fn eq(self, other: Field) -> bool { self == other } }\n\nimpl Eq for u64 { fn eq(self, other: u64) -> bool { self == other } }\nimpl Eq for u32 { fn eq(self, other: u32) -> bool { self == other } }\nimpl Eq for u8 { fn eq(self, other: u8) -> bool { self == other } }\nimpl Eq for u1 { fn eq(self, other: u1) -> bool { self == other } }\n\nimpl Eq for i8 { fn eq(self, other: i8) -> bool { self == other } }\nimpl Eq for i32 { fn eq(self, other: i32) -> bool { self == other } }\nimpl Eq for i64 { fn eq(self, other: i64) -> bool { self == other } }\n\nimpl Eq for () { fn eq(_self: Self, _other: ()) -> bool { true } }\nimpl Eq for bool { fn eq(self, other: bool) -> bool { self == other } }\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3) & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\nstruct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n// docs:start:ord-trait\ntrait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"47":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"80":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n"},"86":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/messaging.nr","source":"use crate::{\n    hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness\n};\n\nuse std::merkle::compute_merkle_root;\nuse dep::protocol_types::{constants::L1_TO_L2_MSG_TREE_HEIGHT, address::{AztecAddress, EthAddress}, utils::arr_copy_slice};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_message_hash(\n        portal_contract_address,\n        chain_id,\n        storage_contract_address,\n        version,\n        content,\n        secret_hash\n    );\n\n    let returned_message = get_l1_to_l2_membership_witness(storage_contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    // Check that the message is in the tree\n    // This is implicitly checking that the values of the message are correct\n    let root = compute_merkle_root(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_message_nullifier(message_hash, secret, leaf_index)\n}\n"},"89":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<N>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, N>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<N, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<N, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"95":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn block_number(self) -> Field {\n        block_number()\n    }\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<N>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<N>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, N>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N)\n}\n\nunconstrained fn storage_write<N>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<N>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<N>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}