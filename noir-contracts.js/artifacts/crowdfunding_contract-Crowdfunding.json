{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"Crowdfunding","functions":[{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2dC5Bk11nfb8/0zrR2dnpeO7uzO7PaXtnBxhQwMz3SSjzM2jxMildwCFCFjbKWVkaOLGFpZSSXTUhs4mCDDaQqhcEpjIkB4xBCCvM02BBiuXAFKAOGAhRDKNu85MS8HWQlvq3+b//66+/e7ttzv+7b67lVU3P73nPv+b7vnHPP/3uc79SSJ4+lT/zVuufHuv8XksFDZS51/+8e7tgr8V27kXTWZoTOuRmhc35G6KyXSGdK23zSf5RN77EAuZZN48IM0LhYcruLxnr3vPGJvxs+8Xc8efLbO3CTjM11O056P23gVICLKJP10pcZ4aTHX+D8TPf/s+6///LDrbvvvfPKQ637Hrzauu+u1gvue/DeOx/gg3+F8+3u/zsu33NP6+p9rcsPPHDl/qu3v/jyQ7e/4O6rtz9w98uu8NGPj1tnvTbmg78z7oOn5sd8cBcPXuj+v3z16pUXf+PVVEIPPPiCq/dfvuNq65vuvvoNrfteeuX+u+6575v4gpvHrfk7D1vzG8at+fvHffBX8eDOIMmX77wzm9o/GLfS/zXug9fG1xjU7tTHrPSmcR+8dAhqnzdupS8c98F7x33w2w/B5k+MW+kfHKLSvx+30s84NuaDXz/ugy8/Nj6bj49b6bMWxq/0KxfGrPRrxn3wwUNQ+13jVvrGcR/8wXEf/KVDsPmhcStdWxy/0p3FMSu9adwHLx2C2nvHrfTBcR+884YxH/xmPDgWynjluDX/z8PW/OFxa35s3Ae3jvfOi/aJZxwfs9LdcR/88kNQ+6JxK/3GcR983SGo/dFxK337uA++Y9wHf+8QbP6/cSt9xtL4lT57acxKHxr3wR8Z98F3H4LNLzoxZqWvPTF+pd83bqU/MO6D7zwEtb8/bqUfGvfBx8Z9cGl5fDZ3l8es9OsOUeld41Z6z7gPvuYQ1L5r3EofGffBXxv3we9pjvng76yM+eBH8eBYuOZvx635n64esubnrY5Z8wvGffA78GDRXvj941b6lnEf/G+HoPYD41b6wXEfnF8bn9rza2NW+oxxH9wb98GvOASbV8et9PsPUenPj1vpR8d98ML6mA9+3vr4bL5z3ErrG+NXenJjzErPjvvgrYeg9qvGrfT2cR+8a9wHX3UINt86bqW/dYhKPzBupR8c98H5k8Wovea/W+o+SP9gKynJUXnr7h0LeDnrSI/UB1nvXtT/lK6l7j0+lF6Ts6WGa7KAz+GazMXzuCbDYR20LJbP782NHsnlvfcTzuOUB5mORPcSznlvB6Krl8/jrQ3IuLT37u4ehLTJJ2QX1CYdJ7zkfqz77gZ+qw1kOqkl5QYP3YD31lCPrtdxvo2yMOV0aJ4DremR6jsaL8dznrOxBU2UWcBz9tui32rrVFaCF+n/hr4JeL+08SeSw8vw4t7B/t7BxYvpO5ZAg9pMddVx/7uXe+VaoKtZIl3tK7e1r+xeuSt9x7JDVxN06f4XL/bKPRV0rZZI15U779q/eHDwgvQdKw5dq6BL938R5Z4OutTmJY6F3fS9C+W/d499t959t+hfAE+al1ql1b13wHksAW88WjifBz2lf/O739Dy+Xyy7fj9Kee9N9+cymrFyOqYkVUTZUjDSoD8akl/oF4Lv1ecusuTxS2duKnVEWSx6tCzOmFZrDp1lyiLF6R1r40gizWHnrUJy0L1FaV5pQI0N8x5OXXfclda9/oIslh36FmfsCzWnbrLk8XFi2ndGyPIYsOhZ2PCslB9RWleqQDNDXNeTt37Hf3h5AiyOOnQc3LCslB9RWlemUGa1ypAc8Ocl1P3xYO07s0RZLHp0LM5YVlsOnWXOJd0MOKpEWRxyqHn1IRlofqK0rwxgzSfrADNDXNeTt0Xb0vrPj2CLE479JyesCxOO3WXKIvO/Lc1giy2HHq2JiwL1VeU5s0ZpHmjAjQ3zHk5dR90xt+ZEWRxxqHnzIRlccapu0RZdLDA2RFkcdah5+yEZaH66knPJveWUHr2bl5KshdXksbE0LiEc9rlZIO/lJRnP2P7bKOundLl8WT72P6i3zuhde91fEM3BvCUvvd8+e/tzG2t7rvkMzjvyOpC97xsu3UL762hHl2v4/zNKKtyKqvvgWhP/Q7nuucXcp47a55rosw5PHfePKffauu0/u/pnkf1rVH6dWoH9PSSgO9gx/bfSPqPUb47/MaUSM9eEJ+79Ck8kZQ79naMrBpGVk2U4Td6Wt/NI5qPaM6iOf0eLIMOXZM/WGM+/VY+PN8rF+C72U/rpV9NMk0MDzroPwmwv7eXkn7f1jB6aAOP8I0E8blLG3TZ30prG101spq0Ddr6d/Q7z557RHP5NNM/LlqXUG4Stv1RaJykr69h6NHv9di6dxkPovenvx9FvQHfs3bK8yrqa4EO1VdHmZOIR/qj7rXlZDC2IKsfRfn4svrRBmhcM/KNjAVRv5Gu1nBkERALuRvEU5syVj9ZNDzVUeax7n87d0smtr1UTu9cTgbH3lzS33bp8UTS345F5s67hhzpOzZA17rDr+7/dQ6/Ht2XutdXDI9PmN/sS944OgRW2LMXSN98MjiGouaBIN9jp8/Kv6I+K/pVXx1lJPusPmt9XNe+id3/y5AZ/ToBvO0H+Ys6MtsyMhP9pyGza2Vq+TLbypDZJmQmWdEWHxGXls5Jaw6NiaFRB3WbCD9JUd2G8onwFS4l/e01jB766yJ8J0tJvy91GD3R/oulpN+3NIyeaLsd/RCj0BPtP1hCHaPQQzv5uSB6dgrQIxq8WEvGz3I9hMYLdTzr26e/cQ7XrA8pvSb51XFNPDB/4w7eJ3oYd8d2WDHPBI3XdlF5R4/XID47NhUb47FjeGI/4LiLivGwPm/9Po12KELz+gzSPIlYmmE0x/S59sUgDNJOvw3HIdctI1/yFWB/2C86Z9AGFIERg/jsfDPOGZ62DU9NlOHauIi5sZYMrjnQb/pvi9B8ugI0x7Rf+5ag+IR9jT/J9UYjX/Il33mZ/gG2W6rvCYuorjru31HrlfvKWo+ugLl7vyiWmFUfuTen7BieiB/pr4yKV8vyV55BOxSh+VwFaA5qv3bQvLyfNS9bvug30LX0t5Kp8/45535QmxSe12dZF7A2rm3DE/VErkONir3Nwqh58cJ5NB+rAM1B7XcQpCsMzOunjXzFVzq/aq35yzC/fhPGp95R5rzP+ZXxJZfnB+Vdto9B45u2C7Z/A+eyXXB+j7B7F7WlEetG+BCD+Ox8r+z6sLOGJ64Pa+B/1Powq+Pr9ybaoQjN6zNIc7C/aCSaY/rck7aLAL/hNduF5HrSyJd8BcQd7BeN441eqxfE566nd1ubM23mtF1E5Sewa8z1Oy+nQh7NmxWgOab9nrRdRMSKavxJrqtGvuRL8i3bdqG+RtsFffu6/9PAVm8BtorAfofBEhH6cSSWsDER3hynMrRdRK37zZrj8tYq59G8VgGaozBvVGyKnZdt/Ij4oo2AcTo/Wxu8v+bcD2qT/aJ+/mi/UxCfri5wxvBEjErbRRRGtWPT5mYoSvN2BWgOar+DIFx9bfxKrieNfMUX5zldS8fnex3bYpnzfhDOPSgabxSN54+DnhdeufolVx7+6sv33H3n5at333fvc6+85MErD1ytgUyG55H0WtLPxhMoM4frDMk949x/Av8jQ/CzhlNweqt2EPTvLD+1IfYWIjPE/ne7jZUVUmlT/andGeouWTFkKQrqnnJoTAyNOgh1o5avFRnC0en/ioZ4Em5GmBWLhsAGL1doF11uuAh6GgHyCeKzA7UWDE8rhqcmytAdthDAZy3pDydsJYOpb49ongzNVDe5fErlTlWERo69QHoOis4pTNUclV4+gM/ON6FueDrlyF1l2FcjUkB7Y+fatgpJrx2OaI6nmXUfQnVq2wtp3fMjyGLeoScgPXiuLPLS5XHLj9MVoVHX+J2MMLtyKYKHp2sl1+Wlyg74Hu4Xxabsr3a5BvsHMXUV+kcjlp79JUPPMDl6NHKc6T7pnwuSY1Z6OC6b0bXFYHqKpofzaOT4jEhv1reV0gg03gga9RxTP9hwpdRecfNcj4eoJacMXWw5dNRR5gP1XtnburQtJ4OuAprx+Q2Y1tKQlEYvLHVaIbH8bm5XVGYMIz4LOeraAui2OGaaJv/lxHfjTcuF6Om8VZMZ9WCOGV2bwzU9Q5dyVOiL3B9Kqai6ueUBXWTklc+qzNd2GUm/Xy+c6/HujUXPDV2F9mGY/yz2qyiXKud+L6SvbGw+Z3hln/LGDl2GJdKyVzM8ctyIBo6BezAGlucH5dRKJjMXso9440/3J7FlhHVr2y0a6NZmOHRUquasOWXY2Nd9jv2IJVl57boNGm14T5Rezu8e8fMrgJ8jliDVkv4Q/lYy+J2uo8z3AT//q1jadqlTnAWNr0K9EakIaqa+VjK4xKWOMl8MmfxbfD91nzrFaXNtmriOWJiYSefzuJaHo4ijN8y1SF9/VkjsOmj0UiZGhH8E+Q8OmApPR56OTrtG1BL3CD5Xuu2yafgQ73WnHaPmUhsjYVN1cb5nWn9vi6goTGLThdrUZEwXSp19wciVOjvHbBQuyNLZvaW/q7hmbWLEr8EhlIeKU4lKa1wkToWxT1HfhKi0xhEhgB72s6lrJr21SVYKUtV3RPNkaPb0fc7BpypCoxejF5VaWNiXKVzfXTEMvgIM/qsOBqdPyrOtTmvZZBYGt7a7qtkTlhN/qWS0HGs5cjzSR/rpOWlkNsm6s3Ae44x17m1TzfHqpXCP2no869tLLKprxKLqX1zeoPvse9P04ega9Zi87YzLtPESrwfrcH1zlt6fzgv/Zy60HdpsBztn0Y6tMv9jvlf2r2fcFz2rflXPtjWr9vwjm3rf0R7VbkA/0qzabaN8kkHjtU18Yv0OXIJ/LS1Ht32y1jVZe9hZR2Z2/ouKn+H8w9iknfnQegvrTC/H/NNC/x91/onq/1nzD9ty1PnH6gTT1pm8OckukaaewBiVaL3F6gncRmQVcmwlg1stcQ3iXs5YpfzLXtYbsKarM6bki7DrLxvgXWVuGcJ7xDq4IN47faMOHtN3M3ZA11Xms/E9+dzuOdcw0s/8pc59HTXzu4Vz+rcCtubt2LJb5b+3Y3O+AP5bqIc83QQZlMUT6651/1SPrtdx/iXzvbIqJ3kQN6ZH+q1SXDBpt8+tmueaKHMjnmuZ5/RbbZ3K7lnoZ1+KOTVqO64bM3hhKiiVydOtvZiryHj4FSNX/fb0HMZx6/4k/JiqS++28qHMuJ44qq1PGZnZtZVZOpbuE2dE2ahWjMzsNozcmpF2NKXspI3iciwmPfhkSuVr9TYvLa7KMK11lbbIyKP52AzSHL3tVQTNOxWgmdtK0wambaWpZz4MLLfUvb6MZ06ARz3zyA29cnYrI9Jn9VjGJKrMtwAPvHuIHadKMfHUWT17JPXYk+baJPxGerf1G1FnpW5rdVb6eBhDHu270dytPsO1rZynW8mgblJHme/K0eWWUY79a9Fci1wHnpV3oQ4apactxtLTJk62Y5Y6pMp87xB7nsXckvU2eBNPN4K3gHWSberB4m3d1E09+E1DbAAR8g/ivdPPuJ1L+u4zDu8q8xZ8i38Y84L6IeeNn3Lu68jDiMwrcCGAZ+rhJb63gxGfAv5bqIc8PRUyKIsn1i0bgOp5CmjQ+dthA1A5yUNtKNqXk177kHb7XMM810SZFp6ztgNrq0hl9zb0s5+agA2glcEL49hUhrmCOA+kR5YtvQrxtp6OS/3R03Gj7I5ZOm4DNOoabQXCHrTD2LgD4sQoH1AtGfSFWsxPjLiQZONclXlvzryStVZmB3jY+jCrGFOW5x+ZpbguL76JuRWJhwO+WR3MorFi8Ri3oFeZR4fgsYaRgfXrLyeDW9xG+Ts8PCY6iIFV5o+nhMci8okRGwuPnXJ4V5k/wTz5Zw7eom3nYyXgsVYAz0E4b5dYQ/3ogsMTcVNZPLFu4THVQ0yo878HHlM5yUNtKNrTsSg8Ttrtcw3zXBNlzuO5C+Y5tkV6pLL7CPrZxyaAx85n8MI4I5XhdykqZsGuGbNxf7QB2rlezzI2sFbvv8cjC1d6MUpRtoesGCVuPa5rHq5knGxVceWovjyupbNtyrjTWV6PYGOZZ8EmGbXWl7ZGiz9UXx1lzuWMZb5LdErWxFY2JidqbSHxruWNa3FV5ik5vAXJvx2J9fktTt99xuFdZZ6ONUfP6J5Tp6IedptzX0cetmKsUcQ3MQin7noYfdHhibEfZfHEuoWtiJn1X+e31ntlrd1ZbSjaafcn7fY5u46dMSKMy8iy4VN3+wzmrKv37kf5BlcyeCG2snNkpB3Ffvs9Owpj3FmG8Ykq86wh2CpvqxLO0VFzXVYMPbGHjaHPWvPybgd7zGo+klmN66X9R88w1nfD4W/V4S9Kl8rKd7ECGr31xgH0HBS1Wz1/CLaydivJOs9uRX45VhrmWmSbWLobRgbsN41YetwYaK9NVOYbhrSJnfMka7aJ9VsnSb8d1rM1BmDCgzze1x3e7xuChyNy50TiYbZv+u5TDu8qcxU45aXAu56t8Vud+zry8DDxUYS/OyiuvIOHW+C/hXrI0wXIoCyeWLfwsLXh1XH+KuBhlVNZtaFoX056OJq02+ca5rlmMmhr9ex6+s3Ykpehn30r8HBUXFE9gxfiYS8/VRSOsv6oIrZG2idU5jtGtDUy15WHG6P8HVm4kbqVrnm5rjzf+yzkuvJi4E+CF9umzI3IdXyMq7TrA9VnuNUl9apLJcpjG++tOfJgnskfwBj/3fogT9fD2viq6TB5OVXydBjqwmWv6ZuUb9yu86CO8V+HYLqIdYeRugX9xOm7r+VQwnWV+WmMw58FZrOYPb3/Hue+jjxMRwx/vWA68lQFTPdIDqZTGxbFdOvmucNgul9AP3vPFDCdze/mYTpiIfr8rF0tpbsK+TWIKbw1a56NKdqvonevGjl6+1KNioWIESLx3LbhwebJJj5YSHx8xXUrj+bMK0vOszYfeBX20/ljjNvPXejRFpEzpGje0+At1PeC+OzbN0TvttiM+X25Jn9a+LEozesVoJl1l4db2zd7Oroniw2HniifUpYsaK+IyvOTFU/APD8q87EhtuMsudJ2nJdrkHrjqrk2bR+L5EHbdhT+yeoPxAxrRo5VkxkxA3VWi2toY47e75e6pd5tfRmMIaCeMM2YN8lltaIyaya+D0zXaIug7nGpRBoX8V7qEA2HHuZtil6TWDcyY1wK5WN1f/1Xmdd2F/h31o0c6/F0Gu8QT1H7QJ0yMr6W/y0ZpIcyjrDBsH7JmPn29H8xSBanjSxUj4e51L42dzlz6H0t2vdpOe1L38Az8MzXHOvxHKB7TDSHl21H2rw+s8vn9ZrDi3qRrqvMAdr7lu45dVFiuS907uvI08uOcngV54l163tg18Uyh9cXHOuVVTnJgzpGeoyaw+uUee4wObw+C/3sC/FdidIFb8zghbYmlfH2uGW8vudviorXz/I3UY/UNa5X8PCcF68f5aPOitenfVXXovN60Y7IuqL2vJ8zsufcmf57jTP3DttrzcsHOqk8HsRA+q8ytw+ZKyOwbxDvbq4L2ij0X2XuRJvehblQ8yrnyged+zry5krmNrkQwDPnqxLfm5vrgjw9FTIoiyfWrbkyL9fFVcyVKid5qA1F+zRyXbwI/exBzJVRungrgxfOLyrDfH1Rc7edA20eb9qzFkwZ5r1WmVfkfLOKrK2c1ho9xjvRPuLN+YuQi+iO0jOGrWVp4hpteJrTiLs09zFH/2swDp4KX1MUhsmykRLDeDZSL8dc1NjIyjHHsWrXJkT23SxbI/uu10+9WKhp+UK4t0YwNt3lt0XvT/v3G/Gdj/LLcGy1ksHvDHPP/MZCr+ybQFvEnhPemui0yh+smExeAZn8MDC9t3ebtzfsLOZvPPKv9B0HQbamA87dOvL0hBb4jNCNovjUvs82P7z1U7Ado/yNNiZMv4lVPHuQzQMa6bctkvvbm3MXQbc3504TS1lde9R8bkH4ap95xnTkjUHGcUT4CDiPjEJPcM7XsNwBnN/L3vfZ4uWTRlZZeDlqXGTpTPSDHtEcT7MXj8U5eBLrukah0ZsXI8YgMTh9px+sGAb/AmDwP3Xs6rOU6zJSL8/a12ScPJtR2CYrz+YqaKzS/skTzG+/G4UpiHs13kS/l0vz40P8PddzLs05fGvq3XPif65v33Du68jDbPyutwJ4DvIjzVQuzfWFXtmycmmumOcOk0uzgX62ATt3lN3+fAYv1ClVxouNUPmq7RPK2Agv1pX5nTz71bRyuzDW1VurUCY9RXKmy+fCGPsq763j5dWMzm0lrGDr5ng5U1GZUScbln+ravu627E/ie+O2tr77iwYOVZNZmxrrvfjGr5J5VCw6wtrSfa+CPTnq8yzuzQP2xeBfN7c/cBRD6MP19MzovSeLH8N9Z48fw3HZZVyKdNXtBJLj5unKy/G+7k5fYbvEp3eOgTxRDtrlI7WyOCNeorKfG0Ob1Ex9pE6Wlb8uqefPh/Y+XboYJIFbUv3Ovd11MzvVtIvQ/2/XuLXyVMV4tdfDB1N5SQPG4c+jT2o70A/uxdz5qTi171cCTa/8CTjfKyN1pvDbZwL5/CX5nyzaJtnzJCdtyPnuiw8Rb3Sxl5lxfZ88DqKFalyzlrPfqxzxrjYfdG5jpP81R3+ovZczIpFuBE0er6gAHoOaCOy+MPbA/K7h2CrrL1biK3E03mHX46V8+ZaZJsMy2PEfnM+lp4256m8NlGZ/zCkTVqGN8mabUKsk4C/BPVZ3iPy3ebxbnObpcd/HIKHWwE0TtJnseHwrjJvBU55G/Cu2og5lH7Oua+jZn63nHNix1ZSLh5+Svnv7eDhp4L/lqlHPP0jyKAsnli38LDq0fU6zn8WeFjlRKfaULSnY1U4mrTb56xfo4kyxOrW12F9K6nsfhz97OeAh6PWaV3I4IV4WGWo20Th86y8NPQhE1OwDHPyqswvD8HDXhyinuVc2AriN8uH0QKNuubFIZ4H3bMUh0ifmPAi/V+2TRm3TrzPnLybKNtKfL/FpPNteLE278cYX14c5OlIhylGd6QOQ1247Jy8UXi2iI7x4SGYLsAu147ULVrgMT3fdHhXmb/AOPwIMJuNF0zvf9y5ryMP0xHDXy+YjjxVAdM9noPp1IZFMd2iee4wmO4v0c8+PgVMZ3VQD9MRC3lrGyYRhzIuptAcQ3uhZ2OK9qvo3XUjx6wcyKNgIWKESfq5PTs053mW0bPMkbW+2M8bj6x1iW8EvrNzOHOh0y4fhYXsXqL6TSxkc1gH0dOXP03f4mOGHsr+XI7s+S7RSX+veBNPjJuaVJy66PCw81NyeAv6NrUjxx3zy6XvXnN4V5mnL/bk9IzuOXUE5sm5zbmvIw+vUFeK2IcyfW9AXvEOXmF+71bi7zW5AxmUxRPrFl5RPcxXrvNbF3tlVU7yUBuK9nQsbnXPSbt9zuawbqLMFp7LynvPmJ7PQD+7DXNP1Ld2K4OXY+BFZfitXQuix377Rcca5Ej9lmW8/Y2flfPN8vaApf7MuS4Kd2Xpz8RdusbYLstz+vtR0Nssn97OWtLlpP/I+541QU9A3FmHnmYBeoL3/dyLXDej/l/2WlI73ppGVs1kcB/RRjK9PTZmkeaUnmWcpwe/M8sVodH77kX0Z36/iJsuY74LGJ/7taQnf4t3Gc+jMl+/3Ct7BbZi5uhID36H2JZRNld+81r4TZsr52/REzAn7Ea2FfuGxyfn+fuG6F22/9M+IJmp7SYxTwTgp31+GyUzm9ejjjIvHSKz9QyZsZ/Z70iUrYffDNKYGBp1MJ454pta1BYdjZ2L7lcX7dNaQh2j0BOcB2XvMHlQIuwPRW0D9D/TVqRr6oseBprDNbXJPK7RjqVrXEcnOUR8s4rKIbrfBvHpYm3rX2abTQITrhl6rE21KM2rFaA5pv3aF4Pmtf10Lj2eDOaW8fgKsEHsF51Xac+L+C4G8blLe6/efczwxJy0jEeOWkOYFY/PNYRFaF6vAM0x7de+JX3vVvk8XRt/kuuWkS/5kp22TBsM2y2lweYRJl5/N2zDPwldOSpvHNs6PaaJl4L47HwXbNyjl39YZbh3wbRiwYrSfLoCNAe1XzsIa1z7Lkiu1idLW3zDXEvH53sWB++fdu4Htck+40d0TFP/CuLTxdVeLmyrC0Vi1KwcYHm4Oo/mRgVoDmq/gyi9UuPXxlBZvtL5VXFKj2J+/T0n7qfMeZ/zK2Onf/yGXr1H+vb4R8qTXd/r6a60ZYrPKLt9lu66gnYoQnO0nXoUmiP17QgfttW3m0a+5CtC3y/qQ6cdOyJ3SxCfnfG3YHhaNjwxfpT69kIAn7UkOzftAtqhCM0rFaA5pv2e1LePlc/TtfEnuR4z8vXWrJStbzNXqN1Tj3lYNhq9crVGj66jeXn8I+XJ+mK9Oc6uD4r6/uXNcdxbsQjNk8gzPIzmoPZrR/n77bxs/dbePkuMD9hsDN5fcO5HxqIV8S8Gt1NYLJqHUe36PmJU6tvTWoNYlObNCtAc1H4H0bia9osk8deS2DGejs+nTWB+LTI+g/fB2S8aHxGt6xXNH8d+GtCf9ormHGecQtS+NUVijam3LQfIJ0pvoy5TdqzxMSOrppEVY1uIoQL0kFzdSvUd0TwZmumrYny0t2/NNGm0cb9B9BwUnauOgZ6I2MsgPjvfBLt+dyMZlLu3njhq/bYdO/pdRzsc0RxPM+s+xDy0by+kdc+PIIt5h575CcuCMZreHs12bdy0abS2vCgbEm0tHk6vlVyX52+JsI0Wxbzsr9x3Iz3YP4jVq9A/lmPpKRzT6NHIcab7nGfnguRov036zRhuXVsMpmfJ0DNMjh6NHJ8B8XsdGucK0LgFGvWcZ1sU3WmbvzLYNpHSyzmo5dBRR5lPX+qVfXWXNuYHo61lw1yLsjeSB717w/Awrb3v9G5bt2fzq5rMvD09mVPtGOheNdeibDN59kuup/N8EtPyh2R926skMw/XcI3dHK7pGfrHovz4mq+VJ8XaE2q4Npf0+8v4rMr8EPyqb2/0ePfGomcXr0L7MH5kFvtVlH/Iy61F3svG5nOGV/Ypb+zQHlsiLX3rsmvdP7uemGPg5zAGvu6GQTm1ksnMhewj3viza66j7NmUn95t19Q3cS16T8G8OWXY2Lc5dKLWROS1K9eLenlsI/RyfveIn98L/ByxBqCWDOYftt/pOsr86fFe2V+PpW2XOgX7xftQ76Ty1tkYc+at+/eQyfvx/bS+Wvotg33VI+E6YmFiJrvOeRiOIo62tn/6xFol8zcsvo95KYL3aOvEBgTkh+v4MxhXmR55OvpZ8Blhf47iMx0PaV9sGj5sjGu0b9iz9+s351Iv95nuTwJvLxsabY4k5k2izm59l9TZOWYntU+C1c+zcipYm5hng4qMfykS30GsEPDtaxeNf4n2SQXxucv5vex4Cov91oysiP2i1/fVksHYeZsb+ojmydDs6fucg1crQuOE1n7sZsUEn4TeXQUM/nxg8K0ubcTg9FN4ttWoeToLg1M/9zC4F/tZJXvCssPLJORYy5HjkT7ST8+ykdkk687CeYwD0zl9yDZegN9e9vuo2Jqsb6+3bwP7oM0Zye8M+940fTj8vuia5w+nb+JSSTQSrwfrcH1zFtfKPfOG0HZosx3snEU7tspsY856NuasWfRFz6pf1bNtzao9/8im3ne0R7Ub0I80q3bbKJ9k0HhtE59Yv4Pqq6PMlRv6ZcCD7xKdJx2Z2fkvKn6G8w+/iS+qmM70qzf0yt47xvwT1f+z5h+25ajzj9UJpq0zeXMS4z90Tc8wRiVab7F6AnM7ML69lfTrNEnSv/b/X+aMVcq/7H0pA/b96Ywp+SI0piQv5hlUmVcN4T3Ad9IO4r1vfyDFL510eFeZb8P35LXdc+5pRz/z9zr3ddTM7xbO6d86F8Bz+t6APT47Nme7v+mNDk8tyKAsnlh3LemN8wTXubfqG27olVU5ycPuS5qO5R3cz3qubp5rogz3h7rRPKffautUdq9HP/tezKkRMdK1ZHDPKm+fxB3IQ9fmnXI25ipSH+L+Wa2kP35b/5m7JT2y9JyomP2sOZNy0rUt0BOdW0Ays3bYLB2L6/FFY1R/tPkYVox8suxodp9umzMvIkfhJ1MuTau3eXkpVYZ5ZadlxylKc2MGaZ7Evntl03yqAjQvdf+SpN8GdqJ7Tj3zEWC5G1BW/7tmzmvPps98VvfDRF1O8yXps3osYxJV5teAB04eH3wv9dgqxcRTZ/XskdRjbc63SfiN9G7rN1pOfN3W6qz08TCGPNp3o7nb7rlNTCQ91uomdZT5QI4ux/1N2b/Ommspv9tB/GbtiboNGqWnnY2lp02cbMcsdUiV+ZMh9jyLuSVr+nXE0w542wnize7Ru2Dqph78kSE2gAj5B/He6WfnwGP67g2Hd5X5K3yL/wbzgvoh54368cH7OvIw4jZkeT6AZ+rhJb63gxEvgP8W6iFPN0EGZfHEumUDUD26Xsf5/PFeWZWTPIjL0yMdi9LTSbt97ox5rokyN+K5lnlOv2k/+Rj6mfpRpM51YwYvjGOz9hzqYSqfNUdE2Xaz5gjSrWvUH4UzqD/qPjFIlN3R7q29ZeTYTHx7BrGHrtm4A+LEKB9QyoP1hVrMT4y4kGTjXJU506XZm1ey1sq8CH4d68OsYkxZnn9kluK6vPimZTxDPBzwzepgljOQUfpu9Q/VV0eZT8vpW3yX6LR+/eWkh6XPgLcIf4eHx0THWfCmMns5vEXisQDe++zRwmOrDu8qcwtijG518BZtgc8pAY8F+E72gnDeLrGG+tF5hyfiprJ4Yt3CYxeMbOs4/yLgMZVTWbWhaE/HovA4abfPnTHPNVHmHJ47b57Tb7V1KrvPQT97zgTw2LkMXhhnRL1F9ETZ06ytx+agqSWDPnQvNlBlviLnm5WFK/XsJGwPWWvktkGjrnm4knGyVcWVo/ryuJbOy6/+zOtgPYKNZZ4Fm2TUWl/aGi3+UH3cG+tfDMFWNuZcsia2sjE5UWsLiXctb4yFV5mXDMFWEfmkI7F+HTym795weFeZl2LOewjYycbldnKNOfd15GErxspHfBODcOquh9HPOjwx9qMsnli3sJXqoS1a5/8G2MrandWGop12f9Jun7Pr2BkjwriMLPsMdbeXo5+9GtgqCstsZfBCbGXnyEg7iv32e3YUtZPFVoxPVJnXD8FW1gbBGHrO0VFzXVYMPbGHjaHPWvNycsbj2rOwxyzF9dL+o2cY67vo8Fd3+IvSpbKwPMe4t944gJ6DonartxW0W0nWeXYr8suxcsZci2wTS/cZIwP2mzOx9Lgx0F6bqMxPDWkTO+dJ1mwT67dOkn47rGdrDMCEB3m8Lzi8/8IQPByROycSD7N9W0m/v0LXVeaXgVN+ZYit8TfHtDUyjiHC3x0UV97Bw7SXtVAPeWKcdlk8sW7hYWvDq+P8fcDD1vanNhTt6VgVjibt9rkz5rlmMmhr9ex6+s3Ykvegn/0m8HBUXNF2Bi/EwyoTnL9/ZFsjfVQsQ1ujyvz+iLZG5rrSs5wLo/wdWf436lZ2vxvaGmkjnaVcV/RrEy+KF8/W+D7kH9R9xlXa9YF6lvv2Ua+6VKI8NvHemiMP5pn83xjjn7I0yNP1sDa+ajpMXk6VPB2GunDZa/om5RvXOPB0DAUzZ2G6iHWHkboF/cTpu086vF/DvNgvYXGpJw6L2dP7p5z7OvIwHTH89YLpyFMVMN3mUq+sxWZqw6KYbsE8dxhMt4R+pn40SUxn87t5mI5YiD4/a1erSn4NYgpvzZpnY4r2q+jddr80+os5D42ChYgRIvHcpuHB5skmPlhIfHzFdSufljOvLDnP2nzgVdhPZ4/76Zzo0Rbgvy687y/X2EbYtIP47Ns3RO+22KyJMsznPy38GJPXoX2zp/95svD2F43yz2TJgrp/RP+nLOzYZM4clfn8nO9Lnlxph83L20cdrEo5+qi3BMdL5PYHzm0rRo5VzmvIsc04F9FdpXgt+m+YH2BavjJirYWKyoz+e44ZXaNeLz2wbN3lDN5LnXTLoYc5kKLWLlqdWHVTj6F8yAOfVZnfBi66C/arNbxDPC0HyXjVyFj15O31EWlzWTYyVt0ct+wXl7rnu4c7BvIHs+0oe9q1KD/iXpV5M9r3JTnty3yfV/HMD0BfCcDxE7Wd2Xak7ezh69x21nR4V5lvRnt/C2xjkgWx3Oud+zrydJwj21lxnorazl6XYztTGxa1na2a5w5jO3sV+tnr8V2J0gW3M3ihXqYy3n6xjH331h9OS29jrinG/nt4zot9j4qby4p9p62Sc6voidAlaJPz9p4ocZzuemssOHem57/lzL3D9i3zcmtOap2i6vbWKb51yFw56+sUmw7vKvOf0ab/BXOh5lXOle907uvImyuP1ikW54l1a668YGTLdYq/iLlS5VRWbVh0neKWee4w6xR/Ev3snZgro3Txcxm8cH5RGea+i1r/NcyuTLvgginDOUZlHsn5ZnHOF99ZMedRc35WzDnnfF2jfcSb86n3iO5pxf82k/4cvLqWl/+CcUK/hXFwL/w2URgmC3sRw3g2Ui9fWxSuzcrXRlnaOP/IsZpla6Tfw+unXlxRFTB1MDbd5beFvu0P4Tsf0FZt9h1rEyHv1/I0LPfK/hloi9i/wVtfnNb7WMVk8siJXtmPAtN7+6Atm2tVW3fs6RheLsQj/0rfcRBkazoousbgHPiM0I2i+NQeyjYuy+IEtmOUvzFrXSvnMM8e5OWwqEJMkjfnMq7cm3OniaW89cej5EYLwlf7XDOgI28MMo4jwkfAeWQUeoJzWu0F8dm3f1PZeyhbvLxsZJWFl6PGRZbORD/oEc3xNHvxWJyDFytCo5cbOWIMEoPThvCZsfGShTH464DB293zWc0bGamXZ+0R4q2bmaWclZPQoyQzT4/ycsVH7GkehSmIe22ecG+vsOd0x9j1ulfYtby1uK4yX4pvzZd3z4n/uVb8+c59HXmY7WivsOI8se5a0huvSeLvFfa8E72yKid5qA2nuVfYc9HPno/5dtJ7hVGnVBkvNoL7cHm270mtKfdiOuwaSerCTdDt2a+i7AxZ9ivq7V6uqgisMqqOTZ8LY+yrvE+Nl6MyOk+Uvg3eXvaSy0ZFZcbxMiyX1aq5Nu22tnsSRbY1cw20nLr5jVmrqMzY1lw7x/Vwk8pH4OUCydpjgLknVObbczDpUuLva/1K5Jywsa20s1HPiNJ7svw11Hvy/DVHOdj8HGx5Md5vzOkzfJfo9NYhePm8onS0rQzeqKeozJuH6GgRMfaROlpW/Lqnn/4wsPNboYPZtfLp/Z9x7uuomd8tnNMXdb3Er5OnKsSv/zR0tGFx6NPI/fBj6Gc/gzlzUvHr4sWLX+e3dlL+PIt3OT/YmDzacVXmXTnfLNrmGTOkZzlHT3MNJdclikbLM23o10OsCLGHjQuZ9npqz36sc+q8eoYxLlsOf2cd/j4J9sk8oI3I4g9vn8w/GIKtsvbJJLay+2SSX46VHXMtsk0s3TY/O/vNTiw9bc5TeW2iMh8e0iZZe9OwTcQTy9KW5e1tGoAJD/J4P+Pw/pEheDgirmmSPotFh3eV+SvglL8B3uXeALpfXx68ryMPDzP27HrZ25Q83QQZlMUT6xYeVj26Xsf5/HKvrMpJHsScSff3KHubnjXPNZND7G2KfqZ+FKUfUZewvBBvqQx1mygcZW36ds0GsZbFw7RPqMyJ7smwNSqMQ/RwY4QPkbzo3fpN3Yr+BP0XdjoLuqsah7iDa8KL9IkxX4J4sW3KuHXifea3Jf+txPdbTDrfhhdr08IagK9ZHuTpSIcpRnekDkNduOz8tlF4toiOsZfzfQyad9qRuoXdr77p8K4yt2Ac3grMZuMF0/vPce7ryMN0xPDXC6YjT1XAdF+Ug+k4/6XHqJjujHnuMJjuc9DPngNMF7X2Pmu/+jxMRyzkrW2YxB5R465t0BxDe6FnY4r2q+jddh+3ZjK4/92oWIgYYZJ+bm9teBbu5r4SKvO8nHkla13ih4DvLM6g35+xPNOKiUppsLpDED2dOX0dcmolg3ERdZR5YY7s+S7RaWOTiUXXwVvAHn+dvKYnM3hjjILKvHgIXgnI/7wfxHtfXmnhlRWHd5W5H/PIVeARtRH1n1c693Xk4RXmEz4dwHOQb6mDV2zcwpbD06RzWtKWqPN/Dbxi5w61IWM/TnXPSbt9bt08xznnFJ7LiplUW6eyewj97JWYe6K+tacyeGF8qcrwW7sSRI/99ouOFchR7bRgynAuVJnXDrFBaT4T38RdnOuicttn4S7uVaRrjMOzPKe/Ly/26D1RPr2dtaRLSf+R9z07AflFrLNaQh2j0MM1ShExDkF87nK8Ra8lPWFkxRjLKughRzRPTt/TWBet/DYuVYRG71sdpac1DD0N0BFY9y6/98SZPwF8EPA96+g+J1BfKxnU9+so8zsbvbJvh22d/Uf/vX4UhSmy+tEKeLE+gwZoK5se9RvZsBqOLAL8DLtBPLUpY/WTRcMTMdkvDdGRbXup/9AX4o29iPYK6pfuGnHRzzVpKvOeITLLml+WIDP7/QzibX+SthjR79lifr2gLUYy43fBs8UEYOu9onlRiK3Xg+gpgq0pnwhdtagtZQ30RNiPaEcdhR7mGI3QJZeS/jVJw+ihXSZizzzuzzcKPdwH91QQPZsF6BENtBFwzvHwu/on8andlyK9pnbiHnve3oGil7HhAX25XVQ20X05iM+Ovmvz0tp1dWyzBv5Pa1/jojQ3Z5DmYB/OSDTH9Ln2xaD5uZ1ilOOQ67qRL/kK+J7uF8UHp0BPlO0tgM/ON+O04emE4amJMly3FOHD8Wz2+n0a7VCE5rUK0BzTfu1bgnxe+xp/kuuWkS/5ku+pTNst2y3VhYQl6PPS/ac1e+U2mz26Ivy1S0l/W6fHNHFoEJ+73pxyyvDkYb1If3bWHtXM9VCE5tMVoDmo/dpB8/K174Lkum7ky7wpNtYi/f2pzcH7p537UTEhn0y6gLX/eBhVZRiTHGFvycOo62iHIjQfqwDNQe13EKQr7FtcvWbkK77S+VWxg8/E/PrZGJ96R5nzPudX7k9/02qv3gjba1F7TrT9LYjPzndhxfB00vDEeF3aCKL8V1l76TAmpgjNzRmkeRKxR8NojulzT9oIIvy3+pZJrjb/D/mKiheyvpe8bwZ9Go3y6dkL4rPzzVgyPK0anhhPQRtBlI/5hKHH+gOL0rxSAZpj2u9JG0GAv/0alrC52Ty+1CfKthGo3WgjqOO/7j8EDHMXMEwExvpkwhLWL+/NcXY9bWRMVdYclxerlkfzJOLAhtEchXmj4iPsvGxjGCjbTXMtHZ8vaw7eX3LuB7XJflFfc7R/J4hPVxfw8qSqDG0Ek4qPtzGjRWnerADNQe13EISrr41fyXXZyJc5BOwYT8fntzs2vLLXtwfg3IOiMS/E8xFzQ9oGso2+8MrVL7ny8FdfvufuOy9fvfu+e5975SUPXnngag1kMkSMpNeSfjaeSAZTEaQHwxI3nPtP4P8kl4uuGvqCmr8dBP07qbCk7imsz0LkOsq8octoVlhfw8hH7a53LhtZ6X8U1C2iAhPqBqjA+0WHMOUTofYtJf3tNYye4BDpvaJLnBiaFZBipV10+z6aFiJSfQfx2YFa84anRcMTl+3T7TQfwGctyU6XyrRHRzTH00x1k8sKVG61IjTaLWeC6DkoOqfQrBCRBiqIz843Yc7wtOrIXWXYV+cC+PTGjn7PoR2OaI6nmXUfQnVq2wtp3VsjyGLLoScqbXeWLJhuwDMdqdxaRWi05ucos2sz6WFKD0/XSq6LmFT/A76HhZffs7/qOc6f8zgX3VXoHwux9OwvGXqGydGjkeNM9znPRqW7ykohwnRXdiu2KHqWDD3D5OjRyPEZkZKtaMpApjbjljjpQXM7Q2//NtZd1ln2yBDBlkNHHWXevNYr+3+7tC0ng64CmvH5DZjWEoyURi/8c1qhp/xublZUZgzXZZiHDTumzsDv1LRM/tPa2lDv9rY2tDpv1WRGPZhjRtfO4JqeYdrwAFdIBy/LlmrTqDHdM11k5JXPXkuB2T1Jv19PX+mV88ai54auQvswnH4W+1WUS5VzvxfSVzY2t9utsE95Y4d+mxJp2asZHjlumLZMZT4dY+DXVgbl1EomMxeyj3jjj65OK79WkPz0bhvOSrc2lxVFpW7LmlOGjX3d59iPWPqU166boNGG90Tp5fzuET8/E/07YqlPLekPlW8lg99ppvr8euDnZ8fStkudgqlYvxD1Riz5ryWDqV+97WlVZgky+cf4fl67j/9r5to0cR2xsLcdNFN95uEo4uhlcy3I3567LYTny2aaigCsdxDkPzgoupScdo2oMPEIPtO+lPbFFcPHCfO7CqnsON9zjFcpbRvT/1Fnnzdypc7OMRuFC7J0dm+JLeVubWLEr8EhlIeKU4mINTpMqNksLR2JCgH0sJ+NgyL2i17GW0uyl3eoviOaJ0Ozp+9zDl6tCI0c0/ofMQaJwZnu9NUVw+DvW+2Vfa2DwWkL82yr01o2mYXBre2uavaE5cRfKhktx1qOHI/0kX56mkZmk6w7C+d52/PRh6y+zf7vLQmMwDF5315iUV0jFlX/4hjV/SosXfPS4BFXe32iTBsv8XqwDtc3Z/WlBF8JbYc228HOWbRjq8x3Ys56O+asWfRFz6pf1bNtzao9/8im3ne0R7Ub0I80q3bbKJ9k0Hh10+Lb8cq0+L+70i8DHnyX6DzpyMxLAxuV/trqKimPj1ZMZ/o8zD9/NMb8E9X/s+YftuWo84/VCaatM3lzkt3elHoCY1Si9RarJ5zAdeFfbStmU3xzDeJf5oxVyr/sZb0Ba7o6Y4pbnraS/u1GxbvK/N0Q3iPWwQXx3ukbc+AxffdJh3eVeRxxGU90z7mGkX7m5dXB+zpq5ncL5/RvRWzVnb43YGvxjs35HPhvoR7yxC2cy+KJdde6f6qH25Lr/MRqr6zdslltKNrTsaC4YNJun2uY55oow+0jd8xz+q22TmU3h3lrGan9Ita81pLBLS0b4F28MDZa/7eccjbmKjIefhFybeG3p+cwjpvbbOtelM52xsjWyocy43riqDRbq0Zm1g6bpWPpPnFGVH9UXXq3Xb+SZUdTakzaKJgaMyIVKbFwAtkmhgcdnyzbZzB99KxsRXFsBmmO3nopguZTFaA5Hbc3dM+pDx7vnlPP/CwHy92AZ/RdOo5rXBuqa/p2LuId1PU0n5J+q+cyZlFlPh944du651l2nirFzFOn9eyV1HOb5tok/Ep6t/UrUaflPavT0gfEGPNo347mdqb30nX1Pem5Vnepo8xXdRvC0/WWk8FtHpmXgf0rap14Vl6GOdBIPS6QnjZxtB2z1DFV5vk5suW7RKdkvQnexNNZ8BawjrJNPdnmaDoL3lTmjhzeouQfxHunn22Dx/TdGw7vKvMN+Ba/CPOG+iHnlYed+zryMCTnlnMBPFNPL/G9HQx5Hvy3UA95akEGZfHEumUjUD26Xsf5Q7ARqJzkoTYU7elYpE0l67kF81wTZXbwnLUtWFtGKrt70c8enoCNYCeDF9pJrb2HeprKZ8U7RK3zzYp3IC61WwxnrfXXfWKQKLvkoqGb87Zo1DViEcaa6L+NSyBOnOQaa6sTECMuJNk4V2VelzOvZK2leRR+H+vjrGLMWZ7/ZJbivrz4J24HTzwc8M3qYBaNFYvHmPNMZd40BI8tGBlYvz+3JWcOkwh/iIfHiN/1X2V+aEp4LCLfGLGx8Bhjj/RfZd6GefLHHLxF2887SsBjAb6VvSCct0usoX50zuGJuKksnli38Jjq0fU6zn8eeEzlJA+1oWhPx6LwOGm3zy2Y55oos43nzpnn9Ftt3Ym9Qz97xwTw2HYGL4xDUhnG0EfFNDQMPTYukDZCO9frWcYO/krONysLV3oxTFG2h6wYpjnQqGseriTuqCquHNXXRzxv25RxqbO8XsHGOs+CTTJqLTD1Kos/VF8dZf5wCLayOppkzXfamJ2otYfEu5Y3rtVVmQ8NwVYRW3tFYn1+i9N3bzi8q8yfY857DNjJxu2m9x937uvIw1aMpZ+1nNYWo3trvBkbUhZPrFvYSvXQFq3zfwC2snZn6uGiXfMDabfP2XXujCFh3EaWDZ+620fRzx4HtoryHS5m8EJsZefISDuK/fZ7dhTGrbWSwfUhjIutdwWXha2sDYIx9pyjo+a6rBh7Yg8bY5+1JubV11G+klmN+yV21DO0SS47/DUc/qJ0Kau76PciaPTWIwfQc1DUbtXKGct8l+iUrPPsVuSXY2XBXItsE0v3gpEB+81CLD1ujLTXJirzaUPaxM55kjXbxPqtdT0Br5b3iG2f8ng/4fC+n8N7ENY6iMTDbN8W+CLvKnMRebJu655n2Rq/2LmvIw8PM44hwt8dFHfewcO0l7WSfr+6eGIcd1k8sW7hYWvDq+P8OWu9stb2pzYU7emYFI4m7fa5BfNcMxm0tXp2Pf1mbMnnop+pH0XGFc1l8EK8xZgb0ROFo6w/qoitkfYJlfknQ/CwlwvLw41R/o4s3EjdSte8XFict2cpF5YXI88cZLZNmTuR6/wYV2nXD6rNabekXnWpRHls4r01Rx7MQ3knxvj3rQ3ydD2sna+aDpOXcyVPh6EuXPaav0n5xjUOPB3jwSGYLmJdYqRuQT9x+u6TDu8q8zKMw5cDs1nM3snL5NzXkYfpiOGvF0xHnqqA6V6Tg+nUhkUx3Qnz3GEw3begn712CpjO5n/zMB2xEO0D1q5WlfwbxBTemjbPxhTtV9G7G0aOTVxjHodRsBAxQiSe2zQ82DzaxAcLiY+vuG7lTTnzypLzrM0XHpFThTyMst/OD2Hc6mKQ/7pwXtTgLdb3gvjc9XQ8i82aKMPxHuWTyMKPzC1RhOZgH/1INMfg1vbNad0nRpDFCYeeqO9vlixo14/KA5QVK0Efqcq8Y4jteJRYCeuzz7LnN8y1aftY+L3S/yj8k9UfiBk8rFMlmREzcGxbXEMbc/R+wNQt9W7ry2AMAfWEaca8US5VlFkz8X1gukZbBHWPSyXSWMd7qUMsOPQwr1P0msS6kRnjUnRtLun3vfFZlfny7mL69Dv9Adjc1hwZR+QQTd+1amSsevL2L4mywbB+yZh2ddVdD5LFmpGFjZ8ifWpfm9ucsXrbaN8/y2lf+gYeA74/u97jOUD3mGiOL9uOtHn95eR9uBPN8bXi8K4yf4f2/hjsedbvm95vrA/e15Gnlx3l+CrOE+vW9yAvx9fieq+sXU+rNiya42vVPHeYHF8fRz9r4LsSpQuezeCFtiaV8fbAZby+t2ZyWnob8wRTt/bwnLdmclI+6mUjR9oCmPcrQpegHZF1STYljtO+fTe5BuQs5t4v6557WIaxhF6MIDFPxLpFjhWbD5PziMrc1OUla66MwL5BvLu5Lrh3r66rzNPQpp+KudDmBkjv3+rc15E3VzK3yfWS64I8tSCDsnhi3ZorVY+X6+Ii5kqVkzzUhtPMdfHp6Ge3Yq6M0sWzcl1wflEZxq9Mag7UN5P5nqzfxdpb6bO4lPPNKrK2Mmq9Q1a8k5dLjvYRb87X/UmsrRy2lqWJa7Th5fn4mMP/yzAOPoxxEIVhsrAXMYxnIyVWFI1RuDYrxxzHql2bEGTrz7U1sm29furFQlUBUwdj011+W/T+tH/fjv4d5Zfh2Gol/jdTZf7dRq/sHbFjb9dbE53We1fFZHIJMnkRML0d/9S9JqEzjpKvxuqMo+arOfKv9B0HQbamA87dOvL0hB3wGaEbRfGpfaEbho+6+R+8xsmNCdPvYXm3bR7QSL9t1vxKv23enMv8pN6cO00sZXXtUfNuBOGr/aJxrIzjiPARcB4ZhZ7gnK9huQM4v5e9L7TFy8tGVll4OWpcZOlM9IMe0RxPsxePxTn4REVotP77qDFIDE7f6Y9UDIMvAoP/J8euPizX5bRiD72cAZF6OcdmKxk9z+YJcy0S2wzbm5c6SnAeJHffNE+P8vJ5BshnNwpTEPdqvIl+L5fmu4b4eyJ8UpG6ZJFcmv8d9sdH4M8R3ub69vc793XkYTZ+149yaY7GE+uuJcNzaf42/D1l5dJcNM8dJpfme9HP3o/5Nspuv53BC3VKlfFiI6j/VmkfUa6v9mJdiQc8+9W0crsw1tVbq1AmPaPq2PS5MMa+ynvreHk1o3NbCSvYujleNioqM+pkw/JvrZpr025rO/Yn8d1RW3vfnXkjx6rJjG3N9X5cwzepHAp2fSHpt/lLuM/1NT2xezFrHaW3V/ffdhegUQ+jD9fTM6L0nix/DfWePH8Nx2WVcinTV7QYS4+bpysvxnszp8/wXaLTW4fAfAniLUpHW8jgjXrKtRxLObxFxdhH6mhZ8eueftqCPeim7jnXrdG2tOfc15Gno9EXdb3Er5OnKsSv7270yg6LQx81ft36GA8Tv/4p6Gd7mDMnFb8uXrz4dX5rJxXnY2203hxu41w4h9+W882ibZ4xQ3bejpzrsvAU9Uobe5UV2/Mj11GsyCzlrCUeoc5r903nOk7yN+fwF7XnourSu/X7LGj0fEEB9BzQRmTxh7cH5D8bgq2y9m4hthJP2w6/HCvb5lpkmwzLY8R+sx1LT5vzVF6bqMw/H9Imds6TrNkm4ollacuac3iPyHebx3vd4f2FQ/BwRFzTJH0WzMWr/ypzD3DKvcC7HFe6/wrnvo48PMzYs4C1JHv0G5T43t0a+FA/Ou/wdAEyKIsn1i08fMHIto7zlwMPq5zKqg1Fe/pbOJq02+esX6OJMsTq1tdhfSup7O5HP3sF8HDUOq1zGbwQD6tMcI5w16bvrVFZBj0sQ/uEynzrEDzsxSF6uDHCh0he9G79pm6la14cIuftWYpDpE9MeJH+L9umjFsn3mdO3hWUbSW+32LS+Ta8WJs3YIz/xsYgT0c6TDG6I3UY6sJl5+SNwrNFdIwfHYLpAuxy7UjdgnHv6btXHN5V5scxDn8CmM3GC6b33+Xc15GH6YjhrxdMR56qgOnemYPp1IZFMV3dPHcYTPd29LN3TQHTWR3Uw3TEQt7ahknEoYyLKTTHcK70bEzRfhW9m34W0ahrXBs5ChYiRpikn9uzQ2fhbsb6qcxvD/Ele+sSbwe+8/JMNs21SHk0k355NI08iHuasfS4sdzHDD3El384xEZl25p9TbyJJ2LnqDzJ6xm80RalMh8aglfWA2icRAyH5rNlh3eV+XPMI48Bj3g5xR537uvIwyvrkGVE7vX0vafKf28Hr5wG/y3UQ56oL5bFE+sWXlE9ul7H+T8Ar6ic5KE2FO1pf1BeatJun1s1z3F+YV71U+Y5/WZu9I+inz0+gbnnZAYvx8AL9/oRPZPSg0UHbVCiY8GU4fqsa3umdokvYoPy5rqAb1vuXLcOGu38t+Tw3NGjuj/+P5VN3McrXgMA","debug_symbols":"7d3hjvQ4ep7hc9nfRiBSryTKpxIEwSZxggWMdRBvAgRGzj099id1j4f1VY30zENW8/63Tqq7qWuqVe/N+rr4L3/6b//wX/73//jPf/nrf/+nf/7T3//Hf/nTP/7Tf/3z3/7yT3/9+L/+5U/Tf8jlX/9f//l//vmvv/w//PPf/vy//vanv1+m7e/+9A9//W8f/6uk//d3f/rvf/nHf/jT38+R/99/+rtfvmi/8EVzrn3Rtu8/vqiUrfJF85UvWmtflFI6vurjfy2VL9sufVlM1S+LKMeXxTJXvixd+7J87cvma18W175sufZl67Uv2659Wbn2ZfulL1uuPUuWa8+S5dqzZLn2LFmuPUuWa8+S5dqzZLn2LFmuPUuWa8+S9dqzZL32LFmvPUvWa8+S9dqzZL32LFmvPUvWa8+S9dqzZL32LNmuPUu2a8+S7dqzZLv2LNmuPUu2a8+S7dqzZLv2LNmuPUu2a8+Scu1ZUq49S8q1Z0m59iwp154l5dqzpFx7lpRrz5Jy7VlSrj1L9mvPkv3as2S/9izZrz1L9mvPkv3as2S/9izZrz1L9mvPkv3asyRN08WvSxe/Ll/8uvni18XFr1suft168eu2i19XLn7dxedLuvh8SRefL+ni8yVdfL6ki8+XdPH5ki4+X9LF50u6+HxJF58v+eLzJV98vuSLz5d88fmSLz5f8sXnS774fMkXny/54vMlX3y+zBefL/PF58t88fkyX3y+zBefL/PF58t88fkyX3y+zBefL/PF58vFTdp0cZc2XdymTRf3adPFjdp0cac2XdyqTRf3atPFzdp0cbc2XdyuTRf3a9PFDdt0ccc2XdyyTRf3bNPFTdt0cdc2Xdy2TRf3bdPFjdt0cec2Xdy6TRf3btPFzdv0YHshp+X4unn/9XuFf/ebR8ecjp8S8zqdj/4Y+iuP3mOPH4/ely9ryjEda0odril3uKa5wzVFh2taOlzT2uGatg7XVDpc097dmvLU3308T/3dx/PU3308T/3dx/PU3308T/3dx/PU3308T/3dx/PU3308Tx3ex1OH9/HU4X08dXgfTx3ex1OH9/HU4X08dXgfTx3ex7P9XrAsxz/vXbbP75y35VhR7m5F9uf3UvKxolJqK1q7W9HW3YpKdyvae1vRPHW3otTdihT3o7x/WVF6sqKPN1GOb71++WuLdK5o7m5F0d2Klu5WtHa3oq27FZXuVrTbVzTnc0XlVyv67WPzmtKPB+d1Xj/vXvNSX0c+15E+v3dslQdvy7HmbY8v3/iHS0y4VF0SLlWXjEvVZcal6hLfyGWet3MdsXx1+XGxy0gXu36ni93iXEeZKhe7fauLnT8vdq9cbBnpYv2D4RmqH+8OV0bVZepuRam7FeXuVjR3t6LobkVLdyuyv4jlfNyPPhqjtqKtuxWV7la097aidepuRam7FeXuVvQH37N//JSw/JTF8lNWy0/ZLD+lWH7K7vgp22T5KcnyU7Llp1h+9zfL7/5m+d3fLL/7m+V3f7P87m+W3/1i+d0vlt/9YvndL5bf/WL53S+W3/1i+d0vkn98sn7uW3752MGr/7CqlA7XtPe3Js0frInXlDpcU+5wTXOHa4oO16S410Y+32r4+qef9TVt5z9p3Pane13TuYy8/6p2f/vY8vnRrOnJQ9MWB2La1q9v8VX322Nfj8tbvnzvc79d8gd2392wPDHcejbcyoMt10u/cmWcS91HudRZ8leRb3KpaZxLzeNc6jzOpcY4l9r1fKe91K7HMO2lDjMtzdMw09I8jTMtpXGmpTTOtJTGmZbSONOS5O+63+RSx5mW0jjTUvJPS+fbQuXLn249+CPP6fi3v+t0ez93TmWga93HudY8DXStaaBrzQNd6zzQtcZA17oMdK3rQNc60NyUB5qb8kBz0zzQ3DQPNDfNA81Nkg/VifPPxmLZ4smaUqzHn5mk2H4t82NN0eGaNvualv3zr3zj2cc5pX06H70v5Vf/pS89L8pg17uPdb2SD7J5p+tNg11vHux658GuNwa73mWw610Hu97B5qsYbL6KwearZbD5ahlsvloGm68kn7OyTueHS63bs72LPC3nx1Gkku5fQXn7K9jf/Qokn/vS9grS219BfvsrmN/+CuLtr2B5+ytY3/4K3v41eX371+T17V+Tt7d/Td7e/jV5e/vXZMknBG3L+YfcJT0tnGWfzh56+tfnOebzY3Dj6eEo3+5zBGbJZyvx3+cP++8j+VQq/vtc/+9Tnvz3SaP+95H+uYTkA8tglHwiG4ySj5yDUfKZejBKPjQQRsmnIsJYhg06LeOw3SVl3IfNIy0jFSNhpGIkjFSMhDFgVDBSMRJGKkbCSMVIGKkYCSMVI2CMiYqRMH6vimn1t78xfa+Maef4vTqmnWPgKHH8XiXTzvF7pUw7x+/VMu0cv1fMtHP8XjXTzDF9r5xp50jPaBzpGY0jPaNxDBwljvSMxpGe0Th23jPztB2X+/GA8ux7P/vsu0idd4f6enPn89jvvN6WnxsRufOZ7K0sO5/L3soysJRZdj6fvZVl5zPaW1l+rzmtreX3mgHbWna+//xOlnPne9BvZUn36CzpHp0l3aOzDCxllnSPzpLukVlG76/jaT227ud//TiWn35v8SdVRfT+ytxWp/fX2rY6vb96ttXp/fWwrU7vr3BtdXrfq2ur0/vuW1ud3vfTmuosve+QtdVhVv6ZDrPyz3SYlX+mE+j8RIdZ+Wc6zMo/0/HPO+vyuZ9Vnv0Fd6T9/CTyHJ/7WWvtwet6fOctfbL/60cB//YbL8cVfv2M3l8e+28w6wRMHSYBU4fJwNRhZmDqMAFMHWYBpg6zAlOH2QaFWdJxNMHy9a3E6mPTB8Kx5PRlEakc4+BaYFQwjjpVaxm3UWdwMeOoE7uYcdT5Xsw4ag2IGcPOuE3Ho1P55fv9lHFfz8vd1/VzW6u+UTVv50LS5x/gztWHrue/h5q3L4uuPnidj8eu8/z1oT8QFxDvI64g3kfcQLyPWEC8j7iDeBuxwRGM3xAxgXgfMYN4H3EG8T5igHgfkWIRIFIsryCux/ddS1QQKRYBIsUiQKRY7iPuFIsAkWIRIFIsAkSKRYAYIN5HpFgEiBSLAJFiESBSLAJEiuU24jJRLAJEikWASLEIECkWAWKAeB+RYhEgUiwCRIpFgEixCBAplvuIiWIRIFIsAkSKRYBIsQgQA8T7iBSLAJFiESBSLAJEikWASLHcR8wUiwCRYhEgUiwCRIpFgBgg3kekWASIFIsAkWIRIFIsAkSK5T7iTLEIECkWASLFIkCkWASIAeJ9RIpFgEixCBApFgEixSJApFh+g/hvMkGGPJKhLR7JEAyPZKiARzKBzAMZ5vVHMgzhj2SYrB/JMC4/kmEGfiCzMAM/kmEGfiTDDPxIhhn4kUwg80CGGfiRDDPwIxlm4EcyzMCPZJiBH8iszMCPZJiBH8kwAz+SGXae2eZPmZgrMsPOM09lRn1tinx+48i/Pgbhdz343xi3UV/IxIyjvuqJGUd9iRQzjrqnJGYMGBWMo053YsZRR0Ex46j7YGLGUTfNxIxUjIJx2HNZxYxUjISRipEwUjESxoBRwUjFSBipGAkjFSNhpGIkjFSMgnHYs1rFjFSMhJGKkTBSMRLGgFHBSMW8wJhzOf7xSZ6nXGGkYiSMVMxLjGv6ZPztL/U67ImZv49xyeVgXPJeYWRulDAyN0oYmRsljAGjgpG5UcLI3ChhZG6UMLL7LWFk91vBOOwpmmJGKkbCSMVIGKkYCSPjt4SR8VvCyPitYBz2EL7fx1i2802Esj958BznBc5Ref9rHfbMvpbmjFJ+c+Yuv3lgbjdnMPabM0X7zRm5/eZsj/vN2Uu3mw97tGJLczrUb06H+s3pUL85s6LavJx2JVV2coc9dK6Z+LDnI/1x4vv5j/X3slbE2Wlxi3NXUYunaTr+lCJNKSrm9KfdfNjzhFqa059+c/rTb05/+s0Dc7s507nfnPdB/ebsbfnN6VC/OR1qNx/2TK8/0nyN4wJTqrxXMexpYS3N6VC/OR3qNw/M7eZ0qN+cDvWb06F+czrUb06H2s05krOBOR3qN6dD/eZ0qN88MLeb06F+czrUb06H+s3pUL85HWo351DVBuZ0qNw8p9M8p6ViTof6zelQv3lgbjenQ/3mdKjfnA71m9OhfnM61G7OsbgNzOlQvzkd6jenQ/3mgbndnA71m9OhfnM61G9Oh/rN6VC3+cYx2w3M6VC/OR3qN6dD/eaBud2cDvWb06F2cw4z/gPM49M8SsWcWdFvzmuo3nydT/MtV8x5DfWb8xrqN2cv12/OXq7fnL1cuzlnbzcwZz73m7OX6zdnL9dvHpjbzelQvzkd6jenQ/3mdKjfnA61m3P2dgNzOtRvTof6zenQe+Y/GANGBSO1KGEkACWMNJ2EkUyTMFJeCsYgpiSM9JGEkeSRMFIxEsaAUcFIxUgYqRgJIxUjYaRiFIwLA88rjPtyPDh/rKjCyMAjYeQl5iXGMp2M1V9qXmIkjLzESBjZKFMwctK9hpGNMgkjc6OEkblRwhgwKhjZKJMwUjESRirmBcbt+KyHrfKJJpy+fp+QerlLyNno9wmpltuEFMttQmrlNmFAeJeQSrlNSKHcJqRObhNSJ7cJqZO7hJzefJ+Q0fo2IaP1bcKA8C4ho/VtQkbrFwjnz8/innPeKoyM1xJGRmwJI2O2gpFDgTWMFIuEkWqRMDLwvMQY+8m4VP61A4dgKhgL5/29xDhPJ+Oc1wojLzESRl5iJIxsjkkYA0YFI5tkEkbmRgkjc6OEkY0yCSMbZQpGTqLUMFIxEkYq5iXG8xvP815jpGIkjAGjgpGKkTBSMRJGKuYVxjjXPMdc2f3mJFANIxWjYOS8Tg0jFSNhpGIkjFSMhDFgVDBSMRJGKkbCSMVIGKkYCSMVo2DktEcNIxUjYaRiJIxUjIQxYFQwUjESRipGwkjFSBipGAkjFaNg5JhFDSMVI2GkYiSMVIyEMWBUMFIxEkYqRsJIxUgYqRgJIxWjYFyoGAkjFSNhpGIkjFSMhDFgVDBSMRJGKkbCSMVIGKkYCSMVo2DkJF8NIxUjYaRiFIx8muhLjM8+v3EnBl9i3NLJuE8VRsZvCSPjt4SR8VvCyPgtYNz5iGANI+O3hJG5UcLI3ChhDBgVjLyJIGGkYiSMVIyEkYp56aPe8nQwfmzxVBipGAUjHxGsYaRiJIxUjISRipEwBowKRipGwkjFSBipGAkjFfMa4+eZCF/XfDJSMQpGPiJYw0jFSBipGAkjFSNhDBjvn1608xHBGkYqRsJIxUgYqRgJIxWjYOQjgjWMVIyEkYqRMFIxEsaAUcFIxUgYqRgJIxUjYaRiJIxUjIKRjwjWMFIxEkYqRsJIxUgYA0YFIxUjYaRiJIxUjISRipEwUjEKRj4iWMNIxUgYqRgJIxUjYQwYFYxUjISRipEwUjESRipGwkjFKBj5iGANIxUjYaRiJIxUjIQxYFQwMn5LGBm/JYyM3xJGxm8F48b4LWFk4HmBMX9s4fx4cP5YUYUxYFQwsm0rYWRulDAyN0oYmRsljMyNCsbC3ChhZNtWwsi2rYSRipEwBowKRirmJcb9+MbzlEqFkYqRMFIxEkYqRsJIxSgYdypGwkjFvMRYpnPg2ecKIxUjYaRiJIwBo4KRipEwUjESRipGwkjFSBipGAFjmjjnW+RIx2gcCRmNIyWjcQwcJY60jMaRmNE4UjMaR3JG40jPSBw58VvkSM9oHOkZjSM9o3EMHCWO9IzGkZ7RONIzGkd6RuNIz0gcOftb5EjPaBzpGY0jPaNxDBwljvSMxpGe0TjSMxpHekbjSM9IHDkFXORIz2gc6RmNIz2jcQwcJY70jMaRntE4Mj++4li2fDiW/cmDU444LjBHqaBzWHMLdCbTBuiMsQ3QmXkboAfofnSm6QbojN4N0HnfoQE6b1I0QKdI9ejbiZdLDZ2Dt1ugU6QN0CnSBugUaQP0AN2PTpHq0df5RN9yDZ0ibYBOkTZAp0gboFOkfnQOUW+BTpE2QKdIG6BTpA3QA3Q/OkXaAJ0ibYBOkTZAp0gboFOkfvSNIm2ATpE2QKdIG6BTpA3QA3Q/OkXaAJ0ibYBOkTZAp0gboFOkfvRCkTZAp0gboFOkDdAp0gboAbofnSJtgE6RNkCnSBugU6QN0ClSP/pOkTZAp0gboFOkDdAp0gbozOlq9L0cj93LWiNnSreTM6PbyZnQzeRpYj63kzOd28mZze3kTOZ28oDcTc77RHZy6tNOTn3ayalPOzn16SZP1KednPq0k1OfdnLqU/6+0DSl4wKnFDX0AN2PToE2QKdBG6BToQ3Q6dAG6JSoHz3Tog3QqdEG6PRoA3SKtAF6gC5HT+VEn1MNnSJtgE6RNkCnSBugU6QN0ClSP/pMkf6hI2MdnSL1z+kzRdoAnSJtgB6g+9Ep0gboFGkDdIq0ATpF2gCdIvWjB0XaAJ0ibYBOkTZAp0gboAfofnSKtAE6RdoAnSJtgE6RNkCnSP3oC0XaAJ0ibYBOkTZAp0gboAfofnSKtAE6RdoAnSJtgE6RNkCnSP3oK0XaAJ0ibYBOkTZAp0gboAfofnSKtAE6RdoAnSJtgE6RNkCnSP3oG0XaAJ0ibYBOkTZAp0gboAfofnSKtAE6RdoAnTldjV5Ou5L2CnlhSpeTz8c3LstWI2dGt5MzodvJmVrs5MwsdnL20O3k7KDbyZnL3eQ7c7mdnLncTs5cbidn39xOHpC7yalPOzn1aSenPuXk5yJKqe2X79SnnZz6NJPnifq0k1OfdnLq005OfdrJA3I3OfVpJ6c+7eTUp52c+rSTU59u8kR92smpTzs59Wknpz7t5AG5m5z6tJNTn3Zy6tNOTn3ayalPN3mmPu3k1KednPq0k1OfdvKA3E1OfdrJqU87OfVpJ6c+7eTUp5t8pj7t5NSnnZz6tJNTn3bygNxNTn3ayalPOzn1aSenPt3kQQrZyUkhOzkpZCcnhezkAbmbfNQh8eOhx+eMz9uWajSjDnPPaZZRJ4C5THHQlJRrNKO+Ur9AM+or6gs0o77yvUAz6mbdCzSjbqq9QDPsXPOcZti55jnNqP+U4TnNOuo+2ws0TMMPaZiGH9IwDT+kCWge0TANP6RhGn5IwzT8kIZp+CEN0/AjmmGPLX+Bhmn4IQ3T8EMapuGHNAHNI5php+Ftnz5pnh2p/NGax5o/7kE1x2FHZ7HjuO+max3Hfetd6zjsBK91HPb8c7XjsG0gdhw2JMSOw1aH2DFwlDjSMxpHekbjSM9oHOkZjSM9I3Ec9tx4tSM9o3GkZzSO9IzGMXCUONIzGkd6RuNIz2gc6RmNIz2jcJyHPYlc7UjPaBzpGY0jPfOK47yXY82RU80xcJQ40jMvOW7x6Vj9vWZ+fMVxjeODXj7+51xzZH6UOA57lrDakflR48j8+JJjOVaRti9X+MWR+VHjGDhKHJkfNY7sh7/k+NnXW6r1zLAHh/4+x7J+rrmsFcdhz0n8XY45TcfnCuaUoubI67XGkddrjSOv1xpHXq81jrx/rXFk/1HjyPwocRz2PD+1I/uPGkd6RuNIz2gcA0eJIz2jcaRnNI70jMaRntE40jMSx2EP5VM70jMaR3pG40jPaBwDR4kjPaNxpGc0jvSMxpGe0TjSMxLHhZ7RONIzGkd65iXHJU7HZak50jMax8BR4kjPaBzpGY0jPaNxpGc0jvSMxHHcw1zFjvSMxpGe0TjSMxrHwFHiSM9oHJkfJX/vOu6JplrHcY8/FTsyP77099fnKj7WXNsPH/dgVbEj86PGMXCUODI/ahzZD9c4sh+ucaRnNI70jMSR811FjvSMxpGe0TjSMxrHwFHiSM9oHOkZjSM9o3GkZzSO9IzEkfNdRY70jMaRntE40jMax8BR4kjPaBzpGY0jPaNxpGc0jvSMwjE43/U1xyfnVATnu4oc6RmNIz2jcQwcJY70jMaRntE40jMaR3pG40jPSBw5b1jkSM9oHOkZjSM9o3EMHCWO9IzGkZ7RODI/vuK4nJ8HkJZtefKd47zAOea5gp4ZNhugM5k2QGeMbYDOzNsAPUD3ozNNN0Bn9G6AzvsODdB5k6IBOkXqR+e48xboFGkDdIq0ATojoxq9nHYl7TVyBkY3OWdxysn3ko8VV9++4NhOPzk3FjV5ms7jxdJUO14sOH6xBTol6kfnYMcW6JRoA3RKtAE6M3oD9ADdj857ow3Q2ehqgE6RNkCnSBugU6R69PV8cEq1Ny84mrMFOkXaAJ0ibYBOkTZAD9D96BRpA3SKtAE6RdoAnSJtgE6R+tE57LcFOkXaAJ0ibYBOkTZAD9D96BRpA3SKtAE6RdoAnSJtgE6R+tE5rlmPntP54JyWGjpF2gCdIm2ATpE2QA/Q/egUaQN0irQBOkXaAJ0ibYBOkfrROXC7BTpF2gCdIm2ATpE2QA/Q/egUaQN0irQBOkXaAJ0ibYBOkdrRF45Mb4FOkTZAp0gboFOkDdADdD86RdoAnZFRjx6f6FEq6JxK3QKdF1I9+jqf6FuuofNC2gCdF9IG6GztNkBna7cBOlu7DdCZ0/3oHOjdAp2t3QbobO02QKdIG6AH6H50irQBOkXaAJ0ivYd+OBKZLzmW/VjzOlWfj3SjxJGTtEWO1J3GkWDTONJgGsfAUeJIKWkciR+NIz2jcaRnNI70jMQx6BmNIz2jcaRnNI70jMYxcJQ40jMaR3pG40jPaBzpGY0jPSNxXOgZjSM9o3GkZzSO9IzGMXCUONIzGkd6RuNIz2gc6ZlXHNfIp2PMNUd6RuK40jMaR3pG40jPaBzpGY1j4ChxpGc0jvSMxpGe0TjSMxpHekbiuNEzGkfm8BccPziOvy/8+J+1vy/cmMM1joGjxJE5XOPIHK5xZA7XODKHaxyZwyWOhTlc48j7ChpHekbjSM9oHANHiSM9o3GkZzSO9IzGkZ7RONIzEkfOgxc50jMaR3pG40jPaBwDR4kjPaNxZA7/jeNBw2j9kIZp+QHNyvHTj2mYaR/SBDTuEyhXDrhtgc4GagN0prwG6MyPDdCZTP3onJ/dAp1pugE628kN0Nl7boAeoMvRtxMvlyo6RdoAnSJtgE6RNkCnSBugU6R+dE6K/wPQn5y1unJSfAt0irQBOkXaAD1A96NTpA3QKdIG6BRpA3SKtAE6RepH58D6FugUaQN0irQBOkXaAD1A96NTpA3QKdIG6BRpA3SKtAE6RepHD4q0ATpF2gCdIm2ATpE2QA/Q/egUaQN0irQBOkXaAJ0ibYBOkfrRF4q0ATpF2gCdIm2ATpE2QA/Q/egUaQN0irQBOkXaAJ0i9aOvzOlq9L0cp7vuZa2RM6XbyZnR7eQBuZuc+dxOznRuJ2c2t5MzmdvJeafITb7xPpGdnPq0k1OfdnLq004ekLvJqU87OfVpJ6c+7eTUp/x9oWlKx4OnFDV0+tOPXijQBug0aAN0KrQBOh3aAD1A96PTog3QqdEG6PRoA3SKtAE6RapHT+VEn1MFfadIG6BTpA3QKdIG6BRpA/QA3Y9Okf6hI2MdnSL1z+k7RdoAnSJtgE6R2tG3iSJtgE6RNkCnSBugU6QN0AN0PzpF2gCdIm2ATpE2QKdIG6BTpH70RJE2QKdIG6BTpA3QKdIG6AG6H50ibYBOkTZAp0gboFOkDdApUj96pkgboFOkDdAp0gboFGkD9ADdj06RNkCnSBugU6QN0CnSBugUqR99pkgboFOkDdAp0gboFGkD9ADdj06RNkCnSBugU6QN0CnSBugUqR89KNIG6BRpA/QAXYxeTruS9ho5U7qcfD5WXJatRs6MbidnQneTL0wtdnJmFjs5e+h2cnbQ7eQBuZucudxOzlxuJ2cut5Ozb24nZ9fcTb5Sn3Zy6tNOTn3Kyc9FlFLbL1+pTzt5QO4mpz7t5NSnnZz6tJNTn3Zy6tNNvlGfdnLq005OfdrJqU87eUDuJqc+7eTUp52c+rSTU592curTTV6oTzs59Wknpz7t5NSnnTwgd5NTn3Zy6tNOTn3ayalPOzn16SbfqU87OfVpJ6c+7eTUp508IHeTU592curTTk592smpTzs59WkmLxP1aSenPu3k1KednPq0k5NCdnJSyE5OCtnJSSE7OSnkJk+KIXFO5bjSeX1Gviz7jwcv2+d3zh8Xcixp7m9J0d+Slv6WtPa3pM2+pP34+Pp1WqtLKv0tae9uSXnqb0mpvyXl/pbkv3uXfNwESqkuKfpb0tLfktb+lrT1t6TS35L27pY0T/0tKfW3pNzfkvq7e8/93b3n/u7ec39377m/u/fc39177u/uHf3dvaO/u3f0d/eO/u7e0d/dO/q7e0d/d+/o7+4d/d29o7+799Lf3Xvp7+699Hf3Xvq7ey/93b2X/u7eS39376W/u/fS39176e/uvfZ39177u3vXP+x9n453Z9O0L9IV7bEf77nuy/L5Bu0v7/wea1o6XNPa4Zq2DtdUOlzT3t+a6h9Z3HhNqcM15Q7XNHe4pg7v41uH9/Gtw/v41uF9fOvwPr51eB8vHd7HS4f38dLhfbx0eB8vHd7HS4f38eK+Fzz9B3L71N2K3M/vp7W5R3crWrpb0drdirbuViSYTvL+ZUXpyYrSUs5/Kb5O+fN7p+1c097dmvZp6nBNqcM15Q7XNHe4puhwTYt7TWvezzXFVl3T2uGatg7XVDpc097fmtLU4ZpSh2v6Y+/jx0+ZLT8lLD9lsfyU1fJTNstPKZafsjt+Sp4sPyVZforldz9bfvez5Xc/W373s+V3P1t+97Pldz9bfvdnxX7Vup0/5cujr+7q7XPqcE25wzXNHa4pOlzT0uGaBPfDyMdPifjyU+pr2s594m1/NmOftZ2//E3qLwP2tUvdxrnUMs6l7sNcakzjXGoa51LzOJc6j3OpMc6lLuNc6jjTUowzLcU401KMMy0t40xLyzjT0mKfls6tq7JuTx67TJ8foiRo82Ue6FpjoGtdBrrWdaBr3Qa61jLQte7jXOs6DXStaaBrHWhuWgeamxR/Mf021zrQ3LQONDetA81Nir9Ij/MPEmLZ4smaUqzz8b1j+7XMsaa9vzUp/tL6961p2Y9HpzWeni+wT+ejP2bhX/2XvvS8UPwV91tdbwx2vctg17sOdr3bYNdbBrvefazrVXySwFtdbxrsegebr8pg85Xikxve6noHm6/KYPNVGWy+2gX353U6KjvW7dneRZ6W49E5lSS4gvntryDe/gqWt7+C9e2vYHv7KyhvfwX7e19BnhSfndL4CtLbX8GbvyZ/XMGbvyZ/XMGbvyZ/XMGbvyZ/XMGbvyZ/XMGbvybnSfGpH7/rRO1cpuNz4XOJz3qq/0veHPPxtmmOp5+w1uqfE38wBowKxgVGBeMKo4Jxg1HBWGBUMO4wChgVHw4F46T49CsYJ8XHe8E4ZSpGwhgwKhipGAkjFSNhpGIkjFSMhPFbVUyrv//I0/ytMqah47fqmIaO3ypkGjp+q5Jp6Bg4Shy/Vcs0dPxWMdPQ8VvVTEPHb5UzDR3pGYlj0DMaR3pG40jPaBzpGY1j4Chx7Ltn5mk7LndOX/7+q/69n37+ycf19t0d+uvtex77ndfb8m8H87T0PZO9l2Xfc9l7WfY9m72XZd/z2XtZBpYyy281pzW2/FYzYGPLvvef38uy7z3o97Kke2SWK92js6R7dJZ0j86S7tFZBpYyy85fx9N6bN3PebZ/WsHW+StzY53OX2sb63T+6tlYp/PXw8Y6nb/CNdbpfK+usU7nu2+NdTrfT2us0/kOWWMdZuWf6BRm5Z/pMCv/TIdZ+Wc6zMo/0wl0fqLjn3e26biCvTz9C+41HSvZ13V5cr3zdi4kff47zrn60PXcVpu3L4uuPnidj8eu8/z1oQdiAfE+4g7ibcR9AvE+YgLxPmIG8T7iDOJ9xADxPuIC4n3EFcT7iBSLAJFiESBSLC8grsf3XUv8FjFNFIsAkWIRIFIsAkSKRYAYIN5HpFgEiBSLAJFiESBSLAJEiuU+YqJYBIgUiwCRYhEgUiwCxADxPiLFIkCkWASIFIsAkWIRIFIs9xEzxSJApFgEiBSLAJFiESAGiPcRKRYBIsUiQKRYBIgUiwCRYrmPOFMsAkSKRYBIsQgQKRYBYoB4H5FiESBSLAJEikWASLEIECmW+4hBsQgQKRYBIsUiQKRYBIgB4n1EikWASLEIECkWASLFIkCkWO4jLhSLAJFiESBSLAJEiuXfIx4ygcwDGdrikQzB8EiGCngkw2j/SIZ5/YHMyhD+SIbJ+pEM4/IjGWbgRzKBzAMZZuBHMszAj2SYgR/JMAM/kmEGfiCzMQM/kmEGfiTDDPxIhhn4kUwg80CGGfiRDDPwI5lR55lt/pSJyrkAqYw6zzyXGfS1KfL5jSP/+iyJ3/Xgg3HQFzI146CvemrGQV8i1YyD7impGQfdgFIzDjrdiRlHPY9VzTjoPpiacdBNMzUjFSNhDBgVjFSMhJGKkTBSMRJGKkbCSMUIGPOoZ7SqGakYCSMVI2GkYiSMAaOCkYqRMFIxEkYqRsJIxUgYqZjnjDmX4x+f5HnKFcZRz21VM1IxrzCu6ZOx9ks96omZv49xyeVY85L3GiNzo4SRuVHCyNwoYWRulDAyNyoYRz09U83I3ChhZPdbwsjut4QxYFQwUjESRipGwkjFSBgZvxWMox4FqWZk/JYwBozPGct2volQ9icPnmM6VjFH9f2vUc/sa2rOKOU3Z+7ym7PV7DdnMLabj3o8YVNzRm6/OdvjfnP20v3mgbndnA71m9OhfnM61G4+6jlyf5x5ScuPx5ZU28kd9dC5huLstYjF9/Mf6//q8j7F2Wkxi496Ns8fJ56mKZ14KWrm9KffPDC3m9OffnP6029Of/rNmc395kzndvNRz5pqas7elt+cDvWb06F+88Bcbb7GgZdS7b2KUU8La2pOh/rN6VC/OR3qN6dD7eajnhHY1JwO9ZvToX5zOtRvHpjbzelQvzkd6jenQ/3mdKjfnA61m3NAaQNzOtRvTof6zelQv3lgbjenQ9XmOZ3mOS01czrUb06H+s3pUL85Heo2nzlitoE5Heo3p0P95nSo3zwwt5vToX5zOtRvTof6zelQvzkdajfnkOAG5nSo35wO9ZvToX7zwNxuTof6zelQvzkd6jenQ/3mdKjdnEPHG5gH5mrz+DSPUjNnVvSb8xoqN1/n03zLNXNeQ+3mnBzcwJy9XL85e7l+c/Zy/eaBud2c+dxvzl6u35y9XL85Heo3p0Pt5py93cCcDvWb06F+czrUbx6Y283pUL85Heo3p0NvmR+MpKWEkVpUMC4EoISRppMwkmkSRspLwhgwKhjpIwkjySNhpGIkjFSMhJGKUTCuVIyEkYqRMFIxEkYGnhcY92U717ymGiMDj4Jx4yXmFcbyuebqL/XGS4yEkZcYCSMbZRLGgFHByEaZhJG5UcLI3ChhZKNMwshGmYKRs901jFTMc8bt+KyHrfaJJpy+fp+QerlNGBDeJaRabhNSLLcJqZXbhJTKbUIq5S4hp37fJ6RObhNSJ7cJqZPbhIzWtwkZrW8TMlrfJmS0vk3IaH2TMDjI+AXC+fOzuOectxoj47WEkRFbwsiYLWEMGBWMFIuEkWpRMHJi5kuMsZ+My1xjZOCRMPIS8wLjPJ2Mc15rjLzESBh5iZEwsjkmYWSDTMLIJpmCkRPuNIzMjRJGNsokjGyUSRgDRgUjFSNhpGJeYTy/8TzvVUYqRsJIxUgYqRgFI2eMahipmBcYP96yOhhjru1+cxKohpGKkTAGjApGKkbCSMVIGKkYCSMVI2GkYhSMnFCpYaRiJIxUjISRipEwBowKRipGwkjFSBipGAkjFSNhpGIUjByzqGGkYiSMVIyEkYqRMAaMCkYqRsJIxUgYqRgJIxUjYaRiFIwcs6hhpGIkjFSMhJGKkTAGjApGKkbCSMVIGKkYCSMVI2GkYhSMnOSrYaRiJIxUjISRipEwBowKRipGwkjFCBgXPk30FcZnn9+4TMTgK4xbOhn3qcLIh7JqGBm/JYyM3xJGxm8JY8CoYGT8ljAyN0oYmRsljLyJIGHkTQQFIx8RrGGkYiSMVMwrH/WWjzV//M+lxkjFSBgDRgUjFSNhpGIkjFSMhJGKkTBSMQpGPiJYw0jFSBipmJcYP89E+MXgt4xUjIQxYFQwUjESRipGwkjFSBipGMHpRQsfESxh5COCNYxUjISRipEwUjESxoBRwUjFSBipGAkjFSNhpGIkjFSMgpGPCNYwUjESRipGwkjFSBgDRgUjFSNhpGIkjFSMhJGKkTBSMQpGPiJYw0jFSBipGAkjFSNhDBgVjFSMhJGKkTBSMRJGKkbCSMUoGPmIYA0jFSNhpGIkjFSMhDFgVDBSMRJGKkbCSMVIGKkYBWNh/JYwMn5LGBm/JYyM3xLGgFHByMDznDHvy3aueU01RgYeCSPbtgrGnblRwsjcKGFkbpQwMjdKGANGBSPbthJGtm0ljFSMhJGKkTBSMa8w7sc3nqdUfsu4TlSMhJGKkTBSMRJGKkbCGDAqGKmYVxjL55r3ucZIxUgYqRgJIxUjYaRiFIwc861hpGIkjFSMhJGKkTAGjApGKkbCSMVIGKkYCSMVI2GkYhSMHPOtYaRiJIxUjISRipEwBowKRipGwkjFSBipGAkjFSNhpGIUjBzzrWGkYiSMVIyEkYqRMAaMCkYqRsJIxUgYqRgJIxUjYaRiFIwc861hpGIkjFSMhJGKkTAGjApGKkbCSMVIGKkYCSMVI2GkYhSMHPOtYWRufIGxbPlYc9mfPDjliAMvR+2vhjmFuYE5E6nfnPHVb86s6zdnMPabM0XbzTmTuoE57zL4zXlLwm9Oh8rNt+U0L1XzwNxuTof6zelQvzkd6jenQ/3mdKjcfJ1P8y1XzDlVvIE5Heo3p0P95nSo3zwwt5vToX5zOtRvTof6zelQvzkdajcvdKjfnA71m9OhfnM61G8emNvN6VC/OR3qN6dD/eZ0qN+cDrWb73So35wO9ZvToX5zOtRvHpjbzelQvzkd6jenQ/3mdKjfnA51m28THeo3p0P95nSo35wO9ZsH5nZzOtRvTof6zelQu3liPheb7+V47K8u71Oc6dwtzmzuFmcyd4sH4mZxpnK3ODO5W5yJ3C3O+0Jucd4VMotnmtMtTnO6xWlOtzjN6RYPxM3iNKdbnOZ0i9Oc6neBpimdeClq5lSn35zutJvPlKffnPb0m1OffnP6028emNvNaVC/ORXqN6dD/eZ0qNw8lRNvTjVzOtRuHnSo35wO9ZvToX5zOtRvHpj/gbNi3ZwOtc/nQYf6zelQvzkd6jenQ+3mCx3qN6dD/eZ0qN+cDvWbB+Z2czrUb06H+s3pUL85Heo3p0Pt5isd6jenQ/3mdKjfnA71mwfmdnM61G9Oh/rN6VC/OR3qN6dD7eYbHeo3p0P95nSo35wO9ZsH5nZzOtRvTof6zelQvzkd6jenQ+3mhQ71m9OhfnM61G9Oh/rNA3O7OR3qN6dD/eZ0qN+cDvWb06F2850O9Zszn4vNS1p+PLakvSYeiIvF5+Mbl2WriTObu8WZzN3izCte8TIxrbjF2TN3i7Nj7hZnHneLB+JmceZxtzjzuFucfXK3OLvkbnGa0yyeaE63OM2pFj8XUcpeE6c53eI0p1s8EDeL05xucZrTLU5zusVpTrc4zWkWzzSnW5zmdIvTnG5xmtMtHoibxWlOtzjN6RanOd3iNKdbnOY0i880p1uc5nSL05xucZrTLR6Im8VpTrc4zekWpznd4jSnW5zmNIsHzekWpznd4jSnW5zmdIsH4mZxmtMtTnO6xWlOtzjN6RanOc3iC83pFqc53eI0p1s8EDeLU0BucQrILU4BucUpILP4Ouh0+PHQ43PC521LNZlBp7gXZAZ97Z/LFIdM+WWhv5UZ9DX6BZlBX0tfkBn0Ne8FmUF3557LbIPuor0gM+o881xm1Hnmucyg/2LhBZlA5oEMM/AjGWbgRzLMwI9kmIEfyTADP5AZ9Qz3F2SYgR/JMAM/kmEGfiQTyDyQGXUG3vbpU+bZgaR5nQ+PvFUZRx2YxYyjTtdixlFHcTHjqHO7lnHUA7LVjMO+y69lHPafBGgZR20NMWPAqGCkYiSMVIyEkYqRMFIxEkYqRsC4T1SMhJGKkTBSMRJGKkbCGDAqGKkYCSMVI2GkYiSMVIyEkYpRMI56FLuakYqRMFIxEkYq5gXGeS+HR+RUYwwYFYxUzCuMW3wyVn+pmRtfYFzj+BiFj/851xiZGxWMox6nrGZkbpQwMje+wlhOj+3LFX5hZG6UMAaMCkbmRgkju9+vMH429ZZqFTPq6am/j7GsxzdO5euaT8ZRj4v8XYw5TcendeWUosbIK7WEkVdqCSOv1BJGXqkljLxPLWFkv1HCyNyoYBz1WEM1I/uNEkYqRsJIxUgYA0YFIxUjYaRiJIxUjISRipEwUjEKxlEPylMzUjESRipGwkjFSBgDRgUjFSNhpGIkjFSMhJGKkTBSMQrGlYqRMFIxEkYq5hXGJU7GZakxUjESxoBRwUjFSBipGAkjFSNhpGIkjFSMgnHY41bFjFSMhJGKkTBSMRLGgFHBSMVIGJkbFX/BOuypo1rGYY8oFTMyN77y99TnKlKJ2u73sIefihmZGyWMAaOCkblRwsjut4SR3W8JIxUjYaRiFIycwaphpGIkjFSMhJGKkTAGjApGKkbCSMVIGKkYCSMVI2GkYu4zzhNnsGoYqRgJIxUjYaRiJIwBo4KRipEwUjESRipGwkjFSBipGAUjZ7AKjpb4YKRiJIxUjISRipEwBowKRipGwkjFSBipGAkjFSNhpGIUjJwIrGGkYiSMVIyEkYqRMAaMCkYqRsJIxUgYmRtfYFzOv+5Py7Y8+c4xHauYY54r5jNDpt+cidRvzvjqN2fW9ZsH5nZzpmi/OSO335x3GfzmvCXhN6dD7eYcR97AnA71m9OhfnNmRbF5ScuPx5a018SZFM3inJmpFt9LPlZcfbeC4zXt4txVxOJpOg8DS1Oq/SkFByU2MKc/7eYcwdjAnP70m9OffnNmc795YG43531Qvzl7W35zOtRvTof6zelQufl6Pjil2nsVHKLZwJwO9ZvToX5zOtRvHpjbzelQvzkd6jenQ/3mdKjfnA61m3MobwNzOtRvTof6zelQv3lgbjenQ/3mdKjfnA71m9OhfnM61G7Oscpy85zOB+e01MzpUL85Heo3p0P95oG53ZwO9ZvToX5zOtRvTof6zelQt3niYOwG5nSo35wO9ZvToX7zwNxuTof6zelQvzkd6jenQ/3mdKjdnKPNG5jToX5zOtRvTof6zQNzuzkd6jdnVpSbx6d5lIo5B0g3MOc1VG6+zqf5lmvmvIb6zXkN9Zuzl+s3Zy/Xb85ert+c+dxuztnbDczZy/Wbs5frN6dD/eaBud2cDvWb06F+czr0lvnBSFq+wlj2w2Odqs9GalHByKHXGkaaTsJIpkkYKS8JY8CoYKSPJIwkj4SRipEwUjESRipGwbhQMRJGKkbCSMVIGKkYCWPAqGCkYiSMVIyEkYqRMFIxEkYqRsG4UjESRipGwkjFSBipGAljwKhgpGIkjFSMhJGKkTBSMS8wrpFPxphrjFSMgnGjYiSMVIyEkYqRMFIxEsaAUcFIxUgYqRgJIxUjYaRiJIxUjIKxUDESRsbv54w5nX8z+PE/a38zWBi/JYwBo4KR8VvCyPgtYWT8ljAyfksYGb8VjDvjt4SRNxEkjFSMhJGKkTAGjApGKkbCSMVIGKkYCSMVI2GkYgSMmRPbNYxUjISRipEwUjESxoBRwUjFSBgZv/894yHDRP1IhiH5gQwnRD+UYZR9JBPImE+KzJxC28Cc/VK/OdOd35y50W/ORGo354TrBuZM0X5zdo/95mw1+80Dc7X5tpzmpWpOh/rN6VC/OR3qN6dD/eZ0qN2ck9ztJ6JmTnJvYE6H+s3pUL95YG43p0P95nSo35wO9ZvToX5zOtRuzoHyDczpUL85Heo3p0P95oG53ZwO9ZvToX5zOtRvTof6zelQu/lCh/rN6VC/OR3qN6dD/eaBud2cDvWb06F+czrUb06H+s3pULv5Sof6zelQvzkd6jenQ/3mgbndnA71m9OhfnM61G9Oh9rNN+ZzsflejoNYf3V5n+JM525xZnO3eCBuFmcud4szlbvFmcnd4kzkbnHeFzKLF94VcovTnG5xmtMtTnO6xQNxszjN6RanOd3iNKdbnOZUvws0TenES1Ezpzrt5jvd6TenPP3mtKffnPr0mwfmdnMK1G9Og/rNqVC/OR3qN6dD5eapnHhz+q35PNGhfnM61G9Oh/rN6VC/eWBuN6dD/8hZsW5Oh7rn83miQ/3mdKjfnA61myc61G9Oh/rN6VC/OR3qNw/M7eZ0qN+cDvWb06F+czrUb06H2s0zHeo3p0P95nSo35wO9ZsH5nZzOtRvTof6zelQvzkd6jenQ+3mMx3qN6dD/eZ0qN+cDvWbB+Z2czrUb06H+s3pUL85Heo3p0Pt5kGH+s3pUL85Heo3p0P95oG53ZwO9ZvToX5zOtRvTof6zelQu/lCh/rN6VC/eWCuNS9p+fHYkvaaONO5Wnw+VlyWrSbObO4WZzI3i6/MK25xphW3OHvmbnF2zN3igbhZnHncLc487hZnHneLs0/uFmeX3Cy+0ZxucZrTLU5zqsXPRZRS2x/faE63eCBuFqc53eI0p1uc5nSL05xucZrTLF5oTrc4zekWpznd4jSnWzwQN4vTnG5xmtMtTnO6xWlOtzjNaRbfaU63OM3pFqc53eI0p1s8EDeL05xucZrTLU5zusVpTrc4zekVj4nmdIvTnG5xmtMtTnO6xQNxszjN6RanOd3iNKdbnOZ0i9OcZvFEc7rFaU63OM3pFqc53eIUkFucAnKLU0BucQrILU4BmcWzYDqcUzkudF6fiS/L/uPBy5Y+BT+u41jR3N2KorsVLd2taO1uRZt7RfvxyfPrtFZXVLpb0d7biuapuxWl7laUu1uR/Z5d8vHbX0p1RdHdipbuVrR2t6KtuxWV7la097aimLpbUepuRbm7FXV3z47u7tnR3T07urtnR3f37Ojunh3d3bOX7u7ZS3f37KW7e/bS3T176e6evXR3z166u2cv3d2zl+7u2Ut39+y1u3v22t09e+3unr12d89eu7tnr93ds9fu7tlrd/fstbt79trdPXvr7p69dXfPrn8a+3oe5Ltt2gXtsR9voO7L8vlu6y9v4x5LWvpb0trfkrb+llT6W9Le3ZLqnyncdkmpvyXl/pY097ek/u7epb+7d+nv7l36u3uX/u7epb+7997f3Xvv7+6993f33vu7e+/93b33/u7ee393772/u/fe39177+7uvUzd3b2Xqbu79zKZbwLP/jnpMq29Lcj81H62jbOkqbcFpd4WlHtb0NzbgqK3BS29Lej+fSjvXxaUniwozcd3TvHlD0jOvyBZ0tbbgkpvC9o7W1CeeltQ6m1BubcFzeYFbcd9KO1TdUHR24KW3ha09ragrbcFld4WtHe2oNl8p85p/vHgPKfqglJvC8q9LWjubUHR24KW3ha09ragP/ROffyQ4vghu+GHxOT4IcnxQ7Ljh8yOHxKOH7I4fsjq+CGO3/hw/MaH4zd+cfzGL47f+MXxG784fuMXx2/84viNXxy/8YvjN34RvCW3bucP+fIvQ+uTzXYsKE/Vnln2vtazTp2tJ3W2ntzZeubO1hOdref+7THy8d5sxJf3Zh+s53yXctvT1bVfeoN4XYe50m2YKy3DXOk+ypVu0zBXmoa50jzMlc7DXGkMc6XDzEjbMDPSNsyMtA0zI23DzEhlmBmpDDMjlWFmpDLMjCT4U8d3uVL3jHTuZJd1e/LYZfr8NNpn+2WvXOo6zqVu41xqGedS92EudZ/GudQ0zqXmcS51HudSY5xLHWda2seZlvZxpqV9nGlpH2ZaWqdhpqVV8Bfscf7lZXy8GfJkSSnW459wp9h+DXMsKfe3pMW8pI/R7ljSGs/+9DXt0+dfwyzlV/+Zrz0p1rEudxvrcstYl7sPdbmCD5N4q8tNY11uHuty57EuN8a63LGmqjTWVJXGmqrSWFNVGmuqymNNVYKPBFmnI6pj3Z5tVORpOf+wO5UkuID13S9ge/cLKO9+AfubX4DgI1AaX0B69wvI734B87tfQLz7Bbz7K/H87q/E87u/Es/v/ko8v/srcbz7K7Hgk1y2ZT0uoKSnQbPk41unZX32z3JznB8CmePpB8U2+7fBq+CjalBcBZ/Fg+Iq+LAhFFfBpymhuAo+LgrFVfB5WCiugg/8QnEVfKIZiqvgI9tQXBfaRaFIuygUaReFIu0iUFxpF4Ui7aJQpF0UirSLQjFQFCjSLgrF79Qu7f7Ibf1O8dKQ8TvVS0PG75Qv7Ri379QvDRm/U8A0ZPxOBdOQ8TslTEPGgFHB+J0ipiEjFSNhpGIkjFSMhJGKUTAWKkbCSMVIGLuumHnajkfP6cufuT743s8/1ql0XRv6y+16Dvudl9v2D6RL17PYe1F2PY+9F2XXM9lbUe5dz2XvRdn1bPZelN9pPmtM+Z1mv8aUAaWKsusd5/eipHZklNSOjJLakVFSOyLKbaJ2ZJTUjoyy71fwtB779HOe3R/Jsk19vyY3xun7VbYxTt+vm21xUt+vhI1x+n5ta4zT995cY5y+d9sa4wQ4j3H63hFrjMOE/BMcJuSf4DAh/wSHCfkxTmZC/gkOE/JPcMKNU85/Erem9AQn0n5+xG6Oz+2rdak8eF2Pra6Pm8XnMvJe+8bL8uOxy5dF/PLYw2XBpeqy4lJ12XCpuhRcqi47LjWXecKl6pJwqbrkIV2WtB0uX98xrD42pfn4rJyUviwilXMKnGcUBYqBokBxzMlbrTjmnK5WHHOqVyuO2QBqRXcxrPOx/rR9+ePFBx+ct55Xu6/r8mRjat7OhaTPP6et74+t5793+uVfAvz8wet8PHad568P/WEYE4a3DROGtw0zhrcNZwxvGwaGtw0XDG8brhjeNtwwvG1YMLxtSKfcNlzolPuGdMpzw/X4vmuJmiGdct+QTrlvGBjeNqRT7hvSKfcN6ZT7hnTKfUM65bbhSqfcN6RT7hvSKfcN6ZT7hoHhbUM65b4hnXLfkE65b0in3DekU24bbnTKfUM65b4hnXLfkE65bxgY3jakU+4b0in3DemU+4Z0yn1DOuW2YaFT7hvSKfcN6ZT7hnTKfcPA8LYhnXLfkE65b0in3DekU+4b0im3DXc65b4hnXLfkE65b0in3DcMDG8b0in3DemU+4Z0yn1DOuW+IZ1y17BMdMp9QzrlviGdct+QTrlvGBj+2vCAIT4ewFAUD2DIhAcwzP4PYBjo6zCJKf0BDKP3Axjm6QcwDMkPYAKYOgyT7wMYJt8HMEy+D2CYfB/AMPnWYTKT7wMYJt8HMEy+D2CYfB/ABDB1GCbfBzBMvg9gmHzrMPOgc8w2f8LEXIMZdI55DjPmq1Lk8xtH/vWxBb/rwYfimC9hasUxX+/UimO+OKoVx9xDUiuOueEkVhz0tFS14pgjoFpxzH0vteKYm2RqxUBRoEi7KBRpF4Ui7aJQpF0UirSLQHHQE1TVirSLQpF2USjSLgrFQFGgSLsoFGkXhSLtolCkXRSKtItAcdBTVX+XYs7l+BcmeZ5yTZF2USjSLi8orulTsfobzbz4XHHJ5VBc8l5TZF5UKDIvKhSZFxWKzIsCxUFPt1QrMi8qFJkXFYrsdSsUA0WBIu2iUKRdFIq0i0KRdhEoDnpWo1qRqVuhyNStUGTSea74UXiHYtmfPHiO6VjFHNW3ugY9WK8pOTOUnZyBy07OzrKbfNBDAZuSMz3byRm17eTshtvJA3I3OfVpJ6c+7eTUp52c+jST74Oe9/bHkZe0/HhsSXsNnBHRDM7+ihZ8P/8l/l7WCvighyQ1BOeWogVP02mXphQ18oDcTU512smpTjs51Wknpzrt5MzkbvJBD3BqSs57nnZytrPs5NSnnTwgd5NTn2ryNY4LTKn21sSgh3s1Jac+7eTUp52c+nSTD3rsXlNy6tNOTn3ayalPO3lA7ianPu3k1KednPq0k1OfdnLq003O8aB+curTTk592smpTzt5QO4mpz7t5NSnmDynkzynpUZOfdrJqU87OfXpJueAVz859Wknpz7t5NSnnTwgd5NTn3Zy6tNOTn3ayalPOzn16SbniF4/OfVpJ6c+7eTUp508IHeTU592curTTk592smpTzs59ekm58BvPzn1aSdnSFSTxyd5lBo5Q6KdnJdPNfk6n+RbrpBzcq+fnJdPOzmbt3ZyNm/t5AG5m5y53E7OXG4nZ/PWTs7mrZ2c+nSTc0y2n5z6tJNTn3Zy6tNOHpC7yalPOzn1aSenPu3k1Ocd8kORoLytGNNEIyoUyT6FIiWnUCTOFIqBokCRhFIoUkUKRUJHoUi7KBRpF4Fiol0UirSLQpF2USjSLgpFJp3nivtyPDh/rKimyKQjUMy8urygWKZTsfobnXl1USjy6qJQDBQFiuyMKRTZGVMoMi8qFJkXFYrsjAkUOa5doki7KBRpl6eK2/HRDdtSE6Rb7goGgjcF6ZW7grTKXUE65a4gjXJXkD65Kchh3rcF6ZK7gjTJXUGa5K5gIHhTkIn6riAT9V1BJuq7gkzUNwU5oPi2IBP1U8H582O055y3miJTtUKRyVqhGCgKFNn1VyjSKQpFWkWgyNmWryjGfioutX/TwHGVEkVeXZ4rztOpOOe1psiri0KRVxeFIrthCkV2xASKHF0nUWReVCgyLyoU2RlTKAaKAkXaRaFIuygUaZcXFM9vPM97VZF2USjSLgJFzg2VKNIuCkXa5bnix6bNoRhzba+bAzslioGiQJF2USjSLgpF2kWhSLsoFGkXgSKnTkoUaReFIu2iUKRdFIqBokCRdlEo0i4KRdpFoUi7KBRpl/uKidMQJYq0i0KRdlEo0i4KxUBRoEi7KBRpF4Ui7aJQpF0UirSLQJHTECWKtItCkXZRKNIuCsVAUaBIuygUaReFIu2iUKRdFIq0i0Ax0y4KRdpFoUi7KBRpF4VioChQpF0UirSLQpF2ESguTN33P38xrUzdLyhu6VTcp5oik45CMVAUKDLpKBSZdBSKTDoKRXZpFYrMiwJFPlFVosgurUKRXVqFIu2iUAwUBYq0ywuf1panQ/FjU6emSLsoFGkXhSLtolCkXQSKfKKqRJF2USjSLgpF2kWhGCgKFGmXVxQ/zzH4xeC3irSLQpF2USjSLgpF2kWgyCeqShRpl/tnDSU+UVWiSLsoFANFgSLtolCkXRSKtItCkXZRKNIu9xUzn6gqUaRdFIq0i0KRdlEoBooCRdpFoUi7KBRpF4Ui7aJQpF0EinyiqkSRdlEo0i4KRdpFoRgoChRpF4Ui7aJQpF0UirSLQpF2ESjyiaoSRdpFoUi7KBRpF4VioChQpF0UirSLQpF2USjSLgpF2kWgONMuCkXaRaHI1K1QDBQFikzdCkWmboUiU7dAMZh0nirmfTkenD9WVFNk0lEoskurUGReVCgGigJF5kWFIvOiQpF5UaHILq1CkV1ageJCuygUaReFIu3yguJ+fON5SqWmSLsoFANFgSLtolCkXRSKtItCkXZ5QbFM56SzzzVF2kWgyMnHEkXaRaFIuygUaReFYqAoUKRdFIq0i0KRdlEo0i4KRdpFoMgp3BJF2kWhSLsoFGkXhWKgKFCkXRSKtItCkXZRKNIuCkXaRaDIKdwSRdpFoUi7KBRpF4VioChQpF0UirSLQpF2USjSLgpF2kWgyCncEkXaRaFIuygUaReFYqAoUKRdFIq0i0KRdlEo0i4KRdrlvuLMKdwSRdpFoUi7KBRpF4Ui8+JzxbLlQ7HsTx6ccsRxgTlKjZzh0k7OJGonZ2x1k3Nas5+cgdhOzvRsJ2fUtpMH5G5y3oCwk1OfavJtOclLlZz6tJNTn3Zy6tNNznnbfnLq005OfarJ1/kk33KNnPq0kwfkbnLq005OfdrJqU87OfVpJ6c+3eScmO4npz7t5NSnnZz6tJMH5G5y6tNOTn3ayalPOzn1aSenPt3kQX3ayalPOzn1aSenPu3kAbmbnPq0k1OfdnLq005OfdrJqU83+UJ92smpTzs59Wknpz7t5AG5m5z6tJNTn3Zy6tNOTn3ayalPN/lKfdrJmcu15Hs5HruXtQYegHvBmcnN4EzkZnDmcTM407gZnFncC74xiZvBeRfIDM57QGZwStMMHoB7wSlNMzilaQanNM3glKYZnNL0ghdKU/yez3TapSlFjZzWtJNTm3ZyetNOHpC7yWlOOznVaSenO+3klKednPZ0k+/Up52c+lSTp3KSz6lGTn3ayalPO3lA7ianPu3k1KednPr8A4fEOjn1aZ/LqU8zeUzUp52c+rSTU592curTTh6Qu8mpTzs59Wknpz7t5NSnnZz6dJMn6tNOTn3ayalPOzn1aScPyN3k1KednPq0k1OfdnLq005OfbrJM/VpJ6c+7eTUp52c+rSTB+RucurTTk592smpTzs59Wknpz7d5DP1aSenPu3k1KednPq0kwfkbnLq005OfdrJqU87OfVpJ6c+3eRBfdrJqU87OfVpJ6c+7eTM5VrykpYfjy1pr4EzlYvBz+sry1YDZyY3gzORe8EXJhUzOHOKGTwA94KzQ24GZw43gzOHm8GZw83gzOFe8JV9cTM4u+JmcErTDE5pmsEDcC34uYhSavvhK6VpBqc0zeCUphmc0jSDU5pe8I3SNINTmmZwStMMTmmawQNwLzilaQanNM3glKYZnNI0g1OaXvBCaZrBKU0zOKVpBqc0zeABuBec0jSDU5pmcErTDE5pmsEpTS/4TmmawSlNMzilaQanNM3gAbgXnNI0g1OaZnBK0wxOaZrBKU0r+DJRmmZwStMMTmmawSlNM3gA7gWnNM3ghI8ZnPAxgxM+XvBE+JjBCR8zeAwJ/vHQ4wrnbUs1mDHHtxdgxnzVn8sUB0z5ZaG/hRnz1fk5TB7zVfQFmDFf7V6AGXM77gWYMbfNXoAJYOowg84xz2HG/IcJL8CMuY/2AgyT7wMYJt86zKDHzr8Aw+T7AIbJ9wEMk+8DmACmDsPk+wCGyfcBDJPvAxgm3wcwTL51mEGPvH4Bhsn3Acygk++2T58wT97NTXmdjzXnrao46JgsVgwUBYqjvoWuVRx0WhcrDjraixUH7QCx4qDRoFVcBi0MseKgOSJWpF0UirSLQjFQFCjSLgpF2kWhSLsoFGkXhSLtIlAc9OBztSLtolCkXRSKtItCMVAUKNIuCkXaRaFIuygUaReFIu0iUBz0KO3fpzjv5Vhz5Npf0Q96PrZakXZ5QXGLT8XqbzTz4nPFNY4PXfn4n3NNkXlRoci8qFBkXlQoMi++oFg+1/zlCj8VBz0QV63IvKhQZF5UKLLX/YLiZ0dvqdYugx7B+fsUy3p841TKWlPkNfqpYk4nR04pKoqDHiWoVuQ1WqHIa7RCkddohWKgKFBkf1GhyLyoUGR/UaHI/qJCkXa5r7gOejidWpF2USjSLgpF2kWhGCgKFGkXhSLtolCkXRSKtItCkXYRKA56vpxakXZRKNIuCkXaRaEYKAoUaReFIu2iUKRdFIq0i0KRdnlBcYlTcVkqiqOe6ilWpF0UirSLQpF2USgGigJF2kWhSLsoFGkXhSLtolCkXQSKo57LKlakXRSKtItCkXnx/t+krqOeDCpWZF5UKDIvvvD30ecqUonaXveoB5RqFUc9zVSsyLyoUGReVCiy161QDBQFirSLQpF2USjSLgpF2kWhSLsIFDknVaJIuygUaReFIu2iUAwUBYq0i0KRdlEo0i4KRdpFoUi7CBQ5J1WiSLsoFGkXhSLtolAMFAWKtItCkXZRKNIu90+DWDknVaJIuwgUOSdVoki7KBRpF4Ui7aJQDBQFirSLQpF2USjSLgpF2kWhSLsIFDmzV6JIuygUaReFIu2iUGRefK64nH+rn5ZtefKdYzpWMcc818gZLu3kTKJ2csZWNzlnXvvJGYjt5EzPdnJGbTt5QO4m5w0IOzn1aSenPu3k1KednPo0k2+ccSwmL2n58diS9hp4AG4F52xLMfhe8rHi2psTG8dgusG5pWjB03Tapal2dNfGkYZ+cqrTTk512smpTjs51ekm58xGPzlTuZ2c9zzt5Gxn2ckDcjc59Wknpz7V5Ov54JRqb01w3KWfnPq0k1OfbnJO3fSTU592curTTk592skDcjc59Wknpz7t5NSnnZz6tJNTn25yzvD1k1OfdnLq005OfdrJA3I3OfVpJ6c+7eTUp5g8p/PBOS01curTTk59usk5hdlPTn3ayalPOzn1aScPyN3k1KednPq0k1OfdnLq005OfbrJOUfbT0592smpTzs59WknD8jd5NSnnZz6tJNTn3Zy6tNOTn26yTkJ3U9OfdrJqU87OUOimjw+yaPUyBkS3eQcxisnX+eTfMs1cl4+7eS8fNrJ2by1kwfkbnI2b+3kzOV2cuZyOzmbt3ZyNm/d5ByT7SenPu3k1KednPq0kwfkN8gPRYLyBcWyH2tep+pzkUZUKJJ9CkVKTqFInN1XLBO9pVAkoRSKVJFCkdBRKAaKAkXaRaFIuygUaReFIu2iUKRdBIqJdlEo0i4KRdpFoUi7KBQDRYEi7aJQpF0UirSLQpF2USjSLgLFTLsoFGkXhSLtolCkXRSKgaJAkXZ5rrhGPhVjrinSLgpF2kWhSLsoFGkXgeJMuygUaReFIu2iUKRdFIqBokCRdlEo0i4KRdpFocjU/VQxp/PvAD/+Z+XvAEswdSsUmboVikzdCkWmboVioChQZOpWKDJ1KxSZuhWKvGOgUKRdBIocRy9RpF0UirSLQpF2USgGigJF2kWhSLsoFGkXhSLtolCkXQSKHGYuUaRdFIq0i0IxUEy1N+o5ePoRDLPxAxjG3QcwTLB1GI6KdZ/oWDgq1k/O9qidPCB3kzMv2smZRO3kzLh2cqZnOzmbxW5yTlr3k1OfavJtOclLlZz6tJNTn3bygNxNTn3ayalPOzn1aT63tHDSup+c+nSTc9K6n5z6tJNTn3Zy6tNOHpC7yalPOzn1aSenPu3k1KednPo0k++cO+8npz7t5NSnnZz6tJMH5G5y6tNOTn3ayalPOzn1aSenPt3kifq0k1OfdnLq005OfdrJA3I3OfVpJ6c+7eTUp52c+rSTU59u8kx92smpTzs59Wknpz7t5AG5m5z6tJMzl2vJ93KcmbqXtQbOVO4Fn5nJzeBM5GZw5nEzONO4GTwA94IziZvBeRfIDM57QGZwStMMTml6wYPSNINTmmZwStMMTmmawQNwLzilKX7PZzrt0pSiRk5r2smpTTs5vWknpzjd5AvNaSenOu3kdKednPK0kwfkbnLq005OfarJUznJ51Qjpz7t5NSnnZz6dJOv1KednPq0k1Off+CQWCenPt1z+RqQu8mpTzs59Wknpz7t5NSnnZz6dJNv1KednPq0k1OfdnLq004ekLvJqU87OfVpJ6c+7eTUp52c+nSTF+rTTk592smpTzs59WknD8jd5NSnnZz6tJNTn3Zy6tNOTn26yXfq005OfdrJqU87OfVpJw/I3eTUp52c+rSTU592curTTk59esmXaaI+7eTUp52c+rSTU5928oDcTU592smpTzs59Wknpz7d5Im5XEte0vLjsSXtNXCmcjH4eX1l2WrgzORm8ADcC86kYgZnTjGDs0fuBc/skJvBmcPN4MzhZnDmcDN4AO4FZ1/cDM6uuBmc0jSDU5pmcEpTDH4uopTafvhMaZrBKU0zOKVpBqc0zeABuBec0jSDU5pmcErTDE5pmsEpTS94UJpmcErTDE5pmsEpTTN4AO4FpzTN4JSmGZzSNINTmmZwStMLvlCaZnBK0wxOaZrBKU0zeADuBac0zeCUphmc0jSDU5pmcErTC75SmmZwStMMTmmawSlNM3gA7gWnNM3glKYZnNI0g1OaZnBK0wu+UZpmcMLHDE74mMEDcC844WMGJ3zM4PfHwjmV4zrn9Rn4suw/Hrxs6RPw46f8WFCZeltQ6m1BubcFzb0tKMwL2o/vvE5rdUFLbwtae1vQ1tuCSm8L2jtb0O6+U5d8/NqXUl1Q6m1BubcFzb0tKHpb0NLbgtbeFrT1tqDS24L2vhaUps7u1Gnq7E6dps7u1Gnq7E6dps7u1Gnq7E6dps7u1Gnq7E6dps7u1Gnq7U6dertTp97u1Km3O3Xq7U6dertTp97u1Km3O3Xq7U6dertTp97u1Lm3O3Xu7U6de7tT597u1Lm3O3Xu7U6de7tT597u1LmfO/XH//V//vy//vLn//KP//DPH1/xy//n//7rf/3bX/7prz/+z7/93//5b/8/H4/9/w=="},{"name":"donate","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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85nL5uVquSrn85bNy9VyVc5nLZuXq+WqnM9ZNi9Xy1U5n7FsXq6Wq3I+X9m8XC1X5Xy2snm5Wq7K+Vxl83K1XJXzmcrm5Wq5KufzlM3L1XJVzmcpm5er5aomLVc1abkq51OyzcvVclVFy1UVLVflfAa6eblarsr5DHTzcrVclfMZ6Oblarkq5zPQzcvVclXOZ6Cbl6vlqpzPQDcvV8tVOZ+Bbl6ulqvSmq2etGarJ63Z6klrtnrSmq2etGarJ63Z6klrtnrSmq2etGarJ63Z6klrtnrSmq2etGarJ63Z6klrtnrSmq2etGarJ63Z6klrtnrSmq2etGarJ63Z6klrtnrSmq2etGarJ63Z6klrtnrSmq2etGarJ63Z6klrtnrSmq2etGarJ63Z6klrtnrSmq2etGarJ63Z6klrtnrSmq2etGarJ63Z6klrtnrWmq2etWarZ63Z6llrtnq+Fa1ypVxV1pqtnrVmq2et2epZa7Z61pqtnrVmq2et2epZa7Z61pqtnrVmq2et2epZa7Z61pqtnrVmq2et2epZa7Z61pqtnrVmq2et2epZa7Z61pqtnrVmq2et2epZa7Z61pqtnrVmq2et2epZa7Z61pqtnrVmq2et2epZa7Z61pqtnrVmq2et2epZa7Z61pqtnrVmq2et2epZa7Z61pqtnrVmq2et2epZa7Z61pqtnrVmq2et2epZa7Z61pqtnrVmq2et2epZa7Z61pqtnrVmq2et2epZa7Z61pqtnrVmq2et2epZa7Z61pqtnrVmq2et2epZa7Z61pqtnrVmq2et2epZa7Z61pqtnrVmq2et2epZa7Z61pqtnrVmq2et2epZa7Z61pqtnrVmq2et2epZa7Z61pqtnrVmq2et2epZa7Z61pqtnrVmq2et2epZa7Z61pqtnrVmq2et2epZa7Z61pqtnrVmq09as9Unrdnqk9Zs9Ulrtvp0K1rlSrmqSWu2+qQ1W33Smq0+ac1Wn7Rmq09as9Unrdnqk9Zs9UlrtvqkNVt90pqtPmnNVp+0ZqtPkaZv1zU/f3iddsoN9NxtKTfQnblu2+uH151yA92ZW8oNdGduKTfQnbml3EB5t6HcSPOZW8qN9NxtKDfSc7eh3EB5t6XcolWulquKNJ+5pdxhXdW7hGGd0rsE1+7nfo48vw5y25aD/+z2f/erYN+TlM8o2LUDOqNg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Wm9Srmq9Sbmq9SblqtablKtab0WrXClXtd6kXNV6k3JV603KVa03LVeVtFxVpD32LeVquapIO9tbyi1a5Wq5qkhbwVvK1XJVkTZgt5Sr5aoibXtuKVfLVUXabNxSrparirTFt6VcLVcVaWNtS7larirSdtaWcrVcVaRNpC3larmqSFs3W8rVclWRNky2lKvlqiJtU2wpV8tVRdoc2FKulquKtCWvpVwtVxVpI1xLuVquKtL2s5ZytVxVpE1fLeVquapIW61aytVyVZE2OLWUq+WqIm0railXy1VF2szTUq6Wq4q0haalXC1XFWnjSku5Wq4q0naRlnK1XFWkTRot5Wq5qkhbI1rK1XJVkTYktJSr5aoibQNoKVfLVUWaqt9SrparijT5vqVcLVcVaTp9S7larirSBPmWcrVcVaQp7y3larmqSJPYW8rVclVas9VXrdnqq9Zs9VVrtvqqNVt91ZqtvmrNVl+1ZquvWrPVV63Z6qvWbPVVa7b6qjVbfdWarb5qzVZftWarr1qz1Vet2eqb1mz1TWu2+qY1W33Tmq2+3YpWuVKuatOarb5pzVbftGarb1qz1Tet2eqb1mz1TWu2+qY1W33Tmq2+ac1W37Rmq29as9U3rdnqm9Zs9U1rtvqmNVt905qtvmnNVt+0ZqtvWrPVN63Z6pvWbPVNa7b6pjVbfdOarb5pzVbftGarb1qz1Tet2eqb1mz1TWu2+qY1W33Tmq2+ac1W37Rmq29as9U3rdnqm9Zs9U1rtvqmNVt905qtvmnNVt+0ZqtvWrPVN63Z6pvWbPVNa7b6pjVbfdOarb5pzVbftGarb1qz1Tet2eqb1mz1TWu2+qY1W33Tmq2+ac1W37Rmq29as9U3rdnqm9Zs9U1rtvqmNVt905qtvmnNVt+0ZqtvWrPVN63Z6pvWbPVNa7b6pjVbfdOarb5pzVbftGarb1qz1Tet2eqb1mz1TWu2+qY1W33Tmq2+ac1W37Rmq29as9U3rdnqm9Zs9U1rtvqmNVt905qtvmnNVt+0ZqtvWrPVN63Z6pvWbPWqNVu9as1Wr1qz1avWbPV6K1rlSrmqqjVbvWrNVq9as9Wr1mz1qjVbvWrNVq9as9Wr1mz1qjVbvWrNVq9as9Wr1mz1qjVbvWrNVq9as9Wr1mz1qjVbvWrNVq9as9Wr1mz1qjVbvWrNVq9as9Wr1mz1qjVbvWrNVq9as9Wr1mz1qjVbvWrNVq9as9Wr1mz1qjVbvWrNVq9as9Wr1mz1qjVbvWrNVq9as9Wr1mz1qjVbvWrNVq9as9Wr1mz1qjVbvWrNVq9as9Wr1mz1qjVbvWrNVq9as9Wr1mz1qjVbvWrNVq9as9Wr1mz1qjVbvWrNVq9as9Wr1mz1qjVbvWrNVq9as9Wr1mz1qjVbvWrNVq9as9Wr1mz1qjVbvWrNVq9as9Wr1mz1qjVbvWrNVq9as9Wr1mz1qjVbvWrNVq9as9Wr1mz1qjVbvWrNVq9as9Wr1mz1qjVbvWrNVq9as9Wr1mz1qjVbvWrNVq9as9Wr1mz1qjVbvUrNVl9vUrPV7+Uquap7uUqu6l6ukqu6l1u0ylVyVfdylVzVvVwlV3UvV8lV3cvVclVSs9Xv5Wq5KqnZ6vdytVyV1Gz1e7larkpqtvq9XC1XJTVb/V6ulquSmq1+L1fLVUnNVr+Xq+WqpGar38vVclVSs9Xv5Wq5KqnZ6vdytVyV1Gz1e7larkpqtvq9XC1XJTVb/V6ulquSmq1+L1fLVUnNVr+Xq+WqpGar38vVclVSs9Xv5Wq5KqnZ6vdytVyV1Gz1e7larkpqtvq9XC1XJTVb/V6ulquSmq1+L1fLVUnNVr+Xq+WqpGar38vVclVSs9Xv5Wq5KqnZ6vdytVyV1Gz1e7larkpqtvq9XC1XJTVb/V6ulquSmq1+L1fLVUnNVr+Xq+WqpGar38vVclVSs9Xv5Wq5KqnZ6vdytVyV1Gz1e7larkpqtvq9XC1XJTVb/V6ulquSmq1+L1fLVUnNVr+Xq+WqpGar38vVclVSs9Xv5Wq5KqnZ6vdytVyV1Gz1e7larkpqtvq9XC1XJTVb/V6ulKtKWrPVk9Zs9aQ1Wz1pzVa/F6NVrpSrSlqz1ZPWbPWkNVs9ac1WT1qz1ZPWbPWkNVs9ac1WT1qz1ZPWbPWkNVs9ac1WT1qz1ZPWbPWkNVs9ac1WT1qz1ZPWbPWkNVs9ac1WT1qz1ZPWbPWkNVs9ac1WT1qz1ZPWbPWkNVs9ac1WT1qz1ZPWbPWkNVs9ac1WT1qz1ZPWbPWkNVs9ac1WT1qz1ZPWbPWkNVs9ac1WT1qz1ZPWbPWkNVs9ac1WT1qz1ZPWbPWkNVs9ac1WT1qz1ZPWbPWkNVs9ac1WT1qz1ZPWbPWkNVs9ac1WT1qz1ZPW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02VvS6bLXpdMl70vmS57YTJd9sZkuuyVyXTZO5Ppspcm02VvTabLXptMl703mS57cTJd9uZkuuzVyXTZu5Ppspcn02VvT6bLXp9Ml70/mS57gTJd9gZluuwVynTZO5Tpspco02VvUabLXqNMl71HmS57kTJd9iZluuxVynTZu5Tpspcp02VvU6bLXqdMl71PmS57oTJd9kZluuyVynTZO5Xpspcq02VvVabLXqtMl71XmS57sTJd9mZluuzVynTZu5Xpspcr02VvV6bLXq9Ml71fmS57wTJd9oZluuwVy3TZO5bpspcs02VvWabLXrNMl71nmS97zzJf9p5lvuw9y3zZe5b5Vi670nzZlZbLrrRedqXtsitddo+47D3LfNl7lvmy9yzzZe9Z5sves8yXvWeZL3vPMl/2nmW+7D3LfNl7lvmy9yzzZe9Z5sves8yXvWeZL3vPMl/2nmW+7D3LfNl7lvmy9yzzZe9Z5sves8yXvWeZL3vPMl/2nmW+7D3LfNl7lvmy9yzzZe9Z5sves8yXvWeZL3vPMl/2nmW+7D3LfNl7lvmy9yzzZe9Z5sves8yXvWeZL3vPMl/2nmW+7D3LfNl7lvmy9yzzZe9Z5sves8yXvWeZL3vPMl/2nmW+7D3LfNl7lvmy9yzzZe9Z5sves8yXvWeZL3vPMl/2nmW+7D3LfNl7lvmy9yzzZe9Z5sves8yXvWeZL3vPMl/2nmW+7D3LfNl7lvmy9yzzZe9Z5sves8yXvWeZL3vPMl/2nmW+7D3LfNl7lvmy9yzzZe9Z5sves8yXvWeZL3vPMl/2nmW+7D3LfNl7lvmy9yzzZe9Z5sves8yXvWeZL3vPMl/2nmW+7D3LfNl7ltNl71lOl71nOV32nuV02XuW061cdqXLdvFd9p7ldNl7ltNl71lOl71nOaXrVnVedo+47D3L6bL3LKfL3rOcLnvPcrrsPcvpsvcsp8ves5wue89yuuw9yylft8/3snvE3nuW95vH60rTfDu40rRuz4NNW94OfrqWWv78dJ3n6fXTuXw7V3F6rtnpuRan51qdnmtzeq7q81x7b6p2P1dyeq7s9FxO7/eT0/v95PR+Pzm9309O7/eT0/v97nvENb3PtcwHV1qm/Oenl+3bz075h58t0/LnZ8u8/vWzzzPtvnF82pnuMJ9nWtLPZ0oOz5QdnmlyeKbi8Eyz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"},{"name":"_check_deadline","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/+WZ227bRhCGV1Kk2JVEUpZkxdTZomTZVtKkRu27XhW97CsU6QkpUqRB0l606BP2NXpdoI/QnZkd/qRYqFjDWBSIAIrk7P9xZmeXqx07Mw1jjurGfqbGfezdkYlMy55qdHxm9EoaTS0yNTWtqZGptZOZxrn9Ov7U6INj+nrE381rvqYre7QyUyPgUZOeRw6lKaOgGDtea1CPDRvpc0xfoiHsKEOLfeCX9vyRiB87cXtdF6NpA2uL5lguGf0JZkU7jJKgA7QDtOPQn2FWtMsoCbpAu0C7Dl3ArGjEKAkioBHQyKE/wKxozCgJYqAx0Nihb2BWNGGUBAnQBGgi5yoS+SOdB/di+/QSZkV7jJKgB7QHtOfQH2FW9IRREpwAPQF6Ug30JA/0AGK9/Qazon1GSdAH2gfad+h3MCs6YJQEA6ADoAOHfguzokNGSTAEOgQ6pPOSXq33eDETBg3eRn39SG3W+oraJz4y+Jyyq9Oyq5HAQ7nUFpqCI4jO8IKnLb5MnX7sFpBJjYUTMtHBEb+VO+0uMZO1yp7AsTTUxUiN6uGMzvR2fl8Iay/g25rOQZoopiWrXJPXspZb5k4FvyUmT9sQaRuV17NjdNcmofZFOVoSn+XRnhWyJJqRC5zQX2BWNGWUewY0BZpW+5jmy8IBxHr7BmZFx4ymMlKKjoGOq97G+fLgiUT+SNsfif2R7mHEZu4rmBWVCUmCCdAJ0EnV2yRP9gHEensFs6JTRkkwBToFOq16m+aLjieSHkZsgK9hVnTGKAlmQGdAZ1VvszyDnsjAH+n7I0mQwHr+SOSPxEEy1vVH0iDjEgfpSztIYP8xYezb+SvMis4ZJcEc6BzovOptnqfhAGK9fQ2zogtGSbAAugC6qHpb5HPOE+n6I6k/kvgjvSDIPTI2CJLkyB+J/ZHOg2fMzuh3MCu6ZJQES6BLoMuqt2XeJ08k8Ud6QZDZYYS+eEPrdtN3DBpsoXXPvMyLkJE8sViEnLOr87KrlcBLudQW2q6vIFpjV76RImTj9BeuCNlKEbIlEx0c8Tu50+4Ss12rLINjaaiLkRrVA/VkY6dG7VUhrL2Ab10pZe5cKC35g0pDixCgSNnpXsrQ1fOs2NIQrYxCXniMKjXcEqNVRc78kdgfSf2Rjj8S+SPtIN3v+iPjIEme+CP9IIFNg2RsEKT7SZDAekHelzhIxrpB5lhi/qfvfphF6R4TZhak+/MPe471giD3yNjgwZNsN0XvYVZ0xeiovMvb31n9G9LxR5IgXiJ/JA3Sl14QZHYYoYv6G+yG7xg05Y2ucWopIJbyxGIBkeV79GJtIPDKcStst9cQXWBXvZUCYuv0l27XfiUFxBWZ6OCIX8uddpeYq7XKNnAsDXUxUmOjUItsF/ZJLwth7QV86youKiCapvwhYYP/GyyXVQXBzSj/d0cTfd7k+c2Q340pVRuri7p7NN1lyNIFNC5hF65Lkpnf6YojL0SaOdkl54jSuIl4AMlrJkHy6ImVMrDh/7+sWjCQRiqozFVQG4mlz1WawUTJR7Tcp8vCWNvB/RwjokN1zUNFY3gN7Bqjdm3yKrCM9P2RxB8Z+CM9fyTyR+IgGev6I5Mg4zJ68L7Y6fkWZkV3jJJgB3QHdFf1tsv75ImMgiB9f2RwGOFF6G8sDizPF4ctFodd/oOylScWf1CesqunZVfPBN7JpbZQF55B9ByLzAtZH184/SfuB+VGflBuyEQHR/yX3Gl3iblZq+xjOJaGuhipUT08p/PCPunPQlh7Ad/qn7gG/BP75A86/gF3XJNRbCQAAA==","debug_symbols":"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"},{"name":"withdraw","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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s5j3vHQW857DTmLe8Ibq2cx7DjuLec9hZzHvOews5smZn8S857CzmPccdhbznsPOYt5z2FnMew47iXnD28ZnM+96XoL5z9tkg+GN0bOZd20z67RxbTOLedc2k5gvrm1mMe/1+VnMe33+18w/sOkanZNNcjYZ2fTa+Dk201YOIIlesun1bk42Pc/jZNNzN042PR9jZLN6jsXJpudNJ9msR7ExUN7+weaTT1e6c9/oAQmFR+49c5rHvedZ87gn534a957DzePeM7553Ht+OI97zybnce+55zTum2eq87j3vHYe957XzuPe89p53JNzP417z2vnce957TzuPa+dx73ntfO497x2Gvfd89p53HteO497z2vnce957Tzuybmfxr3ntfO497x2Hvee187j3vPaedx7XjuL+7h5XjuPe89r53Hvee087j2vncc9OffTuPe8dh73ntfO497z2nnce147jfvgGlOA+xMT0GJwhTmLeb9nJZj/PJMoBr9lZzHvd+ws5r1yPIn56HXjWcx71fjXzD+w6Rqdk03X3efYzOHwMeTaPpwK1A/UOTz85fCPU4Gc+UnMe1V3FvOea85i3nPNWcx7rjmLec81JzGfPNcUYD7T8adzTq+Y91xzFvOel85i3nPYWcyTMz+Jec9hZzHvOews5j2HlWW+bK+Y9xx2FvOew05injyHPcd8+WKk5PCB+ZDpvsMn58d5/4/v4ZFnsfO49zx2Hveeyc7jnpz7adx7NjuPe89nRbi/v3p906PxFfee0c7j3nPaedx7VjuN++x57TzuPa+dx73ntRLcU9/u3Ld/asyf1d2y58A64kQeJxVx8txaIk6lfn260as7x3Predx7bj2Pe8+t53HvufU07ovn1vO499x6HveeW4tw3+4zi0rvr7j3fHke9+TcT+Pe89p53HteO497z2vnce957TzuPa8V4T4cQEIN/9T3P6s3V8+BdcTJ82UdcfLcWiJObbv/zvYPJP+4c6rn1vO4J+d+GveeW8/j3nPredx7bj2Pe8+t53HvubUI9yHfuY/tBffN8+V53HsOPI97z2vnce957Tzuybmfxr3ntfO497xWgvs3e81+Vm9ungPriJPnyzriZDe3LumO+vYT/6c45f71FkDoDzieMpKPKyc+bra74fhivtvNrGczbzevns283ax6NvN2c2o25h/YJGeTkU27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7znsLOY9h53FvOews5gnZ34S857DzmLec9hZzHsOO4t5z2FnMe857CTmyXPYWcx7DjuLec9hZzHvOews5smZn8S857CzmPccdhbznsPOYt5z2FnMew47ifnsOews5j2HncW857CzmPccdhbz5MxPYt5z2FnMew47i3nPYWcx7znsLOY9h53EfPEcdhbznsPOYt5z2FnMew47i3ly5icx7znsLOY9h53FvOv5c8zHQAeQ2Oon5k/MdKqu52cx73p+FvOu52cx73p+FvPkzAswf2LiRHU9P4t51/OzmPffpGYx779JzWLec9hJzDfPYSWYP1G3aZ7DzmLec9hZzHsOO4t5cuYnMe857CzmPYedxbznsLOY9xx2FvOew05ivnsOO4t5z2FnMe857CzmPYedxTw585OY9xx2FvOew85i3nPYWcx7DjuLec9h5zB/o9iZn8S857CzmPccdhbznsPOYp6c+UnMew47i3nPYWcx7znsLOY9h53FvOewk5gPnsPOYt5z2FnMew47i3nPYWcxT878JOY9h53FvOews5j3HHYW857DTmI+2tXzoeU76sHfW+ZPTO8I0a5C5+fSrubm55KcSzYu7epifi7tKt3vcdmPD5ctv+LSrnbl59KuGuXn0u5vJOxcJru/enyTy4/TaELyvIePS897+Lj0vIePS3Iu2bj0vIePS897znF5on6ZPO/h49LzHj4uPe9h45I87+Hj0vMePi497+Hj0vMePi7JuWTj0vMePi497+Hj0vMePi497+Hj0vMeNi6z5z18XHrew8el5z18XHrew8clOZdsXHrew8el5z18XHrew8el5z18XHrew8Zl8byHj0vPe/i49LyHj0vPe/i4JOeSjUvPe/i49LyHj0vPe/i49LyHj0vPe9i4rJ738HHpeQ8fl5738HHpeQ8fl+RcsnFpV19u6fAxbp0+cXlirkG1qy/5ubSrL9m5bHb1JT+XdvUlP5d29eX3uDwxI6LZ1Zf8XJJzycal3bo6P5d26+rf5PJzL37zvIePS897+Lj0vIeNy+55Dx+Xnvfwcel5zzkuT9Qvu+c9fFySc8nGpec9/8LGpec9fFx63sPHpec9fFx63sPFZdw87+Hj0vMePi497+Hj0vMePi7JuWTj0vMePi497+Hj0vMePi497+Hj0vMeNi4Nb4fn59LzHj4uPe/h49LzHj4u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"},{"name":"init","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"donation_token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"operator","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"deadline","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"_publish_donation_receipts","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"7Z3hjhXHEYXfZX+j6HZVT/eMXyWKImzjCAktlsGRIuR3zxL23gVxQuXk3vZW0+eXDXSPar6its4cemo+3P386sff//H31/e/vH1398NfP9y9efvTy/ev394//OrD3ekvxf7zu+9+fXn/8TfevX/52/u7H04v7l7d//zw3z9e3P3y+s2rux+82h9/e/Fxg7MbKrthYzc0dkNnN+zshoPcYKf/fcOLr9Yd2/a48uj9srYYWltLPy+uZa+X1ccGFjfz/ri42eafL/4Udrkm7HJye1xaTlv9UwO3q3gf5SnuLYi7lFLPq0s/fTvuXi832beyfx23D4r709Xr0KtvQ6/ehl69D736PvTqx8ir+2no1cvQq9vQqw+tVR9aqz60Vn1orfrQWvWhtepDa7UOrdU6tFbr0FqtQ2u1Dq3VOrRW69BarUNrtQ6t1Tq0VrehtboNrdVtaK1uQ2t1G1qr29Ba3YbW6ja0VrehtboNrdU2tFbb0FptQ2u1Da3VNrRW29BabUNrtQ2t1Ta0VtvQWu1Da7UPrdU+tFb70FrtQ2u1D63VPrRW+9Ba7UNrtQ+t1X1ore5Da3UfWqv70Frdh9bqPrRW96G1ug+t1X1ore5Da/UYWqvH0Fo9htbqMbRWj6G1egyt1WNorR5Da/UYWqvH0Fotp9PYy5exl7exl/exl69jL7+NvXwbe/k+9vL72MuPrdoytmrL2KotY6u2jK3aMrZqy9iqLWOrtoyt2jK2asvYqrWxVWtjq9bGVu3Y80xl7IGmMvZEU7nuSFN1O587q+52WY3Py/m+Py5u9fT1ebly3QGom57dK0YfxzT2PGZhjjU97ij0Dv7wLX36ljkm9LiDPn/r9AFcp0/gOp1zp3Ne6ZxXOueVznnlT1zTOa90ziud80rnvNI5r3TONzrnG53zjc75Rud8o3O+0Tnf6JxvdM43OucbnfNG57zROW90zhud80bnvPHvVtA5b3TOG53zRue80znvdM47nfNO57zTOe90zjv/Qg2d807nvNM53+mc73TOdzrnO53znc75Tud8p3O+829R0Tnf6ZwfdM4POucHnfODzvlB5/ygc37QOT/onB/8q3P8u3Mnekehdxi9w+kdld6x0TsavaPTO3Z6B53zQue80DmnX441+u1Yo1+PNfr9WKNfkDX6DVmjX5E1/h1Zo3NudM6NzrnROTc650bn3OicG51z2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2ocz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2odz2oertA9XaR+u0j5cpX24SvtwlfbhKu3DVdqHq7QPV2kfrtI+XKV9uEr7cJX24Srtw1Xah6u0D1dpH67SPlylfbhK+3CV9uEq7cNV2oertA9XaR+u0j5cpX24SvtwFftwD38V/HHTQ453sA+7cQ9/sZ/2Nf9iH3j9+OntYwuWfuvCjwGVbAFZtoA8W0A1W0BbtoBatoB6toD2PzWgUurTp3SOclldTicUfj+PEdg+m2iA15Zy/hKRWY+isP08zODhf9vTlXc/YzmEBWCpJ2FBWIqwICwmLAiLCwvCUoUFYdmEBWFpwoKwdGFBWKRyIRapXIRlk8qFWKRyIRapXIhFKhdiqcKCsEjlQixSuRCLVC7EIpULsUjlIixNKhdikcqFWKRyIRapXIilCgvCIpULsUjlQixSuQhLX7JBP30Korh3hGXJBh1jWfJHrm92wdINYVnyR26MZckfuTGWJY2FGMuSxkKIZV/SWKh2nKOo/fQFFrC6XRZ/ttb6BeGSGue2CJfUQ7dFuKS5cVuES8rP2yJcUqpyCC9vG5WjIoRLytrbIlxSAt8W4ZJy+aYID+nCqxGqI0cI7enKxRFCdeSrEepnYYTQ+/m9a98Bwu20ps1w8ieEJUDYt3PIvYF/StlOa7aTmyLMbDNs/Vxv2376Yu1j8Jkf8MPg68zBZ1YhYfCZ+38YfOZn4TD4zE+hYfCZNU8UfMmsNsLgZ25SZeYmVWZuUmXmJlVmblJl5iZVZm5SZeYmZTM3Kcv8MBoGP3OHtZk7rM3cYW3mDmszd1ibucPazB3WM/+o7OVsOnc3FHzmH5Vh8JkLttdzFH3rKPjMBRsGn7lgw+AzS+Io+NQTC8PgM0vifpz/zWU3GHzqn/NR8Kl/zkfB15mDzyyJw+BTd9go+NQdNgo+dYeNgk/dYYPgU09LC4OfucOmnjwWBj9zh009xSsMfuYOm3oiVhj8zB029XSpMPiZO2zqSU1h8DN32NRTj8LgZ+6wqScIhcHP3GFTT+MJg5+5w7aZO2ybucP2mTts6oFIYfAzd9g+c4ftM3fY1GOdwuAzd9h9a+fgjx6sbf28tp+erntsaOl2HuvWP3sh7mHpI5LMffuZkGRWA/8nkmLgPjMLhxveZ+qxSLe8z8xy5Jb3mVm53PI+M4ucW95nXeQ+M0unW97nd6iy4H1+h9IJ3ucieij1mJwb3uexiB5KPbPnlve5iB46FtFDR13kPhfRQ6mnNt3yPhfRQ8cieij1qKzb3WdLPc/qlve5hh5qqSdD3fI+vxs99N/8ePAvPK1fxoL1cgJQqqB8DSX1yZJvvzzZUs+NCoNPfbIkCj71yZIg+NRzo8LgU58saZfg+4GCT32yJAo+9cmSKPjMzS8MPvXJkij41B02Cj51h42CT91ho+BTd9gg+NRDr8LgZ+6wqYdehcHP3GFTD70Kg5+5w6YeehUGP3OHTT30Kgx+5g7rE8/QaZ66w0bBp+6wUfCpO2wUfOoOGwWfusNGwU88pa7NPKWuzTylrs08pa7NPKWu5Z5SFwU/c4fNPaUuCn7mDpt7Sl0U/MwdNveUuij4mTts7il1QfC5p9RFwc/cYXNPqYuCn7nD5p5SFwU/c4fNPaUuCn7mDpt7Sl0U/MwdNveUuij4mTts7il1UfAzd9jcU+qi4GfusLmn1EXBz9xhc0+pC4JPPStt3BfP7fxJplL708F8/MVze7ryZyf+rfsZYeZuMwnCzD1vEoSZO28ShPs5CjsMIczc/ydBmFmFTIIwsxaaBGFmRTYJwszOSz6EDSBMPd9wEoR6OrkaoZ5Orkaop5OrEVYhvBahnk6uRqinkwihXxZ7LQihnk6uRqink6sR6unkWoSpp41OglBPJ1cj1NMJgXA7IYR6OrkaYRXCEOF+RtggQj2dhAhL+zZCPZ1cjVBPJ1cj1NNJiLCfxwP4Dv4pvqceXDsJQknrqxFKWl+NUNL6aoRVCK9FKGl9NcIlRY3bJQr3/gXCRyxL2qghltQjip8Ry5KaLMaypM6KsSypnbxvFyy7ISxVWBCWJTVOjGVJSzDGsqTNF2NZU+WGWNZUuRGW1GPCnxHLmio3xLKmyg2xSOVCLFVYEBapXIhFKhdikcqFWKRyIRapXIQl9aj+Z8QilQuxSOVCLFK5EEsVFoRFKhdikcqFWKRyIRapXIhFKhdhSf25jGfEIpULsUjlQixSuRBLFRaERSoXYpHKhVikciEWqVyIRSoXYUn9yZpnxCKVC7FI5UIsUrkQSxUWhEUqF2KRyoVYpHIhFqlciEUqF2FJ/dmoZ8QilQuxSOVCLFK5EEsVFoRFKhdikcqFWKRyIRapXIhFKhdh6VK5EItULsQilQuxSOVCLFVYEBapXIhFKhdikcqFWKRyIRapXIRlzU/AxVikciEWqVyIRSoXYqnCgrBI5UIsUrkQi1QuxCKVC7FI5SIsa35KLMYilQuxSOVCLFK5EEsVFoRFKhdikcqFWKRyIRapXIhFKhdg2df8qleMRSoXYpHKhVikciGWKiwIi1QuxCKVC7FI5UIsUrkQi1QuwrLot89CLFK5EItULsQilQuxVGFBWKRyIRapXIhFKhdikcqFWKRyERZ9+wxjkcqFWKRyIRapXIilCgvCIpULsUjlQixSuRCLVC7EIpWLsOjbZxiLVC7EIpULsUjlQixVWBAWqVyIRSoXYpHKhVikciEWqVyERd8+w1ikciEWqVyIRSoXYqnCgrBI5UIsUrkQi1QuxCKVC7FI5SIs+vYZxiKVC7FI5UIsUrkQSxUWhEUqF2KRyoVYpHIhFqlciEUqF2HRt88wFqlciEUqF2KRyoVYqrAgLFK5EItULsQilQuxSOVCLFK5CIu+fYaxSOVCLFK5EItULsRShQVhkcqFWKRyIRapXIhFKhdikcpFWPTtM4xFKhdiWVPlbnbB0iGWNVVuiKUKC8KypsoNsaypckMsa6rcEMuaKjfEsqbKjbAs+u2zEMuaKjfEIpULsUjlQixVWBAWqVyIRSoXYpHKhVikciEWqVyA5Vj022chFqlciEUqF2KRyoVYqrAgLFK5EItULsQilQuxSOVCLFK5CMui3z4LsUjlQixSuRCLVC7EUoUFYZHKhVikciEWqVyIRSoXYpHKRVgW/fbZN7A8/OqfL397/fLHN6/ePez5+Ie/3//0/vXb+8dfvv/Xr5/+5GHtvwE="}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"pending_shields","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"donation_token","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"operator","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"deadline","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"donation_receipts","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"events":[{"fields":[{"name":"who","type":{"kind":"field"}},{"name":"amount","type":{"kind":"field"}}],"kind":"struct","path":"Crowdfunding::WithdrawalProcessed"}],"functions":[{"fields":[],"kind":"struct","path":"Crowdfunding::_check_deadline_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"Crowdfunding::donate_parameters"}}],"kind":"struct","path":"Crowdfunding::donate_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"Crowdfunding::withdraw_parameters"}}],"kind":"struct","path":"Crowdfunding::withdraw_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Crowdfunding::_publish_donation_receipts_parameters"}}],"kind":"struct","path":"Crowdfunding::_publish_donation_receipts_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"donation_token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"operator","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"deadline","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"Crowdfunding::init_parameters"}}],"kind":"struct","path":"Crowdfunding::init_abi"}]}},"file_map":{"100":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/unencrypted_logs/unencrypted_event_emission.nr","source":"use crate::{\n    context::{PrivateContext, PublicContext}, event::event_interface::EventInterface,\n    encrypted_logs::payload::compute_encrypted_event_log, oracle::logs_traits::LensForEncryptedEvent\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Serialize};\n\nfn emit<Event, NB, MB, OB, N, M>(\n    context: &mut PublicContext,\n    event: Event\n) where Event: EventInterface<NB, MB>, Event: Serialize<N>, [Field; N]: LensForEventSelector<N, M> {\n    let selector = Event::get_event_type_id();\n\n    let serialized_event = event.serialize();\n    let mut emitted_log = [0; M];\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    for i in 0..serialized_event.len() {\n        emitted_log[i] = serialized_event[i];\n    }\n\n    emitted_log[serialized_event.len()] = selector.to_field();\n\n    context.emit_unencrypted_log(emitted_log);\n}\n\npub fn encode_event<Event, NB, MB, OB, N, M>(context: &mut PublicContext) -> fn[(&mut PublicContext,)](Event) -> () where Event: EventInterface<NB, MB>, Event: Serialize<N>, [Field; N]: LensForEventSelector<N, M> {\n    | e: Event | {\n        emit(\n          context,\n          e,\n        );\n    }\n}\n\ntrait LensForEventSelector<N, M> {\n    // N = event preimage input in fields\n    // M = event preimage input in fields + event selector as field\n    fn output(self: [Field; N]) -> [Field; M];\n}\n\nimpl LensForEventSelector<1, 2> for [Field; 1] {\n    fn output(self) -> [Field; 2] {[self[0] as Field; 2]}\n}\nimpl LensForEventSelector<2, 3> for [Field; 2] {\n    fn output(self) -> [Field; 3] {[self[0] as Field; 3]}\n}\nimpl LensForEventSelector<3, 4> for [Field; 3] {\n    fn output(self) -> [Field; 4] {[self[0] as Field; 4]}\n}\nimpl LensForEventSelector<4, 5> for [Field; 4] {\n    fn output(self) -> [Field; 5] {[self[0] as Field; 5]}\n}\nimpl LensForEventSelector<5, 6> for [Field; 5] {\n    fn output(self) -> [Field; 6] {[self[0] as Field; 6]}\n}\nimpl LensForEventSelector<6, 7> for [Field; 6] {\n    fn output(self) -> [Field; 7] {[self[0] as Field; 7]}\n}\n"},"102":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::{Point, pub_key_to_bytes},\n    constants::{GENERATOR_INDEX__IVSK_M, GENERATOR_INDEX__OVSK_M}, hash::poseidon2_hash\n};\n\nuse std::field::bytes32_to_field;\n\nuse crate::oracle::unsafe_rand::unsafe_rand;\n\nuse crate::event::event_interface::EventInterface;\nuse crate::note::note_interface::NoteInterface;\n\nuse crate::encrypted_logs::{\n    header::EncryptedLogHeader, incoming_body::EncryptedLogIncomingBody,\n    outgoing_body::EncryptedLogOutgoingBody\n};\n\npub fn compute_encrypted_event_log<Event, NB, MB, OB>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    event: Event\n) -> [u8; OB] where Event: EventInterface<NB, MB> {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    let eph_sk: Scalar = fr_to_fq(unsafe_rand());\n    let eph_pk = eph_sk.derive_public_key();\n\n    // TODO: (#7177) This value needs to be populated!\n    let recipient = AztecAddress::from_field(0);\n\n    let ivpk_app = compute_ivpk_app(ivpk, contract_address);\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_Header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_event(event, randomness).compute_ciphertext(eph_sk, ivpk_app);\n    let outgoing_body_ciphertext: [u8; 176] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk_app).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; OB] = [0; OB];\n    // @todo We ignore the tags for now \n\n    let eph_pk_bytes = pub_key_to_bytes(eph_pk);\n    for i in 0..64 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[128 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[176 + i] = outgoing_Header_ciphertext[i];\n    }\n    for i in 0..176 {\n        encrypted_bytes[224 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = OB - 400;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[400 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (64 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (176 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\npub fn compute_encrypted_note_log<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> [u8; M] where Note: NoteInterface<N, NB> {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    let eph_sk: Scalar = fr_to_fq(unsafe_rand());\n    let eph_pk = eph_sk.derive_public_key();\n\n    // TODO: (#7177) This value needs to be populated!\n    let recipient = AztecAddress::from_field(0);\n\n    let ivpk_app = compute_ivpk_app(ivpk, contract_address);\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_Header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_note(note, storage_slot).compute_ciphertext(eph_sk, ivpk_app);\n    let outgoing_body_ciphertext: [u8; 176] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk_app).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now \n\n    let eph_pk_bytes = pub_key_to_bytes(eph_pk);\n    for i in 0..64 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[128 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[176 + i] = outgoing_Header_ciphertext[i];\n    }\n    for i in 0..176 {\n        encrypted_bytes[224 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 400;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[400 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (64 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (176 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field elememt to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let r_bytes = r.to_be_bytes(32);\n\n    let mut high_bytes = [0; 32];\n    let mut low_bytes = [0; 32];\n\n    for i in 0..16 {\n        high_bytes[16 + i] = r_bytes[i];\n        low_bytes[16 + i] = r_bytes[i + 16];\n    }\n\n    let low = bytes32_to_field(low_bytes);\n    let high = bytes32_to_field(high_bytes);\n\n    Scalar::new(low, high)\n}\n\nfn compute_ivpk_app(ivpk: Point, contract_address: AztecAddress) -> Point {\n    // It is useless to compute this, it brings no value to derive fully.\n    // Issue(#6955)\n    ivpk\n    /*\n    // @todo Just setting infinite to false, but it should be checked.\n    // for example user could define ivpk = infinity using the registry\n    assert((ivpk.x != 0) & (ivpk.y != 0), \"ivpk is infinite\");\n\n    let i = fr_to_fq(poseidon2_hash([contract_address.to_field(), ivpk.x, ivpk.y, GENERATOR_INDEX__IVSK_M]));\n    let I = i.derive_public_key();\n\n    let embed_I = Point { x: I.x, y: I.y, is_infinite: false };\n    let embed_ivpk = Point { x: ivpk.x, y: ivpk.y, is_infinite: false };\n\n    let embed_result = embedded_curve_add(embed_I, embed_ivpk);\n\n    Point::new(embed_result.x, embed_result.y)*/\n}\n"},"103":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    encrypted_logs::payload::compute_encrypted_note_log, oracle::logs_traits::LensForEncryptedLog\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field, address::AztecAddress, point::Point, abis::note_hash::NoteHash,\n    constants::MAX_NOTE_HASHES_PER_CALL, utils::arrays::find_index\n};\n\nunconstrained fn compute_unconstrained<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    compute(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note)\n}\n\nfn compute<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let encrypted_log: [u8; M] = compute_encrypted_note_log(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note);\n    let log_hash = sha256_to_field(encrypted_log);\n    (encrypted_log, log_hash)\n}\n\nfn emit_with_keys<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    note: Note,\n    ovpk: Point,\n    ivpk: Point,\n    inner_compute: fn(AztecAddress, Field, Field, Point, Point, Note) -> ([u8; M], Field)\n) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    let note_exists_index = find_index(\n        context.note_hashes.storage,\n        |n: NoteHash| n.counter == note_hash_counter\n    );\n    assert(\n        note_exists_index as u32 != MAX_NOTE_HASHES_PER_CALL, \"Can only emit a note log for an existing note.\"\n    );\n\n    let contract_address: AztecAddress = context.this_address();\n    let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n    let (encrypted_log, log_hash) = inner_compute(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n\npub fn encode_and_encrypt_note<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let header = context.get_header();\n        let ovpk = header.get_ovpk_m(context, ov);\n        let ivpk = header.get_ivpk_m(context, iv);\n        emit_with_keys(context, e.note, ovpk, ivpk, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let header = context.get_header();\n        let ovpk = header.get_ovpk_m(context, ov);\n        let ivpk = header.get_ivpk_m(context, iv);\n        emit_with_keys(context, e.note, ovpk, ivpk, compute_unconstrained);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ovpk: Point,\n    ivpk: Point\n) -> fn[(&mut PrivateContext, Point, Point)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys_unconstrained<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ovpk: Point,\n    ivpk: Point\n) -> fn[(&mut PrivateContext, Point, Point)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, compute_unconstrained);\n    }\n}\n"},"104":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/outgoing_body.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash\n};\n\nuse std::aes128::aes128_encrypt;\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nstruct EncryptedLogOutgoingBody {\n    eph_sk: Scalar,\n    recipient: AztecAddress,\n    recipient_ivpk_app: Point,\n}\n\nimpl EncryptedLogOutgoingBody {\n    pub fn new(eph_sk: Scalar, recipient: AztecAddress, recipient_ivpk_app: Point) -> Self {\n        Self { eph_sk, recipient, recipient_ivpk_app }\n    }\n\n    pub fn compute_ciphertext(self, ovsk_app: Scalar, eph_pk: Point) -> [u8; 176] {\n        // Again, we could compute `eph_pk` here, but we keep the interface more similar\n        // and also make it easier to optimise it later as we just pass it along\n\n        let mut buffer: [u8; 160] = [0; 160];\n\n        let serialized_eph_sk_high = self.eph_sk.hi.to_be_bytes(32);\n        let serialized_eph_sk_low = self.eph_sk.lo.to_be_bytes(32);\n\n        let address_bytes = self.recipient.to_field().to_be_bytes(32);\n        let serialized_recipient_ivpk_app = self.recipient_ivpk_app.serialize();\n        let serialized_recipient_ivpk_app_x = serialized_recipient_ivpk_app[0].to_be_bytes(32);\n        let serialized_recipient_ivpk_app_y = serialized_recipient_ivpk_app[1].to_be_bytes(32);\n\n        for i in 0..32 {\n            buffer[i] = serialized_eph_sk_high[i];\n            buffer[i + 32] = serialized_eph_sk_low[i];\n            buffer[i + 64] = address_bytes[i];\n            buffer[i + 96] = serialized_recipient_ivpk_app_x[i];\n            buffer[i + 128] = serialized_recipient_ivpk_app_y[i];\n        }\n\n        // We compute the symmetric key using poseidon.\n        let full_key: [u8; 32] = poseidon2_hash(\n            [\n            ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y,\n            GENERATOR_INDEX__SYMMETRIC_KEY as Field\n        ]\n        ).to_be_bytes(32).as_array();\n\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(buffer, iv, sym_key).as_array()\n    }\n}\n\nmod test {\n    use crate::encrypted_logs::outgoing_body::EncryptedLogOutgoingBody;\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, hash::poseidon2_hash\n    };\n\n    use crate::context::PrivateContext;\n\n    #[test]\n    fn test_encrypted_log_outgoing_body() {\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        );\n        let recipient_ivsk_app = Scalar::new(\n            0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        );\n        let sender_ovsk_app = Scalar::new(\n            0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        );\n\n        let eph_pk = eph_sk.derive_public_key();\n        let recipient_ivpk_app = recipient_ivsk_app.derive_public_key();\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let body = EncryptedLogOutgoingBody::new(eph_sk, recipient, recipient_ivpk_app);\n\n        let ciphertext = body.compute_ciphertext(sender_ovsk_app, eph_pk);\n\n        let expected_outgoing_body_ciphertext = [\n            127, 84, 96, 176, 101, 107, 236, 57, 68, 8, 53, 202, 138, 74, 186, 54, 74, 193, 245, 7, 109, 59, 218, 33, 1, 31, 205, 225, 241, 209, 64, 222, 94, 245, 4, 150, 47, 241, 187, 64, 152, 20, 102, 158, 200, 217, 213, 82, 1, 240, 170, 185, 51, 80, 27, 109, 63, 231, 235, 120, 174, 44, 133, 248, 10, 97, 60, 40, 222, 190, 147, 76, 187, 48, 91, 206, 48, 106, 56, 118, 38, 127, 82, 4, 182, 188, 44, 224, 31, 129, 47, 107, 134, 252, 20, 25, 122, 191, 158, 69, 35, 255, 215, 171, 196, 45, 91, 184, 83, 80, 238, 201, 1, 233, 235, 159, 171, 130, 158, 64, 176, 165, 132, 30, 84, 81, 71, 195, 145, 47, 82, 247, 210, 192, 23, 4, 220, 90, 56, 109, 46, 105, 79, 251, 165, 141, 185, 233, 191, 118, 219, 153, 191, 162, 99, 238, 241, 249, 9, 74, 210, 241, 54, 28, 126, 226, 85, 235, 174, 75, 239, 207, 100, 184, 248, 194\n        ];\n\n        for i in 0..expected_outgoing_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_outgoing_body_ciphertext[i]);\n        }\n        assert_eq(expected_outgoing_body_ciphertext.len(), ciphertext.len());\n    }\n}\n"},"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\nstruct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext(self, secret: Scalar, point: Point) -> [u8; 48] {\n        let full_key = point_to_symmetric_key(secret, point);\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes(32).as_array();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nfn test_encrypted_log_header() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar::new(\n        0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    );\n    let point = Point::new(\n        0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        false\n    );\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    let expected_header_ciphertext = [\n        228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 23, 131, 32, 226, 26, 176, 43, 39, 239, 177, 177, 192, 85, 216, 17, 15, 18, 187, 35, 225, 135, 192, 63, 88, 29, 173, 232, 46, 72, 82, 187, 139\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext);\n}\n"},"106":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/incoming_body.nr","source":"use crate::note::note_interface::NoteInterface;\nuse crate::event::event_interface::EventInterface;\nuse dep::protocol_types::{scalar::Scalar, point::Point};\n\nuse std::aes128::aes128_encrypt;\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nstruct EncryptedLogIncomingBody<M> {\n    plaintext: [u8; M]\n}\n\nimpl<M> EncryptedLogIncomingBody<M> {\n    pub fn from_note<T, N>(note: T, storage_slot: Field) -> Self where T: NoteInterface<N, M> {\n        let mut plaintext = note.to_be_bytes(storage_slot);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn from_event<T, MR>(event: T, randomness: Field) -> Self where T: EventInterface<M, MR> {\n        let mut plaintext = event.private_to_be_bytes(randomness);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn compute_ciphertext(self, eph_sk: Scalar, ivpk_app: Point) -> [u8] {\n        let full_key = point_to_symmetric_key(eph_sk, ivpk_app);\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(self.plaintext, iv, sym_key)\n    }\n}\n\nmod test {\n    use crate::encrypted_logs::incoming_body::EncryptedLogIncomingBody;\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, traits::Serialize, abis::event_selector::EventSelector\n    };\n\n    use crate::{\n        note::{note_header::NoteHeader, note_interface::NoteInterface},\n        event::event_interface::EventInterface, oracle::unsafe_rand::unsafe_rand,\n        context::PrivateContext\n    };\n\n    struct AddressNote {\n        address: AztecAddress,\n        owner: AztecAddress,\n        randomness: Field,\n        header: NoteHeader,\n    }\n\n    global ADDRESS_NOTE_LEN: Field = 3;\n    global ADDRESS_NOTE_BYTES_LEN = 32 * 3 + 64;\n\n    impl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n        fn compute_note_content_hash(self) -> Field {1}\n\n        fn get_note_type_id() -> Field {\n            1\n        }\n\n        fn get_header(self) -> NoteHeader { self.header}\n\n        fn set_header(&mut self, header: NoteHeader) {self.header = header; }\n\n        fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n            (1, 1)\n        }\n\n        fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {(1,1)}\n\n        fn serialize_content(self) -> [Field; ADDRESS_NOTE_LEN] { [self.address.to_field(), self.owner.to_field(), self.randomness]}\n\n        fn deserialize_content(fields: [Field; ADDRESS_NOTE_LEN]) -> Self {\n            AddressNote { address: AztecAddress::from_field(fields[0]), owner: AztecAddress::from_field(fields[1]), randomness: fields[2], header: NoteHeader::empty() }\n        }\n\n        fn to_be_bytes(self, storage_slot: Field) -> [u8; ADDRESS_NOTE_BYTES_LEN] {\n            let serialized_note = self.serialize_content();\n\n            let mut buffer: [u8; ADDRESS_NOTE_BYTES_LEN] = [0; ADDRESS_NOTE_BYTES_LEN];\n\n            let storage_slot_bytes = storage_slot.to_be_bytes(32);\n            let note_type_id_bytes = AddressNote::get_note_type_id().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = storage_slot_bytes[i];\n                buffer[32 + i] = note_type_id_bytes[i];\n            }\n\n            for i in 0..serialized_note.len() {\n                let bytes = serialized_note[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n            buffer\n        }\n    }\n\n    impl AddressNote {\n        pub fn new(address: AztecAddress, owner: AztecAddress, randomness: Field) -> Self {\n            AddressNote { address, owner, randomness, header: NoteHeader::empty() }\n        }\n    }\n\n    #[test]\n    fn test_encrypted_note_log_incoming_body() {\n        let note = AddressNote::new(\n            AztecAddress::from_field(0x1),\n            AztecAddress::from_field(0x2),\n            3\n        );\n\n        let storage_slot = 2;\n\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        );\n        let ivpk_app = Point::new(\n            0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            false\n        );\n\n        let body = EncryptedLogIncomingBody::from_note(note, storage_slot);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk_app);\n\n        let expected_note_body_ciphertext = [\n            228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 63, 127, 188, 251, 150, 188, 238, 205, 3, 86, 102, 164, 175, 12, 137, 158, 163, 111, 205, 10, 229, 230, 46, 202, 110, 107, 156, 180, 67, 192, 161, 201, 48, 153, 169, 1, 25, 182, 93, 39, 39, 207, 251, 218, 234, 147, 156, 13, 110, 180, 190, 199, 41, 6, 211, 203, 176, 110, 165, 186, 110, 127, 199, 22, 201, 149, 92, 249, 219, 68, 145, 68, 179, 29, 233, 34, 98, 123, 197, 234, 169, 53, 44, 14, 81, 60, 92, 27, 250, 134, 49, 248, 57, 119, 236, 118, 158, 104, 82, 243, 98, 164, 60, 72, 74, 27, 177, 194, 221, 225, 193, 150, 67, 235, 205, 106, 150, 24, 126, 186, 220, 178, 199, 189, 113, 54, 181, 55, 46, 15, 236, 236, 9, 159, 5, 172, 237, 154, 110, 50, 241, 64, 92, 13, 37, 53, 20, 140, 42, 146, 229, 63, 97, 25, 159, 63, 235, 104, 68, 100\n        ];\n\n        assert_eq(expected_note_body_ciphertext.len(), ciphertext.len());\n\n        for i in 0..expected_note_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_note_body_ciphertext[i]);\n        }\n    }\n\n    struct TestEvent {\n        value0: Field,\n        value1: Field,\n        value2: Field,\n    }\n\n    impl Serialize<3> for TestEvent {\n        fn serialize(self) -> [Field; 3] {\n            [self.value0, self.value1, self.value2]\n        }\n    }\n\n    global TEST_EVENT_LEN: Field = 3;\n    global TEST_EVENT_BYTES_LEN = 32 * 3 + 64;\n    global TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS = 32 * 3 + 32;\n\n    impl EventInterface<TEST_EVENT_BYTES_LEN, TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS> for TestEvent {\n        fn get_event_type_id() -> EventSelector {\n            EventSelector::from_signature(\"TestEvent(Field,Field,Field)\")\n        }\n\n        fn private_to_be_bytes(self, randomness: Field) -> [u8; TEST_EVENT_BYTES_LEN] {\n            let mut buffer: [u8; TEST_EVENT_BYTES_LEN] = [0; TEST_EVENT_BYTES_LEN];\n\n            let randomness_bytes = randomness.to_be_bytes(32);\n            let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = randomness_bytes[i];\n                buffer[32 + i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes = serialized_event[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn to_be_bytes(self) -> [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] {\n             let mut buffer: [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] = [0; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS];\n\n             let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n             for i in 0..32 {\n                 buffer[i] = event_type_id_bytes[i];\n            }\n\n             let serialized_event = self.serialize();\n\n             for i in 0..serialized_event.len() {\n                 let bytes = serialized_event[i].to_be_bytes(32);\n                 for j in 0..32 {\n                     buffer[32 + i * 32 + j] = bytes[j];\n                }\n            }\n\n             buffer\n        }\n\n        fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n            _emit(self);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_event_incoming_body() {\n        let test_event = TestEvent { value0: 1, value1: 2, value2: 3 };\n\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        );\n\n        let ivpk_app = Point::new(\n            0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            false\n        );\n\n        let randomness = 2;\n\n        let body = EncryptedLogIncomingBody::from_event(test_event, randomness);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk_app);\n\n        let expected_event_body_ciphertext = [\n            228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 63, 127, 188, 251, 150, 188, 238, 205, 3, 86, 102, 164, 175, 12, 137, 158, 163, 111, 205, 10, 229, 230, 46, 202, 110, 107, 156, 180, 67, 192, 161, 201, 66, 122, 29, 35, 42, 33, 153, 216, 199, 208, 103, 207, 126, 153, 189, 136, 19, 220, 238, 15, 169, 29, 255, 11, 123, 107, 70, 192, 53, 40, 36, 93, 187, 32, 123, 136, 104, 23, 229, 245, 152, 90, 84, 2, 136, 112, 42, 27, 82, 214, 104, 14, 250, 48, 199, 245, 88, 22, 200, 77, 38, 51, 127, 56, 138, 255, 16, 46, 179, 129, 215, 185, 185, 116, 148, 16, 133, 62, 56, 180, 10, 132, 109, 77, 206, 199, 21, 167, 7, 163, 171, 158, 244, 23, 18, 121, 108, 42, 107, 7, 48, 84, 212, 104, 39, 16, 109, 7, 108, 129, 60, 80, 112, 241, 223, 140, 186, 158, 38, 74, 230, 213, 159, 175, 142, 228, 128, 160\n        ];\n\n        assert_eq(expected_event_body_ciphertext.len(), ciphertext.len());\n\n        for i in 0..expected_event_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_event_body_ciphertext[i]);\n        }\n    }\n}\n"},"112":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__INNER_NOTE_HASH,\n    hash::{\n    pedersen_hash, compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_inner_note_hash_from_preimage(storage_slot: Field, note_content_hash: Field) -> Field {\n    pedersen_hash(\n        [storage_slot, note_content_hash],\n        GENERATOR_INDEX__INNER_NOTE_HASH\n    )\n}\n\nfn compute_inner_note_hash<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    compute_inner_note_hash_from_preimage(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N, M>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let (_, inner_nullifier) = note_with_header.compute_note_hash_and_nullifier(context);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\nfn compute_note_hash_for_read_request_from_innter_and_nonce(\n    inner_note_hash: Field,\n    nonce: Field\n) -> Field {\n    // TODO(#1386): This if-else can be nuked once we have nonces injected from public\n    if (nonce == 0) {\n        // If nonce is zero, that means we are reading a public note.\n        inner_note_hash\n    } else {\n        compute_unique_note_hash(nonce, inner_note_hash)\n    }\n}\n\npub fn compute_note_hash_for_read_request<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let inner_note_hash = compute_inner_note_hash(note);\n    let nonce = note.get_header().nonce;\n\n    compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, nonce)\n}\n\npub fn compute_note_hash_for_consumption<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    if (header.note_hash_counter != 0) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        inner_note_hash\n    } else {\n        // If a note is not transient, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the siloed_note_hash which has already been hashed with\n        // nonce and then contract address. This hash will match the existing leaf in the note hash\n        // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, header.nonce);\n        compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, N, M, S>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n    let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, note_header.nonce);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        let (_, nullifier) = note.compute_note_hash_and_nullifier_without_context();\n        nullifier\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [inner_note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"113":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_inner_note_hash, compute_note_hash_for_consumption}, note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let inner_note_hash = compute_inner_note_hash(*note);\n\n    let serialized_note = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash,\n        note_hash_counter\n    )\n        == 0\n    );\n\n    context.push_note_hash(inner_note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, N, M>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let inner_note_hash = compute_inner_note_hash(*note);\n\n    context.push_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let (note_hash, nullifier) = note.compute_note_hash_and_nullifier(context);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let note_hash_for_consumption = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a non-transient note and we don't populate the note_hash with real\n        // value (if we did so the `notifyNullifiedNote` oracle would throw).\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a transient note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can find it and squash both\n        // the note and the nullifier.\n        note_hash\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    assert(notify_nullified_note(nullifier, note_hash_for_consumption, nullifier_counter) == 0);\n\n    context.push_nullifier(nullifier, note_hash_for_consumption)\n}\n"},"114":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\nstruct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting  \n * a change note in a token's transfer function only when there is \"change\" left).\n */\nstruct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(self) {}\n}\n"},"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"122":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::{compute_siloed_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_contract_initialization_nullifier(context.this_address());\n    let header = context.get_header();\n    header.prove_nullifier_inclusion(init_nullifier);\n}\n\nfn compute_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    compute_siloed_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(address)\n    )\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"123":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr","source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"},"124":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::{address::AztecAddress, point::Point};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<M>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<M>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<M>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32\n) {}\n\nunconstrained pub fn emit_encrypted_event_log<M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<N, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<N, M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\n}\n"},"125":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"128":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n"},"132":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<N>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field\n) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number as Field, N)\n}\n\nunconstrained pub fn storage_read<T, N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"133":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/unsafe_rand.nr","source":"#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n\n// Called `unsafe_rand` because we do not constrain in circuit that we are dealing with an actual random value.\n// Instead we just trust our PXE.\nunconstrained pub fn unsafe_rand() -> Field {\n    rand_oracle()\n}\n"},"135":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n"},"136":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use crate::keys::PublicKeys;\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained fn get_public_keys_and_partial_address_oracle_wrapper(address: AztecAddress) -> [Field; 13] {\n    get_public_keys_and_partial_address_oracle(address)\n}\n\nfn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle_wrapper(address);\n\n    let keys = PublicKeys {\n        npk_m: Point::new(result[0], result[1], result[2] as bool),\n        ivpk_m: Point::new(result[3], result[4], result[5] as bool),\n        ovpk_m: Point::new(result[6], result[7], result[8] as bool),\n        tpk_m: Point::new(result[9], result[10], result[11] as bool)\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"138":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        inner_note_hash,\n        counter\n    )\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field, _counter: u32) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(\n    nullifier: Field,\n    inner_note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash, counter)\n}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, NB, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N, NB> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n// Only ever use this in private!\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n// Only ever use this in private!\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n"},"139":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"140":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{\n    abis::{\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\n    utils::reader::Reader,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n}\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\n    let mut reader = Reader::new(fields);\n\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n    // WARNING: if updating, see comment in public_call_stack_item.ts's PublicCallStackItem.hash()\n    let item = PublicCallStackItem {\n        contract_address: AztecAddress::from_field(reader.read()),\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\n        public_inputs: PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            args_hash: reader.read(),\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            end_side_effect_counter: 0,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0\n        },\n        is_execution_request: true\n    };\n    reader.finish();\n\n    item\n}\n"},"148":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr","source":"use crate::{\n    context::{PublicContext, UnconstrainedContext}, oracle::storage::storage_read,\n    state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like SharedImmutable but without the ability to read from private functions.\n// docs:start:public_immutable_struct\nstruct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\nimpl<T, Context> Storage<T> for PublicImmutable<T, Context> {}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl <T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UnconstrainedContext> {\n    unconstrained pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"149":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr","source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext}, oracle::storage::storage_read,\n    state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PublicContext> {\n    // Intended to be only called once. \n    pub fn initialize<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T> SharedImmutable<T, UnconstrainedContext> {\n    unconstrained pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PrivateContext> {\n    pub fn read_private<T_SERIALIZED_LEN>(self) -> T  where T: Deserialize<T_SERIALIZED_LEN> {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n"},"153":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr","source":"use dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE, lifecycle::{create_note, create_note_hash_from_public, destroy_note},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader, note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note> PrivateSet<Note, &mut PublicContext> {\n    // docs:start:insert_from_public\n    pub fn insert_from_public<N, M>(self, note: &mut Note) where Note: NoteInterface<N, M> {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note> PrivateSet<Note, &mut PrivateContext> {\n    // docs:start:insert\n    pub fn insert<N, M>(self, note: &mut Note) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    // docs:start:remove\n    pub fn remove<N, M>(self, note: Note) where Note: NoteInterface<N, M> {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read = self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note(self.context, note);\n    }\n    // docs:end:remove\n\n    // docs:start:get_notes\n    pub fn get_notes<N, M, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> where Note: NoteInterface<N, M> {\n        get_notes(self.context, self.storage_slot, options)\n    }\n    // docs:end:get_notes\n}\n\nimpl<Note> PrivateSet<Note, UnconstrainedContext> {\n    // docs:start:view_notes\n    unconstrained pub fn view_notes<N, M>(\n        self,\n        options: NoteViewerOptions<Note, N, M>\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N, M> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"},"155":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_delay_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initally equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation \n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the \n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a \n// reduced delay, invalidating prior private reads.\nstruct ScheduledDelayChange<INITIAL_DELAY> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option, \n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pre: Option<u32>,\n    post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numeric value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\nimpl<INITIAL_DELAY> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior contraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This \n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is \n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in \n            //                             which to scheduled value change\n\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY)\n            )\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Serialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn serialize(self) -> [Field; 1] {\n        // We pack all three u32 values into a single U128, which is made up of two u64 limbs.\n        // Low limb: [ pre_inner: u32 | post_inner: u32 ]\n        // High limb: [ empty | pre_is_some: u8 |  post_is_some: u8 | block_of_change: u32 ]\n\n        let lo = ((self.pre.unwrap_unchecked() as u64) * (1 << 32))\n            + (self.post.unwrap_unchecked() as u64);\n\n        let hi = (self.pre.is_some() as u64) * (1 << 33) \n            + (self.post.is_some() as u64 * (1 << 32)) \n            + self.block_of_change as u64;\n\n        let packed = U128::from_u64s_le(lo, hi);\n\n        [packed.to_integer()]\n    }\n}\n\nimpl<INITIAL_DELAY> Deserialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn deserialize(input: [Field; 1]) -> Self {\n        let packed = U128::from_integer(input[0]);\n\n        // We use division and modulo to clear the bits that correspond to other values when unpacking.\n\n        let pre_is_some = ((packed.hi as u64) / (1 << 33)) as bool;\n        let pre_inner = ((packed.lo as u64) / (1 << 32)) as u32;\n\n        let post_is_some = (((packed.hi as u64) / (1 << 32)) % (1 << 1)) as bool;\n        let post_inner = ((packed.lo as u64) % (1 << 32)) as u32;\n\n        let block_of_change = ((packed.hi as u64) % (1 << 32)) as u32;\n\n        Self {\n            pre: if pre_is_some { Option::some(pre_inner) } else { Option::none() },\n            post: if post_is_some { Option::some(post_inner) } else { Option::none() },\n            block_of_change,\n            _dummy: [0; INITIAL_DELAY],\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"157":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable_private_getter.nr","source":"use dep::protocol_types::{\n    hash::{pedersen_hash, poseidon2_hash}, traits::{FromField, ToField}, address::AztecAddress,\n    header::Header\n};\n\nuse crate::context::PrivateContext;\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{\n    shared_mutable::SharedMutable, scheduled_delay_change::ScheduledDelayChange,\n    scheduled_value_change::ScheduledValueChange\n}\n};\n\nstruct SharedMutablePrivateGetter<T, INITIAL_DELAY> {\n    context: &mut PrivateContext,\n    // The contract address of the contract we want to read from\n    other_contract_address: AztecAddress,\n    // The storage slot where the SharedMutable is stored on the other contract\n    storage_slot: Field,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numberic value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\n// We have this as a view-only interface to reading Shared Mutables in other contracts.\n// Currently the Shared Mutable does not support this. We can adapt SharedMutable at a later date\nimpl<T, INITIAL_DELAY> SharedMutablePrivateGetter<T, INITIAL_DELAY> {\n    pub fn new(\n        context: &mut PrivateContext,\n        other_contract_address: AztecAddress,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        assert(other_contract_address.to_field() != 0, \"Other contract address cannot be 0\");\n        Self { context, other_contract_address, storage_slot, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    pub fn get_value_in_private(self, header: Header) -> T where T: FromField + ToField + Eq {\n        // We create a dummy SharedMutable state variable so that we can reuse its historical_read_from_public_storage\n        // method, greatly reducing code duplication. \n        let dummy: SharedMutable<T, INITIAL_DELAY, ()> = SharedMutable::new((), self.storage_slot);\n        let (value_change, delay_change, historical_block_number) = dummy.historical_read_from_public_storage(header, self.other_contract_address);\n\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // If our context has the same header as the one we pass in via the parameter, we are trying to read the \"current\" value\n        // and thus need to set the tx max block number below. If the context header is not the same as the one we pass in, this means\n        // we are trying to read a historical value and thus have no constraint on the max block number that this transaction can be included in.\n        if (self.context.historical_header.global_variables.block_number.eq(header.global_variables.block_number)) {\n            self.context.set_tx_max_block_number(block_horizon);\n        }\n\n        value_change.get_current_at(historical_block_number)\n    }\n}\n"},"159":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_value_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\nstruct ScheduledValueChange<T> {\n    pre: T,\n    post: T,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Serialize<3> for ScheduledValueChange<T> {\n    fn serialize(self) -> [Field; 3] where T: ToField {\n        [self.pre.to_field(), self.post.to_field(), self.block_of_change.to_field()]\n    }\n}\n\nimpl<T> Deserialize<3> for ScheduledValueChange<T> {\n  fn deserialize(input: [Field; 3]) -> Self  where T: FromField {\n    Self {\n        pre: FromField::from_field(input[0]),\n        post: FromField::from_field(input[1]),\n        block_of_change: FromField::from_field(input[2]),\n    }\n  }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>  {\n    fn eq(self, other: Self) -> bool where T: Eq {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"160":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable.nr","source":"use dep::protocol_types::{\n    hash::{pedersen_hash, poseidon2_hash}, header::Header, address::AztecAddress,\n    traits::{FromField, ToField}\n};\n\nuse crate::context::{PrivateContext, PublicContext};\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{scheduled_value_change::ScheduledValueChange, scheduled_delay_change::ScheduledDelayChange}\n};\nuse crate::oracle::storage::storage_read;\nuse dep::std::unsafe::zeroed;\n\nmod test;\n\nstruct SharedMutable<T, INITIAL_DELAY, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Serialize<N> trait, and allocate N storage slots to\n// this state variable. This is incorrect, since what we actually store is:\n//  - a ScheduledValueChange<T>, which requires 1 + 2 * M storage slots, where M is the serialization length of T\n//  - a ScheduledDelayChange, which requires another storage slot\n//\n// TODO https://github.com/AztecProtocol/aztec-packages/issues/5736: change the storage allocation scheme so that we\n// can actually use it here\nimpl<T, INITIAL_DELAY, Context> Storage<T> for SharedMutable<T, INITIAL_DELAY, Context> {}\n\n// TODO: extract into a utils module once  we can do arithmetic on generics, i.e. https://github.com/noir-lang/noir/issues/4784\nfn concat_arrays<N, M, O>(arr_n: [Field; N], arr_m: [Field; M]) -> [Field; O] {\n    assert_eq(N + M, O);\n    let mut out: [Field; O] = [0; O];\n    for i in 0..N {\n        out[i] = arr_n[i];\n    }\n    for i in 0..M {\n        out[N+i] = arr_m[i];\n    }\n    out\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, INITIAL_DELAY, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    fn hash_scheduled_data(\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) -> Field where T: ToField {\n        // TODO(#5491 and https://github.com/noir-lang/noir/issues/4784): update this so that we don't need to rely on\n        // ScheduledValueChange serializing to 3 and ScheduledDelayChange serializing to 1\n        let concatenated: [Field; 4] = concat_arrays(value_change.serialize(), delay_change.serialize());\n        poseidon2_hash(concatenated)\n    }\n\n    // Since we can't rely on the native storage allocation scheme, we hash the storage slot to get a unique location in\n    // which we can safely store as much data as we need.\n    // See https://github.com/AztecProtocol/aztec-packages/issues/5492 and\n    // https://github.com/AztecProtocol/aztec-packages/issues/5736\n    // We store three things in public storage:\n    //  - a ScheduledValueChange\n    //  - a ScheduledDelaChange\n    //  - the hash of both of these (via `hash_scheduled_data`)\n    fn get_value_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 0], 0)\n    }\n\n    fn get_delay_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 1], 0)\n    }\n\n    fn get_hash_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 2], 0)\n    }\n\n    // It may seem odd that we take a header and address instead of reading from e.g. a PrivateContext, but this lets us\n    // reuse this function in SharedMutablePrivateGetter.\n    fn historical_read_from_public_storage(\n        self,\n        header: Header,\n        address: AztecAddress\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) where T: FromField + ToField + Eq {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for both the ScheduledValueChange and\n        // ScheduledDelayChange, but that'd require one full sibling path per storage slot (since due to kernel siloing\n        // the storage is not contiguous), and in the best case in which T is a single field that'd be 4 slots.\n        // Instead, we get an oracle to provide us the correct values for both the value and delay changes, and instead\n        // prove inclusion of their hash, which is both a much smaller proof (a single slot), and also independent of\n        // the size of T.\n        let (value_change_hint, delay_change_hint) = get_public_storage_hints(address, self.storage_slot, historical_block_number);\n\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let hash = header.public_storage_historical_read(self.get_hash_storage_slot(), address);\n\n        // @todo This is written strangely to bypass a formatting issue with the if that is breaking ci.\n        let (a, b, c) = if hash != 0 {\n            let a = SharedMutable::hash_scheduled_data(value_change_hint, delay_change_hint);\n            (a, value_change_hint, delay_change_hint)\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized, meaning no value or delay change was ever\n            // scheduled. Therefore, the hints must then correspond to uninitialized scheduled changes.\n            let b = ScheduledValueChange::deserialize(zeroed());\n            let c = ScheduledDelayChange::deserialize(zeroed());\n            (hash, b, c)\n        };\n\n        assert_eq(hash, a, \"Hint values do not match hash\");\n        assert_eq(value_change_hint, b, \"Non-zero value change for zero hash\");\n        assert_eq(delay_change_hint, c, \"Non-zero delay change for zero hash\");\n\n        (value_change_hint, delay_change_hint, historical_block_number)\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PublicContext> {\n    pub fn schedule_value_change(self, new_value: T) where T: ToField {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) where T: ToField {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value_in_public(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay_in_public(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value_in_public(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay_in_public(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        self.context.storage_read(self.get_delay_change_storage_slot())\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) where T: ToField {\n        // Whenever we write to public storage, we write both the value change and delay change as well as the hash of\n        // them both. This guarantees that the hash is always kept up to date.\n        // While this makes for more costly writes, it also makes private proofs much simpler because they only need to\n        // produce a historical proof for the hash, which results in a single inclusion proof (as opposed to 4 in the\n        // best case scenario in which T is a single field). Private shared mutable reads are assumed to be much more\n        // frequent than public writes, so this tradeoff makes sense.\n        self.context.storage_write(self.get_value_change_storage_slot(), value_change);\n        self.context.storage_write(self.get_delay_change_storage_slot(), delay_change);\n        self.context.storage_write(\n            self.get_hash_storage_slot(),\n            SharedMutable::hash_scheduled_data(value_change, delay_change)\n        );\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext> {\n    pub fn get_current_value_in_private(self) -> T where T: FromField + ToField + Eq {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n\n        let (value_change, delay_change, historical_block_number) = self.historical_read_from_public_storage(self.context.get_header(), self.context.this_address());\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n}\n\nunconstrained fn get_public_storage_hints<T, INITIAL_DELAY>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>) {\n    // This function cannot be part of the &mut PrivateContext impl because that'd mean that by passing `self` we'd also\n    // be passing a mutable reference to an unconstrained function, which is not allowed. We therefore create a dummy\n    // state variable here so that we can access the methods to compute storage slots. This will all be removed in the\n    // future once we do proper storage slot allocation (#5492).\n    let dummy = SharedMutable::new((), storage_slot);\n\n    (\n        storage_read(address, dummy.get_value_change_storage_slot(), block_number), storage_read(address, dummy.get_delay_change_storage_slot(), block_number)\n    )\n}\n"},"167":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{GAS_LENGTH, FIXED_DA_GAS, FIXED_L2_GAS}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\n    abis::gas_fees::GasFees\n};\nuse std::ops::{Add, Sub};\n\nstruct Gas {\n    da_gas: u32,\n    l2_gas: u32,\n}\n\nimpl Gas {\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\n        Self { da_gas, l2_gas }\n    }\n\n    pub fn tx_overhead() -> Self {\n        Self { da_gas: FIXED_DA_GAS, l2_gas: FIXED_L2_GAS }\n    }\n\n    pub fn compute_fee(self, fees: GasFees) -> Field {\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.da_gas == 0) & (self.l2_gas == 0)\n    }\n\n    pub fn within(self, limits: Gas) -> bool {\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\n    }\n}\n\nimpl Add for Gas {\n    fn add(self, other: Gas) -> Self {\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\n    }\n}\n\nimpl Sub for Gas {\n    fn sub(self, other: Gas) -> Self {\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\n    }\n}\n\nimpl Serialize<GAS_LENGTH> for Gas {\n    fn serialize(self) -> [Field; GAS_LENGTH] {\n        [self.da_gas as Field, self.l2_gas as Field]\n    }\n}\n\nimpl Deserialize<GAS_LENGTH> for Gas {\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\n    }\n}\n\nimpl Eq for Gas {\n    fn eq(self, other : Gas) -> bool {\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\n    }\n}\n\nimpl Empty for Gas {\n    fn empty() -> Self {\n        Gas::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Gas::empty();\n    let serialized = item.serialize();\n    let deserialized = Gas::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n"},"169":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr","source":"use crate::{\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct NoteHash {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for NoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteHash {\n    fn eq(self, other: NoteHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter) \n    }\n}\n\nimpl Empty for NoteHash {\n    fn empty() -> Self {\n        NoteHash {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl NoteHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNoteHash {\n        ScopedNoteHash { note_hash: self, contract_address }\n    }\n}\n\nstruct ScopedNoteHash {\n    note_hash: NoteHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<NoteHash> for ScopedNoteHash {\n    fn inner(self) -> NoteHash {\n        self.note_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNoteHash {\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNoteHash {\n    fn value(self) -> Field {\n        self.note_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl Eq for ScopedNoteHash {\n    fn eq(self, other: ScopedNoteHash) -> bool {\n        (self.note_hash == other.note_hash)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedNoteHash {\n    fn empty() -> Self {\n        ScopedNoteHash {\n            note_hash: NoteHash::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\n        array_concat(self.note_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            note_hash: reader.read_struct(NoteHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNoteHash {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.note_hash.value, read_request.value(), \"Value of the note hash does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the note hash does not match read request\");\n        assert(\n            read_request.counter() > self.note_hash.counter, \"Read request counter must be greater than the counter of the note hash\"\n        );\n    }\n}\n\nimpl ScopedNoteHash {\n    pub fn expose_to_public(self) -> NoteHash {\n        // Hide the actual counter when exposing it to the public kernel.\n        NoteHash { value: self.note_hash.value, counter: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = NoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"170":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"172":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr","source":"use crate::{\n    abis::{\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    transaction::tx_context::TxContext, utils::arrays::validate_array\n};\n\nstruct PrivateCircuitPublicInputsArrayLengths {\n    note_hash_read_requests: u32,\n    nullifier_read_requests: u32,\n    key_validation_requests_and_generators: u32,\n    note_hashes: u32,\n    nullifiers: u32,\n    l2_to_l1_msgs: u32,\n    private_call_requests: u32,\n    public_call_stack_hashes: u32,\n    note_encrypted_logs_hashes: u32,\n    encrypted_logs_hashes: u32,\n    unencrypted_logs_hashes: u32,\n}\n\nimpl PrivateCircuitPublicInputsArrayLengths {\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\n        PrivateCircuitPublicInputsArrayLengths {\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\n            note_hashes: validate_array(public_inputs.note_hashes),\n            nullifiers: validate_array(public_inputs.nullifiers),\n            l2_to_l1_msgs: validate_array(public_inputs.l2_to_l1_msgs),\n            private_call_requests: validate_array(public_inputs.private_call_requests),\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\n        }\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    note_hashes: [NoteHash; MAX_NOTE_HASHES_PER_CALL],\n    nullifiers: [Nullifier; MAX_NULLIFIERS_PER_CALL],\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs: [L2ToL1Message; MAX_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    tx_context: TxContext,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.returns_hash == other.returns_hash) &\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\n        (self.is_fee_payer == other.is_fee_payer) &\n        (self.max_block_number == other.max_block_number) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\n        (self.note_hashes == other.note_hashes) &\n        (self.nullifiers == other.nullifiers) &\n        (self.private_call_requests == other.private_call_requests) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.l2_to_l1_msgs == other.l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\n        self.historical_header.eq(other.historical_header) &\n        self.tx_context.eq(other.tx_context)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\n\n        fields.extend_from_array(self.max_block_number.serialize());\n\n        for i in 0..self.note_hash_read_requests.len() {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..self.nullifier_read_requests.len() {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..self.key_validation_requests_and_generators.len() {\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\n        }\n        for i in 0..self.note_hashes.len() {\n            fields.extend_from_array(self.note_hashes[i].serialize());\n        }\n        for i in 0..self.nullifiers.len() {\n            fields.extend_from_array(self.nullifiers[i].serialize());\n        }\n        for i in 0..self.private_call_requests.len() {\n            fields.extend_from_array(self.private_call_requests[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n        fields.push(self.public_teardown_function_hash);\n        for i in 0..self.l2_to_l1_msgs.len() {\n            fields.extend_from_array(self.l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        for i in 0..self.note_encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.unencrypted_logs_hashes.len() {\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.tx_context.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            is_fee_payer: reader.read() == 1,\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL]),\n            nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL]),\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            public_teardown_function_hash: reader.read(),\n            l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            tx_context: reader.read_struct(TxContext::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PrivateCircuitPublicInputs {\n    fn empty() -> Self {\n        PrivateCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter : 0 as u32,\n            end_side_effect_counter : 0 as u32,\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            tx_context: TxContext::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PrivateCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PrivateCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x15c9b0a92b9b541598e24c9f0b0b4b04b7f2408599751c45aa12de671fd9b363;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"173":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item_compressed.nr","source":"use crate::abis::{call_context::CallContext, function_data::FunctionData, gas::Gas};\nuse crate::address::AztecAddress;\nuse crate::constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH};\nuse crate::traits::{Hash, Empty, Serialize, Deserialize};\nuse crate::utils::reader::Reader;\n\n/**\n * A compressed version of the PublicCallStackItem struct used to compute the \"hash\"\n * of a PublicCallStackItem.\n * \n * Historically, we have been zeroing most values in the PublicCallStackItem struct\n * to compute the hash involved when adding a PublicCallStackItem to the PublicCallStack.\n * \n * This struct is used to store the values that we did not zero out, and allow us to hash\n * only these, thereby skipping a lot of computation and saving us a lot of constraints\n * \n * Essentially this struct exists such that we don't have a `hash` function in the \n * PublicCallStackItem struct that practically throws away some values of the struct\n * without clearly indicating that it does so.\n */\nstruct PublicCallStackItemCompressed {\n    contract_address: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    revert_code: u8,\n    start_gas_left: Gas,\n    end_gas_left: Gas,\n}\n\nimpl Eq for PublicCallStackItemCompressed {\n    fn eq(self, other: PublicCallStackItemCompressed) -> bool {\n        (self.contract_address == other.contract_address)\n            & (self.call_context == other.call_context)\n            & (self.function_data == other.function_data)\n            & (self.args_hash == other.args_hash)\n            & (self.returns_hash == other.returns_hash)\n            & (self.revert_code == other.revert_code)\n            & (self.start_gas_left == other.start_gas_left)\n            & (self.end_gas_left == other.end_gas_left)\n    }\n}\n\nimpl Hash for PublicCallStackItemCompressed {\n    fn hash(self) -> Field {\n        std::hash::pedersen_hash_with_separator(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PublicCallStackItemCompressed {\n    fn empty() -> Self {\n        PublicCallStackItemCompressed {\n            contract_address: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n    fn serialize(self) -> [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.push(self.revert_code as Field);\n        fields.extend_from_array(self.start_gas_left.serialize());\n        fields.extend_from_array(self.end_gas_left.serialize());\n\n        assert_eq(fields.len(), PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n  fn deserialize(fields: [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH]) -> PublicCallStackItemCompressed {\n    let mut reader = Reader::new(fields);\n\n    let item = PublicCallStackItemCompressed {\n      contract_address: reader.read_struct(AztecAddress::deserialize),\n      call_context: reader.read_struct(CallContext::deserialize),\n      function_data: reader.read_struct(FunctionData::deserialize),\n      args_hash: reader.read(),\n      returns_hash: reader.read(),\n      revert_code: reader.read() as u8,\n      start_gas_left: reader.read_struct(Gas::deserialize),\n      end_gas_left: reader.read_struct(Gas::deserialize),\n    };\n    reader.finish();\n    item\n  }\n}\n"},"175":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n"},"176":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr","source":"use crate::{\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for ReadRequest {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\n        ScopedReadRequest { read_request: self, contract_address }\n    }\n}\n\nstruct ScopedReadRequest {\n    read_request: ReadRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<ReadRequest> for ScopedReadRequest {\n    fn inner(self) -> ReadRequest {\n        self.read_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ScopedReadRequest {\n    fn eq(self, other: ScopedReadRequest) -> bool {\n        (self.read_request == other.read_request)\n        & (self.contract_address.eq(other.contract_address))\n    }\n}\n\nimpl Empty for ScopedReadRequest {\n    fn empty() -> Self {\n        ScopedReadRequest {\n            read_request: ReadRequest::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            read_request: reader.read_struct(ReadRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedReadRequest {\n    pub fn value(self) -> Field {\n        self.read_request.value\n    }\n    pub fn counter(self) -> u32 {\n        self.read_request.counter\n    }\n}\n\n#[test]\nfn serialization_of_empty_read() {\n    let item = ReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"179":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr","source":"use crate::{\n    address::AztecAddress,\n    abis::validation_requests::{\n    key_validation_request::KeyValidationRequest,\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\n},\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct KeyValidationRequestAndGenerator {\n    request: KeyValidationRequest,\n    sk_app_generator: Field,\n}\n\nimpl Eq for KeyValidationRequestAndGenerator {\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\n    }\n}\n\nimpl Empty for KeyValidationRequestAndGenerator {\n    fn empty() -> Self {\n        KeyValidationRequestAndGenerator {\n            request: KeyValidationRequest::empty(),\n            sk_app_generator: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\n        array_concat(self.request.serialize(), [self.sk_app_generator])\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\n        let mut reader = Reader::new(fields);\n        let res = Self {\n            request: reader.read_struct(KeyValidationRequest::deserialize),\n            sk_app_generator: reader.read(),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl KeyValidationRequestAndGenerator {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = KeyValidationRequestAndGenerator::empty();\n    let serialized = item.serialize();\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"180":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point::new(fields[0], fields[1], fields[2] as bool),\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"183":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        EventSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"184":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr","source":"use crate::{\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH},\n    hash::compute_siloed_nullifier, traits::{Empty, Hash, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct Nullifier {\n    value: Field,\n    counter: u32,\n    note_hash: Field,\n}\n\nimpl Ordered for Nullifier {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for Nullifier {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for Nullifier {\n    fn eq(self, other: Nullifier) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.note_hash == other.note_hash) \n    }\n}\n\nimpl Empty for Nullifier {\n    fn empty() -> Self {\n        Nullifier {\n            value: 0,\n            counter: 0,\n            note_hash: 0,\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\n        [self.value, self.counter as Field, self.note_hash]\n    }\n}\n\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            note_hash: values[2],\n        }\n    }\n}\n\nimpl Readable for Nullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        // Public kernels output Nullifier instead of ScopedNullifier.\n        // The nullifier value has been siloed.\n        let siloed_request_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.value, siloed_request_value, \"Value of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl Nullifier {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\n        ScopedNullifier { nullifier: self, contract_address }\n    }\n}\n\nstruct ScopedNullifier {\n    nullifier: Nullifier,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<Nullifier> for ScopedNullifier {\n    fn inner(self) -> Nullifier {\n        self.nullifier\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNullifier {\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNullifier {\n    fn value(self) -> Field {\n        self.nullifier.value\n    }\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl Eq for ScopedNullifier {\n    fn eq(self, other: ScopedNullifier) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedNullifier {\n    fn empty() -> Self {\n        ScopedNullifier {\n            nullifier: Nullifier::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            nullifier: reader.read_struct(Nullifier::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.nullifier.value, read_request.value(), \"Value of the nullifier does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.nullifier.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl ScopedNullifier {\n    pub fn nullified_note_hash(self) -> Field {\n        self.nullifier.note_hash\n    }\n\n    pub fn expose_to_public(self) -> Nullifier {\n        // Hide the actual counter and note hash when exposing it to the public kernel.\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Nullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = Nullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"192":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr","source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n  fn eq(self, other: Self) -> bool {\n    (self.nullifier == other.nullifier) &\n    (self.next_nullifier == other.next_nullifier) &\n    (self.next_index == other.next_index)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"193":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"194":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr","source":"use crate::{\n    abis::{\n    private_call_stack_item::PrivateCallStackItem, call_context::CallContext,\n    function_data::FunctionData, caller_context::CallerContext,\n    side_effect::{Ordered, RangeOrdered, Scoped}\n},\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PrivateCallRequest {\n    target: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Ordered for PrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.start_side_effect_counter\n    }\n}\n\nimpl RangeOrdered for PrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.start_side_effect_counter\n    }\n    fn counter_end(self) -> u32 {\n        self.end_side_effect_counter\n    }\n}\n\nimpl Eq for PrivateCallRequest {\n    fn eq(self, other: PrivateCallRequest) -> bool {\n        (self.target == other.target) \n            & (self.call_context == other.call_context) \n            & (self.function_data == other.function_data) \n            & (self.args_hash == other.args_hash) \n            & (self.returns_hash == other.returns_hash)\n            & (self.caller_context == other.caller_context)\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\n    }\n}\n\nimpl Empty for PrivateCallRequest {\n    fn empty() -> Self {\n        PrivateCallRequest {\n            target: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.push(self.target.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.extend_from_array(self.caller_context.serialize());\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = PrivateCallRequest {\n            target: reader.read_struct(AztecAddress::deserialize),\n            call_context: reader.read_struct(CallContext::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            caller_context: reader.read_struct(CallerContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            end_side_effect_counter: reader.read_u32(),\n        };\n        reader.finish();\n        item\n    }\n}\n\nimpl PrivateCallRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\n        ScopedPrivateCallRequest { call_request: self, contract_address }\n    }\n\n    pub fn matches_stack_item(self, stack_item: PrivateCallStackItem) -> bool {\n        (self.target == stack_item.contract_address)\n            & (self.call_context == stack_item.public_inputs.call_context)\n            & (self.function_data == stack_item.function_data)\n            & (self.args_hash == stack_item.public_inputs.args_hash)\n            & (self.returns_hash == stack_item.public_inputs.returns_hash)\n            & (self.start_side_effect_counter\n                                == stack_item.public_inputs.start_side_effect_counter)\n            & (self.end_side_effect_counter\n                                    == stack_item.public_inputs.end_side_effect_counter)\n    }\n}\n\nstruct ScopedPrivateCallRequest {\n    call_request: PrivateCallRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\n    fn inner(self) -> PrivateCallRequest {\n        self.call_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedPrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.call_request.counter_start()\n    }\n}\n\nimpl RangeOrdered for ScopedPrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.call_request.counter_start()\n    }\n    fn counter_end(self) -> u32 {\n        self.call_request.counter_end()\n    }\n}\n\nimpl Eq for ScopedPrivateCallRequest {\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\n        (self.call_request == other.call_request)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedPrivateCallRequest {\n    fn empty() -> Self {\n        ScopedPrivateCallRequest {\n            call_request: PrivateCallRequest::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.call_request.serialize());\n        fields.extend_from_array(self.contract_address.serialize());\n\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = ScopedPrivateCallRequest {\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        item\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = ScopedPrivateCallRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"199":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\n    abis::gas_fees::GasFees,\n    constants::{\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\n    DEFAULT_INCLUSION_FEE\n},\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    utils::reader::Reader\n};\n\nstruct GasSettings {\n    gas_limits: Gas,\n    teardown_gas_limits: Gas,\n    max_fees_per_gas: GasFees,\n    inclusion_fee: Field,\n}\n\nimpl GasSettings {\n    pub fn new(\n        gas_limits: Gas,\n        teardown_gas_limits: Gas,\n        max_fees_per_gas: GasFees,\n        inclusion_fee: Field\n    ) -> Self {\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\n    }\n\n    pub fn default() -> Self {\n        GasSettings::new(\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\n            DEFAULT_INCLUSION_FEE\n        )\n    }\n}\n\nimpl Eq for GasSettings {\n    fn eq(self, other: Self) -> bool {\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\n    }\n}\n\nimpl Empty for GasSettings {\n    fn empty() -> Self {\n        GasSettings::new(\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\n        )\n    }\n}\n\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\n\n        serialized.extend_from_array(self.gas_limits.serialize());\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\n        serialized.push(self.inclusion_fee);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\n        let mut reader = Reader::new(serialized);\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasSettings::empty();\n    let serialized = item.serialize();\n    let deserialized = GasSettings::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"208":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr","source":"use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PrivateCallStackItem {\n    fn empty() -> Self {\n        PrivateCallStackItem {\n            contract_address: AztecAddress::empty(),\n            function_data: FunctionData::empty(),\n            public_inputs: PrivateCircuitPublicInputs::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = PrivateCallStackItem::empty();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item = PrivateCallStackItem::empty();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x065f2831db9ac0db5e710bd3a865b5facd8cf83f1585e1af8fd1d6ce9c47f685;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr","source":"use crate::address::AztecAddress;\nuse crate::traits::{Empty, Serialize, Deserialize};\nuse crate::constants::CALLER_CONTEXT_LENGTH;\nuse crate::utils::reader::Reader;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n    is_static_call: bool,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, other: CallerContext) -> bool {\n        other.msg_sender.eq(self.msg_sender)\n            & other.storage_contract_address.eq(self.storage_contract_address)\n            & other.is_static_call == self.is_static_call\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n            is_static_call: false,\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\n    }\n\n    // Different to an empty context, a hidden context won't reveal the caller's msg_sender and storage_contract_address,\n    // but will still propagate the is_static_call flag.\n    pub fn is_hidden(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array(self.msg_sender.serialize());\n    fields.extend_from_array(self.storage_contract_address.serialize());\n    fields.push(self.is_static_call as Field);\n\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\n    let mut reader = Reader::new(fields);\n\n    let item = CallerContext {\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\n      is_static_call: reader.read_bool(),\n    };\n    reader.finish();\n    item\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = CallerContext::empty();\n    let serialized = item.serialize();\n    let deserialized = CallerContext::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"21":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    fn new(x: Field, y: Field, is_infinite: bool) -> Self {\n        Self { x, y, is_infinite }\n    }\n\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n// Scalar represented as low and high limbs\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    pub fn derive_public_key(self) -> EmbeddedCurvePoint {\n        let public_key = fixed_base_scalar_mul(self.lo, self.hi);\n        EmbeddedCurvePoint { x: public_key[0], y: public_key[1], is_infinite: false }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, key: EmbeddedCurveScalar) -> bool {\n        (key.hi == self.hi) & (key.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n#[foreign(multi_scalar_mul)]\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> [Field; 3]\n// docs:end:multi_scalar_mul\n{}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(\n    scalar_low: Field,\n    scalar_high: Field\n) -> [Field; 3]\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    let scalar = EmbeddedCurveScalar { lo: scalar_low, hi: scalar_high };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n"},"211":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr","source":"use crate::{\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\n    constants::{\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\n},\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct LogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n}\n\nimpl Ordered for LogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for LogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for LogHash {\n    fn eq(self, other: LogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n    }\n}\n\nimpl Empty for LogHash {\n    fn empty() -> Self {\n        LogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n        }\n    }\n}\n\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length]\n    }\n}\n\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n        }\n    }\n}\n\nimpl LogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\n        ScopedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedLogHash {\n    log_hash: LogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<LogHash> for ScopedLogHash {\n    fn inner(self) -> LogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedLogHash {\n    fn eq(self, other: ScopedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedLogHash {\n    fn empty() -> Self {\n        ScopedLogHash {\n            log_hash: LogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(LogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the counter when exposing to public.\n        // The log hash must already be siloed when we call this.\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nstruct EncryptedLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    randomness: Field,\n}\n\nimpl Ordered for EncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for EncryptedLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for EncryptedLogHash {\n    fn eq(self, other: EncryptedLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.randomness == other.randomness) \n    }\n}\n\nimpl Empty for EncryptedLogHash {\n    fn empty() -> Self {\n        EncryptedLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            randomness: 0,\n        }\n    }\n}\n\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.randomness]\n    }\n}\n\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            randomness: values[3],\n        }\n    }\n}\n\nimpl EncryptedLogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedEncryptedLogHash {\n    log_hash: EncryptedLogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\n    fn inner(self) -> EncryptedLogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl ScopedEncryptedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the secret randomness and counter when exposing to public\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\n        // The log hash will already be silo'd when we call this\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nimpl Ordered for ScopedEncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedEncryptedLogHash {\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedEncryptedLogHash {\n    fn empty() -> Self {\n        ScopedEncryptedLogHash {\n            log_hash: EncryptedLogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct NoteLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    note_hash_counter: u32,\n}\n\nimpl NoteLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\n        LogHash { value: self.value, counter: 0, length: self.length }\n    }\n}\n\nimpl Ordered for NoteLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for NoteLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteLogHash {\n    fn eq(self, other: NoteLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.note_hash_counter == other.note_hash_counter) \n    }\n}\n\nimpl Empty for NoteLogHash {\n    fn empty() -> Self {\n        NoteLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            note_hash_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            note_hash_counter: values[3] as u32,\n        }\n    }\n}\n"},"215":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr","source":"struct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n"},"216":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n}\n// docs:end:call-context\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n"},"217":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"22":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"220":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize, Empty}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        (self.is_private == other.is_private)\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nimpl Empty for FunctionData {\n    fn empty() -> Self {\n        FunctionData {\n            selector: FunctionSelector::empty(),\n            is_private: false\n        }\n    }\n\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data = FunctionData::empty();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data = FunctionData::empty();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty function data hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"227":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n    counter: u32,\n}\n\nimpl Ordered for L2ToL1Message {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content, self.counter as Field]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\nimpl L2ToL1Message {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\n        ScopedL2ToL1Message { message: self, contract_address }\n    }\n}\n\nstruct ScopedL2ToL1Message {\n    message: L2ToL1Message,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\n    fn inner(self) -> L2ToL1Message {\n        self.message\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedL2ToL1Message {\n    fn counter(self) -> u32 {\n        self.message.counter\n    }\n}\n\nimpl Eq for ScopedL2ToL1Message {\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\n        (self.message == other.message)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedL2ToL1Message {\n    fn empty() -> Self {\n        ScopedL2ToL1Message {\n            message: L2ToL1Message::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            message: reader.read_struct(L2ToL1Message::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\n#[test]\nfn serialization_of_empty_l2() {\n    let item = L2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = L2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped_l2() {\n    let item = ScopedL2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"229":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"235":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<N> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<N> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<N> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<N> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"237":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr","source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  num_txs: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.num_txs);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let num_txs = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      num_txs,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      num_txs: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.num_txs == other.num_txs)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n"},"238":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"239":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr","source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"241":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n"},"243":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr","source":"use crate::{\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    abis::gas_settings::GasSettings\n};\n\n// docs:start:tx-context\nstruct TxContext {\n    chain_id : Field,\n    version : Field,\n    gas_settings: GasSettings,\n}\n// docs:end:tx-context\n\nimpl TxContext {\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\n        TxContext { chain_id, version, gas_settings }\n    }\n}\n\nimpl Eq for TxContext {\n    fn eq(self, other: Self) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.gas_settings.eq(other.gas_settings))\n    }\n}\n\nimpl Empty for TxContext {\n    fn empty() -> Self {\n        TxContext {\n            chain_id: 0,\n            version: 0,\n            gas_settings: GasSettings::empty(),\n        }\n    }\n}\n\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\n\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.extend_from_array(self.gas_settings.serialize());\n\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let context = Self {\n            chain_id: reader.read(),\n            version: reader.read(),\n            gas_settings: reader.read_struct(GasSettings::deserialize),\n        };\n\n        reader.finish();\n        context\n    }\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context = TxContext::empty();\n    let serialized = context.serialize();\n    let deserialized = TxContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let context = TxContext::empty();\n    let hash = context.hash();\n\n    // Value from tx_context.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"246":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: Field = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point {\n            x: 0,\n            y: 0,\n            is_infinite: false\n        }\n    }\n}\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn pub_key_to_bytes(pk: Point) -> [u8; 64] {\n    assert(!pk.is_infinite, \"Point at infinity is not a valid public key.\");\n    let mut result = [0 as u8; 64];\n    let x_bytes = pk.x.to_be_bytes(32);\n    let y_bytes = pk.y.to_be_bytes(32);\n    for i in 0..32 {\n        result[i] = x_bytes[i];\n        result[i + 32] = y_bytes[i];\n    }\n    result\n}\n"},"247":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"249":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n"},"25":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n#[no_predicates]\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    let value = pedersen_commitment_with_separator(input, 0);\n    if (value.x == 0) & (value.y == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value.x, y: value.y, is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        points[i] = EmbeddedCurveScalar::from_field(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let values = multi_scalar_mul(generators, points);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: values[2] as bool }\n}\n\n#[no_predicates]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let v1 = pedersen_commitment_with_separator(input, separator);\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    multi_scalar_mul(\n        [length_generator[0], v1],\n        [EmbeddedCurveScalar { lo: N as Field, hi: 0 }, EmbeddedCurveScalar { lo: 1, hi: 0 }]\n    )[0]\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n#[test]\nfn assert_pedersen_noir() {\n    // TODO: make this a fuzzer test once fuzzer supports curve-specific blackbox functions.\n    let input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq(pedersen_hash_with_separator(input, 4), pedersen_hash_with_separator_noir(input, 4));\n    assert_eq(pedersen_commitment_with_separator(input, 4), pedersen_commitment_with_separator_noir(input, 4));\n}\n"},"263":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"273":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"289":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"303":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/main.nr","source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n\ncontract Token {\n    // Libs\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        hash::compute_secret_hash,\n        prelude::{NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress},\n        encrypted_logs::{\n        encrypted_note_emission::{\n        encode_and_encrypt_note, encode_and_encrypt_note_with_keys,\n        encode_and_encrypt_note_with_keys_unconstrained\n    },\n        encrypted_event_emission::{encode_and_encrypt_event, encode_and_encrypt_event_with_keys_unconstrained}\n    }\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public, compute_authwit_nullifier};\n    // docs:end:import_authwit\n\n    use crate::types::{transparent_note::TransparentNote, token_note::{TokenNote, TOKEN_NOTE_LEN}, balances_map::BalancesMap};\n    // docs:end::imports\n\n    #[aztec(event)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: BalancesMap<TokenNote>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128>>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n\n    // docs:start:admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[aztec(public)]\n    #[aztec(view)]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_public\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n\n    // docs:start:mint_private\n    #[aztec(public)]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        storage.balances.add(caller, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, caller, caller));\n\n        Token::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    // docs:start:shield\n    #[aztec(public)]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n\n    // docs:start:transfer_public\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n\n    // docs:start:burn_public\n    #[aztec(public)]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:redeem_shield\n    #[aztec(private)]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let pending_shields = storage.pending_shields;\n        let secret_hash = compute_secret_hash(secret);\n        // Get 1 note (set_limit(1)) which has amount stored in field with index 0 (select(0, amount)) and secret_hash\n        // stored in field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TransparentNote::properties().amount, amount, Option::none()).select(\n            TransparentNote::properties().secret_hash,\n            secret_hash,\n            Option::none()\n        ).set_limit(1);\n        let notes = pending_shields.get_notes(options);\n        let note = notes.get_unchecked(0);\n        // Remove the note from the pending shields set\n        pending_shields.remove(note);\n\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        storage.balances.add(to, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, to));\n    }\n    // docs:end:redeem_shield\n\n    // docs:start:unshield\n    #[aztec(private)]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n\n    // docs:start:transfer\n    #[aztec(private)]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, from_ivpk));\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk));\n\n        Transfer { from, to, amount: amount.to_field() }.emit(encode_and_encrypt_event_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk));\n    }\n    // docs:end:transfer\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[aztec(private)]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier, 0);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_from\n    #[aztec(private)]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, from_ivpk));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, to_ivpk));\n    }\n    // docs:end:transfer_from\n\n    // docs:start:burn\n    #[aztec(private)]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n\n    /// Internal ///\n\n    // docs:start:increase_public_balance\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n\n    // docs:start:balance_of_private\n    unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.balance_of(owner).to_field()\n    }\n    // docs:end:balance_of_private\n}\n// docs:end:token_all"},"315":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr","source":"use dep::aztec::{\n    prelude::{AztecAddress, NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash},\n    note::utils::compute_note_hash_for_consumption, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app\n};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\nglobal TOKEN_NOTE_LEN: Field = 3; // 3 plus a header.\n// TOKEN_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TOKEN_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n#[aztec(note)]\nstruct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NoteInterface<TOKEN_NOTE_LEN, TOKEN_NOTE_BYTES_LEN> for TokenNote {\n    // docs:start:nullifier\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self {\n            amount,\n            npk_m_hash: owner_npk_m_hash,\n            randomness: unsafe_rand(),\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n"},"317":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr","source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::{note_getter_options::PropertySelector, utils::compute_note_hash_for_consumption},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash}\n};\n\nglobal TRANSPARENT_NOTE_LEN: Field = 2;\n// TRANSPARENT_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TRANSPARENT_NOTE_BYTES_LEN: Field = 2 * 32 + 64;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[aztec(note)]\nstruct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nstruct TransparentNoteProperties {\n    amount: PropertySelector,\n    secret_hash: PropertySelector,\n}\n\nimpl NoteInterface<TRANSPARENT_NOTE_LEN, TRANSPARENT_NOTE_BYTES_LEN> for TransparentNote {\n\n    // Custom serialization to avoid disclosing the secret field\n    fn serialize_content(self) -> [Field; TRANSPARENT_NOTE_LEN] {\n        [self.amount, self.secret_hash]\n    }\n\n    // Custom deserialization since we don't have access to the secret plaintext\n    fn deserialize_content(serialized_note: [Field; TRANSPARENT_NOTE_LEN]) -> Self {\n        TransparentNote {\n            amount: serialized_note[0],\n            secret_hash: serialized_note[1],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): Ensure nullifier collisions are prevented\n    fn compute_note_hash_and_nullifier(self, _context: &mut PrivateContext) -> (Field, Field) {\n        self.compute_note_hash_and_nullifier_without_context()\n    }\n\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit. \n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n\n    // CUSTOM FUNCTIONS FOR THIS NOTE TYPE\n    // Custom serialization forces us to manually create the metadata struct and its getter\n    pub fn properties() -> TransparentNoteProperties {\n        TransparentNoteProperties {\n            amount: PropertySelector { index: 0, offset: 0, length: 32 },\n            secret_hash: PropertySelector { index: 1, offset: 0, length: 32 }\n        }\n    }\n}\n// docs:end:token_types_all\n"},"32":{"path":"std/merkle.nr","source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n"},"330":{"path":"/usr/src/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Deserialize, Serialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n"},"342":{"path":"/usr/src/noir-projects/noir-contracts/contracts/crowdfunding_contract/src/main.nr","source":"// docs:start:empty-contract\ncontract Crowdfunding {\n    // docs:end:empty-contract\n\n    // docs:start:all-deps\n    use dep::aztec::{\n        protocol_types::address::AztecAddress,\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note,\n        state_vars::{PrivateSet, PublicImmutable, SharedImmutable}\n    };\n    use dep::aztec::unencrypted_logs::unencrypted_event_emission::encode_event;\n    use dep::value_note::value_note::ValueNote;\n    use dep::token::Token;\n    // docs:end:all-deps\n\n    #[aztec(event)]\n    struct WithdrawalProcessed {\n        who: Field,\n        amount: Field,\n    }\n\n    // docs:start:storage\n    #[aztec(storage)]\n    struct Storage {\n        // Token used for donations (e.g. DAI)\n        donation_token: SharedImmutable<AztecAddress>,\n        // Crowdfunding campaign operator\n        operator: SharedImmutable<AztecAddress>,\n        // End of the crowdfunding campaign after which no more donations are accepted\n        deadline: PublicImmutable<u64>,\n        // Notes emitted to donors when they donate (can be used as proof to obtain rewards, eg in Claim contracts)\n        donation_receipts: PrivateSet<ValueNote>,\n    }\n    // docs:end:storage\n\n    // docs:start:init\n    // docs:start:init-header\n    // docs:start:init-header-error\n    #[aztec(public)]\n    #[aztec(initializer)]\n    // this-will-error:init-header-error\n    fn init(donation_token: AztecAddress, operator: AztecAddress, deadline: u64) {\n        // docs:end:init-header\n        // docs:end:init-header-error\n        storage.donation_token.initialize(donation_token);\n        storage.operator.initialize(operator);\n        storage.deadline.initialize(deadline);\n    }\n    // docs:end:init\n\n    // docs:start:deadline\n    // docs:start:deadline-header\n    #[aztec(public)]\n    #[aztec(internal)]\n    #[aztec(view)]\n    fn _check_deadline() {\n        // docs:end:deadline-header\n        let deadline = storage.deadline.read();\n        assert(context.timestamp() < deadline, \"Deadline has passed\");\n    }\n    // docs:end:deadline\n\n    // docs:start:donate\n    // docs:start:call-check-deadline\n    #[aztec(private)]\n    fn donate(amount: u64) {\n        // 1) Check that the deadline has not passed\n        Crowdfunding::at(context.this_address())._check_deadline().enqueue_view(&mut context);\n        // docs:end:call-check-deadline\n\n        // docs:start:do-transfer\n        // 2) Transfer the donation tokens from donor to this contract\n        let donor = context.msg_sender();\n        Token::at(storage.donation_token.read_private()).transfer_from(donor, context.this_address(), amount as Field, 0).call(&mut context);\n        // docs:end:do-transfer\n\n        let header = context.get_header();\n        // 3) Create a value note for the donor so that he can later on claim a rewards token in the Claim\n        // contract by proving that the hash of this note exists in the note hash tree.\n        let donor_npk_m_hash = header.get_npk_m_hash(&mut context, donor);\n        let mut note = ValueNote::new(amount as Field, donor_npk_m_hash);\n        storage.donation_receipts.insert(&mut note).emit(encode_and_encrypt_note(&mut context, donor, donor));\n    }\n    // docs:end:donate\n\n    // docs:start:operator-withdrawals\n    // Withdraws balance to the operator. Requires that msg_sender() is the operator.\n    #[aztec(private)]\n    fn withdraw(amount: u64) {\n        // 1) Check that msg_sender() is the operator\n        let operator_address = storage.operator.read_private();\n        assert(context.msg_sender() == operator_address, \"Not an operator\");\n\n        // 2) Transfer the donation tokens from this contract to the operator\n        Token::at(storage.donation_token.read_private()).transfer(operator_address, amount as Field).call(&mut context);\n        // 3) Emit an unencrypted event so that anyone can audit how much the operator has withdrawn\n        Crowdfunding::at(context.this_address())._publish_donation_receipts(amount, operator_address).enqueue(&mut context);\n    }\n    // docs:end:operator-withdrawals\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _publish_donation_receipts(amount: u64, to: AztecAddress) {\n        WithdrawalProcessed { amount: amount as Field, who: to.to_field() }.emit(encode_event(&mut context));\n    }\n}\n"},"38":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"4":{"path":"std/cmp.nr","source":"// docs:start:eq-trait\ntrait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\nimpl Eq for Field { fn eq(self, other: Field) -> bool { self == other } }\n\nimpl Eq for u64 { fn eq(self, other: u64) -> bool { self == other } }\nimpl Eq for u32 { fn eq(self, other: u32) -> bool { self == other } }\nimpl Eq for u8 { fn eq(self, other: u8) -> bool { self == other } }\nimpl Eq for u1 { fn eq(self, other: u1) -> bool { self == other } }\n\nimpl Eq for i8 { fn eq(self, other: i8) -> bool { self == other } }\nimpl Eq for i32 { fn eq(self, other: i32) -> bool { self == other } }\nimpl Eq for i64 { fn eq(self, other: i64) -> bool { self == other } }\n\nimpl Eq for () { fn eq(_self: Self, _other: ()) -> bool { true } }\nimpl Eq for bool { fn eq(self, other: bool) -> bool { self == other } }\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3) & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\nstruct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n// docs:start:ord-trait\ntrait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"47":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"64":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::{Point, pub_key_to_bytes},\n    utils::arr_copy_slice\n};\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret_fields = multi_scalar_mul([point], [secret]);\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/6061): make the func return Point struct directly\n    let shared_secret = pub_key_to_bytes(Point::new(shared_secret_fields[0], shared_secret_fields[1], false));\n    let mut shared_secret_bytes_with_separator = [0 as u8; 65];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[64] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nfn check_point_to_symmetric_key() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar::new(\n        0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    );\n    let point = Point::new(\n        0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        false\n    );\n\n    let key = point_to_symmetric_key(secret, point);\n    // The following value gets updated when running encrypt_buffer.test.ts with AZTEC_GENERATE_TEST_DATA=1\n    let expected_key = [\n        49, 167, 146, 222, 151, 129, 138, 184, 87, 210, 245, 249, 99, 100, 1, 59, 223, 180, 5, 99, 14, 7, 177, 236, 159, 203, 231, 72, 220, 180, 241, 23\n    ];\n    assert_eq(key, expected_key);\n}\n"},"65":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::PrivateContext,\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}},\n    state_vars::{shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter}\n};\n\nglobal DELAY = 5;\n\n// docs:start:key-getters\ntrait KeyGetters {\n  fn get_npk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ivpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ovpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_tpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_npk_m_hash(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Field;\n}\n\nimpl KeyGetters for Header {\n    fn get_npk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, NULLIFIER_INDEX, self)\n    }\n\n    fn get_ivpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, INCOMING_INDEX, self)\n    }\n\n    fn get_ovpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, OUTGOING_INDEX, self)\n    }\n\n    fn get_tpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, TAGGING_INDEX, self)\n    }\n\n    fn get_npk_m_hash(self, context: &mut PrivateContext, address: AztecAddress) -> Field {\n        get_master_key(context, address, NULLIFIER_INDEX, self).hash()\n    }\n}\n// docs:end:key-getters\n\nfn get_master_key(\n    context: &mut PrivateContext,\n    address: AztecAddress,\n    key_index: Field,\n    header: Header\n) -> Point {\n    let key = fetch_key_from_registry(context, key_index, address, header);\n    if is_empty(key) {\n        // Keys were not registered in registry yet --> fetch key from PXE\n        let keys = fetch_and_constrain_keys(address);\n        // Return the corresponding to index\n        keys.get_key_by_index(key_index)\n    } else {\n        // Keys were registered --> return the key\n        key\n    }\n}\n\nfn fetch_key_from_registry(\n    context: &mut PrivateContext,\n    key_index: Field,\n    address: AztecAddress,\n    header: Header\n) -> Point {\n    let x_coordinate_map_slot = key_index * 2 + 1;\n    let y_coordinate_map_slot = x_coordinate_map_slot + 1;\n    let x_coordinate_derived_slot = derive_storage_slot_in_map(x_coordinate_map_slot, address);\n    let y_coordinate_derived_slot = derive_storage_slot_in_map(y_coordinate_map_slot, address);\n\n    let x_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        x_coordinate_derived_slot\n    );\n    let y_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        y_coordinate_derived_slot\n    );\n    let x_coordinate = x_coordinate_registry.get_value_in_private(header);\n    let y_coordinate = y_coordinate_registry.get_value_in_private(header);\n\n    Point::new(x_coordinate, y_coordinate, false)\n}\n\n// Passes only when keys were not rotated - is expected to be called only when keys were not registered yet\nfn fetch_and_constrain_keys(address: AztecAddress) -> PublicKeys {\n    let (public_keys, partial_address) = get_public_keys_and_partial_address(address);\n\n    let computed_address = AztecAddress::compute(public_keys.hash(), partial_address);\n\n    assert(computed_address.eq(address));\n\n    public_keys\n}\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n"},"66":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr","source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH, hash::poseidon2_hash,\n    point::Point, traits::{Deserialize, Serialize, Empty, is_empty}\n};\nuse crate::keys::constants::{NUM_KEY_TYPES, NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX};\n\nglobal PUBLIC_KEYS_LENGTH = 12;\n\nstruct PublicKeys {\n    npk_m: Point,\n    ivpk_m: Point,\n    ovpk_m: Point,\n    tpk_m: Point,\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m : Point::empty(),\n            ivpk_m : Point::empty(),\n            ovpk_m : Point::empty(),\n            tpk_m : Point::empty()\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        ( self.npk_m == other.npk_m ) &\n        ( self.ivpk_m == other.ivpk_m ) &\n        ( self.ovpk_m == other.ovpk_m ) &\n        ( self.tpk_m == other.tpk_m )\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash(\n                [\n                self.npk_m.x,\n                self.npk_m.y,\n                self.npk_m.is_infinite as Field,\n                self.ivpk_m.x,\n                self.ivpk_m.y,\n                self.ivpk_m.is_infinite as Field,\n                self.ovpk_m.x,\n                self.ovpk_m.y,\n                self.ovpk_m.is_infinite as Field,\n                self.tpk_m.x,\n                self.tpk_m.y,\n                self.tpk_m.is_infinite as Field,\n                GENERATOR_INDEX__PUBLIC_KEYS_HASH\n            ]\n            )\n        }\n        )\n    }\n\n    pub fn get_key_by_index(self, index: Field) -> Point {\n        assert(index as u8 < NUM_KEY_TYPES, \"Invalid key index\");\n        if index == NULLIFIER_INDEX {\n            self.npk_m\n        } else if index == INCOMING_INDEX {\n            self.ivpk_m\n        } else if index == OUTGOING_INDEX {\n            self.ovpk_m\n        } else {\n            self.tpk_m\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.x,\n            self.npk_m.y,\n            self.npk_m.is_infinite as Field,\n            self.ivpk_m.x,\n            self.ivpk_m.y,\n            self.ivpk_m.is_infinite as Field,\n            self.ovpk_m.x,\n            self.ovpk_m.y,\n            self.ovpk_m.is_infinite as Field,\n            self.tpk_m.x,\n            self.tpk_m.y,\n            self.tpk_m.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: Point::new(serialized[0], serialized[1], serialized[2] as bool),\n            ivpk_m: Point::new(serialized[3], serialized[4], serialized[5] as bool),\n            ovpk_m: Point::new(serialized[6], serialized[7], serialized[8] as bool),\n            tpk_m: Point::new(serialized[9], serialized[10], serialized[11] as bool)\n        }\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: Point { x: 1, y: 2, is_infinite: false },\n        ivpk_m: Point { x: 3, y: 4, is_infinite: false },\n        ovpk_m: Point { x: 5, y: 6, is_infinite: false },\n        tpk_m: Point { x: 7, y: 8, is_infinite: false }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x146f68c0e0ba4067d61a3304bbfdec0797d5df1357db6c01247c48bfb345c7d7;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nfn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nfn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: Point { x: 1, y: 2, is_infinite: false },\n        ivpk_m: Point { x: 3, y: 4, is_infinite: false },\n        ovpk_m: Point { x: 5, y: 6, is_infinite: false },\n        tpk_m: Point { x: 7, y: 8, is_infinite: false }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.x, deserialized.npk_m.x);\n    assert_eq(keys.npk_m.y, deserialized.npk_m.y);\n    assert_eq(keys.ivpk_m.x, deserialized.ivpk_m.x);\n    assert_eq(keys.ivpk_m.y, deserialized.ivpk_m.y);\n    assert_eq(keys.ovpk_m.x, deserialized.ovpk_m.x);\n    assert_eq(keys.ovpk_m.y, deserialized.ovpk_m.y);\n    assert_eq(keys.tpk_m.x, deserialized.tpk_m.x);\n    assert_eq(keys.tpk_m.y, deserialized.tpk_m.y);\n}\n"},"80":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n"},"81":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr","source":"use std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext, oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: Header, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for Header {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier);\n\n        // 2) Check that the witness we obtained matches the nullifier\n        assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n        // 3) Compute the nullifier tree leaf\n        let nullifier_leaf = witness.leaf_preimage.hash();\n\n        // 4) Prove that the nullifier is in the nullifier tree\n        assert(\n            self.state.partial.nullifier_tree.root\n            == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n        );\n        // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n        //     was included in the nullifier tree.\n    }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, N, M>(header: Header, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M>;\n}\n\nimpl ProveNoteIsNullified for Header {\n    // docs:start:prove_note_is_nullified\n    fn prove_note_is_nullified<Note, N, M>(self, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M> {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n    // docs:end:prove_note_is_nullified\n}\n"},"89":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<N>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, N>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<N, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<N, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"95":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn block_number(self) -> Field {\n        block_number()\n    }\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<N>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<N>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, N>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N)\n}\n\nunconstrained fn storage_write<N>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<N>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<N>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}