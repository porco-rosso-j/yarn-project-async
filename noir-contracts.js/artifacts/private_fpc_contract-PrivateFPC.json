{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"PrivateFPC","functions":[{"name":"fund_transaction_privately","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"user_randomness","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+xdCZgcRfXvnZ3dJGyySUhIIFyTkJNc07ubPZIQNoQQCCEk3Dckm10IhHAF5FQQUE7Bv4DIJSAgAiJyiQpyigKiouABKIiiIniBqMjhv2q2H/vbSvXMdvd7s104/X3v257aOn7v1atXr86u8rqfqRt43qcHdL9XKaoO/mYU5Yww+ovvWUtYrSXtYEtYvSVsmCVsQ0vYKEXtRtgWlnhbWsJylrCxlrAJQRg+VcHf9uBvY765qamzpaHTb/RX5BvaVrbOyjfNWtnc6rf6s1pnrWpobWzsbG1qbWlb2daSb/ObGjv9rlltjV357ufVqp688gkfjW1QIEPCOlHRB8H7JHifDO8aQxrfpyn6fVV3mMnX71OKua98/YEUKXgyhl7lkz3+BEYd/SOfjvrYvnS+Oa+nfjNQv1Wgn/SuzdRr6keNER+fKmY5bsSXV94CN2nePr2gLP4UCOF10zDrf/zaCHu9an0jVy0oxJjK2BAoo/+nKj7Ffr1KpnK5GzMnz29Y8lqZ71g1y1/ZvKrF71wxq7Wjo63R9xtWNK9oXtnQ2tW5cpbfOqtV5dmxoqFVFdewosPvzK9o7tQNcQOvp9Hhw90Q32DuKOn5c5Ug4D9X8ef7F0ZlkOL7LyBhpnytWDkMgMbK1WApX846+iuz4pPh1/mO9bp7U/2UozeVMrjcOF9jxFkDOP8WAP178PfN4O9bgZ0YGcT7h/rxtqJ/KvqXon8rekfRfxS9q+g9Re9rb1LRf6u6K69KUUZRtaKsohpFtYoGZLzePf5blh7fbABJlZZRgP7fmSujXD0WpxIh3oEZQcA6c+58B2XS3WNpvgeB+WPKt6zK9qaQsm2QEQS8gYCy1aVc2TTfdY4r21tCyjY4Iwh4sICyDUm5smm+hwgomwRWbYHrMvw+fn2Gf4a1GvT0NZjhexPe3wre9TM00xOfkzddt/UCMhvGJzPfHFdw683fGI0R+d/DFegNFY1QNFLRRopGKRqtaGNFmygao2hTRZsp2lzRFoq2VJRTNFbROEVbKRqf6Xav0QUfnll/1WRDS9gIS9hIS9hGlrBRlrDRlrCNLWGbWMLGWMI2tYRtZgnb3BK2hSVsS0tYzhI21hI2zhK2lSVsfGb9TjIrqJNJ2+Jwhj6ms6v72ZCxvxo5QGYsb9ZFQp5XjeCTX9tIvrz8jRjrYiMn6qLTH8Umvw5/NFterf7GjHUxyom6yPubcMmvM++P4cqrI+9vylgXo12oi9a8vxmX/FTfszlTXp0qry0Y62JjB+qiQ/G8JZP8WlVeOaa8FMv+WMa62CT9ddGpeR7HI78OnddWPHm16rzGM9bFmDLVRT7Z4zP6ez6jv+Jjf5u0LjZ1pC4Y+zWf0S77mzDWxWZCdcG9uYWx/fqM+udLyS9jyC8N41vKawLjvJXOg3uuSs8DDhOYr5uY4a1rbr71evZwCb4HpJtvrY8TBfieVCbbmBgnY3tkrGt/Usr1RreXCQJ6s3XK+R4u1F6mOtJeJjO2F8a69jnlR2to5Efo39pOfHgyIdOzbjYl0xOHU8/03qoNBfRshnD7SopP8zxFgO+ZjoybpjD6mlsztlVGvfFdqYu3GdfIpmZk2nCa2oXNbm4NdnMq2M1pQnZT70cdIWA/GlJuNzXP0wT4bnSkrU5jbF/TGe0mo974rtTFPxnt5oyMTBtOU7uw2c3pYDdngN2cKWQ39R7+kQL2oznldlPzPFOA7xZH2upMxvaVZ7SbjHrju1IX/2K0m35Gpg2nqV3Y7GYe7KYPdrNByG7qc08bCdiP2Sm3m5rnBgG+5zjSVhsY21cjo91k1Bvflbr4N6PdbMrItOE0tQub3WwEu9kEdnOWkN3UZ0VHCdiPeSm3m5rnWQJ8b+tIW53F6Zcw2k1GvfFdqYt3GO1mS0amDaepXdjsZjPYzRawm61CdlOfrx8tYD+2S7nd1Dy3CvC9wJG22srYvtoY7Saj3viu1MV/GO3m7IxMG05Tu7DZzTawm7PBbs4Rspv6TpKNBezHDim3m5rnOQJ8L3Kkrc5hbF9zGe0mo974rtTFu4x2c5uMTBtOU7uw2c25YDe3Abs5T8hu6nucNhGwH4tTbjc1z/ME+N7ZkbY6j7F9bctoNxn1xnelLt5jtJvtGZk2nKZ2YbOb24LdbAe7OV/Ibuq778YI2I+lKbebmuf5Anzv6khbnc85nmO0m4x647tSF+8z2s0FGZk2nKZ2YbOb24HdXAB2c3shu6nvC91UwH7slnK7qXneXoDv3R1pq9sztq+FjHaTUW98V+riA0a7uUNGpg2nqV3Y7OZCsJs7gN1cJGQ39R3LmwnYj71Sbjc1z4sE+N7bkba6iLF97choNxn1xnelLv7LaDd3ysi04TS1C5vd3BHs5k5gNxcL2U1d+OYC9mO/lNtNzfNiAb73d6StLmZsXzsz2k1GvfFdqQuPsS6WZGTacJrahc1u7gx2cwnYzV2E7Kb+lscWAvbjoJTbTc3zLgJ8H+xIW92Fcx6M0W4y6o3vSl1UMdbFrhmZNpymdmGzm0vBbu4KdnOZkN3U3z/aUsB+rEy53dQ8LxPgu8ORtrqMsX0tZ7SbjHrju1IXGc45yYxMG05Tu7DZzeVgN3cDu7m7kN3U34zLCdiPrpTbTc3z7gJ8H+pIW92dsX3twWg3GfXGd6UuqhnrYs+MTBtOU7uw2c09wG7uCXZzLyG7qb+zOVbAfhyecruped5LgO8jHGmrezG2r70Z7Saj3viu1EWWsS72yci04TS1C5vd3Bvs5j5gN/cVspv628TjBOzH2pTbTc3zvgJ8H+VIW92XsX3tx2g3GfXGd6UuahjrYv+MTBtOU7uw2c39wG7uD3bzACG7qb/nvpWA/Tg25XZT83yAAN/HOdJWD2BsXwcy2k1GvfFdqYtaxro4KCPThtPULmx280CwmweB3TxYyG4OyPT+7iuXnE5Iud3UPB8swPfHHGmrBzO2r0MY7Saj3viu1MUAxrpYkZFpw2lqFza7eQjYzRVgN1dmvF5PhrnuhnqM63AZGX1lX/tmbO+2utREddkR1OVoRavUe00QblSrlc98ssd/vao89ZFP9virGPWmFnB2BkLuCv4eGvw9LPi7Oug/JwfxD1e/j1C0RtGRitYqOkrR0YqOUXSsouMUrVN0vKITFH1M0YmKTlJ0sqJTFJ2q6DRFH1f0CUWnKzpD0ScVnanoLEVnK/qUok8rOkfRuYrOU3S+ogsUXajoM4ouUnSxos9mAsHTx+41+JzX++H+aBFjxfhdjIb9/xgVRjfIDUCpJRWdEzfi/VxGEPDnMvz5XsKoDFJ8XwImminfgrJlvPJYf06rKomzS6hRXAp6y+5CXMLsQpBVJ9A1ECatKJwVgIp9WfDj85oniQq4VMAyXcrcaqT4zgjynRTj5cIyzCd7fK2Yl2f46+YLzJaMDIDO9/QgX25ZfF5IFlcIyeIKQVl0Ccni5JTPJUq1h1P6l++OEvjEdP/UMn2TNp/s8Rn10mesa59TftqR0vOdNo/biyjPUvqEeUr0WVwyQafyymJecj7Z418u1Akg6IiY/VLlaMxXChiF01MymR/FeUvK81WZdBqY0wfI6OVV4JzErZ9SMuesn6shL7+xUbWNVS1+16quxlktbQ0r/ebG5uaupq6W5tamVV2zmlasaun0m1Y0NrR1tuS7/NbOzpZZjR0tzV1tqzqau9Bo+6saG5tWta3s8Gc1NK9YmW9d1bgi39XU0tiQX7GqsWXVqsbW5uYVjY2rmlu7WttaGxpWdDW25me1tLTlmxsa2xqk6ufqoH7KObrmnIbBTuya4McXXTHgUviuETDW1wp1XNcKjl60LL4oIIvrhGRxnaAsVgl59p9M+UhOqj2cmfKRnJTun+XISI5RL33GuvbPqozkzMe/Rmgkd72LI7nrhUdy1wsYhXP+B0dyX8qk08CcIzRS+JJjI7kbGEdyZzGO5KTq5wYYyYV1CmmegpPEKdXB3OhiB3OjcAdzo0AHc16ZOhjOdd4UrRX16mCS4jq/TCOApDhvYuygGfXPP1+oA7ipDx10Upl+OcPXEfaaHk1RB32eUP18+SM01Xpz8OMrGctGpnyyxw/b0MO5Qy1pXoybonyJiicZchtVKRkmzeuWlNeHbjC3CDhGtwo5ibdm5KaivyIki9uEZHGb8LS8hCw+k/Jpean2cFHKp+WldP9iR6blGfXSZ6xr/+LKtLz5FPosLpmgs/tVyVmTW4Q6ga8KzppozF8VMAqXODItfwujI3h7Jp0G5hKhUeXtGflpec76+RrjtPzFjKN+qfr5Wj+M+qWOL90R/Pi6KwZcCt8dAsb6TqGO607B0YuWxdcFZHGXkCzuysgelZHw7C9L+UhOqj18PuUjOSndv9yRkRyjXvqMde1fXhnJmY9/h9BI7m4XR3J3C4/k7hYwClf9D47k7smk08BcJTRSuMexkdy9jCO5yxlHclL1c2+m/BusOKfgJHFKdTDfcLGD+YZwB/MNgQ7mGkc2WHEasIuEPNikuL7oyAar+xg7aEb9878o1AHcl5HfYPXNDF9HePGAdHbQ1wjVzzct9cM96l3FaH8OY8zrW4x9WTnv/+PEjXi/nREE/O0Mf773MyqDFN/3Z3oEzJRvWe//O8wRb3qVUKN4oJg3nVTp7mf0BtCqE+iPwrbZ7wQ/Hsx4/Pf/6Qp4QMAyPcDcaqT4zgjynRTjQ8IyzCd7fK2YDwkMKx8WGmI/nJFbyHtQSBaPCMnikYzs9lQJWVyf8kVNqfbwpZQvakrp/g2OLGoy6qXPWNf+DZVFTfMp9FlcMkGn8tGM4JzzQ0KdwKOCc84a86MCRuFmRxY1H2J0BB/LpNPA3Cw0J/dYRn5Rk7N+vpvhmzO9gXHOVKp+vpsp//ZUzmkY7MQeD358zxUDrvOQwPe4gLH+vlDH9X3B0YuWxfcEZPGEkCyeEJTFYUKe/S0pH8lJtYdbUz6Sk9L92xwZyTHqpc9Y1/5tlZGc+fiPC43knnRxJPek8EjuSQGjcMf/4EjuqUw6DcwdQiOFpxwbyf2AcSR3G+NITqp+fpAp//ZUzik4SZxSHczTLnYwTwt3ME8LdDB3OrI9ldOAfUnIg018ONOR7ak/ZOygGfXPv0uoA/hhRn576o8yfB3hDQPS2UHfKVQ/P/oITbX+OPjxTMbjv/8vbEMP5w61pHkxbooSuW+OZMhtVKVkmDSvn6S8PnSD+YmAY/RTISfxpxm5qehnhGTxrJAsnhWelpeQxb0pn5aXag/fSPm0vJTu3+fItDyjXvqMde3fV5mWN59Cn8UlE3R2n5OcNfmJUCfwnOCsicb8nIBRuN+RafmfMDqCP8uk08DcLzSq/FlGflqes35+zjgtfx/jqF+qfn7eD6N+qeNLvwh+/NIVAy6F7xcCxvp5oY7recHRi5bFLwVk8YKQLF7IyB6VkfDsv5PykZxUe3gw5SM5Kd1/yJGRHKNe+ox17T9UGcmZj/8LoZHciy6O5F4UHsm9KGAUHvsfHMn9KpNOA/OY0EjhV46N5H7NOJJ7iHEkJ1U/v86Uf4MV5xScJE6pDuYlFzuYl4Q7mJcEOpjHHdlgxWnAviHkwSbF9T1HNli9zNhBM+qf/z2hDuDljPwGq99k+DrC+waks4N+XKh+fgMddLnur1st1PG9khEE/EqGP9/fMhpmKb5/Cy4bU75lvSzxMCFl+11GEPDvBJTt1ZQrm+b7VQFls2Hl2NGnvaoMsww4PbXfZ2RlmE/2FIzfqwJe+R8y6dYd/TXoWwR0h/OW7z+mXIZat3U9c8/PM7YZ/w+M9fFayutD68trAm35T4z1IcG3Xr/8kwDfTw5It+3uEuL7KaFRPLetZawf/ynmtbdyOdacH8xEvK9nBAG/LuBYv5Fyx1rz/UamR8BM+ZZV2Q4VUrY/ZwQB/1lA2f6ScmXTfP+lTKO4fLKn0HD/ItCL/TXlIy896vqrAN9/Y26kg7yeuWL9WxuyD4L3Q+F9NbwfFrzr5++ZnrScfOqR698E5Pcmo7cLTdAqg3yyx+9krOvJQT5vqTz/oehtRf9U9C9F/1b0jqL/KHpX0XuK3td1rOi/mkk1BKxSlFFUrSirqEZRraIBigYqGqRoA0V1igYrGqKoXtFQRcMUDVe0oaIRikYq2kjRKEWjFW2saBNFY6q7vUicO38r0AEM+4cl7G1L2D8tYf+yhP3bEvaOJew/lrB3LWHvWcLet4R9YAn7ryWsIH8jrMoSlrGEVVvCspawGktYrSVsgCVsoCVskCVsA0tYnSVssCVsiCWs3hI21BI2zBI23BK2oSVshCVspCVsI0vYKEvYaEvYxpawTSxhY6p7bAw9UTfiRLE5SW3tWwx5dXZ1P/9gxPXDlO8pCHhe9Taf/Nr+yZeX/y/GuviRE3XR6f+bTX4d/jtsebX6/2Gsix87URd5/10u+XXm/fe48urI++8z1sUzLtRFa97/gEt+qu/5L1NenXomuppxb5cDddGhv05WzZNXqx7bMOWlWParGevip+mvi07Nc5ZHfh06rxqevFp1XrWMdfFs+utCZ+0PYJFfZyGvgSx5dRTyGsRYF8+lvi5aCzxvwCK/Aky/jiOvzu68BjPWxc/SXhcd3TwP4ZBfa3de9Rx5dbPsD2Wsi5+nvC5WBTwPY+B5ZZDXcIa8WoK8NmSsi1+kuy4a6MTjiOQ8+5TXyMR5tXZRXhsx1sUvU10XrSuJ51HJ5ffhSdbRifNq+TCvjRnr4vlU18WsD3neJDHP/od5janmm7P8IeMZlxdScqC1xOMzzpv5jPM+/jOMdfGiI3XBOD/gM45v/WcZ6+JXjtQF4zjIZ/Tj/Z8z1sWvHakLRn/PZ/RX/OcZ6+IlR+qCsV/zGe2y/yvGunjZkRtqGNuvz6h/vpT8Mob80rCuTHltyuiH6jy49wDp/VVvZvj3QW1WzVvX3HwfnunZ+8PJ9z9Svutf6+Nm1fx8v+3I2f3NGdsjY137b6dcb3R72VRAb/6dcr61jZBoL+840l62YGwvjHXtc8qvsJ/Q6/Ej9G9tJ2g/8hbVPfuRt6zuicOpZ0dkevadctbfeym/RVPzvKVA+3rfkXHTlozzvDnGtsqoN74rdXEEo98/tlqmDaepXdjsZg7s5liwm+OE7OaaTM/efMw38bmqgem2m5rncQJ2s2qgG211HGP72opzjM4nP9+VuljDaDfHV8u04TS1C5vd3Ars5niwmxOE7OaRmZ7zS5hvUjllU243Nc8TBOxmjSNtdQJj+5rIaDcZ9cZ3pS6OZLSbk6pl2nCa2oXNbk4EuzkJ7OZkIbu5NtNzxhPzTSqngSm3m5rnyQJ2c5AjbXUyY/uawmg3GfXGd6Uu1jLaza2rZdpwmtqFzW5OAbu5NdjNqUJ286hMzzl4zDepnAan3G5qnqcK2M0hjrTVqYztaxqj3WTUG9+VujiK0W5Or5Zpw2lqFza7OQ3s5nSwmzOE7ObRmZ67QjDfpHIalnK7qXmeIWA3hzvSVmcwtq+ZjHaTUW98V+riaEa7ma+WacNpahc2uzkT7GYe7KYvZDePyfTcp4T5JpXTyJTbTc2zL2A3N3KkrfqM7auB0W4y6o3vSl0cw2g3G6tl2nCa2oXNbjaA3WwEu9kkZDePzfTcOYf5JpXTxim3m5rnJgG7uYkjbbWJsX3NYrSbjHrju1IXxzLazeZqmTacpnZhs5uzwG42g91sEbKbx2V67uXEfBOfo0i53dQ8twjYzc0daastjO2rldFuMuqN70pdHMdoN9uqZdpwmtqFzW62gt1sA7s5W8hursv03F2M+SbeC51yu6l5ni1gN8c60lZnM7avOYx2k1FvfFfqYh2j3ZxbLdOG09QubHZzDtjNuWA3txGym8dneu53x3wT779Nud3UPG8jYDcnONJWt2FsX/MY7Saj3viu1MXxjHZz22qZNpymdmGzm/PAbm4LdrNdyG6ekOn5Bgbmm1ROk1NuNwt3XwvYzSmOtNV2xvY1n9FuMuqN70pdnMBoN7erlmnDaWoXNrs5H+zmdmA3FwjZzY/pwgXsx7SU203N8wIBvqc70lYXMLav7RntJqPe+K7UxccY7ebCapk2nKZ2YbOb24PdXAh2cwchu3mi9jUF7Ec+5XZT87yDAN++I211B8b2tYjRbjLqje9KXZzIaDd3rJZpw2lqFza7uQjs5o5gN3cSspsnZXq+N4n5JpVTU8rtpuZ5JwG+ZznSVndibF+LGe0mo974rtTFSYx2c+dqmTacpnZhs5uLwW7uDHZziZDdPDnT801ezDfx3pSU203N8xIBvtscaatLGNvXLox2k1FvfFfq4mRGu7m0WqYNp6ld2OzmLmA3l4Ld3FXIbp6S6fluOeabeD9Eyu2m5nlXAb63caSt7srYvpYx2k1GvfFdqYtTGO3m8mqZNpymdmGzm8vAbi4Hu7mbkN08VRVeI2A/2lNuNzXPuwnwPd+RtrobY/vandFuMuqN70pdnMpoN/eolmnDaWoXNru5O9jNPcBu7ilkN09ThdcK2I/tU243Nc97CvC90JG2uidj+9qL0W4y6o3vSl2cxmg3966WacNpahc2u7kX2M29wW7uI2Q3P64KHyBgP3ZMud3UPO8jwPdOjrTVfRjb176MdpNRb3xX6uLjjHZzv2qZNpymdmGzm/uC3dwP7Ob+QnbzE6rwgQL2Y0nK7abmeX8BvndxpK3uz9i+DmC0m4x647tSF59gtJsHVsu04TS1C5vdPADs5oFgNw8Sspunq8IHCdiPZSm3m5rngwT4Xu5IWz2IsX0dzGg3GfXGd6UuTme0m4dUy7ThNLULm908GOzmIWA3VwjZzTNU4RsI2I89Um43Nc8rBPje05G2uoKxfa1ktJuMeuO7UhdnMNrNjmqZNpymdmGzmyvBbnaA3VwlZDc/qQqvE7Af+6TcbmqeVwnwva8jbXUVY/vqZLSbjHrju1IXn2S0m13VMm04Te3CZjc7wW52gd08VMhunqkKHyxgPw5Iud3UPB8qwPeBjrTVQxnb12GMdpNRb3xX6uJMRru5ulqmDaepXdjs5mFgN1eD3TxcyG6epQofImA/Dkm53dQ8Hy7A9wpH2urhjO3rCEa7yag3vit1cRaj3VxTLdOG09QubHbzCLCba8BuHilkN89WhdcL2I9VKbebmucjBfjudKStHsnYvtYy2k1GvfFdqYuzGe3mUdUybThN7cJmN9eC3TwK7ObRQnbzU6rwoQL247CU203N89ECfK92pK0ezdi+jmG0m4x647tSF59itJvHVsu04TS1C5vdPAbs5rFgN48TspufVoUPE7Afa1JuNzXPxwnwfaQr37RhbF/rGO0mo974rtTFpxnt5vHVMm04Te3CZjfXgd08HuzmCUJ28xxV+HAB+3F0yu2m5vkEAb6PceWOccb29TFGu8moN74rdXEOo908sVqmDaepXdjs5sfAbp4IdvMkIbt5rip8QwH7sS7ldlPzfJIA38e7cucjY/s6mdFuMuqN70pdnMtoN0+plmnDaWoXNrt5MtjNU8BunipkN89ThY8QsB8nptxuap5PFeD7JFfu4GFsX6cx2k1GvfFdqYvzGO3mx6tl2nCa2oXNbp4GdvPjYDc/IWQ3z1eFjxSwH6em3G5qnj8hwPdprpyJZmxfpzPaTUa98V2pi/MZ7eYZ1TJtOE3twmY3Twe7eQbYzU8K2c0LVOEbCdiP01NuNzXPnxTg+wxXzqgwtq8zGe0mo974rtTFBYx286xqmTacpnZhs5tngt08C+zm2UJ280JV+CgB+3FWyu2m5vlsAb7PdmXPIGP7+hSj3WTUG9+VuriQ0W5+ulqmDaepXdjs5qfAbn4a7OY5QnbzM6rw0QL245yU203N8zkCfJ/ryhouY/s6l9FuMuqN70pdfIbRbp5XLdOG09QubHbzXLCb54HdPF/Ibl6kCt9YwH5ckHK7qXk+X4DvC12ZU2NsXxcw2k1GvfFdqYuLGO3mhdUybThN7cJmNy8Au3kh2M3PCNnNi1XhmwjYj4tTbjc1z58R4Puzrvg4jO3rIka7yag3vit1cTGj3by4WqYNp6ld2OzmRWA3Lwa7+Vkhu/lZVfgYAftxScrtpub5swJ8X+pIW/0sY/v6P0a7yag3vjN1wWg3P1ct04bT1C5sdvP/wG5+DuzmJdVeryfDXHfDPUZ5V6fbZh6qhPenDH8fNMmTaafcdf3HKsb2wGgzdX1UB/Wt8815vR9uPbgsPnbfDNDYRns9NlX/nuz1tOVXq+zvlwVtnNJ9Xv2+XNEXFF1R3RMupQuXMtrZK4V04cpAFzIl9CGf7PE/z2i3ckE+V6k8r1Z0jaIvKrpW0XWKrlf0JUU3KLpR0U2KvqzoZkVfUXSLolsV3aboq4puV/Q1RXco+rqiOxXdpehuRfcoulfRNxTdp+ibir6l6NuBAFGWGs9Ar3fY1ZawayxhX7SEXWsJu84Sdr0l7EuWsBssYTdawm6yhH3ZEnazJewrlrBbLGG3WsJus4R91RJ2uyXsa5awOyxhX7eE3WkJu8sSdrcl7B5L2L2WsG9Ywu6zhH3TEvYtS9i3gzB8uH3OzzPar6sY8urs0k/ev5oR1+Vl8v+T8Kzr4hoW+XXX6xeT59UQyM+/lrEuvpDmumj6EKd/XTKe88Czf32SvBp6yc//EmNdXJHOusgbOP0bYvLc3LUez/6N8fJqtcjPv4nT90tbXbRacfpfjs5zSwjP/s1R82oJlZ//Fc5+LD110VAEp39LFJ5bivLs39r3vDpKyM+/jbEurk5DXbSUxOl/tW885/vAs397X/LK90l+/tcY6+Ka/q2LWX3E6d9RiuemPvPsf71oXk1dEeTn38lYF1/sr7poiYTTvyuc59aIPPt3h+TV1hVZfv49jHVxbfnrIh8Dp3+vjed8LJ79b6yflx9Tfv59jHVxXTnrYlVsnP43e/PcmIBn/1uQV0NXIvn532asi+sdWXdjnB/wGce3/hWM625fcqQuGMdBPqMf71/NWBc3OFIXjP6ez+iv+Ncy1sWNjtQFY7/mM9pl/0uMdXGTUF1UM9cFY/v1GfXP55Sfi2uF96s8H1D0HUUPKnpI0cOKHlH0qKLHFH1X0eOKvqfo+4qeUPSkoqcU/UDR04p+qOhHin6s6BlFP1H0U0XPKnpO0c8U/VzRLxT9UtHzil4IFm1w/eZ+y5rOA5aw71jCHrSEPWQJe9gS9ogl7FFL2GOWsO9awh63hH3PEvZ9S9gTlrAnLWFPWcJ+YAl72hL2Q0vYjyxhP7aEPWMJ+4kl7KeWsGctYc9Zwn5mCfu5JewXlrBfWsKet4S9UO3WWuH9DHnRWuEDjLjudWSt8Dss8uuu1weT5/XhWuFDjHXxDUfWCh9OxnOvtcJHkuRlrBU+ylgX9zmyVvhYTJ5ta4XfjZeXda3wcca6+KYja4Xfi85z6Frh96PmVWSt8AnGuviWI2uFT0bhucRa4VN9z6vkWuEPGOvi246sFT7dN577tFb4w77k1ce1wh9x+neOrBX+uBTPEdYKn6nmWyv8CWNdPODIWuFPq/nWCp+t5lsrfI6xLr7jyFrhz6r51gp/Xs23VvgLxrp40JG1wl9W860VPl/Nt1b4AmNdPOTIPDzj/IDPOL7172Och3/YkbpgHAf5jH68/23GunjEkbpg9Pd8Rn/F/w5jXTzqSF0w9ms+o132H2asi8ccWStkbL8+o/75nPKTXius4svrw7XCF1VF/0rRrxW9pOhlRb9R9Iqi3yr6naJXFf1e0R8U/VHRa4r+pOh1RW8o+rOivyj6q6K/Kfq7ojcVvaXoH4reVvRPRf9S9G9F7yj6j6J3g0UbXL950bKm8ytL2K8tYS9Zwl62hP3GEvaKJey3lrDfWcJetYT93hL2B0vYHy1hr1nC/mQJe90S9oYl7M+WsL9Ywv5qCfubJezvlrA3LWFvWcL+YQl72xL2T0vYvyxh/7aEvWMJ+48l7N1q+bVCbLNJbf2LLGtd3WuFv2IcszzryFrhr1nk112vLyXP68O1wpcZ6+I5R9YKf5OM515rha8kyctYK/wtY138zJG1wt/F5Nm2VvhqvLysa4W/Z6yLnzuyVviH6DyHrhX+MWpeRdYKX2Osi184slb4pyg8l1grfL3veZVcK3yDsS5+6cha4Z/7xnOf1gr/0pe8+rhW+FfGunjekbXCv5XiOcJa4d+r+dYK32SsixccWSt8q5pvrfAf1XxrhW8z1sWLjqwV/rOab63wX9V8a4X/ZqyLXzmyVvhONd9a4X+q+dYK32Wsi187Mg/POD/gM45v/Z8xzsO/5EhdMI6DfEY/3v8lY1287EhdMPp7PqO/4r/IWBe/caQuGPs1n9Eu+y8x1sUrjqwVMrZfn1H/fCn5meuESev5vWounA2F+2h1W9sesL4Laym4roLrLrgug+s2uK6D6z64LoTrRriuhOtOuC6F61a4roXrXrguhutmuK6G6264Lofrdriuh+t+uC6I64a4rojrjrguieuWuK6J6564Lqrv/S31/h7EfwHe8cwcnqnDM3d4Jg/P7OGZPjzzh2cC8cwgninEM4d4JhHPLOKZRjzziGci8cwknqnEM5d4JhPPbOKZTjzziWdC8cwonil9CN7xTCqeWcUzrXTm9X319wNF/9VGUjWkKkUZRdWKsopqFNUqGqBooKJBijZQVKdosKIhiuoVDVU0TNFwRRsqGqFopKKNFI1SNFrRxoo2UTRG0aaKNtP5e91ENhof0+7kkz2s+xMkcXKeuZbEyXgner4KcG6eLaEISTugLbJswBs0NvPjBpro4nNdln7Xl6ZvGSh8lbf+Jd8SFfR6lRuKtCVffeRrAWcuUKSxwd9xwd+tgr/js928TA7iT1C/JyqapGiyoimKtlY0VdE0RdMVzVA0U1Feka+oQVGjoiZFsxQ1K2pR1KqoTdFsRXMUzVW0jaJ5irbV/Cqar2g7RQsUba9ooaIdFC1StKOinRQtVrSzoiVZr/fuEA0+5/V+TE83aUNhrBh/bJYP1y6MCqMb5Aag1JKKzokb8S7NCgJemuXPd1dGZZDie1fohpjyLShbxiuP9ee0qpI4xwo1imWgt+wuxK6MlhGtOoGugTBpReGsAFTs5UED2k3zJFEBywQs0zLmViPFd0aQ76QYdxeWYT7Z42vF3D3LXzd7MFsyMgA639ODfLllsZuQLPYUksWegrIYKySLNwem26ZItYe3+pfvkhvVpHT/HwNlPC/uhQxGvfQZ69rnlJ92pLQfYvO4vYjyLKVPmKdEn8UlE3Qq9yrmJeeTPf7uQp0Ago6I2S9Vjsa8l4BR+HdKVpqjOG9Jed47m04Dw1kXqJd7g3MSt35KyZyzfvaBvPzGRtU2VrX4Xau6Gme1tDWs9Jsbm5u7mrpamlubVnXNalqxqqXTb1rR2NDW2ZLv8ls7O1tmNXa0NHe1repo7kKj7a9qbGxa1bayw5/V0LxiZb51VeOKfFdTS2NDfsWqxpZVqxpbm5tXNDauam7tam1rbWhY0dXYmp/V0tKWb25obGuQqp99gvop5+iacxoGO7F9A8XazxUDLoVvXwFjvb9Qx7W/4OhFy2I/AVkcICSLAwRlsaWQZ/+flI/kpNrDuykfyUnp/nuOjOQY9dJnrGv/vcpIznz8fYVGcge6OJI7UHgkd6CAUdD7PbhkAfWX6pHcQdl0GhjOukC9PMixkdzBjCO59xhHclL1czCM5MI6hTRPwUnilOpgDnGxgzlEuIM5RKCDyZSpg+Fc503RWlGvDiYprmqhuuDeqreCsYNm1D+/WqgDWNGHDjqpTFdm+TrCXtOjKeqgM0L1s/IjNNXaESjWKttGpnyyxw/b0MO5Qy1pXoybonyJiicZchtVKRkmzasz5fWhG0yngGPUJeQkdglORa8SksWhQrI4VHhaXkIWtcxOGjc+qfYwoH/5LjktL6X7A8vklOeTPT6jXvqMde1zyu+jMi3fITRrcpjkrEmnUCdwmOCsicZ8mIBRGOzItHwnoyO4OptOAzNYaFS5ugzT8pz1czjjtDwa7aSjfqn6ObwfRv1Sx5eOCBRrjSsGXArfEQLG+kihjutIwdGLlsUaAVmsFZLF2qzsURkJz74+5SM5qfYwNOUjOSndH+bISI5RL33GuvaHVUZy5uMfITSSO8rFkdxRwiO5owSMwsj/wZHc0dl0GpiRQiOFox0byR3DOJIbxjiSk6qfY/phgxXnFJwkTqkO5lgXO5hjhTuYYwU6mFGObLDiNGADhDzYpLhGO7LB6jjGDppR//zRQh3AcWXYYLWOcYNVr+nRFHXQo4TqZ52lfrhHvVsy2p+tGPM6nrEvK+f9f8cLOQ4nZAUBn5Dlz/djjMogxffHsj0CZsq3rPf/beWIN72lUKM4sZg3nVTpPsboDaBVJ9AfhW2zJwUN6GTbtlmOCjhRwDKdKLwgx8V3RpDvpBhPSfmiplbMUwSGlacKDbFPFVzIO1lIFqcJyeI04e2pErIYk/JFTan2sGnKFzWldH8zRxY1GfXSZ6xrf7PKoqb5FPosLpmgU/lxyTnnU4Q6gY8LzjlrzB8XMAo5RxY1T2F0BD+RTaeByQnNyX2iDIuanPVzOuOi5maMc6ZS9XN6P2xP5ZyGwU7sjECxPumKAZfCd4aAsT5TqOM6U3D0omXxSQFZnCUki7MEZbGVkGc/LuUjOan2sFXKR3JSuj/ekZEco176jHXtj6+M5MzHP0NoJHe2iyO5s4VHcmcLGIXJ/4MjuU9l02lgJguNFD7l2Eju04wjufGMIzmp+vl0P2xP5ZyCk8Qp1cGc42IHc45wB3OOQAeztSPbUzkN2KZCHmxSXFMd2Z56LmMHzah//lShDuDcMmxPPY9xe+pmg9LZQW8tVD/nfYSmWs8PFOsC20amfLLHD9vQw7lDLWlejJuiRO6bIxlyG1UpGSbN68KU14duMBcKOEafEXISPyM4FX2BkCwuEpLFRcLT8hKymJHyaXmp9jAz5dPyUrqfd2RanlEvfca69vOVaXnzKfRZXDJBZ/diyVmTC4U6gYsFZ0005osFjEKTI9PyFzI6gp/NptPANAmNKj9bhml5zvr5P8Zp+TzjqF+qfv6vH0b9UseXPhco1iWuGHApfJ8TMNaXCnVclwqOXrQsLhGQxWVCsrgsK3tURsKzb075SE6qPbSkfCQnpfutjozkGPXSZ6xrv7UykjMf/3NCI7nPuziS+7zwSO7zAkZh7v/gSO7ybDoNzFyhkcLljo3kvsA4kmtlHMlJ1c8X+mGDFecUnCROqQ7mChc7mCuEO5grBDqYeY5ssOI0YDOFPNikuLZ1ZIPVlYwdNKP++dsKdQBXlmGD1VWMG6zyg9LZQc8Tqp+roIMu1/1144U6vquzgoCvzvLnew2jYZbi+5psj4CZ8i3rZYlbCSnbF7OCgL8ooGzXplzZNN/XCiibDSvHjr4Ls/zXp3F6atelfE3omqC+uevm+my6dUd/DbpTQHc4b/n+UsplqHX7+iz//Dxjm/GvZ6yPG1JeH1pfbhBoyzcK71BOik+vX94owPd2g9Jtu8cK8b1AaBTPbWsZ68dfwLz2Vi7HeqyQY31TVhDwTQKO9ZdT7lhrvr/s+ChunJCy3ZwVBHyzgLJ9JeXKpvn+SplGcflkT6HhfkWgF7sl5SMvPeq6RYDvW5kbqeoYPWyf2pB9ELyPg/fx8L5V8K6f27I9aTn51CPXWwXk91VGb5c8Hs+zyyCf7PFzjHU9OcjndpXn1xTdoejriu5UdJeiuxXdo+heRd9QdJ+ibyr6lqJvK7pf0QOKvqPoQUUPKXpY0SOKHlX0mKLvKnpc0fcUfV/RE4qeVPSUoh8oelrRDxX9SNGPFT2j6CeKfqroWUXPBSN2nDu/PdABDPuaJewOS9jXLWF3WsLusoTdbQm7xxJ2ryXsG5aw+yxh37SEfcsS9m1L2P2WsAcsYd+xhD1oCXvIEvawJewRS9ijlrDHLGHftYQ9bgn7niXs+5awJyxhT1rCnrKE/cAS9rQl7IeWsB9Zwn5sCXvGEvYTS9hPLWHPWsKeA3tID9nu9uBvPtnTy+YktbW3M+TV2dX9fI0R1w4p31MQ8LzqDj75tX2dLy//Tsa6WOREXXT6d7HJr8O/my2vVv8exrrY0Ym6yPv3csmvM+9/gyuvjrx/H2Nd7ORCXbTm/W9yyU/1Pd9iyqtT5fVtxrpY7EBddCie72eSX6vK6wGmvBTL/ncY62Ln9NdFp+b5QR75dei8HuLJq1Xn9TBjXSxJf13orP1HWOTXWcjrUZa8Ogp5PcZYF7ukvi5aCzx/l0V+BZj+4xx5dXbn9T3Gulia9rro6Ob5+xzya+3O6wmOvLpZ9p9krItdU14XqwKen2LgeWWQ1w8Y8moJ8nqasS6WpbsuGujE4w+T8+xTXj9KnFdrF+X1Y8a6WJ7qumhdSTw/k1x+H55k/UnivFo+zOunjHWxW6rrYtaHPD+bmGf/w7yey/LNWe7AeMZl95QcaC3x+IzzZj7jvI+/E2Nd7OFIXTDOD/iM41t/CWNd7OlIXTCOg3xGP97flbEu9nKkLhj9PZ/RX/F3Y6yLvR2pC8Z+zWe0y/6ejHWxjyM31DC2X59R/3wp+WUM+aVhXZny+hmjH6rz4N4DpPdXfTXLvw/q51neuubme0K2Z+8PJ99rUr7rX+vjzwX4PtKRs/u/YGyPjHXtH5lyvdHt5WcCenN0yvm+Xai9HONIe/klY3thrGufU366bvU+ZfIj9G9tJ2g/8i+zPfuRn8/2xOHUs4nZnn2nnPW3LuW3aGqenxfg+3hHxk3PM/qaLzC2VUa98V2pi4mMdfFiVqYNp6ld2OzmC2A3XwS7+Sshuzkp27M3H/NN/I2mlNtNzfOvBPg+yZG2+ivG9vVrRrvJqDe+K3UxibEuXsrKtOE0tQub3fw12M2XwG6+LGQ3J2d7zi9hvknldGrK7abm+WUBvk9zpK2+zNi+fsNoNxn1xnelLiYz1sUrWZk2nKZ2YbObvwG7+QrYzd8K2c0p2Z4znphvUjmdnnK7qXn+rQDfZzjSVn/L2L5+x2g3GfXGd6UupjDWxatZmTacpnZhs5u/A7v5KtjN3wvZza2zPefgMd+kcjor5XZT8/x7Ab7PdqSt/p6xff2B0W4y6o3vSl1szVgXf8zKtOE0tQub3fwD2M0/gt18TchuTs323BWC+SaV0zkpt5ua59cE+D7Xkbb6GmP7+hOj3WTUG9+VupjKWBevZ2XacJrahc1u/gns5utgN98QspvTsj33KWG+SeV0Qcrtpub5DQG+L3Skrb7B2L7+zGg3GfXGd6UupjHWxV+yMm04Te3CZjf/DHbzL2A3/ypkN6dne+6cw3yTyunilNtNzfNfBfj+rCNt9a+M7etvjHaTUW98V+piOmNd/D0r04bT1C5sdvNvYDf/DnbzTSG7OSPbcy8n5ptUTpek3G5qnt8U4PtSR9rqm4zt6y1Gu8moN74rdTGDsS7+kZVpw2lqFza7+RbYzX+A3XxbyG7OzPbcXYz5JpXT5Sm3m5rntwX4/oIjbfVtxvb1T0a7yag3vit1MZOxLv6VlWnDaWoXNrv5T7Cb/wK7+W8hu5nP9tzvjvkmldNVKbebmud/C/B9tSNt9d+M7esdRrvJqDe+K3WRZ6yL/2Rl2nCa2oXNbr4DdvM/YDffFbKbfrbnGxiYb1I5XZtyu6l5fleA7+scaavvMrav9xjtJqPe+K7Uhc9YF+9nZdpwmtqFzW6+B3bzfbCbHwjZzYZsz3eCMN+kcroh5XZT8/yBAN83OtJWP2BsX/9ltJuMeuO7UhcNjHXh1ci04TS1C5vd/C/YTS0DsptVNT1xOOusMdvzLTXMN6mcbk653SzwXMOf71ccaatVjO0rU8OHi1FvfFfqopHRblbXyLThNLULm93M1PTYzWqwm1khu9mU7fneJOabVE63pdxuap6zAnbzq4601Sxj+6phtJuMeuO7UhdNjHaztkamDaepXdjsZg3YzVqwmwOE7OasbM83eTHfxPcNpdxuap4HCNjNrzvSVgcwtq+BjHaTUW98V+piFqPdHFQj04bT1C5sdnMg2M1BYDc3ELKbzdme75ZjvonPMabcbmqeNxCwm/c40lY3YGxfdYx2k1FvfFfqopnRbg6ukWnDaWoXNrtZB3ZzMNjNIUJ2s0XV2UMCdvO+lNtNzfMQAbv5TUfa6hDG9lXPaDcZ9cZ3pS5aGO3m0BqZNpymdmGzm/VgN4eC3RwmZDdbVZ09LGA370+53dQ8DxOwmw840laHMbav4Yx2k1FvfFfqopXRbm5YI9OG09QubHZzONjNDcFujhCym22qzh4RsJsPpdxuap5HCNjNhx1pqyMY29dIRrvJqDe+K3XRxmg3N6qRacNpahc2uzkS7OZGYDdHCdnN2arOHhWwm4+l3G5qnkcJ2M3vOtJWRzG2r9GMdpNRb3xX6mI2o93cuEamDaepXdjs5miwmxuD3dxEyG7OUXX2mIDd/H7K7abmeRMBu/mEI211E8b2NYbRbjLqje9KXcxhtJub1si04TS1C5vdHAN2c1Owm5sJ2c25qs6+K2A3f5Byu6l53kzAbj7tSFvdjLF9bc5oNxn1xnelLuYy2s0tamTacJrahc1ubg52cwuwm1sK2c1tVJ09LmA3f5xyu6l53lLAbj7jSFvdkrF95RjtJqPe+K7UxTaMdnNsjUwbTlO7sNnNHNjNsWA3xwnZzXmqzr4nYDefTbnd1DyPE7CbzznSVscxtq+tGO0mo974rtTFPEa7Ob5Gpg2nqV3Y7OZWYDfHg92cIGQ3t1V19n0Bu/mLlNtNzfMEAbv5S0fa6gTG9jWR0W4y6o3vSl1sy2g3J9XItOE0tQub3ZwIdnMS2M3JQnazXdXZEwJ288WU203N82QBu/krR9rqZMb2NYXRbjLqje9KXbQz2s2ta2TacJrahc1uTgG7uTXYzalCdnO+qrMnBezmyym3m5rnqQJ28zeOtNWpjO1rGqPdZNQb35W6mM9oN6fXyLThNLULm92cBnZzOtjNGUJ2cztVZ08J2M3fpdxuap5nCNjNVx1pqzMY29dMRrvJqDe+K3WxHaPdzNfItOE0tQub3ZwJdjMPdtMXspsLVJ39QMBu/jHldlPz7AvYzddcuWOcsX01MNpNRr3xXamLBYx2s7FGpg2nqV3Y7GYD2M1GsJtNQnZze1VnTwvYzTdSbjc1z00CdvPPrtz5yNi+ZjHaTUa98V2pi+0Z7WZzjUwbTlO7sNnNWWA3m8FutgjZzYWqzn4oYDf/lnK7qXluEbCbf3flDh7G9tXKaDcZ9cZ3pS4WMtrNthqZNpymdmGzm61gN9vAbs4Wsps7qDr7kYDd/EfK7abmebaA3XzblTPRjO1rDqPdZNQb35W62IHRbs6tkWnDaWoXNrs5B+zmXLCb2wjZzUWqzn4sYDf/nXK7qXneRsBuvuPKGRXG9jWP0W4y6o3vSl0sYrSb29bItOE0tQub3ZwHdnNbsJvtQnZzR1VnzwjYzfdSbjc1z+0CdvN9V/YMMrav+Yx2k1FvfFfqYkdGu7ldjUwbTlO7sNnN+WA3twO7uUDIbu6k6uwnAnbT2yDddlPzvEDAblZt4EZbXcDYvrZntJuMeuO7Uhc7MdrNhTUybThN7cJmN7cHu7kQ7OYOQnZzsaqznwrYzWzK7abmeQcBu1njSFvdgbF9LWK0m4x647tSF4sZ7eaONTJtOE3twmY3F4Hd3BHs5k5CdnNnVWfPCtjNgSm3m5rnnQTs5iBXfBzG9rWY0W4y6o3vSl3szGg3d66RacNpahc2u7kY7ObOYDeXCNnNJarOnhOwm4NTbjc1z0sE7OYQR9rqEsb2tQuj3WTUG9+ZumC0m0trZNpwmtqFzW7uAnZzKdjNXWu8Xk+Gue6Ge3wy2rVG1mbmkz3+OKWnNwr0Fctq+HVjGOjGMtAN/dD7RHifDO+fr+55f7Wqf9+nKVoe9FMmX8tr0oMzDl+7Kfy6edZ6Pe3S9rR7LLoxS5dvmAP2NrKshr/P4cbImJcYxokOYJzsAEZty7gwEjb97G42JO6OdTdGR2Z3xkap+R7gdRst8+GuvEkev4LhkzTvrnxba2dza5ukDHarkZEBN84rq93AmfXSrVP0zIU89wiMzZ7B372Cv3sHf/cJ/u4b/N0v+Lt/8PeA4O+Bwd+Dgr8HB38PCf6uCBytXFDuSvW7Q9EqRZ2KuhQdqugwRasVHa7oCEVrFB2paK2ioxQdregYRccqOk7ROkXHKzpB0ccUnajoJEUnKzpF0amKTlP0cUWfUHS6ojMMLJ9Uv89UdJaisxV9StGnFZ2j6FxF5yk6X9EFii5U9BlFFym6WNFnFf2fos8pukTRpYouU/R5RZcr+oKiKxRdqegqRVcrukbRFxVdq+i6AMuyAMv16veXFN2g6EZFNyn6sqKbFX1F0S2KblV0m6KvKrpd0dcU3aHo64ruVHSXorsV3aPoXkXfUHSfom8q+paibyu6X9EDir6j6EFFDyl6WNEjih5V9Jii7yp6XNH3FH1f0ROKnlT0lKIfKHpa0Q8V/UjRjxU9o+gnin6q6FlFzyn6maKfK/qFol8qel7RC4peVPQrRb9W9JKilxX9RtErin6r6HeKXlX0e0V/UPRHRa8p+pOi1xW9oejPiv6i6K+K/qbo70a9vql+v6XoH4reVvRPRf9S9G9F7yj6j6J3Fb2n6H1FHyj6ryLdAVUpyiiqVpRVVKOoVtEARQMVDVK0gaI6RYMVDVFUr2ioomGKhtcGF2wEWDZUv0coGqloI0WjFI1WtLGiTRSNUbSpos0Uba5oC0VbKsopGqtonKKtFI1XNEHRREWTFE1WNEXR1oqmKpqmaLqiGYpmKsor8hU1KGpU1KRolqJmRS2KWhW1KZqtaI6iuYq2UTRP0baK2hXND3ghu7Gd+r1A0faKFiraQdEiRTsq2knRYkU7K1qiaBdFSxXtqmiZouWKdlO0u6I9FO2paC9FeyvaR9G+ivZTtL+iAxQdqOggRQcrOkTRCkUrFXUoWqWoU1GXokMVHaZotaLDFR2haI2iIxWtVXSUoqMVHaPoWEXHKVqn6HhFJyj6mKITFZ2k6GRFpyg6VdFpAe80OPy4+v0JRacrOkPRJxWdqegsRWcr+pSiTys6R9G5is5TdL6iCxRdWNudx2eCPIOf3kXq5WJFn1X0f4o+p+iS4J+XBn8vC9K0B2k+r35frugLiq5QdKWiqxRdregaRV9UdK2i6xRdr+hLim5QdKOimxR9WdHNir6i6BZFtyq6TdFXFd2u6GuK7lD0dUV3KrpL0d2K7lF0r6JvKLpP0TcVfUvRtxXdr+gBRd9R9KCihxQ9rOgRRY8qekzRdxU9ruh7ir6v6AlFTyp6StEPFD2t6IeKfqTox4qeUfQTRT9V9Kyi5xT9zKiTn6vfv1D0S0XPK3pB0YuKfqXo14peUvSyot8oekXRbxX9TtGrin4f5DU4yOsP6vcfFb2m6E+KXlf0hqI/K/qLor8q+puivyt6M6ibt4K//wj+vh38/Wfw91/B338Hf98J/v4n+Ptu8Pe94O/7wd8Pgr//JUUZ0P2nKvibCf5WB3+zwd+a4G9t8HdA8Hdg8HdQ8HeD4G9d8Hdw8HdI8Lc++Ds0+Dss+Ds8+Luh/quFVx383SswwBimHYecEba/Jd5BlngHW+IdYglbYUnbYQnrtIQdaglbbQk7whJ2pCXsKEvYMZaw4yxhx1vCPmYJO8kSdool7DRL2CcsYWdYws60hJ1tCfu0JexcS9j5lrALLWEXWcI+awn7nCXsUkvY5y1hX7CEXWkJu9oS9kVL2HWWsBssevoVS9jtlrC7LGH3WcIesIQ9Ygn7niXsB5awZyxhP7OEvWAJe9kS9qol7E+WsL9awt6yyPRtS9i/LGHvWMLetYS9bwn7ryVMO4NmWLUlrMYSNsASNsgSVmcJG2IJG2oJG24JG2EJG2UJ28QStpklbEtL2DhL2ARL2GRL2FRL2AxLmG8Ja7KEtVjCZlvCtrGEtVvCFlrCdqhdX08XWcJ2tKTdyRJvqSVsV0vaZZawPSxhe1ry28sStrcl7T6WeAdawg6ypD3YEtZhCVtlya/TEtZlSXuoJd4aS9iRlrRrLWHHWsKOs+S3zhJ2vCXtCZZ4p1jCTrWkPc0S9llL2CWWsEstYZdZwi63hF1hCbvKEnaNJexaS9j1lrAbLGE3WcJutoTdYgm7zRJ2uyXsDkvYnZawuy1h91rC7rOEfcsSdr8l7DuWsIcsYY9Ywh6zhD1uCfu+JexJS9gPLGE/tIT92BL2E0vYs5awn1nCfmEJe9ES9rIl7HeWsD9awl63hP3FEvZ3S9g/LGH/sYS9Zwn7wBKmB2tmmB6gtRthgy3xhljC6i1hQ4MwfMzFoqQLPIyT7762VUx55YvxnE/2+JfV8slvxADG01FQ9yP6UPf5ZE+vRbKkctALDUy4RBdx9qxJzHNDV1dzi9/W0ipZN5yLuAc4Ujf71ZTHfiQ+TcLI8/6O8My4oO7v4wjPVYw87+1IGzyQEadeaxvo9d5turFnf3jKnNUok2/zLJl8W5rcyre5TSjfTqF8W2TybcgL1dtKmXwbpfCucku+zb6QHITsjpgcmoXyneVWvmLt2DX9lbLrUv1mg/Ylqoy8uX0hRv/PuuGP3WHlZH6KEPNpdtK3doTnDCPPUx3huZqR52mO8Mw50TC9TDznkz3+DEb5/aHKjUH3TM8NnHlHcPqMOiSJs8EReTY6grPJEZyzHMHZ7AjOFkdwtjqCs80RnLMdwTnHEZxzHcG5jSM45zmCc1tHcLY7gnO+Izi3cwTnAkdwbu8IzoWO4NzBEZyLHMG5oyM4d3IE52JHcO7sCM4ljuDcxRGcSx3BuasjOJc5gnO5Izh3cwTn7o7g3MMRnHs6gnMvR3Du7QjOfRzBua8jOPdzBOf+juA8wBGcBzqC8yBHcB7sCM5DHMG5whGcKx3B2eEIzlWO4Ox0BGeXIzgPdQTnYY7gXO0IzsMdwXmEIzjXOILzSEdwrnUE51GO4DzaEZzHOILzWEdwHucIznWO4DzeEZwnOILzY47gPNERnCc5gvNkR3Ce4gjOUx3BeZojOD/uCM5POILzdEdwnuEIzk86gvNMR3Ce5QjOsx3B+SlHcH7aEZznOILzXEdwnucIzvMdwXmBIzgvdATnZxzBeZEjOC92BOdnHcH5f47g/JwjOC9xBOeljuC8zBGcn3cE5+WO4PyCIzivcATnlY7gvMoRnFc7gvMaR3B+0RGc1zqC8zpHcF7vCM4vOYLzBkdw3ugIzpscwfllR3De7AjOrziC8xZHcN7qCM7bHMH5VUdw3u4Izq85gvMOR3B+3RGcdzqC8y5HcN7tCM57HMF5ryM4v+EIzvscwflNR3B+yxGc33YE5/2O4HzAEZzfcQTng47gfMgRnA87gvMRR3A+6gjOxxzB+V1HcD7uCM7vOYLz+47gfMIRnE86gvMpR3D+wBGcTzuC84eO4PyRIzh/7AjOZxzB+RNHcP7UEZzPOoLzOUdw/swRnD93BOcvHMH5S0dwPu8IzhccwfmiIzh/5QjOXzuC8yVHcL7sCM7fOILzFUdw/lYIZ8bAmfRbqZMZef5dmXjOJ3v8Vxnl98cqN/Tx954bOP/gCM4/OoLzNUdw/skRnK87gvMNR3D+2RGcf3EE518dwfk3R3D+3RGcbzqC8y1HcP7DEZxvO4Lzn47g/JcjOP/tCM53HMH5H0dwvusIzvccwfm+Izg/cATnfx3B6Tkyb1PlCM6MIzirHcGZdQRnjSM4ax3BOcARnAMdwTnIEZwbOIKzzhGcgx3BOcQRnPWO4BzqCM5hjuAc7gjODR3BOUIIJ/e+gEmMPI90hOcqRp43+h+s51Fl4jmf7PFHV/HJb98aN+zOxo7oY5aR500c6RPGJNfHhq6u5ha/raW1WN3kkz3+poztZq8aN2zFZow87+aIrdjckXazhSM4t/wftL05R3yBsYzt+8pqN3gex8jzZbVutMGtHLEV4x3BOcERnBMdwTnJEZyTHcE5xRGcWzuCc6ojOKc5gnO6IzhnOIJzpiM4847g9B3B2eAIzkZHcDY5gnOWIzibHcHZ4gjOVkdwtjmCc7YjOOc4gnOuIzi3cQTnPEdwbusIznZHcM53BOd2juBc4AjO7R3BudARnDs4gnORIzh3dATnTo7gXOwIzp0dwbnEEZy7OIJzqSM4d3UE5zJHcC53BOdujuDc3RGceziCc09HcO7lCM69HcG5jyM493UE536O4NzfEZwHOILzQEdwHuQIzoMdwXmIIzhXOIJzpSM4OxzBucoRnJ2O4OwSwpkxcCbdRz2BkedDy8RzPtnjH1bFJ78RA9zQx9WOtJvDHcF5hCM41ziC80hHcK51BOdRjuA82hGcxziC81hHcB7nCM51juA83hGcJziC82OO4DzREZwnOYLzZEdwnuIIzlMdwXmaIzg/7gjOTziC83RHcJ7hCM5POoLzTEdwnuUIzrMdwfkpR3B+2hGc5ziC81xHcJ7nCM7zHcF5gSM4L3QE52ccwXmRIzgvdgTnZx3B+X+O4PycIzgvcQTnpY7gvMwRnJ93BOfljuD8giM4r3AE55WO4LzKEZxXO4LzGkdwftERnNc6gvM6R3Be7wjOLzmC8wZHcN7oCM6bHMH5ZUdw3uwIzq84gvMWR3De6gjO2xzB+VVHcN7uCM6vOYLzDkdwft0RnHc6gvMuR3De7QjOexzBea8jOL/hCM77hHBmDZyN+ebGBOek/Pere+XV1LQqfl4fmHl1tvhx8/rv+nnFPgs2bIOy1UU3znw8nnWGFp7zcfKqsuflt3VFzyuT5auL4eWui26crVF5ri7Gc0u0vLJF5dfUFSWvGsa62LB/6qIbZ1Pfea4tzfOsvuY1oC/yy/ctr4GMdTGiP+uiG2e+LzwP6ivPLaXz2qDv8usolVcdY12M7P+66MbZUpznwdF4biiW15Co8msJz6uesS42SktddONsCeN5aByeW+15DYsnv1ZbXsMZ62JUuuqigLO5a32eN4zPc97Ma0QS+TX0zmskY12MTmFdBDjzyPNGSXlu6slrVHL5NVBeoxnrYuP01kUBZ2c3UH/jLEdeXTo3fxOmvFRu/hjGutgk5XVBODfN8s01MI5vfRyfJeVxTJnqIp/s8RnHQT6jH++PZKyLTR2pC0Z/z2f0V/zRjHWxmSN1wdiv+Yx22R/DWBebO1IX3+SbT/YZbYHPqMu+VF1kmOviW1V8+nep0DfCudczvl3F5e+tbJPEeb8j60MPOILzO47gfNARnA85gvNhR3A+4gjORx3B+VhVefrgpP1mDSPP33WE51pGnh93hOcBjDx/zxGeBzLy/H1HeB7EyPMTjvC8ASPPTzrCcx0jz085wvNgRp5/4AjPQxh5ftoRnusZef6hIzwPZeT5R47wPIyR5x87wvNwRp6fcYTnDRl5/okjPI9g5PmnjvA8kpHnZx3heSNGnp9zhOdRjDz/zBGeRzPy/HNHeN6YkedfOMLzJow8/9IRnscw8vy8IzxvysjzC47wvBkjzy86wvPmjDz/yhGet2Dk+deO8LwlI88vOcJzjpHnlx3heSwjz79xhOdxjDy/4gjPWzHy/FtHeB7PyPPvGHnWa+O0D28K8F8VyKA6+L9eS9Zrq3qtUa+96bUovTaj1yr03L2ey9Zzu3quU8/96bkwPTek50r03IEeS+uxpR5r6bGH9sW1b6p9Ne276L5c923a1ucUaVug24bWFS07/a3PiYomKZoMOO+v6sG+taKpiqYpmq5ohqKZWkaKfEUNuh4VNSmapahZUYuiVkV6w9VsRXMUzVW0jaJ5irYN6m2+ou0ULVC0vaKFinZQtEjRjop2UrRY0c6KlijaRdFSRbsqWqZouaLdFO2uaA9FeyraS9HeivZRtK+i/RTtr+gARQcqOkjRwYoOUbRC0UpFHYpWKepU1KXoUEWHKVqt6HBFRyhao+hIRWsVHaXoaEXHKDpW0XGK1ik6XtEJij6m6ERFJyk6WdEpik5VdJqijyv6hKLTFZ2h6JOKzlR0lqKzFX1K0acVnaPoXEXnKTpf0QWKLlT0GUUXKbpY0WcV/Z+izym6RNGlii5T9HlFlyv6gqIrFF2p6CpFVyu6RtEXFV2r6DpF1yv6kqIbFN2o6CZFX1Z0s6KvKLpF0a2KblP0VUW3K/qaojsUfV3RnYruUnS3onsU3avoG4ruU/RNRd9S9G1F9yt6QNF3FD2o6CFFDyt6RNGjih5T9F1Fjyv6nqLvK3pC0ZOKnlL0A0VPK/qhoh8p+rGiZxT9RNFPFT2r6DlFP1P0c0W/UPRLRc8rekHRi4p+pejXil5S9LKi3yh6RdFvFf1O0auKfq/oD4r+qOg1RX9S9LqiNxT9WdFfFP1V0d8U/V3Rm4reUvQPRW8r+qeifyn6t6J3FP1H0buK3lP0vqIPFP1XkTYGVYoyiqoVZRXVKKpVNEDRQEWDFG2gqE7RYEVDFNUrGqpomKLhijZUNELRSEUbKRqlaLSijRVtomiMok0VbaZoc0VbKNpSUU7RWEXjFG2laLyiCYomKpqkaLKiKYq2VjRV0TRF0xXNUDRTkTZyvqIGRY2KmhTNUtSsqEVRq6I2RbMVzVE0V9E2iuYp2lbbWkXzFW2naIGi7RUtVLSDokWKdlS0k6LFinZWtETRLoqWKtpV0TJFyxXtpmh3RXso2lPRXor2VrSPon0V7adof0UHKDpQkf6Ovf5G/CGK9LfN9XfD9Te59feu9bek9Xea9XeL9TeB9Tdy9fdn9bdd9XdT9TdJ9fc+9bc09Xcq9Tcg9fcV9bcL9XcB9Tf39Pfs9Lfi9HfY9DfO9PfD9Le59Hev9Del9Pea9LeQTlekv+Gjv4+jvz2jv+uiv5miv0eiv/Whv6Ohv1Ghv/+gv62gv1ugvwmg79vXd9nre+L1Hez6fnN9d7i+l1vfea3vk9Z3Net7kPUdw/r+Xn03rr53Vt/pqu9L1XeR6ns+9R2a+n5KffejvldR31mo7wPUd+3pe+z0HXH6/jV9t5m+N0zfyaXvu9J3Sel7mvQdSPp+IX13j74XR985o+9z0Xel6HtI9N5xvWdZ7+HVfYree6r3deo9k3o/ot7rp/fR6T1qev+X3g+l9wfp/TJ6/4jeT6H3F+j1dr3+rNdj9fqkXq/T61d6PUevb+j5fj3/reeD9fyoni/U82d6PknPr+j5Bj3+1uNRPT7T4xXtv2t/Vvt32t/R/X+hYw6eDXteC32pflasW9d55NHrcuuOyq1YtSr3sdXrDssddULnsV1rjtIm38tBGur3lx6/Zs3qrtWdx+ZWHdV5XG7tUetyR65Y13FY7oQVa47vzK1eq7NZ23mc7kMKRpSeccHfZccedcLqtYfm1n6Y0eq1HWuOP271UWtzXStWr+nUPVfBjNKzafC3Y8WaNQWsxx3Xeey6g49cceLBK1evO/i41Sfrjq5gcSMmeTp6kh9FT/KT6EmejZ7kV9GTvBQ9yavRk/whepLXoyf5c/Qk/4ye5N/Rk7wbPcn70ZPobjZikoHRk9RHTzIsepIx0ZNsFj3JhOhJJkVPsnX0JNOiJ5kVPUlL9CTbRE+ybfQkC6InWRg9ydLoSZZFT7J79CR7Rk9yUPQkh0RP0hU9yWHRk6yDJBODv8uOX7lmdUdu1Yp1K3LHrVEOh/Y81k4ixwP8jeMTpT4hUerzMj2pJ1DqwNc5ujsXcpHWd3cuhMR99c4+GyPNrOrINdISPUl79CTbRU+yMHqSRdGTLIueZLfoSfaJnmS/6EkOip7kkOhJVkdPckT0JGujJzk6epKToic5JXqSM6InOTN6kgujJ7koepLLoye5InqSq6Mn+WL0JDdHT3JL9CR3RE9yZ/Qk90ZPcl/0JA9HT/Jo9CSPR0/y/ehJnome5KfRk/wyepIXoif5AySJ7tr8MVHq1xKlfj/bkzqyW3VXTU/ivrhI2gHcIoi3pCdpYSFKP/OPPXbFSaqkVZ0n5o46fl3uqK7cyqOOX7vqOEy4W9yE+8ZNeEjchNd58eVzY9xCb42b8IkEaJ9PkPbXcQH/LmrCbwSRJsRNOC1uwsa4CWfHTbh93IRnQcK+ViWlPSduoZ+Jm/C2GGgfCOIthbRj10973PEr1x27omNdeAa7QwYjgr872fFSkr2iMkoJD4he1sFxyzrGiy7UB4N42/QdJyVpj4qTEu6SAOfy6Dj3iItzVQycZI2XQdpISkoZ7Nl3RinJPlEZpYQHRS9rRdyyjvOiC/XHQbwISkpJ2qPipIRxlJTSRlBSShJZSSlhHCX9ZRAvtpJSBhGUlJJEVlJKGEFJKUlkJaWEcZT0ZS+hUF+OLtSX4wr15ehCfTmuUF9OINQ/BvEitHxK0h4VJyWM0/IpbYSWT0kit3xKGKflvxnEi62klEEEJaUkkZWUEkZQUkoSWUkpYRwlfSeIF0FJKUl7VJyUMI6SUtoISkpJIispJYyjpJlgxSm2klIGEZSUkkRWUkoYQUkpSWQlpYRxlHRQUqEOii7UQXGFOii6UAfFFeqgBELdKEgbe0hKGUQYklKSyENSShhhSEpJIg9JKWGcIenoIG0Ec0pJ2qPipIRxzCmljWBOKUlkc0oJ45jTsUlb/tjoLX9s3JY/NnrLHxu35Y9N0PInR1fSyXGVdHICJZ0cXUknx1XSyQmU1E+qpH50JfXjKqkfXUn9uErqJ1DS1qRCbY0u1Na4Qm2NLtTWuEJtTSDU9ugtvz1uy29P0PLbo7f89rgtvz1By1+cVEkXR1fSxXGVdHF0JV0cV0kXJ1DS5dGVdHlcJV2eQEmXR1fS5XGVdHkCJd0vqZLuF11J94urpPtFV9L94irpfgmUdEVSoa6ILtQVcYW6IrpQV8QV6ooEQt062FcSebGcEk6Lm7AxbsLZcRNuHzdhnMVySht5sZwSfiZuwjiL5fkgbeyZCcogwswEJYk8M0EJI8xMUJLIMxOUMM7MREOQNkKvSknao+KkhHF6VUoboVelJJF7VUoYp1edG6SN3QFQBhE6AEoSuQOghBE6AEoSuQOghHE6gAXRlXRBXCVdkEBJF0RX0gVxlXRBAiVdklRJl0RX0iVxlXRJdCVdEldJlyRQ0t2TCnX36ELdPa5Qd48u1N3jCnX3BELdP3rL3z9uy98/QcvfP3rL3z9uy98/QcvvTKqkndGVtDOuknZGV9LOuEramUBJ10RX0jVxlXRNAiVdE11J18RV0jUJlPT4pEp6fHQlPT6ukh4fXUmPj6ukxydQ0lOTCvXU6EI9Na5QT40u1FPjCvXUBEI9J+mQ9JzoQ9Jz4g5Jz4k+JD0n7pD0nARD0vOim9Pz4prT8xKY0/Oim9Pz4prT8xKY00uStvxLorf8S+K2/Euit/xL4rb8SxK0/CujK+mVcZX0ygRKemV0Jb0yrpJemUBJb0iqpDdEV9Ib4irpDdGV9Ia4SnpDAiW9NalQb40u1FvjCvXW6EK9Na5Qb00g1Luit/y74rb8uxK0/Luit/y74rb8uxK0/AeSKukD0ZX0gbhK+kB0JX0grpI+kEBJH4uupI/FVdLHEijpY9GV9LG4SvpYAiV9OqmSPh1dSZ+Oq6RPR1fSp+Mq6dMJlPTZpEJ9NrpQn40r1GejC/XZuEJ9NoFQq4ObEPQVunHTTqyKCJgS7peg0EPjFnpM3IS3JEBblYmfdtNMTMAT4yb04ybcNm7CXeImXBk34WEJauTouIWekKDQj8ct9KwEhV4Ut9BLExT6ZIK0P48L+DdxEx4R4y4ZSntyTcxCz0hQ6NNxC30uQaEvxy309wkKnTggftoVCdJekiDtzxOkHTMwftotB8asoIlxE06Pm7A5bsK5cRMuiJtwcdyEJyWoyrviFvqtuAkfjZvwibgJfxo34fNxE/4ubsLX4ybMDIqZcHDchKPiJszFTTg9bsK5kLAPl91h0u3ilnkiJIzaKM+OW+gFcRP+MQHagRvELHRE3IQHbhAf7c0J0t4TF/CDcRP+MwHa6rqYhQ6Jm3D7uvhol8UtdO+4CVfETXhoAjYX1cdPu3N9TMDL4yY8KgHasxOkPTcu4IviJvxqArSPJkj7vbiAn46b8PUEaKuGxk9bMzQm4Lq4CackQLttgrQL4gLeKW7CQxOgPS1B2jPiAv503IQ3JkB7T4K034wL+MG4CX+VAO2f4xb6VtyEw4fFRzs2QdoJw2ICnho34U4J0O6bIO2BcQF3xE14RgK0n02Q9tK4gK+Mm/CbCdA+EbfQH8VN+OcEaKuHx087YHhMwEPiJpyaAO0xCdJ+PC7gs+MmvChuwmsh4dj12Tzy+DXrVh+95qRwXm+IW/LDCQT83biFvpKg0N/HLXTghvEL3SRB2s03jAl4q7gJ5ydAe36CtJfHBfzFuAm/EjfhHXETPgwJY7XU78Yt+ZUENfP7uIVWj4hf6IARMQsdn6DQyXELXZyg0P0TpD04LuDOuAnPTID26QRpn48L+DdxE74eN+GbcRPWjuxJGMs8bDAyZsmTRsavmalxC90xQaFL4ha6OkGhR8Yt9KIEhV6bIO0NcQHfEjfh9xOgrd8oftpNN4oJeDIkjLgwOD1umU1xE+4ICWMZiCVxS16doG6OjFvoeQkK/UzcQu9IUOjDCdJ+Ny7gp+ImfC0B2v8mSFs9KibgQXETThoVH+0RCdLemSDtg3GZ/W+CQseMjlnohLgJ83ETzoubcEnchOePji/Yz8ct9Lq4CW+Pm/DuBGzeH7fQRxIU+k6CtO0bx0+7y8YxmT0tQaHnxi300rgJr0yAdvdNYha63ybxC10dt9CjEhSaG9OTNpZrNn5MTNTzx8RHvTBuoSsTFNoVt9AzExT66biF3pCg0JvjFvrdBIU+EbfQ3yco9E9xCx2wafxC6zaNWejkBIVOi1voTgkK3SVuoYcnKHRt3ELPT1DoRXELvS1BoXfELfTpBIU+E7fQvyQo9M24hY7cLH6hExKknbJZTMAz4ybcJQHajgRpD40L+Mi4Cc9PgPa6BGlvjAv41rgJn0iA9qUEaX8bF/BrcRMO2Dw+2s0TpB27eUzAk+ImXJgA7f4J0h4cF3Bn3IRnJkD7hQRpr44L+EtxEz6cAO2ALeKnHblFTMCbxk04IW7CZkg4dn02Sw80Z8ctee8EAt4/bqEnJij01LiFXpOg0K8lSHtXXMDfjJvw5wnQbrJl/LQTt4wJeHrchPMhYax2szBuySsTyKkrbqHnJCj0CwnSXh0X8JfiJnw4AdqhufhpVyZIuzYXk9nj4yY8NW7CT8VNeHHchJfl4gt2l7E9aWO18uVjY6JeOzY+6mPjFnpRgkI/F7fQOxIUenfcQp9JUOhzcQv9V4JCB46Ln3bwuJiAN4ybMJ8A7Q4J0i6OC3hZ3IRrE6C9I0HaB+ICfixuwl9Awli28MW4Jb+TQE7vxy10y63iF5pPkLZpq5iAZ8dNuE8CtFckSPvluIBvj5vwEUgYS4Ufj1vybxPI6Q9xCx00Pn6hYxKk3WJ8TMDj4ybcLgHafRKkPSAu4JVxE56eAO1lCdJeERfwtXETficB2mcTpP1FXMC/jpvwvQRoN5wQP+2oCTEBbxY34ewEaJclSLtHXMD7xU14YlS0dAVMTVX3X7i3y8t5PVdd55M8rf6KWsgcbp3s+U0FD+wpuw7jBuE6LLj616sKwgaAlAppjHIKaYKwagjLBmFZCKsJwmqg2IHs8sgXrvMbxJ1v3m8aGPDBm2/e1/kO5s83r9VuiNcj8xyUMwjqgC57qWLkCcuuCojKofAsvG8MceHymQLm2uB9MKSnO6/qi6QbaKSrhzgbQLrBRjr6/WH7hXT6eDC1AcIspG+tdV5PW/EAr2fgpQfrtJYdT97XMqPlt0M71y09fs2a1V2rO4/dpfPIlZ3HHnfY6qP3Xr1ubedxx1UBWGJgY4OBKq83Mx9AHDRi+F5tCctB+oEQh5PxKhAo5V1rYBoIuBjLbkCj7IHsPIsMUDYazwb8eBp7dRx9wLMB4OFvJN3GU4DPPBr7Dzxeo2wanIwhq3pvfSMk1EkUdHsDAw/9pvIqmMuDWeMxbVwdxKtOCUYKww5Hog0WHMkgL8pf9yfbQLkD+MttrAL5k+NEOKi8LMR5BuLOD96HwP/RMR5ohEnZxSpv/QEH/R4EGAcADvor1YcOMPAMsMiCfUCQ77blEg4atpeaEBlnIQ59ogjuZvrwsbU9HCjpZwjISrhfLbSBuj7wRnF2L8FbncEb+inEG/FUJ8ub1ICr0TbgIvyDQWYUZ78SMhsSIjNsv3XwTjIT4K0BB4qM+RZkNtSQGfY1JDOKs6KEzIaGyAwHjyQripuBeEOMtAMgjn4+CN4pHvY/kmMAtJ3Eq2fw6hlYZerMb4o6BqgHPEPZ8XS3ZyqD01fX+Q4TkJ/Od7iQHDbkz7cwZqEra6iNUjnDoG5Hgi5w8YRl05wBlUPhWXg/CeLCVSO9bAFhr4c4OJG0oZGOfg8HGRwD6UwbUQdyQf9Kos6rvN62MAe/hwNGChsKGLOAjfg6HcIkJlFxXGb61uhXUJzLIe5ZwfsQ+P8A4GegESY1EVbMt64FjDg+or8C45UCnkEGnkFF5IPjEXNCVIehjtDfYcAXhZF+4Ria2sogCDN9PZzTqocw0gMsn3zgYRBGMh4OYcQnlh9FTwT67aJ6gv6GTU8E8DTZ8GQNPDiRXmvEobRZiHN98Nfmj8n0993jLirPHJsMBYwU56YiGG320zbuqjfyEOKtUEfDDd6yFt4ozm0GLnxk+pxu/0XCj8O+N+v1tmPIO8X5OsjpruAd2zf2M49Y/k9PMd91OMhypADPOt+N+PMt+GyjgP8clIM8jQYZcPGEZZPPRuVQeBbeH4a4o416oDok7Lotkq83uki6gUa6eoiD/uRGRjr6TXWtZfcNeCc9khkb9PZ3TV6ywMsIeCc8UnPCpm9BOHCuPazPQJ+O4jwZ/LXZLPSn0V+gtOXwp82FZFz8JYxmf1Bn4Rn9aZfng8uFx5QfzokW80UozgvB37C+kH/zRrcvYo5nUG8JI8V5qQhGzItw2nwRc01moNd73qqdhbfuubl6g7cs4CDeKM6rRXiTmj8U4t3HuUTyRQZYeKc4fwI5vRG86/qnOsL1pHct/6enmC+Ctv6jMn+EPKVh/ug/ELfU/JHWA9L1kUXSDTbS4bzTMEjXl3mnv8E76ZGMbbPPLeE6BvFCcXBdnfoznBuwrWNLzYeErWMPAIzmelPYnBitN99t/I8Vd2tDl/RGzjHAJ+dGzsKcTBBWC1DY/YbWfIvMXoOGVin/Wah/ytv6ZioH14apf+K2qThfjn0lrtnR+yYQ11yfM/tUXNMcWiTdICNdvbf+vGWVt/4aKv1Gn43S4ebO6UGYjP/bsCqNmztp/+WhneuWHb9yzeqO7VesW7HHsZ2dRfZ1TjewV3nr7+ukOJV9nT2PlF5h30d2wdw3gGOmicHfqHtScP66THtSfBk/p1tm5hgO1y9IZhRnegmZhY3h0GbZxnACPlyDTP/TLTOz/zH3omAf0FRCZvUhMsM8zX0hUuNemfntbpmZ6xbmXhRct5hTQmZh6xbYl5rzVBlv/b46F4Sba8S018XMQ8cXWgMQ2hvRLXsaT5Hssd/XD64tLDR4xgfzIpw1huxwbEhxhcbtDXUGHsLoGRg9g1+ZNY2GVlwb7guekYBnBDue7n6DyuDeH8S/dtM9FhklJIfR/PkWxiLkO1LbonI2grrFcQAXT1g2+Z5UDoVn4X0/iAu3uRcwk84S9nqIg/M75lqTubalZbAb5GHO49SBXNA2SNR5lRe+xjUKMFLYCMBo7g3QfK0AvAJ9ZGE+Pcr69ykQtzN4HwL/3xD4GWKESc6bhY070Z/BvoLwCMy/+rbx81CLfOi92iIznCsjHnBuj3xbXA8z1yh1GLUjW1vA8XvGgo9woSxxXor+mv427hlC/aa5h5EQZq4b0z4iV/VJAM8sGx6zHqq8Hvmba3c4PqA4Zwd/w9aO+M+FdPuEpAOmP47rixTn3CIYMS/CafPHzX15QrwV7GjYGSbkjeJcVIQ3mTmQbj+Hn/feaz60djfUwjvFuQTkdFnwju0b+6MbLf+np5iPi3sgBfb7+EL+Qx79HdKjURae0Afj4gnLJt+OyqHwLLzfAHE3NuqB6pCw67oju79xkXRDjHT1EAd9wlFGOvpNda1ldwW8kx5JroGNDOEF1+4oDs4vS+2rMX0QwjEc5BjWZ6DvR3G+GvwN20eE67T6QT8F+2ypvb9he7IzgNG2T9vkGf3udYDb48bdmm8stgYZZa0R+THXGnGdpQqyq+HmJ9+Ql2lf3flK9F3oq9JTrF8h3rSubAQy1olqjfhS/qnQ2mnRC2zQf0rDBTZjIG5fLrChdk9xdb3ZztX3Jb8kF9ugX9RfZyCE/EupNba8VDvCPTIe1KNnyI8e3Buv2341JNrAiI/thBOz0DpA3rZWMtTgG30V7raP+7JwTorCcZ1mJsTFee+c11MPODandkhxM976+xIG9jG/eoiD9ipsvgfX7MZDWVLr63UGDvqN6+sS+zej3ps0xIKHUafyuCcOy5Jok3H3leJ9OMIYe93tgjq5jWi5DVafwsSB/fpCiDsfZGPby2+7u8eMR/OJtvZe7r1atnX6xcDvkYBN4B6BLtPHynm968Az8JpjQtv9ELsGf0vdD2HO9+E+e+k+JWtgwfVnirNHCT7C9hEMsOS1dx/z8rze/iXOWw418iiGIQNx8DwfprGtuR9olGHi3DCkvEGWvA7pY16e17tfRZ7N9XvUV10Wtlk8F4r7zduD93yyp9fZSGrHIwzMyP+hwV8tqzWQDm2tDT/2U7jPRmKMhf1NvQWvvA2yr62Y9qWYDbKdBTnWkCk+dZa02O8dCvx63Pwa8ztVFmzm/I45l1Nl2TeeMfaND7fEGwh85zzesVitUL4S87JR9/0Sb7b5nRojvszeeKl9l73vwjT3EOI5AgF/3MeyyZ6aPhnu+cT5HdNe2PYq4nk9/eh6s93z0Jf86r31+7piYyvc/1uO+Z2we/2w7UvsB456D9UgCx7O/WD13vp7raXaZNR7DPBs1kALxjTMZ9VZ8DDWj2878yU1d43jQbRx00Vl7hdsKp4/z3m9x6j6wTW0VojrB+94Dhz3+WN7pvzoHX2EWiNtqTuAKD6Njc11MrR1Jk+4p0G6n8gaWND3ozjzgr+lzgaYfNRa8prfx7w8r3e/gfNM5l6tjLf+OsAHRlxss/VF0mG++jHXNNAe4rwSznnQX4G7xnqdkaO8qw2sWJ+1RhycX6A4S4O/pe45pfotNp9RTJ8ozm4lyhsaUl6tJa89+5iX5/XWJ1z3Ms/m4fmAvuhTsXRYln4GG2mw70JM5toXjmvZ+g8/n0dMiB/x2c71SI1bzfZv6m0x3UabRnE6g79h49Zi/dmpwK/HzW8/7ksgPumvOZ+bhf+fAPFQF/nHp77Q/gM/L+mrR7nDlnizjXspH5xz+6ic3cY+MQ1ntzeHuH05u22uT+p6M/uBgX3ML8mZ7jTs75Ipu7uNbiCUr0Q7wjMDHtSjZ8iPHtQhc18D5SN7D2N32xe4363Q9s3zLeb9KXgOhLvt49oWringegy9N0Bcc73ErAdc06S46COhfetLfrh/E+1V2F3H6AdPgrKk9jWE7a3CfQ1Sa/tR9jUIr+Hkw9aLJNpk1D332K9hnyKIMY/z+6iT7aLl+lafwsSB/foiiLt98B62r8F2DvAkSGNr47hO3M7CY+895GS/0F4QjxRnCeA9CrAJ1HuX6VflvN717xl4aTxmqyOKszz429c9AObYvxz9iLmuj+v9FGevEnwMD+FjoCWvffuYl+f19ilRR809CMUw4BwkninCNMgzxTm4BM4RIeVtYMlrZR/z8rzefSnyTFhxbwK2GWyztvsBuPUn7E6+egv/q4O/WlZrIR22Lxt+7JtwHUxiXIV9zFAL3jLYIOvdtaZ9KWaDUPYUh86bhM0JmWnNvu7DORiP1w+gPqkayj0JcJnrA8X24hFWenJcWFvzTThvZfptGs+Hc1ADe8ru63xWr74Z5rjw3HO1ZY6r2pjj0jaHbFjnkavX7bm2c23HsScdva5z1ZKjDqVY+sGejJ4PvN6c4ewchmctYR8Yf3MGV7gSnjHyGeT1tlQe5NEevOeTPK35Fqw981ROBgsuUXsiI5HW7lEq/66a/CyZ01i9TzfZds6i5yLBl24deBqw1tI6ai2tg9IcvaLjiPnHHnr8kZ1r1x2HjYCAmw0DG0MG/prmCePlgt9mXmhua4EJdMv1oxvG6RO630UaRlvHrFINg0xU1cDePH14xagR/uE1oyB8Hf7hVaMQnsQ8ogyrIezD5TII+/BqADCtv/QgjWUr3ADD1BeWyIk3CBtEfEHYBoY8C9NmUDaFDQajQmFDgh9o+uuDsF6f9gH+6O+wIAyXd4cHYdhYNgzCcNluRBCG7tVOwXvO4zJ03Z8cWcydb7DNbwl7vt2GeRf+fAvD/KVBXjR0oHIWQx3sGrxzu+1LId8qKIfCs/A+BeJSPJIHuZOEXevZzsH7rkXS7WSkq4c4O0O6XYx09BunBLYM3mV0trGis8Hjks62QFxT98hF7k+dxe1j/Do7S0hnZ1V0NgJPUXV2IcQ1dY+mVfpTZ+kaUxmdXVGxs8Hjks7uDnFN3aOrc/pTZykvGZ3tENLZxorORuApqs6ugLim7tGVUP2ps3TMU0Znu6R0tqOis33nKarOHgVxTd2jI039qbOdwbuIzrZ120N+nfUrdjYCT1F19jSIa+reZsF7f+rsccG7nv9qDybctgjCZPS4yZfR43xzRY/7zlNUPb4A4pr6SHNP/anHnwzetR4vCvR4LITtGISNC8KEdLtNRrebKjY6Ak9RdfsqiGvq6FbBe3/q9v8F7zI629pW8Su6H5d09haIa+pesFzarzp7bfAuo7NtQjqbr4zfIvAUVWfvg7im7tE29/7U2duDd+0v3Bj4C1Mg7KYgbGsI+3IQNhXCbg7CpkHYV4Kw6RB2SxA2A8JuDcJmQthtQVgewr4ahPkQdnsQ1gBhXwvCGiHsjiCsCcK+HoTNgrA7g7BmCLsrCGuBsLuDsFYIuycIa4Owe4Ow2RD2jSBsDoTdF4TNhbBvBmHbQNi3grB5EPbtIGxbCLs/CGuHsAeCsPkQ9p0gbDsIezAIWwBhDwVh20PYw0HYQgh7JAjbAcIeDcIWQdhjQdiOQRhu3Hmwqvuv/jkk+H/OY2rD/squwv4Nr/dTZfzOwTtuMZS4CkTnSVtlO1asWbPs2NUnrFjXucPxazvWrT5qbRVAJNgkIvwfsvABxMHtPaX29ukHbzfCtAMsYbjvz/Yb8UntSdN5h30tGm8FrJRd/rIFTm814BYweoo1XzzRJfHl3agnumpl8fQ60SW8H7OoHuDNLgI3sTXg9sC+yB1vnGfvVmKckMduhf+Usdzpd51vfZAX5+1bWlZDDVkVO1EufVqxygs/qY4YSAdxiyfeBJMGjBSWATwSbaCYPcA6xK3OpsxqUiYz3H4beKgf2lWNtQ7cVQl7rrPHW4FzFhz4lbPtJvRgGxpgG2JgNvlBmUvcHlIFZXkGD/hVbbTRFEbv2I9LuOHoX5sY8asctPW6NoQPvJFnTCD/sC8cVVtkgPl4QV51RpguU+KmB+SP8qbfeAMYbl0nPFL+BelElde7T0BZ1PGXnZeUMdo6m4zxBvtJRXTIZsvQpnrB/80biwd6ErcPFa+vgWUs2ytStoB9a0Bb6gH/noGHHry5U0DHGqJOceBtZxJ+gRCfZfVFBxmyKrcvGnZjCZ4Mdg0z3giIdst2w2R/YrR9VUWqbwizYViHtmOEeHtWmmTW68Y+eCesS2T95waUKfW3GUN+6D9nwX9eVsJ/HmSEldM3pd84viK+bP4k+s8C/lKDbexn+iKoO7UhfOANuvv30X9GGeAtXFS2zZ5IjX/D2sYQ+GvaZUmfiHSC/DGcA6C/Un2zgIwLembelGTKGG9KOqyE/2zeuGHeAIvjHbxVBvsCSpvx1r9NiY6Rm3nkPFl/S8D2F2Qf9tUg2w1Ix5aQvXkbnO0rPiQvipvxet+GT3npcNOWkOwpHt4aLTnXEdbmbF8wkCrbK1K2QB8Vecxhu+2ZDY+/sqPOi/b1AjwCL3BzZK82yTlW0fmyf/FbyU/nu6GQHEbw51sYs9FxSbJNVA7eM7MR6AIXT1h2VUBUDoVn4f0zVT1xKR7Jg3SWsNdDHBzrmbeG0W/8ytqnqnryMG1j4ZqI4B1tg0SdV3nr3+xm3r5W763/lVYR3S5hJ/H2Mds4C2+aS5PMcGxljhk11qtgnMXu7yl7YZvXNHHgvObj43viXgvjLHMci3YcZS7xdS/bGIZ+41okjWds4w7R/QaBnAeEYMRrjHCMa+MjC3Fu7eM4C2VA7zjGs/kaUnMQYe13KGAknnHMI+V34Rg3B7/xqyqkv3hVj20OQWI/QLE5hAxgNMfsQvMFRdtapWy5dQFc39NPlfE7B+84PyH1VYkoX7oWHj/lcd4Sy5Jqj2F6gPZKYhyPtrovcsexkYA/NqvO6712UQoP+vNSYzUBPvPoK3KvV5njgaGGrOq99ccIQmOxor4r3hxcwVzB/FHBrPGYPiiOFzMpwVjOMXZY/4Z1SP7IAIvM6lImM/TTaByL/vtbMMYW8E9moUzN+XfcN0ZxzoEx9r9gjG36mzhngDKX2C9vG7+aZ0twjcw25kS/VMA/Ksi5NgRjsZvYTT5wLSQTGADbGBt5w3kcm+3or7mmIZ79CwPSY1UaT5fn61zdZYd9pahStkhfEXk8gvon0R6w7fUFz4bCeIrVjbDvUxizjOTPt2BjaV3DXK/BNROKs1kR+4l5EU6yp5TnEJDVRiCzjfh561VfZL+G9UPZXpGyBeq0MG4exZ9vQVdGB3mRrhB+Ki8LcSaV0JXRhnxIVyjPISCr0SCz0QIyK6Yr5SzbK1K2QJ026Hw35s+3oCubBHmRrhB+Ki8LcRpK6MomhnxIVyjPISCrTUBmm/DzVlRXqLwM8Ik6k4E49H/aH2Piz5WJBy+EByHdaNT5juHPt6BzmwZ5kc4RfiovC3HaS+jcpoZ8SOcozyEgq01BZpvy81ZU56i8DPC5CcTNQBz6P+mcib+qTDx4ITwI6Ubh2tXN+PMt6Bx93Zl0jvBTeVmIs7SEzm1uyId0jvIcArKiuDg3IrxGUFQPcT6JxhG2+SQcx2wuhDFsHG2TGY6vTH2k9pMx4lL7wbZH8T+q4/G+fKmbfR3I2GtBbazWqA88O9BRoo2V2reBe/gHFElH8XHPmTkXVWvkg3NRq4vglJz3C9Oh2jKW7RUpW0qHzK+TUp2gDlGcY0rokGlfbPuTiKfhRdKZYx6bDg0w8kEd+lgJHZLanxWmQwPKWLZXpGwpHTL7erMPwb7+ExH7enNdBuejNy+SjuIX0yGz/0MdOruEDkn5EWE6hH4CYUJdynjry536Y7Ot5MrEgxfCg6Qukn9Juri5IZMsxLm4hC5uZvBBukh5DgGeNiuSjuIX08XNjXxQFy8rghP3BVFaIb++qH5i2cQL4z4SH8vQdWu23Y+cPgdrD1Hm+nHdfEshPMMi4MHP4G3Bj8cX4rOwrkB8cO+FGmvIapghq3qIkwP5jRWQXxWUS3nTbyrPRcy2cWwdxBueEowUhp94ENDnojYM69A8O4Ayq0uZzGz3c9F6mu4f7s/04BWYry2cNx0D5eUAB87lU5zFsN/loQDbEIiL+11GGmGSe4yoLMp7pCFLjZHWE3ANit5xv4tEH1jlrb/fjsrGOTea46sN4SMLcZ7qoz+FMjDP6+G+YLQnUmf3zftT8CwJ/SWeyzHfSTpBfuAoiywE9j+Jnt0396+ZMsb9a78oMXYw9xeS/mCe5t69DJSF8yMZb/3z5zS2M/PQ8SXP7kvcUWWbQ7DtHaQ4r0ScQ8B2TH/NsVwG4uEZdB1u2hKSPcXD/QpS+xeKtTkqT6ifaMA+yQMM+OTgfQTg4deXhnyd17tPKIUHz8tIrK0gn9zn5/nHTd2fn5UYHwr5hoVx07ggL7IPVA76zluBLjCV7WPZVQFRORSehffq4EBqndejgziWorQkI2yv+qmHOIMsvOWYecsZeOj3VjExD00J5rFGHPpNeq/16B+ZHvymjdf1R7qF9jUnxNMWBl5s94SRwnDOS2JeBfsaypt+bwF4aHyysUVmdSmT2SjARWMy0tXCfGJ1D17+PWV+wYZtDOXlAAfuE6Q4h2zVE3ejABuOF3GMaO5NFRqL+baxGP2m8nC8iH6XOabFuUTUFakz+WF7bNAfN3kphxyrQuQoWXZY2x4mWw+R54+xL5HyI6Oc7cX+WHp8xe1HCvi9Ff80eFzyT+dF9E/RDujHBf+0GObNU4J5rBHH5p/OrO7Bb/ZX6Guh3c4J8RTF18L7J6X80zA/xOafjrTILG3+KY47yC/EObEl4J/yz/H41jvqxhjY8J64E8b1xF0G/qk5N499LOppf86T2+ZiTV8U15VQV6TuaBpi4DbnP4dYeCmHHKtC5ChZdljbHiJbDw1Y5x7w7xl46MH+j9/OzcpHvbcUfQ2peU4qg9s/3RL448w3J1AvQn7kLCGfpGDbg+XnD207lkM6M4G/Dnwsm/xTKofCs/B+Nvin5LOi30RpCTu1D4pbD3G2sPCW82R8b8qbfk/4H8K8pYOYK7oRH7M53qLfZBO1jTkcxi6mL4NjT+zTxwnxlDPw0m+UMYXh+DAnhCfMR80BHvI5h1lkVpcymeE8ncSej7A5+0uqJcvtHhOZ3xQwceA+7Se27Il7OYyJcG5cP+jXof5LnfsL2/uH+9iJH8Rljn/qIA3qoNQY39zHQb9xnsHkpRxyrAqRo2TZYTZDeC2wAevcA/49Aw892Efl2PF0z9lvEQFPDvBI7K2V2isuNVct02d0z9kLjF0ahHydgm2fGORFtp3KGQc6Myl45x4TTYR8q6AcCs/C+8MwJqJxEvpjlJZkRO2D4tZDnJyFt5wnM96jvOn3pJiYx6YEs+mr02/Se61Hd4Lfa/ZXOKZFuz1eiKcwXx5lTGE4hpPyKcP8EPQp8duwpszqUiYzHM+QX4hjoB+Bf8o/X9ntn5rftRhjYMPvWry0RU/cn4J/Sv9H386210jqbErYOgmVh34e+n6mLxp2XiUnhDvsvEoOMJq8lEOOVSFy7M/zRUL10IB17gH/noHHfJexc435OqO8UnjQ1xDw93zkk9s/lZirlrHtjXkhP7JRyCcp2PbJQV5k26mc8aAzU4J3bv90MuRbBeVQeBbe6SPuWvfJZ0W/idKSjHLBO8WthzjjLLzlPBnfm/Km31NiYt7KQcxpkbM5DqDf1Fa17v8ZfGqzj8UxEfY1E4V4ChsnoIwpDMctUv5qmO+E/ir5QptbZFaXMpnhWIl8WRxf1Wd78PLPtXX71FtAeTlv/f04WYjzxOY9cTcMsKFviv5ozgiT6vOrvPV9HvpN5Q3xet8pSGGm/1wHacqx7jDWwE2/xwHGnMFLOeRYFSJHybKpfijvMZayBeqhAevcA/49Aw892JcI+G4dOAfQFzzoH0ns8RSy5718VO57R8y+2DavQXEmgPz6q0+oYC4PZqGy8zbfziaLSRY8/TXHKzTf32ssV0wWky14JpdZFjju+6hjnuggZhflPKGCuYL5I4S5YusqmMMwV9pgBXMY5oq/UcEchrmiG+XBXLF1FcwfJcwVW1fBHIa50gYrmMMwV/yNCuYwzBXdKA/miq2rYP4oYa7YugrmMMyVNljBHIa54m9UMIdhruhGeTBXbF0F80cJc8XW/e9gxu/PEVY84zA2JRgpDM8LjRfCkzPw0G+sQ9rPv6VFZnUpk1kOcNHZC7y/YUpND16BM65NKFM6F2Ker81CnJmjeuJOD7Dh+YqxwM84I0zzIHU3MZVFedNvKg/PLI+DMMRLf7cywiT1OezOsfGA0eSlHHKsCpGjZNlhZ76E7UoD1rkH/HsGHnrGAx7+PeZ+Hu1VX/BgXyVxfx7yyX3Wmn9PvJ+Xsu06X4EzpYV99FsHeZENpnLQ35vq9egCF09YdlVAVA6FZ+F9aU1PXIpH8iCdJez1EAfPkpjnec0z2LqIHWp68jBtYh3IBW2DVH8edpYX+3PzfK+Mbhfv6yYBHuq7xlpkVg4fKIrMxgGecfx4et1dQflr9ToQfKux7OX61u9n5Ix6yUKcv2/UE3cF+FY2H8Xmz0rdnRrmz1J5eHYV/RZ6x2/pSvSXVd76d1hR2Wh3SN9qQ/jIQpw1gfxt3+JE3tBXnGyECfUXvm0sS7+nAEazzUn6brkgL3rPWWQhVXaYrSlH2TmjbBvf7DbWX9mB/ah5zx+Vl4U4pxTRZ1ufTDYH2zjxNEWSt0CuJh6TN/Rbao04U4B/ivPJIvzjt7GRN6m2mwMecvAbyxaw5YVxzhSD9yrjdw7e0ZeZyo+nuc7rbbdL4ZkKeLbmx+ML8VkYj0wL8uI+/z7dkNUEQ1b1EGcayG+6gPxsYwL6TeW5iFmo7EL9zeiDLGZY8MwosyyovKiYsf4qmOUwp0E38B4uwloH8aakBKM5vyFk94v6h1iHtrH6VHhPk8xygIvGraR72sW6B8bUAvdvNODYh/xewoF3TFOcH4/siftNGFObd7YhP6in/PMCxedwqDyN0by3e4iBl/6ONcIGej31xI17rIEb5UMYbes+0nKsCpGjZNlh92aXk2/PC9cfesf5F3a/ORiLkn2gNkll4xwyxflhibGoaY+mWHjLBe9Ty81viM00+dVxyI+oNeJMBZlQnJ8VkUl/tp8MYMzB3wzEwbFNxlt/jjPn9W9bGGjwwFJ2oPfY9+m8pxoyyUKc35TQe3NcRHpv0/Fi4ynTv7HpojnGQV38Qx/nSoTHR0X1k8rLAC+oXxmIQ/8n/TRlmPPEfMDCnAvWD/GCTw7ecY6D399ryqNv2Rc8MwAPexsK5lyoDO615Zn8eAv55gXqRefr8+Nt0vk2CshB60xTkBfZPionDzozK3iv8njtQhPkWwXlUHgW3ofVdv/Vut8QhDVCekpLMqL2QXHrIc4MC285Zt4aDDz0e1ZMzDMdxFyRc3zMjUYc+k32RbfXd2B/hdlP6nZCbRj7+AYhnvIGXvqNMqYwnJvjt8PF/ck84KGx9hSLzOpSJjPcO0zzIqSrWg22qO3By+8Dda/PT4PycoDDNhY6f0RP3HEBtiHe+j4rrmehnpZrTdLct6Qxks+N6/CIl/5ONsKE9r4U3Stgm1eaXEY5VoXIUbJsqh/Ke2tL2QL10IB17gH/noGHHtwTxe/Hdu8xHRcBD/ZtEvPQ5fDXuddefUNW4wxZ1UMc9IkF/PyCbs808NBvX7bsvM0vscmiwYJHqn8MkwWVFxVzvoK5gtmr6HMFc0Wf88meipwrmMuKuaLP/zuY8Qw3zntQvMkpwUhhOM8pMP4pOm+BdUjzENMtMivHfFYUmeGcG80Z4dzmOTCfJTCWb0KZ0nwW4aDycO/9Thv2xL0A5rMoLs4FTTfCJPd9mevG9JvKGwJ8TYcwc+6qDtKgrkjps7kvkn7PBIwmL+WQY1WIHCXLpvqhvKdZyhaohwascw/49ww89OD8kcAcRAfaq77gQZ9AYh1Baq4FbTD3fJa5bmTOH9VDnAaQn8D6sm+bX6PfjbJl91rbLiaLJguepjLLAtfBo2BuqGAuC+aKblQwh2Gu6EYFcxjmim7Ew4xnonD8SvFmpARjOdcFw8Z5WIc0bptskVldymRm2/9B7UWPsV+B8b/APoImlKl5Xw+evac4jcN74v4exv+UBsfOtnkhqX1OYXMuVB6O9XFsbY71w/Y+Selz2N4nHzCavJRDjlUhcpQsm+qH8p7cD3x7RfgW0IEG1DcPZO8ZeOjBsT7/eNFvQVvZFzzYt0vMpyKf3Hvq+e2/3yK1X1bn28yfb2F+oCXIi+w/ldMEddvq9egCF09YdlVAVA6FZ+F90ICeuBSP5EE6S9jrIQ7uj2820tHvWSCDqgE9eZj2uA7kYjsbkGOWj+mzNhl4y+2zhtlJ9G2o35xhkVldymSGc7kSe/ZwHQT3KW88oKdc/vl0v6XKKC/nrT+Xn4U4bw/ribtZgC3MP7L50lJraWG+NJWH6yPoM9E7np+V6C+rvPXXlc25XdTJ2hA+8IzPpED+w7z1HzyziDIw163TZqewTrBfkfLnwtaxbOceUMdtvr+ULQ3z/dGW2s6uSKy/RT3bKbwemMezPMLzHJF9cNRfAZ+sAdtuX/A0Ax6XfE+dL/l23Ot/pn/YZMgK/cMWkF+rgPyK+Z3oV7uGGe0T+ncUL58SjKaPb5ub0n7PcvDJBNZiC/f9YHk5wEHlZSHOw+CT7WnxydLc1xM/5ejrw86I4tyfrR8VkE+DTT55Qz6ot7Weve/PQpyVJfzB6UZayX4pSj+J/ZJA+29CW9MXPK2Ap4Ufjy/EZ6GfbAvy4u4nZxuystlPitMG8pstID9bH0i/qbwK5grmMMzojxDWOoiXTwnGMvlwefRzKH/tS5wFfo5AP1FYU8T51BzgoPKyEOdc8HPOAT/H9GnCfEsJW17Mt6TyhgAP2NdJ+Tnm/R2zDFmE+TkC8mmyySdvyAfbg+nnoB5QnEv76OcI+xWR/Rz0KwTsSivasL7gmQ142vjx+EJ8FvycOUFe3H7OXENWNrtMceaA/OYKyM/Wt9JvKq+CuYK5grmC+X8BM/rthLUO4uVTgrFMY51efjvlr33j74HfLuD3tGo5mHtBzPED7sdYDn77U+C3mz562BhMwjcpNgaj8oYAD+i7SfntLQaeFkMWYX67gHxabfLJG/LB9mD67agHFOcXffTbhf3kyH47+skCdqUVbVhf8MwFPHP48fhCfBb89m2CvLj99nmGrGx2meJsA/KbJyA/W99Kv6m8CuYK5grmCub/BczotxPWOoiXTwnGMo11evntlL/2jTcY2FOuxPyglkMblJfz1h8/ZCHOJuC31wfYtA9q+uhhYzAJ36TYGIzKGwI8oO8m5be3GXjaDFmE+e0C8mm1ySdvyAfbg+m3ox5QnE2Dui/lt8vKunsPLbaXnLe+3iHuXBHcNpvQYPCBe4bR55a+44Ix3wabzGx7iinOpIgyoz1GuKd6tkVmUmd+BNp0QWbbGDIz901nIc6MEjLbJkRmuC+bZEVxMxAP+yAdTvuW8BsiGYiHe9KE9t022WRknjdGGbVElBGt6aJeEV/o00jxljd4a7DwRnG2KcFbPoQ3rH/iKS/LW4OQj1WQ2baGzAj/PJAZxdm+hMy2DZEZ3tNFstoWZCbAW+NAyIsx34LM5hsyI/ztIDOKs3MJmc0Pkdk8kBnJaj7ITOLcgvYJZ1kwegZGevAsA6XDM6zz+TFG3j+PMttOCM/8CHi2Azzt/Hh8IT4Lvs6CIC/uecDtDVnNN2RVD3EWgPy2F5BfFZRLedNvKs9FzHgukrDWQbymlGCksHbAaN7lou3uahh3C4zJGnDOxhx3U3lZiPPq0J64R8K4e44hXzxjiTKXuoMy7Iwl3pNhu39Y6lxc2HehmgCPeeZASD4NNvmYZ4d1HPJfaj27n4vnOk4uMe629ZNS597i9OVC/VJz1H67HfBInIkU4jOPfg93P2nazyZDVmg/hf2eQltuN/DQbyqvgrmCuYK5fzFjn4M+CMWblRKMFIbnwdv58RTWcczxuvbZbgB/UsDXaK7y1v8OLeGg8vCeiK+CP3kz+JO0vwjPu9r8Jak7zcLOh+Kcn+2OIanzqqXu/BHyr6S+g1zwSc27XWz+JsW5u8T8knmnjzkewXMuwnef+1Lzo2hjis1rU5xvl5BZe4jMbPf2UdwMxEP7ocNpjIPnHzLe+t+O0PGFxrPNNhk1GbhQRo9FlBHZJdQr4oviSvJmnr33LbxRnCdL8DYjhDes//bgneJi/bdDWlwTMuvfzEPHl5rPEJqPbUafiGRP+Km8LMR5toTsTf+qxZAd3pGAc6kCvDXinCdjvs04f0gyI/wLQGYU54USMts+RGbzQWbmXFsGykK/L+OtP29J+mrmoeMLyahJ57uQP9+C7HcI8iLZE34qLwtxXi0h+x3gd87rkT3lOQTkRXGFeJul810kJLMdDZkR/kUgM4rzRgmZ7Rgis4UgM5IVxc1AvB0grQ43z+6SvlI8PActdC666J4iPNP6v1q2wDnlhqh3hOCZ/B0FZFHn9T4PUgrPjsJ4itUNli1gMwp72nYK8jL9TbQZFKd6UPffMJuxk8EH7WdEf5N42gl424mft15yrTLkWs6yvSJlS9Xp4iAv08/GOqU4Q0rU6WKDD6pT9LOJp8XA22J+3orWaTnL9oqULVWnOwd5mf471inFGV2iTnc2+KA6Rf+deNoZeNuZn7eidVrOsr0iZUvV6ZIgL3N8gXVKccaWqNMlBh9Upzi+IJ6WAG9L+HkrWqdUXgb4JFztQfgSQw7kK5r428vEgxfCg6Ru7BLkZY5/UDcozowSurGLwQfpBo5/iKddgLdd+HkrqhtUXgbeCdcHAaal8Ls9Iaau4NH57hoj364Sj853WXK8vhnggRwy8E5l9eX/tri7QppFRrwPjN/6yDHVEeok/X+bIjop1G6KttlFULaAXhfaLPFujr93schnQYk2u8zgg9osjr/NOkJ9y/Hx1qzX/losZfWXfShH2V6RsnflL7swTkY7Tfx7Bh56dgU8y4Xw7BoBz3LAs5Qfjy/EZ2GNcLcgL+69QLsbstrVkFU9xNkN5Le7gPyqoFzKm35TeS5i1nio3RDWOoi3S0owUthSwCOgz0VtGNaheZcoyqw5ZTJrA4y0HwP3aRw+qAevwDpHYe16IZSXAxy4FkRxjoJ9IWsDbEMgbrOFH5S51Ple83w7/cZxP40X8WwLvePcrMDdOAU5zwnBiD6BeaelyQfeaXlSET8L/RqUAYWR7cB6Qnsidad+WD21AkbCOw/wSPlEpBPkj823yELgfFheSMa97oivCZEx7vP6VAlf3dxvRfqDbYhkZfumW87j9ZOk9jwtNWRmzgVnIc6FJWS2NERmqOMkK+wzpWxjmI5Tedhnkh2vg/8Lr6P5NttIv1sAo7mvA206fkOs2QiTlG3Y/j+0uQsscpRaC6WyqK77o2yvSNkSe4uirsPiXS0C47k2bDt9wYM2QOrbEQJ89tqDyj2+3NWQ1RxDVvUQB88yCcxf+Dabbs4rVjBXMFcwVzBXMKcTM/q4hLUO4jWnBCOF4XyExJxzMX8N65B86PkWmdWlTGY4dqH5KjxD/zzMpc3nx9uGMjXXyai8LMTxYS7t15a5NBzTzDPC0jyXht9FFphLa5OYS3utxFzaYIsMzPEx3kVejjFz2F3k+A0hc+5HcvwXNs+A3xgl/UUdt43X0/BNz/mAR8BeFG1rlbJl1jui3peEd+dItJs6r3c/XApPOeZxwupG+NtYeSFbWegv8O6enLe+rcxCnEEbdP8Nm98172yhfgDnd0lW6PtKnYnGe55z8LucZXtFynZoTqsNxzakK4SfystCnJEldCVsnIR9NMkK971I7MPRfdsCS1lS44swvVxaxrK9ImUL7CdrwPGRB/x7Bh56cM/Zbvx4Wuq83vvtSuHBfS8SeziE+Mzjfg7uueg9DFktM2RVD3F2B/ntISC/KiiX8qbfVF4FcwVzBXMFc1TMOJdGWOsg3tKUYKQw3Jcr0KcU9SOwDmk8Occis/kpkxnOI9LcJH6/e9cNevAKzC+2oEzNOVLbvaZv1ffE3T3AhvNa84GfNiNMch4pbB+qbR8bfhuQ3nFeQWB81GKbH6Sy8RvaNA6oDeEDxzoHFRnr4NgCZUDvuGawqxEm5Iv7yB/lTb+XAUbiuRxjIvyeSs6zr5uR/mJbpf+jbqdhzQX30kitR4S1tUrZIntTG6LuX8J9uhLtBte/+oJHeH4hX+/Z5xOk2mOYHqC9kprLiHJOSnguo6Eyl5HsqYyjyudvm34Gjgl2TQnGco6jwmwY1qG5joIym5MymeG5LRq/4BmCK2AcJXWeyDyzsNDAhmcW7oFx1DUwjjLHXriHAWXen3sYbGMrekffQ6IPrPLW/8Y6lU3l6TjUhmq98PVFivOVEuOoeRYZ0LvtHCjaE6n2G3amcTfASDyjPZH2iWgcZfOJpM9UM+Zb0DPqu2pCZJyFOPeWWHc0zzqT/lCeQ0BWFDfjrd9H5YJw81w03Vtj5qHjS+mhkO0vyH7PIC+SvWn7sxDnoRKy3xN+57we2WNbIXlR3AzEQ1nqcNOWkOwpHs5xlWPOy2xzuLesv+bbhPqoBuwPPeDfM/DQg/t2JXQ16h2PewCePfnxSLXJgp3dK8iLewy0tyGrFkNW9RBnL5Df3gLys41v6DeV5yJmjce0W3UQrzUlGClsT8AjNb4Is2FYh+RzL7TIbE7KZIZjIBpnkH+h+9E/whhI4h4fHLNRv23iyEKcj8EY6A0YAy035Iv8oMwF7swuOt+O92HRWGMphNE7joGkxpoLQzCiT0DtvDaEjyzE+Vcfx0AoA3O9EvtCtCdS7dccB5o2GOsE/QApnwjHnzn4LewT5cvph5syRj88GxwY6KsfTvqD42qSFfrhZh+VC8L3NLCQH27moeNL6SH6RYz5NqCPQbIn/FReFuLUl5C96a8sNGQ3BORFcTMQD2Wpw01bQrKneLjOI7l+G9bmyrGn1bw30Va2QB8VeU/rQsAjoas459oXPNL+sBCfBTu7T5AX9xhoX0NWCw1Z1UOcfUB++wrIrwrKpbzpN5XnImbcJ4H+PMVbmhKMFLY34BHQ56I2DOuQfO7lFpnNSZnMbOt75F/ofrS5rgev1BhoDygv562/rpeFOG0wBpodYBvirT/GxPUFlLnUPq2w9QXcp2XyhWM3HANJ9IE23aWyqTwc49eG8JGFOAuL+FDIG+6dM88iSbbVsPHOXoDR3FMo6f9Q/ZPvZduXLDXeKZfPbcoYfe7lEX1u0h8c75CspG09+i6M+TagH0AyI/z7gMw+9ANKyGzfEJmhjpOs9gWZCcyzFNXxtjKW7RUpW6APa7HVKdlL7MMozsqIdUp9m23PbzH/0vRNsJ+qNeJQWlznP6wITpzjQr2S8mnC9Ap9GurnSV518H/hPae+Tf70ex5gpDBcSzXvhcQ58/llkG3YnPm+gNFcTy7HPiazrnGdgeQyJ6Uyw3UGrGvChucnBPYa9LrLJxvkPd/AIyMfvyPq/mu0H1JzjgJ6kEdbMpAt31lWX32OIat6iCO8h6yobbN934RPFs2zsM8qJovlFjxSd/iHyWK5pWxGWRTK3qcPstjHgkfAly0qi30sZTPKokmXvV8fZLGfBc9+ZZYFlRcV87IUYB5ovPOU3VKwcfv3QRb7W/DsX2ZZ7G8pm08WDYX57AP6IIsDLHgOKLMsqLyomPdJAeaBxjtP2c0FX+vAPsjiQAueA8ssCyovKuZ9HMS8fwowDzTeecpu7tRlH9QHWRxkwXNQmWVxkKVsRll06bIP7oMsDrbgObjMsjjYUjZjv1rwiw7pgywOseA5pMyyoPKiYt7fQcz7OYh5mYOYlzuIeR8HMbvYBtOgGwONd56ymzt02Sv6IIsVFjwryiwLKu9/AfP+DmLex0HMyx3EfLCDmNMgZ/wGwcaDJfH4q+oMPCQzz8DoGRjr4B3XN1YG7+0e3zoE1s9KKKuDXR7d9WPqC/3uEC3b79D5dgrwpPPt4s+3MK93aJAX7QvossjqsOC9irmeDoV8q6AcCs/C+0aDe+JSPJIH2QPCrtcxVwXviN1Mt8JIVw9xVkG6LiMd/aa61rKrg3YuoVt90Wu9D4La8uYgi/nBO37vZKURJmkvVxq46fcKwEj2Eu3DSiE8Yd9wpPLwOxrzUyqzegjDtfo6ITyjDDyjLLKQKnuEUfaIMpY91Ch7aBnLHmSUPaiMZY8xyh5TxrK3MMreooxlTzLKnlTGsicYZU8oY9lbG2VvXcaypxllTytj2ZONsicbZQ+Bd/zuFvu3c/yVhT6eyqA9Ueb3nITGER1Rv9uzAvBI9NNCfav1bNZ8gyfcB4l7l6T26q0w8JjjsqiYlzmIebmDmMtxBq6iG73XplzBvL+DmF3U5wMcxOyinF3U5wMdxHyQg5gPdhCzi/rsYj9Y8UXLg7nSp5QHs4u6cUgFc1kwV3z+8mB2sQ266COlQc56HpTmRJ8aLImney8F4iGZeQZGz8CIezBWgMxoXbbd491LQWXhGv0qdnkU3+uySrTs7r0UAnseCvPKh/LnW5hXPizIi/ZSHGqR1ergvYq5nnCfQxWUQ+FZeP8+7KWgeCQPsgeEXa9/0D4HxG6m29dIVw9xOiHdoUY6+k11rWX3HWjnErrVF73WeymoLdNeisr6On/ZlfX17rwr6+vyZVfW17vzTuv6eg38r8MIk/RBOwyM9HtfwEg+qOwe0m48VFZVkLdZdr0hqzTKrB7CcN/EYCE8Yf1nOcoO6z/LUXZY/1mOssP6z3KUHdZ/lqPssP6zHGWH9Z/lKDus/yxH2WH9ZznKDus/y1F2WP9ZsakVm8pddsWmVmxqucpOs01Ff78a8LCPkfyVhbtBqAza80tl4/hMYL67sOeXxgr0VBm/c/C+L+CRGPsIjVcKc7MrDJ5qDJ7wjCLu+V0hwGeVFz7/uALqIQrmZQ5iTuuZ6GKY03r2/KOmG/s5iDmtdyl81PT5AAcxuyhnF/X5QAcxH+Qg5rTeDfJR02cX+8GKL1oezJU+pTyYXdSNQyqYy4K54vOXB7OLbdBFHykt96fRnOgtQyTx8N+fRvsH2z3ePb9UFu4l7WSXR/E92Z2iZXfv+RXYm1uYVz6MP9/CvDLtcaU9v4dZZHV48F7FXE+4H7cKyqHwLLx/eUhPXIpH8iB7QNh1VNqPi9jNdCuMdPUQpwvSHWako99499zV0M4ldKsvem27P023c2pzWQijtAMhDO0phVHeG0IYyWYjCCNZjIYwktMmEEb1uSmEkcwzEHZE8F4LYWuC9wEQdmTwvhmErQ3eh0PYUcH7BhB2dPC+MYQdE7zj/uVjg/eREHZc8I57jdcF78Mg7PjgHfcFnxC8D4GwjwXvuIf3xOAd6/Kk4B33254cvG8JYacE77g39tTgfTyEnRa84z7WjwfvW0HYJ4L3iRB2evA+AcLOCN5zEPbJ4H0shJ0ZvE+FsLOCd9xbenbwPg7CPhW84z7QTwfvUyDsnOB9MoSdG7zPhrDzgve5EHZ+8N4IYRcE79tA2IXBex7CPhO8bwthFwXvsyDs4uB9JoR9NnhvgLD/C97bIexzwfsMCLskeN8Owi4N3reHsMuC9x0g7PPB+44QdnnwvhOEfSF4XwxhVwTvO0PYlcH7Egi7KnhfBGFXB++7QNg1wXsThH0xeJ8OYdcG780Qdl3w7kPY9cH7rhD2peB9dwi7IXhvhbAbg/c9Ieym4H0phH05eN8bwm4O3tsgjGzcKggjXxF9M7LVeEaL+rlOCCP72AVhZB8PhTCy84dBGNma1RBG9vFwCKN1/CMgjNb410AY2bMjIYz6krUQRrbwKAgjm3k0hJH9PgbCqB86FsLIBh8HYWSr10EY9VfHQxjZ+RMgjPqwj0EY9REnQhj1aydBGNnlkyGM+rpTIIz6q1MhjOz8aRBG9vvjEEZ2/hMQlgveT4cwsrdnQBjZ0U9CGNn5MyGM+oizIIzs/NkQRv3BpyCM+pJPQxjZ4HMgjGz1uRBGtv88CJsavJ8PYWT7L4Awsg0XQhjZx89AGNnbiyCM7PfFEEY25LMQRnb5/yCM+ojPQRjZrksgjGz/pRBGtusyCKPvcX8ewsgmXQ5hZFe+AGHUr10BYXS/8JUQRn3dVRBG/drVEEZ7Sa6BMOrXvghh7cH7tRA2P3i/DsKob7oewuhuwC9BGPVXN0DYwuD9RgijPuwmCKP+5csQRv0a2WRt+7S9ou+hoi1fZoQNhLJzHu8YyPwOKf2m8jRG89ubQ+Adv8/bZoRp3ALfuy/gbjNw02/8ljzx0AZh9E56VQVpzLzwO8X0je3akPKyEGfHoNOxfVd7oCfyPfvCN8qp76exNGHbCzBSnCVFMGJehHOZwS/Kcm/gTaC+G2y87WbgQd52KyH/vQUwSuo61p/Oe7mFd4qzd32PnPYN3tF27QFyPMzyf3qqjN85eMf63leAZ52vwPdQC/NN+wP/OSgHecJvYHLxhGXTfJP5vc8svB9a3xPX/A4n1SFh122R1iSKfb9zoZHO9v3OKm/9b9jSb6prLbsDQc9Ij7TspL5PvU8IL7sBLxSH7JLGI/UNe/Ob1eY37LGPqjXiUNosxDm6iM3S/yJfgPjG/hb9BAHbVrS/3RswUtgywGjyrPWlORjQDYH/45h3mRFW8X/6Xh+c/s9SiEN6Xcz/oTifKtH/CrTJgv9DcySm/7MHYKQ455Xwf/aE3zmvuP+zJ/AmYP8abLxR3Syz8HZxCfnvKYBR0vZj/em8l1t4pziXQr/0efBvqN52AzneZPk/PcX8H6xvCXur892HP99ed7eTHu1j4Qm/Z8/FE5ZN/o/pV2Th/Ubwf0x/hOqQsOu2SP4vYjfTtRjp6iHOXpDO9DXoN45BrgQ9uwn8H6l+aq8QXpYCLxQH/Z/dhPCY/g/hwDGz6f9QHJv/c3sJ/4d8AeIb+1v0EwRsW9H+dk/ASGHoo5k8a335YzDJPQT+j2sDrUaYpB9BZVHeppyxn2uFMHpH/8f0iQYC3zmvPH7bcsBIPNj8NvR/lofktRDikF7XhpSXhTiPleh/Bdpkwf+htSSy7YRtN8BIcb5fwv/ZHX7nvJ76RvmSDHYH3lr5eWuw8UZ102rh7Ycl5L+7AEYh3n3UPfJ/2iy8U5yfQr/0HPg3VG9LQY6/s/yfnmL+D9a3hL0VmiPN2+YR97LwhHMhXDxh2eT/mH4FzmH+Fvwf0x+hOiTsuI6A2M10y410OGeC8xamr0G/cQzyS9Cz34H/I9VP7RHCy0LgheLg+Yk2ITxm/2OOtXUcqqdaIw6OWyjOGyX8H/IFiG/0LdBPELBtPvJCedPv3QEjhaGPZvKs9eUK8H+oH8b1L9u8lpRtDfPr0Nchf8Y2jzIfcLcYYRr3rkK4zTkb+r0rYLT5cvSO3/DcNSQv9H+o/mpDystCnEywwSKs/xWYJ2hDP45sO2HD9kZxaotgxLwIZ5vBL8oS93wL2JsWG2+mvUHeBpeQv4BP3lIOW0v+zxwL7xRn+NAeOY0I3nXbpHqbB3IcZ/k/PcX8H6xvCXsrNEeat80j7mHhCedCuHjCssn/Mf0KnMMcO7QnrumPUB0SdlxHQOxmul2NdDhngvMWpq9Bv3EMMhr0jPSoHGMAkxf0f8w1cY1njhAes/8hHHNAjlRPpv+DawYUZ+siNgt9C5wnMX0HyfmGeV5vfun3csBIYbiWZfKs9WVX8H+oH2628NUMfEnVYxhfVB5+/3wehM0DvPS3zQhLs9+Gd8S2huSF/g/VX60XPganOO0l+l/2MVLw7VvaL0i23fT/shBn+xL+jw+/c976uo2y9IE3gfpus/Fmm/+hOItLyN8XwCip61h/Ou/5Ft4/9MehX1oO/g21hQUgx0Ms/6enmP+D9S0xvhEaI+RtfvQyC0/oC3DxhGWT/2PbD0LvB4P/Y/b9VIc4r21bfzHTzTHSoc+Aa/1hc+tU11p2e4KeHQL+zzxI1x6855M91vkH4gX9H4qD61/s3xkP8Mw38BAOHFeb618Uh9Li+tdhJfwf8gVs+03QTxCwbUX7Wx8wmntL6iw8a315Pjj4gXtU8PzNfCNM0v8x65F+o/+zwOABfSL022z1kVb/h/qLYv4PrpHReYJi/g/F+XiJ/reJXyatxfyfJsBIcT4Z0f8x+9ww/2c+P28NNt6obuZbeDun/P5PgxDvPuoe+T8LLLxTnAuhX7oI/Buqt4Ugx2ss/6en4v/0r/9zdRH/x1xT6Kv/02qkS+L/fA707Brwf6T6qaUhvMwDXmz+j9R+pAUGHsKBY2bT/6E4lBb9n5tK+D/kC+DcCqVFPyEN/g/6aCbPWl8OB/+H7Baey55hhA0EXnLMfFFZlDf9pjI0xpnBO/3Plm6eIQ+0HWb9U9osxLm3RJ8l0LcUfAY6D1hj8I99C8X5VgmfYTv4nfN6/EDKcwhg306Wt2Zso8V8BorzUAn5C4yjmiV9hu2BR533TAvvFOe7YMu/Bz4B1VsTyPFnlv/TU8xnWACy3EGAZ53vIv58Cz7DjsB/DspBnnYCGXDxhGWTz0DlUHgW3p8Dn4HikTyoDgk7jj0Ru5luhpGuHuJgX7fISEe/qa617J4CPfsZ+AzbQbr24D2f7CnIbmEIL+gzUBwqV+OZKYSn3cBDOGaCHM1x5jwDH/r6vy7hM1D/iXeUmP2t5BxRk9ebX/q9ADBSGN6ZYvKs9eWG4AINXHvB+0kajDBJX4jKorzpN5WHcw8Nsnha0Rch+zTTwJOFOH8p0Yebfg314TOBN+JpBvDWzs9bA85Pmby1A28U5x/l96EaJH3T7YBHnfccC+8U5x2wre9a+mjc97HBsPX/T0+xPnw+yHJ7AZ6FxmuFPhz7oZy3/rws+g/cffgOkC/2lRSehfdBw3rimn2qOcbEuVnEbqabYaSr99b3YWz9Jf2mutay+y/oGemRpK1dEMLLTOCF4qCtlZqHMG0/4Si272OmgQ/3fWwYyDCsD6f+DPtws/+THEeE7Y+YDxjNsW+dhWetL6uhD6e5gjykmWOE6ehzhfiaY/BFv6k8jZHu8sG6NdMRn60Qh/Iw65/SZiHOuCL1r/nfhp1/vwXrtcbgfxvASHEmFsFo05EGg98hwO88Ud66/aFtDd5mWnijONNKyH9bAYxCvPcaY5DPMNvCO8Xxh/XIqRF8AnPdTP9/O8v/6SnmM2wLspQY5wmNX/I4h0J6tMDCE46BuXjCsslnMPtinL+ZDz6D2YdTHRJ2XLtF7GY6c78MjpXnQzqzf6bfOK/YAnq2HfgMUnsl5ofwgj4DxSG7pPHMFsIz18BDOGaDHM21gpkGPlwrWFzCZ6D+07ZXAvtWAdtWdK1gW8Bo2yth8lzwMcFnaDF4CONLqh7D+KLy8MwJnoMy0xGfzRCH8jDrH/f4U5z9SvRZ/L5vt8+A9ZLz1l/vQb/moBI+g9kmGgx+0f+aK8pbt8+wjcGbzWejOKvK7rN1+wzSe6DJZ2i18E5xVoMtPwJ8AnNfjf7/yZb/01PMZ9gGZNkuwLPQeCmPczakR/MtPOGYm4snLJt8BrMvxvmik8BnMPtw8xyfbotkuxG7mc48E4hj820h3XwjHf1uD/5q2R0FenYy+AxS48FtQ3hBn4HikF2SPO9r7kkjHLhvLazPwD1pFOeTffQZ8AwDpcW+VWrcMtvrza85bqn31u8P6iw8F9Ywgwu4td7OMnjAc6rIl/Tedcq7xcCrMZIfgHVrpiM+myAO5WHWP+6Xpzj/V6LP4j+72O0zUJ2Zd5LZ/JrLSvgMpo40GPyi/zVblLd8E84FmT4D8kZxriq7z5ZvEuK915iGfIZmC+8U5zqw5V8Cn4DqbRbI8U7L/+kp5jPgnTsS40qh8VIefQDSo20tPOGYm4snzIt8BrMvxvmir4PPYPbhVIeEXbdFst2I3UzXYqTDsfk2kM7sn+k3zmN+GfTsTvAZpMaD24Twgj4DxcE7umYJ4Wk28BCOWSDHsD6D0mKf8a0++gx43wWlxb5VatwSdnfXHMBo9gd1Fp61vpwFPsMMgwfcN4F8SdVj2L4JKk9jpG8eNIni6e7DUU45b329ykKcJ0v04aaOUh+O+wuIJzxHInWvemsIbzYf6scl+nCJu78kxxjYV+u8Gy28U5znwLb+HPpoc4+n/v/vLf+np1gfjjZSwmYIjR/ztvmjuRae8DwRF09YNvXhVA6u+dD7q9CHm+t2VIe2NVDEbqZrNtLhmjDOcZtzfvQb/egXQM9+D324lK2dHcIL9uEUB21toxAe0/YTjkaQI9WT2YfjOaEP93v1sQ/Hc3xm/yc5Pg7bf98KGM3zAHUWngvnvaEPn2nwgN8TQr4ahPgyz8/RbyoP/QzcN4h7KOhvoxEmdIawgLvRwG36Gbj/rxHC6B3vlWgKyWs6xKE6rQ0pLwtxssO7/4b1v+w2IrhXwvR/TH8M/Z+BRTDa/B/f4BdlKXuu2e7bUd34Ft7qS8i/WQCjDO/duo71p/OeYeGd4owY3iOnjYJ3HBfMBDmOt/yfnmL+j/S5aaH5oLxtns92Fhz3UXHxhGWT/0PlUDjOMW41vCdu2F4uXIMkX7jYHrAmI109xME53VJn1rXsNgE9Iz2S7KdaQniZDrxQHLJLGs8MITxm/0M48Owd1VOtEYfSZiHOtCI2C/0fPEtg+g4ytq2b35leb37NuYl6b/29lHUWnrW+bAz+z+QgHPeN5o0wSdtKZVHe9Bt9HVPOQ7ze/hr9bTDCJP3vsLMd6OuYvlx/+pFCsmhAudNTrO9C2yAwVmtEP7gvePB8k4SvLMRnHm3NBx5vH23a+kZDVmjrhefeevlflDf9LrYOWsHMj1njMe0cfi+3ISUYKUx2zru43cU6pP4ob5FZXcpkhvebCPT5efRJ8K6eDvBh8/zlNlZ5698NNN2oF7wbqG7DnriHBtjC5l2mG2GSfgeV5Xl2nxZ9o+kQRu+DAaNAf9dYzDfHPSnmfI7NN6c4x5bwzQdbZEDv6BPa7JSUvx7W5poBI/GMPoiUf0g6UeX19rNRFtJ+CmO+jdh/1oTIGO/7/ESJ+bZSfTHOZ+K90RL6IzSv04hzCyQzwo97ASnOp0rIrC1EZqjj5j6ujLf+fbu5INyc5/ggCDfz0PEl11EF9oE04nyQee8ezj9RnItLyN6cW2o0ZIdnJ3F/0HR+3oraF5wfov4R+9A09Z313vo+AfKWCdJNCX43yco1jz5L1rP3peizXGeZs6z2etcH9sGNRt6UZgqENxp5l3FfYgdirDH4mGPBeGMJjAJ61SG5bwntgs7bdtaE4twC88G3wboC6ctkkOO3Lf+np8r4nYN3nLuR2N8ttCez0I7Ms77zLDy1gwy4eMKyq4y8KRzPGX9r+PoYSB5Uh/h9AdobYcNO6aYb6eohzlxIF3aGH/es3AF69m0Ys0nND88N4SUPvFCcBuDFnJ819y/gnHqtZ/eJcX3gkRK2ZTI//1b7R9gmA0aK83g/2T8B3q32z7fwTnGeAr18Guyb6Yfo/79o+T89FfvXv/bvhSL2z7RjfbV/eSNdEvv3DOjZi2D/pO6CmxvCSwPwQnGKzS1TfLR/1J5qjTi276D8toRtEfB/rfaPsE0HjBTnD/1k/6TGVGH+H/JOcd4AvfwL2Deq0zzI8X3L/+mp2L/+tX/vFbF/ph3rq/1rMNIlsX9vgp693w/+n2mj0P7hvhrau4Dzv+b9zEJrDUX3a6Dfat6/iDaZ0tFYHO028VRrxMG5AoozKFjHsNnEOktaXa+v1Ha/2/Yw4Po6zh335z5Tkqlt/h/XaWxrbv05/287r0PvuD+2OSQv3B9rfnet2Fz4mCI6IbIOGeyPNc/QmOeZ8QzNFkUwYl6E0zb3TDLAsxUCPkCjjTfbehbFGV9C/hJz/5LzquZ31/IW3inOFFhXnRq84/kftEOzLf+np5ifgvUtcaZTaM4vj/2ded8e8oTneLh4wrLJT6Fy8Az3h33thj1xzfOtVId4rx/1zYjdTGd+uwvPxeI9SWF3MuLe4pmgZ6RHkv1UWwgvuP5BcXC9V8r/MPsf27qGOf4z16Nx/LddEZuF+4LwfJBtD6LU+aCwfTh4Psg8Q1Fn4Rn3omi9HReET4Y0M4wwyfF/2LknPAdr7n3GM0Po/5h7ZtO2r7c//XEhWTREnWPE/VcC/XUTtsu+4MHxscTeFCE+82jruffHmrbVN2RV7j2IYWMkvM+hgrmC2YYZz7bgvgyKV457LPqC0TbnIDWeCesrsA6pD51hkVldymQ2E/AI+Cl5nEfC842ngd8tcA6sqcooLwc48NtpFGeXET1xzwiwoR+CvtIUI0zSV6KyPM8+n4f+3BQIo3fc0yvQRzcVm5fENXfSt2LzkhTnghLjicEWGZjn8sPsVH/ORRLP6DdJ+bR41jHn2e9jkPatGPNtwv6zJkTGuC/8CyXmCEv1xTh3XI5zYAJzzU04/2beO2Cb+722hMxaQmSGOm6eH8lAWdjf4d5dPKuWseSh4wvJqEFo3qEJ5336sp/6lhKyN+eQfEN2tv3UkvPFAnOn1vswi+2D/noJmc0JkVmpfdBT+HkrapOpPPQd0e9Ik79R763vRyFvtA96WvC7QVauefTzsp7d/+i1Vw/mps190Oa6MPo25j7oaRDuG3mXbx+032sfuPn93TkWjI+XwChwR0xeaE3Eug9muoX3D/cBwrz/07B+RPoyDuT4ouX/9FQZv3PwjnN0H5V9MMhTO8iAiycsu8rrwz7ADdfHQPKgOoy6D2aKkS7RPkDQsxdhnFuufYCmfcZ9MLazK5TO/FazjkPtqdazjyOyEOe3JWzLOHb+7faPsI0DjBTnD/1k//h5L74PEHn/cB8g6OVfwL6Zfkhh/5bl//RU7F8/7wMsYv9MO9ZX+2f7rjXFibwPEPTsfbB/Unth54bwYjsHUmw+3nYOLuwcCK6Df+h/BnOIYbaF3/+12z/Chmf1PtThEhil7J/UmCrM/0PeP/y2FszxDg3ebXda6f9vYfk/PRX717/2b/MR62MgeZh2rD/OgYwAPSM96o9zILje05dzIObao83/M+fm0P+bUMK28K/z2O0fYcN1HoozpZ/sn9Rdh2H+H/JOcWaAXubBvpnfN9L/39byf3oq9q9/7d+8IvYv7jmQWUa6JPavCfRsW7B/5fL/bHdY2c6BTA7ece8/pSnH/r2w73rhvfHmmTa0yZSO5iKL3aE0zcgH18p2LmIT6yxpdb2eA+dAKvekx8NdjnvSp0CcKPekH1Cin0zDPemHFMGIeRFO23plee5J717bMnmz7YGgOF0l5C+xXiy5rhTlnvQjoP84EvwQ2z3pp1r+T08xP6VyT3p0nrBs8lOK3ZN+Cvgpabwn/RjQs1PBTyn3Pem4/mu7J71c5wfMfXrYR5n7tnB8QXHOKmKzwu5Jt+3Rkjp3Gdbf4j3ptrshTZ5x/6LW26lB+HRLmunAl9QaQNiaPZWnMW4dvNv2CKL/Y54N6e/zK8QDnsuWGkuPM/DYyhaQRUPUNRbcsyvhq+B5+L7gwfGxxH5GIT7zaOu5z4GYtsY8z1/ufethYyQqr4K5gjkMM96ZgfvSKN6MlGC0zTlIjWfC+gqsQ+pDp1hkVo47TaPIbBzgEfBT8jiPhPusHhwhWm4T+kc0XjJxZCHO/43siftogG0IpEFfaZwRJukrhekb+ko2v4/e8RyIQB/d67yNibHYuXKTD1yr+WGJ8cRgiwzM9Y8wO9Wfc5GmrZD0aXH+L+etP5Yph2/FmG8T9p81ITLGMekLJeYIS/XFOHdcjvPO5To7Q/htc7+vlJDZrBCZoY6bZw4zUBb2d3jeA89kZyx56PhCMmpIyxmcN0rI3pxDMr9hazuDI8RbY1rOzrxVQmZtITIr9S0C8zvuuSDc7LPMbxGgH1OOeR/TtlN56IOi/5Imv6UewpAfes8E6SYTJsAs4adWeb3PdiBm3PNMcQaM7MFMukPnSaYY6dBHorwpzWQIn2nkHbYGxL++0NTrPI25TtVmwVhXAiO/XjXlhdZWCvqK9kXnvbWFd4ozDMYKGwbv2L6mghzHWv5PT5XxOwfvONcncYZG5zuXP9+CHuGekByUgzzNAxlw8YRlV3m9961QeBbec9CGzf0tVIeEXfcVtL6F2M1044x09RAH19DMvSv0G89BjgI9Iz3SspsG6dqD93yyp9can8kLrlN9uKcMeAlbT8LzdNSeiq0nUZzJJWzLVHb+7faPsE0FjB9+G7if7B8/73b7N83CO8XxQS8bwb7ZztNtZ/k/PRX717/2b34R+2fasb7avylGuiT2rwX0bDuwf1tDuvbgPZ/ssdo/23k6ioPz+tOMdLbzxCRP8zwd+pwUZ6cStoV/3thu/6YZvPa6N6ef7J/UnHmY/2e7q3c30Ms9wL7ZztN1WP5PT8X+9a/9W1nE/pl2rK/2b4aRLon92wf0rAPsn9S8wuwQXqYBLxSn2Hk68w4Im/83zcgH/b/DS9gW/jNldvtnO09Hcdb2k/2TOk9n2r9xFt4pznGgl8eDfaM6xf1SZ1n+T0/F/vWv/TuziP0z7Vhf7d80I10S+3cS6NlZ/eD/mTYK7R+eMaG9fra5VtwH2F/713CulWSHNpnS0Vwk2m3iqdaIQ2lxTvTiIjaxzpK2cE4SzpOY/nbavs+Ca7i2tWfcI2Db79Gfa8+2u7bpHc+TNITkNQ3imHuDi63DXlfusUxwnoTWxcx1T/TnKc6NRTBiXoTTtu5pnjERWltpsvFGdTPTwtutJeQvse4sua6E9afztu0joTh3QP9xJ/ghVG84TnvY8n96ivkpWN9S331v4c83jz6feX4aecJvbHDxhGWTn2Ke00B/8yHLWhvJg+qQsOM6OGI309m+GWZ+i6PKCz+riWe67gU9exj8lHJ9x4N4wXEaxcG9RlLjRrP/MffZ6ThUT+b4D8+BUZwnitgs3JNa7KyGkG0reu6iCTCaa8B1Fp5xH6TW24lBOO4bHWuEDfR67A83X1QW5T0W3gnjhOB9LISNBbz0d2sjTHLtwvRj6fdUwJgL3rcGPFLjiJyBx1a2gCwaUO70FOu7pgIegTP6jXVQRl/w4FhJYo1TiM9e93xwnycxxyTmmTP8ZqTweaWCbpt3ENBvPDtYwSyPWeMx7Rx+u2rrlGA050aE2mBRu4t1SP3RWIvMyrEvLorMcoAnx48nj3MylL/2SbyNRMttRF+Dxh4mjizEuWujnrjZ4H2I1/v7a/Q3Z4RJ+h1UFuVNv9HvsPlQ9I5nMwT6u4Kcp4ZgxPkc864vkw+862toIP9SZzNQBvSOPqHNTknNj4a1uRmAMRe8ow8i5R+STpAOjbXIQtpPYcy3EfvPmhAZ49rZZkV0CPMinGZfjOfaKS7u26b/feD1Hodz+GZdwYPnZ6Lk21XiYTqb7JsBHsghA+8411Xq/7a4PqQxx+UfGL8HePZ76j6cjyuiF1J9stC8fCPOi1CbMOeN8czbjBJtwpxjoTaB6xDm3TpCvDUIzW0VZGae8SL8uAf/w/NBJWTWGCIz27w9xc1APDwfR+cRPPg/nf/AePS3HPM0Zv9B5aGfiz5SDt49r399o3oIQ37oneRNc4g4fsjxYy6MtfEsBmLGPXoUZ6eNejCT7tD5j7FGOvTDKG9KMw7Cpxp5l2//X74ZMdYYfDRaMO5SAqOAXjVL7v9D+6LznmDhneLsBuORPYJ3bF8TQY4dlv/TU2X8xv/j3JzE9yKF1qsK7cg899hs4QnXf7h4wrKrAqJy8N5iel8JbZjikTyoDvGsIM3vI3YzXc5IVw9x8J5O845C81tphf1/oGcdMCbHsXJ78J5P9hRk1xTCy1jgheIU20dC8XF+jdpTrWcf82QhzuElbMtEfv6t9o+wTQSMFGdtP9k/Ad6t9m+yhXeKcxzo5fFg30w/pLBvy/J/eir2r3/t35lF7F8ueI9q/8Ya6ZLYv5NAz84C+zcB0rUH7/lkj9X+mTYK7R+ef5tspDPnJtAfrjXimD6nfs4vYVsE5nCs9m+ywSvav4v6yf5JzRGG+X/IO8W5BPTyMrBvVKdjQY43Wv5PT8X+9a/9u6GI/TPtWF/t39ZGuiT27wrQsxtl12Ss9s+0UWj/bN8Fxfl9aj+4b2WsEO4JBm5zj0q917vP0A/aZAo39xKib2veW0Vp8dzK14vYxDpLWl2v99R0v+NaEcrRXDuR2huB9p/ypt9UHq6T2NZ3cB3Otqban+s75rcMhsA77n+eEZLXZIhjfhus2FrHI+We0w72P+M3XXLe+vc4Yn/2eIl51Dz8znk99Y3yJRngPS0CPkCjjTeqm6kW3n5QQv4S89iS86rmPTI5C+8U5xnoP34KfgjVG/opr1j+T08xP0X6Ox9Cc3557O9Ij2x3kuNeYC6esGzyU8y70HAP/2/ATzH3/lId4ndCqG8udkbTvNvOtme4ygu/O53qWsvu56Bnr4CfItVP+SG8oJ9CcXA9PyeEx+x/zL0sOg7Vk3mOCr/LQ3H+VGKPBfkCeE7K9B2EbFvRfcL43U0KwzNxJs+41wjPVm0FacYbYZLjfyqL8qbfVB76aOMhbDzgpb8TjTCNe5IQ7okGbvo9CTASDxMhjN7R/5kUklcO4lA91oaUh+tk3qjuP2H9L/tcduD/mHf/Ejacb/nwbHMRjJgX4Rxv8Gvbuz8Q4uW4eAu+e2jylgt+j7fwtkEJ+Ut8m1aG925dN+fLxlp4pzhDR/XIaXjwrtsj1ds4lKPl//QU83+wviV8PqF+NI/9lnmOEHnCeU4unrBs8n+oHOwP6X3LUT1xzfGZuT8A94YVu6NskpEOzxXh2pZ5t495L5aW3UagZ6RHkv3U1iG85IAXc+1Kcv7F7H8Ix1iQI9WTuccU15cozuQiNkvzRr4A8Y1zK+gnSN2VMc7rza95Vwaet58AGHMGz1pfDoT5ny2D8LGQZisjTNK2UlmUN/1GX8eU8xCvt79GfycYYZJrl2Hzf+jrmL5cf/qRQrJoQLnTU6zvQtvA7ofl813oB/cFz2TAI+ErI5+c57SEbE2X1B50IV+l1x3K5FNQOehTYN/PxROWTT6FefYI7ypZCj6FOX4nncW9irZ54LD5crzfZIdRPXmYdgnPLaNtkDp3EHZuGde3KWwS4JHqR8PsJPaj1H9sZZFZXcpkNh7wCPTRefQhKP+CDwE+51b85XZVGeXlAAeVl4U452/eE3dFgC3MT0jbPEkueC82TyLVXxabf0G7Y96lYJt/oThrSvjSgy0yoHf04dJkp8LmW6T8uVyQF73nDFmE2SmbDyxlS8N8YLSl5hq45Jx4WFurlC1ioxui7i+Xnk/HsWtf8AiPy/I4b4BlSbXHMD1AeyVgPxvQVvdF7tL7SqLue8NzPi7Np+K4hvsOEHPucmtDVjh3WY77JsPmRPG+SduesGLzy7l+wGjO5UquWYfZA6zDXPA+ySKzXMpkhn67Ob+l/f4bYEwi4M9bz+uZ63K4FrQLjEluhjGJOXeOfhuFSc65hvltOOc60ZAvrudiPy7lj48PwYjrJNSGakP4wL3jd/Vxft+2xo5jf9vcUn/ujSSe0Z5I+xc0JrH5FxJzfJIyNtcjTRnjmuBDJdbszTk90h/ct0qywj5TagwZVl/lWI8I63uwbAH7Fnk9AufPBHRsFvZVfcEjfWeVpC9arvvoxhuyKvc9aWE+S7G73SqYK5hdxYzzeLjvkOJNSAlG87yFK2OrNMgMx1Y0fsH9Rn+HsZXAPoJZVSAn84wF7tehOENhbPV2ibHVeCOsnOMW+m1bR7CNNXBsJeBLF+S8dQhGKg91pzaED1zX9kZ3/yk1tkIZ0DuuV9jsidS9nWFtA89qmXb5o+qr92Xv0P9q2QL9R+QxivSYANteX/BMF8ZTrG6E55rzQv1xwe5GOR+5aRGbinkRTnP/cdj5SKnzOeMBWw5+l7Nsr0jZUvc4+vz5FnQFz7rlAD9+u4LiTCyhK+b3lcy7QvBbTQ0gM6lvR4XpSjnL9oqULVCnDUJnSgu6Yp4pNe+XxHOdfgldCbuPAb/hRbLCb/ZIffckTFeovIy3/vnQXBDeZMiB7s408efKxIMXwoOQbjTiWWLGfAs6h98iygF+/LYqxdm2hM6Z95KY30HGe1CaQWYS374qpnNUXsZb/+x0VRBu3qlCOmfiryoTD14ID0K6UfgOm8C3wwo6Z347jPDjPTsUZ5cSOhd2hw7lOQRkRXHLvX4fpoc4x2Sui4aNo1uFMIaNo20yI/wZb319pPZjzjNS+2k2eKL2U1k7+8iunTUkWTuTOsMitXZG7YV77cz8lqDNhlCcVpCfgA0vai/wDjXXMEdZH+lPjBRWjnu9ONdH0iAz2/oIzbVof+S00T14BXz5Bo0X7+nLAQ4c51GcZzbriXtGgG2IgY34mWmESe73C/veNc5b0VjT9r1rXB+R6HOqvPX3vlLZtrv1a0P4wL1nFxTxRZE3XAsx10eEzv8U/ZblZMBouxNQyv/Bu6By8Fv4HFBeSMYFnTLXNm138VKcy0uMXczzWuY3iHBfIMXNQFlYbxlv/XtqyOc289DxpfRQaF25AcdRxdaVKc71JWRvjqtnGrLDNWgc78w0ZEnjHWpX9H+SPcXDNVmhNeGibQ7HudJle0XKFpi/t54xta3JUJyvRdQN6muxbyOexhdJZ94th/1mrREH9zpTnHuK4JTs28N0aEYZy/aKlC2lQ3i3Sg7qBHWI4jxQQodMv5l0CPeKEE8Ti6Sj+MV0aLyRD+rQo33c04H3eUjdtRKmV+Us2ytSttRcTJR7THAuRmC81Bh1LqYF8EitvQrwKToX02bIarwhq3qIg/MabQLys82z0G8qr4K5PJg1HnNPYB3Em5gSjBQ2E/BIzc2E2V2sw1zw3miRWS5lMvMBI83R4J09r8P8kcD+A+t3Ls27l7MQ53Mwf/TXGPNHUvOKYfNHeCaur/NHAnMIjbZ5RXN8ruOQX1YbwgeeI/1PH30xlEGxeUth36XXnamUN/1GP9YcO/enDxlmT2x3aUjNw4XNmU8GjBSG39sVsBdF21qlbJk5/jqvd7+nnyrjdw7eGwGPRLup83rfxV8Kj/B4rHCfSqOlLKn2GKYHaK+kxn5oP0vJHcd+Evs8oo79pNdkhfjMo6/IPfabbchqvCGreojTBvKbLSC/Km/9/U/0ezbgMfvsOog3OSUYzW+tSbWBYvYA65Ds9zSLzPyUyWwmYKSxAM5lNmzcg1fqPnjz20KzDPnhnOSeMCZpDrChH4ljLHPfsqRvGbZ+ivc5mnsv8Awc9uNS/vjEEIy4DkFtqDaEjyzEmR/IP2xM0miRgenP4ngd7YlU+w0br7cCRuIZ7YmUf4H7CXLwG2UhPcfJzRP1XTUhMs5CnKVFdAjzIpykP5TnEJAV9plSZ3vD6mvrMpbtFSlb6n73KHfpoV8u5YtGWReRnt+V9EWpz+b2RecYsppoyKoe4swG+c0RkF8xn2UO4DH7IvSrtk4JRgpDW9Sf++7NedAwXzQNMkN/2TzXofuSo1Lmi44GX/Q48EXNOXXc01oOXzRML9APs82Z03t/+KLm+RCbL2rygb7ox4v4ETbfO8x2SK0ThbWDNsBo288u5UvgXUQ5b/31iXLMr3DzRP1UTYiMsxDnvBJ+pzlXY9pWHCdg/yi1FhpWXy1lLNtLadkCfUGjTZ/M8wuoT5dF1CdzrgXb/+wi6cw9Amjvze8yzAacFOeqPo7ZUacF1jmK6jSVl/HWH+9Veb3Pe9P/ac9si5FHVT/zgD4Y1TmuqZTDHwj7ljKue1IY7usQOBvcaPOxZhvykZGF3xF1bQ3HsRL6I7VGhjZxIFu+sxps8zG2NXSKgxik+vyw9fI2S9l8smieZRtD22Qxx4JHaqwVJos5lrIZZVEoe24fZDHXgmdumWUx11I2oyyadNnb9EEW21jwbFNmWVB5UTG3pQDzQOOdp+yWgo2b1wdZzLPgmVdmWcyzlM0ni4bCfMi2fZDFthY825ZZFlReVMxzU4B5oPHOU3ZzWxXkVUwW7RY87WWWBZURFfNcBzHPSwHmgSHv+URPc6cue34fZDHfgmd+mWUx31I2oywK58K264MstrPg2a7MstjOUjZjv1rwixb0QRYLLHgWlFkWVF5UzPMcxLyNg5jbHMQ8x0HMcx3E7GIbTINuDDTeecpu7tBlb98HWWxvwbN9mWVB5f0vYJ7nIOa5DmKe4yDm7RzEnAY5496Q7TeRxOOviroHjjDUwTuubywM3ts93rM6VNZCKGsHdnl014+pL/R7B9Gy/Q6d744CPOl8d+LPtzCvtzjIi9a2d7LIaufgvYq5nhZDvlVQDoVn4X3+Jj1xKR7Jg+wBYddr6IuCd8RuptveSFcPcRZBup2MdPSb6lrLrgXauYRu9UWv9Vo+teXNQRZ4vkQ/uu0vNMIk7eVCAzf93h4wkr1E+7BQCE/YWn05y/ZSWPYQeMez8QJr04U5MdJbsj1UNu7rozh7BO0rbF/NDgZvsy28me3Fxq8tL4ozHuIQxlojzg6AneLsXwR7f+o57qvBtp/x1q8L2ldj9uM5r9JW+6tsqXZJfR+1S9JpbJcU5/AS7XKRwQe1S1sbXFQkHcUv1gZ3MPLBNnh0EZx4bwalHQhhOa88Ok3lZYAX1K8MxKH/U7s07Viun3nAOzSozusMPJ4nOw6gsihvU3ZY77jfTeA8bhfKjPa7LTLkI+U71nk98qanyviN/0ffX0J/hOo8jzaB8s4ZPOG9KbgvTcCW+jZfwrSlUTG3OYh5joOY5zqI2UXd2MZBzPMcxOyiPm/rIGYX5eyiPrc7iHm+g5i3cxCzi/rsYj9Y8UXLg7nSp5QHs4u6saCCuSyYKz5/eTC72AZd9JHSIGfcJzNkjCSe7n0yiIdk5hkYPQMj7q/ZAWS2Y/De7vHuk6GydoSyBPZ+FN3HtJNo2d37ZHYW4Ennu4Q/38K88i5BXrQmtsQiq6XBexVzPe0C+VZBORSehfcNxvTEpXgkj1zwTtj12hvtr0HsZrqJRrp6iIN7eJYY6eg31bWWnQftXEK3+qLXeg2Q2jLuk6H1mDr4u6MRJmkvdzRw0++JgJHsJdoHiT1nVV74Gh+VVw9yWZRSmdVDGPJD75kg3RbB79myci3YElyfRsx4TwvFGQvtmXS22utdH3hPzEQjb0qzBYRPNPIO25eyAzv/jb3aZ43Bxw4WjBNKYOTXq8YOGd679XUn4FHnPc7CO8XZekyPnKYF79i+tgQ5zrH8n56++DkfpT4ZeUpDnzy7SJ9MdRi1T97RSJekT86Dns2B/nkRpGsP3vPJnl77fk1eZgIvFGcK8DLFSEfxcU8QtadaIw6lzUKc7UrYli3Z+bfbP8K2JWD8cMzRT/aPn3e7/Vtk4Z3i7Ax6uQvYN9MP0f8/wPJ/eir2r3/t3/5F7J9px/pq/2Ya6ZLYv+WgZweA/RsH6dqD93yyx2r/TBuF9m868GLuiaT4aP9InrVGHPQ5KU5HCdsynZ1/u/1bZPCK9u/QfrJ//LwX9/+Qd4qzBvRyLdg3qtOZIMfTLP+np2L/+tf+nVrE/pl2rK/2b4qRLon9Oxb07DSwf1LzCotDeFkEvFCcPPCSN9JR/GL+3yIjH/T/ziphW/i/VWy3f4TN9o3wc/rJ/vHzbrd/O1p4pzgXgl5eBPaN6nQKyPEay//pqdi//rV/Vxexf6Yd66v9W2SkS2L/Pgd6dk0/+H+mjUL71wC8mHOdFB/tH8mz1ohDabMQ58YStqWBnX+7/dvR4BXt31f6yf7x817c/0PeKc7toJd3gH2jOsVzWg9a/k9Pxf71r/37ThH7Z9qxvtq/vJEuif27G/TsQbB/UyBde/CeT/ZY7Z9po9D+NQEv44x0FB/tH8mz1ohDaXFt5fEStqWJnX+7/Rtn8Ir278l+sn/8vNvt3xQL7xTnR6CXz1jWN/Igx5cr6x+ptX8vFbF/ph3rj/WP50DPXu7H9Y9xwAvFaQZezPUPio/2j+RZa8TB9Q+K84cStqWZnf/i6x/NgJHivN5P9o+f9+LrH8g7xfkb6OWbYN+oTnH9o2rT9f9PT8X+9a/98zbticu1/jHOSJfE/v0T9Iz0SMsuD+nag/d8ssdq/0wbhfZvAvAywUhnW/8w/b8pRj7o/w0MeA2zLfzzn3b7R9hwjE5xBpfAKGX/pOZ+Tftnm5+gOMM37ZHTCLBvVKfjQI7jLP+np2L/+tf+jS1i/0w71h/rH6NBz8aB/SuX/2faKLR/k4AXc/2D4hdb/6A4tvWPKSVsyyR2/ouvf0wCjBRnej/ZP37ei/t/yDvFaQC9bAL7RnWK6x8LLP+np2L/+tf+bVfE/sVd/5hgpEti/1pBzxaA/SvX+odpo9D+TQVephrpbOsfpv+XN/JB/29xCdvCP/9pt3+EDcfoFGdpP9k/qbnfsPUP5J3i7A56uSfYN6rTCSDHVZb/01Oxf/1r/zqK2D/TjvXH+se+oGer+sH/M20U2r8ZwIu5/kHx0f6RPGuNOLj+QXGOKGFbZrDzX3z9YwZgpDhH9ZP94+e9uP+HvFOcdaCXJ4B9ozrF9Y+zLf+np2L/+tf+nVXE/sVd/5hqpEti/04GPTsb7N8ESNcevOeTPVb7Z9ootH+T/7+9c42R5KruePVsb+/Mzs7srPfhjePdqZ6Z3Z1998zsePZhOysSOx8gCEd5gDASwbC28sAxiAgnOFISSwGFDyQQoeAIBCIWr4hYSSBYKARHBAkiQEh5oMTKQ1ZiARFKHCSCxCapmfrTvz5zqqrHU6d7Fqa+9K1b59Y959zb5/7vuafuhSw2/nkj6x+MfxbNWytsy3zt8pfHP8+DR9G8bUj2r37Zfft3zJFdNL+LfvlOZ33jNPT4+Pb6x5a1f39QYv+sHRvG+sdj6GePD3H9w4t/PgVZ7PqHF/8sfdr4Z65/iOYPK2zLqdrlL1//OAUeRfPEkOxf/bKXr39QdtF8DP3yz2Df1KZc//is81zXtv0brv37q4D1jzrjnz+JfvZZ2L/TKHc1T3c2d5XGP3vrHyuQZcWU89Y/LP47Zt5D/PeFCttSv//Tt3/ijXN00Xx5SPYvyvdr7Z/nnxDN36FffsVZ32D887Pb6x9b1v79e4n9e77xz3WufzyNfvbsEPCftVG0fz8CWez6h+jL1j9E461/fKPCttR/Hlj5+gfPTxTNc0Oyf/XLXo7/KLtovoV++W3YN7Up1z/Gbl3/XNe2/Ruu/Ru9tUtb1/rHiim3Gft3Hf1M/WiQ6x/WRtH+3YW8dp4WPc8x1LNI3HqX4fsuh2/llZ1lpb24aLclU8vQ0G8pmoN5G3k2cdwpm7XryZ1rae4hdwpljpu8UfCXJvXqsWh/PtWX8XgmT3PvO6UXwPeKycv4vhjEt51/6P4ieJQMK8hTein/baCMfdcyaLS/equgviZojpf0iVHQpUltOlnKeLycv0s2WLxdAo+iOVXCI98lPo8bealL7tMX1d5WtmXDD2XrVOg/4EyxhUjZ2X7Zu884sotm+daunlaAQ/Rf4D4ldzvPdZXhFLb37UG6vKP+967ilDshf4p6KNMPQQd1ycS6hVNUj/KbSN8FnCI66UNtKN6z/+KVPE3ebbk5U24SNFdQ7g5TTvdq69W96dDP7gZOqX8OsKa7KwWyLEMW0cguRe6dccbwIz64r6nFEaJRWeKIF5fYrEw2YQHJzfGWOCHCtpWNt5fBo/K4X7eVOesvDx5eSxP/zKPMKZMX2a9Ul959yshA/HMKeUoT/8yZvFHoJK2Z7znDt4d1PCynNPHPSsG7iH801rQK6muC5tUV42/AOLnEcdL6cr1x8oEK/HMJ92nSbW/qVzrg2TtRa1VWNrXNKUe21w4efy5Eys72y959xpFdNK/HuPQGxw9D/PPo8/TTsL2vBOkyAFd1OLarH93uyEScUpdMrFv4R/Uov4n0bwD/iE76UBuK9+y/qHGIvNtyK6bcJGi4b/ftppzu1daZ7h5GP3t0APjncoEsxD+ikV0aNv4RH2X4RzRvrcA/wgL0N6kscUKEbSsbby+BR+VV4Z9F4J8lp8x5kzeK8mnNchWdba/6Mh6FZ84jj/1KfJ8yeZGxa0W4bR48luE2naXdQBn7LuIf25dtfezL76sYfwN8edeI42TbxdsceBTN4xX4x2JCi9Opy+D51pInm7U3lO0jFfoPwORLkbaW7Ze9e8GRXTRPYFz6Y+AbtdsS9PiU81xXGf5he0dhyYB5bId+BPWjy45Mt0MHdcnEuoV/LK5oIv1p4B+LR9SG4j37Lwr/kndbbt6UmwTNRZSzWEP3nIN8HP3sKeCfqHHqYoEsxD+ioT9kIYgfO/6IjwXoUe1k8Q/nLaL5XAX+ERagn8Rih0h/w1LSK6/uGSehvDPg0cqc9Zev3byWnsDzYyizYPIibavq0rs9rCO5FpDHfiW+z5m8yP/DOcO37onbJMM55ClN/HOm4F383sPGMtv6GMv8zxXjb8Ca8DX+J2XbxRvjbUTzTAX+sf/vBSMvdRlsbxY92dQ2C45sX63Qf4CfZjHS1rL9sncvObKL5hsYl/4T+Ebttgw96sA5PtdVhn/Y3hHz/aA5QsfD0XOOTMQCdcnEuoV/VA99yEr/L/CPHfvVhvRra88O8m7LnTHliBm4t0vRXJ+xct9EP1M/ihynThTIMg9ZRCO7lPGzFMSPHX/s/CKjUTu1DA2/rxXNaK7DIvwjLOBhC+KEKB/0ctIrr8U1k8n6Oem4I3PWXx4B/jlhZKBfaxByFfV1+kzK1pFS8H3a5EXiHxt/q3uOz5LhNPKULsM/oiH+OZunWwX1NUFztKQvjyYh59lc43/S4h+eZyOamRIevf/3nJGXuqS9CWjvZU+2ecMPZZuv0H/AfgLLkX2d7Ze9+7gju2jOHunq6Tzwjf4LJ6DHO53nusrwD9s7Ii4/CEuu4p9FyJ+iHm/MrBv/8PwIzql53oDSdxzp0tq5t9qQ81GNOeTdlrMxC5yzc92maE7MPS6W0M/uBP6JilM9XyAL8Y9oZJcyfqL2jrNxs+KDONLOmUWjspy33N0n/mGcsMoSJ0TtlVI03p4Dj3YPnHFH5tV52aG19ASen0SZ4yYvcv+Lovhn1UeM5sU/p+DbW/+Kin8vWv8i1rF9pmj963TBuxgTr7GmVVBfEzT3Voy/AePkNY6T9lsmb5x8ZQX+OYv7NOm2N/UrHZyFbFHr/1Y2OyelbNcGjz8XImVn+2XvPuHILpqfw7j0C8A3FtNnz9/kPNdVhn/Y3hHz/SBc1eHYbvd7pUzEKXXJxLqFf1QP/XhK/wrwj+ikD7WheKcvlrzbcnavrknQcG83u7evPRMw091D6GdvAv6JGqfOFchCX5bnj46Kv7D+KBuLwzHKxoxyf13RPFqBf4QFJDfHW+KEqLNii8bbs+BReZ4vh/Ou9wP/zDllLAYZJI49bvjNeBRW8PDPOH7nTV7Gd9TepfOGb4sjidsYs6L0nvy3kaw/y4X/GdHYvmzrY19+V8X4W7svb+FV9xHHybaLN643i+bdFfjHYkKLyalLzrcCMMA1T7Y0v/fmUu+v0H/E+uMgvlEQ/pl1ZBfNBzEufRj4xp7PkT1/0nmuqwz/sL2jsGTAPLZDP4L60TlHJp5zXJdMrFv4xztrWOlPAP9YPKI25Lq+8G/ZGc0nTblJ0JxBuaLYAs5BPop+9iTwT9Q4daZAlhSy2DWxjJ/ZIH7s+CM+OK+2MaOp4Y9xe0/16f+hn8RbJ4ryNxStE/F7e4t1xpP1Mmf95RXAP7nYyTTKtE1eJlfUHkiqS+/WveqbgAxt5LXBr35nTV6kP3TW8K17rtFJhlnwE/V/mDH8eHUH6GKRetdVNnbx24iA8Xppo99SM3YvYu4YJGeHtv56Uu8YbW2r9XXxe5AT0F/UXLdojsS57jbP8Txn/Fg7x/ny7Bbh0Zu/R80Niuwu21DjUdvR2fgW09kM+AkY8zvck0fvzzDJ/wDDtuuvd6lh6kvBh+prgua9R7u038l545hO3HHU5EXiDtWVGBmIOyTPUeQpvQc8Box3Sx5WVd2qj32yVSBHEzSj+cMibL7H0YHSxISenRqmX08yE4NE4UP1iUbSi7Opi2icUuN7lzh+7izQcRM0B0v6UD9jMf2wnN9G9J8gv+0SfVnSmfj3/Ki3VujsVIHO2MelK9GOoC6OdyPJ+vWE63m+fUdGH6SjxaA5/BJ9KNY/7K3hH6/QvfXHzBndcX1ctJlsR+uXrdS+qD7iII6hW2nsnEzWYwLKNpKXy4+I7sGXAXrtELM0E38sJWZZOdrlWW2+I+ltD47B9rtWlbkF+XPm3YOLKVnqkMedRg5vD4MrFTzW36+WOjGy+9/dpI7sorkKvPqCPM3/1xHo8R7nua6GuU+Rpu8mIs4tKJ5jtR8xdjJFPZSJ8RF1ycS6G0lvfCfPIVb6JfgP2zhQtSG/jdSaAHm35Y6acpOgOYtyRXtRMPb7bvQz9aNI//DZAlnakEU09P1b/6zoGR+a5ulW4mPiJmheWmFbjtQuv2//xNsR8Ciae4dk/+qX3bd/M47sovkZ9Mv7YN8sDsmev855rmvb/g3X/j1UYv+sHevX/rVNuc3Yv/vRz14H+5ei3NU83dnc5do/a6No/8p8y6Kn/dP/qWVouD4qmocrbEv9+Ne3f+LtKHgUzSNDsn9Rc6oi/EfZRfPr6JePwr6pTdvQ49ud57q27d9w7d/vlNg/a8f6tX+zptxm7N+b0c/ePgT8Z20U7R+/BVbsAv2/aZ5mXEM7iO/U8K174lblSXe0ySqnuTjttmRqGRr6CkTznhKbOO6Uzdp1srmW9mIYuL5O33FU3HVR3Au/D5JOPf8/12m8Nbdh+v8lgxfXy/jYEwXvOgoa/R9aBfXRF/5HFeNk7euQeXysfJPW90y8IZo/qfB/2phhz/fsfccW4Ftc8mTz1rNE82SF/iN8/5F+VbZf9u62I7toPoXx49PAIWo32qEvOc91leEUtndEPF6Qz6/D8c7uIUCZ+K1MXTKxbuEUG3fKb9y+CJxi41XVht5eEOTdljthynnf1DSS9Wsfdp+pTHefQT/7EnBK1Dh1qkAWrn/Yve0j8Ycdf7x1DTv/s+vRnP/9fcUavJ1fjid+DGLU9yhFcTgnwaPy+K2PlZmxKFm/Hcvzj6DMtMmLnP+rLr17GmnxKBmmkcd4Xv22Td5Wi+sdJh4P0sXiRn2MjL+Kited2QA/nB9HxKYEydmhrb+e1DtGW9s6Y3Q16BjEojmS6rsReeYZh4wXEF17i/DozYWjcHZq+NE921C2fdrR2fgW01kKftL6+VmNNZ0wdWXj+/h0t97p+utdbJj6UvCh+ri2+FvTXdq9eZrjI8fwCZMXOYarrsTIwDGcmEO/SjPWNGDsWPRwn+ou+w7MysE1hFtygapiTakDpYmvPDs1TB+ZZOZ4HoW11Cf0P5h2dBE95tf43kWOnzsLdMx45RMlfaifsZg+zUF8nxTgA12kX0g6E/+eT/Jchc7mC3TGPm6/axhJ1n+Pkeb51gYo1pS+WNGPmvurebqzuav0v6L6OKan+e9WGwcmk/XjG2WzcZPESgF67XD8bSb+uMDx9wXTXZ7VdxQ3adeROOboHSrDuMkZ8+6B+do7iz1xozuNHN7a/t0VPNbfrxY7MbL37o1jY2Ypu2heCOz1Y3ma/68x6PFe57muhrlPkeacPmIf4SA/92o/sjHrpx2Z6DeuSybW3Uh694Rj/KvSL8d/2K4Zqw25d5z8guTdlpsw5bjWfBLlTptyuue3Fvegn92L+UeKclfzdGdz16ruThbIMg1ZRNOGLG1TTvSMG9f/qZX4+K4JmvsqbMtY7fL79k+8jYFH0dw/JPtXv+y+/Usd2UXz8+iXr4V9szhkdd9057mubfs3XPv3phL7Z+1Yv/Zv2pTbjP17HfrZI7B/UbFzJwtkaUMW0dA35e2Houdc74maOxfFjZBvL/7Dfttkv1EiHrdxQ4wnFM1bSmziuFM2a9cv7lhLe2s7XHegH2BY+6HQd+X5cuhz8/ynw/TleHvNKM24oWMF75oAjf0Ou8yv8a6KcbJ2n3IeN8S9G9NkfdwUx7N3V/gRbCyV50ewsURRa4OebJ5vUjTvr9B/hB8n0q/A9svePe3ILpoPYvz4MHAI/4d6/qTzXFcZTmF7R8QpBOGfDsdg9aNTjkzEE3XJxLqFU7xz35T+BHCKjeNJ8zT3S9ecnbzbcnafdW8vukZSvIcsY/c+in72JHDKoPaxox2SLKKh7z5g3codfzy/Xpqn7XqK/Z44u56qWE8RFmBMjsoSJ0TF6aZJr7y6PwEelccYaCsz1xWzZ3uTblpljpi8SPyruvRu3XNPGBvbxP0AiX9sLNFWi3eK/D8U7RkwHauLxY3OsVPwEzBeL4+b+qr44fw4Yq4UJGeHtr7uuCFrW1Ojq0HHkxTNkVTfNs/bPH8v8czvwtL8l36J6S3Co+cniZqDFY1vbEON+0ccnQ1i356N6Owo+InYkyeTd8rUlWG/RtqtN2A/hOWGqS8FH9wPQTQXZ7q0O3PeivBdavKGGYc9AblS5CnNmLIInNNI1q+BqW7Vl9HYbzCtHPwGcyp/WBVTRh0oTew9a/Ii/3P97G+d5mna9igcLt2pD00ZXRTZKW/uEjWXL5q7cK8G5U2Bn6kgflLDT7pd93frDrDRixwbdDXMfYo015Mi/jf0OfTDT/B8uuOtr0X+H1Mjp+6/z/bEv8A1rH742d4Tv/fKdGX9tN53DaLZ3l9+m+etzPP2Pv7r+UkNP7pnG2psbzs6m9piOkvBo/VZZ3PCn0i7/AbM9S5w3t7PfvvfbndpX5rzxniMKciTmrzIeYfq0rtTo8sJoz/lKU2MF+CPuODNO1Q344PsN1BWDn4DdV/+0JuvevM+rrMH7ye/2iY2rsXbR8fGsUTiTLW/+kvb0UUAjupE4cVMjo3E3DyYrv32G3OTk7sxTRwfI/pPkH1e1ZndA8jaZ+4B9Etpuc5OFuiMfdzu3R8k22JQ3Mqqzmzcivj3zkx9JC3X2ekCnc1DZ3bP/ZFkfRxII8+3caz6Rsy+I6MP0tES43ZqfO+q7hXLa2OGGF8smt9M136LdG9jh1OjuwnoS7SR/ssimzw3wLqTkrrT+ute9trUrnexTX87z+y3Te06GcfZfuLIuR9FmqftNyTca0o07yzhkz4l9quoPamL+tUR8CM+uUam54PArEWxP9OOztrgJ3o9RW161ugnRhcL923UH0ufZET/ifKr0p6M1vbe5dX4ZBtr6a27cHwSD1FnYhStsZxx6q5PF7et9uNzfejinMNPxF7JZbo459Rdoy56ztIu08V5h5+A/Z1LdXHeqbtGXaziqE4fuug4/HQGrIuys8nLeD6zBXgeNel66l5ZtXELfehiweFnYcC6WHDqrk8Xa9/NLvahi0WHn8UB60L1bZTn81uA51GTrqfu2y5ldS/1oYslh5+lAetC9W2U5/M3IM8LW4DnUZOup+7bXpPVfaEPXVxw+LkwYF1ccOquURfXsrqX+9DFssPP8oB1sezUXeO4uoqLbutDF7c5/Nw2YF2ovo3yvHAD8ty5AXk+cwPyfO4G5Pn8Dcjzjfgf3Ap9Y9Sk66n7ttXv9Vf60MWKw8/KgHWh+r4feF64AXk+fwPyfO4G5Hn5BuR5K+g5W89o5+nL7Uh+Fl690e+BxcM40lzfuJinryb1xnerrouo61Lt+lhrH9tfdH8ptO6F+7L3XgmQKXvv7fW/d9Wvd0f+Lq0L3+7o6s483ai5ne7AexuoR/lNpFfaXVrRSR+yB+I9W3++nKfJuy23YspNguYyyt1uyulebZ3p7iz+5xF9q59+nelB/2Xu3aB1VX7bd9HkRdrLi4Zv3a+AR9lL2oeLQfyorkb+bls3vxk7u0V1Nok8yqP0SF7OnuMYpNeeM8qahucZ5Ivmxfg/q89qb+W2Kce+b/eE4t7KK+bdRfth1b/Wvtwhj3Zv0WmHxx+v4LH+frXciYwtuQQZs3ePObKL5qfbXT29LE/z/7UXenzAea6rYe5TpFegy++VMZkybYUx+f6SMVltuNEx+aIpt5kx+RXoZw9gfD6LclfzdGdz16ruLhfI0oYsouG+8fabatEzLk7/p5ah4b71onmwwrbsrV1+3/6Jt73gUTSvH5L9q1923/6ddWQXzRvRL38Z9s3ikOz5W5znurbt33Dt35tL7J+1Y/3av7Yptxn796voZ2+B/YvaX/xygSzc50A0PLfcfgcieto//Z9ahoZ7movmbRW2pX7869s/8XYRPIrmHUOyf1FzqiL8R9lF83vol4/BvqlN29Djh5znurbt33Dt3wdL7J+1Y/3av1lTbjP27z3oZx8aAv6zNor2j98UjZlyoqf9kz5bhoZnN4jmiQrbUv8exr79GzOy0v796ZDsX9Q500X4j7KL5kn0y0/CvqlNZ6HHzzvPdW3bv+Hav8+V2D9rx/q1fydMuc3Yv79AP/s87F8b5a7m6c7mLtf+WRtF+8dvJO33maIvw3/27Cbivy9X2Jb6v/f27Z944xxdNH87JPsX9a27tX9tR3bR/AP65dOwb2pTfmP+dee5rm37N1z797US+2ftWL/2b8yU24z9+xf0s68PAf9ZG0X7xz1Kte+76Onr4Z7wUXvdtw3fuiduVV7Z97xaiynzW95i3kO/5bdKbOK4UzZr13fsWEtzTxjuP5KavMg1kDTp1Yfu+90ThnvZzJm8oL1C+j5bSDJ4ZwtprbmRFJ8txD1nNnK20NhMrx54Be0FsvpN50b2OZko4ZHvEp+pkbfobKG0ftncPVy4/5CVbX+F/gNs0oUg2d2zhdqO7KI5PNPV0y15mnsazUCPJ53nuhrmPkV6+2yhjcvEuoVTys4Wmp/p0trv1tWGwzxb6Cj6mfpR5Dg1XyDLUcgiGu5NEjVvtOOP3Q8uo1E7tQwNzxYSzUKJzeIehzxbyGKHSLw1k/TKq3viLeVxn2orM/fr886/If5hjGdUO6ouvVv3xLLcP0N5KfjV74zJi5y7FrUHz4SUDDPIU5pnK84WvIv7lNs992x93HPvRyvG39r3KsrPVtR/w67l8/8mmhdW4B+LCVMjL3XJffnSumXLsZ2VzZ4rQNnuqdB/ACZfjsQ/bL/s3Ucc2UXzUxiXXgp8o3bjuRP3O891Ncx9ijTbO8LeZu+dr/+9q/jH7us378h0CjqoSybWLfxjcQX3FLwG/GPxiNpQvGf/ReFf8m7LzZpyk6Dh/N9iDd1zDnIv+tn9wD9R49TxAlmmIItoGDcbtXeYHX/s+S0ZjdqpZWgYWyuaByvwjz1/wtsLONLfUHS20DHwaDHguCMzz9fJ+u3+pFdunsdIP0pU/Ivq0rutX887/3Ei6T0LUr/2PJ7RZGudCRn5f7Dr4V7dAbpY3Oi5GDxTKg3i5+gG+EnBT8TcMUjODm399aTeMdraVuvrGvS5aqnhR/f81uFG45n7RopXzj2PbBEelccxLg3ip8iGpeBHtn3C0dn4FtPZGPgJGD9Xz887YOrKxvf3zYTWu8hxWzje8tEEzcxsl/bxnLcJlOEYPmbyIsfwov7GMdzDI0rz/LyAsWPRw332GyH2yVaBHNz/94kKnLvH0YHSxFepyRu2j8zaikispT4h3iYcXaT1190J0vEix8+dBTqmr/jPK3xXVWMxfZqcK0b0nyAf6KrO5ozOxL/nk/xMhc6q/Pn094l2JFl/xmya51sboP32Rcf/yyDmd/a/wvg22XqOB1tpHJhMeu2/5FF6JC+nWAtipYhxvwFdlX07KpqvwJelvqPvhidMOY45erfK8Lvho+bdA/O153ur2vN7Jcecw+PTFTzW368WOzGy954nq/bZ68gumn+Fn/AZ+JvVX/ZDj885z3U1zH2KNOf0UefMBPi5e84itN8fUSb6jeuSiXU3kt5zapTfRPq/8B+259moDb8bW5N0/YLk3ZazsaOToDmGcjYWx35rkenuWfSz5zD/OIByV/N0Z3OXe26Vtc+ToKFPeK8pJ/o2aKTPlqHhd6mi+XaFbakfg/r2b6+Rlfbv+pDsXxT+tvbvgCO7aHZg7rkzT9PHzXnzAee5rm37N1z7t3+2S1tlx/q1fxOm3Gbs3xj6mfpRprv9KHc1T3c2d7n2z9oo2j/6pmQD6D+z8RaR3/zbueGMw7fypDvaZJUTFqXdlkw2blpl6ZNKZ3tl5jXulM3a9UWIm7Zzfq47RJ9FTvuvd9u1SPpEPF8OfW6pyRu2L4c6U57SjBtqF7zrAGhsDJytrycGrqRPhPiU87ghfruYJuvjpjieLZfwyHeJT8+PkOZpxu0FtPeiJ9sBww9lu1Kh/wg/TmRfZ/tl7x5zZBfNVYwfLwAO4f9Zz+9xnutqmPsU6eAzVMPOoucYbM8D9c7XrhuncN8N4hbuo6H0S4BTRCd9qA29s3XJuy1nz/zzYo0bSfGZ1ozduxv97B7glCjf2lyBLAcgC/0k4mciiB/r6xMf1k+ZXS1Dw7Ut0bysxGZxjdeLLyZOiIrTTZNeeXXP/WWUR2xQtq6Y6epQnk+f7ZTJi8SRU0Yu3TNWyMY2TSS9cU76tbFEWy3eKfL/YP0hXt0Ra8gbnWNzLT0qjun5+jyjzrcMkLNnP8u644ZSoytvHUU0g4gnKZojqb4bkeeib585x9sKPHpz4SiMUWTD2Iay7VOOzsa3mM72gp+A8XM1buiwqSsb3986G1rvIsdt4XjLRxM0e+a6tG/LeZtAGY7he01e5Bhe1N84hnt4RGnGDQWMHYsezrXrA+yTrQI5uIbwWAXO3ePowK7JFNmpYfrIrK2IxFr8ni1N1vtiBzHm1/jeRY6fOwt0zLnSByp8Vynus3RZPF4KnUXFbbeDdGZjrcS/5xf6aIXOZgp0xj6e5mnRMj4oxW+Wb22A4oZEx3FhEPM7+1/hOoFsPceDrTQOTCKP8iht44aIlSLG/QZ0ZWNHuHYqmr+EL0t9R3FD3vdW1j+iMowbGjPvHpivPV83pz+Dcsw4PH62gsf6+9Xaunn9svfuWaT22e/ILpq/hp/wC/A3q78cgh6fdp7rapj7FGnO6SNipYL83Kv9iGu/KeqhTPQb1yUT624kvevT3KdF6X/Ef9iuY6sNuaeO3X/VK7fXlJtM1u/D2UjWr1HrnnGzX0Y/exrzj8ModzVPdzZ39cSOWFn4HSu/sZcsdv3ZnqeW0Uif9ntTrj+L5pkK21I/BvXt334jK+3fs0Oyf1H429q/w47sovkP9MtvwL5ZHJI9v+4817Vt/4Zr/75TYv+sHevX/k2Zcpuxf8+hn12H/TuEclfzdGdzl2v/rI2i/UuRpzUd+s9Uhus9UXbb2l/dHwaPypPuaJNVzsboE4/buCGVpU9q91yvHniNO2Wzdt23Yy1NvxB9ItZPEhk7WfWdOH0ini+HPjfPfzpMX473Db7SjBuaLnjXYdCkebqVVPs1frCkT4T4lPO4IY1V1o+QgkfRTJfwyHepvOdHsLFEkd+XWtnUNt7e/ccq9B/hx4n0K6SQMUt7flnRnIKP/EyeZlwQ/e1XnOe6ynAK2zsiTiEI/3Q4BqsfzTkyEU/UJRPrFk6x8TjcM+vyXJfWxvGoDbmPrObs5N2Ws/vPenv0NJLivWwZu9dBP1M/GuT+PpKF471o6LufCuLH+vrEB/16dj3FW9sSzQ+X2Cyu8Xp7GRInBNi20vG2DR6978LL1hUzvoWP9qHMIZMX+d2QxYM2jonri4eQdwj86ne/yYvsf0X4l3hSMnBOrzTxz1TBu+jvUPu1CuprguZlFeNv7b7sHP/szt9lfbn8v4nmFRX4Zzfu06Tb3tSvdLAbsgXM0xY92dQ2hxzZ7qvQ/+4AHiPnqGy/7N2HHdlF8wDGpZ8FvpEuboEeH3ae6yrDP2zvGynWi3Mduz5LmVLooC6ZWLfwj+rhHErpNwL/iE76UBt6e6uRd1tuypTz9uYpG+vU1pnuXot+9jDwT9Q4NVYgC79vtd9wD9L/Ij44Z1Y72e9m6f8Wza9V4B9hAfqbLHYIsm0LlEXv1v1u8Kg8xkBbmbP+8smRtfQEyo+gzC6Tl8nVCpJLdenduld9/G/tQt4u8Ktfb619UPjbrttMQIaymCsP/9iY54xmH/Ti1dcEzTsrxt99deskxz835e+y+GcfeBTNYxX45ybcp0m3valf6eAmyLarbtny/aatbGqbXY5s763Q/00BPAbJvsC+Z78bo+yieRzj0gccfEMc+fHniX/Y3hHjXfbeg/W/t8P5nvrRQUemm6GDumRi3cI/qoc4VumPAf+ITvpQG4p3zkXIuy03ZcpNgobfVh805XSvts509xH0s48D/0SNU0Xr7cQ/omG89KBivWwMPudsZfuGiOZTFfhHWID4x2KHINu2QFn0bt3fBB4pr3i0Mq+ucebGxdtPcTzp4geuHUfhOtWld+te9WX87QFvyhuHPHrWMnkZ3yNBfLcM37ofAY+2PYiJ8iXI1X46UvCuXaCx/h9bH+fgfzN4/8814jjZdvHmfUvwlQr8YzHhuJGXuuQ+GbW3d47trGx2jkDZ/qlC/7Vj8v/nMbKvW//PHkd20TyDcenfgG/4f9bzbzrPdZXhH7Z3hL0N2iemZ59AG+9FmQ5CB3XJxLqFfyyuaCL938A/Fo/YOXV2L/xL3m253abcJGj2oVyRb51zkK+in30T+Gcc5a7m6c7mrp45gJVlF2ThHFX8RMXO7TH80DcgPbbAD2lUtgma71TgH2EByc3xljghyt9QNN4yTpS4R79W5qy//D7wzy7wrjJjJi8S/xTF/9BeWj3TJ0T8YzHRKOROk8Hgtj3gkX1FeUoT/+wpeNcIaOxeUrY+7iW1P1/EH1gsb45/JvN3ybZTF+JRNDeX8Mh3iU+7xzl1OQnZouJ/rGxqmzFHtiMV+p8M4HEQe0QI/7Qc2UUzc6yrp7k8nbWT2m0X9LjkPNdVhn/Y3hH2NsRH2lnDP9aPuM+Rib6QumRi3cI/FlfQh7l4rEtr8YjaULzTF1u2R94eU87zmXhYw669ZLqbRz9TP4ocp/YWyDICWbz1hyifrMUD4oNzZvHRMjQq2wTNlRKbNZl0sQB9EZRTvwG2rXS8ncSv9Z2MOzKv7pvo4J+mU6YJuaJsq/V92HGF+Idz/xHII753m7zI+UCRP45Yx8NyShP/jBe8axQ06netgvqaoLmnYvytHRPm+Idz+zQpx2g/WYF/JnCfJr3rs0nSq0vG30X5QKxsapsRR7aXDxp/5mN2lOxsv+zdnu9RNK/EuPQq4Bu1G/HPQ85zXWX4h+0d8b17EK7qcGy3a8SUiTilLplYt/CP6uH6ptK/CPzTz1q0xiHybsvZPX8mk971C5Wr2ksu09019LOHgH+ixqnJAllGwb9oaL+j1uPs+CM+WtAjY0lIo7JN0DxcgX+ID/RrsUOkv6soTobrj8rjWpaVOesv47lxuQq+k7r5vrhwqYWX/0DSe42w4tHuT5bfyO8bJn8kvx8x+Tvy+x0mv5nfN03+zvx+p8lv5fctk78rv99l8kd1b/LH8vsxk787v99t8sfz+3GTvye/32PyJ/L7CZM/md9Pmvy9+f1ekz+V30+Z/H35/T6Tf1N+f5PJ35/f7zf5B/L7Ayb/YH5/0OQfyu8Pmfyb8/ubkR8y3l9c25toR93vzcfUZu38LlzM3rszgF/6t4k97XyKdLSRTUOX2abcxb46xv4AjU4SN3ePnANZXMi5mPJFczL/zWhOg86OIdnzy85zXWW4kONuxDw8CG92iHmEC/c6MhG/1SUT6xYutP4mrm1fAq31U6kNGb+p8XlfSbldphzX0rxvYFSO9NmV6e480uxHFgdEYUXaA9YVYaN2Q65Xv+ZVb7j/RQ/en5jLizM5jOfia3WcB7+2LP93o+YdaV6eNNk+ZWNJ7xpkgrrsZX1OqtemR5LedSH73Msbd+rZ5+TZ2Gv7vuziuFvnfr3ZO6TvnQ5vTTzn+nKjfl4WKO+OZL0O9jn6+T8DmMAXFi0NAA==","debug_symbols":"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nbj8XHrew8el3byH7q8CxpzevTdY153L2h7+cqpfXAbDO3H5ubSb9/BzaTfv4efSbt7DzyU5l2xc2s17fsTlGncX11SecWk37+Hn0m7ew8+l3byHn0vPe9i4NLyfmJ9Lz3vOcZnvf7kuz7j0vIePS897+Lgk55KNS897+Lj0vIePS897+Lj0vOccl/cfh9qSn3HpeQ8bl4b3E/Nz6XkPH5ee9/Bx6XkPH5fkXLJxaTfvyWX/OSyWJbzh8pbU7H/69p8Pb8xQe2TTbuYjwabd3EeCTbvZjwSbdvOfn7EZA+1A4lr/YvP7p09M1QuGtxqPZt5ubjWaebuZ2Gjm7eZto5knZ34Q854TjmLe88dRzHuuOYp5z0tHMe857CDmDW+oHs2857CjmPccdhTznsOOYp6c+UHMew47innPYUcx7znsKOY9hx3FvOewg5g3vG18NPOu5yWYf79NNhjeGD2aedc2o04b1zajmHdtM4j54tpmFPNenx/FvNfnP2b+gU3X6JxskrPJyKbXxs+xmZayA0n0lE2vd3Oy6XkeJ5ueu3Gy6fkYI5vVcyxONj1vOslm3YuNgfLyF5sHn650536lByQUHrn3zGkc955njeOenPth3HsON457z/jGce/54TjuPZscx73nnsO4Xz1THce957XjuPe8dhz3nteO456c+2Hce147jnvPa8dx73ntOO49rx3Hvee1w7hvnteO497z2nHce147jnvPa8dxT879MO49rx3Hvee147j3vHYc957XjuPe89pR3MfF89px3HteO457z2vHce957Tjuybkfxr3nteO497x2HPee147j3vPaYdwH15gC3J+YgBaDK8xRzPs9K8H8+5lEMfgtO4p5v2NHMe+V40HMR68bj2Leq8YfM//Apmt0TjZdd59jM4fdx5Dr+uZUoLajzuHhL4e/TgVy5gcx71XdUcx7rjmKec81RzHvueYo5j3XHMR88lxTgPlM+5/OOT1j3nPNUcx7XjqKec9hRzFPzvwg5j2HHcW857CjmPccVpb5sjxj3nPYUcx7DjuIefIc9hzz5YuRksMb5kOm+w6fnB/n/T++h0eexY7j3vPYcdx7JjuOe3Luh3Hv2ew47j2fFeH+/ur1TY/GZ9x7RjuOe89px3HvWe0w7rPnteO497x2HPee10pwT225c7/+rTF/V3fLngPriBN5nFTE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oCFK5FFSECWvPWiIktceNETJaw8aouS1Bw1R8tqDgig1rz1oiJLXHjREyWsPGqLktQcNUSKPkoIoee1BQ5S89qAhSl570BAlrz1oiJLXHuCjRMvitQcNUfLag4Yoee1BQ5S89qAhSuRRUhAlrz1oiJLXHjREyWsPGqLktQcNUfLag4IoBa89aIiS3Xwpl+UepSW8i1KqO/GB8vL1aWqHzO8fzvXhL98i+sA8OfODmLeb14xm3m6uMpp5u/nHaObt5hSSzLf858Nlyc+Yt5snDGY+2tX+o5m3+1viaObt/j4oyny4M1+eMe857CjmyZkfxLznsKOY9xx2FPOew45i3nNYCebX+5ahdX3GvOewg5hPnsOOYt5z2FHMew47innPYUcxT878IOY9hx3FvOewo5j3HHYU857DjmLec9hBzJPnsKOY9xx2FPOew45i3nPYUcyTMz+Iec9hRzHvOewo5j2HHcW857CjmPccdhDz2XPYUcx7DjuKec9hRzHvOewo5smZH8S857CjmPccdhTznsOOYt5z2FHMew47iPniOewo5j2HHcW857CjmPccdhTz5MwPYt5z2FHMew47innX8+eYj4F2IHGt75g/MdOpup4fxbzr+VHMu54fxbzr+VHMkzMvwPyJiRPV9fwo5l3Pj2Lef5Maxbz/JjWKec9hBzG/eg4rwfyJus3qOewo5j2HHcW857CjmCdnfhDznsOOYt5z2FHMew47innPYUcx7znsIOab57CjmPccdhTznsOOYt5z2FHMkzM/iHnPYUcx7znsKOY9hx3FvOewo5j3HHYM8zeKnflBzHsOO4p5z2FHMe857CjmyZkfxLznsKOY9xx2FPOew45i3nPYUcx7DjuI+eA57CjmPYcdxbznsKOY9xx2FPPkzA9i3nPYUcx7DjuKec9hRzHvOewg5qNdPR/WfEfd+XvJ/InpHSHaVej8XNrV3PxcknPJxqVdXczPpV2l+zMu2/7hsuRnXNrVrvxc2lWj/Fza/Y2Enctk91ePH3L5dhpNSJ738HHpeQ8fl5738HFJziUbl5738HHpec85Lk/UL5PnPXxcet7Dx6XnPWxckuc9fFx63sPHpec9fFx63sPHJTmXbFx63sPHpec9fFx63sPHpec9fFx63sPGZfa8h49Lz3v4uPS8h49Lz3v4uCTnko1Lz3v4uPS8h49Lz3v4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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"other_asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"admin_npk_m_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"other_asset","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"admin_npk_m_hash","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"other_asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"admin_npk_m_hash","type":{"kind":"field"}}],"kind":"struct","path":"PrivateFPC::constructor_parameters"}}],"kind":"struct","path":"PrivateFPC::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"amount","type":{"kind":"field"}},{"name":"asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"user_randomness","type":{"kind":"field"}}],"kind":"struct","path":"PrivateFPC::fund_transaction_privately_parameters"}}],"kind":"struct","path":"PrivateFPC::fund_transaction_privately_abi"}]}},"file_map":{"112":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__INNER_NOTE_HASH,\n    hash::{\n    pedersen_hash, compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_inner_note_hash_from_preimage(storage_slot: Field, note_content_hash: Field) -> Field {\n    pedersen_hash(\n        [storage_slot, note_content_hash],\n        GENERATOR_INDEX__INNER_NOTE_HASH\n    )\n}\n\nfn compute_inner_note_hash<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    compute_inner_note_hash_from_preimage(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N, M>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let (_, inner_nullifier) = note_with_header.compute_note_hash_and_nullifier(context);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\nfn compute_note_hash_for_read_request_from_innter_and_nonce(\n    inner_note_hash: Field,\n    nonce: Field\n) -> Field {\n    // TODO(#1386): This if-else can be nuked once we have nonces injected from public\n    if (nonce == 0) {\n        // If nonce is zero, that means we are reading a public note.\n        inner_note_hash\n    } else {\n        compute_unique_note_hash(nonce, inner_note_hash)\n    }\n}\n\npub fn compute_note_hash_for_read_request<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let inner_note_hash = compute_inner_note_hash(note);\n    let nonce = note.get_header().nonce;\n\n    compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, nonce)\n}\n\npub fn compute_note_hash_for_consumption<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    if (header.note_hash_counter != 0) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        inner_note_hash\n    } else {\n        // If a note is not transient, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the siloed_note_hash which has already been hashed with\n        // nonce and then contract address. This hash will match the existing leaf in the note hash\n        // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, header.nonce);\n        compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, N, M, S>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n    let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, note_header.nonce);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        let (_, nullifier) = note.compute_note_hash_and_nullifier_without_context();\n        nullifier\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [inner_note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"122":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::{compute_siloed_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_contract_initialization_nullifier(context.this_address());\n    let header = context.get_header();\n    header.prove_nullifier_inclusion(init_nullifier);\n}\n\nfn compute_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    compute_siloed_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(address)\n    )\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"123":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr","source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"},"124":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::{address::AztecAddress, point::Point};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<M>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<M>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<M>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32\n) {}\n\nunconstrained pub fn emit_encrypted_event_log<M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<N, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<N, M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\n}\n"},"125":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"128":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n"},"130":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs_traits.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n// TODO: this is awful but since we can't have a fn that maps [Field; N] -> [u8; 480 + N * 32]\n// (where N is the note pre-image size and 480 + N * 32 is the encryption output size)\n// The fns for LensForEncryptedLog are never used, it's just to tell the compiler what the lens are\n\n// The to_bytes fn for ToBytesForUnencryptedLog is used to allow us to hash some generic T\n\n// I could have omitted N from the trait, but wanted to keep it strictly for field arrs\n// TODO(1139): Once we enc inside the circuit, we will no longer need the oracle to return\n// anything, so we can remove this trait\ntrait LensForEncryptedLog<N, M> {\n    // N = note preimage input in fields\n    // M = encryption output len in bytes (= 480 + N * 32)\n    fn output_fields(self: [Field; N]) -> [Field; N];\n    fn output_bytes(self: [Field; N]) -> [u8; M];\n}\n\nimpl LensForEncryptedLog<1, 512> for [Field; 1] {\n    fn output_fields(self) -> [Field; 1] {[self[0]; 1]}\n    fn output_bytes(self) -> [u8; 512] {[self[0] as u8; 512]}\n}\nimpl LensForEncryptedLog<2, 544> for [Field; 2] {\n    fn output_fields(self) -> [Field; 2] {[self[0]; 2]}\n    fn output_bytes(self) -> [u8; 544] {[self[0] as u8; 544]}\n}\nimpl LensForEncryptedLog<3, 576> for [Field; 3] {\n    fn output_fields(self) -> [Field; 3] {[self[0]; 3]}\n    fn output_bytes(self) -> [u8; 576] {[self[0] as u8; 576]}\n}\nimpl LensForEncryptedLog<4, 608> for [Field; 4] {\n    fn output_fields(self) -> [Field; 4] {[self[0]; 4]}\n    fn output_bytes(self) -> [u8; 608] {[self[0] as u8; 608]}\n}\nimpl LensForEncryptedLog<5, 640> for [Field; 5] {\n    fn output_fields(self) -> [Field; 5] {[self[0]; 5]}\n    fn output_bytes(self) -> [u8; 640] {[self[0] as u8; 640]}\n}\nimpl LensForEncryptedLog<6, 672> for [Field; 6] {\n    fn output_fields(self) -> [Field; 6] {[self[0]; 6]}\n    fn output_bytes(self) -> [u8; 672] {[self[0] as u8; 672]}\n}\nimpl LensForEncryptedLog<7, 704> for [Field; 7] {\n    fn output_fields(self) -> [Field; 7] {[self[0]; 7]}\n    fn output_bytes(self) -> [u8; 704] {[self[0] as u8; 704]}\n}\nimpl LensForEncryptedLog<8, 736> for [Field; 8] {\n    fn output_fields(self) -> [Field; 8] {[self[0]; 8]}\n    fn output_bytes(self) -> [u8; 736] {[self[0] as u8; 736]}\n}\nimpl LensForEncryptedLog<9, 768> for [Field; 9] {\n    fn output_fields(self) -> [Field; 9] {[self[0]; 9]}\n    fn output_bytes(self) -> [u8; 768] {[self[0] as u8; 768]}\n}\nimpl LensForEncryptedLog<10, 800> for [Field; 10] {\n    fn output_fields(self) -> [Field; 10] {[self[0]; 10]}\n    fn output_bytes(self) -> [u8; 800] {[self[0] as u8; 800]}\n}\nimpl LensForEncryptedLog<11, 832> for [Field; 11] {\n    fn output_fields(self) -> [Field; 11] {[self[0]; 11]}\n    fn output_bytes(self) -> [u8; 832] {[self[0] as u8; 832]}\n}\nimpl LensForEncryptedLog<12, 864> for [Field; 12] {\n    fn output_fields(self) -> [Field; 12] {[self[0]; 12]}\n    fn output_bytes(self) -> [u8; 864] {[self[0] as u8; 864]}\n}\n\ntrait LensForEncryptedEvent<N, M> {\n    // N = event preimage input in bytes\n    // M = encryption output len in bytes (= 480 + M)\n    fn output(self: [u8; N]) -> [u8; M];\n}\n\nimpl LensForEncryptedEvent<96, 512> for [u8; 96] {\n    fn output(self) -> [u8; 512] {[self[0] as u8; 512]}\n}\nimpl LensForEncryptedEvent<128, 544> for [u8; 128] {\n    fn output(self) -> [u8; 544] {[self[0] as u8; 544]}\n}\nimpl LensForEncryptedEvent<160, 576> for [u8; 160] {\n    fn output(self) -> [u8; 576] {[self[0] as u8; 576]}\n}\nimpl LensForEncryptedEvent<192, 608> for [u8; 192] {\n    fn output(self) -> [u8; 608] {[self[0] as u8; 608]}\n}\nimpl LensForEncryptedEvent<224, 640> for [u8; 224] {\n    fn output(self) -> [u8; 640] {[self[0] as u8; 640]}\n}\nimpl LensForEncryptedEvent<256, 672> for [u8; 256] {\n    fn output(self) -> [u8; 672] {[self[0] as u8; 672]}\n}\n\n// This trait defines the length of the inputs in bytes to\n// the unencrypted log hash fn, where the log can be any type T\n// as long as the ACVM can convert to fields.\ntrait ToBytesForUnencryptedLog<N, M> {\n    // N = preimage input in bytes (32 * num fields or chars)\n    // M = full log input in bytes ( = N + 40 = N + 32 for addr, + 4 for selector, + 4 for len)\n    fn to_be_bytes_arr(self) -> [u8; N];\n    fn output_bytes(self) -> [u8; M];\n}\n\nimpl ToBytesForUnencryptedLog<32, 68> for Field {\n    fn to_be_bytes_arr(self) -> [u8; 32] {\n        self.to_be_bytes(32).as_array()\n    }\n    fn output_bytes(self) -> [u8; 68] {[self as u8; 68]}\n}\n\nimpl ToBytesForUnencryptedLog<32, 68> for AztecAddress {\n    fn to_be_bytes_arr(self) -> [u8; 32] {\n        self.to_field().to_be_bytes(32).as_array()\n    }\n    fn output_bytes(self) -> [u8; 68] {[self.to_field() as u8; 68]}\n}\n\nfn arr_to_be_bytes_arr<N, L>(fields: [Field; L]) -> [u8; N] {\n    let mut bytes: [u8] = &[];\n    for i in 0..L {\n        // Note that bytes.append() results in bound error\n        let to_add = fields[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes = bytes.push_back(to_add[j]);\n        }\n    }\n    bytes.as_array()\n}\n\n// each character of a string is converted into a byte\n// then an ACVM field via the oracle => we recreate here\nfn str_to_be_bytes_arr<N, L>(string: str<L>) -> [u8; N] {\n    let chars_bytes = string.as_bytes();\n    let mut bytes: [u8] = &[];\n    for i in 0..L {\n        let to_add = (chars_bytes[i] as Field).to_be_bytes(32);\n        for j in 0..32 {\n            bytes = bytes.push_back(to_add[j]);\n        }\n    }\n    bytes.as_array()\n}\n\nimpl ToBytesForUnencryptedLog<32, 68> for [Field; 1] {\n    fn to_be_bytes_arr(self) -> [u8; 32] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 68] {\n        [self[0] as u8; 68]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<64, 100> for [Field; 2] {\n    fn to_be_bytes_arr(self) -> [u8; 64] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 100] {\n        [self[0] as u8; 100]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<96, 132> for [Field; 3] {\n    fn to_be_bytes_arr(self) -> [u8; 96] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 132] {\n        [self[0] as u8; 132]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<128, 164> for [Field; 4] {\n    fn to_be_bytes_arr(self) -> [u8; 128] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 164] {\n        [self[0] as u8; 164]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<160, 196> for [Field; 5] {\n    fn to_be_bytes_arr(self) -> [u8; 160] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 196] {\n        [self[0] as u8; 196]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<192, 228> for [Field; 6] {\n    fn to_be_bytes_arr(self) -> [u8; 192] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 228] {\n        [self[0] as u8; 228]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<224, 260> for [Field; 7] {\n    fn to_be_bytes_arr(self) -> [u8; 224] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 260] {\n        [self[0] as u8; 260]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<256, 292> for [Field; 8] {\n    fn to_be_bytes_arr(self) -> [u8; 256] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 292] {\n        [self[0] as u8; 292]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<288, 324> for [Field; 9] {\n    fn to_be_bytes_arr(self) -> [u8; 288] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 324] {\n        [self[0] as u8; 324]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<320, 356> for [Field; 10] {\n    fn to_be_bytes_arr(self) -> [u8; 320] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 356] {\n        [self[0] as u8; 356]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<352, 388> for [Field; 11] {\n    fn to_be_bytes_arr(self) -> [u8; 352] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 388] {\n        [self[0] as u8; 388]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<384, 420> for [Field; 12] {\n    fn to_be_bytes_arr(self) -> [u8; 384] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 420] {\n        [self[0] as u8; 420]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<416, 452> for [Field; 13] {\n    fn to_be_bytes_arr(self) -> [u8; 416] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 452] {\n        [self[0] as u8; 452]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<448, 484> for [Field; 14] {\n    fn to_be_bytes_arr(self) -> [u8; 448] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 484] {\n        [self[0] as u8; 484]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<480, 516> for [Field; 15] {\n    fn to_be_bytes_arr(self) -> [u8; 480] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 516] {\n        [self[0] as u8; 516]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<512, 548> for [Field; 16] {\n    fn to_be_bytes_arr(self) -> [u8; 512] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 548] {\n        [self[0] as u8; 548]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<544, 580> for [Field; 17] {\n    fn to_be_bytes_arr(self) -> [u8; 544] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 580] {\n        [self[0] as u8; 580]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<576, 612> for [Field; 18] {\n    fn to_be_bytes_arr(self) -> [u8; 576] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 612] {\n        [self[0] as u8; 612]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<608, 644> for [Field; 19] {\n    fn to_be_bytes_arr(self) -> [u8; 608] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 644] {\n        [self[0] as u8; 644]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<640, 676> for [Field; 20] {\n    fn to_be_bytes_arr(self) -> [u8; 640] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 676] {\n        [self[0] as u8; 676]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<672, 708> for [Field; 21] {\n    fn to_be_bytes_arr(self) -> [u8; 672] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 708] {\n        [self[0] as u8; 708]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<704, 740> for [Field; 22] {\n    fn to_be_bytes_arr(self) -> [u8; 704] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 740] {\n        [self[0] as u8; 740]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<736, 772> for [Field; 23] {\n    fn to_be_bytes_arr(self) -> [u8; 736] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 772] {\n        [self[0] as u8; 772]\n    }\n}\n\nimpl ToBytesForUnencryptedLog<768, 804> for [Field; 24] {\n    fn to_be_bytes_arr(self) -> [u8; 768] {\n        arr_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; 804] {\n        [self[0] as u8; 804]\n    }\n}\n\nimpl<N,M,L> ToBytesForUnencryptedLog<N, M> for str<L> where [Field; L]: ToBytesForUnencryptedLog<N,M> {\n    fn to_be_bytes_arr(self) -> [u8; N] {\n        str_to_be_bytes_arr(self)\n    }\n    fn output_bytes(self) -> [u8; M] {\n        [0; M]\n    }\n}\n"},"135":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n"},"139":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"149":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr","source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext}, oracle::storage::storage_read,\n    state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PublicContext> {\n    // Intended to be only called once. \n    pub fn initialize<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T> SharedImmutable<T, UnconstrainedContext> {\n    unconstrained pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PrivateContext> {\n    pub fn read_private<T_SERIALIZED_LEN>(self) -> T  where T: Deserialize<T_SERIALIZED_LEN> {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n"},"167":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{GAS_LENGTH, FIXED_DA_GAS, FIXED_L2_GAS}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\n    abis::gas_fees::GasFees\n};\nuse std::ops::{Add, Sub};\n\nstruct Gas {\n    da_gas: u32,\n    l2_gas: u32,\n}\n\nimpl Gas {\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\n        Self { da_gas, l2_gas }\n    }\n\n    pub fn tx_overhead() -> Self {\n        Self { da_gas: FIXED_DA_GAS, l2_gas: FIXED_L2_GAS }\n    }\n\n    pub fn compute_fee(self, fees: GasFees) -> Field {\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.da_gas == 0) & (self.l2_gas == 0)\n    }\n\n    pub fn within(self, limits: Gas) -> bool {\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\n    }\n}\n\nimpl Add for Gas {\n    fn add(self, other: Gas) -> Self {\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\n    }\n}\n\nimpl Sub for Gas {\n    fn sub(self, other: Gas) -> Self {\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\n    }\n}\n\nimpl Serialize<GAS_LENGTH> for Gas {\n    fn serialize(self) -> [Field; GAS_LENGTH] {\n        [self.da_gas as Field, self.l2_gas as Field]\n    }\n}\n\nimpl Deserialize<GAS_LENGTH> for Gas {\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\n    }\n}\n\nimpl Eq for Gas {\n    fn eq(self, other : Gas) -> bool {\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\n    }\n}\n\nimpl Empty for Gas {\n    fn empty() -> Self {\n        Gas::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Gas::empty();\n    let serialized = item.serialize();\n    let deserialized = Gas::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n"},"169":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr","source":"use crate::{\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct NoteHash {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for NoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteHash {\n    fn eq(self, other: NoteHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter) \n    }\n}\n\nimpl Empty for NoteHash {\n    fn empty() -> Self {\n        NoteHash {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl NoteHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNoteHash {\n        ScopedNoteHash { note_hash: self, contract_address }\n    }\n}\n\nstruct ScopedNoteHash {\n    note_hash: NoteHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<NoteHash> for ScopedNoteHash {\n    fn inner(self) -> NoteHash {\n        self.note_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNoteHash {\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNoteHash {\n    fn value(self) -> Field {\n        self.note_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl Eq for ScopedNoteHash {\n    fn eq(self, other: ScopedNoteHash) -> bool {\n        (self.note_hash == other.note_hash)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedNoteHash {\n    fn empty() -> Self {\n        ScopedNoteHash {\n            note_hash: NoteHash::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\n        array_concat(self.note_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            note_hash: reader.read_struct(NoteHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNoteHash {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.note_hash.value, read_request.value(), \"Value of the note hash does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the note hash does not match read request\");\n        assert(\n            read_request.counter() > self.note_hash.counter, \"Read request counter must be greater than the counter of the note hash\"\n        );\n    }\n}\n\nimpl ScopedNoteHash {\n    pub fn expose_to_public(self) -> NoteHash {\n        // Hide the actual counter when exposing it to the public kernel.\n        NoteHash { value: self.note_hash.value, counter: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = NoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"170":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"172":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr","source":"use crate::{\n    abis::{\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    transaction::tx_context::TxContext, utils::arrays::validate_array\n};\n\nstruct PrivateCircuitPublicInputsArrayLengths {\n    note_hash_read_requests: u32,\n    nullifier_read_requests: u32,\n    key_validation_requests_and_generators: u32,\n    note_hashes: u32,\n    nullifiers: u32,\n    l2_to_l1_msgs: u32,\n    private_call_requests: u32,\n    public_call_stack_hashes: u32,\n    note_encrypted_logs_hashes: u32,\n    encrypted_logs_hashes: u32,\n    unencrypted_logs_hashes: u32,\n}\n\nimpl PrivateCircuitPublicInputsArrayLengths {\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\n        PrivateCircuitPublicInputsArrayLengths {\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\n            note_hashes: validate_array(public_inputs.note_hashes),\n            nullifiers: validate_array(public_inputs.nullifiers),\n            l2_to_l1_msgs: validate_array(public_inputs.l2_to_l1_msgs),\n            private_call_requests: validate_array(public_inputs.private_call_requests),\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\n        }\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    note_hashes: [NoteHash; MAX_NOTE_HASHES_PER_CALL],\n    nullifiers: [Nullifier; MAX_NULLIFIERS_PER_CALL],\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs: [L2ToL1Message; MAX_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    tx_context: TxContext,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.returns_hash == other.returns_hash) &\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\n        (self.is_fee_payer == other.is_fee_payer) &\n        (self.max_block_number == other.max_block_number) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\n        (self.note_hashes == other.note_hashes) &\n        (self.nullifiers == other.nullifiers) &\n        (self.private_call_requests == other.private_call_requests) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.l2_to_l1_msgs == other.l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\n        self.historical_header.eq(other.historical_header) &\n        self.tx_context.eq(other.tx_context)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\n\n        fields.extend_from_array(self.max_block_number.serialize());\n\n        for i in 0..self.note_hash_read_requests.len() {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..self.nullifier_read_requests.len() {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..self.key_validation_requests_and_generators.len() {\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\n        }\n        for i in 0..self.note_hashes.len() {\n            fields.extend_from_array(self.note_hashes[i].serialize());\n        }\n        for i in 0..self.nullifiers.len() {\n            fields.extend_from_array(self.nullifiers[i].serialize());\n        }\n        for i in 0..self.private_call_requests.len() {\n            fields.extend_from_array(self.private_call_requests[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n        fields.push(self.public_teardown_function_hash);\n        for i in 0..self.l2_to_l1_msgs.len() {\n            fields.extend_from_array(self.l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        for i in 0..self.note_encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.unencrypted_logs_hashes.len() {\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.tx_context.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            is_fee_payer: reader.read() == 1,\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL]),\n            nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL]),\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            public_teardown_function_hash: reader.read(),\n            l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            tx_context: reader.read_struct(TxContext::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PrivateCircuitPublicInputs {\n    fn empty() -> Self {\n        PrivateCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter : 0 as u32,\n            end_side_effect_counter : 0 as u32,\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            tx_context: TxContext::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PrivateCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PrivateCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x15c9b0a92b9b541598e24c9f0b0b4b04b7f2408599751c45aa12de671fd9b363;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"175":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n"},"176":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr","source":"use crate::{\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for ReadRequest {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\n        ScopedReadRequest { read_request: self, contract_address }\n    }\n}\n\nstruct ScopedReadRequest {\n    read_request: ReadRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<ReadRequest> for ScopedReadRequest {\n    fn inner(self) -> ReadRequest {\n        self.read_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ScopedReadRequest {\n    fn eq(self, other: ScopedReadRequest) -> bool {\n        (self.read_request == other.read_request)\n        & (self.contract_address.eq(other.contract_address))\n    }\n}\n\nimpl Empty for ScopedReadRequest {\n    fn empty() -> Self {\n        ScopedReadRequest {\n            read_request: ReadRequest::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            read_request: reader.read_struct(ReadRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedReadRequest {\n    pub fn value(self) -> Field {\n        self.read_request.value\n    }\n    pub fn counter(self) -> u32 {\n        self.read_request.counter\n    }\n}\n\n#[test]\nfn serialization_of_empty_read() {\n    let item = ReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"179":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr","source":"use crate::{\n    address::AztecAddress,\n    abis::validation_requests::{\n    key_validation_request::KeyValidationRequest,\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\n},\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct KeyValidationRequestAndGenerator {\n    request: KeyValidationRequest,\n    sk_app_generator: Field,\n}\n\nimpl Eq for KeyValidationRequestAndGenerator {\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\n    }\n}\n\nimpl Empty for KeyValidationRequestAndGenerator {\n    fn empty() -> Self {\n        KeyValidationRequestAndGenerator {\n            request: KeyValidationRequest::empty(),\n            sk_app_generator: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\n        array_concat(self.request.serialize(), [self.sk_app_generator])\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\n        let mut reader = Reader::new(fields);\n        let res = Self {\n            request: reader.read_struct(KeyValidationRequest::deserialize),\n            sk_app_generator: reader.read(),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl KeyValidationRequestAndGenerator {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = KeyValidationRequestAndGenerator::empty();\n    let serialized = item.serialize();\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"180":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point::new(fields[0], fields[1], fields[2] as bool),\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"184":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr","source":"use crate::{\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH},\n    hash::compute_siloed_nullifier, traits::{Empty, Hash, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct Nullifier {\n    value: Field,\n    counter: u32,\n    note_hash: Field,\n}\n\nimpl Ordered for Nullifier {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for Nullifier {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for Nullifier {\n    fn eq(self, other: Nullifier) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.note_hash == other.note_hash) \n    }\n}\n\nimpl Empty for Nullifier {\n    fn empty() -> Self {\n        Nullifier {\n            value: 0,\n            counter: 0,\n            note_hash: 0,\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\n        [self.value, self.counter as Field, self.note_hash]\n    }\n}\n\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            note_hash: values[2],\n        }\n    }\n}\n\nimpl Readable for Nullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        // Public kernels output Nullifier instead of ScopedNullifier.\n        // The nullifier value has been siloed.\n        let siloed_request_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.value, siloed_request_value, \"Value of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl Nullifier {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\n        ScopedNullifier { nullifier: self, contract_address }\n    }\n}\n\nstruct ScopedNullifier {\n    nullifier: Nullifier,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<Nullifier> for ScopedNullifier {\n    fn inner(self) -> Nullifier {\n        self.nullifier\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNullifier {\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNullifier {\n    fn value(self) -> Field {\n        self.nullifier.value\n    }\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl Eq for ScopedNullifier {\n    fn eq(self, other: ScopedNullifier) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedNullifier {\n    fn empty() -> Self {\n        ScopedNullifier {\n            nullifier: Nullifier::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            nullifier: reader.read_struct(Nullifier::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.nullifier.value, read_request.value(), \"Value of the nullifier does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.nullifier.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl ScopedNullifier {\n    pub fn nullified_note_hash(self) -> Field {\n        self.nullifier.note_hash\n    }\n\n    pub fn expose_to_public(self) -> Nullifier {\n        // Hide the actual counter and note hash when exposing it to the public kernel.\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Nullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = Nullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"192":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr","source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n  fn eq(self, other: Self) -> bool {\n    (self.nullifier == other.nullifier) &\n    (self.next_nullifier == other.next_nullifier) &\n    (self.next_index == other.next_index)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"193":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"194":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr","source":"use crate::{\n    abis::{\n    private_call_stack_item::PrivateCallStackItem, call_context::CallContext,\n    function_data::FunctionData, caller_context::CallerContext,\n    side_effect::{Ordered, RangeOrdered, Scoped}\n},\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PrivateCallRequest {\n    target: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Ordered for PrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.start_side_effect_counter\n    }\n}\n\nimpl RangeOrdered for PrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.start_side_effect_counter\n    }\n    fn counter_end(self) -> u32 {\n        self.end_side_effect_counter\n    }\n}\n\nimpl Eq for PrivateCallRequest {\n    fn eq(self, other: PrivateCallRequest) -> bool {\n        (self.target == other.target) \n            & (self.call_context == other.call_context) \n            & (self.function_data == other.function_data) \n            & (self.args_hash == other.args_hash) \n            & (self.returns_hash == other.returns_hash)\n            & (self.caller_context == other.caller_context)\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\n    }\n}\n\nimpl Empty for PrivateCallRequest {\n    fn empty() -> Self {\n        PrivateCallRequest {\n            target: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.push(self.target.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.extend_from_array(self.caller_context.serialize());\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = PrivateCallRequest {\n            target: reader.read_struct(AztecAddress::deserialize),\n            call_context: reader.read_struct(CallContext::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            caller_context: reader.read_struct(CallerContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            end_side_effect_counter: reader.read_u32(),\n        };\n        reader.finish();\n        item\n    }\n}\n\nimpl PrivateCallRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\n        ScopedPrivateCallRequest { call_request: self, contract_address }\n    }\n\n    pub fn matches_stack_item(self, stack_item: PrivateCallStackItem) -> bool {\n        (self.target == stack_item.contract_address)\n            & (self.call_context == stack_item.public_inputs.call_context)\n            & (self.function_data == stack_item.function_data)\n            & (self.args_hash == stack_item.public_inputs.args_hash)\n            & (self.returns_hash == stack_item.public_inputs.returns_hash)\n            & (self.start_side_effect_counter\n                                == stack_item.public_inputs.start_side_effect_counter)\n            & (self.end_side_effect_counter\n                                    == stack_item.public_inputs.end_side_effect_counter)\n    }\n}\n\nstruct ScopedPrivateCallRequest {\n    call_request: PrivateCallRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\n    fn inner(self) -> PrivateCallRequest {\n        self.call_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedPrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.call_request.counter_start()\n    }\n}\n\nimpl RangeOrdered for ScopedPrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.call_request.counter_start()\n    }\n    fn counter_end(self) -> u32 {\n        self.call_request.counter_end()\n    }\n}\n\nimpl Eq for ScopedPrivateCallRequest {\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\n        (self.call_request == other.call_request)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedPrivateCallRequest {\n    fn empty() -> Self {\n        ScopedPrivateCallRequest {\n            call_request: PrivateCallRequest::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.call_request.serialize());\n        fields.extend_from_array(self.contract_address.serialize());\n\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = ScopedPrivateCallRequest {\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        item\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = ScopedPrivateCallRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"199":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\n    abis::gas_fees::GasFees,\n    constants::{\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\n    DEFAULT_INCLUSION_FEE\n},\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    utils::reader::Reader\n};\n\nstruct GasSettings {\n    gas_limits: Gas,\n    teardown_gas_limits: Gas,\n    max_fees_per_gas: GasFees,\n    inclusion_fee: Field,\n}\n\nimpl GasSettings {\n    pub fn new(\n        gas_limits: Gas,\n        teardown_gas_limits: Gas,\n        max_fees_per_gas: GasFees,\n        inclusion_fee: Field\n    ) -> Self {\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\n    }\n\n    pub fn default() -> Self {\n        GasSettings::new(\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\n            DEFAULT_INCLUSION_FEE\n        )\n    }\n}\n\nimpl Eq for GasSettings {\n    fn eq(self, other: Self) -> bool {\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\n    }\n}\n\nimpl Empty for GasSettings {\n    fn empty() -> Self {\n        GasSettings::new(\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\n        )\n    }\n}\n\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\n\n        serialized.extend_from_array(self.gas_limits.serialize());\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\n        serialized.push(self.inclusion_fee);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\n        let mut reader = Reader::new(serialized);\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasSettings::empty();\n    let serialized = item.serialize();\n    let deserialized = GasSettings::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"208":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr","source":"use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PrivateCallStackItem {\n    fn empty() -> Self {\n        PrivateCallStackItem {\n            contract_address: AztecAddress::empty(),\n            function_data: FunctionData::empty(),\n            public_inputs: PrivateCircuitPublicInputs::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = PrivateCallStackItem::empty();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item = PrivateCallStackItem::empty();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x065f2831db9ac0db5e710bd3a865b5facd8cf83f1585e1af8fd1d6ce9c47f685;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr","source":"use crate::address::AztecAddress;\nuse crate::traits::{Empty, Serialize, Deserialize};\nuse crate::constants::CALLER_CONTEXT_LENGTH;\nuse crate::utils::reader::Reader;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n    is_static_call: bool,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, other: CallerContext) -> bool {\n        other.msg_sender.eq(self.msg_sender)\n            & other.storage_contract_address.eq(self.storage_contract_address)\n            & other.is_static_call == self.is_static_call\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n            is_static_call: false,\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\n    }\n\n    // Different to an empty context, a hidden context won't reveal the caller's msg_sender and storage_contract_address,\n    // but will still propagate the is_static_call flag.\n    pub fn is_hidden(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array(self.msg_sender.serialize());\n    fields.extend_from_array(self.storage_contract_address.serialize());\n    fields.push(self.is_static_call as Field);\n\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\n    let mut reader = Reader::new(fields);\n\n    let item = CallerContext {\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\n      is_static_call: reader.read_bool(),\n    };\n    reader.finish();\n    item\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = CallerContext::empty();\n    let serialized = item.serialize();\n    let deserialized = CallerContext::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"211":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr","source":"use crate::{\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\n    constants::{\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\n},\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct LogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n}\n\nimpl Ordered for LogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for LogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for LogHash {\n    fn eq(self, other: LogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n    }\n}\n\nimpl Empty for LogHash {\n    fn empty() -> Self {\n        LogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n        }\n    }\n}\n\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length]\n    }\n}\n\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n        }\n    }\n}\n\nimpl LogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\n        ScopedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedLogHash {\n    log_hash: LogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<LogHash> for ScopedLogHash {\n    fn inner(self) -> LogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedLogHash {\n    fn eq(self, other: ScopedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedLogHash {\n    fn empty() -> Self {\n        ScopedLogHash {\n            log_hash: LogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(LogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the counter when exposing to public.\n        // The log hash must already be siloed when we call this.\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nstruct EncryptedLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    randomness: Field,\n}\n\nimpl Ordered for EncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for EncryptedLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for EncryptedLogHash {\n    fn eq(self, other: EncryptedLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.randomness == other.randomness) \n    }\n}\n\nimpl Empty for EncryptedLogHash {\n    fn empty() -> Self {\n        EncryptedLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            randomness: 0,\n        }\n    }\n}\n\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.randomness]\n    }\n}\n\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            randomness: values[3],\n        }\n    }\n}\n\nimpl EncryptedLogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedEncryptedLogHash {\n    log_hash: EncryptedLogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\n    fn inner(self) -> EncryptedLogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl ScopedEncryptedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the secret randomness and counter when exposing to public\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\n        // The log hash will already be silo'd when we call this\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nimpl Ordered for ScopedEncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedEncryptedLogHash {\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedEncryptedLogHash {\n    fn empty() -> Self {\n        ScopedEncryptedLogHash {\n            log_hash: EncryptedLogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct NoteLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    note_hash_counter: u32,\n}\n\nimpl NoteLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\n        LogHash { value: self.value, counter: 0, length: self.length }\n    }\n}\n\nimpl Ordered for NoteLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for NoteLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteLogHash {\n    fn eq(self, other: NoteLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.note_hash_counter == other.note_hash_counter) \n    }\n}\n\nimpl Empty for NoteLogHash {\n    fn empty() -> Self {\n        NoteLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            note_hash_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            note_hash_counter: values[3] as u32,\n        }\n    }\n}\n"},"215":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr","source":"struct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n"},"216":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n}\n// docs:end:call-context\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n"},"217":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"22":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"220":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize, Empty}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        (self.is_private == other.is_private)\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nimpl Empty for FunctionData {\n    fn empty() -> Self {\n        FunctionData {\n            selector: FunctionSelector::empty(),\n            is_private: false\n        }\n    }\n\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data = FunctionData::empty();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data = FunctionData::empty();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty function data hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"227":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n    counter: u32,\n}\n\nimpl Ordered for L2ToL1Message {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content, self.counter as Field]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\nimpl L2ToL1Message {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\n        ScopedL2ToL1Message { message: self, contract_address }\n    }\n}\n\nstruct ScopedL2ToL1Message {\n    message: L2ToL1Message,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\n    fn inner(self) -> L2ToL1Message {\n        self.message\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedL2ToL1Message {\n    fn counter(self) -> u32 {\n        self.message.counter\n    }\n}\n\nimpl Eq for ScopedL2ToL1Message {\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\n        (self.message == other.message)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedL2ToL1Message {\n    fn empty() -> Self {\n        ScopedL2ToL1Message {\n            message: L2ToL1Message::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            message: reader.read_struct(L2ToL1Message::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\n#[test]\nfn serialization_of_empty_l2() {\n    let item = L2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = L2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped_l2() {\n    let item = ScopedL2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"235":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<N> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<N> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<N> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<N> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"236":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"// Utility function to console.log data in the acir simulator\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<M, N>(_msg: str<M>, args: [Field]) {}\n\n/// NOTE: call this with a str<N> msg of form\n/// \"some string with {0} and {1} ... {N}\"\n/// and an array of N field which will be formatted\n/// into the string in the simulator.\n/// Example:\n/// debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n/// debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\nunconstrained pub fn debug_log_format<M, N>(msg: str<M>, args: [Field; N]) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n/// NOTE: call this with a str<N> msg of length > 1\n/// Example:\n/// `debug_log(\"blah blah this is a debug string\");`\nunconstrained pub fn debug_log<N>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n"},"237":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr","source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  num_txs: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.num_txs);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let num_txs = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      num_txs,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      num_txs: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.num_txs == other.num_txs)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n"},"238":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"239":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr","source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"241":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n"},"243":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr","source":"use crate::{\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    abis::gas_settings::GasSettings\n};\n\n// docs:start:tx-context\nstruct TxContext {\n    chain_id : Field,\n    version : Field,\n    gas_settings: GasSettings,\n}\n// docs:end:tx-context\n\nimpl TxContext {\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\n        TxContext { chain_id, version, gas_settings }\n    }\n}\n\nimpl Eq for TxContext {\n    fn eq(self, other: Self) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.gas_settings.eq(other.gas_settings))\n    }\n}\n\nimpl Empty for TxContext {\n    fn empty() -> Self {\n        TxContext {\n            chain_id: 0,\n            version: 0,\n            gas_settings: GasSettings::empty(),\n        }\n    }\n}\n\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\n\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.extend_from_array(self.gas_settings.serialize());\n\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let context = Self {\n            chain_id: reader.read(),\n            version: reader.read(),\n            gas_settings: reader.read_struct(GasSettings::deserialize),\n        };\n\n        reader.finish();\n        context\n    }\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context = TxContext::empty();\n    let serialized = context.serialize();\n    let deserialized = TxContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let context = TxContext::empty();\n    let hash = context.hash();\n\n    // Value from tx_context.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"247":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"249":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n"},"25":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n#[no_predicates]\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    let value = pedersen_commitment_with_separator(input, 0);\n    if (value.x == 0) & (value.y == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value.x, y: value.y, is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        points[i] = EmbeddedCurveScalar::from_field(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let values = multi_scalar_mul(generators, points);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: values[2] as bool }\n}\n\n#[no_predicates]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let v1 = pedersen_commitment_with_separator(input, separator);\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    multi_scalar_mul(\n        [length_generator[0], v1],\n        [EmbeddedCurveScalar { lo: N as Field, hi: 0 }, EmbeddedCurveScalar { lo: 1, hi: 0 }]\n    )[0]\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n#[test]\nfn assert_pedersen_noir() {\n    // TODO: make this a fuzzer test once fuzzer supports curve-specific blackbox functions.\n    let input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq(pedersen_hash_with_separator(input, 4), pedersen_hash_with_separator_noir(input, 4));\n    assert_eq(pedersen_commitment_with_separator(input, 4), pedersen_commitment_with_separator_noir(input, 4));\n}\n"},"263":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"273":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"289":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"32":{"path":"std/merkle.nr","source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n"},"372":{"path":"/usr/src/noir-projects/noir-contracts/contracts/private_fpc_contract/src/main.nr","source":"mod lib;\n\ncontract PrivateFPC {\n    use dep::aztec::protocol_types::{abis::log_hash::LogHash, address::AztecAddress, hash::poseidon2_hash};\n    use dep::aztec::state_vars::SharedImmutable;\n    use dep::private_token::PrivateToken;\n    use crate::lib::emit_randomness_as_unencrypted_log;\n\n    #[aztec(storage)]\n    struct Storage {\n        other_asset: SharedImmutable<AztecAddress>,\n        admin_npk_m_hash: SharedImmutable<Field>\n    }\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(other_asset: AztecAddress, admin_npk_m_hash: Field) {\n        storage.other_asset.initialize(other_asset);\n        storage.admin_npk_m_hash.initialize(admin_npk_m_hash);\n    }\n\n    #[aztec(private)]\n    fn fund_transaction_privately(amount: Field, asset: AztecAddress, user_randomness: Field) {\n        assert(asset == storage.other_asset.read_private());\n        // convince the FPC we are not cheating\n        context.push_nullifier(user_randomness, 0);\n\n        // We use different randomness for fee payer to prevent a potential privay leak (see impl\n        // of PrivatelyRefundable for TokenNote for details).\n        let fee_payer_randomness = poseidon2_hash([user_randomness]);\n        // We emit fee payer randomness to ensure FPC admin can reconstruct their fee note\n        emit_randomness_as_unencrypted_log(&mut context, fee_payer_randomness);\n\n        PrivateToken::at(asset).setup_refund(\n            storage.admin_npk_m_hash.read_private(),\n            context.msg_sender(),\n            amount,\n            user_randomness,\n            fee_payer_randomness\n        ).call(&mut context);\n        context.set_as_fee_payer();\n    }\n}\n"},"373":{"path":"/usr/src/noir-projects/noir-contracts/contracts/private_fpc_contract/src/lib.nr","source":"use dep::aztec::protocol_types::abis::log_hash::LogHash;\nuse dep::aztec::oracle::logs::emit_unencrypted_log_private_internal;\nuse dep::aztec::hash::compute_unencrypted_log_hash;\nuse dep::aztec::context::PrivateContext;\n\nfn emit_randomness_as_unencrypted_log(context: &mut PrivateContext, randomness: Field) {\n    let counter = context.next_counter();\n    let log_slice = randomness.to_be_bytes_arr();\n    let log_hash = compute_unencrypted_log_hash(context.this_address(), randomness);\n    // 40 = addr (32) + raw log len (4) + processed log len (4)\n    let len = 40 + log_slice.len().to_field();\n    let side_effect = LogHash { value: log_hash, counter, length: len };\n    context.unencrypted_logs_hashes.push(side_effect);\n    let _void = emit_unencrypted_log_private_internal(context.this_address(), randomness, counter);\n}\n"},"374":{"path":"/usr/src/noir-projects/noir-contracts/contracts/private_token_contract/src/main.nr","source":"mod types;\nmod test;\n\n// Minimal token implementation that supports `AuthWit` accounts and private refunds\n\ncontract PrivateToken {\n    use dep::compressed_string::FieldCompressedString;\n    use dep::aztec::{\n        note::utils::compute_inner_note_hash_from_preimage, hash::compute_secret_hash,\n        prelude::{NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress},\n        protocol_types::{abis::function_selector::FunctionSelector, point::Point, hash::pedersen_hash},\n        oracle::unsafe_rand::unsafe_rand,\n        encrypted_logs::encrypted_note_emission::{encode_and_encrypt_note, encode_and_encrypt_note_with_keys}\n    };\n    use dep::authwit::{auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public}};\n    use crate::types::{token_note::{TokenNote, TOKEN_NOTE_LEN}, balances_map::BalancesMap};\n\n    #[aztec(storage)]\n    struct Storage {\n        admin: PublicMutable<AztecAddress>,\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        balances: BalancesMap<TokenNote>,\n        total_supply: PublicMutable<U128>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        decimals: SharedImmutable<u8>,\n    }\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        storage.decimals.initialize(decimals);\n    }\n\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        storage.admin.write(new_admin);\n    }\n\n    #[aztec(public)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    unconstrained fn un_get_name() -> pub [u8; 31] {\n        storage.name.read_public().to_bytes()\n    }\n\n    #[aztec(public)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    unconstrained fn un_get_symbol() -> pub [u8; 31] {\n        storage.symbol.read_public().to_bytes()\n    }\n\n    #[aztec(public)]\n    fn public_get_decimals() -> pub u8 {\n        storage.decimals.read_public()\n    }\n\n    #[aztec(private)]\n    fn private_get_decimals() -> pub u8 {\n        storage.decimals.read_private()\n    }\n\n    unconstrained fn un_get_decimals() -> pub u8 {\n        storage.decimals.read_public()\n    }\n\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        storage.minters.at(minter).write(approve);\n    }\n\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        let header = context.get_header();\n        let caller_npk_m_hash = header.get_npk_m_hash(&mut context, caller);\n        storage.balances.add(caller_npk_m_hash, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, caller, caller));\n        PrivateToken::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    #[aztec(private)]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let from_npk_m_hash = header.get_npk_m_hash(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n        let to_npk_m_hash = header.get_npk_m_hash(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        storage.balances.sub(from_npk_m_hash, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, from_ivpk));\n        storage.balances.add(to_npk_m_hash, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, to_ivpk));\n    }\n\n    #[aztec(private)]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let from_npk_m_hash = header.get_npk_m_hash(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n        let to_npk_m_hash = header.get_npk_m_hash(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        storage.balances.sub(from_npk_m_hash, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, from_ivpk));\n        storage.balances.add(to_npk_m_hash, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, to_ivpk));\n    }\n\n    #[aztec(private)]\n    fn balance_of_private(owner: AztecAddress) -> pub Field {\n        let header = context.get_header();\n        let owner_npk_m_hash = header.get_npk_m_hash(&mut context, owner);\n        storage.balances.to_unconstrained().balance_of(owner_npk_m_hash).to_integer()\n    }\n\n    unconstrained fn balance_of_unconstrained(owner_npk_m_hash: Field) -> pub Field {\n        storage.balances.balance_of(owner_npk_m_hash).to_integer()\n    }\n\n    #[aztec(private)]\n    fn setup_refund(\n        fee_payer_npk_m_hash: Field, // NpkMHash of the entity which will receive the fee note.\n        user: AztecAddress, // A user for which we are setting up the fee refund.\n        funded_amount: Field, // The amount the user funded the fee payer with (represents fee limit).\n        user_randomness: Field, // A randomness to mix in with the generated refund note for the sponsored user.\n        fee_payer_randomness: Field // A randomness to mix in with the generated fee note for the fee payer.\n    ) {\n        // 1. This function is called by fee paying contract (fee_payer) when setting up a refund so we need to support\n        // the authwit flow here and check that the user really permitted fee_payer to set up a refund on their behalf.\n        assert_current_call_valid_authwit(&mut context, user);\n\n        // 2. Get all the relevant user keys\n        let header = context.get_header();\n        let user_npk_m_hash = header.get_npk_m_hash(&mut context, user);\n        let user_ovpk = header.get_ovpk_m(&mut context, user);\n        let user_ivpk = header.get_ivpk_m(&mut context, user);\n\n        // 3. Deduct the funded amount from the user's balance - this is a maximum fee a user is willing to pay\n        // (called fee limit in aztec spec). The difference between fee limit and the actual tx fee will be refunded \n        // to the user in the `complete_refund(...)` function.\n        // TODO(#7324): using npk_m_hash here does not work with key rotation\n        storage.balances.sub(user_npk_m_hash, U128::from_integer(funded_amount)).emit(encode_and_encrypt_note_with_keys(&mut context, user_ovpk, user_ivpk));\n\n        // 4. We generate the refund points.\n        let (fee_payer_point, user_point) = TokenNote::generate_refund_points(\n            fee_payer_npk_m_hash,\n            user_npk_m_hash,\n            funded_amount,\n            user_randomness,\n            fee_payer_randomness\n        );\n\n        // 5. Set the public teardown function to `complete_refund(...)`. Public teardown is the only time when a public\n        // function has access to the final transaction fee, which is needed to compute the actual refund amount.\n        context.set_public_teardown_function(\n            context.this_address(),\n            FunctionSelector::from_signature(\"complete_refund(Field,Field,Field,Field)\"),\n            [fee_payer_point.x, fee_payer_point.y, user_point.x, user_point.y]\n        );\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn complete_refund(\n        fee_payer_point_x: Field,\n        fee_payer_point_y: Field,\n        user_point_x: Field,\n        user_point_y: Field\n    ) {\n        // 1. We get the final note content hashes by calling the `complete_refund` on the note.\n        let fee_payer_point = Point { x: fee_payer_point_x, y: fee_payer_point_y, is_infinite: false };\n        let user_point = Point { x: user_point_x, y: user_point_y, is_infinite: false };\n        let tx_fee = context.transaction_fee();\n        let (fee_payer_note_content_hash, user_note_content_hash) = TokenNote::complete_refund(fee_payer_point, user_point, tx_fee);\n\n        // 2. Now we \"manually\" compute the inner note hashes.\n        let fee_payer_inner_note_hash = compute_inner_note_hash_from_preimage(\n            PrivateToken::storage().balances.slot,\n            fee_payer_note_content_hash\n        );\n        let user_inner_note_hash = compute_inner_note_hash_from_preimage(PrivateToken::storage().balances.slot, user_note_content_hash);\n\n        // 3. At last we emit the note hashes.\n        context.push_note_hash(fee_payer_inner_note_hash);\n        context.push_note_hash(user_inner_note_hash);\n        // --> Once the tx is settled user and fee recipient can add the notes to their pixies.\n    }\n\n    /// Internal ///\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n\n    /// Unconstrained ///\n\n    unconstrained fn admin() -> pub Field {\n        storage.admin.read().to_field()\n    }\n\n    unconstrained fn is_minter(minter: AztecAddress) -> pub bool {\n        storage.minters.at(minter).read()\n    }\n\n    unconstrained fn total_supply() -> pub Field {\n        storage.total_supply.read().to_integer()\n    }\n}\n"},"379":{"path":"/usr/src/noir-projects/noir-contracts/contracts/private_token_contract/src/types/token_note.nr","source":"use dep::aztec::{\n    prelude::{AztecAddress, NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, point::Point, scalar::Scalar, hash::poseidon2_hash},\n    note::utils::compute_note_hash_for_consumption, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app, note::note_getter_options::PropertySelector\n};\nuse dep::std::field::bn254::decompose;\nuse dep::std::embedded_curve_ops::multi_scalar_mul;\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n    fn get_owner_npk_m_hash(self) -> Field;\n    fn get_owner_selector() -> PropertySelector;\n}\n\ntrait PrivatelyRefundable {\n    fn generate_refund_points(\n        fee_payer_npk_m_hash: Field,\n        user_npk_m_hash: Field,\n        funded_amount: Field,\n        user_randomness: Field,\n        fee_payer_randomness: Field\n    ) -> (Point, Point);\n\n    fn complete_refund(\n        incomplete_fee_payer_point: Point,\n        incomplete_user_point: Point,\n        transaction_fee: Field\n    ) -> (Field, Field);\n}\n\nglobal TOKEN_NOTE_LEN: Field = 3; // 3 plus a header.\nglobal TOKEN_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n// Grumpkin generator point. \nglobal G1 = Point { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n\n#[aztec(note)]\nstruct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NoteInterface<TOKEN_NOTE_LEN, TOKEN_NOTE_BYTES_LEN> for TokenNote {\n    // docs:start:nullifier\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> ( Field, Field ) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> ( Field, Field ) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n\n\n\n    fn compute_note_content_hash(self) -> Field {\n        let (npk_lo, npk_hi) = decompose(self.npk_m_hash);\n        let (random_lo, random_hi) = decompose(self.randomness);\n        // We compute the note content hash as an x-coordinate of `G ^ (amount + npk_m_hash + randomness)` instead\n        // of using pedersen or poseidon2 because it allows us to privately add and subtract from amount in public\n        // by leveraging homomorphism.\n        multi_scalar_mul(\n            [G1, G1, G1],\n            [Scalar {\n                lo: self.amount.to_integer(),\n                hi: 0\n            },\n            Scalar {\n                lo: npk_lo,\n                hi: npk_hi\n            },\n            Scalar {\n                lo: random_lo,\n                hi: random_hi,\n            }]\n        )[0]\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self {\n            amount,\n            npk_m_hash: owner_npk_m_hash,\n            randomness: unsafe_rand(),\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n\n    fn get_owner_npk_m_hash(self) -> Field {\n        self.npk_m_hash\n    }\n\n    fn get_owner_selector() -> PropertySelector {\n        PropertySelector { index: 1, offset: 0, length: 32 }\n    }\n}\n\n/**\n * What is happening below?\n *\n * First in generate_refund_points, we create two points on the grumpkin curve;\n * these are going to be eventually turned into notes:\n * one for the user, and one for the fee payer.\n *\n * So you can think of these (x,y) points as \"partial notes\": they encode part of the internals of the notes.\n *\n * This is because the compute_note_content_hash function above defines the content hash to be\n * the x-coordinate of a point defined as:\n *\n * amount * G + npk * G + randomness * G\n *   = (amount + npk + randomness) * G\n * \n * where G is a generator point. Interesting point here is that we actually need to convert\n * - amount\n * - npk\n * - randomness\n * from grumpkin Field elements\n * (which have a modulus of 21888242871839275222246405745257275088548364400416034343698204186575808495617)\n * into a grumpkin scalar\n * (which have a modulus of 21888242871839275222246405745257275088696311157297823662689037894645226208583)\n *\n * The intuition for this is that the Field elements define the domain of the x,y coordinates for points on the curves,\n * but the number of points on the curve is actually greater than the size of that domain.\n *\n * (Consider, e.g. if the curve were defined over a field of 10 elements, and each x coord had two corresponding y for +/-)\n *\n * For a bit more info, see\n * https://hackmd.io/@aztec-network/ByzgNxBfd#2-Grumpkin---A-curve-on-top-of-BN-254-for-SNARK-efficient-group-operations\n *\n *\n * Anyway, if we have a secret scalar n := amount + npk + randomness, and then we reveal a point n * G, there is no efficient way to\n * deduce what n is. This is the discrete log problem.\n *\n * However we can still perform addition/subtraction on points! That is why we generate those two points, which are:\n * incomplete_fee_payer_point := (fee_payer_npk + fee_payer_randomness) * G\n * incomplete_user_point := (user_npk + funded_amount + user_randomness) * G\n *\n * where `funded_amount` is the total amount in tokens that the sponsored user initially supplied, from which the transaction fee will be subtracted.\n *\n * So we pass those points into the teardown function (here) and compute a third point corresponding to the transaction fee as just\n *\n * fee_point := transaction_fee * G\n *\n * Then we arrive at the final points via addition/subtraction of that transaction fee point:\n *\n * fee_payer_point := incomplete_fee_payer_point + fee_point\n *                      = (fee_payer_npk + fee_payer_randomness) * G + transaction_fee * G\n *                      = (fee_payer_npk + fee_payer_randomness + transaction_fee) * G\n *\n * user_point := incomplete_user_point - fee_point\n *                       = (user_npk + funded_amount + user_randomness) * G - transaction_fee * G\n *                       = (user_npk + user_randomness + (funded_amount - transaction_fee)) * G\n * \n * When we return the x-coordinate of those points, it identically matches the note_content_hash of (and therefore *is*) notes like:\n * {\n *     amount: (funded_amount - transaction_fee),\n *     npk_m_hash: user_npk,\n *     randomness: user_randomness\n * }\n *\n * Why do we need different randomness for the user and the fee payer notes?\n * --> This is because if the randomness values were the same we could fingerprint the user by doing the following:\n *      1) randomness_influence = incomplete_fee_payer_point - G * fee_payer_npk =\n *                              = (fee_payer_npk + randomness) * G - G * fee_payer_npk = randomness * G\n *      2) user_fingerprint = incomplete_user_point - G * funded_amount - randomness_influence =\n *                          = (user_npk + funded_amount + randomness) * G - funded_amount * G - randomness * G =\n *                          = user_npk * G\n *      3) Then the second time the user would use this fee paying contract we would recover the same fingerprint and\n *         link that the 2 transactions were made by the same user. Given that it's expected that only a limited set\n *         of fee paying contracts will be used and they will be known searching for fingerprints by trying different\n *         fee payer npk values of these known contracts is a feasible attack.\n */\nimpl PrivatelyRefundable for TokenNote {\n    fn generate_refund_points(fee_payer_npk_m_hash: Field, user_npk_m_hash: Field, funded_amount: Field, user_randomness: Field, fee_payer_randomness: Field) -> (Point, Point) {\n        // 1. To be able to multiply generators with randomness and npk_m_hash using barretneberg's (BB) blackbox function we\n        // first need to convert the fields to high and low limbs.\n        let (fee_payer_randomness_lo, fee_payer_randomness_hi) = decompose(fee_payer_randomness);\n        let (fee_payer_npk_m_hash_lo, fee_payer_npk_m_hash_hi) = decompose(fee_payer_npk_m_hash);\n\n        // 2. Now that we have correct representationsn of fee payer and randomness we can compute `G ^ (fee_payer_npk + randomness)`\n        let incomplete_fee_payer_point = multi_scalar_mul(\n            [G1, G1],\n            [Scalar {\n                lo: fee_payer_npk_m_hash_lo,\n                hi: fee_payer_npk_m_hash_hi\n            },\n            Scalar {\n                lo: fee_payer_randomness_lo,\n                hi: fee_payer_randomness_hi\n            }]\n        );\n\n        // 3. We do the necessary conversion for values relevant for the sponsored user point.\n        let (user_randomness_lo, user_randomness_hi) = decompose(user_randomness);\n        // TODO(#7324): representing user with their npk_m_hash here does not work with key rotation\n        let (user_lo, user_hi) = decompose(user_npk_m_hash);\n        let (funded_amount_lo, funded_amount_hi) = decompose(funded_amount);\n\n        // 4. We compute `G ^ (user_npk_m_hash + funded_amount + randomness)`\n        let incomplete_user_point = multi_scalar_mul(\n            [G1, G1, G1],\n            [Scalar {\n                lo: user_lo,\n                hi: user_hi\n            },\n            Scalar {\n                lo: funded_amount_lo,\n                hi: funded_amount_hi\n            },\n            Scalar {\n                lo: user_randomness_lo,\n                hi: user_randomness_hi\n            }]\n        );\n\n        // 5. At last we represent the points as Points and return them.\n        (Point {\n            x: incomplete_fee_payer_point[0],\n            y: incomplete_fee_payer_point[1],\n            is_infinite: incomplete_fee_payer_point[2] == 1\n        }, Point {\n            x: incomplete_user_point[0],\n            y: incomplete_user_point[1],\n            is_infinite: incomplete_user_point[2] == 1\n        })\n    }\n\n    fn complete_refund(incomplete_fee_payer_point: Point, incomplete_user_point: Point, transaction_fee: Field) -> (Field, Field) {\n        // 1. We convert the transaction fee to high and low limbs to be able to use BB API.\n        let (transaction_fee_lo, transaction_fee_hi) = decompose(transaction_fee);\n\n        // 2. We compute the fee point as `G ^ transaction_fee`\n        let fee_point_raw = multi_scalar_mul(\n            [G1],\n            [Scalar {\n                lo: transaction_fee_lo,\n                hi: transaction_fee_hi,\n            }]\n        );\n        let fee_point = Point {\n            x: fee_point_raw[0],\n            y: fee_point_raw[1],\n            is_infinite: fee_point_raw[2] == 1\n        };\n\n        // 3. Now we leverage homomorphism to privately add the fee to fee payer point and subtract it from\n        // the sponsored user point in public.\n        let fee_payer_point = incomplete_fee_payer_point + fee_point;\n        let user_point = incomplete_user_point - fee_point;\n\n        assert_eq(user_point.is_infinite, false);\n\n        // Finally we return the x-coordinates of the points which are the note content hashes.\n        (fee_payer_point.x, user_point.x)\n    }\n}\n"},"38":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"47":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"65":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::PrivateContext,\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}},\n    state_vars::{shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter}\n};\n\nglobal DELAY = 5;\n\n// docs:start:key-getters\ntrait KeyGetters {\n  fn get_npk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ivpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ovpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_tpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_npk_m_hash(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Field;\n}\n\nimpl KeyGetters for Header {\n    fn get_npk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, NULLIFIER_INDEX, self)\n    }\n\n    fn get_ivpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, INCOMING_INDEX, self)\n    }\n\n    fn get_ovpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, OUTGOING_INDEX, self)\n    }\n\n    fn get_tpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, TAGGING_INDEX, self)\n    }\n\n    fn get_npk_m_hash(self, context: &mut PrivateContext, address: AztecAddress) -> Field {\n        get_master_key(context, address, NULLIFIER_INDEX, self).hash()\n    }\n}\n// docs:end:key-getters\n\nfn get_master_key(\n    context: &mut PrivateContext,\n    address: AztecAddress,\n    key_index: Field,\n    header: Header\n) -> Point {\n    let key = fetch_key_from_registry(context, key_index, address, header);\n    if is_empty(key) {\n        // Keys were not registered in registry yet --> fetch key from PXE\n        let keys = fetch_and_constrain_keys(address);\n        // Return the corresponding to index\n        keys.get_key_by_index(key_index)\n    } else {\n        // Keys were registered --> return the key\n        key\n    }\n}\n\nfn fetch_key_from_registry(\n    context: &mut PrivateContext,\n    key_index: Field,\n    address: AztecAddress,\n    header: Header\n) -> Point {\n    let x_coordinate_map_slot = key_index * 2 + 1;\n    let y_coordinate_map_slot = x_coordinate_map_slot + 1;\n    let x_coordinate_derived_slot = derive_storage_slot_in_map(x_coordinate_map_slot, address);\n    let y_coordinate_derived_slot = derive_storage_slot_in_map(y_coordinate_map_slot, address);\n\n    let x_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        x_coordinate_derived_slot\n    );\n    let y_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        y_coordinate_derived_slot\n    );\n    let x_coordinate = x_coordinate_registry.get_value_in_private(header);\n    let y_coordinate = y_coordinate_registry.get_value_in_private(header);\n\n    Point::new(x_coordinate, y_coordinate, false)\n}\n\n// Passes only when keys were not rotated - is expected to be called only when keys were not registered yet\nfn fetch_and_constrain_keys(address: AztecAddress) -> PublicKeys {\n    let (public_keys, partial_address) = get_public_keys_and_partial_address(address);\n\n    let computed_address = AztecAddress::compute(public_keys.hash(), partial_address);\n\n    assert(computed_address.eq(address));\n\n    public_keys\n}\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n"},"80":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n"},"81":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr","source":"use std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext, oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: Header, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for Header {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier);\n\n        // 2) Check that the witness we obtained matches the nullifier\n        assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n        // 3) Compute the nullifier tree leaf\n        let nullifier_leaf = witness.leaf_preimage.hash();\n\n        // 4) Prove that the nullifier is in the nullifier tree\n        assert(\n            self.state.partial.nullifier_tree.root\n            == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n        );\n        // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n        //     was included in the nullifier tree.\n    }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, N, M>(header: Header, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M>;\n}\n\nimpl ProveNoteIsNullified for Header {\n    // docs:start:prove_note_is_nullified\n    fn prove_note_is_nullified<Note, N, M>(self, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M> {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n    // docs:end:prove_note_is_nullified\n}\n"},"89":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<N>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, N>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<N, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<N, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"95":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn block_number(self) -> Field {\n        block_number()\n    }\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<N>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<N>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, N>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N)\n}\n\nunconstrained fn storage_write<N>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<N>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<N>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}