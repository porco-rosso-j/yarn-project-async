{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"DelegatedOn","functions":[{"name":"private_set_value","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"new_value","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"public_set_value","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"new_value","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/1WOwQ7CMAxD3aYdmZB25sIFGokf4Mr/i68iTlu2RcpmJc91GgTQAq87RnGCDYv/EvuDqVxk77QhzZFxSVe2gUFCESwP/1wN3afy5kL4QkPFueiskRqr2iBjqjaZJY6LisydubTjRjob0GpxCdWOr53RLqGvNBxxReSVfzKp/KS8fdk/f0i2lzQBAAA=","debug_symbols":"5ZZNCoMwEIXvkrWU/I7Rq5RSosYSkCgaC0W8e5O2SqFCDzC7eTPfYr7dW0hjq/l2db7tJ1KeF9L1tQmu9zEthJ4Ye22nwfi0mIIZAykZYzoj1jdpVLBmpHWdJaWQcs1+acFgowXonWYSDmgFjH5oBaB2ulBHsMx3WNE/sAa+fa0hp9/wJUuuApGrROSqELkCItcckatG5FrgceUUkSuiLsE5DtcY7mZ0pupsaozpNvt6K5AxhsfwvkT2CQ=="},{"name":"get_private_value","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"7d3RbiS3mYbhe5ljY1Fk/VXFyq0sFgsncRYGDDuInQUWRu595URdGscUWia/+ZoS3zM76R6xH5eq/5caNX/+9Odv/vj3//nvb7//yw8/fvrDf/786bsf/vT1T9/+8P3Tv/38afmPXP75v/7416+//+V/+PGnr//206c/bMvx1advvv/z0z+V9I+vPv3l2++++fSHNeIf//XVL086G5605tqTypqfn1TWo/KkteVJ0fKkreVJe8uTjpYnlZYnnQ1PiqXlSanlSS1XRLRcEdFyRUTLFREtV0S0XBHRckVEyxWxtVwRW8sVsbVcEVvLFbG1XBFbyxWxtVwRW8sVsbVcEVvLFbG3XBF7yxWxt1wRe8sVsbdcEXvLFbG3XBF7yxWxt1wRe8sVcbRcEUfLFXG0XBFHyxVxtFwRR8sVcbRcEUfLFXG0XBFHyxVRWq6I0nJFlJYrorRcEaXliigtV0RpuSJKyxVRWq6I0nJFnC1XxNlyRZwtV8TZckWcLVfE2XJFnC1XxNlyRZwtV8TZckWkZWl6Vmp6Vm561tr0rGh61tb0rL3pWUfTs0rTs5qujdR0baSmayM1XRup6dpITddGaro2UtO1kZqujdR0baSmayM3XRu56drITddGbro2ctO1kZuujdx0beSmayM3XRu56dpYm66NtenaaNrUTE27mqlpWzM17Wumpo3N1LSzmZq2NlPT3mZq2txMTbubqWl7MzXtb6amDc7UtMOZmrY4U9MeZ2ra5ExNu5ypaZszNe1zpqaNztS005matjpT015natrsTPWA35f0/Kzj2H71rK9+89hYU3l+cKz7cj36abCrPPqMM54ffW7bej06x3Jb0TrcimK4FW3DrWgfbkXHcCsqw63oHG1F9Y2qh64oDbei4e7Z53D37HO4e/Y53D37HO6efQ53zz6Hu2efo92z8zLaPTsvo92z8zLaPTsvo92z8zLaPTsvo92z8zLaPTsvo92z8zLaPTsvw92zk/m7f9vO5wdvx8vfUM1PX+V5PTHYesxX9VZu+zRbKbX1lMHWc461nrwMtp402HryYOtZB1tP//0nn5+tJ91Zz9MPvZ4f/LRl/vInr7f7c94GW88+2HqOwdZTBlvPOdZ61mWw9STzeo7b/edpi7O2njzYetbB1hODrWcbbD37YOs5BluP+f78FFjPD3661dTWc461nlgGW08a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cl9xj3wpxlpTDBQFirSLQpF2USjSLgpF2kWhSLsIFIN2USjSLgpF2kWhSLsoFANFgSLtolBk6r6rmNP1e4BP/1j7PcBg6lYoMnULFDemboUiU7dCkalbocjUrVAMFAWKTN0KRX5ioFCkXRSKtItCkXYRKHJovESRdlEo0i4KRdpFoRgoChRpF4Ui7aJQpF0UirSLQpF2EShy5LhEkan73xRvMAzSr8AEMHUYxt1XYJhgX4FhEDCf6LhxVKyfnO1ROzlTnZ2cedFOHpC7yZlx7eRMz3ZyNovt5Ows28mpTzX5sV3kpUbOSet+curTTk592smpTzt5QO4mpz7d55Zy0rqfnPq0k1OfdnLq00y+c9K6n5z6tJNTn3Zy6tNOHpC7yalPOzn1aSenPu3k1KednPp0k3OivZ+c+rSTU592curTTh6Qu8mpTzs59Wknpz7t5NSnnZz6dJNn6tNOTn3ayalPOzn1aScPyN3k1KednPq0k1OfdnLq005OfbrJV+rTTk592smpTzs59WknZy7Xkp/ldmbqWfYaOFO5GZyZ3AzORO4FD+ZxMzjTuBmcWdwMziRuBg/AveD8DMgMTmmawSlNMzilaQanNL3gG6VpBqc0zeCUphmc0hT/zGe57NKSokYekLvJqU07Ob1pJ6c47eQ0p52c6nST73SnnZzytJPTnnZy6tNOHpCLyVO5yNdUI6c+7eTUp52c+rSTU592curTTX5Qn19wSKyTU5/uufygPu3k1KedPCB3k1OfdnLq005OfdrJqU87OfXpJi/Up52c+rSTU592curTTh6Qu8mpTzs59Wknpz7t5NSnnZz6dJOf1KednPq0k1OfdnLq004ekLvJqU87OfVpJ6c+7eTUp52c+jSTHwv1aSenPu3k1KednPq0kwfkbnLq005OfdrJqU87OfVpJ6c+3eSJ+rSTU592curTTk592skDcjc59Wknpz7t5MzlWvKStufHlnRWwDNTuRj8en1lO2rgzORmcCZyMziTihmcOcUMzh65GZwdcjM4c7gXfGUON4Mzh5vBmcPN4OyLm8EDcC84pWkGpzTN4JSmGPxaRCm1/fCV0jSDU5pe8KA0zeCUphmc0jSDU5pm8ADcC05pmsEpTTM4pWkGpzTN4JSmF3yjNM3glKYZnNI0g1OaZvAA3AtOaZrBKU0zOKVpBqc0zeCUphd8pzTN4JSmGZzSNINTmmbwANwLTmmawSlNMzilaQanNM3glKYX/KA0zeCUphmc0jSDU5pm8ADcC05pmsEpTTM4pWkGpzS94IXwMYMTPmZwwscMTviYwQNwL3j/WLimcnud634PfNvO5wdvR3oBfPoqtwWV0RZ0DragcxltQWm0BWXzgs7bn7wve3VB62gLitEWtI22oH20BR2jLch9py759m1fSnVB51gLKssy2oLSaAvKoy1oHW1BMdqCttEWtI+2oGO0BQ12py7LaHfqNNqdOo12p06j3anTaHfqNNqdOo12p06j3anTaHfqNNqdOo12p86j3anzaHfqPNqdOo92p86j3anzaHfqPNqdOo92p86j3anzaHfqdbQ79TranXod7U69jnanXke7U6+j3anXce7UT//2v1//7duv//jdNz8+PeOX//Pv3//pp29/+P75X3/6v7/+6/95euz/Aw=="},{"name":"view_public_value","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/7VUPU/DMBR00nyYpCBgACEx+CekG2MLEwsDA3tamxIBseQkEvx5RCzZ5HBcCdH0JOtdnvzOzxfbARkQmBiT3wiIJxERPwIPx9wF8CsTV0qVn6yqufhgsmuZfGZr2dW8+am8NpFCNevH0vBiH9wUi8QVB6RksCSHeaHJnUHO9pv148TwrWhv3+Tm9aF7XwuFXoQefxgZQ6udD2p3sm5VuWlXnCvRNFg98yh+7VDMQPGlrOp7jlXR/5SehGoqWWNV/Ecl7UYC3M6jzvfS8GI/LLRubrTYhLpaM3X25l4hBtz2QMlwBKfsJ4M1mlaqciseRcnxcqZOmxjd32a/8QGYAQ+BJ5585OjtihR02YR2BGT8jFBnHxR6n3Dt4lBHTu9pbrRio237z8F3O+fSxFMyBmrZPu35sJrH4NUc1nF91LkQPNU46sc3EZZJnHYGAAA=","debug_symbols":"7ZjRaoMwFIbfJdcycnJOTqKvMsawrR2CaKl2MMR3n3aadhjWC2GQLVdyzMefP99VSC8Oxe7y9lrWx6YV2XMvqmafd2VTj1Mv5JO+/mxPeT3NbZefO5HJRBT1YfwOiTiWVSEyJBqSFWeUmUlD1rHWDi/JGM2boi3MpJW8ijZboi26aE9ruynaqCXarqNTXzSwkwis9YMNQFvpaEWOBmIvjY7WrO8LeWBEXGCS8DPMuByU7S0XUHlYQp5Z0uYbe7UC8n9qQbuwxODRAlGLT4uKWnxaMGrxaaGoxadFRy0+LfyHtIBxWnijFhO1+LTY39cC+qaFH2hJabl2QXpXRCHN/dOw+ysZeH8IvL8KvD8G3p/C7T9O7/m5zHdVMb1DTIuXer88S4xj93H6WhnZTw=="}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"current_value","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"a_map_with_private_values","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"new_value","type":{"kind":"field"}}],"kind":"struct","path":"DelegatedOn::public_set_value_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"DelegatedOn::public_set_value_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"amount","type":{"kind":"field"}},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"DelegatedOn::get_private_value_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"DelegatedOn::get_private_value_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"new_value","type":{"kind":"field"}},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"DelegatedOn::private_set_value_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"DelegatedOn::private_set_value_abi"}]}},"file_map":{"102":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::{Point, pub_key_to_bytes},\n    constants::{GENERATOR_INDEX__IVSK_M, GENERATOR_INDEX__OVSK_M}, hash::poseidon2_hash\n};\n\nuse std::field::bytes32_to_field;\n\nuse crate::oracle::unsafe_rand::unsafe_rand;\n\nuse crate::event::event_interface::EventInterface;\nuse crate::note::note_interface::NoteInterface;\n\nuse crate::encrypted_logs::{\n    header::EncryptedLogHeader, incoming_body::EncryptedLogIncomingBody,\n    outgoing_body::EncryptedLogOutgoingBody\n};\n\npub fn compute_encrypted_event_log<Event, NB, MB, OB>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    event: Event\n) -> [u8; OB] where Event: EventInterface<NB, MB> {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    let eph_sk: Scalar = fr_to_fq(unsafe_rand());\n    let eph_pk = eph_sk.derive_public_key();\n\n    // TODO: (#7177) This value needs to be populated!\n    let recipient = AztecAddress::from_field(0);\n\n    let ivpk_app = compute_ivpk_app(ivpk, contract_address);\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_Header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_event(event, randomness).compute_ciphertext(eph_sk, ivpk_app);\n    let outgoing_body_ciphertext: [u8; 176] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk_app).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; OB] = [0; OB];\n    // @todo We ignore the tags for now \n\n    let eph_pk_bytes = pub_key_to_bytes(eph_pk);\n    for i in 0..64 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[128 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[176 + i] = outgoing_Header_ciphertext[i];\n    }\n    for i in 0..176 {\n        encrypted_bytes[224 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = OB - 400;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[400 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (64 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (176 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\npub fn compute_encrypted_note_log<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> [u8; M] where Note: NoteInterface<N, NB> {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    let eph_sk: Scalar = fr_to_fq(unsafe_rand());\n    let eph_pk = eph_sk.derive_public_key();\n\n    // TODO: (#7177) This value needs to be populated!\n    let recipient = AztecAddress::from_field(0);\n\n    let ivpk_app = compute_ivpk_app(ivpk, contract_address);\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_Header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_note(note, storage_slot).compute_ciphertext(eph_sk, ivpk_app);\n    let outgoing_body_ciphertext: [u8; 176] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk_app).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now \n\n    let eph_pk_bytes = pub_key_to_bytes(eph_pk);\n    for i in 0..64 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[128 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[176 + i] = outgoing_Header_ciphertext[i];\n    }\n    for i in 0..176 {\n        encrypted_bytes[224 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 400;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[400 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (64 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (176 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field elememt to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let r_bytes = r.to_be_bytes(32);\n\n    let mut high_bytes = [0; 32];\n    let mut low_bytes = [0; 32];\n\n    for i in 0..16 {\n        high_bytes[16 + i] = r_bytes[i];\n        low_bytes[16 + i] = r_bytes[i + 16];\n    }\n\n    let low = bytes32_to_field(low_bytes);\n    let high = bytes32_to_field(high_bytes);\n\n    Scalar::new(low, high)\n}\n\nfn compute_ivpk_app(ivpk: Point, contract_address: AztecAddress) -> Point {\n    // It is useless to compute this, it brings no value to derive fully.\n    // Issue(#6955)\n    ivpk\n    /*\n    // @todo Just setting infinite to false, but it should be checked.\n    // for example user could define ivpk = infinity using the registry\n    assert((ivpk.x != 0) & (ivpk.y != 0), \"ivpk is infinite\");\n\n    let i = fr_to_fq(poseidon2_hash([contract_address.to_field(), ivpk.x, ivpk.y, GENERATOR_INDEX__IVSK_M]));\n    let I = i.derive_public_key();\n\n    let embed_I = Point { x: I.x, y: I.y, is_infinite: false };\n    let embed_ivpk = Point { x: ivpk.x, y: ivpk.y, is_infinite: false };\n\n    let embed_result = embedded_curve_add(embed_I, embed_ivpk);\n\n    Point::new(embed_result.x, embed_result.y)*/\n}\n"},"103":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    encrypted_logs::payload::compute_encrypted_note_log, oracle::logs_traits::LensForEncryptedLog\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field, address::AztecAddress, point::Point, abis::note_hash::NoteHash,\n    constants::MAX_NOTE_HASHES_PER_CALL, utils::arrays::find_index\n};\n\nunconstrained fn compute_unconstrained<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    compute(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note)\n}\n\nfn compute<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let encrypted_log: [u8; M] = compute_encrypted_note_log(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note);\n    let log_hash = sha256_to_field(encrypted_log);\n    (encrypted_log, log_hash)\n}\n\nfn emit_with_keys<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    note: Note,\n    ovpk: Point,\n    ivpk: Point,\n    inner_compute: fn(AztecAddress, Field, Field, Point, Point, Note) -> ([u8; M], Field)\n) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    let note_exists_index = find_index(\n        context.note_hashes.storage,\n        |n: NoteHash| n.counter == note_hash_counter\n    );\n    assert(\n        note_exists_index as u32 != MAX_NOTE_HASHES_PER_CALL, \"Can only emit a note log for an existing note.\"\n    );\n\n    let contract_address: AztecAddress = context.this_address();\n    let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n    let (encrypted_log, log_hash) = inner_compute(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n\npub fn encode_and_encrypt_note<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let header = context.get_header();\n        let ovpk = header.get_ovpk_m(context, ov);\n        let ivpk = header.get_ivpk_m(context, iv);\n        emit_with_keys(context, e.note, ovpk, ivpk, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let header = context.get_header();\n        let ovpk = header.get_ovpk_m(context, ov);\n        let ivpk = header.get_ivpk_m(context, iv);\n        emit_with_keys(context, e.note, ovpk, ivpk, compute_unconstrained);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ovpk: Point,\n    ivpk: Point\n) -> fn[(&mut PrivateContext, Point, Point)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys_unconstrained<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ovpk: Point,\n    ivpk: Point\n) -> fn[(&mut PrivateContext, Point, Point)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, compute_unconstrained);\n    }\n}\n"},"104":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/outgoing_body.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash\n};\n\nuse std::aes128::aes128_encrypt;\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nstruct EncryptedLogOutgoingBody {\n    eph_sk: Scalar,\n    recipient: AztecAddress,\n    recipient_ivpk_app: Point,\n}\n\nimpl EncryptedLogOutgoingBody {\n    pub fn new(eph_sk: Scalar, recipient: AztecAddress, recipient_ivpk_app: Point) -> Self {\n        Self { eph_sk, recipient, recipient_ivpk_app }\n    }\n\n    pub fn compute_ciphertext(self, ovsk_app: Scalar, eph_pk: Point) -> [u8; 176] {\n        // Again, we could compute `eph_pk` here, but we keep the interface more similar\n        // and also make it easier to optimise it later as we just pass it along\n\n        let mut buffer: [u8; 160] = [0; 160];\n\n        let serialized_eph_sk_high = self.eph_sk.hi.to_be_bytes(32);\n        let serialized_eph_sk_low = self.eph_sk.lo.to_be_bytes(32);\n\n        let address_bytes = self.recipient.to_field().to_be_bytes(32);\n        let serialized_recipient_ivpk_app = self.recipient_ivpk_app.serialize();\n        let serialized_recipient_ivpk_app_x = serialized_recipient_ivpk_app[0].to_be_bytes(32);\n        let serialized_recipient_ivpk_app_y = serialized_recipient_ivpk_app[1].to_be_bytes(32);\n\n        for i in 0..32 {\n            buffer[i] = serialized_eph_sk_high[i];\n            buffer[i + 32] = serialized_eph_sk_low[i];\n            buffer[i + 64] = address_bytes[i];\n            buffer[i + 96] = serialized_recipient_ivpk_app_x[i];\n            buffer[i + 128] = serialized_recipient_ivpk_app_y[i];\n        }\n\n        // We compute the symmetric key using poseidon.\n        let full_key: [u8; 32] = poseidon2_hash(\n            [\n            ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y,\n            GENERATOR_INDEX__SYMMETRIC_KEY as Field\n        ]\n        ).to_be_bytes(32).as_array();\n\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(buffer, iv, sym_key).as_array()\n    }\n}\n\nmod test {\n    use crate::encrypted_logs::outgoing_body::EncryptedLogOutgoingBody;\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, hash::poseidon2_hash\n    };\n\n    use crate::context::PrivateContext;\n\n    #[test]\n    fn test_encrypted_log_outgoing_body() {\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        );\n        let recipient_ivsk_app = Scalar::new(\n            0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        );\n        let sender_ovsk_app = Scalar::new(\n            0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        );\n\n        let eph_pk = eph_sk.derive_public_key();\n        let recipient_ivpk_app = recipient_ivsk_app.derive_public_key();\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let body = EncryptedLogOutgoingBody::new(eph_sk, recipient, recipient_ivpk_app);\n\n        let ciphertext = body.compute_ciphertext(sender_ovsk_app, eph_pk);\n\n        let expected_outgoing_body_ciphertext = [\n            127, 84, 96, 176, 101, 107, 236, 57, 68, 8, 53, 202, 138, 74, 186, 54, 74, 193, 245, 7, 109, 59, 218, 33, 1, 31, 205, 225, 241, 209, 64, 222, 94, 245, 4, 150, 47, 241, 187, 64, 152, 20, 102, 158, 200, 217, 213, 82, 1, 240, 170, 185, 51, 80, 27, 109, 63, 231, 235, 120, 174, 44, 133, 248, 10, 97, 60, 40, 222, 190, 147, 76, 187, 48, 91, 206, 48, 106, 56, 118, 38, 127, 82, 4, 182, 188, 44, 224, 31, 129, 47, 107, 134, 252, 20, 25, 122, 191, 158, 69, 35, 255, 215, 171, 196, 45, 91, 184, 83, 80, 238, 201, 1, 233, 235, 159, 171, 130, 158, 64, 176, 165, 132, 30, 84, 81, 71, 195, 145, 47, 82, 247, 210, 192, 23, 4, 220, 90, 56, 109, 46, 105, 79, 251, 165, 141, 185, 233, 191, 118, 219, 153, 191, 162, 99, 238, 241, 249, 9, 74, 210, 241, 54, 28, 126, 226, 85, 235, 174, 75, 239, 207, 100, 184, 248, 194\n        ];\n\n        for i in 0..expected_outgoing_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_outgoing_body_ciphertext[i]);\n        }\n        assert_eq(expected_outgoing_body_ciphertext.len(), ciphertext.len());\n    }\n}\n"},"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\nstruct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext(self, secret: Scalar, point: Point) -> [u8; 48] {\n        let full_key = point_to_symmetric_key(secret, point);\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes(32).as_array();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nfn test_encrypted_log_header() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar::new(\n        0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    );\n    let point = Point::new(\n        0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        false\n    );\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    let expected_header_ciphertext = [\n        228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 23, 131, 32, 226, 26, 176, 43, 39, 239, 177, 177, 192, 85, 216, 17, 15, 18, 187, 35, 225, 135, 192, 63, 88, 29, 173, 232, 46, 72, 82, 187, 139\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext);\n}\n"},"106":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/incoming_body.nr","source":"use crate::note::note_interface::NoteInterface;\nuse crate::event::event_interface::EventInterface;\nuse dep::protocol_types::{scalar::Scalar, point::Point};\n\nuse std::aes128::aes128_encrypt;\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nstruct EncryptedLogIncomingBody<M> {\n    plaintext: [u8; M]\n}\n\nimpl<M> EncryptedLogIncomingBody<M> {\n    pub fn from_note<T, N>(note: T, storage_slot: Field) -> Self where T: NoteInterface<N, M> {\n        let mut plaintext = note.to_be_bytes(storage_slot);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn from_event<T, MR>(event: T, randomness: Field) -> Self where T: EventInterface<M, MR> {\n        let mut plaintext = event.private_to_be_bytes(randomness);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn compute_ciphertext(self, eph_sk: Scalar, ivpk_app: Point) -> [u8] {\n        let full_key = point_to_symmetric_key(eph_sk, ivpk_app);\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(self.plaintext, iv, sym_key)\n    }\n}\n\nmod test {\n    use crate::encrypted_logs::incoming_body::EncryptedLogIncomingBody;\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, traits::Serialize, abis::event_selector::EventSelector\n    };\n\n    use crate::{\n        note::{note_header::NoteHeader, note_interface::NoteInterface},\n        event::event_interface::EventInterface, oracle::unsafe_rand::unsafe_rand,\n        context::PrivateContext\n    };\n\n    struct AddressNote {\n        address: AztecAddress,\n        owner: AztecAddress,\n        randomness: Field,\n        header: NoteHeader,\n    }\n\n    global ADDRESS_NOTE_LEN: Field = 3;\n    global ADDRESS_NOTE_BYTES_LEN = 32 * 3 + 64;\n\n    impl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n        fn compute_note_content_hash(self) -> Field {1}\n\n        fn get_note_type_id() -> Field {\n            1\n        }\n\n        fn get_header(self) -> NoteHeader { self.header}\n\n        fn set_header(&mut self, header: NoteHeader) {self.header = header; }\n\n        fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n            (1, 1)\n        }\n\n        fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {(1,1)}\n\n        fn serialize_content(self) -> [Field; ADDRESS_NOTE_LEN] { [self.address.to_field(), self.owner.to_field(), self.randomness]}\n\n        fn deserialize_content(fields: [Field; ADDRESS_NOTE_LEN]) -> Self {\n            AddressNote { address: AztecAddress::from_field(fields[0]), owner: AztecAddress::from_field(fields[1]), randomness: fields[2], header: NoteHeader::empty() }\n        }\n\n        fn to_be_bytes(self, storage_slot: Field) -> [u8; ADDRESS_NOTE_BYTES_LEN] {\n            let serialized_note = self.serialize_content();\n\n            let mut buffer: [u8; ADDRESS_NOTE_BYTES_LEN] = [0; ADDRESS_NOTE_BYTES_LEN];\n\n            let storage_slot_bytes = storage_slot.to_be_bytes(32);\n            let note_type_id_bytes = AddressNote::get_note_type_id().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = storage_slot_bytes[i];\n                buffer[32 + i] = note_type_id_bytes[i];\n            }\n\n            for i in 0..serialized_note.len() {\n                let bytes = serialized_note[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n            buffer\n        }\n    }\n\n    impl AddressNote {\n        pub fn new(address: AztecAddress, owner: AztecAddress, randomness: Field) -> Self {\n            AddressNote { address, owner, randomness, header: NoteHeader::empty() }\n        }\n    }\n\n    #[test]\n    fn test_encrypted_note_log_incoming_body() {\n        let note = AddressNote::new(\n            AztecAddress::from_field(0x1),\n            AztecAddress::from_field(0x2),\n            3\n        );\n\n        let storage_slot = 2;\n\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        );\n        let ivpk_app = Point::new(\n            0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            false\n        );\n\n        let body = EncryptedLogIncomingBody::from_note(note, storage_slot);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk_app);\n\n        let expected_note_body_ciphertext = [\n            228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 63, 127, 188, 251, 150, 188, 238, 205, 3, 86, 102, 164, 175, 12, 137, 158, 163, 111, 205, 10, 229, 230, 46, 202, 110, 107, 156, 180, 67, 192, 161, 201, 48, 153, 169, 1, 25, 182, 93, 39, 39, 207, 251, 218, 234, 147, 156, 13, 110, 180, 190, 199, 41, 6, 211, 203, 176, 110, 165, 186, 110, 127, 199, 22, 201, 149, 92, 249, 219, 68, 145, 68, 179, 29, 233, 34, 98, 123, 197, 234, 169, 53, 44, 14, 81, 60, 92, 27, 250, 134, 49, 248, 57, 119, 236, 118, 158, 104, 82, 243, 98, 164, 60, 72, 74, 27, 177, 194, 221, 225, 193, 150, 67, 235, 205, 106, 150, 24, 126, 186, 220, 178, 199, 189, 113, 54, 181, 55, 46, 15, 236, 236, 9, 159, 5, 172, 237, 154, 110, 50, 241, 64, 92, 13, 37, 53, 20, 140, 42, 146, 229, 63, 97, 25, 159, 63, 235, 104, 68, 100\n        ];\n\n        assert_eq(expected_note_body_ciphertext.len(), ciphertext.len());\n\n        for i in 0..expected_note_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_note_body_ciphertext[i]);\n        }\n    }\n\n    struct TestEvent {\n        value0: Field,\n        value1: Field,\n        value2: Field,\n    }\n\n    impl Serialize<3> for TestEvent {\n        fn serialize(self) -> [Field; 3] {\n            [self.value0, self.value1, self.value2]\n        }\n    }\n\n    global TEST_EVENT_LEN: Field = 3;\n    global TEST_EVENT_BYTES_LEN = 32 * 3 + 64;\n    global TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS = 32 * 3 + 32;\n\n    impl EventInterface<TEST_EVENT_BYTES_LEN, TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS> for TestEvent {\n        fn get_event_type_id() -> EventSelector {\n            EventSelector::from_signature(\"TestEvent(Field,Field,Field)\")\n        }\n\n        fn private_to_be_bytes(self, randomness: Field) -> [u8; TEST_EVENT_BYTES_LEN] {\n            let mut buffer: [u8; TEST_EVENT_BYTES_LEN] = [0; TEST_EVENT_BYTES_LEN];\n\n            let randomness_bytes = randomness.to_be_bytes(32);\n            let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = randomness_bytes[i];\n                buffer[32 + i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes = serialized_event[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn to_be_bytes(self) -> [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] {\n             let mut buffer: [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] = [0; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS];\n\n             let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n             for i in 0..32 {\n                 buffer[i] = event_type_id_bytes[i];\n            }\n\n             let serialized_event = self.serialize();\n\n             for i in 0..serialized_event.len() {\n                 let bytes = serialized_event[i].to_be_bytes(32);\n                 for j in 0..32 {\n                     buffer[32 + i * 32 + j] = bytes[j];\n                }\n            }\n\n             buffer\n        }\n\n        fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n            _emit(self);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_event_incoming_body() {\n        let test_event = TestEvent { value0: 1, value1: 2, value2: 3 };\n\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        );\n\n        let ivpk_app = Point::new(\n            0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            false\n        );\n\n        let randomness = 2;\n\n        let body = EncryptedLogIncomingBody::from_event(test_event, randomness);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk_app);\n\n        let expected_event_body_ciphertext = [\n            228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 63, 127, 188, 251, 150, 188, 238, 205, 3, 86, 102, 164, 175, 12, 137, 158, 163, 111, 205, 10, 229, 230, 46, 202, 110, 107, 156, 180, 67, 192, 161, 201, 66, 122, 29, 35, 42, 33, 153, 216, 199, 208, 103, 207, 126, 153, 189, 136, 19, 220, 238, 15, 169, 29, 255, 11, 123, 107, 70, 192, 53, 40, 36, 93, 187, 32, 123, 136, 104, 23, 229, 245, 152, 90, 84, 2, 136, 112, 42, 27, 82, 214, 104, 14, 250, 48, 199, 245, 88, 22, 200, 77, 38, 51, 127, 56, 138, 255, 16, 46, 179, 129, 215, 185, 185, 116, 148, 16, 133, 62, 56, 180, 10, 132, 109, 77, 206, 199, 21, 167, 7, 163, 171, 158, 244, 23, 18, 121, 108, 42, 107, 7, 48, 84, 212, 104, 39, 16, 109, 7, 108, 129, 60, 80, 112, 241, 223, 140, 186, 158, 38, 74, 230, 213, 159, 175, 142, 228, 128, 160\n        ];\n\n        assert_eq(expected_event_body_ciphertext.len(), ciphertext.len());\n\n        for i in 0..expected_event_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_event_body_ciphertext[i]);\n        }\n    }\n}\n"},"110":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr","source":"use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus, PropertySelector},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\n\nmod test;\n\nfn extract_property_value_from_selector<N>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note. \n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value = serialized_note[selector.index].to_be_bytes(32);\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, N, M>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<N>(serialized_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let is_equal = value_field == select.value.to_field();\n        let is_lt = value_field.lt(select.value.to_field());\n\n        if (select.comparator == Comparator.EQ) {\n            assert(is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(is_lt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(is_lt | is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!is_lt & !is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!is_lt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N, M> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    context.push_note_hash_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, M, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> where Note: NoteInterface<N, M> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nfn constrain_get_notes_internal<Note, N, M, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> where Note: NoteInterface<N, M> {\n    let mut returned_notes = BoundedVec::new();\n\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        let opt_note = filtered_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n\n            // The below code is used to collapse a sparse array into one where the values are guaranteed to be at the \n            // front of the array. This is highly useful because the caller knows that the returned array won't have\n            // more than option.limits notes, and can therefore loop over this limit value instead of the entire array,\n            // resulting in a smaller circuit and faster proving times.\n            // We write at returned_notes[num_notes] because num_notes is only advanced when we have a value in \n            // filtered_notes.\n            returned_notes.push(note);\n        };\n    }\n\n    // As long as we only loop till `options.limit` the array will be guaranteed to be at most of length `options.limit`.\n    assert(returned_notes.len() <= options.limit, \"Got more notes than limit.\");\n    // We will however check that nothing else was returned after the limit.\n    for i in options.limit..filtered_notes.len() {\n        assert(filtered_notes[i].is_none(), \"Got more notes than limit.\");\n    }\n\n    assert(returned_notes.len() != 0, \"Cannot return zero notes\");\n\n    returned_notes\n}\n\nunconstrained fn get_note_internal<Note, N, M>(storage_slot: Field) -> Note where Note: NoteInterface<N, M> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, M, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N, M> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained pub fn view_notes<Note, N, M>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N, M>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N, M> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n"},"112":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__INNER_NOTE_HASH,\n    hash::{\n    pedersen_hash, compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_inner_note_hash_from_preimage(storage_slot: Field, note_content_hash: Field) -> Field {\n    pedersen_hash(\n        [storage_slot, note_content_hash],\n        GENERATOR_INDEX__INNER_NOTE_HASH\n    )\n}\n\nfn compute_inner_note_hash<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    compute_inner_note_hash_from_preimage(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N, M>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let (_, inner_nullifier) = note_with_header.compute_note_hash_and_nullifier(context);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\nfn compute_note_hash_for_read_request_from_innter_and_nonce(\n    inner_note_hash: Field,\n    nonce: Field\n) -> Field {\n    // TODO(#1386): This if-else can be nuked once we have nonces injected from public\n    if (nonce == 0) {\n        // If nonce is zero, that means we are reading a public note.\n        inner_note_hash\n    } else {\n        compute_unique_note_hash(nonce, inner_note_hash)\n    }\n}\n\npub fn compute_note_hash_for_read_request<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let inner_note_hash = compute_inner_note_hash(note);\n    let nonce = note.get_header().nonce;\n\n    compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, nonce)\n}\n\npub fn compute_note_hash_for_consumption<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    if (header.note_hash_counter != 0) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        inner_note_hash\n    } else {\n        // If a note is not transient, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the siloed_note_hash which has already been hashed with\n        // nonce and then contract address. This hash will match the existing leaf in the note hash\n        // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, header.nonce);\n        compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, N, M, S>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n    let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, note_header.nonce);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        let (_, nullifier) = note.compute_note_hash_and_nullifier_without_context();\n        nullifier\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [inner_note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"113":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_inner_note_hash, compute_note_hash_for_consumption}, note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let inner_note_hash = compute_inner_note_hash(*note);\n\n    let serialized_note = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash,\n        note_hash_counter\n    )\n        == 0\n    );\n\n    context.push_note_hash(inner_note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, N, M>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let inner_note_hash = compute_inner_note_hash(*note);\n\n    context.push_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let (note_hash, nullifier) = note.compute_note_hash_and_nullifier(context);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let note_hash_for_consumption = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a non-transient note and we don't populate the note_hash with real\n        // value (if we did so the `notifyNullifiedNote` oracle would throw).\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a transient note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can find it and squash both\n        // the note and the nullifier.\n        note_hash\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    assert(notify_nullified_note(nullifier, note_hash_for_consumption, nullifier_counter) == 0);\n\n    context.push_nullifier(nullifier, note_hash_for_consumption)\n}\n"},"114":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\nstruct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting  \n * a change note in a token's transfer function only when there is \"change\" left).\n */\nstruct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(self) {}\n}\n"},"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"124":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::{address::AztecAddress, point::Point};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<M>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<M>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<M>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32\n) {}\n\nunconstrained pub fn emit_encrypted_event_log<M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<N, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<N, M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\n}\n"},"127":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle<N>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<N>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<N>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n"},"128":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n"},"132":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<N>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field\n) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number as Field, N)\n}\n\nunconstrained pub fn storage_read<T, N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"133":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/unsafe_rand.nr","source":"#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n\n// Called `unsafe_rand` because we do not constrain in circuit that we are dealing with an actual random value.\n// Instead we just trust our PXE.\nunconstrained pub fn unsafe_rand() -> Field {\n    rand_oracle()\n}\n"},"136":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use crate::keys::PublicKeys;\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained fn get_public_keys_and_partial_address_oracle_wrapper(address: AztecAddress) -> [Field; 13] {\n    get_public_keys_and_partial_address_oracle(address)\n}\n\nfn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle_wrapper(address);\n\n    let keys = PublicKeys {\n        npk_m: Point::new(result[0], result[1], result[2] as bool),\n        ivpk_m: Point::new(result[3], result[4], result[5] as bool),\n        ovpk_m: Point::new(result[6], result[7], result[8] as bool),\n        tpk_m: Point::new(result[9], result[10], result[11] as bool)\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"138":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        inner_note_hash,\n        counter\n    )\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field, _counter: u32) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(\n    nullifier: Field,\n    inner_note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash, counter)\n}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, NB, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N, NB> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n// Only ever use this in private!\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n// Only ever use this in private!\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n"},"144":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{hash::pedersen_hash, storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"146":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UnconstrainedContext> {\n    unconstrained pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"153":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr","source":"use dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE, lifecycle::{create_note, create_note_hash_from_public, destroy_note},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader, note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note> PrivateSet<Note, &mut PublicContext> {\n    // docs:start:insert_from_public\n    pub fn insert_from_public<N, M>(self, note: &mut Note) where Note: NoteInterface<N, M> {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note> PrivateSet<Note, &mut PrivateContext> {\n    // docs:start:insert\n    pub fn insert<N, M>(self, note: &mut Note) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    // docs:start:remove\n    pub fn remove<N, M>(self, note: Note) where Note: NoteInterface<N, M> {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read = self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note(self.context, note);\n    }\n    // docs:end:remove\n\n    // docs:start:get_notes\n    pub fn get_notes<N, M, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> where Note: NoteInterface<N, M> {\n        get_notes(self.context, self.storage_slot, options)\n    }\n    // docs:end:get_notes\n}\n\nimpl<Note> PrivateSet<Note, UnconstrainedContext> {\n    // docs:start:view_notes\n    unconstrained pub fn view_notes<N, M>(\n        self,\n        options: NoteViewerOptions<Note, N, M>\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N, M> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"},"155":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_delay_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initally equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation \n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the \n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a \n// reduced delay, invalidating prior private reads.\nstruct ScheduledDelayChange<INITIAL_DELAY> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option, \n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pre: Option<u32>,\n    post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numeric value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\nimpl<INITIAL_DELAY> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior contraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This \n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is \n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in \n            //                             which to scheduled value change\n\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY)\n            )\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Serialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn serialize(self) -> [Field; 1] {\n        // We pack all three u32 values into a single U128, which is made up of two u64 limbs.\n        // Low limb: [ pre_inner: u32 | post_inner: u32 ]\n        // High limb: [ empty | pre_is_some: u8 |  post_is_some: u8 | block_of_change: u32 ]\n\n        let lo = ((self.pre.unwrap_unchecked() as u64) * (1 << 32))\n            + (self.post.unwrap_unchecked() as u64);\n\n        let hi = (self.pre.is_some() as u64) * (1 << 33) \n            + (self.post.is_some() as u64 * (1 << 32)) \n            + self.block_of_change as u64;\n\n        let packed = U128::from_u64s_le(lo, hi);\n\n        [packed.to_integer()]\n    }\n}\n\nimpl<INITIAL_DELAY> Deserialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn deserialize(input: [Field; 1]) -> Self {\n        let packed = U128::from_integer(input[0]);\n\n        // We use division and modulo to clear the bits that correspond to other values when unpacking.\n\n        let pre_is_some = ((packed.hi as u64) / (1 << 33)) as bool;\n        let pre_inner = ((packed.lo as u64) / (1 << 32)) as u32;\n\n        let post_is_some = (((packed.hi as u64) / (1 << 32)) % (1 << 1)) as bool;\n        let post_inner = ((packed.lo as u64) % (1 << 32)) as u32;\n\n        let block_of_change = ((packed.hi as u64) % (1 << 32)) as u32;\n\n        Self {\n            pre: if pre_is_some { Option::some(pre_inner) } else { Option::none() },\n            post: if post_is_some { Option::some(post_inner) } else { Option::none() },\n            block_of_change,\n            _dummy: [0; INITIAL_DELAY],\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"157":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable_private_getter.nr","source":"use dep::protocol_types::{\n    hash::{pedersen_hash, poseidon2_hash}, traits::{FromField, ToField}, address::AztecAddress,\n    header::Header\n};\n\nuse crate::context::PrivateContext;\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{\n    shared_mutable::SharedMutable, scheduled_delay_change::ScheduledDelayChange,\n    scheduled_value_change::ScheduledValueChange\n}\n};\n\nstruct SharedMutablePrivateGetter<T, INITIAL_DELAY> {\n    context: &mut PrivateContext,\n    // The contract address of the contract we want to read from\n    other_contract_address: AztecAddress,\n    // The storage slot where the SharedMutable is stored on the other contract\n    storage_slot: Field,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numberic value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\n// We have this as a view-only interface to reading Shared Mutables in other contracts.\n// Currently the Shared Mutable does not support this. We can adapt SharedMutable at a later date\nimpl<T, INITIAL_DELAY> SharedMutablePrivateGetter<T, INITIAL_DELAY> {\n    pub fn new(\n        context: &mut PrivateContext,\n        other_contract_address: AztecAddress,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        assert(other_contract_address.to_field() != 0, \"Other contract address cannot be 0\");\n        Self { context, other_contract_address, storage_slot, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    pub fn get_value_in_private(self, header: Header) -> T where T: FromField + ToField + Eq {\n        // We create a dummy SharedMutable state variable so that we can reuse its historical_read_from_public_storage\n        // method, greatly reducing code duplication. \n        let dummy: SharedMutable<T, INITIAL_DELAY, ()> = SharedMutable::new((), self.storage_slot);\n        let (value_change, delay_change, historical_block_number) = dummy.historical_read_from_public_storage(header, self.other_contract_address);\n\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // If our context has the same header as the one we pass in via the parameter, we are trying to read the \"current\" value\n        // and thus need to set the tx max block number below. If the context header is not the same as the one we pass in, this means\n        // we are trying to read a historical value and thus have no constraint on the max block number that this transaction can be included in.\n        if (self.context.historical_header.global_variables.block_number.eq(header.global_variables.block_number)) {\n            self.context.set_tx_max_block_number(block_horizon);\n        }\n\n        value_change.get_current_at(historical_block_number)\n    }\n}\n"},"159":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_value_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\nstruct ScheduledValueChange<T> {\n    pre: T,\n    post: T,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Serialize<3> for ScheduledValueChange<T> {\n    fn serialize(self) -> [Field; 3] where T: ToField {\n        [self.pre.to_field(), self.post.to_field(), self.block_of_change.to_field()]\n    }\n}\n\nimpl<T> Deserialize<3> for ScheduledValueChange<T> {\n  fn deserialize(input: [Field; 3]) -> Self  where T: FromField {\n    Self {\n        pre: FromField::from_field(input[0]),\n        post: FromField::from_field(input[1]),\n        block_of_change: FromField::from_field(input[2]),\n    }\n  }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>  {\n    fn eq(self, other: Self) -> bool where T: Eq {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"160":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable.nr","source":"use dep::protocol_types::{\n    hash::{pedersen_hash, poseidon2_hash}, header::Header, address::AztecAddress,\n    traits::{FromField, ToField}\n};\n\nuse crate::context::{PrivateContext, PublicContext};\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{scheduled_value_change::ScheduledValueChange, scheduled_delay_change::ScheduledDelayChange}\n};\nuse crate::oracle::storage::storage_read;\nuse dep::std::unsafe::zeroed;\n\nmod test;\n\nstruct SharedMutable<T, INITIAL_DELAY, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Serialize<N> trait, and allocate N storage slots to\n// this state variable. This is incorrect, since what we actually store is:\n//  - a ScheduledValueChange<T>, which requires 1 + 2 * M storage slots, where M is the serialization length of T\n//  - a ScheduledDelayChange, which requires another storage slot\n//\n// TODO https://github.com/AztecProtocol/aztec-packages/issues/5736: change the storage allocation scheme so that we\n// can actually use it here\nimpl<T, INITIAL_DELAY, Context> Storage<T> for SharedMutable<T, INITIAL_DELAY, Context> {}\n\n// TODO: extract into a utils module once  we can do arithmetic on generics, i.e. https://github.com/noir-lang/noir/issues/4784\nfn concat_arrays<N, M, O>(arr_n: [Field; N], arr_m: [Field; M]) -> [Field; O] {\n    assert_eq(N + M, O);\n    let mut out: [Field; O] = [0; O];\n    for i in 0..N {\n        out[i] = arr_n[i];\n    }\n    for i in 0..M {\n        out[N+i] = arr_m[i];\n    }\n    out\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, INITIAL_DELAY, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    fn hash_scheduled_data(\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) -> Field where T: ToField {\n        // TODO(#5491 and https://github.com/noir-lang/noir/issues/4784): update this so that we don't need to rely on\n        // ScheduledValueChange serializing to 3 and ScheduledDelayChange serializing to 1\n        let concatenated: [Field; 4] = concat_arrays(value_change.serialize(), delay_change.serialize());\n        poseidon2_hash(concatenated)\n    }\n\n    // Since we can't rely on the native storage allocation scheme, we hash the storage slot to get a unique location in\n    // which we can safely store as much data as we need.\n    // See https://github.com/AztecProtocol/aztec-packages/issues/5492 and\n    // https://github.com/AztecProtocol/aztec-packages/issues/5736\n    // We store three things in public storage:\n    //  - a ScheduledValueChange\n    //  - a ScheduledDelaChange\n    //  - the hash of both of these (via `hash_scheduled_data`)\n    fn get_value_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 0], 0)\n    }\n\n    fn get_delay_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 1], 0)\n    }\n\n    fn get_hash_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 2], 0)\n    }\n\n    // It may seem odd that we take a header and address instead of reading from e.g. a PrivateContext, but this lets us\n    // reuse this function in SharedMutablePrivateGetter.\n    fn historical_read_from_public_storage(\n        self,\n        header: Header,\n        address: AztecAddress\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) where T: FromField + ToField + Eq {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for both the ScheduledValueChange and\n        // ScheduledDelayChange, but that'd require one full sibling path per storage slot (since due to kernel siloing\n        // the storage is not contiguous), and in the best case in which T is a single field that'd be 4 slots.\n        // Instead, we get an oracle to provide us the correct values for both the value and delay changes, and instead\n        // prove inclusion of their hash, which is both a much smaller proof (a single slot), and also independent of\n        // the size of T.\n        let (value_change_hint, delay_change_hint) = get_public_storage_hints(address, self.storage_slot, historical_block_number);\n\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let hash = header.public_storage_historical_read(self.get_hash_storage_slot(), address);\n\n        // @todo This is written strangely to bypass a formatting issue with the if that is breaking ci.\n        let (a, b, c) = if hash != 0 {\n            let a = SharedMutable::hash_scheduled_data(value_change_hint, delay_change_hint);\n            (a, value_change_hint, delay_change_hint)\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized, meaning no value or delay change was ever\n            // scheduled. Therefore, the hints must then correspond to uninitialized scheduled changes.\n            let b = ScheduledValueChange::deserialize(zeroed());\n            let c = ScheduledDelayChange::deserialize(zeroed());\n            (hash, b, c)\n        };\n\n        assert_eq(hash, a, \"Hint values do not match hash\");\n        assert_eq(value_change_hint, b, \"Non-zero value change for zero hash\");\n        assert_eq(delay_change_hint, c, \"Non-zero delay change for zero hash\");\n\n        (value_change_hint, delay_change_hint, historical_block_number)\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PublicContext> {\n    pub fn schedule_value_change(self, new_value: T) where T: ToField {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) where T: ToField {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value_in_public(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay_in_public(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value_in_public(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay_in_public(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        self.context.storage_read(self.get_delay_change_storage_slot())\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) where T: ToField {\n        // Whenever we write to public storage, we write both the value change and delay change as well as the hash of\n        // them both. This guarantees that the hash is always kept up to date.\n        // While this makes for more costly writes, it also makes private proofs much simpler because they only need to\n        // produce a historical proof for the hash, which results in a single inclusion proof (as opposed to 4 in the\n        // best case scenario in which T is a single field). Private shared mutable reads are assumed to be much more\n        // frequent than public writes, so this tradeoff makes sense.\n        self.context.storage_write(self.get_value_change_storage_slot(), value_change);\n        self.context.storage_write(self.get_delay_change_storage_slot(), delay_change);\n        self.context.storage_write(\n            self.get_hash_storage_slot(),\n            SharedMutable::hash_scheduled_data(value_change, delay_change)\n        );\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext> {\n    pub fn get_current_value_in_private(self) -> T where T: FromField + ToField + Eq {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n\n        let (value_change, delay_change, historical_block_number) = self.historical_read_from_public_storage(self.context.get_header(), self.context.this_address());\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n}\n\nunconstrained fn get_public_storage_hints<T, INITIAL_DELAY>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>) {\n    // This function cannot be part of the &mut PrivateContext impl because that'd mean that by passing `self` we'd also\n    // be passing a mutable reference to an unconstrained function, which is not allowed. We therefore create a dummy\n    // state variable here so that we can access the methods to compute storage slots. This will all be removed in the\n    // future once we do proper storage slot allocation (#5492).\n    let dummy = SharedMutable::new((), storage_slot);\n\n    (\n        storage_read(address, dummy.get_value_change_storage_slot(), block_number), storage_read(address, dummy.get_delay_change_storage_slot(), block_number)\n    )\n}\n"},"180":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point::new(fields[0], fields[1], fields[2] as bool),\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"21":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    fn new(x: Field, y: Field, is_infinite: bool) -> Self {\n        Self { x, y, is_infinite }\n    }\n\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n// Scalar represented as low and high limbs\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    pub fn derive_public_key(self) -> EmbeddedCurvePoint {\n        let public_key = fixed_base_scalar_mul(self.lo, self.hi);\n        EmbeddedCurvePoint { x: public_key[0], y: public_key[1], is_infinite: false }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, key: EmbeddedCurveScalar) -> bool {\n        (key.hi == self.hi) & (key.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n#[foreign(multi_scalar_mul)]\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> [Field; 3]\n// docs:end:multi_scalar_mul\n{}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(\n    scalar_low: Field,\n    scalar_high: Field\n) -> [Field; 3]\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    let scalar = EmbeddedCurveScalar { lo: scalar_low, hi: scalar_high };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n"},"217":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"22":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"229":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"235":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<N> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<N> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<N> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<N> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"238":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"246":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: Field = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point {\n            x: 0,\n            y: 0,\n            is_infinite: false\n        }\n    }\n}\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn pub_key_to_bytes(pk: Point) -> [u8; 64] {\n    assert(!pk.is_infinite, \"Point at infinity is not a valid public key.\");\n    let mut result = [0 as u8; 64];\n    let x_bytes = pk.x.to_be_bytes(32);\n    let y_bytes = pk.y.to_be_bytes(32);\n    for i in 0..32 {\n        result[i] = x_bytes[i];\n        result[i + 32] = y_bytes[i];\n    }\n    result\n}\n"},"25":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n#[no_predicates]\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    let value = pedersen_commitment_with_separator(input, 0);\n    if (value.x == 0) & (value.y == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value.x, y: value.y, is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        points[i] = EmbeddedCurveScalar::from_field(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let values = multi_scalar_mul(generators, points);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: values[2] as bool }\n}\n\n#[no_predicates]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let v1 = pedersen_commitment_with_separator(input, separator);\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    multi_scalar_mul(\n        [length_generator[0], v1],\n        [EmbeddedCurveScalar { lo: N as Field, hi: 0 }, EmbeddedCurveScalar { lo: 1, hi: 0 }]\n    )[0]\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n#[test]\nfn assert_pedersen_noir() {\n    // TODO: make this a fuzzer test once fuzzer supports curve-specific blackbox functions.\n    let input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq(pedersen_hash_with_separator(input, 4), pedersen_hash_with_separator_noir(input, 4));\n    assert_eq(pedersen_commitment_with_separator(input, 4), pedersen_commitment_with_separator_noir(input, 4));\n}\n"},"273":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"32":{"path":"std/merkle.nr","source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n"},"330":{"path":"/usr/src/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Deserialize, Serialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n"},"344":{"path":"/usr/src/noir-projects/noir-contracts/contracts/delegated_on_contract/src/main.nr","source":"// A contract used along with `Parent` contract to test nested calls.\ncontract DelegatedOn {\n    use dep::aztec::prelude::{\n        AztecAddress, FunctionSelector, NoteHeader, NoteGetterOptions, NoteViewerOptions, PublicMutable,\n        PrivateSet, PrivateContext, Map\n    };\n    use dep::aztec::encrypted_logs::encrypted_note_emission::encode_and_encrypt_note;\n    use dep::value_note::value_note::ValueNote;\n\n    #[aztec(storage)]\n    struct Storage {\n        current_value: PublicMutable<Field>,\n        a_map_with_private_values: Map<AztecAddress, PrivateSet<ValueNote>>,\n    }\n\n    #[aztec(private)]\n    fn private_set_value(new_value: Field, owner: AztecAddress) -> Field {\n        let header = context.get_header();\n        let owner_npk_m_hash = header.get_npk_m_hash(&mut context, owner);\n\n        let mut note = ValueNote::new(new_value, owner_npk_m_hash);\n        storage.a_map_with_private_values.at(owner).insert(&mut note).emit(encode_and_encrypt_note(&mut context, context.msg_sender(), owner));\n        new_value\n    }\n\n    #[aztec(public)]\n    fn public_set_value(new_value: Field) -> Field {\n        storage.current_value.write(new_value);\n        new_value\n    }\n\n    #[aztec(private)]\n    fn get_private_value(amount: Field, owner: AztecAddress) -> pub Field {\n        let mut options = NoteGetterOptions::new();\n        options = options.select(ValueNote::properties().value, amount, Option::none()).set_limit(1);\n        let notes = storage.a_map_with_private_values.at(owner).get_notes(options);\n        notes.get_unchecked(0).value\n    }\n\n    unconstrained fn view_public_value() -> pub Field {\n        storage.current_value.read()\n    }\n}\n\n"},"38":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"4":{"path":"std/cmp.nr","source":"// docs:start:eq-trait\ntrait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\nimpl Eq for Field { fn eq(self, other: Field) -> bool { self == other } }\n\nimpl Eq for u64 { fn eq(self, other: u64) -> bool { self == other } }\nimpl Eq for u32 { fn eq(self, other: u32) -> bool { self == other } }\nimpl Eq for u8 { fn eq(self, other: u8) -> bool { self == other } }\nimpl Eq for u1 { fn eq(self, other: u1) -> bool { self == other } }\n\nimpl Eq for i8 { fn eq(self, other: i8) -> bool { self == other } }\nimpl Eq for i32 { fn eq(self, other: i32) -> bool { self == other } }\nimpl Eq for i64 { fn eq(self, other: i64) -> bool { self == other } }\n\nimpl Eq for () { fn eq(_self: Self, _other: ()) -> bool { true } }\nimpl Eq for bool { fn eq(self, other: bool) -> bool { self == other } }\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3) & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\nstruct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n// docs:start:ord-trait\ntrait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"47":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"5":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\nstruct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len);\n        self.get_unchecked(index)\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Responds with undefined data for `index` where `self.len < index < self.max_len()`.\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Does not check whether the passed `index` is a valid index within the vector.\n    ///\n    /// Silently writes past the end of the vector for `index` where `self.len < index < self.max_len()`\n    /// Panics if the given index points beyond the maximum length of the vector (`self.max_len()`).\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        \n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen>  {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n    // TODO: Allow imports from \"super\"\n    use crate::collections::bounded_vec::BoundedVec;\n\n    #[test]\n    fn empty_equality() {\n        let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n        let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n        assert_eq(bounded_vec1, bounded_vec2);\n    }\n\n    #[test]\n    fn inequality() {\n        let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n        let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n        bounded_vec1.push(1);\n        bounded_vec2.push(2);\n\n        assert(bounded_vec1 != bounded_vec2);\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n}\n"},"64":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::{Point, pub_key_to_bytes},\n    utils::arr_copy_slice\n};\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret_fields = multi_scalar_mul([point], [secret]);\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/6061): make the func return Point struct directly\n    let shared_secret = pub_key_to_bytes(Point::new(shared_secret_fields[0], shared_secret_fields[1], false));\n    let mut shared_secret_bytes_with_separator = [0 as u8; 65];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[64] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nfn check_point_to_symmetric_key() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar::new(\n        0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    );\n    let point = Point::new(\n        0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        false\n    );\n\n    let key = point_to_symmetric_key(secret, point);\n    // The following value gets updated when running encrypt_buffer.test.ts with AZTEC_GENERATE_TEST_DATA=1\n    let expected_key = [\n        49, 167, 146, 222, 151, 129, 138, 184, 87, 210, 245, 249, 99, 100, 1, 59, 223, 180, 5, 99, 14, 7, 177, 236, 159, 203, 231, 72, 220, 180, 241, 23\n    ];\n    assert_eq(key, expected_key);\n}\n"},"65":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::PrivateContext,\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}},\n    state_vars::{shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter}\n};\n\nglobal DELAY = 5;\n\n// docs:start:key-getters\ntrait KeyGetters {\n  fn get_npk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ivpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ovpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_tpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_npk_m_hash(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Field;\n}\n\nimpl KeyGetters for Header {\n    fn get_npk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, NULLIFIER_INDEX, self)\n    }\n\n    fn get_ivpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, INCOMING_INDEX, self)\n    }\n\n    fn get_ovpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, OUTGOING_INDEX, self)\n    }\n\n    fn get_tpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, TAGGING_INDEX, self)\n    }\n\n    fn get_npk_m_hash(self, context: &mut PrivateContext, address: AztecAddress) -> Field {\n        get_master_key(context, address, NULLIFIER_INDEX, self).hash()\n    }\n}\n// docs:end:key-getters\n\nfn get_master_key(\n    context: &mut PrivateContext,\n    address: AztecAddress,\n    key_index: Field,\n    header: Header\n) -> Point {\n    let key = fetch_key_from_registry(context, key_index, address, header);\n    if is_empty(key) {\n        // Keys were not registered in registry yet --> fetch key from PXE\n        let keys = fetch_and_constrain_keys(address);\n        // Return the corresponding to index\n        keys.get_key_by_index(key_index)\n    } else {\n        // Keys were registered --> return the key\n        key\n    }\n}\n\nfn fetch_key_from_registry(\n    context: &mut PrivateContext,\n    key_index: Field,\n    address: AztecAddress,\n    header: Header\n) -> Point {\n    let x_coordinate_map_slot = key_index * 2 + 1;\n    let y_coordinate_map_slot = x_coordinate_map_slot + 1;\n    let x_coordinate_derived_slot = derive_storage_slot_in_map(x_coordinate_map_slot, address);\n    let y_coordinate_derived_slot = derive_storage_slot_in_map(y_coordinate_map_slot, address);\n\n    let x_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        x_coordinate_derived_slot\n    );\n    let y_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        y_coordinate_derived_slot\n    );\n    let x_coordinate = x_coordinate_registry.get_value_in_private(header);\n    let y_coordinate = y_coordinate_registry.get_value_in_private(header);\n\n    Point::new(x_coordinate, y_coordinate, false)\n}\n\n// Passes only when keys were not rotated - is expected to be called only when keys were not registered yet\nfn fetch_and_constrain_keys(address: AztecAddress) -> PublicKeys {\n    let (public_keys, partial_address) = get_public_keys_and_partial_address(address);\n\n    let computed_address = AztecAddress::compute(public_keys.hash(), partial_address);\n\n    assert(computed_address.eq(address));\n\n    public_keys\n}\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n"},"66":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr","source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH, hash::poseidon2_hash,\n    point::Point, traits::{Deserialize, Serialize, Empty, is_empty}\n};\nuse crate::keys::constants::{NUM_KEY_TYPES, NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX};\n\nglobal PUBLIC_KEYS_LENGTH = 12;\n\nstruct PublicKeys {\n    npk_m: Point,\n    ivpk_m: Point,\n    ovpk_m: Point,\n    tpk_m: Point,\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m : Point::empty(),\n            ivpk_m : Point::empty(),\n            ovpk_m : Point::empty(),\n            tpk_m : Point::empty()\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        ( self.npk_m == other.npk_m ) &\n        ( self.ivpk_m == other.ivpk_m ) &\n        ( self.ovpk_m == other.ovpk_m ) &\n        ( self.tpk_m == other.tpk_m )\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash(\n                [\n                self.npk_m.x,\n                self.npk_m.y,\n                self.npk_m.is_infinite as Field,\n                self.ivpk_m.x,\n                self.ivpk_m.y,\n                self.ivpk_m.is_infinite as Field,\n                self.ovpk_m.x,\n                self.ovpk_m.y,\n                self.ovpk_m.is_infinite as Field,\n                self.tpk_m.x,\n                self.tpk_m.y,\n                self.tpk_m.is_infinite as Field,\n                GENERATOR_INDEX__PUBLIC_KEYS_HASH\n            ]\n            )\n        }\n        )\n    }\n\n    pub fn get_key_by_index(self, index: Field) -> Point {\n        assert(index as u8 < NUM_KEY_TYPES, \"Invalid key index\");\n        if index == NULLIFIER_INDEX {\n            self.npk_m\n        } else if index == INCOMING_INDEX {\n            self.ivpk_m\n        } else if index == OUTGOING_INDEX {\n            self.ovpk_m\n        } else {\n            self.tpk_m\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.x,\n            self.npk_m.y,\n            self.npk_m.is_infinite as Field,\n            self.ivpk_m.x,\n            self.ivpk_m.y,\n            self.ivpk_m.is_infinite as Field,\n            self.ovpk_m.x,\n            self.ovpk_m.y,\n            self.ovpk_m.is_infinite as Field,\n            self.tpk_m.x,\n            self.tpk_m.y,\n            self.tpk_m.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: Point::new(serialized[0], serialized[1], serialized[2] as bool),\n            ivpk_m: Point::new(serialized[3], serialized[4], serialized[5] as bool),\n            ovpk_m: Point::new(serialized[6], serialized[7], serialized[8] as bool),\n            tpk_m: Point::new(serialized[9], serialized[10], serialized[11] as bool)\n        }\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: Point { x: 1, y: 2, is_infinite: false },\n        ivpk_m: Point { x: 3, y: 4, is_infinite: false },\n        ovpk_m: Point { x: 5, y: 6, is_infinite: false },\n        tpk_m: Point { x: 7, y: 8, is_infinite: false }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x146f68c0e0ba4067d61a3304bbfdec0797d5df1357db6c01247c48bfb345c7d7;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nfn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nfn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: Point { x: 1, y: 2, is_infinite: false },\n        ivpk_m: Point { x: 3, y: 4, is_infinite: false },\n        ovpk_m: Point { x: 5, y: 6, is_infinite: false },\n        tpk_m: Point { x: 7, y: 8, is_infinite: false }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.x, deserialized.npk_m.x);\n    assert_eq(keys.npk_m.y, deserialized.npk_m.y);\n    assert_eq(keys.ivpk_m.x, deserialized.ivpk_m.x);\n    assert_eq(keys.ivpk_m.y, deserialized.ivpk_m.y);\n    assert_eq(keys.ovpk_m.x, deserialized.ovpk_m.x);\n    assert_eq(keys.ovpk_m.y, deserialized.ovpk_m.y);\n    assert_eq(keys.tpk_m.x, deserialized.tpk_m.x);\n    assert_eq(keys.tpk_m.y, deserialized.tpk_m.y);\n}\n"},"80":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n"},"88":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::storage::{raw_storage_read, storage_read};\n\nstruct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = block_number_oracle();\n        let contract_address = contract_address_oracle();\n        let chain_id = chain_id_oracle();\n        let version = version_oracle();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<N>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n\n#[oracle(getContractAddress)]\nunconstrained fn contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn version_oracle() -> Field {}\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"95":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn block_number(self) -> Field {\n        block_number()\n    }\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<N>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<N>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, N>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N)\n}\n\nunconstrained fn storage_write<N>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<N>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<N>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}